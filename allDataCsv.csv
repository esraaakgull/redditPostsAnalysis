168jxwq,,"But the thing is, we have a PHP setup where data is grabbed from the client passed to the server.",0.0,PHP
168jxwq,,The PHP runs some SQL and passes a result back to the client.,0.0,PHP
168jxwq,jyw8bax,I suggest taking this to a PHP forum.,0.0,PHP
168jxwq,jyw8bax,There's probably an idiomatic way to do this in PHP that would be quite easy to use.,0.43333333333333335,PHP
1686ysr,jyv6bdb,Python's first official async implementation was all generators before it was given official syntax.,0.25,Python
1686ysr,jyvzcvf,"This is exactly equivalent to python's generators, using `def __call__(self, x=None): return self.send(x)` (Python doesn't need both `.send` and `.__next__` calls).",0.25,Python
167oefv,jyu88je,I think Forth.,0.0,Forth
167oefv,jyva39m,Assembly.,0.0,Assembly
167oefv,jyva39m,> java  Java does not let you do any of that.,0.0,Java
167oefv,jyva39m,Especially since everything in Lisp is an AST.,0.0,Lisp
167oefv,jyva39m,"(defn foo []         (println ""h""))     (defn main []         (do             (set-instr ""Ü"" (get-child 1 (get-child 1 foo)))             (foo))) ;prints funny German face     ;some Lisp I wrote one day  Also there are people who just invoke (if not embed) GCC in their programme and use it in JIT mode to modify things.",0.13888888888888887,Lisp
167oefv,jywr5qj,Lisp and assembly.,0.0,Lisp
167oefv,jywr5qj,Assembly lets you do anything the CPU allows.,0.0,Assembly
167oefv,jywr5qj,"On Lisp, you have hygienic macros.",0.0,Lisp
167oefv,jywr5qj,And domain-specific languages are normal in the Lisp world.,0.15,Lisp
167oefv,jyx8zi1,Lisp is one of the more moddable.,0.5,Lisp
167oefv,jyx8zi1,This carries over to Common Lisp.,-0.3,Lisp
167oefv,jyx8zi1,"This goes back to the mid 60s  * by default Common Lisp has a source interpreter and/or incremental compiler via the functions EVAL and COMPILE  * by default Common Lisp can load code at runtime via the function LOAD  * CLOS (the Common Lisp Object System) comes with open classes, before/after/around extensions, changeable class hierarchies, and on optional meta-object protocol to change the OOP implementation itself  It's not uncommon that a Common Lisp program might be compiled once for end users, delivered to the end user and then get tiny little loadable patches, which change/add/replace functionality of a running program.",-0.17875,Lisp
167oefv,jyx8zi1,"Let's check an example in CLOS, the Common Lisp Object System.",-0.3,Lisp
167oefv,jyxwznn,C# has very good modding tools and a lot of communities for modding games,0.9099999999999999,C
167oefv,jyu6zdj,"Lisp and various derivatives, definitely.",0.0,Lisp
167oefv,jyu6zdj,"Perl, because running and doing flips with your eyes closed while juggling multiple pairs of scissors is fun for the whole family.",0.1,Perl
167oefv,jyu6zdj,Ruby is another one to put on the list.,0.0,Ruby
167oefv,jyu6zdj,A lot of Ruby libs (like Rails) are based on the concept.,0.0,Ruby
167oefv,jyu6zdj,"Python, to some extent.",0.0,Python
167zsiv,,"def call_function(args:, globals:)       new_context = Dictionary.new(globals[:context].raw.dup)  where I used to do      def call_function(args:, globals:)       new_context = globals[:context].dup  And even before that I used to do      def call_function(args:, globals:)       new_context = globals[:context].deep_dup  My language is implemented in Ruby and the context is a Code::Object::Dictionary  Any help?",0.5,Ruby
167vd73,,Does such tool exist for C?,0.0,C
167vd73,jyszytw,"My favorite is [Lemon](https://compiler-dept.github.io/lemon/), which is very user friendly, generates good clean C code, and acknowledges modern concerns like threading (versus `yacc`).",0.3902777777777778,C
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,Go
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,Rust
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,Kotlin
166rij5,jynj02a,I'm implementing this in Rust.,0.0,Rust
166rij5,jymmzcj,"My toy* language:  * compiles to C  * based off C with modern features and tooling  * methods, generics, algebraic types, first class functions,    iterators, traits, built in strings  * null safety and intuitive error handling based off rust (Option, Result, ?",0.225,C
166rij5,jymmzcj,"operator, etc)  * tunable GC system, might also implement smart pointers, raw pointers available  * cut out as much UB as possible  * easy c library imports and bindings  thats my main goal, I have other ideas I would like to implement like pattern matching, lambdas, and closures but I can do without plus the implementation to C might not be straight forward.",0.13231456043956044,C
166rij5,jymmzcj,"From my research, it seems C is a bad backend unless there is a very close relationship to C. Methods are fine, iterators I think I have figured out, generics would be the most difficult but doable.",-0.01666666666666663,C
166rij5,jymmzcj,If anyone has any experience with C as a backend or any input on some possible pitfalls Id really like to hear.,0.1,C
166rij5,jymmzcj,One reason I want to compile to C is for easy bindings and to easily get the language from working to usable.,0.43333333333333335,C
166rij5,jyn42bu,"The C way is to just leave it to the user: a memory allocation IS a value in the form of a pointer, and you're responsible for fulfilling the promise of freeing it at some point.",0.2,C
166rij5,jyn42bu,"Python has the ""with"" clause which is nice but doesn't allow for interleaving things (A was created before B but we'd like to free it first) or returning the resource from a function or something.",0.4166666666666667,Python
166rij5,jylrwqk,A C compiler.,0.0,C
166rij5,jylrwqk,"I know, boring, but implementing it really made me appreciate compiler developers and I am learning a lot more about C, Rust (the language I am building it in) and low level programming.",-0.07500000000000001,C
166rij5,jylrwqk,"I know, boring, but implementing it really made me appreciate compiler developers and I am learning a lot more about C, Rust (the language I am building it in) and low level programming.",-0.07500000000000001,Rust
166f9gj,jyjdm4r,"* It had lvalue vs rvalue distinction * Conditional expressions `true -> E2, E3` means E2, `false -> E2, E3` means E3 * `E0 rep n` means E0 repeated n times `E0, E0, ... E0` * If Commands (but without else branch): `if E do C`, `unless E do C` * Test Commands: (just like if-then-else) `test E then C or C`, `test E ifso C ifnot C` * It already had a number of undefined behaviours * Let declarations: `let may be used to declare a set of mutually recursive functions and routines` * `There is no need for type declarations in the language, since the type of every variable is already known`",-0.26666666666666666,C
166er7n,,"So there's precondition/postcondition system like in Ada to help, and I guess you can also use proofs to ensure some specific operations can preserve good shape.",0.35,Ada
166er7n,jyjhs0g,"Side note: Common Lisp has these, and they are used in practice by some programmers.",-0.3,Lisp
166er7n,jyjxu27,My first introduction to such a system was [Clojure spec](https://clojure.org/guides/spec).,0.125,Clojure
166er7n,jyjxu27,"While it is very powerful, it: 1. checks entirely at runtime 2. is not Clojure's primary type system  IMO the best way to use it is to enable checking at dev / testing time, and then only enable checking the inputs / outputs of the system (eg HTTP request / response JSON) at runtime (which you are probably already doing).",0.358,Clojure
166er7n,jyjxu27,"IMO if a serious language was to be made employing predicates as the primary typing mechanism, it should: 1. check as much statically as possible, and assert the rest at runtime (java does this for array bounds checking for example, unlike dependently typed languages that can check bounds at compile time) 2. have a good polymorphism story (Clojure has Java classes + interfaces and its own types, records, protocols, multimethods, etc.)",0.2611111111111111,Clojure
166er7n,jyjxu27,"IMO if a serious language was to be made employing predicates as the primary typing mechanism, it should: 1. check as much statically as possible, and assert the rest at runtime (java does this for array bounds checking for example, unlike dependently typed languages that can check bounds at compile time) 2. have a good polymorphism story (Clojure has Java classes + interfaces and its own types, records, protocols, multimethods, etc.)",0.2611111111111111,Java
166er7n,jyp3hgd,"So... hum... a decade or so ago, [Rust had Typestate](https://stackoverflow.com/a/10319250/147192) which was specifically about ""tagging"" types with predicates.",0.0,Rust
166er7n,jyq1qvq,Interesting that you mention Ada.,0.5,Ada
166er7n,jyq1qvq,I think the Spark Ada version can do what you want since the proofs are part of the source code.,0.0,Ada
166er7n,jys75o8,"See: https://simon.peytonjones.org/verse-calculus/  SPJ is a major creator of GHC (Haskell), seems he hit major limitations with ""functional"" paradigm by Haskell, and going ""functional-logic"" by Verse.",0.0625,Haskell
166er7n,jyjmwiz,and Flux which adds liquid types to Rust \[[video](https://www.youtube.com/watch?v=k-izcFCHN2o)\],0.0,Rust
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,C++
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,C
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Java
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Rust
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Scala
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Swift
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,TypeScript
166er7n,jyku6r2,Rust is a great example.,0.8,Rust
166er7n,jykuruc,"look at C++ polymorphism, you CAN do anything with it, but mostly people do pretty standard things that work well and quickly.",0.2708333333333333,C++
1660uus,jyjatia,I'm not asking about the union type (I'm aware of that from Haskell).,0.25,Haskell
1660uus,jyj60fk,"I made a mistake, because I have been writing C all day.",0.0,C
1660uus,jyj60fk,"Contrast this with ignoring that you don't understand how even C can infer the type of a division result, and lashing out at people.",0.0,C
165w7sp,,"While there may be a unique smallest set of values that describes the type of a term, TypeScript lets you do things like union arbitrary types, define types containing literal values, and use [conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) (which essentially lets you check if a type is a subset of another type), which makes them feel much more like sets than type theory's types.",0.19375,TypeScript
165w7sp,jygn361,"But, TypeScript is not type theory either way and you shouldn’t expect it to have much to do with type theory.",0.2,TypeScript
165w7sp,jygn361,"It’s pretty easy to make TypeScript accept an ill-typed program, even without using “obviously” unsound features like casts or `any`.",0.22777777777777777,TypeScript
165w7sp,jygi530,"TypeScript's types are not sets of values, because the type of an expression depends more on its provenance than its actual shape (especially because TypeScript is highly unsound).",0.165,TypeScript
165w7sp,jygi530,"TypeScript's type language does have set-like operators like union and intersection, but that doesn't make them sets.",0.0,TypeScript
165w7sp,jygi530,"TypeScript has subtyping and uses it generously, which is part of the reason why a single value can be given so many different types.",0.14285714285714288,TypeScript
165w7sp,jygi530,"----   Defining the language of ""types"" in TypeScript is actually pretty complicated, but for individual features, it's relatively straightforward:  TypeScript's rules type judgement rules include things that look like  * If you know that `e: A` and `e: B`, then you can conclude `e: A & B`  * If you know that `e: A & B`, then you can conclude `e: A` and `e: B`.",0.03125,TypeScript
165w7sp,jygsqyx,"Agree with u/benjaminhodgson: TypeScript is a tool, not a theory.",0.0,TypeScript
165w7sp,jygsqyx,"And yes, JavaScript has a strong type system, in the sense that you won't crash the browser.",0.4333333333333333,JavaScript
165w7sp,jyoe7ct,"Still, TypeScript treats types as a judgement, so it indeed works as a type theory.",0.0,TypeScript
165w7sp,jyjd5mu,"We're already working on various ways of incorporating more of the popular TS ""typeticool"" techniques, such as adding overloading (with some limitations), first-class polymorphism, and doing type inference for conditional types (which were already [described on a sound declarative system] (https://popl22.sigplan.org/details/POPL-2022-popl-research-papers/37/Type-Level-Programming-with-Match-Types) in Scala's match types ) into a sound type system with great type inference (MLscript, which is in very early development stages).",0.35375,Scala
165rh24,jyoxk6t,That's the behavior you would get from C:      #if FOO     int *a = bar();     #else     double a = bar();     #endif     if (false && a < 1.0) { ... },-0.20000000000000004,C
165ku1s,,"For example, in C++ you can say `const thread_local auto& x = ...`.",0.0,C++
165ku1s,jyfkfc3,"They are declared similar to C# (and other languages), with a type, then the name ``` MyClass a = MyClass.new() ``` But there are also modifiers that can be placed after the type and prefixing the name as so ``` str* fruits = [] int _privateItem ``` The asterisk after a type means it's a collection (list) and the underscore at the start of the name means that it is private.",-0.041666666666666664,C
165ku1s,jyhcwt4,"```let [variable] [type] = [value]```  In my language, types are prefixed with `:`, similar to symbols in Ruby:  E.g.",0.0,Ruby
165ku1s,jyidbba,"In Fortran: PROGRAM TEST IMPLICIT NONE INTEGER :: TESTINT INTEGER, PARAMETER :: CONSTINT And so on :)",0.5,Fortran
165ku1s,jymtzq2,"'=' Expr ```  ``` static: compile time evaluation, like zig comptime or nim static (usable as expression block as well as variable modifier) static var: C style static variable let: immutable var: mutable ```  Just using static is a shorthand for ``` pub?",0.5,C
165ku1s,jyp4gfn,"In my experience with dynamic languages like Python, I have found that it is _extremely_ rare to have bugs caused by assignment to variables that were intended to be immutable (apart from confusion caused by Python not having a separate syntax for declaring new variables).",0.14545454545454545,Python
165ku1s,jyfgew6,I prefer a minimal approach like in Go (the concise variable declaration i.e).,0.0,Go
165ku1s,jyfqz57,"Mine is somewhat influenced by Rust but does not use a `let` keyword          x = 42; // ""Simple variable""             // Single assignment with type inference.",-0.03571428571428571,Rust
165ku1s,jyeq6mr,C++ is a disaster.,0.0,C++
165ku1s,jyoa4ql,"In Scala, block is an expression - it can both declare local variables (or just have any declaration/statement in it), and yield a value:      val foo = {         val x = 42         val y = 1337         x * y     }  Similar is the `let ... in ...` expression in the ML family of languages.",0.0,Scala
165ku1s,jyoa4ql,"Also, IIRC, there is GCC-specific extension for C language.",0.0,C
165ku1s,jyh18w5,"It is not inferable, since without the keyword it would be inferred as static if in global/namespace scope or local (""automatic"" duration in C++ standardese) if in a function.",0.25,C++
165ku1s,jyh18w5,> does C++ not know how to infer addresses?,0.0,C++
165ku1s,jyiho9t,C++ was designed by a committee a long time ago and we have learned a great deal about OOLs since then.,0.375,C++
165ku1s,jyiho9t,"Of course, much of that learning was because of C++.",0.2,C++
165ku1s,jyguqfl,It’s kinda like how Rust works - it’s just that there’s no `let` keyword and type inference is represented using the Almighty Walrus `:=`.,0.0,Rust
165ku1s,jyk5jev,It's kinda like Haskell's `>>=` operator.,0.0,Haskell
165ku1s,jyiktf2,"The original commenter mentioned Rust as an inspiration, as an example they call it [""const eval""](https://doc.rust-lang.org/reference/const_eval.html) for anything that's calculated at compile time, not just individual variables (function calls, match expressions, etc.).",0.1875,Rust
165ku1s,jyiktf2,"Note that Rust's comptime evaluation is less powerful than Zig's but in the context of this conversation it's the same - an indication by the programmer that something **must** be done at compile time otherwise error, rather than leaving it up to the compiler to decide.",0.044444444444444446,Rust
165ku1s,jyo639w,It may be used similarly as `<-` notation from Haskell and Scala.,0.0,Haskell
165ku1s,jyo639w,It may be used similarly as `<-` notation from Haskell and Scala.,0.0,Scala
165ku1s,jyo639w,"Except this one is not tied to single interface/function: in Scala it's fixed to desugaring to`flatMap`,  and in Haskell to `bind`/`>>=`.",0.01428571428571429,Scala
165ku1s,jyo639w,"Except this one is not tied to single interface/function: in Scala it's fixed to desugaring to`flatMap`,  and in Haskell to `bind`/`>>=`.",0.01428571428571429,Haskell
165co33,jydbex4,"Fish is still updating itself to stay relevant in the modern age as well, with the current rewrite from C++ to Rust and the planned future upgrades for migrating from `wchar_t` to UTF-8 and incorporating more concurrency.",0.22000000000000003,C++
165co33,jydbex4,"Fish is still updating itself to stay relevant in the modern age as well, with the current rewrite from C++ to Rust and the planned future upgrades for migrating from `wchar_t` to UTF-8 and incorporating more concurrency.",0.22000000000000003,Rust
165co33,jydhtnk,"The main reason I didn't like nu, and some other utilities shell utilities written in Rust is the ""fancy"" graphics.",0.02083333333333333,Rust
165co33,jygwzb0,"It also helps that learning Bash makes it easy to pick up Zsh, Tsh, Csh, Ash, etc.",0.43333333333333335,Bash
165co33,jyf8is4,"Perl has a lot of these little offbeat things, and it very much appealed to my eclectic sensibilities as a kid.",-0.1425,Perl
165co33,jyf8is4,"For example, consider another Bash-ism: in `case`, patterns can be set off from blocks by a right parenthesis—this means you can’t naïvely scan Bash source under the assumption of balanced brackets.",0.2857142857142857,Bash
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Python
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,C++
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Rust
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Lisp
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Forth
165co33,jyme2ye,Ruby too I guess.,0.0,Ruby
1654vrs,,"My schools' class forces the use of Java programming language, and I absolutely hated it.",-0.9,Java
1654vrs,,"So, over the course of a little less than a month, I wrote my own programming language, in Rust (objectively best programming language), using [pest](https://pest.rs), to be as similar to Rust as possible, but compiling to Java.",0.2076388888888889,Rust
1654vrs,,"So, over the course of a little less than a month, I wrote my own programming language, in Rust (objectively best programming language), using [pest](https://pest.rs), to be as similar to Rust as possible, but compiling to Java.",0.2076388888888889,Java
1654vrs,,"- Enums use classes instead of the builtin `enum` thing in Java, I just didn't feel like using them - Some generated builtins, (i.e.",0.0,Java
1654vrs,jygzfgl,"It's a sledgehammer to crack a nut, you could just ... write Java?",0.0,Java
1654vrs,jyfseyo,Had to make a 2nd comment because I missed this in my first read-through.`Rust (objectively best programming language)`  That's a big statement.,0.3125,Rust
1654vrs,jygm4ki,He’s likely unaware of languages that are better in each of the domains Rust is strong in.,0.23333333333333334,Rust
1654vrs,jygkvj1,"Rust is the best programming language because of its focus on 100% memory safety, 0-cost abstractions, ownership and borrowing...",1.0,Rust
1654vrs,jypmhb9,Borrowing and ownership in Rust are actually just compiler-level constructs; they don't exist after the code is compiled.,0.0,Rust
1654vrs,jypmhb9,"Something similar to async/await is in the works for a future version of Java, but at the moment it's not easy to translate directly to Java without a lot of legwork.",-0.029166666666666667,Java
1654vrs,jypmhb9,You could look at how Kotlin does it.,0.0,Kotlin
1654vrs,jygpqel,"C++ has some memory safety, but it's super complicated.",-0.08333333333333334,C++
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,C++
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,Python
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,Java
1654vrs,jyh716h,and I still think that Rust is by far the best language for the majority of use cases.,0.55,Rust
1654vrs,jygz2vs,"\> Rust is the best programming language because of its focus on 100% memory safety, 0-cost abstractions, ownership and borrowing...",1.0,Rust
1654vrs,jyd9vbl,What parts of Rust does Jasmine handle?,0.0,Rust
1654vrs,jyn4vwv,"Thank you, this helps me understand how people use Rust for implementing programming languages.",0.0,Rust
1654vrs,jyqsuwo,Go is better for a few things even if Rust might be slightly faster runtime.,0.044444444444444446,Go
1654vrs,jyqsuwo,Go is better for a few things even if Rust might be slightly faster runtime.,0.044444444444444446,Rust
1654vrs,jyqsuwo,"For learning/onboarding, Go is by far.. exponentially better than anything out there.",0.3,Go
1654vrs,jyqsuwo,"I'd use Rust or my new fav, Zig, for anything else.",0.13636363636363635,Rust
1654vrs,jyqxfn5,"If you like Go, you're going to love [IntercalScript](https://github.com/Storyyeller/IntercalScript).",0.5,Go
1654vrs,jyqxfn5,"The problem with Go is that it achieves ""simplicity"" by deferring all the work from the compiler to the human and forcing them to write low level repetitive code by hand.",-0.08333333333333333,Go
1654vrs,jyqxfn5,"Also, while Go may be ""simple"", it still has a lot of unforced design errors and dumb gotchas and the like.",-0.1875,Go
1654vrs,jygl63m,"If, in writing code, I made a borrow, there would be no way for me to translate that into Java code.",0.0,Java
1654vrs,jyglr7n,I think you’re missing the point…  It will run in Java with GC.,-0.2,Java
164ox4k,jyc9m4z,Python has [xeger](https://pypi.org/project/rstr/) but being able to reverse a whole grammar would be very convenient too.,0.3,Python
164k73n,jy96lkk,"When Spring (Java) was XML based, all your config was in one spot, now with annotations/decorators, it's all over the codebase.",0.0,Java
164k73n,jyckftc,"Python needs decorator syntax, because `def` is a statement instead of an expression there, so higher-order functions those wrapping other function definitions somehow, have to be called with special syntax.",0.11607142857142858,Python
164k73n,jyckftc,"In my PL `$` is a low-precedence, right-associative, infix operator, works like that in Haskell, i.e.",0.0,Haskell
164k73n,jyckftc,"`(***apk)` there is roughly `(*args, **kwargs)` as in Python.",-0.1,Python
164k73n,jycedsv,"In Java, they're called annotations.",0.0,Java
164k73n,jycvw4u,But if it is actually a tag that you can check if it is in certain object and with that generate code from a function that you wrote (not the compiler for you) then is ok. Basically Java tags,0.2380952380952381,Java
163g4nf,,"Hi everyone,  So I am writing a nil-checker (my keyword is called nil, but its the same as C++'s null).",0.0,C++
163g4nf,jy44k68,"Xcode's is SLOOWWW.... taking minutes on only 500k of C++... mine will run in 0.01 second, and also make the language neater to write.",0.0,C++
162drv9,,I believe Rust has something similar with `std::option` and match statements.,0.0,Rust
162drv9,jxytgkf,[Scala Option](https://www.scala-lang.org/api/2.13.3/scala/Option.html),0.0,Scala
162drv9,jxzbsem,"I see two things here:  - First-class support for `null` is common in a few languages, including Ceylon with its [`if(exists)`](http://web.archive.org/web/20211129235401/https://ceylon-lang.org/documentation/1.3/tour/basics/#dealing_with_objects_that_aren_t_there), Zig with its [`orelse`](https://ziglang.org/documentation/master/#Optionals), or [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator) and [PHP](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce) with the `?",-0.25,C
162drv9,jxzbsem,"I see two things here:  - First-class support for `null` is common in a few languages, including Ceylon with its [`if(exists)`](http://web.archive.org/web/20211129235401/https://ceylon-lang.org/documentation/1.3/tour/basics/#dealing_with_objects_that_aren_t_there), Zig with its [`orelse`](https://ziglang.org/documentation/master/#Optionals), or [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator) and [PHP](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce) with the `?",-0.25,PHP
162drv9,jxzbsem,It is popular in several OOP languages like Kotlin or Ceylon as it allows to downcast class references.,0.3,Kotlin
162drv9,jxzbsem,"TypeScript is similarly notable for encoding ECMAScript's many dynamic type checks in a static, AOT-checked, type system using [a range of narrowing checks](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) including `x instanceof y`, `""x"" in y` and `x.hasOwnProperty(y)` among others.",0.375,TypeScript
162drv9,jxzrdf1,"If used where a block is expected, Raku groups and binds arguments on the left of the `->` to parameters on the right, and calls the lambda/block as many times as appropriate:      for 4, 3, 2, 1 -> a, b { print a } # 42  ⁴ You have to write more verbose syntax if you want to deal with ""some"" or ""none"" tags of optionals:      Int:D  # `:D` is a ""type smiley"".",0.38367346938775515,D
162drv9,jxzrdf1,`Int:D` means some `Int`.,0.0,D
162drv9,jxzhanh,"So some of what you're thinking about overlaps with [Void Safety](https://www.eiffel.org/doc/eiffel/Void-safety-_Background%2C_definition%2C_and_tools)  Eiffel has the following, which might be of interest:  ```eiffel if attached x as l_x then   l_x.f (a) end ``` Kind regards, M ✌",0.3,Eiffel
162clva,jxxa19u,"(3) ""C"" switch-case or similar Pascal case-of instructions can sometimes be replaced into a small array of instructions.",-0.125,C
162clva,jxxa19u,"(3) ""C"" switch-case or similar Pascal case-of instructions can sometimes be replaced into a small array of instructions.",-0.125,Pascal
162clva,jxxt1gb,"Maybe you will find [A deep dive into dispatching techniques - Jonathan Müller - Meeting C++ 2022](https://youtu.be/P4BUvMmdTMU?si=VXcgAIPgsrs646lT) interesting, and/ or [Building the fastest Lua interpreter..",0.25,C++
162clva,jxxt1gb,"Maybe you will find [A deep dive into dispatching techniques - Jonathan Müller - Meeting C++ 2022](https://youtu.be/P4BUvMmdTMU?si=VXcgAIPgsrs646lT) interesting, and/ or [Building the fastest Lua interpreter..",0.25,Lua
162clva,jxxt1gb,Lua is considered to be fast and somewhere on Reddit Lua's author discussed tricks he used unfortunately I can't find it right now.,-0.004761904761904763,Lua
162clva,jxxt1gb,Edit: found the [Lua stuff](https://www.reddit.com/r/programming/comments/badl2/luajit_2_beta_3_is_out_support_both_x32_x64/c0lrus0/),0.0,Lua
162clva,jxxel81,This lets me push common routines into the C++ code instead of having it in the scripting language.,-0.3,C++
162clva,jxxel81,I’m writing in C++ and not making any use of inline assembly at the moment.,0.0,C++
162clva,jxxbuvs,Our other languages would be C++ or Python.,-0.125,C++
162clva,jxxbuvs,Our other languages would be C++ or Python.,-0.125,Python
162clva,jxxbuvs,"C++ destroys my language for performance, up to 100x faster.",0.0,C++
162clva,jxxbuvs,Python is 5-10x slower.,0.0,Python
162clva,jxxbuvs,The C++ code is very difficult to write in comparison to my DSL or else it would be the obvious answer.,-0.325,C++
162clva,jxxbuvs,Comparable C++ is hundreds of lines long and considerably harder to debug.,-0.07500000000000001,C++
162clva,jxxbuvs,The Python code solves some of that.,0.0,Python
162clva,jxxbuvs,"It is easier to write than the C++, but still more difficult than the DSL.",0.0,C++
162clva,jxy53us,"I've recently picked up the Lua code and started reading over it to find things they have done, but it's a bit of searching for a needle in a haystack.",0.0,Lua
162clva,jxxvulf,"(For example, it could be using more memory compared with the C++ solution.)",0.5,C++
162clva,jxynzhz,"All of the loading of the data is handled in C++, completely outside of the script itself (IOW, the script doesn’t contain any code to open a file or read from it).",0.0,C++
162clva,jxynzhz,We have some very robust C++ libraries to handle this.,0.2,C++
162clva,jxynzhz,"C++ destroys all of the above, including my scripts.",0.0,C++
162clva,jxynzhz,"A script is almost surely using more memory compared to a comparable program in C++, although there are some tricks I use in the VM that shrink usage compared to naïve C++.",0.5,C++
162clva,jxwvs2o,"Now because of my host language being Python the only *practical* gains right now come from when native code drops the GIL, but *in theory* this lets me work out the details of message-passing concurrency in a safe and productive environment.",0.2619047619047619,Python
162clva,jxzej11,You said elsewhere Python (I assume CPython) was 5-10 times slower; that was running the data application?,0.0,Python
162clva,jxzej11,">C++ destroys all of the above, including my scripts.",0.0,C++
162clva,jxzej11,C++ will destroy most of those others too.,0.15,C++
162clva,jxzej11,"You should expect interpreted code, that does not have a sophisticated JIT, to be at least a magnitude slower than C++ on pure computation.",0.13809523809523808,C++
162clva,jxzej11,"Python and Lua have dynamic typing, yours has too, but it's not clear how much type checking is left out.",0.0375,Python
162clva,jxzej11,"Python and Lua have dynamic typing, yours has too, but it's not clear how much type checking is left out.",0.0375,Lua
162clva,jxzej11,"If C++ is currently 100x faster, then it will still be at least 10x faster even if you did manage it.",-0.15,C++
162clva,jxzej11,"Maybe consider a hybrid approach: use the scripting language to orchestrate the task, but use special C++ functions to do the bulk of the real work.",0.2785714285714286,C++
162clva,jxzej11,"With more realistic programs than simple benchmarks, my dynamic language works briskly compared to CPython and Lua, not using the ASM accelerator.",0.16666666666666666,Lua
162clva,jxzej11,"The figure used to compare is throughput in lines per second; bigger is better:                      M lps     Lua 5.4         0.06 to 1.0   (2 Lua versions)     CPython 3.11    0.1  to 0.2   (Several versions)     Q               0.5           (My dynamic language)     Q/ASM           1.2          PyPy            0.7  to 1.4   (Several versions)     LuaJIT          1.1  to 1.7   (2 version)     M              10.9           (My static language)     C (gcc-O3)     14.0           (Transpiled from M)  From PyPy downwards is either the result of tracing JIT, or is native code.",0.14285714285714285,Lua
162clva,jxzej11,"The figure used to compare is throughput in lines per second; bigger is better:                      M lps     Lua 5.4         0.06 to 1.0   (2 Lua versions)     CPython 3.11    0.1  to 0.2   (Several versions)     Q               0.5           (My dynamic language)     Q/ASM           1.2          PyPy            0.7  to 1.4   (Several versions)     LuaJIT          1.1  to 1.7   (2 version)     M              10.9           (My static language)     C (gcc-O3)     14.0           (Transpiled from M)  From PyPy downwards is either the result of tracing JIT, or is native code.",0.14285714285714285,C
162clva,jxwzrrv,My host language is C++.,0.0,C++
162clva,jy00va2,> You said elsewhere Python (I assume CPython) was 5-10 times slower; that was running the data application?,0.0,Python
162clva,jy00va2,"I have a C++ library that loads the data for Python, but it is still substantially slower due to the way it has to work with Python.",-0.125,C++
162clva,jy00va2,"I have a C++ library that loads the data for Python, but it is still substantially slower due to the way it has to work with Python.",-0.125,Python
162clva,jy00va2,"Obviously I'll never get ""C++ fast"".",0.1,C++
162clva,jxy410w,"For the shorter job, you would have your answer before someone was able to finish a C++ version of the program.",0.5,C++
162c9z2,,Languages like C++ has implicit conversions.,0.0,C++
162c9z2,,"This is very close to (but not the same as, at least in C++) ""whenever type B can be used, type A can **also** be used"".",-0.033333333333333326,C++
162c9z2,,Languages like C++ does not **chain** implicit conversions.,0.0,C++
162c9z2,,This means A -> B and B -> C does not mean A -> C. 2.,0.15625,C
162c9z2,jxwsuva,"For any types `A`, `B`, `C`, if `A <: B` and `B <: C`, then `A <: C` and `i{A,C} = i{B,C} .",0.0,C
162c9z2,jxxdiu9,**  A common compiler like C will perform several implicit conversions.,-0.15,C
162c9z2,jxxdiu9,"Usually in C integers alike variables are converted into the specific integer byte, even if they where another 8, 16, 32 bits types and integer is 64 bits.",-0.125,C
162c9z2,jy89ain,"In my language Y, the only implicit conversions I'm allowing are the conversion between literals of basic type limited to not allow conversions that would lose information, which makes it so I don't have to write stuff like `1.0f` from C (I can just put a `1`), and a few conversions between sizes of basic types mainly for stuff like multiplying two 4-byte naturals and storing the result in another 4-byte natural, instead of an 8-byte one, which I think should be fine since it's less drastic than implicitly converting floats to integers or something like that.",0.027248677248677248,C
162c9z2,jyh1mwr,"For example, in Java, `int` is a subtype of `long` (per [JLS sec.",-0.07500000000000001,Java
162c9z2,jysoban,"Continuing with Java, `short` is a subtype of `int` and coercion takes place on the language-level (e.g., [JLS sec.",-0.05,Java
16225sf,jxz8chb,"That, or it's C, and it will overwrite memory or, worse, read out the user's password.",-0.4,C
16225sf,jxv7jei,"In the Erlang community, they have a motto, ""let it crash"".",0.0,Erlang
16225sf,jxwi2nv,"That's yet another thing one can accommodate in the type system - by using lifetimes, as featured by Rust, the bounds of a permission can be represented in the type system.",0.0,Rust
16225sf,jxznqne,"> That, or it's C, and it will overwrite memory or, worse, read out the user's password.",-0.4,C
16225sf,jxwhrsh,"- An effects system, such as Koka's algebraic effects or Haskell's monads, prevents access to systems without a direct chain of approval to the entry point; functions can no longer independently execute IO, including network access.",0.03333333333333333,Haskell
16225sf,jxzr1i1,"When writing this kind of code in C++, D or a similar language, I'd `debug assert(mid < len);`.",0.3,C++
16225sf,jxzr1i1,"When writing this kind of code in C++, D or a similar language, I'd `debug assert(mid < len);`.",0.3,D
16225sf,jxz22lf,Otherwise Python wouldn’t be as popular as it is.,0.6,Python
16225sf,jy0aus0,"No, Python has staying power but isn't really ""trending"" in the same way.",0.1,Python
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,Rust
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,Scala
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,Java
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,Python
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,JavaScript
1621mpb,,TLDR: Here's the repo - [https://github.com/liam-ilan/crumb](https://github.com/liam-ilan/crumb) :D  Hi all!,1.0,D
1621mpb,,"I started learning C this summer, and figured that the best way to learn would be to implement my own garbage-collected, dynamically typed, functional programming language in C ;D  The language utilizes a super terse syntax definition...",0.5458333333333334,C
1621mpb,,"I started learning C this summer, and figured that the best way to learn would be to implement my own garbage-collected, dynamically typed, functional programming language in C ;D  The language utilizes a super terse syntax definition...",0.5458333333333334,D
1621mpb,,"If you build anything cool with it, send it to the comments, it would be awesome to see what can be done with Crumb :D",0.7833333333333333,D
1621mpb,jxwv2l5,Have you considered something like Rust where the last statement in a block is the return value?,0.0,Rust
1621mpb,jxuwy6w,So you already knew some other language than C ?,-0.125,C
1621mpb,jxvzvia,"The source code for the Game of Life demo can be found here: [https://github.com/liam-ilan/crumb/blob/main/examples/game-of-life.crumb](https://github.com/liam-ilan/crumb/blob/main/examples/game-of-life.crumb) :D  Graphics are done just through print and escape codes... Every time I need to re-render, I just use the `\e[H` escape code to return to the top left of the terminal, and then print a string containing the rendered screen again...",0.07000000000000002,D
1621mpb,jxvzvia,"When it comes to matrices, it's just lists inside lists :D I have a render function that gets in a matrix, and returns the corresponding string to print :D  One of the nice things about Crumb is that lists are always pass-by-value, so it's harder to accidently mutate the matrix while you traverse it...  Crumb doesn't have any special graphics functions...",0.5714285714285714,D
1621mpb,jyn9uuw,it's very cool and reading through the source code as a C beginner myself it's really concise and well written in my opinion,0.27749999999999997,C
161zt0r,jxwc148,"I would also recommend checking out Lambda Prolog (There's a book Programming with Higher-Order logic), and some languages like Mercury and Curry.",0.0,Prolog
161xxel,jxuid3e,Pretty much the only reason C++ has `auto` is that it was an already reserved keyword from C that wasn't used very much.,0.1775,C++
161xxel,jxuid3e,Pretty much the only reason C++ has `auto` is that it was an already reserved keyword from C that wasn't used very much.,0.1775,C
161xxel,jxuubjk,"C++ also inherited it from D, which used it for two decades and was proposed for inclusion.",0.0,C++
161xxel,jxuubjk,"C++ also inherited it from D, which used it for two decades and was proposed for inclusion.",0.0,D
161xxel,jxuubjk,"`if constexpr` is another feature they took from D, but decided to invent a new keyword for and to make it worse.",-0.13181818181818183,D
161xxel,jxxzqlz,`var` in C#,0.0,C
161xxel,jxvlftx,How can D have used `auto` for two decades before C++ adopted the keyword for type inference if D has been around since 2001 and `auto` for that purpose came out with C++11?,0.0,D
161xxel,jxvlftx,How can D have used `auto` for two decades before C++ adopted the keyword for type inference if D has been around since 2001 and `auto` for that purpose came out with C++11?,0.0,C++
161xxel,jxy439q,"It isn't, and that's why I also dislike `var` in C#.",0.0,C
161xxel,jxy439q,"But I do like Rust's `let`, because it actually carries semantic meaning.",0.0,Rust
161xxel,jxvmnmm,It used it for one decade before C++.,0.0,C++
161xxel,jxy49md,It's not like C++ or C# can just flip their syntax on a whim,0.0,C++
161xxel,jxy49md,It's not like C++ or C# can just flip their syntax on a whim,0.0,C
161wg53,,Go back to 1 (repeat).,0.0,Go
161wg53,,"I know that Prolog is more like SLD Resolution and Horn clauses—I understand the difference, just trying to compare it to something.",0.5,Prolog
161ke75,,Here is a 469 line Forth compiler implemented in Forth:  https://github.com/kragen/stoneknifeforth/blob/master/tinyboot1.tbf1  Here is a 301 line BF interpreter implemented in BF:  https://github.com/canoon/bfbf/blob/master/bf.bf  (I actually don't know which  Scheme-in-Scheme is canonical.,0.0,Forth
161ke75,,"I guess you can argue a bit about this, because almost all of them will all have a garbage collector in C.   Here's a tiny one, but it's not implemented in itself: https://www.piumarta.com/software/lysp/  )  ---  I thought the answer might be C4: C in 4 Functions  https://github.com/rswier/c4  BUT there is no type checker.",0.0,C
161ke75,,"It is a bytecode interpreter for C, not a compiler.",0.0,C
161ke75,,Some variant of Pascal maybe?,0.0,Pascal
161ke75,jxsi44y,"Most likely Pascal, and in particular I'd look closely at the UCSD variant.",0.2222222222222222,Pascal
161ke75,jxsi44y,The compiler is itself written in UCSD Pascal.,0.0,Pascal
161ke75,jxsi5hz,I wouldn't be surprised if APL beats either of those.,0.1,APL
161ke75,jxum4v8,"On top of that there also are inline function definitions (more like Forth words than procedures really), with nesting and recursion.",0.39999999999999997,Forth
161ke75,jxud4wi,I'm working on something similar in TypeScript and I would like to compare (although it's a bunch of work TBH)  The type checker is 118 lines:  https://github.com/andrejbauer/plzoo/blob/master/src/minihaskell/type_check.ml  However I do think the parsing is the more annoying part.,-0.10000000000000002,TypeScript
161ke75,jxud4wi,I am not sure how close the mini Haskell syntax is to Haskell.,-0.25,Haskell
161ke75,jxss3k3,What's an example of an APL implemented in itself?,0.0,APL
161ke75,jxss3k3,I thought most of them were implemented in C or another low level language.,0.25,C
161ke75,jxswcj4,Co-dfns is a dialect of APL written in itself.,0.0,APL
161ke75,jxt4p0i,"A traditional Forth reader is pretty much trivial—grab a string of nonspace characters, check if they parse as a number, or refer to a defined name (“word”), and either compile or interpret the result according to the current mode.",0.1125,Forth
161ke75,jxt4p0i,"APL can express parsers very compactly for grammars that vectorise well, but ironically, APL itself is kind of hard to do that with.",0.16944444444444443,APL
161ke75,jxt9lwv,"As far as APL goes, Aaron Hsu wrote a parallel APL compiler ~~in 17 lines of APL~~ (*edit:* incorrect, see reply below), [which this sub discussed a few years ago](https://old.reddit.com/r/ProgrammingLanguages/comments/k258ez/a_gpucpu_hosted_compiler_written_in_17_lines_of/).",-0.03333333333333333,APL
161ke75,jxt9lwv,"But that does not include the APL run-time, which is still written in C/C++, so it feels like a bit of a cheat to call it a *complete* compiler (it's still really impressive)  EDIT: I just noticed you were also commenting in that discussion so let's just say I'm posting this for people reading along ;)",0.45,APL
16198e7,jxqlwi7,You may want to check out the stack-based Forth programming language.,0.0,Forth
16198e7,jxqlwi7,"Like your opcodes, Forth primitives get their arguments from the stack and return values to the stack.",0.0,Forth
16198e7,jxqlwi7,"For that reason, Forth provides several stack manipulation “words” like DUP, ROT, OVER, and PICK.",0.0,Forth
16198e7,jxrxax9,For example:      add      a b+c        # one value has been popped     neg      a b -c     push x   a b c x     pop x    a b  ETA: the idea for `(a - b)` came from Forth I think.,0.0,Forth
16198e7,jxs1vp0,"Forth or Factor will help you get real comfy with stack based programming, although it might be a hefty investment",0.2,Forth
16198e7,jxzc1vw,"Go ahead and add that link to your original post, if you can edit it.",0.375,Go
160m27p,jxnlwc5,* C was designed to write Unix in.,0.0,C
160m27p,jxnlwc5,* Lua was designed to meet the business needs of the Brazilian national electricity company.,0.0,Lua
160m27p,jxnlwc5,"* PHP, despite its flaws, succeeded because the author had something so definite in mind that he called his language **P**ersonal **H**ome **P**age.",0.0,PHP
160m27p,jxnlwc5,"* Go has been called ""a domain-specific language for writing servers"".",0.0,Go
160m27p,jxnlwc5,* Rust is a systems language.,0.0,Rust
160m27p,jxor3ml,And we'd still be using either Fortran or whatever came before it.,0.0,Fortran
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,C
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,C++
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,Java
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,Python
160m27p,jxp7vta,"It is far easier to make a new language to learn about this stuff than trying to target common languages like C and C++, C# etc...",-0.02121212121212121,C
160m27p,jxp7vta,"It is far easier to make a new language to learn about this stuff than trying to target common languages like C and C++, C# etc...",-0.02121212121212121,C++
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,C++
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,C
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,Python
160m27p,jxnil6p,"Not to mention some people just like to think different ways, and it's really hard to program with mutation if you're in Haskell or something.",-0.14583333333333334,Haskell
160m27p,jxnil6p,In the same vein it's hard to program functionally in C.,-0.14583333333333334,C
160m27p,jxpdgfl,Then you can switch to Rust like mode if you want that level of performance (technically better than Rust performance).,0.5,Rust
160hdhl,,"It's kind of like `lex` and `yacc`, but I think it's cleaner -- the library is written in C (ie.",0.6,C
160a70g,jxmqf23,"It was missing a lot of stuff, but it was actually usable, mostly because I could just throw actual C code in the middle of the program when there was something I couldn't do, with the help of some scripts I was also able to reference variables from zimbu itself.",0.13333333333333333,C
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,C
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,C++
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,Java
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,JavaScript
15zxwjj,jxkxgdr,"> Your store example uses two operands both using ptr %x, so the same rank for both, used to implement C code where LHS and RHS have different ranks.",-0.26666666666666666,C
15zxwjj,jxlg3uk,"The only language I can think of that combines this with parsing is Lua, pretty much every other language out there separates this into distinct phases.",0.125,Lua
15zobnr,,"Since I am using the Haskell recursion-schemes anyway, I am able to use either Cofree or a Functor product with Fix to inject extra information for every node.",0.25,Haskell
15zobnr,jxshcrd,"I can only speak about my C++ implementation, which basically had a struct called Node, and within it had a bunch of different structs like FunctionNode, ObjectNode, ListNode, ForLoopNode etc.",0.0,C++
15z5kwb,jxs5h7m,"For example, a type like Rust's Option<T> can itself be generalized as Result<T, ()>, meaning bool could be generalized as Result<(), ()>.",0.0,Rust
15z5kwb,jxgwpr1,"But if we compare this, for example, Rust code:  ``` fn main() {    let i: Option<()> = Some(());    i .map(|x| print!",0.20833333333333331,Rust
15z5kwb,jxgwpr1,"(""Nope"")); } ```  with this C++ code:  ``` auto i = true; i ?",0.35,C++
15z5kwb,jxgwpr1,"Rust chosen first approach, Argentum chosen second.",0.125,Rust
15z5kwb,jxtj23n,"No one prevents you from creating user-defined classes and go down the path of `result` analysis:  ``` class Result(R, E) {    ok = ?R;    err = ?E; } ```  Argentum on the other hand will go another way: passing error handlers as lambdas:  ``` fn parseInt(from String, onBadFormat(), onOverflow()) int {    ... ?",0.07314814814814814,R
15z5kwb,jxfoq1i,"In short, a lot of languages have the same capabilities (Rust and Haskell could trivially reproduce this) and decided not to do it.",0.0,Rust
15z5kwb,jxfoq1i,"In short, a lot of languages have the same capabilities (Rust and Haskell could trivially reproduce this) and decided not to do it.",0.0,Haskell
15z5kwb,jxfvg57,Also the `:` operator is called `fromMaybe` in Haskell.,0.0,Haskell
15z5kwb,jxfvg57,"In Rust, the `?` operator is `Option::map`, the `:` operator is `Option::or_else`, and the combination of the two is `Option::map_or_else`.",0.0,Rust
15z5kwb,jxg4lvw,"}  can be implemented in, say, Rust as:      fn to_message(number: Option<i32>) -> String {         number                 .map(|n| format!",0.0,Rust
15z5kwb,jxg4lvw,I should borrow Rust approach?,0.0,Rust
15y4cfv,jxbz3gu,Ruby also does this.,0.0,Ruby
15y4cfv,jxc09du,"I do quite close to this for `{ }`, with the exception of the semicolon (It's basically `begin` from Scheme with an alternative syntax).",0.0,Scheme
15y4cfv,jxdfsk5,"The C [comma operator](https://en.wikipedia.org/wiki/Comma_operator) is similar to this: evaluate from left to right, discard each result except the last.",0.07142857142857142,C
15y4cfv,jxew9t3,See Python.,0.0,Python
15xqv3w,jxcx0sb,"So, I think adding optional freedom would nice (like Rust's unsafe keyword but using types).",0.6,Rust
15xqv3w,jxdo2um,"So far, nothing out of the ordinary - Scheme behaves this way.",-0.075,Scheme
15xmg2b,jx79jpn,"Throw some Guile and Python in, source in both Java and C. Would be fun.",0.3,Python
15xmg2b,jx79jpn,"Throw some Guile and Python in, source in both Java and C. Would be fun.",0.3,Java
15xgt8b,,• adores its shared mutable state • embraces radical complexity • has a brick wall for interop with C.,0.0,C
15xgt8b,jx74ln8,This is pretty close to just C++ isn't it?,0.25,C++
15xgt8b,jx79qy5,But without C interop.,0.0,C
15xgt8b,jx6y28u,Not as good as C tbh (a truly perfect programming language),0.85,C
15x8bal,jx52y0o,"A lot of languages just use the logical operators for this, for example in Julia [https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation](https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation)  Additionally, you seem to have a concept of falsy and truthy, which has its dangers.",0.25,Julia
15x8bal,jx8yvyk,"_ = None      (:) :: Option a -> Lazy a -> a     (Some x) : _ = x     None : x = (force x)  With language support you could auto-lazy the RHS of both operators, or you wouldn't even need to do that in a lazy by default language like Haskell, though we can already express the same things in a slightly different way with `maybe`.",-0.125,Haskell
15x8bal,jx5myqp,"Most languages actually have more terse way to express the logic I'm trying to capture, for example in Rust the same can simply be done with:      v = match c {         b'0'..=b'9' => c - b'0',         b'A'..=b'F' => c - b'A' + 10,         _ => 255,     } as i8;  You can ignore the `b'...'` prefix, the sentinel `255` instead of `-1`, and the `as i8`; these just have to do with Rust's `char` type being different from the signed bytes I used in my example above.",0.14285714285714285,Rust
15x8bal,jx5myqp,"A more idiomatic Rust example would be:      let v = match c {         '0'..='9' => Some(c as u32 - '0' as u32),         'A'..='F' => Some(c as u32 - 'A' as u32 + 10),         _ => None,     };  But this isn't quite the same as my original example semantically since it does things like encoding errors in the type system, uses 32-bit unsigned ints instead of 8-bit signed ints, and only work on previously validated Unicode scalar values.",0.14166666666666666,Rust
15x8bal,jx5myqp,"Edit: This isn't relevant to anything, but in trying to figure out a nicer way to do this in C++ rather than with `if` statements, I accidentally did this:      v = 0;     switch (c) {         case 'F': ++v;         case 'E': ++v;         case 'D': ++v;         case 'C': ++v;         case 'B': ++v;         case 'A': ++v;         case '9': ++v;         case '8': ++v;         case '7': ++v;         case '6': ++v;         case '5': ++v;         case '4': ++v;         case '3': ++v;         case '2': ++v;         case '1': ++v;         case '0': break;         default: v = -1;     }  ***ಠ╭╮ಠ***",0.4,C++
15x8bal,jx5myqp,"Edit: This isn't relevant to anything, but in trying to figure out a nicer way to do this in C++ rather than with `if` statements, I accidentally did this:      v = 0;     switch (c) {         case 'F': ++v;         case 'E': ++v;         case 'D': ++v;         case 'C': ++v;         case 'B': ++v;         case 'A': ++v;         case '9': ++v;         case '8': ++v;         case '7': ++v;         case '6': ++v;         case '5': ++v;         case '4': ++v;         case '3': ++v;         case '2': ++v;         case '1': ++v;         case '0': break;         default: v = -1;     }  ***ಠ╭╮ಠ***",0.4,C
15ww9sh,jx4rz7r,"In Rust, you have to use convoluted workarounds like `mem::swap(&mut a, &mut b)` instead.",0.0,Rust
15ww9sh,jxcguy4,"> I think destructuring assignments should be able to affect control flow...  Not sure if this is what you mean, but in Rust control flow constructs come in two flavors: one that accepts booleans (ex.",-0.020833333333333332,Rust
15wdiqh,jx0akqq,"**  Some tips:  You could dive in, into several projects, code and documentation, like Modula and Ada.",0.0,Ada
15wdiqh,jx0akqq,"Java, C# and similar V.M.",0.0,Java
15wdiqh,jx0akqq,"Java, C# and similar V.M.",0.0,C
15wdiqh,jx0akqq,Pascal branch of P.L.,0.0,Pascal
15wdiqh,jx0akqq,Java and C++ uses classes definitions as modules.,0.0,Java
15wdiqh,jx0akqq,Java and C++ uses classes definitions as modules.,0.0,C++
15wdiqh,jx0akqq,**  C++ and Java mix both.,0.0,C++
15wdiqh,jx0akqq,**  C++ and Java mix both.,0.0,Java
15wdiqh,jx0akqq,Delphi doesn't.,0.0,Delphi
15wdiqh,jx0akqq,"**  Pascal call them ""unit (s)"".",0.0,Pascal
15wdiqh,jx0akqq,"**  Java ""package (s)"" sometimes does this.",0.0,Java
15wdiqh,jx0akqq,"There's an special single main folder module as the ""global"" namespace in C++.",0.11309523809523808,C++
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,Delphi
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,C++
15wdiqh,jx0akqq,"C++ ""namespace"" does not have this directly.",0.1,C++
15wdiqh,jx0akqq,Delphi does.,0.0,Delphi
15wdiqh,jx0akqq,Java and C++ emulate this using a class and a static constructor and a static destructor.,0.5,Java
15wdiqh,jx0akqq,Java and C++ emulate this using a class and a static constructor and a static destructor.,0.5,C++
15wdiqh,jx0akqq,"A lot of programers, in C and C++, emulate this by explicitly declaring and calling some functions.",0.0,C
15wdiqh,jx0akqq,"A lot of programers, in C and C++, emulate this by explicitly declaring and calling some functions.",0.0,C++
15wdiqh,jx0akqq,This is emulated in Java and C# with static fields and static methods.,0.5,Java
15wdiqh,jx0akqq,This is emulated in Java and C# with static fields and static methods.,0.5,C
15wdiqh,jx0akqq,"A ""only one mandatory file per (file) module"" approach is better, like Delphi / Turbo Pascal.",0.25,Delphi
15wdiqh,jx0akqq,"A ""only one mandatory file per (file) module"" approach is better, like Delphi / Turbo Pascal.",0.25,Pascal
15wdiqh,jx0akqq,"C++ allows not using a namespace at all, or using anonymous namespaces, or using several same level namespaces in one single file.",-0.023809523809523808,C++
15wdiqh,jx0akqq,"C++ uses anonymous namespaces, it works, but not recommended.",0.0,C++
15wdiqh,jx0akqq,"Modula, Ada also splits ""interface"" and ""implementation"" sections.",0.0,Ada
15wdiqh,jx0akqq,Delphi and FreePascal approach works better.,0.5,Delphi
15wdiqh,jx0akqq,"**  This works similar to *.obj or *.o files and *.h, *.hpp files generated by C or C++ compilers.",0.0,C
15wdiqh,jx0akqq,"**  This works similar to *.obj or *.o files and *.h, *.hpp files generated by C or C++ compilers.",0.0,C++
15wdiqh,jx0akqq,Delphi and FreePascal and TurboPascal had this for years.,0.0,Delphi
15wdiqh,jx1p0d5,"In a sense, classes serve as poor mans modules in Java and C#.",-0.4,Java
15wdiqh,jx1p0d5,"In a sense, classes serve as poor mans modules in Java and C#.",-0.4,C
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Pascal
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Java
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Perl
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Python
15wdiqh,jx5fasi,"Then, a very basic implementation is illuminated in [https://xavierleroy.org/publi/modular-modules-appendix/](https://xavierleroy.org/publi/modular-modules-appendix/) \- it covers both a system for ""mini ML"" and ""mini C"" (by use of modules to abstract over details, hence ""modular modules"").",0.0,C
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,Go
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,Rust
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,C
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,Swift
15wdiqh,jx15ogi,"Oh hey, we meet again :D  Good point about Modula...I guess I could peer into freepascal too.",0.85,D
15wdiqh,jxbyyzb,"I have been meaning to check out D more closely, extra motivation now :)",0.3333333333333333,D
15wdiqh,jx3ds7u,Delphi / FreePascal and C# were highly productive and organized.,0.16,Delphi
15wdiqh,jx3ds7u,Delphi / FreePascal and C# were highly productive and organized.,0.16,C
15wdiqh,jx3ds7u,BTW The same guy that lead the C# project was one of the Delphi developers.,0.0,C
15wdiqh,jx3ds7u,BTW The same guy that lead the C# project was one of the Delphi developers.,0.0,Delphi
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,Java
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,C++
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,PHP
15wdiqh,jx3ds7u,Java didn't allow this.,0.0,Java
15wdiqh,jx3ds7u,"But, in C# or FreePascal, I can have a ""Toolbars"" module with those classes.",0.0,C
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,PHP
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,C
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,Java
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,C++
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,Delphi
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,Pascal
15wdiqh,jx31loy,"There is a special main or root folder like the ""global"" namespace of C++.",0.17460317460317462,C++
15wdiqh,jx31loy,"That single module per file would be similar to a Java class declaration, but can contain types, variables, classes or types declarations, functions.",-0.03571428571428571,Java
15wdiqh,jx2url0,"https://faultlore.com/blah/swift-abi/ - Swift is a language for an OS, so they prioritized a dynamic ABI component, similar to what Windows COM solved -- dynamic  modules at bigger a scale larger than static modules   ABIs are basically the dynamic part (not compiled together) part of a static module system (compiled together)  ----  Matklad has been thinking about modules a lot too, some good observations:  https://lobste.rs/s/vx8hbs/rust_module_system_encourages_poor  https://lobste.rs/s/47amaq/rust_i_wanted_had_no_future#c_vj5c1c  https://matklad.github.io/2023/03/28/rust-is-a-scalable-language.html  ---  If you're interested in dynamic composition of components written in static languages, I'd also look at plugin systems for big apps ... almost all apps grow them -- the browser, Word, Excel, Photoshop, Maya, etc.",0.18846153846153849,Swift
15wdiqh,jy2fhvu,"For instance, functions in C are not first-class, but they are first-class in JavaScript.",0.0,C
15wdiqh,jy2fhvu,"For instance, functions in C are not first-class, but they are first-class in JavaScript.",0.0,JavaScript
15wdiqh,jy2fhvu,"There are no C expressions that denote functions, even if they might denote the memory address of a function.",0.0,C
15wdiqh,jy2fhvu,"Similarly, memory locations are first-class in C, but not in JavaScript.",0.0,C
15wdiqh,jy2fhvu,"Similarly, memory locations are first-class in C, but not in JavaScript.",0.0,JavaScript
15wdiqh,jy2fhvu,"Scala's path-dependent types, type members, and traits are also a way of doing these things, and Scala's object system is an ML-style module system if you know which angle to look at it from.",0.0,Scala
15w9zef,,"I have a kind of outdated website here [http://jeebox.org](http://jeebox.org) and you can compile it in C++ via my github at [http://gamblevore.org](http://gamblevore.org) and see some docs here [http://docs.gamblevore.org/Message.md](http://docs.gamblevore.org/Message.md)  My github has many projects within it, one is to create the libJeebox.dll (or .so or .dylib).",0.2333333333333333,C++
15w9zef,,"It will create a lib and some C++ header code, and C header code too.",0.0,C++
15w9zef,,"It will create a lib and some C++ header code, and C header code too.",0.0,C
15w9zef,,* libJeebox works but what if you are writing a compiler in another language that doesn't work with C APIs?,0.0,C
15w0gic,jwzwws7,"Using Rust as an example, you'd end up with something like this:      struct GetField { receiver: Expression, name: String }     enum Expression { GetField(Box<GetField>), ... }  If you want a chain of fields to result in a single AST node, you'd need something like this instead:      struct FieldChain { receiver: Expression, names: Vec<String> }  That way you'd end up with something like this:      (field ""attr1"" ""attr2"" (identifier ""value""))",-0.4107142857142857,Rust
15vmmet,,"The quote :  ""I’ve programmed systems in many different languages; from assembler to Java.",0.25,Java
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Fortran
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,COBOL
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,C
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Pascal
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,C++
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Java
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Lua
15vmmet,,"I’ve used stack based languages like Forth, and logic based languages like Prolog.""",0.0,Forth
15vmmet,,"I’ve used stack based languages like Forth, and logic based languages like Prolog.""",0.0,Prolog
15vmmet,jww6tts,"They aren't the only typeless languages, BCPL, BLISS, Forth, TCL and Bourne shell are typeless languages.",0.0,Forth
15vmmet,jww6tts,"""System languages"" need some typeless aspects to do what they are designed to do, hopefully those features are well controlled (that's not always the case, for instance C++ having evolved from C which itself can be considered as adding static types to BCPL have aspects which are justifiable only by its root in an untyped language).",0.25,C++
15vmmet,jww6tts,"""System languages"" need some typeless aspects to do what they are designed to do, hopefully those features are well controlled (that's not always the case, for instance C++ having evolved from C which itself can be considered as adding static types to BCPL have aspects which are justifiable only by its root in an untyped language).",0.25,C
15vmmet,jww6tts,"Static languages tend to acquire dynamic aspect (see the addition of object systems to C, Pascal, ML).",0.25,C
15vmmet,jww6tts,"Static languages tend to acquire dynamic aspect (see the addition of object systems to C, Pascal, ML).",0.25,Pascal
15vmmet,jww6tts,"Dynamic languages also can acquire static aspects (see Typescript for Javascript, the type annotation of Python).",0.25,Python
15vmmet,jww6tts,"Word for older assembly language, BLISS, BCPL, Forth.",0.16666666666666666,Forth
15vmmet,jwwyvaz,"You should try Forth  Also I think you're mistaking ""memory layout"" for ""type"" and these are different aspects of computing systems",0.0,Forth
15vmmet,jwwcmuu,Assembly (on most platforms) is a typeless language.,0.5,Assembly
15vmmet,jwwcmuu,Forth is an interesting programming language because it has this very same property.,0.25,Forth
15vmmet,jwwcmuu,Forth is a very simple virtual machine you can build for yourself in just a few hundred lines of assembly code.,-0.1,Forth
15vmmet,jwwcmuu,"It is significantly nicer than Assembly, without being meaningfully limited in scope and power, compared.",0.1517857142857143,Assembly
15vmmet,jwxmzll,"According to wikipedia, the following are typeless languages:  * AutoHotkey * B * BCPL * Bliss * Forth * MUMPS (M) * Rexx",0.0,Forth
15vmmet,jwvysqe,Clojure is probably a combination of the first 2.,0.25,Clojure
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,Java
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,C
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,Rust
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,Assembly
15vmmet,jxd4gnp,"Looking at Ada, it doesn’t have an Integer type.",0.0,Ada
15vmmet,jwwr8bh,"And of course, JavaScript comes to mind, unbidden, like a mosquito on the patio.",0.0,JavaScript
15vmmet,jwz6wzl,"Then I think you can *make* any language produce at least *runtime* type errors, for example you can create a JavaScript function that throws an error when it gets passed a non-integer-number, and you can make any typed language ignore some sort of type errors – in the sense that you can pass a non-e-mail-address to a function that expects an e-mail-address or a value in inches to a function that expects centimeters.",-0.3,JavaScript
15vmmet,jwz6wzl,Python can't prevent you from only using strings to represent numbers.,0.0,Python
15vmmet,jwz6wzl,"Different thought:  In C, an `unsigned char` is used to represent a number between 0 and 255.",0.0,C
15vmmet,jwwzt43,"(in Forth there is no syntax distinction between ASCII 'A', an integer 97, a pointer to the 97th word of memory, etc.",0.0,Forth
15vmmet,jx06f4d,I’ve been a Clojure programmer for a decade and his Clojure articles are rubbish.,0.0,Clojure
15vmmet,jx06f4d,His published Clojure code is horrible.,-1.0,Clojure
15vmmet,jx18sxt,You may have heard of it -- they called it `C`.),0.0,C
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,C
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,C++
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,Haskell
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,Lisp
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,Eiffel
15vmmet,jwz8n75,"For example, an i8 in Rust contains all integers from -127 to +128.",0.0,Rust
15vbuyi,jwuwgs2,"So yeah, here are some facts about established programming languages:   Java does what you do.",0.0,Java
15vbuyi,jwuwgs2,Scala works around the JVM limitation by introducing a compiler feature similar to C++ templates but much more limited.,0.14285714285714288,Scala
15vbuyi,jwuwgs2,Scala works around the JVM limitation by introducing a compiler feature similar to C++ templates but much more limited.,0.14285714285714288,C++
15vbuyi,jwuwgs2,"In C#, generic type information is tracked at runtime.",0.0,C
15vbuyi,jwuwgs2,"Put in any other type and it's a T** if you're thinking in C (where the last layer is the pointer to the list which holds the array, since a list is a reference type).",-0.0625,C
15vbuyi,jwuwgs2,C++ obviously has templates.,0.0,C++
15vbuyi,jwuwgs2,"Similar to C#, but much more powerful.",0.26666666666666666,C
15vbuyi,jwuwgs2,"C has macros for this, which leads to all sorts of awful hacks to have generic collections.",-0.5,C
15vbuyi,jwupjpn,"A normal vector implementation looks like this (I'm using C++ because it gives low-level control):      template <class T> class vector {       T* data;       std::size_t len;       std::size_t cap; // you could have the invariant that len == cap, but then you can't over-allocate     public:       vector(): data(nullptr), len(0), cap(0) {} // don't allocate for an empty vector       vector(vector<T> const& other): data(std::malloc(other.len)), len(other.len), cap(other.len) {         std::memcpy(data, other.data, len);       }       ~vector() {         for (std::size_t i = 0; i < len; ++i) {           (data + i)->~T(); // call destructors on the data         }         std::free(data);       }       void reserve(std::size_t new_cap) {         if (cap < new_cap) {           data = std::realloc(data, new_cap);           cap = new_cap;         }       }       // these are the mutable accessors, constant ones are basically the same       T& operator[](std::size_t idx) {         // maybe add a bounds check         return data[idx];       }       T& first() {         return *data;       }       T& last() {         return data[len - 1];       }       void push_back(T val) {         if (len + 1 >= cap) {           switch (cap) {             case 0: reserve(1); break;             case 1: reserve(4); break; // skip from 1 to 4 because that's better in most cases             default: reserve(cap * 2); break; // double capacity to over-allocate           }         }         ++len;         last() = std::move(val);       }       // depending on your language, you might want to implement emplace_back, it's not too complicated       void pop_back() {         if (len) {           --len;           (data + len)->~T(); // call the destructor of the last element         }       }     };  This is a simplified implementation of C++'s `std::vector`.",0.048214285714285716,C++
15vbuyi,jwxplc8,"The capacity can be part of the static type, as in C++ `array<t, 255>`.",0.5,C++
15vbuyi,jwxplc8,However this will require your language to support something similar to C++ template specialization.,0.0,C++
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,Go
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,Rust
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,C
15uwmsd,,"Swift uses `:` for passing arguments to named parameters (`foo(a: 10)`), why not `=`?",0.0,Swift
15uwmsd,jwsq4yg,Ruby also uses `:` for passing named parameters.,0.0,Ruby
15uwmsd,jwsq4yg,"And in Ruby's particular case, it makes a lot of sense.",0.16666666666666666,Ruby
15uwmsd,jwsq4yg,"Now Ruby has real named arguments, so the ""turn it into a hash argument"" rule only kicks in on old-style functions that don't take any named parameters.",0.1,Ruby
15uwmsd,jwskpy9,"In the C family of languages, assignment is an expression, so `a = b = c` is legal, and as a result, the `=` operator is a poor choice for named arguments.",-0.1,C
15uwmsd,jwskpy9,"The `=` assignments as expressions also leads to a few classes of common bugs in C family languages, so it's hard to defend in a new language, although it's easy to understand in an old languages with an enormous legacy codebase.",-0.017424242424242432,C
15uwmsd,jwu12xp,"IIrc, C# also use ':' for passing named arguments.",0.0,C
15uwmsd,jwtku1p,"Anyway, C making a ""virtue"" out of it (I believe Ritchie or someone else used the argument that assignment was more frequent than comparison for equality) and picking ""=="" for equality, at a time when ASCII was used, well *that* should not have happened.",0.3,C
15uwmsd,jwtnqv4,Python semi-recently added `:=` for assignment expression.,0.0,Python
15uwmsd,jx0g70f,Like in Prolog or Ting.,0.0,Prolog
15uwmsd,jwx7u86,"In languages like LISP, PROLOG or APL which build off math directly you don't have this issue (APL uniquely because assignment is considered).",0.2375,APL
15uwmsd,jx8xl8u,"Languages from the 70ies managed to get this right, Rust somehow regressed on that.",0.2857142857142857,Rust
15uwmsd,jwvn0ee,"The is a possibly well-known blog from a few years ago, that describes a ""mystery language"", comparing it with Go, and concluding they are nearly feature-equal, and then revealing the language to be Algol 68, which was defined in 1968 (and revised, mostly to give it a more format semantic definition, in 1974.)",0.18,Go
15uwmsd,jwvqfuw,"But there's also a universal ""C"" locale that you can place universal symbols for things in, like `==()`.",-0.25,C
15uwmsd,jxe2c58,"This often happens to comments mentioning Rust, but that's not my loss; I remember the things I write pretty well.",0.25,Rust
15uwmsd,jx1j6st,"You may recall that HTML used SGML entities for character names; again, iirc, some Danish standards people were very annoyed that the name for our letter Æ/æ was demoted to be a ""ligature"": Aelig/aelig.",-0.52,HTML
15uwmsd,jx1j6st,"I understand that part of Unicode's early ""mission statement"" was also to reconcile many kinds of code pages that had been in use, so fx ""℃"" exists as a codepoint (U+2103), even if the degree symbol ""°"" existed in Latin1, and we will typically write ""degrees Celsius"" as ""°C"" (two codepoints: °: U+00B0 and C: U+0043.)",0.14444444444444446,C
15uwmsd,jx1j6st,"This is why we got the infamous lexer problem in C, when typedefs were added to the language!",-0.625,C
15uwmsd,jx1j6st,"Using different styles as distinct symbols, in addition to solving the C lexer problem with types, also could solve the problem the C standards committee is having when needing to introduce new keywords at this point in C's lifecycle.",0.14545454545454545,C
15uq630,jwr13cg,"Haskell supports this (as well as embedded DSLs) through ""quasi quotes"" – blocks which are parsed with some custom parser, rather than by the main compiler.",0.16666666666666666,Haskell
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,C
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,C++
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,R
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,JavaScript
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,Java
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,Haskell
15uq630,jwr13cg,"When done well, the downsides are few (some extra complexity in the build process), and I find it a very convenient way of testing and running C and C++ code.",0.0,C
15uq630,jwr13cg,"When done well, the downsides are few (some extra complexity in the build process), and I find it a very convenient way of testing and running C and C++ code.",0.0,C++
15uq630,jwqz0ba,Rust does this via proc macros.,0.0,Rust
15uq630,jwqz0ba,"Right now I am aware of C, lisp, html, sql, latex and (for some cursed reason) gnu cobol.",0.26785714285714285,C
15uq630,jwr5ajj,"In Perl, this isn't a *language* feature, strictly speaking, but there's [a collection of modules](https://metacpan.org/pod/Inline) called `Inline` that let you embed code in other languages, well, inline.",-0.125,Perl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,C
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Perl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,C++
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Python
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Tcl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Java
15uq630,jwsee3q,"The usual suspects get mentioned (Haskell's quasiquoting, Racket) but also some others.",-0.25,Haskell
15uq630,jwsee3q,** Since around 2000 Perl devs have been able to import foreign PL modules and/or embed foreign PL code via [`Inline`s](https://metacpan.org/search?size=500&q=inline) that embed *existing* implementations of foreign PLs into Perl programs.,0.03125,Perl
15uq630,jwsee3q,"Stefan Seifert, the author of several Perl `Inline`s brought the same tech to Raku, and has since taken it to new levels.",0.04545454545454545,Perl
15uq630,jwtn6ib,Common Lisp is one.,-0.3,Lisp
15uq630,jwrq5h8,"Although it mostly is in the form of strings, there are many DB systems that provide a processor to allow embedding SQL into C programs (and other languages), including PostgreSQL ECPG.",0.2916666666666667,C
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,HTML
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,JavaScript
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,PHP
15uq630,jwrq5h8,"Embedding for example a C snippet in a Pascal program is probably not very useful, for that the languages are not sufficiently dissimilar.",-0.11538461538461536,C
15uq630,jwrq5h8,"Embedding for example a C snippet in a Pascal program is probably not very useful, for that the languages are not sufficiently dissimilar.",-0.11538461538461536,Pascal
15uq630,jwrq5h8,Then of course there is C embedding in C++ to some degree.,0.0,C
15uq630,jwrq5h8,Then of course there is C embedding in C++ to some degree.,0.0,C++
15uq630,jwrq5h8,And asm sections in both C and C++ programs.,0.0,C
15uq630,jwrq5h8,And asm sections in both C and C++ programs.,0.0,C++
15uq630,jwrq5h8,"Finally, applications that use extension languages like ECMAScript or Lua will probably also include some code, but again this is most likely in the form of strings.",0.16666666666666666,Lua
15uq630,jwrq5h8,"Finally Perl has had support for various language extensions and embedding for decades, ranging from C (using XS) to ""Latin"".",0.0,Perl
15uq630,jwrq5h8,"Finally Perl has had support for various language extensions and embedding for decades, ranging from C (using XS) to ""Latin"".",0.0,C
15uq630,jwrq5h8,"How many and to what extent they are actually used (except that C for obvious reasons is used for integrating Perl with C-based libraries), I don't know.",0.16666666666666666,C
15uq630,jwrq5h8,"How many and to what extent they are actually used (except that C for obvious reasons is used for integrating Perl with C-based libraries), I don't know.",0.16666666666666666,Perl
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,C
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,Perl
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,C++
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,Lua
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,Pascal
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,C
15uq630,jwrq5h8,"Lexer (.lex) definition files for (f)lex, and grammar (.y) files for yacc/Bison could also be considered DSLs with embedded C code.",0.0,C
15uq630,jwto0dk,"Perl is a multi-syntax language: It has regular code, POD, regex, strings, and here-documents.",0.0,Perl
15uq630,jwsfkbi,Other examples React and C# linq,-0.125,C
15uq630,jxfktx1,"Other people already mentioned web front-end languages like HTML/JS/CSS, plus backend languages like PHP, ASP, etc.",-0.125,PHP
15uq630,jxfktx1,"For example, if you open a large HTML file and jump to the middle of the file, the syntax highlighting needs to know whether it's inside a `<script>` tag or not, which requires scanning the entire file from the start to properly answer.",0.04285714285714286,HTML
15uq630,jxfktx1,"HTML/PHP solve this problem by using delimiters that aren't valid code in the embedded language (`</script>` is not valid JS, and `?>` is not valid PHP).",0.0,PHP
15uq630,jxfktx1,Perl regex solves the problem by providing a wide range of ways to quote regexes so you can always find a delimiter that isn't used in your pattern.,-0.1,Perl
15uq630,jwsjscy,Examples: C# / .NET -- _most_ of the other languages on the CLR are basically just C# with a little syntactic sugar.,0.0625,C
15uq630,jwtbvvh,Ruby on Rails does that - to the point that it becomes a nightmare to work with it - every single DSl has its own complexities and peculiarities to the point that it feels like working in different languages.,0.1761904761904762,Ruby
15uq630,jwtuqu8,To some degree Rust's proc macros fit the definition.,0.4,Rust
15uq630,jwvm6hv,"For example, in Rust, expressions that appear inside the vec!",0.0,Rust
15uq630,jx0gj93,"At the time, I was also programming C and Fortran on the other Crays (running Unix).",-0.125,C
15uq630,jx0gj93,"At the time, I was also programming C and Fortran on the other Crays (running Unix).",-0.125,Fortran
15uq630,jwtv0ex,maybe script/style tags in HTML?,0.0,HTML
15uq630,jwrr2lj,And other Scheme and LISP variants are also often used as embedded extension languages - emacs probably being the best known example.,0.4375,Scheme
15uq630,jwrr2lj,"To what degree that actually includes code embedded directly in the C code, I do not know.",0.05,C
15uq630,jwt7dwl,;D !<,0.3125,D
15uq630,jwuylx7,"Rust's proc macro system is pretty amazing, it allows for the embedding of other DSLs with proper syntax checking, strong typing guarantees, and escape hatches to compute runtime values through rust.",0.2316666666666667,Rust
15uejj0,,"Hi, I just made this language in C++, with an interpreter and C++ transpiler, and also a web app to use it.",0.0,C++
15uejj0,jwqrszy,You should look at COBOL.,0.0,COBOL
15uejj0,jwtdls5,If your goal is to be more accessible than python you probably shouldn't need to download a C++ and ES compiler before you can use the language.,0.4375,C++
15uejj0,jwr5o34,The organization of your code (all in header files) makes it look like you don't know how to write idiomatic C++.,0.0,C++
15uejj0,jwr5o34,I see that your C++ transpiler dumps `using namespace std` into the generated code.,0.0,C++
15uae4o,jwpl5if,Have a look for Modern Compiler Implementation in Java by Andrew Appel.,0.2,Java
15uae4o,jwpl5if,"E: there's a version of the book using C++ too, take your pick.",0.0,C++
15uae4o,jwos6zr,"And Microsoft's Dotnet engineers seem to agree, with the new open source Roslyn C# compiler being fully functional and immutable.",0.06818181818181818,C
15uae4o,jwpx2yk,I can think of some references you might appreciate:  * [Object Oriented Programming in Common Lisp](https://en.wikipedia.org/wiki/Object-Oriented_Programming_in_Common_Lisp) - I enjoyed this book; especially the example at the end about implementing a range of different kinds of IO streams.,0.05,Lisp
15uae4o,jwpx2yk,I remember it being a more compelling illustration of OO than the C++ examples I was used to reading at the time.,0.4,C++
15uae4o,jwpx2yk,* [Lisp in Small Pieces](https://pages.lip6.fr/Christian.Queinnec/WWW/LiSP.html) - It has a chapter towards the end about organizing a compiler in an object oriented style.,-0.25,Lisp
15uae4o,jwq2zfd,First question: How well do you know C++ or Java?,0.25,C++
15uae4o,jwq2zfd,First question: How well do you know C++ or Java?,0.25,Java
15uae4o,jwolatx,"Compiler *C = new JavaCompilerClass();     ...     C->assignSource(""c:\test\helloworld.java"");     C->Compile();     ...     free C();      class JavaCompilerClass : CompilerClass     {        ...        ...     } ;          class CompilerClass     {        ...        ASTClass* AST;        SymbolTableClass* SymbolTable;        ...        LexerClass* Lexer;        ParserClass* Parser;        ...     } ;         Just my two cryptocurrency coins contribution...",0.2681818181818182,C
15uae4o,jwpoyrq,"came to suggest Appel's book, he also made variants in C and ML for comparison",0.0,C
15uae4o,jx6zrki,"Quite a long time ago - the only language the students had in common was Java, which was the reason for choosing it.",-0.11666666666666665,Java
15uae4o,jwoxxd1,"You'd have a very large function that takes a user input and the current total UI state, and returns a new UI state (see the Elm language).",0.10373376623376623,Elm
15uae4o,jwoxxd1,Just compare ready-to-go React widgets to what Elm offers.,0.1,Elm
15uae4o,jx779z0,">Crafting Interpreters by Nystrom is a very well written book  Ah yes, I loved going through creating Lox with C#, it was quite fun.",0.39999999999999997,C
15uae4o,jx779z0,"Though, C# is very slow to start up.",-0.39000000000000007,C
15tzhae,jwpo3kc,For reference: the D reference compiler lowers foreach and while to for loops.,0.0,D
15ty5ei,jwuv24z,"Most notably, the basic usecase of iterating over an array -- which in C is done by just incrementing a pointer -- seems like it could suffer quite a bit of overhead if the iterator was implemented as a wholly separate stack.",0.3333333333333333,C
15tw2nd,jwnmiqz,"Better still, write the compiler in Python, and take over a supercomputer, there's work to be done!",0.625,Python
15tp88l,jwlnqwg,"Ones like gcc on my machine, for an easy-to-compile language like C, might manage 10-20K lines per second, slower if optimising.",0.0,C
15tp88l,jwlnqwg,Tiny C might do 500-1000K lines per second.,0.0,C
15tp88l,jwkyum2,"Take C, C++, C#: you can compile a unit of code to a dynamically linked library (.dll, .so).",0.0,C
15tp88l,jwkyum2,"Take C, C++, C#: you can compile a unit of code to a dynamically linked library (.dll, .so).",0.0,C++
15tp88l,jwkyum2,Or you could look into how Rust works.,0.0,Rust
15tp88l,jwojs8n,In C / C++ this is sort of simulated with *.obj and *.h files.,0.0,C
15tp88l,jwojs8n,In C / C++ this is sort of simulated with *.obj and *.h files.,0.0,C++
15tp88l,jwojs8n,In Java this is done with *.class files.,0.0,Java
15tp88l,jwojs8n,"Delphi has been doing this for decades, with it's own intermediate code files.",0.6,Delphi
15tp88l,jx8sgzf,"In another comment, it appears you are using C++'s `std::map` which is notoriously slow.",-0.30000000000000004,C++
15tp88l,jwn88sf,"I would take a look at speeding the compiler up rather than doing any incremental compilation, which can be a nightmare & very error prone  For reference, [TCC](https://www.bellard.org/tcc/) was compiling 1 mil lines per sec of C on a 2.4ghz pentium 4, which is a single core 32-bit cpu that *doesn't* have any of the nice simd instructions  Given that any cpu you have today is *at least* 10x faster than this, you'd better be doing *at least* 350x more semantic analysis than C to make it worth it!",0.15595238095238095,C
15tkpyo,,I wrote a primitive Lisp parser in OCaml [https://github.com/BranislavLazic/yaran](https://github.com/BranislavLazic/yaran).,0.0,Lisp
15t0pad,jwhbpgk,"As part of the 'interface' (called instance arguments in Agda; similar to typeclasses in Haskell) you can declare a proposition that must hold for any instances, and instances must define a machine-checkable proof of this proposition for the given type.",0.0,Haskell
15t0pad,jwie757,C# has (or had) this functionality with Code Contracts.,0.0,C
15t0pad,jwos6vx,"C++ can do it: [https://godbolt.org/z/4P98obn55](https://godbolt.org/z/4P98obn55)      #include <concepts>          template<typename T>     concept IAdder = requires {         { T::add(int{}, int{}) }->std::integral;         requires (T::add(5, 9) == 14);     };          struct SimpleAdder {         static constexpr auto add(auto x, auto y) { return x + y; }     };          struct FakeAdder {         static constexpr auto add(auto x, auto y) { return 9; }     };          auto main()->int {         static_assert(IAdder<SimpleAdder>);         static_assert(!IAdder<FakeAdder>);     }",0.08333333333333333,C++
15t0pad,jwhp9zt,At least when I first learned it (Idris 1) it felt like a very natural extension of Haskell.,0.026666666666666672,Haskell
15t0pad,jwhsow4,"C# or Java) so it's whatever the target language compilation is, with a small overhead.",-0.25,C
15t0pad,jwhsow4,"C# or Java) so it's whatever the target language compilation is, with a small overhead.",-0.25,Java
15s4uea,jwdnwoi,"It may be as simple as emmitting a SVG or a PNG, or drawing in a HTML Canvas.",0.0,HTML
15s4uea,jwdnwoi,"Start scribling things around, maybe you want to draw a triangle, you may write something like: `define A, B, C to be points; Draw a line from A to B, B to C and A to C`, well, english has no good structure to parse and this is very verbose, so you may try and insert some keywords, and a few rules like ""uppercase letters are always points"" to make it more concise: `def A, B, C; Line A B; Line B C; Line A C`, and from there you continue this process of trying things, defining grammar, changing grammar, until you arrive at something you're happy with.",0.15,C
15s4uea,jwfqtz0,"&#x200B;  I first went with LLVM, but i had to learn the tool, which is very time consuming, and I also had to learn C++, which again, is very time consuming.",0.21666666666666667,C++
15s4uea,jwcdl3g,"I think future languages will support things that are currently done in libraries or functions today, like we are already seeing for example with goroutines in Go.",0.0,Go
15s4uea,jwcdl3g,"in C#, we can’t set any priority to control which tasks should be performed first.",0.25,C
15s4uea,jwp99c0,"Go ahead, make something weird, nobody will probably ever use it.",-0.5,Go
15s4uea,jwmoslg,"Though there is a discontinuity between the Lisp level and the lower-level implementation language, their implementations can share most of the code.",0.5,Lisp
15s4uea,jwpkfsb,"However postfix concatenative languages, like Forth, are another competing influence in my thinking.",0.0,Forth
15s4uea,jwpkfsb,I need to look at how stdio is actually implemented in various C libraries.,0.0,C
15s4uea,jwpkfsb,"Riding on top of C, is not necessarily the direction I want to take.",0.25,C
15s4uea,jwrkluf,[https://piumarta.com/software/maru/](https://piumarta.com/software/maru/)   [https://github.com/attila-lendvai/maru](https://github.com/attila-lendvai/maru)  You probably would want to bootstrap a compiled Lisp.,0.0,Lisp
15s4uea,jwrkluf,No C required.,0.0,C
15s4uea,jwrkluf,"It's a much more complex system, but the Yale T system (a Scheme dialect) was implemented entirely in its own language, save for a tiny assembler stub to initialize.",0.16,Scheme
15s4uea,jwrkluf,"Scheme-48 runs on a VM that is implemented in PreScheme, an embedded language that is compiled into C, but you could go direct to machine code.",0.1,C
15s4uea,jwrkluf,"[https://mumble.net/\~jar/tproject/](https://mumble.net/~jar/tproject/)  [https://www.s48.org/](https://www.s48.org/)  From your remarks about Forth and concatenative languages, however, it may be that you are going for something substantially simpler, and a self-compiling compiled Lisp exceeds your complexity budget.",0.0,Forth
15s4uea,jwrkluf,"[https://mumble.net/\~jar/tproject/](https://mumble.net/~jar/tproject/)  [https://www.s48.org/](https://www.s48.org/)  From your remarks about Forth and concatenative languages, however, it may be that you are going for something substantially simpler, and a self-compiling compiled Lisp exceeds your complexity budget.",0.0,Lisp
15s4mez,jwpcuih,":-)  In the somewhat weird language I am designing right now, I currently use a 𝐩𝐫𝐨𝐜 keyword next to the parameter list; but that is because I expect to use the C preprocessor (with 𝐩𝐫𝐨𝐜 being a macro) to ""compile"" the language to C, and I need to pass the parameters to a macro for manipulation.",0.05714285714285714,C
15s0ox6,,"For example, in the following Haskell code the well-formedness of expressions is ensured at compile time:      data Term a =         IntLit :: Int -> Term Int         BoolLit :: Bool -> Term Bool         Add :: Term Int -> Term Int -> Term Int         Equal :: Term x -> Term x -> Term Bool      -- Bool to bool comparison is fine.",0.1388888888888889,Haskell
15s0ox6,jwewou4,"Sidenote: the very first code sample (in TypeScript) seems messed up: SerializerOf vs. TypeName, StringSerializer vs. ""string"".",0.325,TypeScript
15s0ox6,jwf82kw,String -> Term a  or written in a way that is valid Haskell today      data SomeTerm where         MkSomeTerm :: Term a -> SomeTerm          parse :: String -> SomeTerm,0.0,Haskell
15s0ox6,jwmqqo5,"Haskell might not have this problem, as it has GADTs and type-directed compilation.",0.0,Haskell
15s0ox6,jwc8xyf,There is no such facilities in vanilla Haskell.,0.0,Haskell
15s0ox6,jwn1cby,"As far as I understand, Haskell's GADTs are just like OCaml's in this regard.",0.1,Haskell
15s0ox6,jwn1cby,What's close to mapping types is type families in Haskell.,0.0,Haskell
15ryfsq,jwcohca,"The main motive would be a language that was ""kinder"" than C...  That being said if I had to make some guesses:  - labelled jumps / gotos, if statements for control flow.",0.16666666666666666,C
15rxlp0,jwbximp,"Of course, the point is moot when you're transpiling to C (or Rust?",0.0,C
15rxlp0,jwbximp,"Of course, the point is moot when you're transpiling to C (or Rust?",0.0,Rust
15rxlp0,jwbbt11,"Transpiler is a useless word invented\* by people who felt it dishonest to call their creation a compiler, because our collective misunderstanding of the word ""compiler"" is informally centered around the traditional notion of a batch Fortran or C compiler.",-0.26666666666666666,Fortran
15rxlp0,jwbbt11,"Transpiler is a useless word invented\* by people who felt it dishonest to call their creation a compiler, because our collective misunderstanding of the word ""compiler"" is informally centered around the traditional notion of a batch Fortran or C compiler.",-0.26666666666666666,C
15rxlp0,jwbdvv7,This is especially true if both the source and the target for a transpiler are C style languages.,0.7,C
15rxlp0,jwdzulb,"I make transpilers for languages that are similar to C, so I can take advantage of the mature optimizations of C compilers that I couldn't hope to match.",0.05,C
15rxlp0,jwdlj8v,"Your average programmer (who had one compiler class, if that, years ago and then forgot everything in it as soon as it was over) says ""compiler"" to mean ""I run this program, it takes in source code and spits out something I can execute"", while they say ""transpiler"" to mean ""I run this program, it takes in source code and spits out some other source code I could inspect and mix in with other source code before having to compile again""  Which is a valuable distinction when you're trying to, say, justify using $HotNewLanguage to your team, or seeing if you can still use a certain library you need to use without having to worry about mangling and linking (or worse, figuring out some way to have 2 processes talk to each other), or seeing if you can use that language in $CertainHardware which uses a funky architecture and only has a proprietary C compiler.",-0.1484126984126984,C
15rxlp0,jwdlj8v,The JS dev who's been told to use Babel or the fresh graduate who has to use some JVM language that transpiles to Java are just working a different level and care more about the differences as they see it.,0.26666666666666666,Java
15rxlp0,jwcoppz,"So if I built something and I say “I transpile to C”, then I am highlight that there is a trade off I’ve made, that might be interesting.",0.5,C
15rxlp0,jwbussy,Assembly is definitely a programming language and we would still say you are compiling C even if you emit assembly instead of an executable.,0.0,Assembly
15rxlp0,jwbussy,Assembly is definitely a programming language and we would still say you are compiling C even if you emit assembly instead of an executable.,0.0,C
15rxlp0,jwch2qt,"When C was first introduced, it was considered high level.",0.20500000000000002,C
15rxlp0,jwg5uh4,"Hell, sometimes the categories change based on context — Nim is a transpiler in the sense that it targets a (relatively) high-level programming language, but it's also not a transpiler in the sense that C is just an IR that will immediately be compiled to machine code.",0.0,C
15rxlp0,jwfbemg,"btw: transpilers to C are usually called compiler, as this C is portable assembler enough.",-0.125,C
15rxlp0,jwcleep,Do you consider a distinction between Java bytecode and Java source code to be valuable?,0.0,Java
15rxlp0,jwbwqwr,That's a world of a difference  (And yes there are things like Forth or the Symbolics Lisp Machines that blur this line too)  I really don't care what businesses or marketing care about.,0.2,Forth
15rxlp0,jwbwqwr,That's a world of a difference  (And yes there are things like Forth or the Symbolics Lisp Machines that blur this line too)  I really don't care what businesses or marketing care about.,0.2,Lisp
15rxlp0,jwcrj2d,"for Android, Java to JVM bytecode to DEX to machine code) and also some interpreting going on for JS in the browser, but the vast majority of activity on your device was machine instructions from actually-compiled code.",0.0,Java
15rxlp0,jwbvc8i,_(Compare any ISA to Java bytecode from the JVM spec if you don't have experience in this area.,0.0,Java
15rxlp0,jwbrvi5,"Like if the target is C, then you get the full optimization facilities of an industrial strength C compiler, whereas if the target is asm you get (basically) nothing.",0.35,C
15rxlp0,jwd7f0r,I think a compiler that compiles to C would be considered a transpiler by most people.,0.5,C
15rxlp0,jwcmmqk,"Yes, of course, but that doesn't make Java bytecode machine code.",0.0,Java
15rxlp0,jwceq7f,"So `cc1`, the program `gcc` uses to compile C is not a compiler?",0.0,C
15rxlp0,jweufm5,> Symbolics Lisp Machines that blur this line too  They still have assembly.,0.0,Lisp
15rxlp0,jwcswrf,"Like x86-64 can be one final target, but C broadens that to dozens of architectures (ignoring portability concerns).",0.0,C
15rxlp0,jwehn98,Languages like C and Rust are both high and low level languages depending on context.,0.08,C
15rxlp0,jwehn98,Languages like C and Rust are both high and low level languages depending on context.,0.08,Rust
15rxlp0,jwehn98,It also presents the question of what happens if I generate C then run gcc under the hood.,0.0,C
15rxlp0,jwehn98,Is C just another IR at that point?,0.0,C
15rxlp0,jwgarff,"/u/reini_urban was [just arguing](https://www.reddit.com/r/ProgrammingLanguages/comments/15rxlp0/comment/jwfbemg/?utm_source=share&utm_medium=web2x&context=3):  > btw: transpilers to C are usually called compiler, as this C is portable assembler enough.",0.08333333333333333,C
15rxlp0,jweitbq,"People still write loads of assembly too, especially for small 8-bit MCUs where a compiler simply is too much overhead ;)  But I see your point, in the compiling to C case, I'd argue the whole thing boxed together thing with gcc is a compiler.",0.06666666666666667,C
15rxlp0,jwoelia,> C and Rust are both high and low level languages depending on context  Your classification mentality makes this sound so complicated but it's really just relative.,0.04333333333333334,C
15rxlp0,jwoelia,> C and Rust are both high and low level languages depending on context  Your classification mentality makes this sound so complicated but it's really just relative.,0.04333333333333334,Rust
15rxlp0,jwoelia,In the early home computing world C was considered a middle-ground of abstraction between writing in an assembly language and writing in something like BASIC.,0.05,C
15rxlp0,jwfqyg4,"Again, pointing to CoffeeScript as an example (or TypeScript, for that matter).",0.0,TypeScript
15rxlp0,jwfqyg4,Examples of the first definition would be CoffeeScript and TypeScript.,0.25,TypeScript
15rxlp0,jwfq0oy,"The kids these days, so soft and sheltered, I cannot possibly imagine why would someone not be able to understand the machine generated assembly for a 100k line C program.",0.19999999999999998,C
15rsd77,,"(Elixir, F# will treat middle part as  `(upper() + """"B)(""a"")`).",0.0,Elixir
15rsd77,jwagx4q,"Shell scripting seems to be the obvious example, though I'm not quite getting how your example works.",0.0,Shell
15rsd77,jwb6kob,This C++ proposals explores a bunch of possibilities: https://wg21.link/p2672r0,0.0,C++
15rsd77,jwbxxp7,"> `|` op has a lower precedence   > Elixir, F# will treat middle part as `(upper() + """"B)(""a"")`  That it has lower precedence than `+` is why it's parsed this way.",0.0,Elixir
15rsd77,jwc3sae,"`(+ ""B"")` like Haskell or `(_ + ""B"")`, `(\x -> x + ""B"")`, `&(&1 + ""B"")` in some other languages.",-0.125,Haskell
15r4qj3,jw9wgj5,"One of the first RPython languages, a Prolog, was already implemented as an AST interpreter.",0.25,Prolog
15r1cgs,,"""`  *Looping, if-else and python inspired first class list*  `var names = [""Alice"", ""Bob"", ""Callum""]`  `loop name in $names {`  `if $name == ""Callum"" {`  `echo ""Hello, enemy""`  `} else {`  `echo ""Hello, friend""`  `}`  `}`  &#x200B;  &#x200B;  &#x200B;",0.25,Alice
15r1cgs,jw6pzzg,"I have *thoroughly* learned all the junk in Bash, but it’s always a wearying distraction from whatever my main task is.",0.16666666666666666,Bash
15r1cgs,jwareyj,"Bash and zsh and sh are sort of like giraffes: they're evolutionarily optimized for this one weird set of tasks, which makes them look very different from every other language and makes them kinda bad at things outside their target domain.",-0.26499999999999996,Bash
15r1cgs,jwareyj,It would be handy if there were string literals that could use arbitrary delimiters like `/../` or `|..|` or `[==[..]==]` to make it easy to do stuff like pass shell commands as arguments without getting [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome)  - Shell functions should _really_ have locally scoped variables.,0.2722222222222222,Shell
15r1cgs,jwbhpx5,"Bash needs a return statement to be easy to return with values from functions, also json as a built in type with support.",0.43333333333333335,Bash
15r1cgs,jwakbvm,Shell scripts are not the same domain as Rust.,0.0,Shell
15r1cgs,jwakbvm,Shell scripts are not the same domain as Rust.,0.0,Rust
15qxqf9,jw7ue4v,So folk who like Python's lax attitude toward identifiers can just write stuff like `foo = 42`.,0.0,Python
15qxqf9,jw716v0,[APL](https://en.wikipedia.org/wiki/APL_(programming_language)) enters the chat,0.0,APL
15qxqf9,jw68iei,"It's required for interoperability with weird C libraries, but also great for implementing languages since you are not restricted to only Zig allowed values.",0.10000000000000002,C
15qxqf9,jw62wgv,Identifiers in Julia can end with '!'.,0.0,Julia
15qxqf9,jw8d1x0,End a case-construction with `esac` because ALGOL.,0.0,ALGOL
15qxqf9,jwe91tn,&#x200B;  This maybe look rather conventional at first glance ... but then consider that this is plain C code compiled with the ordinary gcc compiler!,-0.10491071428571427,C
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,Pascal
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,C
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,C++
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,C
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,C++
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,JavaScript
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,Pascal
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,Delphi
15qxqf9,jw70ex9,"Scanner in Kotlin:      const val ctquote: String   = ""'""     const val ctquote2: String  = """" + 34.toChar()     const val ctivar: String    = ""#""     const val ctdef: String     = ""==""     const val ctddot: String    = ""..""     const val ctcomment: String = ""//""     const val ctcomp: String    = ""°""     const val ctcombine: String = ""Combine""     const val cterror: String   = ""Error""     const val ctact: String     = ""Act""     const val cttrue: String    = ""true"" // ?",0.35,Kotlin
15qxqf9,jw60eso,"This is also allowed in a lot of the ML family, including Haskell and OCaml",0.0,Haskell
15qxqf9,jw8por4,So ... really doubling down on Perl then?,0.022222222222222213,Perl
15qxqf9,jwfbbf8,"Hm, this is in many ways as beautiful as I would expect from something descended from Perl, and also as godawful ugly as something descended from Perl.",0.2166666666666667,Perl
15qxqf9,jw90l6p,"APL, as I recall, has lots of strange characters, but tokenizing them is easy - just treat each oddball character as a token.",0.19166666666666668,APL
15qxqf9,jw9sxfe,Similar to C#,0.0,C
15qxqf9,jw8calp,Ruby too.,0.0,Ruby
15qxqf9,jw73zvf,"Some C examples:  * `for` is a reserved word, but if the next character is `m`, now you've go the identifier `form`.",0.0,C
15qxqf9,jw73zvf,I suspect the *actual* answer is that early Fortran's had this restriction to work around [Fortran's other absolutely crazy rules around whitespace and keyword lexing](https://stackoverflow.com/a/5793730/9457).,-0.15625,Fortran
15qxqf9,jw67439,Ruby too,0.0,Ruby
15qxqf9,jw5xz3h,Elixir  I also like the !,0.0,Elixir
15qxqf9,jw8m019,Julia can use `!` so I think maybe `?` too.,0.0,Julia
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,Ruby
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,Scheme
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,Clojure
15qxqf9,jw99whs,"The problem is it clashes with the nullability/safe navigation/null coalescing syntax in C# and TypeScript, which is also neat.",0.0,C
15qxqf9,jw99whs,"The problem is it clashes with the nullability/safe navigation/null coalescing syntax in C# and TypeScript, which is also neat.",0.0,TypeScript
15qxqf9,jw946ad,"To bring this into sharp focus, compare and contrast Raku with both Perl and another old PL that *did* double down on what it thought was a good design that turns out not to be:  * **Unicode** Basic string functions in Python 3 *corrupt* Unicode strings.",0.002777777777777768,Perl
15qxqf9,jw946ad,"To bring this into sharp focus, compare and contrast Raku with both Perl and another old PL that *did* double down on what it thought was a good design that turns out not to be:  * **Unicode** Basic string functions in Python 3 *corrupt* Unicode strings.",0.002777777777777768,Python
15qxqf9,jw946ad,"India is one of the largest nations on earth yet the Python code `'झंडा 🇮🇳'[::-1]`, which reverses a string containing the Hindi word for ""flag"" alongside India's flag, turns their flag into Nicaragua's, and the Indian characters into gibberish!",0.0,Python
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,Perl
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,Python
15qxqf9,jw946ad,* **Backward compatibility** Python 3 can't use Python 2 modules.,0.0,Python
15qxqf9,jw946ad,And Python 3 modules.,0.0,Python
15qxqf9,jw946ad,"Plus Perl modules, including XS ones.",0.0,Perl
15qxqf9,jw946ad,"* **Concurrency** Python 3 has finally gotten an accepted PEP to remove its GIL, with a hoped for time frame of about 5 years if it isn't backed out, a first tentative step in the long road to sensible concurrency solutions.",0.06666666666666667,Python
15qxqf9,jw946ad,"Perl's status is similarly behind the times, but also with plans to catch up.",-0.4,Perl
15qxqf9,jw946ad,"You *may* have been talking about Raku's parsing approach, syntax, and extensibility ""doubling down"" on Perl.",-0.15555555555555559,Perl
15qxqf9,jw946ad,Perl's parsing approach was LALR.,0.0,Perl
15qxqf9,jw946ad,Perl's syntax was a mishmash.,0.0,Perl
15qxqf9,jw946ad,Perl's extensibility was ad hoc.,0.0,Perl
15qxqf9,jw9fxz0,"Scheme, Racket and Common Lisp here treat `x'` as that the quote begins shorthand for `quote` of another form.",-0.3,Scheme
15qxqf9,jw9fxz0,"Scheme, Racket and Common Lisp here treat `x'` as that the quote begins shorthand for `quote` of another form.",-0.3,Lisp
15qxqf9,jw99xy2,Perl is doubling down on being terse and powerful and completely unreadable.,0.08148148148148147,Perl
15qxqf9,jw99xy2,"My own language reads a lot like pseudocode, or Python, and my variable and function names are verbose, because that's what suits me.",0.6,Python
15qxqf9,jw99xy2,"For me, that example of Raku is like an example of APL or indeed any time I have to do a regex.",0.0,APL
15qxqf9,jwhtvgv,It works fine in Clojure.,0.4166666666666667,Clojure
15qxqf9,jwcpesw,"> What I mean is for example         déjà-vu»⚛++    > Perl is doubling down on being terse and powerful and completely unreadable  Perl might, but Raku isn't.",-0.01701388888888889,Perl
15qcea4,jw4vwsc,as done in TypeScript).,0.0,TypeScript
15qblhm,jw367vc,"Zig is the most promising alternative-to-C I've ever seen, as they stick to C's philosophy, fix a lot of traps and solve one of it's biggest issue: tooling.",0.35,C
15q5877,jw23e09,Ruby can be used to do all of that too.,0.0,Ruby
15q2ljm,jw0mdp0,While it is about Lisp I think the thoughts expressed concern any language.,0.0,Lisp
15q2ljm,jw0mdp0,"I found it quite inspiring in general, not just particularly about Lisp.",0.2388888888888889,Lisp
15pfiig,jvz1x38,Do C people even know anything about successful language design?,0.75,C
15pfiig,jvz1x38,"C was successful, but that's mostly because of Unix, not on its own merits.",0.6166666666666667,C
15pfiig,jwqqiic,"Even so, he is not flawless, and as I mentioned in a recent comment somewhere, I believe his paper/article *Why Pascal is not my favorit programming language* unfairly hurt Pascal and also Pascal-derived languages quite a lot, this being one of several factors that helped C in out-competing Pascal and conquering the world around the end of the 1980es.",-0.25,Pascal
15pfiig,jwqqiic,"Even so, he is not flawless, and as I mentioned in a recent comment somewhere, I believe his paper/article *Why Pascal is not my favorit programming language* unfairly hurt Pascal and also Pascal-derived languages quite a lot, this being one of several factors that helped C in out-competing Pascal and conquering the world around the end of the 1980es.",-0.25,C
15pfiig,jwqqiic,"(Other things being for example Ron Cain's Small-C, GNU and GCC, and the close bonds between C and Unix, including the BSD distributions.",-0.125,C
15pfiig,jwqqiic,"Ratfor was used in BWK's book *Software Tools*, and the Pascal article was written after rewriting the book for Pascal: *Software Tools In Pascal*.)",0.0,Pascal
15pfiig,jvz5uht,Isn’t the success of Unix partly because of C as well?,0.3,C
15pfiig,jw0tzwj,I think you have to judge the design of C within the context in which it came into being and was originally used.,0.375,C
15pfiig,jw0tzwj,"Many languages designed to solve many of the same problems were invented before and after C, and yet C won the day.",0.3333333333333333,C
15pfiig,jw0tzwj,"It's true that the history of C and Unix are intimately intertwined, but I don't think the success of C is explained completely by the fact that it was used in Unix (and vice versa).",0.23750000000000002,C
15pfiig,jw0y3qo,I'm sure C was successful for it's own merits.,0.6166666666666667,C
15pfiig,jw0y3qo,Back then everything was in assembly and it wasn't hard to mix assembly with C and you can easily imagine what assembly your compiler would produce with the C code,0.04722222222222222,C
15pfiig,jw1mwb3,"/s  ""C people"" most likely know more about computer science than most who would resort to calling them ""C people.""",0.375,C
15pfiig,jvzuk7t,"Sure, and although I like C, my opinion is that unix's success due to C was more because of timing.",0.29375,C
15pfiig,jw0eu97,"The shortcomings of C are obvious to most, you don't need to be an expert.",0.25,C
15pfiig,jw0eu97,"C emerged around 1972, I started developing my own systems language around 1982, and right now the latest version is still going strong.",0.45476190476190476,C
15pfiig,jw0eu97,"I can spend all day telling you all the things that C did badly, sometimes laughably so.",-0.5999999999999999,C
15pfiig,jw0eu97,"But of course, my own private language is not used by anybody, while C runs half the world.",0.14444444444444446,C
15pfiig,jw0eu97,So you can certainlly call C 'successful'.,0.75,C
15pfiig,jvzumz9,"Yes, but it was also way more portable to other hardware platforms because of C so had more opportunity to grow.",0.2916666666666667,C
15ouf0b,,Dart:  `if (string is!,0.0,Dart
15ouf0b,,"empty) return null`  Kotlin:  `if (string !is empty) return null`  Perhaps we can also support negation before the predicate function like so:  `if (string is !empty) return null`   And if the predicate takes additional arguments, the subject must be the first argument, and the syntax would work like so:  `function longerThan(string, length): boolean { ... }`  `if (string is longerThan(5)) return null`   I think it's not a complicated syntax sugar to implement in a language but it helpes readability.",-0.002777777777777768,Kotlin
15ouf0b,jvu038d,But fair warning: The logical conclusion of that pursuit is COBOL.,0.475,COBOL
15ouf0b,jvu038d,"And oh yes, the bank is still running COBOL on mainframes after oh these many moons.",0.5,COBOL
15ouf0b,jvveqay,"For example, the Java `instanceof` syntax (very similar to the above) is horrid, and requires all sorts of extra parenthesis for no good reason.",-0.0875,Java
15ouf0b,jvu96xn,I like the Scheme convention of using a ?,0.0,Scheme
15ouf0b,jvu9u1o,"If you look at Rust syntax where the outer parenthesis is optional, it will look more readable.",0.5,Rust
15ouf0b,jvtxb7f,I was just thinking about Dart and Kotlin cuz I am a mobile dev haha.,0.2,Dart
15ouf0b,jvtxb7f,I was just thinking about Dart and Kotlin cuz I am a mobile dev haha.,0.2,Kotlin
15ouf0b,jvuj5op,"Ruby too `""string"".empty?`.",0.0,Ruby
15ouf0b,jvv3x7q,"I'm aware of Perl and Ruby, and in both you can have an `else` block if you want, although it is discouraged by some as being difficult to read.",-0.125,Perl
15ouf0b,jvv3x7q,"I'm aware of Perl and Ruby, and in both you can have an `else` block if you want, although it is discouraged by some as being difficult to read.",-0.125,Ruby
15ouf0b,jvwbb5u,"Well, back when I began reading about programming, COBOL was still a very common thing - ""ordinary"" programmers would typically use it in banks, businesses big enough to have an EDP-department (no IT back then!",-0.11523809523809524,COBOL
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,COBOL
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,APL
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,Pascal
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,Ada
15ouf0b,jvwbb5u,"In a way it reminds me most of C enums used as bit masks combined with for example integers, to represent flags or states of an object.",0.5,C
15ouf0b,jvwbb5u,"What I like about the COBOL level 88 ""condition names"", is that even though you use something like an enum, you don't need to make an explicit comparison.",0.0,COBOL
15ouf0b,jvxm8nu,"And I think you've pretty much affirmed that ""special syntax for predicates"" is a COBOL idea.",0.26904761904761904,COBOL
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,COBOL
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,Python
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,PHP
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,Go
15ouf0b,jvxm8nu,At least with COBOL it's not unfamiliar web frameworks and magical metaprogramming.,0.1,COBOL
15oi4b4,jvsg5ik,"But apparently you want your language to look like APL since you don't like keywords, so ...",0.05,APL
15oi4b4,jvua1k5,"https://www.postgresql.org/docs/15/functions-geometry.html  Ruby just has methods [1,2,3].include?",0.0,Ruby
15oi4b4,jvyvdbn,Julia does this,0.0,Julia
15oi4b4,jvsiqta,APL.,0.0,APL
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Lisp
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Haskell
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Rust
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Swift
15o64p8,jvr73jn,You might want to take a look at [Ruby's switch expression](https://www.rubyguides.com/2015/10/ruby-case/) (and the `===` method too).,0.0,Ruby
15o64p8,jvyvjr5,C# has a similar feature.,0.0,C
15o64p8,jvseryg,C# and Rust both have a take on this in each their own way.,0.6,C
15o64p8,jvseryg,C# and Rust both have a take on this in each their own way.,0.6,Rust
15o64p8,jvseryg,Rust is hard-line keyword-first but omits parentheses.,0.0,Rust
15o64p8,jvseryg,C# has the `<expression> switch { <cases> }` structure taken from Scala.,0.0,C
15o64p8,jvseryg,C# has the `<expression> switch { <cases> }` structure taken from Scala.,0.0,Scala
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,Rust
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,Ruby
15o4pr5,,"Here I rewrite a few constructs from a C like language using these 7 controls (exit is used to indicate exiting out of ladder (similar to break), fallthrough is used to indicate exiting out of current block and continuing (similar to continue)):      1.",-0.05,C
15o4pr5,jvpuj9u,"Otherwise you can't access variables in `if` block from `then if` block, which would have been possible in corresponding C style code shown above.",0.0,C
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,Lisp
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,JavaScript
15o4pr5,jvsa4o7,">     if cond1 { >         stmt1; >         if cond2 do >         stmt2; >         stmt3... >     } elif cond3 { >         stmt4... >     }  Another construct for reducing nesting subsumed by this idea is Rust's `let else` (just use a `do` in the last, happy branch of pattern matching).",0.4,Rust
15o4pr5,jvtz1w0,(viz: PHP and the ternary `?`/`:` operator.),0.0,PHP
15o4pr5,jvtz1w0,The *goto fail* bug was basically a clerical error in a hand-rolled version of `if-also` done in C with `goto` and labels.,-0.5,C
15o4pr5,jvreiap,Most families taking after C stop at about this point.,0.5,C
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,C
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,C++
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,Java
15o4pr5,jvreiap,"Contrast this to Rust (or most functional languages) -- the above does make sense, because `if` is an *expression*.",0.25,Rust
15o4pr5,jvreiap,"Additionally, this lets you do things like the following (Rust syntax): ``` let some_var = {     let temp = produce_temp_value();     let another = temp.do_thing();     another + 3 }; ``` Helpful for correct scoping of temporary values without having uninitialized variables.",0.0,Rust
15o4pr5,jvreiap,[The Rust Book](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html#statements-and-expressions) has some more explanation.,0.5,Rust
15o4pr5,jvs2m57,"Rewriting that example using `thif` would be ``` if primary:     prelude thif secondary:     main code elif nextprimary:     next main code ``` I mentioned fallthrough because, if you convert this into C style code, it would be something like ``` if primary:     prelude     if not secondary:         # <fall> or <continue> or <skip> or whatever that makes the control to go back searching for next match in ladder (which is not present in C or any major languages that I know of)     main code elif nextprimary:     next main code ```  Sorry if my explanation is unclear again :|",0.05861111111111113,C
15o4pr5,jvsp3xp,The above version using Python style is the same.,0.0,Python
15o42wx,,where at global scope use can precede declaration) that also uses the template syntax that C++ and many other languages use?,0.125,C++
15o42wx,,I know C++ compilers resolve this issue be maintaining a table of all template declarations and when a template name appears `<` is parsed as an opening bracket for template parameters.,0.0,C++
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,Rust
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,C++
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,C
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,Java
15o42wx,jvzqt1o,"So, in Rust:   - In a _type_ context, angled brackets are just used as is: `Generic<Parameter>`.",0.0,Rust
15o42wx,jvzqt1o,I would recommend -- if you want to stick to angled brackets -- to do it like Rust.,0.0,Rust
15o42wx,jvzqt1o,"Not only because you'll get your order free parsing, but also because Rust users will already be familiar with it.",0.25833333333333336,Rust
15o42wx,jvr7n0s,"In my language transpiled to C++ I handle it in a pre-parse step (I use a peg that doesn't require a separate lexer but I preprocess for indent checking and a few other things):  Roughly, upon encountering balanced `<` and `>,` check if either a `(` `{` or `[` follows the closing `>`.",-0.1416666666666667,C++
15o42wx,jvr7n0s,"Also, `1 < 2 > (0)` is an error unlike in C++ (`1 < 2 > 0` is fine).",0.4166666666666667,C++
15o42wx,jvr7n0s,"On the upside, this parses both     `value = 1 + number_of_bits<number >> 1>::value // fine in c++03, fails c++11`  and  `value = 1 + number_of_bits<(number >> 1)>::value // fine any std`     https://stackoverflow.com/questions/31447039/valid-c03-template-code-wont-compile-in-c11  (I want to de-emphasize the use of < and > in C++ anyway partly by going crazy with CTAD but I still want the < and > syntax mainly for interfacing with 3rd-party code)",-0.01999999999999999,C++
15o42wx,jw157dm,It's a bit frustrating though that this problem is apparently so hard that even the Rust people decided to introduce different syntax to simplify parsing.,-0.23055555555555554,Rust
15o1wxa,jvvjep6,"By the way, if you are interested in garbage collectors, as you seem to be, they are just implementing a new garbage collector for sbcl (a Common Lisp compiler).",0.02878787878787879,Lisp
15o1wxa,jvqg7j5,"As far as I know, there is no non-sweep-time overhead to the Boehm GC, other than the normal overhead of allocating memory (and I think Boehm's `GC_malloc` runs faster than the C stdlib `malloc`).",0.041666666666666664,C
15o1wxa,jvqg7j5,"In fact, you can take a large C program and replace `malloc` with `GC_malloc` (and delete calls to `free`) and it will compile and run with no differences to the generated machine code besides which function is being called (and the lack of `free`s).",0.30714285714285716,C
15o1wxa,jynxm3j,"Look at [SGCL](https://github.com/pebal/sgcl), it's real-time GC for C++ without pauses, locks and tags.",0.0,C++
15o1wxa,jvyd8lz,"Cliff (who wrote the Hotspot JIT compiler for Java) now runs the Coffee Compiler Club ([https://www.youtube.com/@compilers]), is working (with me :-) on building the [Ecstasy](https://github.com/xtclang/xvm) back-end, and in his spare time is designing/building a low level language with global type inference called [AA](https://github.com/cliffclick/aa).",0.16666666666666666,Java
15o1wxa,jvvr44u,"All spilling decisions are made by codegen, the same way as in a plain C backend, without any consideration for relocation.",-0.10714285714285714,C
15o1r70,jvr5o8o,"It's true, I'm not a fan of Perl ...",0.35,Perl
15o1r70,jvuezri,"Now the point of this is that someone can declare for example:      languages          Forth  Forth is just an example, there's no particular use-case.",-0.08333333333333333,Forth
15o1r70,jvuezri,"But anyone who wanted to could, and then the `---` constructor will do the same things but with type `Forth`.",0.0,Forth
15o1r70,jvuezri,"So then can then overload `get` to interact with something that actually knows Forth, and start writing stuff like      x = 2     y = 3     get result from Forth --- x y +     post result to Output() // prints 5  A more realistic use-case is that people may want to talk to non-SQL databases.",0.2222222222222222,Forth
15njznz,jvmeu53,"Liquid Haskell is an example of a tool for adding refinement-type annotations to Haskell code, which you might like to look at for ideas.",0.0,Haskell
15njznz,jvmeu53,Ada also has integer range types like this.,0.0,Ada
15njznz,jvnb8em,"In Ada, these constraints are called subtype predicates :  http://www.ada-auth.org/standards/12rat/html/Rat12-2-5.html",0.0,Ada
15njznz,jvmxlxr,"The below is a syntax I'm working on:  ``` val :: String where str -> str.length in (5 to 10) myString = ""abcdefg""  # constraints are prohibited in type annotations val myOtherString :: String = ""xyzabc"" ```  The first line is a type signature similar to the ones you'll find in Haskell and the like.",0.125,Haskell
15njznz,jvqbvo1,I use it in C# all the time for model validation.,0.0,C
15njznz,jvqsv8e,Side note 2: Saline's refinement type's syntax is inspired from Liquid Haskell (which has been mentioned in another comment) with little tweaks to make it (in my opinion) more logical.,0.1875,Haskell
15njznz,jwlcsfj,"I know people have explored similar ideas for stack languages (I think Christopher Diggins for Cat, Daniel Ehrenberg for Factor, and maybe Anton Ertl for Forth) but I don’t have good references offhand, and I don’t think anyone’s gotten very far with it, but I’d be interested to try using a system like that.",0.27,Forth
15nj1xx,,"As I mentioned in my comment, I sometimes would like to use a function defined by a table as a function argument, but I don't know of any languages that would actually allow this, certainly JavaScript doesn't.",0.10714285714285714,JavaScript
15nj1xx,jvm9cy7,"She had a background in mathematics and apparently no qualms to prefer 'call' over 'apply'  In JavaScript functions can be called directly (of course) and also by their `call()` and `apply()` methods, whose semantics differ slightly.",-0.030555555555555548,JavaScript
15nj1xx,jvmbki3,"[Calling a function seems to be an artefact from Fortran, but I'm not sure.",-0.25,Fortran
15nj1xx,jvok55j,"In languages where functions are or may be lazy, like Haskell or Mathematica, people do call it a “function call” less often, I would say.",-0.20833333333333331,Haskell
15nj1xx,jvpjpk0,"Fortran orignally distinglished between functions (which returned a value and could appear in expressions), which did mimic functions like ""sin(x)"" and could appear in expressions and subroutines (which returned nothing but could change their byref parameters).",0.0,Fortran
15nj1xx,jvop64b,"In functional languages, like Haskell, functions really are functions in the mathematical sense.",0.1,Haskell
15nj1xx,jvop64b,"In fact, in lazy functional languages like Haskell, there is no guarantee that the code will be executed even once; if the result isn’t needed it won’t be invoked and if only parts of the result are needed only those parts of function will be executed.",-0.08333333333333333,Haskell
15nj1xx,jvop64b,"Even traditional procedures (like print) are, thanks to the magic of monads, genuine functions in Haskell.",0.275,Haskell
15nj1xx,jvpog0q,"What I mean is that, in one sense it is probably true, but in that sense it would also be true of procedural languages, as it is definitely possible to implement mathematical functions in them: for example a variable **var** *f*: **array**\[1..*n*, 1..*m*\] of 1..*k* in Pascal can represent *any* mathematical function f(i,j) of two natural variables i <= n, j <= m, to the subset of the natural numbers less than k. (I don't think you were the person who recently insisted in a comments section, that integers in programming languages weren't integers, otherwise this conversation would be rather pointless and futile.)",0.015530303030303026,Pascal
15nj1xx,jvpog0q,"So in this sense, again, Pascal (or procedural languages in general) does not ""truly"" model mathematical functions, but then I have my doubts that Haskell and other functional languages can rightfully claim to do so.",-0.024999999999999994,Pascal
15nj1xx,jvpog0q,"So in this sense, again, Pascal (or procedural languages in general) does not ""truly"" model mathematical functions, but then I have my doubts that Haskell and other functional languages can rightfully claim to do so.",-0.024999999999999994,Haskell
15nj1xx,jvroeoj,"Algol 60 originally used the word **procedure** (Algol 68 cutting it down to **proc**), but when NIklaus Wirth designed Pascal based on his Algol W dialect, he chose to differentiate by using the keyword **function**.",-0.032638888888888884,Pascal
15nj1xx,jvroeoj,"Interestingly, Ada retains the **function** keyword from Pascal, without requiring absence of side effects.",0.24375,Ada
15nj1xx,jvroeoj,"Interestingly, Ada retains the **function** keyword from Pascal, without requiring absence of side effects.",0.24375,Pascal
15nj1xx,jvqagyk,If I write down a Haskell function defining the fibonacci or factorial function(!),-0.07777777777777779,Haskell
15nj1xx,jvzpgvu,Languages like Haskell have laws like  > map f .,0.0,Haskell
15nj1xx,jvrtvt6,"One way to boil down the issue is to ask the question: is it necessary to have a ""real functional programming language, like Haskell"", to do functional programming?",0.014814814814814808,Haskell
15nj1xx,jvv5yf6,Wanna interface with C or some kind of ASM?,0.6,C
15nj1xx,jvzek60,"Then C, being low level and simple, just disallowed nested ""functions"", reducing the problem to global variables and variables in nested blocks that always belong to the same activation.",0.0,C
15nj1xx,jvzek60,"And now we have architectures that can't support the GNU C ""nested functions"" extension, because it uses an implementation technique that creates problems with function pointers.",0.0,C
15nj1xx,jvzek60,"And the ""new old-school"" people, who just adopted the word ""function"" because the language they are using descends from C and has inherited C's term, for something that used to be called subroutine, routine, procedure, or (in Ada for example) sub-program.",0.13636363636363635,C
15nj1xx,jvzek60,"And the ""new old-school"" people, who just adopted the word ""function"" because the language they are using descends from C and has inherited C's term, for something that used to be called subroutine, routine, procedure, or (in Ada for example) sub-program.",0.13636363636363635,Ada
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,Rust
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,Go
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,Python
15n31u1,,I guess there's some backlash against things like Python's `async` / `await` stuff.,0.0,Python
15n31u1,,"](https://en.wikipedia.org/wiki/The_Sneetches_and_Other_Stories) And in fact the *What color...* author seems to agree, highlighting *Go* as a good example.",0.7,Go
15n31u1,jvjz80j,"You can pretty easily model Promises with channels [https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec](https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec)  As far as I know, Erlang has a similar model where everything is sent as messages to specific addresses instead.",0.15666666666666668,Erlang
15n31u1,jw1315g,"I am eliminating it in my language and adopting a structured concurrency approach (see [Notes on structured concurrency, or: Go statement considered harmful](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)).",0.0,Go
15n31u1,jw1315g,"Basically, doing something like Go's green threads, but instead of the `go` keyword as done in Go, I have async scopes.",-0.2,Go
15n31u1,jvkebho,"In many languages (including Go, as you mention), either by language definition or by convention, you never really have to choose between multiple threading runtimes, so there's not really a need for async.",0.07500000000000001,Go
15n31u1,jvm3o28,I'd recommend taking a look at [Lua's Coroutines](http://lua-users.org/wiki/CoroutinesTutorial).,0.0,Lua
15n31u1,jvm3o28,"Lua's solution to this problem is to allow creating a coroutine with `co = coroutine.create(fn)` and then hand off control to the coroutine by calling `coroutine.resume(co, args...)`.",0.0,Lua
15n31u1,jvm3o28,"All of this is accomplished using regular functions, there is no syntactic element for `async` or `go`, there are just ordinary functions (implemented in C), which stash local execution state and hand off control to a different execution state until control returns with a return value.",-0.009999999999999998,C
15n31u1,jvm3o28,"Lua's model uses single-threaded cooperative concurrency, but there are third-party libraries like [LuaThread](https://hserg.github.io/luathread-website/examples.html) that add support for pthreads with a similar level of simplicity in API design and without language extensions.",0.0,Lua
15n31u1,jvo0qpu,"When you invoke a method that exists within a different `service` (equivalent to an Erlang ""process""), the result is a future, and the invocation is asynchronous.",0.0,Erlang
15n31u1,jvm1mmx,"In the case of C# and Kotlin, it's because the built-in thread types are too heavyweight to scale, so async/await allows a large number of ""tasks"" to be multiplexed onto a smaller number of real threads.",0.13809523809523808,C
15n31u1,jvm1mmx,"In the case of C# and Kotlin, it's because the built-in thread types are too heavyweight to scale, so async/await allows a large number of ""tasks"" to be multiplexed onto a smaller number of real threads.",0.13809523809523808,Kotlin
15n31u1,jvm1mmx,"I can't say why Python adopted it, but presumably for similar reasons to JS.",0.0,Python
15n31u1,jvm1mmx,"Languages like Erlang and Go adopted a different model from the start, with comparatively lighter-weight threads (i.e.",0.0,Erlang
15n31u1,jvm1mmx,"Languages like Erlang and Go adopted a different model from the start, with comparatively lighter-weight threads (i.e.",0.0,Go
15n31u1,jvm1mmx,"Java's taking an interesting approach - they're switching the built-in thread concept from something always backed by an OS-level thread to something that *can* be backed by an OS-level thread, but can also be a lightweight thread.",0.5,Java
15n31u1,jvm1mmx,"In the rules of Go, `quux` can certainly call `foo` synchronously.",0.21428571428571427,Go
15n31u1,jvkeohg,"In Kotlin, all functions are synchronous.",0.0,Kotlin
15n31u1,jvl3sgh,"Erlang uses a particular interpretation of the Actor model, which is asynchronous with unbounded mailbox size.",0.16666666666666666,Erlang
15n31u1,jvl3sgh,"This is somewhat but not completely analogous to Go's take on CSP, which is synchronous with bounded channel size.",-0.05,Go
15n31u1,jvl3sgh,"Erlang provides something akin to that with `gen_server:call`, although it also enforces deadlines whereas Go's channels can easily deadlock.",0.43333333333333335,Erlang
15n31u1,jvl3sgh,"Erlang provides something akin to that with `gen_server:call`, although it also enforces deadlines whereas Go's channels can easily deadlock.",0.43333333333333335,Go
15n31u1,jvl3sgh,"However, Erlang can also express asynchronous patterns which aren't possible with Go channels.",0.0,Erlang
15n31u1,jvl3sgh,"However, Erlang can also express asynchronous patterns which aren't possible with Go channels.",0.0,Go
15n31u1,jvl3sgh,Personally I prefer the Erlang model although I do find the unbounded mailbox size something of a footgun.,0.0,Erlang
15n31u1,jvl3sgh,"(Distributed Erlang opts for the latter when network buffers are full, FWIW)",0.175,Erlang
15n31u1,jvlujez,"Think about how it works in JavaScript for example; instead of the old idiom of passing callbacks to perform at some point in the future, we pass the current continuation.",0.03333333333333333,JavaScript
15n31u1,jvlujez,"And because this is JavaScript we're not talking about multiple JavaScript threads, we're really talking about 0 or 1 JavaScript threads.",0.1,JavaScript
15n31u1,jvnwpac,And it seems Go provides a single standard scheduler implementation (despite not having those particular keywords).,0.031746031746031744,Go
15n31u1,jvnwpac,"I don't see the `go` keyword as being *semantically* tied to whichever scheduler Go currently sports; just as a way of saying ""go do this in a separate thread of control"" which up to Rob Pike to solve.",0.0,Go
15n31u1,jvo4cqq,The most annoying thing about Python generators is/was how difficult they are to compose.,-0.26666666666666666,Python
15n31u1,jvp6sor,"> I don't see the `go` keyword as being semantically tied to whichever scheduler Go currently sports; just as a way of saying ""go do this in a separate thread of control"" which up to Rob Pike to solve.",0.0,Go
15n31u1,jvp6sor,"I think your point is that Go's scheduler can be thought of as some global compile-time constant, which could be set to something else.",0.0,Go
15n31u1,jvv96eh,"Virtual threads in Java work like that, for instance.",0.0,Java
15n31u1,jvxbc2x,"> Virtual threads in Java work like that, for instance.",0.0,Java
15mqi66,,"If not, and I doubt it doesn't, is this appliable to C++?",0.0,C++
15mqi66,,"PS: The parser I wrote (for C only) correctly parsed raylib.h and cimgui.h (so the failing case may be rare, but not sure about this)",0.016666666666666663,C
15mqi66,jvl2nwz,"Because it might just look like this:      A B;  I also support out-of-order declarations (not for C), and what I have to do is tentatively assume that with two successive identifiers like `A B`, the first is a type `A` to be subsequently defined.",0.125,C
15mqi66,jvl2nwz,"(Better in my syntax is to write `var A B`, which is also possible, or even `var B:A`, but if parsing existing C, you don't have that option.)",0.25,C
15mqi66,jw7g2na,C grammar is ambiguous without the lexer hack.,0.0,C
15mqi66,jw7g2na,"IOW, order-free parsing of C is not feasible in the general case.",0.05000000000000002,C
15mqi66,jvhyh2c,"It means type specifier, if you search for the C syntax nbf and look at `specifier :=` you understand better.",0.5,C
15mqi66,jvl8hyh,"In C, new type identifiers that can start a declaration by themselves (so don't need `struct` or `enum`) I think are only introduced by `typedef`.",0.06818181818181818,C
15mqi66,jvl8hyh,"But there is an ambiguity: if this new C syntax now allows out-of-order declarations, is the first `A` that visible from the outer scope, or is it intended to be the one defined later?",0.12878787878787878,C
15mqi66,jvlb2mb,"about the `const A typedef B` is parsed correctly as well just because typedef is a type qualifier (or something) and is exactly like writing `const` (look at the c bnfs, which I followed at the 100%, except for the typedef-name, which I recognize using this trick and not the classical lexer hack used by major compilers, which doesn't allow out of order decls)  thanks for the reply, my question also was, if this works correctly with C will it work for C++ as well?",0.128125,C
15mqi66,jvlb2mb,"about the `const A typedef B` is parsed correctly as well just because typedef is a type qualifier (or something) and is exactly like writing `const` (look at the c bnfs, which I followed at the 100%, except for the typedef-name, which I recognize using this trick and not the classical lexer hack used by major compilers, which doesn't allow out of order decls)  thanks for the reply, my question also was, if this works correctly with C will it work for C++ as well?",0.128125,C++
15mqi66,jvlb2mb,"since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C++
15mqi66,jvlb2mb,"since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C
15mqi66,jvlb2mb,however the huge set of syntax feature C++ has more than C scares me,0.45000000000000007,C++
15mqi66,jvlb2mb,however the huge set of syntax feature C++ has more than C scares me,0.45000000000000007,C
15mqi66,jvm0tag,">since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C++
15mqi66,jvm0tag,">since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C
15mqi66,jvm0tag,"The first large C project I wrote, I used a thin syntax wrapper.",0.021428571428571425,C
15mqi66,jvm0tag,"It wrote out the proper C file `prog.c`, `prog.cl` containing declararations for local functions, and `prog.cx` for exported ones.",0.0,C
15mqi66,jvm0tag,"(As for C++, I doubt you will get far with that.",0.1,C++
15mqi66,jvmcil3,"Sorry, I don't know any C++ at all.",-0.5,C++
15mqi66,jvmcil3,Tweaked versions of both C and C++?,0.0,C
15mqi66,jvmcil3,Tweaked versions of both C and C++?,0.0,C++
15mqi66,jvmcil3,Or a new language that looks like C and/or C++?,0.13636363636363635,C
15mqi66,jvmcil3,Or a new language that looks like C and/or C++?,0.13636363636363635,C++
15mqarm,jvi62k3,You'd be surprised how easy it is to get used to typing these when programming in languages descended from C.,0.26666666666666666,C
15mqarm,jvi4h9f,[REBOL](https://rebol.com/) is derived from Lisp and Logo and uses square brackets for blocks  [Red](https://red-lang.org/) is derived from REBOL and uses square brackets for blocks.,0.0,Lisp
15mqarm,jvi4h9f,"[Tcl](https://en.wikipedia.org/wiki/Tcl) uses square brackets for command substitution, executing commands inside.",0.0,Tcl
15mqarm,jvke74y,"I do very little with curly brackets, currently only for dict lookups: `D{k}`, other uses are up for grabs.",-0.12291666666666667,D
15mqarm,jvke74y,At one point they were used for block comments (following Pascal).,0.0,Pascal
15mqarm,jvhy0o9,"Following this line of thought, isn't indentation-based syntax (like in Python) just as good, as it requires no brackets at all?",0.35,Python
15mqarm,jvkhx64,"Objective-C used square brackets for method invocation and ""people"" hated it.",-0.9,Objective-C
15mqarm,jvkhx64,"Its almost the solely reason why Swift was invented, so no they can write `hello.to(world);` sigh.",0.0,Swift
15mqarm,jvkue4i,Scala 3 got rid of curly braces by introducing alternative syntax based on indentation.,0.0,Scala
15mqarm,jvi41go,"Yep  Tcl also uses square brackets and might be the most popular language with the convention  Also my language dt went for square brackets, but in my case the design decision was more about avoiding collision with what shells will ""preprocess"" with (...) and {...} globbing and expansion semantics -- square brackets also have semantics there too, but are less likely to collide",0.2866666666666667,Tcl
15mqarm,jvjwhci,"On the contrary, Python in particular uses brackets every now and then for grouping multi-line code.",0.16666666666666666,Python
15mqarm,jvmivix,"Haskell also allows both styles, but Haskell has had that from the start, and most people use the off-side rule unless they're doing something like writing a short do-block on one line.",0.25,Haskell
15mqarm,jvmivix,"I feel like ""allowing both styles"" is harmful if people don't just standardize on one style (as has happened in Haskell.)",0.0,Haskell
15mqarm,jvmivix,"Scala simply can't do that because of its history - it started with curly brackets only, and as of Scala 3, the language designer is recommending that everyone should use the off-side rule instead.",0.0,Scala
15mqarm,jvmivix,"The result is that both styles will be common, and Scala basically looks like 2 different languages now.",-0.15,Scala
15mqarm,jvmivix,That's why he thought it was important enough to add it to Scala 3.,0.2,Scala
15mqarm,jvoazlx,Haskell uses parentheses for these.,0.0,Haskell
15mqarm,jvoazlx,"Importantly, `[-1]` is a valid lambda, while Haskell's `(-1)` is just a negative number.",0.05000000000000002,Haskell
15mqarm,jvrc7jr,Wait what Haskell styles are you talking about?,0.0,Haskell
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Swift
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Kotlin
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Scala
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Crystal
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Python
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Julia
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,C
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Julia
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Swift
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Python
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Scala
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Kotlin
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Crystal
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,C
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Swift
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Julia
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Crystal
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Python
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Kotlin
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Scala
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,C
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Swift
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Julia
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Kotlin
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Scala
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,C
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Crystal
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Python
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Swift
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Julia
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Kotlin
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Scala
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,C
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Crystal
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Python
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Swift
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Scala
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Kotlin
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Julia
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Crystal
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Python
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,C
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Scala
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,C
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Kotlin
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Python
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Swift
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Crystal
15mnp7h,,"Calling it with the parent's param name invokes the parent's implementation, essentially bypassing the ""override"" altogether   - n/a     - Julia, OCaml  ### Optional/default parameters  #### When declaring an optional param, are there restrictions on where it can be in the overall parameter list?",0.0,Julia
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Kotlin
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Scala
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Swift
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Python
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Crystal
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,C
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Julia
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Kotlin
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Crystal
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Julia
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Scala
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Python
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Swift
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,C
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Scala
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Crystal
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Swift
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Kotlin
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,C
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Python
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Julia
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Swift
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Julia
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Python
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Kotlin
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Scala
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,C
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Crystal
15mnp7h,jvisokl,"Swift and Crystal also have this, but I don't know of any others.",0.0,Swift
15mnp7h,jvisokl,"Swift and Crystal also have this, but I don't know of any others.",0.0,Crystal
15mnp7h,jvlj3c4,"For example, in R, argument resolution is even more complex than this (they even allow partial name matching and ... arguments) and it's really complex and can lead to some unexpected footguns",-0.019999999999999997,R
15m88y4,jvfzrg1,"Generally, the algorithm looks like this:  * Go through every function with a matching name * Check if the provided arguments are legal for that function * If there are zero matches, it's a compiler error (no such function) * If there is exactly one match, then you use that function * If there is more than one match, then you pick ""the most specific"" of that set of matches  For example, [here's how to implement the rules specified by Java](https://github.com/oracle/coherence/blob/212681af0cf9b637e0630250f39e829d5b27e0b6/prj/coherence-core/src/main/java/com/tangosol/dev/compiler/java/InvocationExpression.java#L292).",0.21428571428571427,Go
15m88y4,jvfzrg1,"Generally, the algorithm looks like this:  * Go through every function with a matching name * Check if the provided arguments are legal for that function * If there are zero matches, it's a compiler error (no such function) * If there is exactly one match, then you use that function * If there is more than one match, then you pick ""the most specific"" of that set of matches  For example, [here's how to implement the rules specified by Java](https://github.com/oracle/coherence/blob/212681af0cf9b637e0630250f39e829d5b27e0b6/prj/coherence-core/src/main/java/com/tangosol/dev/compiler/java/InvocationExpression.java#L292).",0.21428571428571427,Java
15m77p7,,For example python has a type Path in pathlib to represent path that takes a string in constructor and implement different operations on Path whereas Go has a lib that is directly manipulating strings.,0.05,Go
15m77p7,jvewpyv,"Python's `Path` overloads the `/` operator so you can write `path1 / path2 / 'foo.jpg'` instead of `pjoin(path1, path2, 'foo.jpg')`, and it'll do the right thing -- unlike `path1 + '/' + path2 + '/foo.jpg'`.",0.2857142857142857,Python
15m77p7,jvesgpt,"Python had a library manipulating string paths forever, the `Path` class is a fairly recent introduction.",0.0,Python
15m77p7,jvfssus,"Even in dynamic languages like Python, you will either have your IDE point out obvious errors, or you'll at least get better runtime errors when you have a type mismatch instead of a wrongly formatted string.",-0.06,Python
15m77p7,jvewieq,"(Go, Zig, Pharo, many Lisps, AWK, C, etc) Then no, do not introduce abstractions for something that can already be expressed.",0.5,Go
15m77p7,jvewieq,"(Go, Zig, Pharo, many Lisps, AWK, C, etc) Then no, do not introduce abstractions for something that can already be expressed.",0.5,C
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,Python
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,Rust
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,Java
15m77p7,jvetq22,"The first case is a ""plain alias"" ( Pascal example ):      type         path = string;  But, this allows to use the new type to be used as a the original.",0.1367694805194805,Pascal
15m77p7,jvetq22,"C and Pascal allows to hide the new type:      type        path = forward class;  Another way is to use it indirectly thru a generic pointer:      type        path = pointer;  And, there are several type constructors ( don't confuse with O.O.",0.04545454545454545,C
15m77p7,jvetq22,"C and Pascal allows to hide the new type:      type        path = forward class;  Another way is to use it indirectly thru a generic pointer:      type        path = pointer;  And, there are several type constructors ( don't confuse with O.O.",0.04545454545454545,Pascal
15m77p7,jvesz99,That’s not how Python works.,0.0,Python
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,Rust
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,Haskell
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,Python
15m77p7,jvf3fsh,"A little twist concerning type definitions: some languages, including C and even some Pascal-derivatives, differentiate between type *aliases* and type *names*.",-0.1875,C
15m77p7,jvgpk89,"**  Free Pascal does this, but it's a little ambiguous.",0.10625000000000001,Pascal
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,Pascal
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,Python
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,C
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,Haskell
15m77p7,jvicg3r,"For the boxing part: Scala and Roc have opaque types, and C# has value types that incur no additional allocation.",0.0,Scala
15m77p7,jvicg3r,"For the boxing part: Scala and Roc have opaque types, and C# has value types that incur no additional allocation.",0.0,C
15m77p7,jvicg3r,"It's like in C++: if you want to reference a value via an interface or base type, you gotta use pointers.",-0.8,C++
15m77p7,jvmc24h,"That's usually the best you can do unless you're using a language that allows arbitrary code execution at compile time, such as by using macros in Common Lisp or proc macros in Rust.",0.07,Lisp
15m77p7,jvmc24h,"That's usually the best you can do unless you're using a language that allows arbitrary code execution at compile time, such as by using macros in Common Lisp or proc macros in Rust.",0.07,Rust
15m77p7,jvkpaes,"JS for very small projects because it's absurdly hackable, and Scala for larger projects as a personal preference.",-0.20625,Scala
15lilq6,,"I actually thank the Bejesus to everyone who [uploaded](https://freecomputerbooks.com/langAssemblyBooks.html) this seminal work because the scheme I was coming up with was basically some Rabin-Karp-like heuristic where I would hash all the 900+ odd mnemonics of x86-64 and then what I would have done is some sort of LL(k) parsing wherein every ident ending at "":"" would define a label, and every three-address-style code would be first lexed using C's regex.h library, and if, for example, ""\\w+\\s+\\%\\w+\\s\\%\\w+"" passed the lexical test, I would hash the leading \\w+ and then use a conditional branch for the opcode (ModR/M and the such and so).",0.020833333333333336,C
15l4y21,,So I have three proposals and I'd like your help picking one:**1) mut params**  Like C#'s ref or Swift's inout.,0.0,C
15l4y21,,So I have three proposals and I'd like your help picking one:**1) mut params**  Like C#'s ref or Swift's inout.,0.0,Swift
15l4y21,jvdyg5x,"I get it; every functional programming guru loves Agda, Haskell, and Emacs, but to have it so reliant on Emacs is absolutely absurd.",-0.5,Haskell
15ktb2o,jvgs6ol,"In general, I do agree that supporting multiple versions of a single dependency is necessary; and I love that Rust supports it.",0.12142857142857144,Rust
15ktb2o,jv7ucp4,"Perl also supports backwards and forwards compatibility through language versions, though in a much more dynamic language.",0.25,Perl
15ktb2o,jv9sgqa,I believe Go modules provide support for multiple major versions of a package to co-exist in an application.,0.03125,Go
15ktb2o,jv8918q,"Raku, Perl 7, and JVM bytecode have ideas like this.",0.0,Perl
15ktb2o,jv8918q,"There are some very adjacent ideas like Python and importing from `__future__`  But I haven't read the paper yet, I'm very interested in it!",0.2020833333333333,Python
15ktb2o,jvaxt57,Perl has long had a version literal form that uses that format.,-0.05,Perl
15ktb2o,jvaxt57,"Did you mean more flexible and less sophisticated than the approach/system in Go, Raku or VL?",0.13020833333333334,Go
15ktb2o,jvbqehi,> There are some very adjacent ideas like Python and importing `from __future__`.,0.1,Python
15ktb2o,jvbqehi,Python's `from __future__` is about *language* versions.,0.0,Python
15ktb2o,jvbqehi,"It's a relatively simple thing, enabling one or more features planned for inclusion in a later (probably next) version of Python.",0.125,Python
15ktb2o,jvbqehi,This is like `from __future__` in Python.,0.0,Python
15ktb2o,jvemszq,I wasn't actually aware Go supported using different minor versions at the same time!,0.05,Go
15ktb2o,jvemszq,">Did you mean more flexible and less sophisticated than the approach/system in Go, Raku or VL?",0.13020833333333334,Go
15ktb2o,jvemszq,In comparison to the approach Go takes.,0.0,Go
15kmsjl,jv935uv,"// Nice     struct Person {         string  Name         string  Email         int     Age     }      // Yuck     type person struct {         name std::string;         email std::string;         age int;     };  Also, the example with C's `int* x, y;` is misleading because the problem with C's syntax is the *grouping* of `int (*x), (y);`, not the fact that `int` comes before `x`.",0.6,C
15kmsjl,jv935uv,"It would definitely have been better if C grouped variable declarations as `(int*) (x), (y);` instead.",0.25,C
15kmsjl,jv809sr,The language used has an example (Go language) is inconsistent or verbose.,0.0,Go
15kmsjl,jv809sr,"If the name is more important and has to come first, the rule should be followed for classes and functions as well, but Go uses the syntax `func bar()` and `type Foo struct{}`.",0.3833333333333333,Go
15kmsjl,jvemuzw,"C doesn't do type grouping though, it does type _qualifiers_",0.0,C
15kmsjl,jvakueo,"You can think of pointer declaration in C as a destructuring declaration `int *t` means `*t` is an `int`, therefore `t` is a pointer.",0.0,C
15kmsjl,jv837sz,"Or you can be Haskell, where exponentiation is `^`, `**`, or `^^`, depending on precisely what types you want!",0.5,Haskell
15kmsjl,jv6m2n7,[Rust RFC with examples](https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html),0.0,Rust
15kmsjl,jv9y0i1,"syntax is very IDE friendly because when you write `name.`,  the IDE can immediately help you to suggest all public members of that object, whereas in C for  example, the IDE cannot easily give you a list of functions that work on a particular data object.",0.23500000000000001,C
15kmsjl,jv9nwm4,"Like in Rust:      Struct { x: a, y: b } = bar(); Struct { x, y } = Struct { x: 5, y: 6 };  Or consider a language where Point has been defined as a 2-tuple:      Point (x,y) = triangle.A    // defining x and y",0.75,Rust
15kmsjl,jv72f1g,"There are languages (like Go) that put the name first and don't use any punctuation to separate the type, but I find declarations easier to read with some kind of separator.",0.425,Go
15kmsjl,jva40hx,"Well, that is a wart of Haskell that can’t express one concept via single operator, right?",0.10714285714285714,Haskell
15kmsjl,jvhduhy,"Meanwhile PHP:      function repeat(string $str, int $n): string  which I guess can be read as in English.",0.0,PHP
15kmsjl,jvc5izy,"There's not a good way to resolve this kind of trade-off within the programming language itself, so Haskell asks the user to make the choice instead.",0.125,Haskell
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Pascal
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Ada
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Haskell
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Scala
15k8zhf,,So one of the weird yet useful(kind of) features of Clojure is that it allows you to call a map even if it's not a function.,-0.5,Clojure
15k8zhf,,We have this feature in Python as well.,0.0,Python
15k8zhf,,I'm curious: how useful is this in a functional statically typed language like Haskell?,0.09999999999999999,Haskell
15k8zhf,jv4hv5x,"In C++ you can overload `operator()` on a class; objects of such classes are officially called ""callable objects"".",0.0,C++
15k8zhf,jv4ggjg,>We have this feature in Python as well.,0.0,Python
15k8zhf,jv4cs1z,I think you misunderstand Clojure.,0.0,Clojure
15k8zhf,jv89ld3,"Python ```python myDict = {0:""zero"", 1:""one"", 2:""two""} numberToName = myDict.get print(numberToName(1)) # prints 1 ```  but not e.g.",0.0,Python
15k8zhf,jv89ld3,"JavaScript: ```js const myMap = new Map(Object.entries({0:""zero"", 1:""one"", 2:""two""})) const numberToName = myMap.get console.log(numberToName(1)) # TypeError since `this` is not defined  const correctNumberToName = myMap.get.bind(myMap) console.log(correctNumberToName(1)) ```  I would also be very careful to specify the semantic choices here, including: 1.",0.0031818181818181746,JavaScript
15k8zhf,jv48qm1,In Haskell map/fmap is a function that takes a function and another argument as inputs and outputs data with a similar structure.,0.0,Haskell
15k8zhf,jv6z2jx,"Saying the name of a function is enough to call that function (without parameters), and that is also true in LISP, Haskell, and some other languages too.",0.075,Haskell
15k8zhf,jv6z2jx,"(In fact, in LISP, a function is exactly the same as just the first item in a list, so technically you do it all the time in Common LISP)  As stated, I suppose Haskell has the same thing.",0.03333333333333333,Haskell
15k8zhf,jv63nky,"In Clojure, maps are a first-class data type, alongside lists and vectors (another Clojure-specific data type).",0.0,Clojure
15k8zhf,jv4db6n,"In Clojure, the application `(m k)` where `m` is a Map is effectively `lookup k m` in Haskell.",0.6,Clojure
15k8zhf,jv4db6n,"In Clojure, the application `(m k)` where `m` is a Map is effectively `lookup k m` in Haskell.",0.6,Haskell
15k8zhf,jv4db6n,"Interestingly, this coercion does not make sense in Haskell because `(->)` is a concrete type constructor provably not equal to anything starting with `Map`.",0.1625,Haskell
15k8zhf,jv7pafd,I disagree with your description of how things work in Lisp.,0.0,Lisp
15k8zhf,jv7pafd,"It's easy to illustrate the difference in a Lisp-1 language like Scheme (or Clojure):      (define (hello-world)       (display ""hello world"")       (newline))          (define (call-twice f)       (f) (f))          (call-twice hello-world)  This last line mentions a 0-argument function without calling it.",-0.10555555555555556,Scheme
15k8zhf,jv7pafd,"It's easy to illustrate the difference in a Lisp-1 language like Scheme (or Clojure):      (define (hello-world)       (display ""hello world"")       (newline))          (define (call-twice f)       (f) (f))          (call-twice hello-world)  This last line mentions a 0-argument function without calling it.",-0.10555555555555556,Clojure
15k8zhf,jv7pafd,"Inside call-twice, that function is called twice, so the output is:      hello world     hello world  I also wouldn't describe Haskell as calling a function by mentioning it, because nothing is executed; a zero-argument function is the same thing as a constant.",0.0,Haskell
15k8zhf,jv4vyf8,Even if Clojure’s implementation has map as a keyword instead of a function (which I’m not sure is true) then it makes sense to make it mirror the syntax of every other lisp data structure.,-0.00833333333333334,Clojure
15k8zhf,jv5s9zn,The real question would be why is Clojure handling map functions differently?,0.1,Clojure
15k8zhf,jvbiu8h,">I also wouldn't describe Haskell as calling a function by mentioning it, because nothing is executed; a zero-argument function is the same thing as a constant.",0.0,Haskell
15k8zhf,jvbiu8h,"But if we go that route, all Haskell really does is manipulate lists by continually expanding them.",0.2,Haskell
15k8zhf,jvbiu8h,"(Technically a Cons cell)  But in terms of the initial question, ""calling a function"" means something different in Haskell.",0.0,Haskell
15k8zhf,jvbiu8h,"Using the definition of sequence manipulations (which is an oversimplification, in truth), _everything_ in Haskell is a function.",0.0,Haskell
15k79uw,jv4hj8o,"This includes Haskell, and there have been [multiple attempts](https://hackage.haskell.org/packages/#cat:Prelude) to provide an alternative prelude based on knowledge learned since Haskell's standard prelude shipped.",0.0,Haskell
15k79uw,jv4hj8o,"Another example is D, which originally shipped with quite a poor standard library and an alternative, Tango gained popularity.",-0.00833333333333334,D
15k79uw,jv4hj8o,"You should be able to leverage these directly from your language without having to use an FFI to a C intrinsics library, and without expecting the compiler to do auto-vectorization magic.",0.3666666666666667,C
15k79uw,jv4hj8o,"For numerics, I would recommend looking at the numerical tower of Scheme.",0.0,Scheme
15k79uw,jv4hj8o,[Kawa](https://www.gnu.org/software/kawa/Numerical-types.html) Scheme has a good implementation.,0.7,Scheme
15k79uw,jv5x5fj,I wrote about some [specific typeclasses and their issues](https://soc.me/languages/equality-and-identity-part1) in popular languages a while ago (a later chapter talks about Haskell).,0.19999999999999998,Haskell
15k79uw,jv5fs0m,>Kawa Scheme has a good implementation.,0.7,Scheme
15jpmxe,jv1q19f,"The Rust version of CPS conversion is misusing `RefCell`; the equivalent of `'t ref` is `&RefCell<T>`, not `RefCell<T>`.",0.0,Rust
15jpmxe,jv1q19f,"The latter is just a `T`, by value, which means the Rust implementation is passing a `u32` around by value and never actually incrementing it.",0.0,Rust
15jpmxe,jv1q19f,"---  All-in-all, Rust is definitely more verbose - but I think it's a shame to not use the one big correctness-checker that Rust has which is missing from OCaml, which is the borrow checker.",0.09999999999999999,Rust
15jpmxe,jv1gael,"For me personally the biggest issue in Rust has been performance, which might be surprising, because the usual meme is to rewrite things in Rust for speed.",0.15,Rust
15jpmxe,jv1gael,What I've seen in Rust is lacking a lot both in convenience and performance.,0.0,Rust
15jpmxe,jv1mahu,"As it is, it reads like it's going to be a critique of this subreddit, but the actual content is about comparing Rust and OCaml as language implementation platforms",0.0,Rust
15jpmxe,jv1int0,"Most of the times, you do not need to implement the whole thing; e.g., if you generate C code, you just need to represent only the constructions you use, not the whole C language.",0.22499999999999998,C
15jpmxe,jv1spim,"For every additional safety guarantee it may confer you in corner cases (mostly low level imperative code), just using immutable data structures, mostly functional code, and advanced types (like GADTs, which BTW are a correctness checking system that's totally missing in Rust) instead is likely to take you much further towards formal correctness, with much less effort.",0.07619047619047618,Rust
15jpmxe,jvgr89t,Seeing all those allocations in the Rust code made me cringe :x,0.0,Rust
15jpmxe,jv1lnyg,"If you want to write the next C++ that would be a massive undertaking, especially without institutional support.",0.0,C++
15jpmxe,jv1w7bk,"---  I'm not saying those other features aren't great; I really wish Rust had something like GADTs, but we should all try to learn from what each language does best.",0.46875,Rust
15jpmxe,jv2mm34,"In Rust, options are:  - Use Rc.",0.0,Rust
15jpmxe,jv2mm34,"Koka has one of the most heavily optimized pure reference counting implementations, and I would be surprised if Rust Rc was faster than Koka.",0.15357142857142855,Rust
15jpmxe,jv2mm34,"Moreover, Rust arenas are not as fast as heap allocation in OCaml/GHC, or other mature bump-pointer'd languages, because those compilers specifically optimize allocations on the machine code level and Rust doesn't.",0.05833333333333334,Rust
15jpmxe,jv2mm34,- Use a garbage collector in Rust.,0.0,Rust
15jpmxe,jv4rf1z,"> Moreover, Rust arenas are not as fast as heap allocation in OCaml/GHC, or other mature bump-pointer'd languages, because those compilers specifically optimize allocations on the machine code level and Rust doesn't.",0.05833333333333334,Rust
15jpmxe,jv4rf1z,You can implement a bump allocating arena in Rust just fine.,0.4166666666666667,Rust
15jpmxe,jv4rf1z,"The only difference between GHC's bump allocator will be that GHC stores the allocation and limit pointers in registers, in Rust you'll have to load them from a heap address.",0.0,Rust
15jpmxe,jv4rf1z,"I have a compiler project in Rust (in progress, not yet released) where I used to use bump allocating arenas/pools for different kinds of objects.",0.0,Rust
15jnq1p,,"Risor is a new language that compiles to bytecode and runs in a lightweight virtual machine, all written in Go.",0.13636363636363635,Go
15jnq1p,,The syntax feels like a blend of Go and Python.,0.0,Go
15jnq1p,,The syntax feels like a blend of Go and Python.,0.0,Python
15jnq1p,,It interoperates with Go types and leverages the Go standard library functions so Go programmers will feel right at home.,0.14285714285714285,Go
15jnq1p,,"Looking ahead, the more interesting aspects of the project are that Go libraries like the [AWS SDK and others are compiled-in](https://risor.io/examples/aws) to the Risor CLI.",0.5,Go
15jn1gv,,I work in a large Python codebase.,0.21428571428571427,Python
15jn1gv,jv0vprs,"Well, Python does haven an `Optional[T]` type annotation, which is an alias for the union `T | None`.",0.0,Python
15jn1gv,jv0vzn0,"Python has type annotations, and its type system includes 'Any' and 'Optional[T]' (which is 'T | None').",0.0,Python
15jn1gv,jv0y1bi,"custom Singletons to represent the absent of a value) is actually quite common in Python if a parameter should accept `None`, but it's absent should be treated differently again (the stdlib does that in quite a few places).",-0.125,Python
15jn1gv,jv0y1bi,The better solution is to use Python with type hints and static type checkers.,0.5,Python
15jn1gv,jv40kk2,"For example, consider this Python code:      if randomChance():        flag = True          print(flag)  The print() may raise an error because \`flag\` is not guaranteed to be assigned.",0.35,Python
15jn1gv,jv40kk2,"Now unlike Python, statically typed languages usually have block scope, but let's assume we keep Python style scope.",-0.25,Python
15jn1gv,jv40kk2,"We may implement a type system where uncertain variable assignments are automatically of a nullable type:      if randomChance():        flag = True          # at this point, flag is of type `Bool?`, because the assignment is uncertain     # so we are *forced* by the compiler to do this:          if flag is not None:        print(flag)  In a language like C# with block scope, we would be forced to do it like this:      bool flag; // or `var flag = false;`          if (randomChance()) {        flag = true;     }          ...",-0.06000000000000003,C
15jn1gv,jv40kk2,So this is an example how you could keep writing Python style code while still having the safety of forced null checks.,-0.30000000000000004,Python
15jn1gv,jv9e8sw,And Python can only tell you the latter.,0.0,Python
15jn1gv,jv9e8sw,"I also work in a large Python code-base for the day-job, and I can tell you that I've gotten a reputation for sprinkling assertions in lots of places.",0.21428571428571427,Python
15jn1gv,jv9e8sw,I will say that frustration with Python is part of the motivation behind my language.,-0.4,Python
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,Java
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,C
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,Python
15jn1gv,jv4o692,This is how you end up with type systems like C or pre-generics Go.,0.0,C
15jn1gv,jv4o692,This is how you end up with type systems like C or pre-generics Go.,0.0,Go
15jn1gv,jv4o692,"I think it's useful to look at TypeScript in this context, since it tries to provide static types that can actually express typical JavaScript patterns.",0.10666666666666666,TypeScript
15jn1gv,jv4o692,"I think it's useful to look at TypeScript in this context, since it tries to provide static types that can actually express typical JavaScript patterns.",0.10666666666666666,JavaScript
15jn1gv,jv4o692,"This might even be enough for a scripting language (think Perl 4, Bash, …).",0.0,Perl
15jn1gv,jv4o692,"This might even be enough for a scripting language (think Perl 4, Bash, …).",0.0,Bash
15jn1gv,jv4mn8w,"This is similar to how TypeScript works, especially when JSDoc type annotations are used so that no compilation step is necessary before execution.",0.0,TypeScript
15jn1gv,jv3m6a1,"My point is that it's completely trivial in the world of dynamic languages and expected within the realm of normal Python programs, to the point of making the limited system you suggested kind of useless.",0.025510204081632657,Python
15jn1gv,jv3uu88,C# is gradually typed FYI.,0.0,C
15jn1gv,jv4m7il,One of the very nice features of C# `dynamic` is that crossing the dynamic–static boundary is safe.,0.4266666666666667,C
15jn1gv,jv4m7il,"In Python or Typescript the type annotations are just annotations, and have little or no interaction with runtime behaviour.",-0.1875,Python
15jn1gv,jv4m7il,"In contrast, C# would do a checked cast at the point of the assignment, possibly raising an exception.",0.0,C
15jn1gv,jv801vd,> One of the very nice features of C# dynamic is that crossing the dynamic–static boundary is safe.,0.4266666666666667,C
15jn1gv,jv801vd,"> In Python or Typescript ... You can assign an int to a str variable by going through an Any type, and the language allows that.",0.0,Python
15jn1gv,jv801vd,"In contrast, C# would do a checked cast at the point of the assignment, possibly raising an exception.",0.0,C
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,Python
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,TypeScript
15jn1gv,jv801vd,Aiui early C# assumed fairly tight explicit static typing would be the norm for devs who used it.,0.14047619047619048,C
15jn1gv,jv9p69k,"Very good point about Raku – whereas most popular gradually typed PLs had a static type system grafted onto an existing dynamic language, a couple of PLs like Julia and Raku were *designed* with gradual typing in mind, which helps with actually achieving safety.",0.4183333333333333,Julia
15jn1gv,jv9p69k,"I perceive it as a design failure that the TypeScript compiler can transpile without typechecking, but it's understandable due to performance constraints.",-0.22083333333333335,TypeScript
15jn1gv,jv9p69k,Even the Deno runtime with its built-in TS support doesn't typecheck by default…  I think C#'s `dynamic` must also be seen in the context of the .NET Common Language Runtime.,-0.15,C
15jn1gv,jv9p69k,"And once that functionality is implemented in the CLR, it makes sense to expose it in the C# language for interoperability purposes, even though it would be rare to use this feature.",0.3,C
15jjcyv,jv23d02,"There're lot of use cases of indirection, just mention one: *vtable* (see C++ virtual methods).",0.0,C++
15j19pa,juzewfr,Feels like Bram is reinventing some parts of Lisp.,0.0,Lisp
15j19pa,juxufxd,"It encourages ad-hoc build systems and customization and built time injections are recipes for technical debt (see Java’s build system problem, there’s a billion ways to run it with gradlew, maven, etccc)",0.0,Java
15i92a9,juu9eff,(Nim is explicitly inspired by Pascal afaik) It also raises a runtime exception when using incorrect fields.,0.0,Pascal
15i92a9,jutgnlz,"You could still have `obj.field` with sum types   This is how Oils does it with [Zephyr ASDL](https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL) --  sum  types, but no pattern matching (because neither Python or C++ support it, at least the versions we use).",-0.3,Python
15i92a9,jutgnlz,"You could still have `obj.field` with sum types   This is how Oils does it with [Zephyr ASDL](https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL) --  sum  types, but no pattern matching (because neither Python or C++ support it, at least the versions we use).",-0.3,C++
15i92a9,jutgnlz,"The pattern is  1. a switch statement on the runtime tag 1. a static cast to the subtype 1. obj.field access, which you say you wanted   There are some syntactic hacks in Python (because it doesn't have switch, but C++ does!",0.625,Python
15i92a9,jutgnlz,"The pattern is  1. a switch statement on the runtime tag 1. a static cast to the subtype 1. obj.field access, which you say you wanted   There are some syntactic hacks in Python (because it doesn't have switch, but C++ does!",0.625,C++
15i92a9,juv0ers,I think Clojure also embraces that point of view.,0.0,Clojure
15i92a9,juw5nwn,"So:      rec Weapon       var name String       var bonus Int     case MeleeWeapon       var damage Int     case RangedWeapon       var minRange Int       var maxRange Int     end  is, AIUI, roughly equivalent to the following using ordinary structs and unions, using C syntax as most are familiar with that:      typedef long long Int;  // 64-bit int          typedef struct {         Int tag;            // discriminating tag         char* name;         Int bonus;         union {             Int damage;             struct {                 Int minRange;                 Int maxRange;             };         };     } Weapon;  I chose a 64-bit `Int` to avoid alignment and padding issues.",0.06071428571428572,C
15i92a9,juw5nwn,"Then that line might be equivalent to this C:      enum {MeleePeapon, RangedWeapon};   // assumed global; see below          if (weapon.tag == RangeWeapon &&  With accesses to the variant parts such as `x = weapon.damage` further guarded like this:      x = (weapon.tag == MeleeWeapon ?",-0.06999999999999999,C
15i92a9,jv77pzb,"I often get issues with the analogous ""when"" statements in Kotlin, because to check for a type I need to add the ""is"" modifier"".",0.0,Kotlin
15i92a9,juyu9sv,"Some Pascals and Ada have the sort of variant record feature I describe here, but as far as I know, languages that have a thing they call ""sum type"" don't have case-independent fields on it.",0.1,Ada
15i92a9,juzzh44,"In Haskell and ML you can duplicate a member over every case to make it *total*, whilst also having *partial* members.",-0.05,Haskell
15i92a9,juvh0b3,This is the same behavior as Haskell.,0.0,Haskell
15i92a9,juvh0b3,"Record fields in Haskell behave like plain functions, so you can call a partial field on a value which is of a case which does not contain this field - the compiler will not complain because they're the correct *type*.",-0.15714285714285714,Haskell
15i92a9,juwwj3n,And Ada [also has them](https://learn.adacore.com/courses/intro-to-ada/chapters/more_about_records.html#variant-records).,0.0,Ada
15i92a9,juwwj3n,"It is not a ""dead end"" feature, the C descendents are just very good at ignoring useful features for decades.",0.4366666666666667,C
15i92a9,juwwj3n,"But just look outside of the C world, and there are treasures everywhere (yes, ML is not the only source of good things).",0.2333333333333333,C
15i92a9,jutqo5e,"The type relationship is the same  (Multiple inheritance also turns into something Rust doesn't have --  variants as first class types, without wrapping)  Why do you say subtyping adds a lot of complexity?",0.08333333333333333,Rust
15i92a9,juvpkog,A potential fix for this in Haskell is to replace the sum type with a GADT and separate the record fields into their own types.,0.3,Haskell
15hwgbo,,Currently there are working iterators for:   * Array * Tuple * String * Number Range (like in Python)  # Problem  I'm not sure how to handle situations in which new keys are added or removed from the map.,-0.03787878787878788,Python
15hwgbo,,"For now the Litan map uses std::map from the C++ standard library as an underlying container, which has some problems with iterator invalidation.",0.0,C++
15hwgbo,,"(1, A)     [VM-Error] Unhandled exception: Invalidated map iterator  # Options  There are a few other options I thought about:  * Just accept UB from C++ (Not an option) * No map iterators (Not an option) * Just stop iteration and exit loop (Very soft error handling and hard to find error.",-0.12166666666666667,C++
15hwgbo,jurjpb8,"C++ solves this problem via the `erase` function on the map; it doesn't work with range-based for loops like the ones you are implementing here, because it requires updating the iterator directly.",0.1,C++
15hwgbo,jur6vfq,I quite like the way Java's concurrent collections (e.g.,0.0,Java
15hwgbo,jur6vfq,"Another trick from Java's iterators is that you can remove the last returned element through the Iterator interface instead of on the Collection, and this allows you to continue iterating safely.",0.25,Java
15hwgbo,jusjj3h,"If your backing language is C++, then consider `std::unordered_map` (hash map), and think about the behavior:   - Should insertion or removal cause an exception?",0.0,C++
15hwgbo,jusjj3h,"---  On another note, C++ doesn't make the distinction, but it's actually pretty important: there's a difference between an _iterator_ and a _cursor_.",0.325,C++
15hwgbo,jusjj3h,"The Rust library offers _some_ cursors for a few collections [see, for example, `LinkedList`](https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html).",-0.05,Rust
15hwgbo,jushte0,"You're in good hands: Java behaves similarly, and throws a `ConcurrentModificationException` in such a case.",0.2333333333333333,Java
15hwgbo,juymb3h,This is what C++ does with \`erase\` as someone else was pointing out.,0.0,C++
15hwgbo,juqtyhy,C++'s std::map has no way to get n-th pair without starting from the begin again and again which would result in O(n\^2) time complexity for the for loop in case of a map.,0.0,C++
15hwgbo,jutefzx,---  Regarding the Rust cursors.,0.0,Rust
15hwgbo,jutefzx,I'm not really familiar with Rust and will need do some reading about that topic.,-0.1875,Rust
15hwgbo,juqz268,"Of course, this is all under the assumption of single threading…  Btw Java also throws an exception if the collection was modified.",-0.07142857142857142,Java
15hwgbo,juvrrg9,"You can think of a Rust Cursor as a wrapper around a pointer to an element -- quite like C++ forward/bidirectional/random iterators -- really, where each cursor is specialized for the container type it can ""browse"".",0.2,Rust
15hwgbo,juvrrg9,"You can think of a Rust Cursor as a wrapper around a pointer to an element -- quite like C++ forward/bidirectional/random iterators -- really, where each cursor is specialized for the container type it can ""browse"".",0.2,C++
15hi5ro,,"(It simply makes sense to have those in a logic language and-honestly, Prolog sucks.",-0.15,Prolog
15hi5ro,,"For comparison, look at how many fine prints you got to read to even use the Prolog _forall_.",0.45833333333333337,Prolog
15hi5ro,jup7xdz,"You can do this more generally in Python with the `all` and `any` built-in functions in conjunction with generator expressions (to ensure that we don't compute more `odd`s than necessary):      >>> def odd(x): return x % 2 == 1     ...      >>> all(odd(x) for x in range(1, 6))     False     >>> any(odd(x) for x in range(1, 6))     True  There's also an interesting idea in probabilistic programming, where `some` corresponds to rejection sampling.",0.21428571428571427,Python
15hi5ro,juqqd8x,"Prolog:      for(_, []) :- true.",0.35,Prolog
15hi5ro,juuksao,"Like Java's `findAny`, then?",0.0,Java
15hi5ro,juqln1n,"Maybe `for` plays a special role in ***logical languages***, like Prolog.",0.3035714285714286,Prolog
15hi5ro,juqln1n,"Would you ever want to print *""some""* element of a collection and how would you do that in C#?",0.0,C
15hi5ro,juqln1n,In Haskell it's called `find`.,0.0,Haskell
15hi5ro,jut7wjw,"Python) that seemingly has _all_, _filter_ and _for_ in multiple forms (and syntaxes); there is perhaps some design points gained.",0.0,Python
15hi5ro,jutihui,Disclaimer: my language doesn't claim to _supersede_ Prolog.,0.0,Prolog
15hi5ro,jutihui,"However, this is not meant to imply it's _impossible_ to make something similar in Prolog.",-0.3333333333333333,Prolog
15hi5ro,jutihui,Edit: this may be a good opportunity to mention [NU-Prolog](https://prnt.sc/xwdAyuqcYfGj) (from NU-Prolog manual) as an attempt to add _some/all_ as a construct in LP languages in a different way than how Prolog does it.,0.35,Prolog
15hi5ro,juveswd,"In Ruby, for example, all iteration is done via methods taking blocks, and syntactic looping constructs while exist, are almost never used.",0.0,Ruby
15hi5ro,juveswd,"And in Rust, `for x in i {...}` is 90% pure sugar for `i.for_each(|x| {...})`.",0.21428571428571427,Rust
15gz8rb,,I'm considering creating a compiler for a high-level programming language and wonder if Go would be a good fit for writing it.,0.55,Go
15gz8rb,,"I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Haskell
15gz8rb,,"I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Rust
15gz8rb,,"Go wasn't that frequently mentioned, although, from what I know, if the language is compiled rather than interpreted, the choice of a programming language shouldn't matter as long as the compiler's target is native code.",0.025,Go
15gz8rb,,"I know Go is self-hosted and, therefore, written in itself.",0.0,Go
15gz8rb,,My language would have a GC: Would Go already having a GC complicate development?,0.0,Go
15gz8rb,,"If so, would Rust be a good option?",0.7,Rust
15gz8rb,,"In addition, I know Rust, for example, has tools for building languages, such as `inkwell` (LLVM bindings) and `cranelift`.",0.0,Rust
15gz8rb,,"To my knowledge, Go has no such tools.",0.0,Go
15gz8rb,junesc0,"Ive built interpreters in Go before, i didnt realize how unergonomic it was until I built the same interpreter in OCaml which has algebraic data types and pattern matching.",0.0,Go
15gz8rb,jum3hqn,"There's a book _just_ about writing a compiler in Go (also, AFAIK, Go is self-hosted)  https://compilerbook.com/  So, take your conclusions",0.0,Go
15gz8rb,jumd0pb,"I write compilers in Go, it's a decent language for that, but you will miss a stronger type system and sum types.",0.16666666666666666,Go
15gz8rb,jumd0pb,"I program most things from scratch, so i don't miss the lack of interop between say, Go and LLVM.",0.5,Go
15gz8rb,jumd0pb,"Go's GC is rarely a problem for a short lived program like a compiler, unless you plan to compile millions of lines of code, i think GCed languages work wonderfully.",0.43333333333333335,Go
15gz8rb,jumd0pb,"Besides, Go's profiling tool offsets most downsides of using GC, after a while, you program knowing exactly what you shouldn't do and performance stops being a problem.",0.375,Go
15gz8rb,jum4ax2,>I'm considering creating a compiler for a high-level programming language and wonder if Go would be a good fit for writing it.,0.55,Go
15gz8rb,jum4ax2,"If you know Go, then Go will be a good fit for writing a compiler and/or interpreter in.",0.55,Go
15gz8rb,jum4ax2,>My language would have a GC: Would Go already having a GC complicate development?,0.0,Go
15gz8rb,jum4ax2,>would Rust be a good option?,0.7,Rust
15gz8rb,jum4ax2,"If you know Rust, then Rust will be a good fit for writing a compiler and/or interpreter in.",0.55,Rust
15gz8rb,jum4ax2,">I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Haskell
15gz8rb,jum4ax2,">I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Rust
15gz8rb,jum4ax2,Go wasn't that frequently mentioned  This is true.,0.22499999999999998,Go
15gz8rb,jum4ax2,"But languages are fads, and Rust is the current fad.",0.0,Rust
15gz8rb,jumd0n3,"As someone who’s writing a compiler in Go, I don’t recommend it if you can avoid it.",0.0,Go
15gz8rb,jumtnoa,You might also be interested in [this post from last week](https://www.reddit.com/r/ProgrammingLanguages/comments/15a4z4c/is_go_a_good_target_language/) about using Go as a compilation *target*.,0.125,Go
15gz8rb,juoozn3,I found C# quite pleasant to use.,0.7333333333333333,C
15gz8rb,jume12c,"Go doesn't have them,  so I wouldn't write any compiler in Go.",0.0,Go
15gz8rb,jume12c,Rust on the other hand is extremely well suited to compiler development.,-0.125,Rust
15gz8rb,jume12c,"Since you can also do concurrency in Rust, and it will also be safer, I don't think Go has any advantage over it in a compiler context.",0.0,Rust
15gz8rb,jume12c,"Since you can also do concurrency in Rust, and it will also be safer, I don't think Go has any advantage over it in a compiler context.",0.0,Go
15gz8rb,jumln2j,"I'm curious why you ask about Go specifically, is it because it's a language you like and/or already know?",-0.1,Go
15gz8rb,jumln2j,"> In addition, I know Rust, for example, has tools for building languages, such as inkwell (LLVM bindings) and cranelift.",0.0,Rust
15gz8rb,jumln2j,"To my knowledge, Go has no such tools.",0.0,Go
15gz8rb,jumln2j,"Another possibility, if the main thing is that you **want** to use Go, is that your compiler translates your new language into Go code, and then invokes the Go compiler.",0.1515151515151515,Go
15gz8rb,jumuscu,Learning rust or ml or Haskell would be a project of its own.,0.6,Haskell
15gz8rb,juomyh9,C interop might be difficult if you write it in go.,-0.5,C
15gz8rb,jupnnvt,"Very good, although I would prefer Rust, if I don't want to struggle with C/C++.",0.9099999999999999,Rust
15gz8rb,jupnnvt,"Although there are more good options, but Rust is a delight for everything, when I use it.",0.6,Rust
15gz8rb,jus65e8,"I did write a lisp compiler in C.  So if you are already good at Go, just use it.",0.7,Go
15gz8rb,jv0fhjo,I wrote a C-like language in Go a couple years ago [https://github.com/0x2ac/myc](https://github.com/0x2ac/myc).,0.0,Go
15gz8rb,jv0fhjo,It uses llir to generate the text format and needs a system C compiler.,0.0,C
15gz8rb,jv0fhjo,It wasn't too bad of an experience but there are some Go-like quirks to do that you have to deal with and the compilers/interpreters I've written later in Rust have been a much nicer experience.,-0.1666666666666666,Rust
15gz8rb,juqnoj9,Using `iota` as a replacement for enums didn't help with Go's lack of ADTs?,0.0,Go
15gz8rb,jvclgl6,"Rust has the Plex library too, which can let you define grammar in a macro and basically skip you to code gen",0.0,Rust
15gz8rb,jumjzex,I just think it's relevant to OP's question in the sense that there may not be as many resources for Go in respect to what they're trying to accomplish.,0.45,Go
15gz8rb,jumjzex,"However as you noted, Go itself is self-hosted so the codebase is a resource, but not quite the same as a book.",0.0,Go
15gz8rb,juvsm1t,> Go is self-hosted  For any* language the drive to self-host is high because presumably the author loves the language and wants to only write in it / check how a large project in it feels like.,0.14357142857142857,Go
15gz8rb,jumpcbq,"Fads are a factor but there are strong arguments for OCaml - it has a powerful type system and pattern matching, and Haskell is even better since it has continuations so you don't have to convert the source to CPS to implement certain structures (although you could use coroutines for most cases and Go does offer those).",0.3895238095238095,Haskell
15gz8rb,jumpcbq,"Fads are a factor but there are strong arguments for OCaml - it has a powerful type system and pattern matching, and Haskell is even better since it has continuations so you don't have to convert the source to CPS to implement certain structures (although you could use coroutines for most cases and Go does offer those).",0.3895238095238095,Go
15gz8rb,jumep90,"CPython uses GC, and many other high level features, but the implementation language is C, which has pretty much nothing.",0.197,C
15gz8rb,jummrjx,"Yeah, I saw some people have mentioned that those two things are quite useful for making compilers, and Go doesn't have them.",0.3,Go
15gz8rb,juoogh0,How do you handle algebraic data types for ASTs in Rust?,0.0,Rust
15gz8rb,juoogh0,"I haven't used Rust much, but when I wrote an interpreter in it, I made an enum for the AST nodes, but found it quite annoying to add new fields.",-0.15454545454545457,Rust
15gz8rb,jumnn0k,The main reason I'd like to use Go if it's a good option is that I already mostly know it.,0.45555555555555555,Go
15gz8rb,jumnn0k,"However, some commenters have already pointed out that Go may not be the best language because it doesn't have pattern matching and algebraic data types.",1.0,Go
15gz8rb,jumnn0k,Rust has both.,0.0,Rust
15gz8rb,jumnn0k,"I also like Rust, but I only know the basics, so I'd have to learn it, which isn't much of a problem since I'd like to learn it at some point.",0.1,Rust
15gz8rb,juqq0uv,"Go has `cgo` package, which allows C interop.",0.0,Go
15gz8rb,juqq0uv,"Go has `cgo` package, which allows C interop.",0.0,C
15gz8rb,juqo0pb,"I may be misunderstanding your comment, but I wasn't planning on compiling to Go.",0.0,Go
15gz8rb,jv0tw2a,Did you already know Rust when you first wrote a compiler in it?,0.25,Rust
15gz8rb,jv0tw2a,"If not, did learning Rust get in the way of writing the compiler?",0.0,Rust
15gz8rb,juon1mv,I believe OCaml should be a much more pleasant and flexible host language than Haskell for this use case.,0.6166666666666667,Haskell
15gz8rb,jumkvwe,"> CPython uses GC, and many other high level features  Yeah, features that the devs had to write from scratch, because as you point out, C does not offer much.",0.18375000000000002,C
15gz8rb,jumkvwe,"I think the point being made here was that it would be *easier* to write an interpreter in a language like Go, because you wouldn't have to worry about things like GC -- it just works.",0.0,Go
15gz8rb,juowj0g,"That’s the most natural representation of an AST, and that’s how all Rust based compilers that I know of do it too.",0.3,Rust
15gz8rb,juozck2,">However, some commenters have already pointed out that Go may not be the best language because it doesn't have pattern matching and algebraic data types  Those will be the people who like to use pattern matching and algebraic data types in their compilers.",1.0,Go
15gz8rb,juozck2,"Creating a tree might have been tricky in 1970s Fortran or BASIC, but pretty much any language now can manage it easily.",0.22083333333333333,Fortran
15gz8rb,juon1k1,Try Crystal.,0.0,Crystal
15gz8rb,juqepzm,"Yeah, I agree that Haskell can be tough.",-0.3888888888888889,Haskell
15gz8rb,juo2yb9,Imagine for example writing a Python interpreter in Go.,0.0,Python
15gz8rb,juo2yb9,Imagine for example writing a Python interpreter in Go.,0.0,Go
15gz8rb,juo2yb9,"This Python may have a specially designed set of data structures to represent Python objects, which might accommodate memory management by reference counting, say.",0.35714285714285715,Python
15gz8rb,juo2yb9,"Now Go apparently has its own GC, but how is that going to fit into what's going on in the Python bytecode execution?",0.35000000000000003,Go
15gz8rb,juo2yb9,"Now Go apparently has its own GC, but how is that going to fit into what's going on in the Python bytecode execution?",0.35000000000000003,Python
15gz8rb,juo2yb9,"Maybe Python relies on immutability to simplify data sharing, while Go data structures are immutable (I've no idea if they are).",0.0,Python
15gz8rb,juo2yb9,"Maybe Python relies on immutability to simplify data sharing, while Go data structures are immutable (I've no idea if they are).",0.0,Go
15gz8rb,juqkrck,"Haven't done Rust must lately so I might be confused, but I think it was the fact that I had to modify the patterns to accommodate the new fields in the first place.",-0.0784090909090909,Rust
15gz8rb,juqkrck,In C# I could just do the pattern matching (eg.,0.0,C
15gz8rb,juqkrck,"In Rust I would need to change all the Expr::Binary(_, _ ,_ ,_) and such.",0.0,Rust
15gz8rb,juqkrck,Seems like the Rust compiler has a struct (Expr) that has some common fields and then a field with an instance of an enum.,-0.3,Rust
15gz8rb,junpnl2,"I'm curious: I've seen mostly-functional languages, specifically Haskell and OCaml, recommended for PL implementation.",-0.1,Haskell
15gz8rb,juqmjrd,It was finally added in Go 1.18.,0.0,Go
15gz8rb,juqn2ol,"I want to write a whole new language, including the GC and other such features, but Go already has many of those.",0.14227272727272727,Go
15gz8rb,juqn2ol,"I was concerned Go already having those features would mess with my implementation of them for my language, although from what I understand, since I'm writing a compiler that targets machine code (or LLVM IR, which then compiles to machine code), that shouldn't be a problem.",-0.175,Go
15gz8rb,juqn2ol,"However, I probably won't use Go and will turn to something like Rust based on what the commenters have said.",0.0,Go
15gz8rb,juqn2ol,"However, I probably won't use Go and will turn to something like Rust based on what the commenters have said.",0.0,Rust
15gz8rb,jusm0t6,I like Go generics.,0.0,Go
15gz8rb,juto5r1,I'm not very experienced with Go.,-0.3076923076923077,Go
15gz8rb,juto5r1,"I've really only built one larger web app with it and am working on another, also in Go.",0.0,Go
15gz8rb,juujd74,Going crazy with them a la Java or C# just isn’t done.,-0.6,Java
15gz8rb,juujd74,Going crazy with them a la Java or C# just isn’t done.,-0.6,C
15gh2sl,juk00n2,"For instance Python doc comments are legitimate statements in the language, and you can read them programmatically by accessing `my_function.__doc__` for example.",0.0,Python
15g0v0c,juh8vy3,"Checkout how functions are defined in OCaml or Haskell, there is one way that is  ``` f arg1 arg2 = <exp> ```  which looks just like function application you would write later and it is sugar for  ``` f = \arg1 arg2 -> <exp> ```  I'm showing haskell here, OCaml has some similar stuff",0.0,Haskell
15g0v0c,juhxx9r,"let x = x  In Lua `local function f` desugars to `local f; f=function` instead of `local f = function`, precisely for this reason.",0.1,Lua
15g0v0c,juhe26k,F# uses  ``` let name x y = x + y ```  it is the same as  ``` let name = fun x -> fun y -> x + y ```  you have the same in JavaScript.,0.15,JavaScript
15g0v0c,jujsfjh,For example one could say in Scala :  val inc = (number: Int) => number + 1   But for a total beginner programmer would that above line really be easy to know what's going on?,-0.07916666666666666,Scala
15g0v0c,jujsfjh,"Now how about this one from Elm:   fn add x y = x+y   It's true there's more likely an easier way to do this in Scala but I hope you can see that Scala puts more of an emphasis on conciseness and being approachable to experts, while something like elm's syntax was meant to lower the barrier for entry for beginner/expert programmers alike",0.3375,Elm
15g0v0c,jujsfjh,"Now how about this one from Elm:   fn add x y = x+y   It's true there's more likely an easier way to do this in Scala but I hope you can see that Scala puts more of an emphasis on conciseness and being approachable to experts, while something like elm's syntax was meant to lower the barrier for entry for beginner/expert programmers alike",0.3375,Scala
15g0v0c,jugcsvq,Lisp isn't consistent though.,0.25,Lisp
15g0v0c,jug9te1,But Lisp ugly :(,-0.725,Lisp
15g0v0c,jujzwrv,"That's why I like PHP over C/C++ due ""function"" keyword makes it readable...",-0.125,PHP
15g0v0c,jugvtrj,"Indeed, this is perfectly normal in JavaScript, btw in your example your subnet even need the brackets `const add = (a, b) => a + b`",-0.3,JavaScript
15g0v0c,juggdx8,"Seeing as all that sugar could be (and often is) delivered by in language macro facilities, Lisp kinda has it both ways by design.",0.0,Lisp
15g0v0c,juga6rm,"Beginners will have no trouble classifying Haskell, Rust, OCaml as ugly, just because the syntax is not close to everyday math.",-0.26666666666666666,Haskell
15g0v0c,juga6rm,"Beginners will have no trouble classifying Haskell, Rust, OCaml as ugly, just because the syntax is not close to everyday math.",-0.26666666666666666,Rust
15g0v0c,jugaswn,The only language I know myself which makes closures explicit was C++.,0.0,C++
15g0v0c,jukch3u,"Haskell gets away without using `let` declarations, and having `let` expressions instead.",0.0,Haskell
15g0v0c,juglr7r,"No reference language, I just didn't particularly like how move closures work in Rust.",0.16666666666666666,Rust
15fs9pu,,"(By that I mean I don't have to learn the language itself before learning anything else, like in Haskell).",-0.3125,Haskell
15fs9pu,,EDIT: here's an non-exhaustive list of candidates  - Haskell - OCaml - Agda - [Hackket](https://github.com/lexi-lambda/hackett) - [Klister](https://github.com/gelisam/klister) - [Typer](https://gitlab.com/monnier/typer),0.0,Haskell
15fs9pu,jv74rt4,"See https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html and this phd thesis: [Scalable Metaprogramming in Scala 3](https://infoscience.epfl.ch/record/299370)  This is more or less the state of the art, it improves over MetaOCaml in several ways.",-0.10416666666666666,Scala
15fp4hw,juga1ix,For example: With [Zigler](https://github.com/E-xyza/zigler) you mix high level Elixir code and low-level Zig code seamlessly:,0.13,Elixir
15fp4hw,jvfvxnl,"I know Haskell already does that but if I do not want a purely functional lazily evaluated language, I don't see many alternatives.",0.15476190476190477,Haskell
15fo0dk,juel0xh,"Newlines aren’t special in that regard - you can imagine rewinding to some other herald symbol (eg go to the nearest `(` if you’re a Lisp, and design your string literals around that).",0.11607142857142858,Lisp
15fluxd,,"* Totally protected from memory leaks (unlike Java, Rust etc.)",0.0,Java
15fluxd,,"* Totally protected from memory leaks (unlike Java, Rust etc.)",0.0,Rust
15fluxd,jug27yw,"You have some very bold statements (""no memory leaks unlike Java, Rust"") in your description that make me suspicious.",0.43333333333333335,Java
15fluxd,jug27yw,"You have some very bold statements (""no memory leaks unlike Java, Rust"") in your description that make me suspicious.",0.43333333333333335,Rust
15fluxd,juvf2sm,"Rust actually used to have sigils for smart pointer types, but decided to ditch them for readability and consistency reasons.",0.10714285714285714,Rust
15fluxd,jugrpqo,I started with making a C++ smart pointer library ([https://github.com/karol11/ltm](https://github.com/karol11/ltm)) that introduces the same semantics.,0.10714285714285714,C++
15fluxd,juh2h8i,"Rust, on the other hand, is a systems-level language.",-0.125,Rust
15fluxd,juwnpfn,"In Rust - smart pointers are not built-in, they a the part of runtime library, and they are numerous.",0.10714285714285714,Rust
15fluxd,juwnpfn,"In contrast Argentum smart pointers are limited by UML, built-in, and deeply integrated in the compiler, same as  Rust &-reference or !-macro sigils.",0.03571428571428571,Rust
15fluxd,jv1ftl8,"BTW there are other demos - that show handling of the graph data structures with loops, file IO, text parsing/formatting and FFI-interop with C.",-0.125,C
15fluxd,jumu09v,Maybe it would help me to better understand Argentum's model if you could provide common code in other languages (I'm Java dev) and how they would be written in Argentum.,0.025000000000000005,Java
15fluxd,jund84j,"```Rust // Define classes class Document {    accounts = Array(Account);    transactions = Array(Transaction); } class Account {    id = 0;    name = """";    init(i int, n String) this { id:=i; name:=n }    toString() { ""{}/       {id}-{name}    ""} } class Transaction {    from = &Account;    to = &Account;    // or accounts = WeakArray(Account);    amount=int;    description = """";    ... }  // Create object doc = Document; doc.accounts.add(Account.init(1, ""Cookies"")); doc.accounts.add(Account.init(2, ""Gold"")); doc.transactions.add(Transaction.init(     &doc.accounts[0],     &doc.accounts[1],     200,     ""Sold""));  // Prints: // Transaction // from 1-Cookies // to 2-Gold // amount: 200 // reason: Sold doc.transactions.each((t){    log(""{}/        Transaction        from: {t.from ?",-0.75,Rust
15fluxd,jur4r0t,"In Java application you can delete account, and this account will be still visible to transactions but not presented in the document `accounts` registry.",0.0,Java
15fluxd,jur4r0t,"While in Java this checking is a multiline statement just to evade null pointers,  but if you want to protect your code from accessing the accounts that was removed from registry,  you need additional flags and checks.",0.0,Java
15fluxd,jurljcs,The problem I see is that Argentum's code needs to cover the edge case in each piece of code while in Java I just can remove the transaction and that's it.,0.0,Java
15fgh6b,judv71d,"In fact, in Haskell, every module does directly correspond to a compilation unit.",0.1,Haskell
15fgh6b,juef2z1,"> JavaScript notably lacked modules, and that was so painful they now have [multiple](https://requirejs.org/) [competing](https://github.com/amdjs/amdjs-api/blob/master/AMD.md) [modules](https://en.wikipedia.org/wiki/CommonJS).",-0.09999999999999998,JavaScript
15fgh6b,juef2z1,"It's funny, there's a 4th that you didn't link that's the actual, official module system :) The 2015 edition added the [standard module system](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) (called ""JavaScript modules"" or ""ES Modules"").",0.1875,JavaScript
15fgh6b,juhuaw8,It feels like JavaScript and Python are out of place in the table.,0.0,JavaScript
15fgh6b,juhuaw8,It feels like JavaScript and Python are out of place in the table.,0.0,Python
15fgh6b,judpts0,"BTW Good Article, but forgot to mention ""Modula"", from the Pascal branch of P.L.",0.7,Pascal
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,Pascal
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,Ada
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,Delphi
15fgh6b,juggfji,That is the approach that languages like Zig or Lua take and I absolutely love it (i.e.,0.5,Lua
15fgh6b,juif795,exactly what happened with C++ templates.,0.25,C++
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,C++
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,Haskell
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,Rust
15fgh6b,jud9x3m,"Since modules are objects in Python, is it enough to consider than they can be nested?",0.0,Python
15fgh6b,juowe0b,"I'm surprised to see Haskell listed under nesting, because module system in Haskell is extremely flat.",0.037500000000000006,Haskell
15fgh6b,juhop5h,"In Java, for example, you might need to have a (pre-compiled) dependency available during compilation for interface checking, but that doesn't stop you from arbitrarily composing a classpath from which implementations are loaded at runtime, replacing anything you like down to individual classes.",0.036111111111111115,Java
15fgh6b,juhop5h,Interfaces in Go work like this.,0.0,Go
15fgh6b,juk62fw,It feels like JavaScript and Python are out of place in the table.,0.0,JavaScript
15fgh6b,juk62fw,It feels like JavaScript and Python are out of place in the table.,0.0,Python
15fgh6b,judf088,Python doesn't have the same language level features for working with nested modules.,0.0,Python
15fgh6b,jueaegm,"Last time I tried, it was honestly quite clunky - much more so than doing this in Scala, which naturally unifies OOP and module systems, making the latter just as easy to use as the former.",0.23333333333333336,Scala
15fgh6b,jumdhw1,"- static methods and properties, - static arrays, - static array sizes (as in C), - static types, - static self types, - static dispatch and linking, - static virtual methods and properties, - static variables, - static visibility and storage class, - static classes, - static classes (the other static ones), static local functions and static lambdas, - static statements (the D ones), - static effects (I made that one up), - static initialisation blocks, - static constructors and shared static constructors, - `using static`, - `static import`, - static columns,  and probably more.",0.455,C
15fgh6b,jumdhw1,"- static methods and properties, - static arrays, - static array sizes (as in C), - static types, - static self types, - static dispatch and linking, - static virtual methods and properties, - static variables, - static visibility and storage class, - static classes, - static classes (the other static ones), static local functions and static lambdas, - static statements (the D ones), - static effects (I made that one up), - static initialisation blocks, - static constructors and shared static constructors, - `using static`, - `static import`, - static columns,  and probably more.",0.455,D
15ewmuk,,"Despite Python's GIL, a bit of threading does *subjectively* seem to [speed up turtle-graphics significantly](https://github.com/kjosib/sophie/blob/main/sophie/adapters/turtle_adapter.py).",0.0,Python
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,Ada
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,C
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,C++
15ewevk,juahxai,"A couple years ago I wrote an [Ada binding](https://github.com/csb6/libtcod-ada) to libtcod, a library used for making rougelike games, and it took a lot of manual effort to get the bindings working so I decided to work on a tool to make it easier.",0.0,Ada
15ewevk,jub9ky6,I got a tip about namespaced properties in Datomic and that seems to fit well with how I use modules (with a restriction like Go where the module/file name must be used as a prefix on imported symbols).,0.4,Go
15ewevk,jud44b3,"I am currently working on a gcc backend and binutil target for a custom ISA, which means learning a lot about these highly generic tools and the mess that is programming in C.",-0.05833333333333333,C
15ewevk,jv479rt,"I  * I started over with my previous Python implementation (which had just a lexer) * I wrote a new on-demand lexer, replacing the old one which used lots of horrible regular expressions.",-0.18606060606060607,Python
15ewevk,jv479rt,"* I wrote a parser, which currently creates a custom Python object, but the structure isn't set in stone, yet.",0.0,Python
15ewevk,jvg2b7l,"I'm thinking of starting a project which translates programs written in C, into my own systems language.",0.3,C
15ewevk,jvg2b7l,"But it will be difficult: C is lower level, quirky, and chaotic in what it allows in many places.",0.0,C
15ewevk,jvg2b7l,"I already have a product that can take C source code and turn it into my syntax, but that is purely for visualisation; I can't compile and run it, as too many details have to be changed or need attention.",0.35714285714285715,C
15ewevk,jvg2b7l,"having to cast every intermediate result down from `i64` to `i32`), that it would better to leave the code as C.",0.17222222222222222,C
15ewevk,juapglh,"The metaphor is message-passing similar to Erlang or Pony, but it turns out that pervasive codata poses some extra challenges.",0.0,Erlang
15ewevk,juapglh,"Also, maybe it's time to learn C#, even if only as a compilation target.",0.0,C
15ewevk,juw212y,Currently dissecting Kotlin type system then perhaps C#’s,0.0,Kotlin
15ewevk,juw212y,Currently dissecting Kotlin type system then perhaps C#’s,0.0,C
15ewevk,juvc7xi,I'm working on transpiling my programming language into JavaScript so that it can run in the browser.,0.0,JavaScript
15ewevk,juvc7xi,The problem is that the nature of Nutt is much more dynamic than that of JavaScript.,0.25,JavaScript
15ewevk,jv59jz4,## Typed functional TS/JS  Last month I started working on a new functional programming language for the TypeScript world.,0.06818181818181818,TypeScript
15ewevk,jv59jz4,"Basically, what could TypeScript be if it wasn't strictly a superset of JavaScript, and instead was more like statically typed functional JS?",0.5,TypeScript
15ewevk,jv59jz4,"Basically, what could TypeScript be if it wasn't strictly a superset of JavaScript, and instead was more like statically typed functional JS?",0.5,JavaScript
15ewevk,jv59jz4,"Now I'm on the long and hairy journey of figuring out how the type system will work, particularly with regards to enabling full/native interop with existing TypeScript code.",0.05833333333333333,TypeScript
15ewevk,jv59jz4,"* Type system and syntax is basically the same as TS where possible  Now I'm getting into the weeds, I'm starting to realise I have to go through a huge amount of work to re-implement most of TypeScript's type system for a language that's almost just syntax sugar on top of TS.",0.23333333333333336,TypeScript
15ewevk,jv59jz4,"I remember when I first learning Elm, and you could do something basic like `type UserStatus = Regular | Visitor` ... it took me way too long to understand that `Regular` and `Visitor` _are not references_ - you're making them up!",0.04,Elm
15ewevk,jwhntg9,"Actually I had three projects associated with C that I'm dropping:  * A C subset compiler (that one was also used to convert C APIs into my syntax) * The C visualiser which I'd started to hone into a more workable conversion tool * A backend for my systems language which targetted C source code  Dealing with C, a language I detest, *and* dealing with its diehards, was becoming too much.",0.2875,C
15ewevk,jv8aunn,I think where I'm at right now is \_not\_ trying to reimplement all of TypeScript's advanced type features but instead just maintain interop with all TS by integrating tsc into my compiler.,0.34285714285714286,TypeScript
15enrue,juasupq,"https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E#:\~:text=1980%E5%B9%B4%E4%BB%A3%E3%81%AB%E9%96%8B%E7%99%BA%E3%81%8C%E5%A7%8B%E3%82%81%E3%82%89%E3%82%8C%E3%81%9F%E3%80%8EMind%E3%80%8F%E3%81%AF%E3%80%81%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E8%AA%9E%E9%A0%86%E3%81%A8%E3%81%AE%E9%A1%9E%E4%BC%BC%E3%81%8C%E6%8C%87%E6%91%98%5B5%5D%E3%81%95%E3%82%8C%E3%82%8B%E9%80%86%E3%83%9D%E3%83%BC%E3%83%A9%E3%83%B3%E3%83%89%E8%A8%98%E6%B3%95%E3%81%AEForth%E3%82%92%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%81%97%E3%81%A6%E3%80%81%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AB%E8%BF%91%E3%81%84%E8%A8%98%E8%BF%B0%E3%82%92%E5%8F%AF%E8%83%BD%E3%81%A8%E3%81%97%E3%81%9F%E3%80%82  >1980年代に開発が始められた『Mind』は、日本語の語順との類似が指摘される逆ポーランド記法のForthをベースとして、日本語に近い記述を可能とした。    Translated: >""Mind,"" whose development began in the 1980s, is based on Forth, a reverse Polish notation system that has been noted for its similarity to Japanese word order.",0.25,Forth
15enrue,ju97sli,"Interesting, seems like a German language COBOL kind of thing to me",0.3666666666666667,COBOL
15enrue,ju98d93,"I do not know COBOL, so I cannot answer your question.",0.0,COBOL
15enrue,jugmpwn,"The similarity to COBOL is so great, you really need to research into it.",0.5,COBOL
15enrue,jugmpwn,"And perhaps also understand why, just as COBOL is in reality nothing whatsoever ""like"" English, so your language is not like German, although superficially, it might seem so.",0.0,COBOL
15enrue,jugs0vq,That was more or less the idea of COBOL: that its similarity to English would make it easier to read (and write).,0.11111111111111112,COBOL
15enrue,jugsgse,"Like you said, COBOL tries to be easier to read by being similar to english.",-0.03333333333333333,COBOL
15enrue,junkozj,"Also, COBOL was more successful for its time than is often credited",0.625,COBOL
15enrue,juj5i2a,"Even if you know neither Latin nor Perl, I think you might get something out of reading about Lingua::Romana::Perligata, Damian Conway's Perl module to allow programming in a Latin ""dialect"" of Perl.",0.0,Perl
15ebelq,,"I am working on my own lexer/parser generator (2-in-one, like C's PEG) and I was wondering if I should do PEG and Packrat or EBNF or even ABNF.",0.6,C
15ebelq,junia71,But you see I am making my blog except I am making my own roff-based macro suite to generate the HTML.,0.6,HTML
15dx5jq,ju4klfv,Drawing 10k triangles one at a time in C is also not going to be fast.,0.2,C
15dx5jq,ju5vo3s,"I had a case like this where I couldn't figure out why my code was running several times slower than equivalent C code, and when I profiled it, it turned out to be an issue caused by calling a function to create array slices in an inner loop (something like `for i, x in xs do for y in xs[(i+1)..] do...`).",0.0,C
15dx5jq,ju5c7m1,Python is too slow for rendering real-time 3d graphics as well - would you consider it a failed language?,-0.4,Python
15dx5jq,ju5c7m1,"In fact, speed beyond a certain is almost needless if your language has some way of doing FFI, because then you can just write performance-critical libraries in C or Rust or whatever while keeping the API in your language, like what NumPy does.",-0.14285714285714285,C
15dx5jq,ju5c7m1,"In fact, speed beyond a certain is almost needless if your language has some way of doing FFI, because then you can just write performance-critical libraries in C or Rust or whatever while keeping the API in your language, like what NumPy does.",-0.14285714285714285,Rust
15dx5jq,jv395pw,One important issue might be the C FFI.,0.4,C
15dx5jq,jv395pw,"It seems that calling a C function, which calls into the module's `call_function` will run a lot of string comparisons.",0.0,C
15dx5jq,ju8k3n7,"The issue isn't in the implementation language (C++), it's my language.",0.0,C++
15dx5jq,ju9b6km,Software renderers are slow in C as well when comparing to a GPU,-0.30000000000000004,C
15dx5jq,jufc6th,"In a language like C++, instrumentation also has the downside that you need to mark up your code to collect the profiling information, but if you're building your own language, that isn't a concern as you can simply add it automatically (or build it into your VM if you're using an interpreted/JITed language).",0.3,C++
15dx5jq,jufc6th,"I've been looking at [Tracy](https://github.com/wolfpld/tracy) for my C++ game engine (and potentially my hobby language), but I've also used [microprofile](https://github.com/jonasmr/microprofile) in the past and had a great experience with it.",0.037500000000000006,C++
15dq3dp,ju5mgb2,"Is it like python?, does it have types like C?.",0.0,C
15dp204,ju3gcpi,"It looks a bit ugly but I think the C++ way of saying ""operator+"" (for example) has it's merits, for this reason",-0.7,C++
15dmp16,," Rust, C++?",0.0,Rust
15dmp16,," Rust, C++?",0.0,C++
15dmp16,,Anything but C  Which has the the best library or framework for making languages like llvm,1.0,C
15dmp16,ju3ll4q,Multiple comments have mentioned Rust.,0.0,Rust
15dmp16,ju3ll4q,Rust is a fantastic programming language.,0.4,Rust
15dmp16,ju3ll4q,"Rust sells itself as a language for lower-level/backend/memory-conscious/high-performance problem spaces, none of which are directly relevant to PL implementation.",0.4,Rust
15dmp16,ju3ll4q,"In principle, Rust isn't the right choice, because it doesn't even sell itself as a good choice for this space.",0.4928571428571428,Rust
15dmp16,ju3ll4q,"My experience has been that for all the advantages Rust has in this space, its parent OCaml is the better choice without paying the costs of Rust that aren't relevant to programming language implementation.",0.45,Rust
15dmp16,ju3ll4q,"OCaml has many/all of the capabilities that make Rust pleasant for writing a compiler, and few/none of the irrelevant challenges that make Rust unpleasant for the same.",-0.10416666666666666,Rust
15dmp16,ju3ll4q,"With Rust, at first I fought the borrow checker, but then learned in an almost Stockholm Syndrome-y sort of way to describe my datastructures/algorithms in unnatural ways to avoid these problems.",0.25,Rust
15dmp16,ju3ll4q,With C++ I miss pattern-matching and spend a lot of time typing boilerplate.,-0.1,C++
15dmp16,ju3ll4q,"C# was fairly pleasant to work with, but still lacks certain capabilities and in general is more boilerplate to describe certain algorithms than in a more appropriate language.",0.3264880952380952,C
15dmp16,ju3ll4q,"C, or any particularly-low-level language is a wildly inappropriate choice in general, if your goal is the actual implementation of the target language.",0.05000000000000001,C
15dmp16,ju3ll4q,"Choosing C gives yourself a personal challenge, can be fun, and done well can end up with a notably high-performance compiler, but at the cost of easily 10x implementation effort on a project that often spans years to begin with.",0.30833333333333335,C
15dmp16,ju3ll4q,"D is very pleasant to work with as a ""C-family"" language and for me was by far the best among C/C++/C#, with the advantages that make those languages nice, and few of the disadvantages.",0.49066666666666664,D
15dmp16,ju3ll4q,"It's still missing the single most important feature, sumtypes and pattern matching, but like C++ et al that can (must be) worked around.",0.15714285714285714,C++
15dmp16,ju3ll4q,"If you were to insist on using a C-family language (C/C++/C#/Java/etc), I was strongly recommend reaching for D first.",0.3416666666666667,D
15dmp16,ju3ll4q,"More notes on OCaml:  * OCaml is a production-ready language that produces (relatively) high-performance executables, is battle-tested, and has a reasonably pleasant ecosystem (Rust's is better, C++ barely has one).",0.3566666666666667,Rust
15dmp16,ju3ll4q,"More notes on OCaml:  * OCaml is a production-ready language that produces (relatively) high-performance executables, is battle-tested, and has a reasonably pleasant ecosystem (Rust's is better, C++ barely has one).",0.3566666666666667,C++
15dmp16,ju3ll4q,"* Haskell, Standard ML, and other functional languages share much of the advantages of OCaml, but suffer from a ""purity problem"" that OCaml lacks.",0.025000000000000005,Haskell
15dmp16,ju3ll4q,"C to your will is satisfying in its own right, i.e., PL implementation in this case being an ""excuse"" for exercises/algo implementation in general.",0.27714285714285714,C
15dmp16,ju2ugtm,"If you're making a compiled language then it doesn't matter as much as your choice of target language that you're going to compile to (C, assembly, LVM), it especially doesn't matter if you're planning to make a self-compiling compiler (like golang)",0.1,C
15dmp16,ju2vj0s,"So yeah, C++ or Rust I guess.",0.0,C++
15dmp16,ju2vj0s,"So yeah, C++ or Rust I guess.",0.0,Rust
15dmp16,ju2vj0s,"In terms of portability, JavaScript and C# are good transpiler targets.",0.7,JavaScript
15dmp16,ju2vj0s,"In terms of portability, JavaScript and C# are good transpiler targets.",0.7,C
15dmp16,ju2tker,Haskell or Ocaml.,0.0,Haskell
15dmp16,ju2v27y,"Rust is great, like C but with modern tooling, pattern matching and a much more elegant type system.",0.5,Rust
15dmp16,ju2v27y,"Rust is great, like C but with modern tooling, pattern matching and a much more elegant type system.",0.5,C
15dmp16,ju2sybw,C++ or C for this.,0.0,C++
15dmp16,ju2sybw,C++ or C for this.,0.0,C
15dmp16,ju2sybw,"Seamless C interop  With these goals, I only really have one option: C.   So personally I think it depends on your goals with the language!",0.07500000000000001,C
15dmp16,ju3t3bb,Rust,0.0,Rust
15dmp16,ju3s0c0,">Rust, C++ ?",0.0,Rust
15dmp16,ju3s0c0,">Rust, C++ ?",0.0,C++
15dmp16,ju3s0c0,"But it depends on the proposed language too: if you use ones like OCaml or Haskell, they have facilities to quickly create mini-me versions of themselves.",0.3333333333333333,Haskell
15dmp16,ju3s0c0,"Think however about how any of those tools would handle a language like a custom assembler, or even your hated C language (its preprocessing language is a peach to implement).",-0.9,C
15dmp16,ju302re,"Chez scheme, racket, Common Lisp (back).",-0.15,Lisp
15dmp16,ju302re,Ocaml and Haskell are great too.,0.8,Haskell
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,Rust
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,Haskell
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,Go
15dmp16,ju2q324,C,0.0,C
15dmp16,ju3rgta,that is Functional like Lisp or supports regular expressions or has Regular Expressions libraries like JavaScript.,0.0,Lisp
15dmp16,ju3rgta,that is Functional like Lisp or supports regular expressions or has Regular Expressions libraries like JavaScript.,0.0,JavaScript
15dmp16,ju3rgta,"The second, is to implement a lexer and a parser like C, C++ compilers does.",0.0,C
15dmp16,ju3rgta,"The second, is to implement a lexer and a parser like C, C++ compilers does.",0.0,C++
15dmp16,ju6cgd9,"Then compile a parser to the source language of choice, write some glue code then: (0) interpret the parsed ast, (1) generate code in some high-level lang w/ garbage collection (OCaml, Python, etc.",-0.75,Python
15dmp16,ju31tvy,Rust enums are great to represent an AST.,0.8,Rust
15dmp16,ju31tvy,"I usually do something like this:  ```Rust enum Toplevel {     Struct {         name: String,         fields: Vec<Parameter>,     }     Function {         name: String,         parameters: Vec<Parameter>         body: Vec<Expression>,     } }  struct Parameter {     name: String,     ty: Type, }  enum Expression {     Block(Vec<Expression>),     FunctionCall {         name: String,         parameters: Vec<Expression>,     }     Assignment(String, Box<Expression>), } ```  Rust has frameworks for LLVM, native and some more unique ones, I didn't get anything useful working with any of them.",0.23125,Rust
15dmp16,ju34r5x,"Of those listed, I think Rust is the best.",1.0,Rust
15dmp16,ju34r5x,"It is seemingly more difficult, but really it’s just that memory management is hard and Rust doesn’t let you manage it poorly (by poor I mean with potential access violations).",-0.11488095238095239,Rust
15dmp16,ju34tyk,"If you’re making an interpreter and you care at all about performance, you’ll want to use a performance-oriented language like Rust.",0.0,Rust
15dmp16,ju34tyk,Haskell and OCaml are good choices.,0.7,Haskell
15dmp16,ju34tyk,"Rust can work here, but the overhead of learning Rust’s idiosyncrasies is probably not worth it.",-0.15,Rust
15dmp16,ju9fzbr,C has been a great non-nonsense language for me to write my compiler in.,0.8,C
15dmp16,ju9fzbr,I personally don’t think the added abstractions of even C++ was helpful (which I previous experience writing compiler code in).,-0.08333333333333333,C++
15dmp16,juj9c07,"Common Lisp, using Metaobject Protocol.",-0.3,Lisp
15dmp16,juptgea,"I think having match expressions and algebraic types helps A LOT in creating compilers, so I'd choose Rust if I were implementing a VM or transpiler.",0.0,Rust
15dmp16,juptgea,"However, libraries for using LLVM are a bit limited compared to C and C++.",-0.07142857142857142,C
15dmp16,juptgea,"However, libraries for using LLVM are a bit limited compared to C and C++.",-0.07142857142857142,C++
15dmp16,ju4k11g,"Since you mention C#, I wonder if you've tried F#.",0.0,C
15dmp16,ju6obaj,">Haskell, Standard ML, and other functional languages share much of the advantages of OCaml, but suffer from a ""purity problem"" that OCaml lacks.",0.025000000000000005,Haskell
15dmp16,ju6obaj,"I would like to add that the absence of mathematical jargon definitely makes OCaml more approachable, which alone may be a compelling enough reason to use OCaml over Haskell.",0.13125,Haskell
15dmp16,ju3afsx,>Compile time function execution  Could you explain how C helps compile-time execution?,0.0,C
15dmp16,ju3afsx,(Because this is not a feature of C itself.),0.0,C
15dmp16,ju5nut3,I cant think of anything about ocaml or Haskell that would make mini me languages particularly easy for a compiler - can you please elaborate?,0.4666666666666667,Haskell
15dmp16,ju3j5q4,"Racket, Ocaml or Haskell.",0.0,Haskell
15dmp16,ju3mn6u,"For comparing, I can only comment on languages I've used:  * Go doesn't provide enough PL-implementation-relevant power to make it a serious contender.",-0.1111111111111111,Go
15dmp16,ju3mn6u,"* Rust is a good choice in the context of worse choices (C, etc), but is not a good choice in the context of better choices (most functional languages, etc).",0.19,Rust
15dmp16,ju3mn6u,"* Rust is a good choice in the context of worse choices (C, etc), but is not a good choice in the context of better choices (most functional languages, etc).",0.19,C
15dmp16,ju3mn6u,"* Haskell is a great choice in the context of worse choices (Rust, etc), but is not a good choice in the context of better choices (OCaml).",0.1375,Haskell
15dmp16,ju3mn6u,"* Haskell is a great choice in the context of worse choices (Rust, etc), but is not a good choice in the context of better choices (OCaml).",0.1375,Rust
15dmp16,ju3mn6u,"OCaml is a productivity-first functional language with all of the expressive power you need for PL implementation, none of the irrelevant challenges you'd be faced with RE Rust et al, and overall gets recommended frequently by the people who use it for PL implementation for a reason.",0.1,Rust
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,COBOL
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,C
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,C++
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,Java
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,Pascal
15dmp16,ju5g06y,"Frankly, Ruby and Perl are huge in this field (not that I would choose either), proving that flexibility sometimes trumps good design.",0.55,Ruby
15dmp16,ju5g06y,"Frankly, Ruby and Perl are huge in this field (not that I would choose either), proving that flexibility sometimes trumps good design.",0.55,Perl
15dmp16,ju6nw0w,"Parsing is certainly easiest in Haskell, and if you're making a simple interpreter then that might be a worthwhile factor",0.2380952380952381,Haskell
15dmp16,ju3ejji,"> If you’re making an interpreter and you care at all about performance, you’ll want to use a performance-oriented language like Rust.",0.0,Rust
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Go
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Haskell
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Lisp
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Java
15dmp16,ju3ejji,or has easy integration with a production-quality GC like the [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) (which has C and C++ bindings).,0.43333333333333335,C
15dmp16,ju3ejji,or has easy integration with a production-quality GC like the [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) (which has C and C++ bindings).,0.43333333333333335,C++
15dmp16,ju3ejji,I don't think Rust's memory management model is very conducive to running as an interpreter for languages with dynamic memory allocation.,0.1,Rust
15dmp16,ju4ow7t,:D,1.0,D
15dmp16,ju3f2yv,It's actually more due to the fact that I want seamless C imports with no FFI.,0.15833333333333333,C
15dmp16,ju3f2yv,I could do this if I transpile down to C with any language.,-0.15555555555555559,C
15dmp16,ju3f2yv,"However since I allow CTFE on native C functions too, it's much easier for my VM to dynamically call dynamic library code with C than a language with an FFI to C.  So I wouldn't say it helps with CTFE but if I want seamless C and CTFE at the same time, my options seem limited to C or C++.",0.04571428571428572,C
15dmp16,ju3f2yv,"However since I allow CTFE on native C functions too, it's much easier for my VM to dynamically call dynamic library code with C than a language with an FFI to C.  So I wouldn't say it helps with CTFE but if I want seamless C and CTFE at the same time, my options seem limited to C or C++.",0.04571428571428572,C++
15dmp16,ju4y86w,What do you think makes OCaml a better choice than Haskell?,0.5,Haskell
15dmp16,ju7w0nx,"If you're already proficient with Haskell, OCaml doesn't have any additional advantage.",0.0,Haskell
15dmp16,ju7w0nx,"Haskell introduces concepts that aren't immediately useful for being time-zero productive, that are also varying degrees of famously difficult to grok.",-0.1,Haskell
15dmp16,ju7w0nx,"I'd rephrase my thought as:  * For someone who is already proficient in Haskell and/or OCaml, they can both be equally good choices.",0.7,Haskell
15dmp16,ju9fge9,"I'm intimately familiar with Haskell but I can certainly imagine Haskell's enforced purity, category theoretic jargon and laziness by default being additional hurdles to those new to the language.",0.2418831168831169,Haskell
15cxb1a,jtzatjr,"Of course, non-deterministic methods might be necessary for some languages such as C++, but I hope to avoid them and only use them as a last resort for disambiguating actual ambiguities and not just inadequate states that can be fixed with deterministic techniques.",0.016666666666666666,C++
15cnhsc,jtx9z61,"With the 3 topics you suggested I would consider looking into things like behavioral types in Rust, such as typestates and session types.",0.0,Rust
15caifs,,"here's the introduction in that repo:  # Introduction Tungstyn is an interpreted scripting language, primarily inspired by LISP, ECMAScript, and Lua.",0.4,Lua
15caifs,ju6knwo,"Reminds me of [Tcl](https://wiki.tcl-lang.org/page/Dodekalogue), what with prefx notation, square brackets and explicit $variables.",0.0,Tcl
15caifs,jtvkhxj,such is C ¯\\\_(ツ)_/¯,0.0,C
15c4q04,jtwi0w9,"At this point, Rust is quite widely deployed and it's unlikely there will be any backward-incompatible changes to the language like there has been in the past.",-0.2833333333333333,Rust
15c4q04,jtwi0w9,So it will not be necessary to update this project with trivial changes to the Rust compiler.,0.0,Rust
15c4q04,jtwi0w9,It can freeze the version of Rust it forked from.,0.0,Rust
15c4q04,jtwi0w9,"But if there's future Rust versions, say Rust V4 or Rust V5, then it will probably still be simpler to track the main Rust compiler to update this project to support future Rust versions, rather than maintaining a completely separate compiler.",0.06666666666666667,Rust
15by6a3,ju41h4j,And why not write it in Pascal?,0.0,Pascal
15by6a3,jucld4i,"Pascal is a bit closer to my Oberon+ language than Go and I consider it much leaner than the huge implementations with complex multi-layer build processes we usually see from Google, and the Go code, in contrast to FP, depends on a garbage collector.",0.012500000000000025,Pascal
15by6a3,jucld4i,"Pascal is a bit closer to my Oberon+ language than Go and I consider it much leaner than the huge implementations with complex multi-layer build processes we usually see from Google, and the Go code, in contrast to FP, depends on a garbage collector.",0.012500000000000025,Go
15by6a3,jucld4i,"I actually had a look at the internals of V8, Dart and Go over the years; re-using a simplified version of V8 would be interesting, but - in contrast to JVM or e.g.",0.25,Dart
15by6a3,jucld4i,"I actually had a look at the internals of V8, Dart and Go over the years; re-using a simplified version of V8 would be interesting, but - in contrast to JVM or e.g.",0.25,Go
15bufdn,jtsrujy,"The SIMULA language was offically published to the IFIP in 1962 (""An Extension of ALGOL to the Description of Discrete Event Networks"") - but Ive not been able to find any copy of this paper (If anyone has a copy, please let me know!)",0.625,ALGOL
15bufdn,ju6x8pe,"UNIVAC 1107 computer's ALGOL compiler (developed at CASE University in Cleveland), and was finished in December 1964.",0.1,ALGOL
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,C++
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,ALGOL
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,Fortran
15b5tr7,jtots69,[COBOL on Wheelchair](https://web.archive.org/web/20160415075723/azac.pl/cobol-on-wheelchair/) is a thing.,0.0,COBOL
15b5tr7,jtots69,So are the [Bash](https://github.com/dzove855/Bash-web-server) [web](https://yoctu.github.io/yosh/) [frameworks](https://github.com/nerdgeneration/www.sh/blob/master/code/www.sh).,0.0,Bash
15b5tr7,jtots69,"And so, C code too?",0.0,C
15b5tr7,jtots69,"Also, PHP.",0.0,PHP
15b1rxq,jtnyt3v,Rust compiles closures by converting them to `struct` with fields of the variables that were captured.,0.0,Rust
15b1rxq,jto8duv,"Rust, C++?",0.0,Rust
15b1rxq,jto8duv,"Rust, C++?",0.0,C++
15b1rxq,jtogiet,Common Lisp?,-0.3,Lisp
15b1rxq,jtoj7qp,A lambda is isomorphic to a virtual method (AKA C++ and even C with certain patterns).,0.21428571428571427,C++
15b1rxq,jtoj7qp,A lambda is isomorphic to a virtual method (AKA C++ and even C with certain patterns).,0.21428571428571427,C
15b1rxq,jtoj7qp,"A lambda type in C could be defined something like this:  ``` struct BasicLambda { int (*func)(int arg1, void* context); void* context; }; ```",0.0,C
15b1rxq,jtogcni,"I think Crystal programming based on LLVM has lambda, they're termed as Proc.",0.0,Crystal
15b1rxq,jtogcni,Edit: [Link to Crystal Proc documentation](https://crystal-lang.org/reference/latest/syntax_and_semantics/literals/proc.html),-0.75,Crystal
15b1rxq,jtqgtir,"GHC Haskell can compile to both llvm and its native codegen, and it has much more lambdas (and closures) than most other languages.",0.2916666666666667,Haskell
15b1rxq,jtqgtir,"Seriously, Haskell is very serious about optimizing lambdas, because they are used a lot in typical programs.",-0.31111111111111106,Haskell
15b1rxq,jtow2pn,"If you’re compiling AOT you could raise the lambda to top level and just have it as a function, I’ve not worked with llvm much but this is how I’ve done it previously and afaik schemes that compile to C also do it this way",0.17777777777777778,C
15b1rxq,jtoxczl,"Llvm is not like Java or .Net CLR, is a low level VM.",0.0,Java
15b1rxq,jtoxczl,Check how C++ and C# implemented lambdas ...,0.0,C++
15b1rxq,jtoxczl,Check how C++ and C# implemented lambdas ...,0.0,C
15b1rxq,jtpubuy,"clang itself supports C lambdas ([""blocks""](https://en.wikipedia.org/wiki/Blocks_(C_language_extension\))) as an extension: https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/CGBlocks.cpp",0.0,C
15b1rxq,jtroems,How does Rust compile functions that can take either a function or a closure as an argument?,0.0,Rust
15b1rxq,jtoizov,"For example, JavaScript named functions (not lambda) are closures.",0.0,JavaScript
15b1rxq,jtt2cof,This `impl Trait` example is roughly syntax sugar for:       fn foo<F: Fn()>(f: F) { ... }  and Rust compiles generic functions via monomorphization.,-0.05,Rust
15b1rxq,jtou4ee,"I don't think Rust closures contain a function pointer; rather, they implement the `Fn`/`FnMut`/`FnOnce` traits which have the associated function `call`.",0.0,Rust
15b1rxq,jtq8las,"JavaScript functions are always closures, irrespective of being named or anonymous.",0.0,JavaScript
15b1rxq,jtq8las,"For example:      function outer(param) {         function inner() {             // closes over ""param""             console.log(param)         }         return inner     }  See also: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures  > In JavaScript, closures are created every time a function is created, at function creation time.",0.0,JavaScript
15b1rxq,jtomu1h,"If you need to expand to plain-old-functions, a common way is to have the object reference become the first argument of the function, so it would become (in C):      void __lambda_f(__closure_f * __c, int x);  The return type would be a function pointer of the type:      void (*__f)(__closure_f *, int);",-0.024999999999999994,C
15b1rxq,jtp4hlh,"If you’re specifically interested in return types - the Rust approach is to use traits (interfaces) for the closure types, which describe what the thing does rather than what the thing is (closures do not have a concrete identifiable type for a few reasons).",0.075,Rust
15b1rxq,jtp4hlh,"When not using `dyn` (so, the normal case) Rust’s compiler does something called “monomorphization” where it replaces trait-based generics with the real function, meaning there’s no runtime vtable or overhead - yay, equivalent performance to writing the thing by hand!",0.2,Rust
15b1rxq,jtp4hlh,"The monomorph topic goes beyond closures, and is discussed here https://rustc-dev-guide.rust-lang.org/backend/monomorph.html  Summary: Rust never lets you give a concrete type to a closure, instead you use a generic that describes what it _does_ rather than what it _is_, and the compiler expands it for you.",0.07500000000000001,Rust
15b1rxq,jtp4hlh,"I’d recommend reading up on how Rust does it even if you aren’t familiar with the language, because it has some of the best documentation out there for this very very complex process.",0.3283333333333333,Rust
15b1rxq,jtoyejk,Closures/anonymous functions in C++ and Rust are implemented by generating a unique type for every closure.,0.375,C++
15b1rxq,jtoyejk,Closures/anonymous functions in C++ and Rust are implemented by generating a unique type for every closure.,0.375,Rust
15b1rxq,jtoyejk,"As you mention, the Fn traits in Rust are used to constrain what the arguments and return types of these unique closure types are.",0.375,Rust
15b1rxq,jtoyejk,In C++ there is no way to write the actual type of a closure in the language.,0.0,C++
15b1rxq,jtoyejk,This is why you see the use of auto frequently when using closures in C++.,0.1,C++
15b1rxq,jtoyejk,The C++ std::function wrapper works a bit differently: it uses heap allocation and type erasure to store the closure.,0.0,C++
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,C++
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,C
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,Rust
15b1rxq,jtomblq,"I think Rust, Zig and Nim are three examples of this being done right.",0.2857142857142857,Rust
15b1rxq,jtooi1g,Is your VM like a VirtualBox VM or a Java RE VM?,0.0,Java
15b1rxq,jtrhdf6,"There are some minor differences between “ordinary” JavaScript functions and arrow functions, the biggest being how `this` is bound.",-0.15,JavaScript
15b1rxq,jtsw26d,"> JavaScript functions are always closures  Unless they do not capture anything from the outer scope, right?",0.2857142857142857,JavaScript
15b1rxq,jtt8n5f,"For JavaScript specifically, it's a dynamically typed language so there's no ahead-of-time process to determine which variables are local vs. free (captured from enclosing scope) so functions are always going to have an associated environment.",0.2,JavaScript
15b1rxq,jtou80x,"I implement them using the C preprocessor, with one or more macros per instruction which emit the assembled bytes into an array.",0.5,C
15b0517,,One of the reason people like Ruby is that it's fairly readable.,0.7,Ruby
15b0517,jtnpl9q,Racket carried forward the Lisp tradition and allows almost any symbol (except braces) to appear almost anywhere within an identifier.,0.0,Lisp
15b0517,jtnpl9q,The other comment mentions using `?` and `!` for optional handling (as is done in Swift).,-0.15625,Swift
15b0517,jtnun9l,The Racket and Clojure tradition of using ?,0.0,Clojure
15b0517,jtnun9l,"Elixir's use of % and of => for example, to do key/values is annoying.",-0.8,Elixir
15b0517,jto7bqb,People coming from Ruby will probably like it.,0.0,Ruby
15b0517,jtolq9b,"Elixir uses this convention, and it makes code delightfully readable.",1.0,Elixir
15b0517,jtorfdo,That way it'd keep the Lisp/Ruby tradition and not clash with C#/JavaScript conventions entirely.,0.0,C
15b0517,jtosohn,Ruby is a lisp derivative.,0.0,Ruby
15b0517,jtosohn,"[Here's a quote from the creator, Matz:](https://web.archive.org/web/20181027195101/blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642)  > Ruby is a language designed in the following steps: > >  * take a simple lisp language (like one prior to CL).",0.125,Ruby
15b0517,jtosohn,>  * add functionality found in Perl (in OO way).,0.0,Perl
15b0517,jtosohn,"> >So, Ruby was a Lisp originally, in theory.",0.375,Ruby
15b0517,jtosohn,"> >So, Ruby was a Lisp originally, in theory.",0.375,Lisp
15b0517,jtosohn,;-)  So it's not hard to see how a lot of lisp ideas (like Symbols as a language construct) and idioms got brought over into Ruby.,0.19791666666666669,Ruby
15b0517,jtq9uoi,"Although I like Scheme, I dislike the use of dedicated predicates for types as opposed to a generic operator for testing types.",0.0,Scheme
15b0517,jtopr3k,Ruby uses & for safe navigation.,0.5,Ruby
15b0517,jtv6okw,Ruby was designed in Japan so the question mark was more natural for them.,0.3,Ruby
15b0517,jtorydh,Ruby does suport ternaries with that syntax and it's not too bad.,-0.6999999999999998,Ruby
15b0517,jtshdbp,"But Scheme also marks mutating functions with a suffix `!`, which suggests an interrobang for predicates which also mutate.",0.0,Scheme
15b0517,jtwfshj,"I looked at it from the perspective of Scheme, which uses the `predicate?` convention and comes with dozens of built-in predicates, but most of them are simple type tests, and IMO, the absence of `is` in Scheme is a drawback.",0.1625,Scheme
15at643,,Prolog in [Charm](https://github.com/tim-hardcastle/Charm) they could do it without any help from me.,0.0,Prolog
15at643,,"Note also that I already have embedded Go, so by using that people can perfectly well define their own extensions to the IO system — e.g.",0.8,Go
15at643,,"if Go has a library for talking to knitting machines, then a power user can whip up a library using embedded Go that implements a command with signature `post (pattern KnittingPattern) to (machine KnittingMachine)`.",0.0,Go
15at643,,But it is essential to the person who wants to embed Prolog in the same sort of way.,0.06666666666666667,Prolog
15at643,,"And as with the IO commands, since you can already embed Go, you can do what you like with this.",0.0,Go
15at643,,"If you *want* to embed Python into Charm, then you are a very sick person, but since Go can call Python you can do that.",-0.9285714285714286,Python
15at643,,"If you *want* to embed Python into Charm, then you are a very sick person, but since Go can call Python you can do that.",-0.9285714285714286,Go
15at643,jtp223m,"There's also [Quasiquotation in Haskell](https://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf), where you might be able to write a quasiquoter to look like:      [sql|         SELECT ID, NAME, SALARY          FROM CUSTOMERS         WHERE SALARY > $threshold$     |]  I believe Raku also supports embedding languages, and parts of the language itself is implemented using its facilities for embedding.",-0.125,Haskell
15at643,jtp223m,"Of these approaches I think the Wyvern's best solves the embedding problem, as whitespace sensitivity resolves ambiguity issues without the need for syntax directed editing (eg, [Language Boxes](https://soft-dev.org/pubs/pdf/diekmann_tratt__parsing_composed_grammars_with_language_boxes.pdf)), or special, per-language delimiters, whereas Nemerle and Haskell can still have ambiguity issues in the embeddings, and I'm not familiar enough with Raku to determine whether or not it can resolve all ambiguity issues.",0.2924107142857143,Haskell
15at643,jtpda2i,"You need to define a new DSL for every language pair, and it does not address the potential for nested embeddings (Eg, Prolog in SQL in Charm).",0.06818181818181818,Prolog
15at643,jttmuzh,"Most of the time it's the C ABI, so there *is*, kind of, a standard way to interact between languages - via C.  But aside from that, if you have a base language, you can implement any embedded language in its types, or interpret it in the base language.",-0.1,C
15aie5u,jtmavec,It looks like this       # Source location for errors     loc =        Missing  # equivalent of runtime.NO_SPID     | Token %Token       # Very common case: argv arrays need original location     | ArgWord %CompoundWord     | WordPart(word_part p)   https://www.oilshell.org/release/0.17.0/source-code.wwz/frontend/syntax.asdl   And then it translates to both typed Python and typed C++.,-0.0716666666666667,Python
15aie5u,jtmavec,It looks like this       # Source location for errors     loc =        Missing  # equivalent of runtime.NO_SPID     | Token %Token       # Very common case: argv arrays need original location     | ArgWord %CompoundWord     | WordPart(word_part p)   https://www.oilshell.org/release/0.17.0/source-code.wwz/frontend/syntax.asdl   And then it translates to both typed Python and typed C++.,-0.0716666666666667,C++
15aie5u,jtmavec,"So the nice thing is that the C++ lets you see the memory layout directly, and it has evolved over the years.",0.35,C++
15aie5u,jtmavec,I believe people hit this problem over and over again and Rust -- variants aren't types by themselves.,0.0,Rust
15af770,,What are your thoughts on using Zig's C compiler as a backend?,0.0,C
15af770,,Let the codegen just spit plain C and let zig c take cover.,-0.21428571428571427,C
15af770,jtllxnb,And there are some platforms that only have ANSI C compilers.,0.0,C
15af770,jtllxnb,You could target those if you make your C output conservative enough!,0.0,C
15af770,jtki01y,C is a great target used by lots of languages!,1.0,C
15af770,jtki01y,And rather than limiting yourself to Zig you can use whichever C compiler is most suitable for the task as hand.,0.525,C
15af770,jtkjk9k,Is there some reason to use Zig's C compiler specifically?,0.0,C
15af770,jtkjk9k,"You're targeting C, you can use any C compiler",0.0,C
15af770,jtl0aho,"If you plan to use zig compiler as backend, I would advise to target pure Zig instead of C compiled by zig.",0.21428571428571427,C
15af770,jts973w,"I switched to using Zig CC for all my new and main C projects, including libsodium.",0.1515151515151515,C
15af770,jts973w,The fact that the C library gets optimized with the same options as the rest of the app is also a good way to get either smaller or faster code than with a generic package of the C library.,0.175,C
15af770,jts973w,I also use `cargo-zigbuild` to build packages for Rust projects.,0.0,Rust
15af770,ju6c07m,:( I had planned adding support for gcc/clang/msvc etc as well (did not get to do it yet)      (generated code should still compile with other C compilers),-0.4375,C
15af770,jtnbo64,"If you're going to target C, then what you do have is a big choice of compilers.",0.0,C
15af770,jtkozgt,"Another major plus is that you can use zig itself, which is for many cases better than straight C (C for FFI only IMHO).",0.2525,C
15af770,jtmgxmo,"Also, dropping LLVM doesn't mean Zig can't compile C. C can be easily transpiled to Zig so I don't see the issue here.",0.060416666666666674,C
15af770,jtkxsx9,There are lots of languages that can compile to C or C++!,0.0,C
15af770,jtkxsx9,There are lots of languages that can compile to C or C++!,0.0,C++
15af770,jtkxsx9,Haskell and Erlang used to be able to too.,0.5,Haskell
15af770,jtkxsx9,Haskell and Erlang used to be able to too.,0.5,Erlang
15af770,jtn4gi6,I was pointing out that you can take advantages of the strengths of other C compilers too.,-0.125,C
15af770,jtlr715,Allso a subset of F* compiles to C.,0.0,C
15af770,jtn5jqa,The C compilers all implement the same API so languages that compile to C can make use of the $CC environment variable to permit the programmer to select the compiler of their choice.,0.0,C
15af770,jtnj95f,"I assure you, I fully understand the advantages of Zig's C compiler.",0.0,C
15af770,jtnj95f,It is [one of its advertised strengths](https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html) that it implements the standard C compiler API and so can be swapped in-and-out with other C compilers without any additional work.,-0.0625,C
15af770,jtnj95f,"This means that you can, for free, take advantage of the best of all the C compilers and use whichever is best for the problem at hand.",0.7999999999999999,C
15af770,jtnj95f,Zig is not a universally superior C compiler.,-0.35,C
15af770,jtnj95f,There are many C compilers and they can excel in many different ways.,0.3333333333333333,C
15af770,jtnj95f,Targeting standard C rather than a non-standard Zig subset has many advantages and no disadvantage.,0.25,C
15a9pzh,jtjflkm,"In Lua this would look like this:  ```lua local function loop()     if condition then         return -- ""break""     end     return loop() -- fallthrough tail call end ```  The obvious alternative to a `break` is a `goto` (which can also be achieved using an early `return` inside a function), but that isn't any cleaner.",0.03333333333333333,Lua
15a9pzh,jtmwaaf,"The example by /u/till-one in [Effekt](https://effekt-lang.org/):      effect Break[A](): A      def forRange(lower: Int, upper: Int) { body: Int => Unit / Break } = {       def loop(i: Int): Unit / Break = {         if(i <= upper) {           body(i);           loop(i + 1)         }       };       try {         loop(lower)       } with Break[A] { () }     }      def f(a: Boolean, b: Boolean) = {       forRange(1, 5) { i =>         if(a) { do Break() };         println(""A"")         forRange(1, 6) { j =>           if(b) { do Break() };           println(""B"")         }       };       forRange(1, 7) { i =>         if(i == 5 && a) { do Break() };         println(""C"")       }     }      def main() = {       f(true, true)     }  Breaking out of a loop, just like early return, is non-local control flow and therefore effectful.",0.12333333333333332,C
15a9pzh,jtl1k6r,"Ada has `exit when`, which combines the typical if-break into a single statement.",-0.11904761904761904,Ada
15a9pzh,jtk3osn,Here is a mainstream language: JavaScript.,0.0,JavaScript
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,Haskell
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,Python
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,C
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,Kotlin
15a9pzh,ju7f1mq,Continuations in Scheme can be used to create all sorts of control-flow operators including `break`.,0.0,Scheme
15a9pzh,ju7f1mq,"I recently wrote Racket versions of Common Lisp `block`, `return` and `return-from` using them, for example, to make imperative style loops easier to work with.",-0.15,Lisp
15a9pzh,jua250z,"The canonical primary source on this line of thinking is [Structured Programming with Go To statements, by Donald Knuth](https://pic.plover.com/knuth-GOTO.pdf).",0.4,Go
15a9pzh,jtqa8za,"In C implementation of breaks you could do setjmp/longjmp, regardless of what the statement is.",0.0,C
15a9pzh,jtllkju,"In this case, the use of `goto` (which Lua has recently acquired - a good move as most languages are doing away with it), can trivially take the place of `break`, without turning all of my code upside down.",0.26111111111111107,Lua
15a9pzh,jtnow7j,Same with Scala.,0.0,Scala
15a9pzh,jtk256z,"In nested loops I even want a more powerful break/continue (in PHP you can do `break 2` to break out of 2 loops for example, other languages provide labels).",0.225,PHP
15a9pzh,jtkrmq7,"In Lua, this would look like this:  ```lua (function()     while loopcond do         if breakcond then return end         ...     end end)() ```  which of course in general isn't particularly beautiful (though something similar is sometimes used to emulate `continue` in Lua 5.1 which doesn't have `goto`, but that's more of a hack).",0.35,Lua
15a9pzh,jtm2odi,"Eh, it's rather clunky in Lua, but in more FP-centric languages (Ocaml, Haskell etc) 3 local tail-recursive functions is probably how you'd do it.",0.25,Lua
15a9pzh,jtm2odi,"Eh, it's rather clunky in Lua, but in more FP-centric languages (Ocaml, Haskell etc) 3 local tail-recursive functions is probably how you'd do it.",0.25,Haskell
15a9pzh,jtn3dyo,"That said, when you're writing idiomatic, imperative Lua, of course use `break`.",0.0,Lua
15a9pzh,jtvusfw,I took the fannkuch example and wrote it in very basic Scheme: [here](https://www.jdoodle.com/ia/Ku8).,-0.375,Scheme
15a9pzh,jtvusfw,I translated from a [C version](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-3.html) I found because I find C more familiar than Lua and it was already organized in a way that didn't require `break`.,0.4375,C
15a9pzh,jtvusfw,I translated from a [C version](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-3.html) I found because I find C more familiar than Lua and it was already organized in a way that didn't require `break`.,0.4375,Lua
15a9pzh,jtn6tuy,"Here's a [real example](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-lua-1.html) in Lua, which has `break` in two separate loops, both of them nested inside an enclosing loop.",0.2,Lua
15a9pzh,jtxu3zh,That Scheme looks surprisingly good when laid out like that.,0.7,Scheme
15a9pzh,jtxu3zh,"But then, so does the original C!",0.46875,C
15a9pzh,jtxu3zh,"While C does have `for`\-loops, sort of, they're still a lot of work, and the first two examples in your link are also non-idiomatic: I had trouble recognising what they did.",0.024999999999999994,C
15a9pzh,jtxu3zh,(BTW the non-`break` C version ran 10-50% slower than the `break` version - just saying.),0.0,C
15a9pzh,jty3tkn,Scheme - especially when you use such a minimal canonical subset like I did - is a language that doesn't place concision at an especially high priority.,0.055,Scheme
15a9pzh,jty3tkn,Scheme code written by Scheme experts to get work done - rather than Scheme code written by a C programmer for demonstration - tends to be more concise because people build tools within the language to help keep the code shorter.,0.3,Scheme
15a9pzh,jty3tkn,Scheme code written by Scheme experts to get work done - rather than Scheme code written by a C programmer for demonstration - tends to be more concise because people build tools within the language to help keep the code shorter.,0.3,C
15a9pzh,jty3tkn,I wouldn't have written the C code that way and I refactored it a bit in C before I tried translating to Scheme.,0.0,C
15a9pzh,jty3tkn,I wouldn't have written the C code that way and I refactored it a bit in C before I tried translating to Scheme.,0.0,Scheme
15a9pzh,jty3tkn,Are you saying that Scheme doesn't have loops as a feature?,0.0,Scheme
15a9pzh,jty3tkn,"In a language like Scheme - setting aside continuations, which I intentionally left out of my language - you can get a better idea about control flow just by looking at the shape of the code and the initial keywords.",0.16666666666666666,Scheme
15a9pzh,jty3tkn,"If I find some time, I might go through the exercise of starting from the Lua code to see how that goes.",0.0,Lua
15a9pzh,jtzitc0,I took some time to look at the Lua code a bit and I realized that eliminating the `break` statements in that code is really trivial to do.,0.2,Lua
15a9pzh,jtzitc0,"while (A) {         if (B) {             C;             break;         }         D;     }      ; Added X and Y for the loop state variables and updates, which are implicit above.",0.0,C
15a9pzh,jtzitc0,"while (A) {         if (B) {             C;             break;         }         D;     }      ; Added X and Y for the loop state variables and updates, which are implicit above.",0.0,D
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,C
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,D
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,Scheme
15a4z4c,,"Go has GC, so prototyping language can do whatever they want without caring about memleak 2.",0.0,Go
15a4z4c,jtj7w87,"Funny you mention that, I started targeting Go last week, and was surprised I couldn't find anyone else doing it.",0.11666666666666665,Go
15a4z4c,jtj7w87,Rust is definitely more meticulous about these things.,0.5,Rust
15a4z4c,jtizkys,"It's probably a decent idea, I mean the points that you listed in favour of Go make sense and seem valid.",-0.07291666666666667,Go
15a4z4c,jtizkys,"If so you probably have to mess with CGo, and as the gophers say: [""CGo is not Go""](https://dave.cheney.net/2016/01/18/cgo-is-not-go) 2.",-0.4625,Go
15a4z4c,jtizkys,Does the Go runtime support everything you need and/or are you willing to build that (ex.,0.25,Go
15a4z4c,jtizkys,"Obviously if you are building a new language rather than just using Go, there must be something it doesn't have that you want.",0.06818181818181818,Go
15a4z4c,jtizkys,The Go compiler is oddly strict about some things but not others.,-0.16666666666666666,Go
15a4z4c,jtimu6p,"> Go has GC, so prototyping language can do whatever they want without caring about memleak  That isn't exactly true.",0.35,Go
15a4z4c,jtimopj,"However, if you have a specific goal in mind for your language(like adding a type system to an already existing dynamic language(TypeScript-style), or to be used instead of another language in a certain niche (like JavaScript in webdev, Elm-style), then you need to make choices based on that goal/niche.",0.07142857142857142,JavaScript
15a4z4c,jtinneo,Go is also a pretty simple language so you’re not going to get bogged down in trying to do fancy syntax tricks or messing around with language features.,-0.0263888888888889,Go
15a4z4c,jtixdrn,If you want what Go provides then sure.,0.5,Go
15a4z4c,jtixdrn,"I think the biggest issue is that GC and the various runtime magic Go uses makes it hard to support in webassembly, which makes it hard to provide online demos.",-0.020833333333333343,Go
15a4z4c,jtixdrn,You might want to consider targeting JS instead of or in addition to Go in order to make it easy to provide in-browser demos.,0.43333333333333335,Go
15a4z4c,jtm5jgi,"I need to write a new backend in Go to replace my treewalker, so it's this route or a VM.",0.13636363636363635,Go
15a4z4c,jtjb88l,"If you want a target language that is not C, Rust is probably the best replacement.",1.0,C
15a4z4c,jtjb88l,"If you want a target language that is not C, Rust is probably the best replacement.",1.0,Rust
15a4z4c,jtjb88l,"That gets you easy ffi to the C abi, more supported architectures, and, potentially, support for embedded devices.",0.3111111111111111,C
15a4z4c,jtjb88l,"Go has some fun footguns you will inherit, like their slice invalidation and “default values” which cause a lot of issues.",0.3,Go
15a4z4c,jtizalo,">runtime magic Go uses makes it hard to support in webassembly  Go is one of the easier languages to compile to WASM, second only to Rust.",0.05208333333333333,Go
15a4z4c,jtizalo,">runtime magic Go uses makes it hard to support in webassembly  Go is one of the easier languages to compile to WASM, second only to Rust.",0.05208333333333333,Rust
15a4z4c,jtkqen4,"I really want to see a successful case of someone compiling a non-Rust-like language to Rust, because it sounds like a nightmare to me.",0.475,Rust
15a4z4c,jtkqen4,"And since OP is interested in simply borrowing Go's GC, they're probably interested in supporting programs that are worst-case for Rust codegen.",0.1875,Go
15a4z4c,jtkqen4,"And since OP is interested in simply borrowing Go's GC, they're probably interested in supporting programs that are worst-case for Rust codegen.",0.1875,Rust
15a4z4c,jtkqen4,"And to be clear, I'm a Rust enthusiast so I'd love to be proven wrong, but it really doesn't seem like the right use case.",0.11714285714285713,Rust
15a4z4c,jtm9nd2,"If I want C ABI, why not just use C?",0.0,C
15a4z4c,jtjw9ut,"Imo, a proper ownership model with RAII is really all you need for memory management - especially if your language is more strict about object lifetimes then eg C++.",0.175,C++
15a4z4c,jtjp9ck,"WASM applications for the web benefit from having super tiny sizes, and having to generate code for the Go runtime is not great in that regard.",-0.022222222222222237,Go
15a4z4c,jtm6xbn,"> I really want to see a successful case of someone compiling a non-Rust-like language to Rust  That's pretty much what procedural macros are for, and there are lots of examples of proc-macro based custom DSLs.",0.35,Rust
15a4z4c,jtm6xbn,"I've also personally worked with Rust code-generation based on a custom SQL DSL (and yes it deals with lifetimes), and I'm sure there are plenty other examples.",0.125,Rust
15a4z4c,jtm6xbn,"Not saying that Rust is a good call, but I also don't think it's as bad as you say.",5.551115123125783e-17,Rust
15a4z4c,jtm0bdy,AFAIK TinyGo doesn't support all of Go's features and is thus not really a fair comparison.,-0.35,Go
15a4z4c,jtm0bdy,It seems like Go might not currently be a good fit for that.,0.025000000000000022,Go
15a4z4c,jtm0ozf,Does it really need to support all of Go’s features as a compilation target?,0.2,Go
15a4z4c,jtm276x,"There’s also Go Assembly, but it might be too low level, and it might not solve the size problem, as the size is almost certainly caused by the linked in stdlib.",0.10714285714285714,Go
15a4z4c,jtm276x,"There’s also Go Assembly, but it might be too low level, and it might not solve the size problem, as the size is almost certainly caused by the linked in stdlib.",0.10714285714285714,Assembly
15a4z4c,jtm33x2,"I have expressed no opinion on Go as a compiler target per se, I just gave my opinion about Go and WASM in general.",0.05000000000000002,Go
15a4z4c,jtm33x2,I don't really see what targeting Go gives you in that situation.,0.2,Go
15a4z4c,jtm4iws,"Go assembly, WebAssembly and ""real"" assembly are different things and don't operate on the same level at all.",0.06666666666666667,Go
15a4z4c,jtm4iws,"In any case it certainly wouldn't solve any bundle size problems as that has to do with Go as a language and its features, not with how it's assembled.",0.21428571428571427,Go
159b6sn,jtg8w5g,"Java’s `int`/`char` types and C/++’s unsigned integral types) is of far more practical use than any infinity would be, and this behavior can be used for tricks like single-comparison bounds checks (𝑥−𝑎 ≤ᵤ 𝑏−𝑎 ↔ 𝑥∈{[𝑎, 𝑏]}).",0.3,Java
159b6sn,jthnvsg,"There is interval arithmetic, and some languages and compilers support it (at least one Fortran compiler had vendor-specific interval arithmetic language extension).",-0.3,Fortran
159b6sn,jteu5yn,"In Lua, they go as far as using the name `math.huge` for the floating point infinity value to emphasize that it just represents a quantity that is too big to fit in a float and not necessarily a singular value representing all infinities.",0.125,Lua
159b6sn,jtht25o,In COBOL you got to choose rounding strategy.,0.0,COBOL
159b6sn,jti7c5a,"In Elm, 1 / 0 = 0.",0.0,Elm
159b6sn,juc1201,"The numbers my Pascal compiler could represent in an integer type variable was the integer range -32767..32767, not a lot.",0.0,Pascal
1597agi,,The best resource that I found so far is Lua source code (and different Lua implementations) or write ups about it.,0.3666666666666667,Lua
1597agi,,"Lua with high interoperability with C in mind, looks rather clunky and I believe dedicated implementation may be much better in terms of performance and cleanness.",0.33,Lua
1597agi,,"Lua with high interoperability with C in mind, looks rather clunky and I believe dedicated implementation may be much better in terms of performance and cleanness.",0.33,C
1597agi,jtenpy3,"I've been researching this recently, so I've got a few good resources:  - [Green Threads Explained](https://c9x.me/articles/gthreads/intro.html) - [Coroutines in Less than 20 Lines of Standard C](https://dotat.at/@/2010-01-22-coroutines-in-less-than-20-lines-of-standard-c.html) - [libaco, a fast coroutine library](https://github.com/hnes/libaco) - [ Implementing Co, a Small Language With Coroutines](https://abhinavsarkar.net/posts/implementing-co-1/)  Lua's coroutine implementation is really great and it inspired both of the C implementations I linked, but it's pretty tightly coupled to the language/VM so it's not easy to understand how it works from reading the source code.",-0.0009157509157509189,C
1597agi,jtenpy3,"I've been researching this recently, so I've got a few good resources:  - [Green Threads Explained](https://c9x.me/articles/gthreads/intro.html) - [Coroutines in Less than 20 Lines of Standard C](https://dotat.at/@/2010-01-22-coroutines-in-less-than-20-lines-of-standard-c.html) - [libaco, a fast coroutine library](https://github.com/hnes/libaco) - [ Implementing Co, a Small Language With Coroutines](https://abhinavsarkar.net/posts/implementing-co-1/)  Lua's coroutine implementation is really great and it inspired both of the C implementations I linked, but it's pretty tightly coupled to the language/VM so it's not easy to understand how it works from reading the source code.",-0.0009157509157509189,Lua
1597agi,jtenpy3,"If you spend some time working with Lua coroutines, I think you'll find it's a really elegant solution to the [What Color Is Your Function?",0.5,Lua
1597agi,jtg9mrp,"You might want to look at implementation strategies for (single shot) delimited continuations or, more recently, effect handlers, for example in Chez Scheme or OCaml 5.These are effectively a different perspective on the same feature.",0.08571428571428572,Scheme
1597agi,jte3p89,"This was written long before Python implemented `async`, and has efficient low level coroutine switching (in assembler) for x86, x86_64, arm, arm64, ppc_osx (that dates it!)",-0.025,Python
1597agi,jtfb8nr,"C# has generators which are compiled to state machines, and can be used as coroutines (e.g.",0.0,C
1597agi,jtfb8nr,You can use sharplab.io to see how they are lowered to simple C# code before compilation.,0.0,C
1597agi,jtfb8nr,"Not sure whether that satisfies your definition of coroutines, but it's been battle-tested in huge systems for many years at this point, and the C# compiler is open source.",0.16250000000000003,C
1597agi,jtoxdw3,"The code is well commented, written in C and has proper coroutine implementation (stackful).",0.0,C
1597agi,jtt7af9,"I'm not expert but I played with Protothreads in C, but that's not really proper coroutines.",0.0,C
1597agi,jtfkwp8,"Reddit must be reading my mind somehow because I was literally pacing around my room thinking about how to implement coroutines in my language written in C just before logging into Reddit to take a break, seeing this post and then this comment lol.",0.8,C
1597agi,jtgalr6,"Lua's coroutines are only ""colorless"" in the sense that there is no compiler yelling at you for using a function in the wrong context, but that just moves the error to runtime, which is arguably *worse*.",-0.3,Lua
1597agi,jtgbn9l,"That is a very different system from Lua's, which are stackful.",0.0,Lua
1597agi,jtgbn9l,"But yeah, C#/Roslyn would be a good place to look for an implementation of stackless coroutines",0.7,C
1597agi,jthfpg6,I think you're perhaps not understanding how Lua's coroutines work ([explainer](https://www.lua.org/pil/9.1.html)).,0.0,Lua
1597agi,jthfpg6,"Here's an example with Lua:      function map(fn, values)         local result = {}         for i,x in ipairs(values) do             result[i] = fn(x)         end         return result     end      -- Same whether `foo` yields or not:     result = map(foo, blah)  Versus Python:      def map(fn, values):         return [fn(x) for x in values]      # If `foo` isn't async, we can do this:     result = map(foo, blah)      # But if it is async, we gotta define an async version:     async def map_async(async_fn, values):         return [await async_fn(x) for x in values]      # And be sure to await the call:     result = await map_async(foo, blah)  I think if you spend an appreciable amount of time working with Lua's coroutines, you'll find it's a breath of fresh air and much more pleasant to work with.",0.33888888888888885,Lua
1597agi,jthfpg6,"Here's an example with Lua:      function map(fn, values)         local result = {}         for i,x in ipairs(values) do             result[i] = fn(x)         end         return result     end      -- Same whether `foo` yields or not:     result = map(foo, blah)  Versus Python:      def map(fn, values):         return [fn(x) for x in values]      # If `foo` isn't async, we can do this:     result = map(foo, blah)      # But if it is async, we gotta define an async version:     async def map_async(async_fn, values):         return [await async_fn(x) for x in values]      # And be sure to await the call:     result = await map_async(foo, blah)  I think if you spend an appreciable amount of time working with Lua's coroutines, you'll find it's a breath of fresh air and much more pleasant to work with.",0.33888888888888885,Python
1597agi,jtgvtwk,"I've been reading through chapter 9 of the book on lua.org and from what I understand, the main difference is that Lua coroutines allow yielding from deeper within the callstack.",0.16666666666666666,Lua
1597agi,jtgvtwk,Whereas in C# (or python) all yields need to be in the generator function itself.,0.0,C
15950o0,jte21wd,Is the lecture you're referring to the one on Go's metaprogramming?,0.0,Go
15950o0,jthc5ev,"Using setjmp/longjmp you can make the common path through the loop as tight as possible (at least, as tight as is possible in C without guaranteed Tailcalls).",-0.1595238095238095,C
15950o0,jtma6ty,"https://research.swtch.com/coro  > For example, Rob Pike's 2011 talk “Lexical Scanning in Go” presents the original lexer and parser for the text/template package.",0.375,Go
15950o0,jtma6ty,"I guess you had to use a state machine since it's in C, not Go.",0.0,C
15950o0,jtma6ty,"I guess you had to use a state machine since it's in C, not Go.",0.0,Go
15950o0,jtma6ty,But to be honest I don't see the similarity between this C code and what's in the video (as I remember watching it many years ago).,0.55,C
15950o0,jtjr4yh,"> Using setjmp/longjmp you can make the common path through the loop as tight as possible (at least, as tight as is possible in C without guaranteed Tailcalls).",-0.1595238095238095,C
15950o0,jtnm4ud,"You can have Goroutines in C too, I guess a light-weight call to clone3 would do it.",0.0,C
15950o0,jths30d,"This is in general quite dangerous as raw C doesn't have stack unwinding, so you need to be quite careful that you don't skip any de-initialization that was supposed to happen (e.g.",-0.22019230769230766,C
15950o0,jths30d,But for specific low-level problems it does something you can't do in C otherwise: 'goto' a location outside of the current function.,0.0,C
15950o0,jtjtvu9,I think both C and C++ would benefit from a `[[tailcall]]` attribute you could apply to a return statement that explicitly enables tail calling -- losing the debugging property of the stack trace in exchange for the guaranteed reclamation of the stack space used by the current function.,0.0,C
15950o0,jtjtvu9,I think both C and C++ would benefit from a `[[tailcall]]` attribute you could apply to a return statement that explicitly enables tail calling -- losing the debugging property of the stack trace in exchange for the guaranteed reclamation of the stack space used by the current function.,0.0,C++
15950o0,jtk7w6u,"You _can_ do stack unwinding in safe C, by manually maintaining a singly-linked list of destructors stored on stack frames, and iterating over it before `longjmp`ing.",0.5,C
1592mvm,jtdbv12,"If you’re interested in a typed Prolog and term rewriting, you should definitely check out [λ-Prolog](https://www.lix.polytechnique.fr/~dale/lProlog/).",0.125,Prolog
1592mvm,jtdyvnc,IMO it's sort of a shame that most Prolog alternatives aren't too popular.,0.55,Prolog
1592mvm,jte5308,"that you want to use as a template, and later try to emulate Prolog declarations, maybe using some collection.",0.0,Prolog
1592mvm,jtfbqxx,Prolog is so cool.,0.35,Prolog
1592mvm,jtu9gdb,It's like Prolog on steroids built into a statically typed functional language.,0.0,Prolog
1592mvm,jtp7hah,"I must shamefully admit that I have never used Prolog, but I know there is a Danish company - Prolog Development Center - that has been developing and selling a Prolog system since back in the 80es.",-0.05,Prolog
1592mvm,jtp7hah,"It of course commercial, and has even been marketed by Borland as Turbo Prolog, also as PDC Prolog and now apparently Visual Prolog.",0.0,Prolog
1592mvm,jtp7hah,"If I remember correctly what I read about it many years ago, it is indeed a Prolog version with a type system, and I would think it is a static type system.",0.5,Prolog
1592cw0,,"Basically CppFront is what I mean, its transpiler doesn't perform any semantic analysis (AFAIK) over code but just translate a new syntax in the corresponding C++, this allows the transpiler to insert useful stuff in the transpiled version, like const-by-default or order independent for function declarations.",0.030965909090909086,C++
1592cw0,jteq75t,"I've spent a lot of time programming in [Moonscript](https://moonscript.org/), which cross-compiles into Lua.",-0.1,Lua
1592cw0,jteq75t,I really like using Moonscript because it smooths over some of the clunky parts of Lua (e.g.,0.2,Lua
1592cw0,jtd30b9,"It kinda limits what you can do in your syntax sugar, but if your target language is C++ *and* your source language is supposed to be roughly the same size/power/complexity, there is only so much you can do.",0.025,C++
1592cw0,jte7327,"**  The original ""C with Objects"" transpiler that turned ""Plain C"" into ""C++"" compiler, is an example of that.",0.08035714285714286,C
1592cw0,jte7327,"**  The original ""C with Objects"" transpiler that turned ""Plain C"" into ""C++"" compiler, is an example of that.",0.08035714285714286,C++
1592cw0,jte7327,"interface where they can be executed as a Library function, instead of a command line or shell program, but I ignore if GNU C or LLVM does.",0.0,C
1592cw0,jtgs7wq,"But if along with the syntax sugar it compiles for example to a safer, easier to debug and use subset of a language ( man I wish there was a C language version of Cppfront) then yes I would definitely appreciate something like that.",0.0,C
1592cw0,jthh2b8,"Lua (and Javascript) are both very simple languages, so they work well as a set of primitives that you can build other language constructs out of (e.g.",-0.0625,Lua
1592cw0,jthh2b8,It's not hard to build a language that is a superset of Lua or Javascript.,0.14583333333333334,Lua
1592cw0,jthh2b8,"When it comes to C++, it's such an enormously complex language that I think it would be difficult to write a sugar language isn't just transpiling to a very narrow subset of C++.",-0.265,C++
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,TypeScript
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Rust
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Haskell
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Python
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,C
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,Lisp
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,Scheme
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,Clojure
158iyza,jtb7bpb,"I put Lisp in the same category as Pink Floyd and ""Zen and the Art of Motorcyle Maintenance"".",-0.05,Lisp
158iyza,jtb7bpb,"If you stumble onto Lisp in your 30s after a decade of interest in programming languages where you've absorbed most of its ideas piecemeal, it will not blow your socks off.",0.25,Lisp
158iyza,jtb7bpb,"But if you're 18 and thought you were hot shit because you wrote a 1,000 line Pascal program, your first shot of Lisp could be very mind-expanding.",0.125,Pascal
158iyza,jtb7bpb,"But if you're 18 and thought you were hot shit because you wrote a 1,000 line Pascal program, your first shot of Lisp could be very mind-expanding.",0.125,Lisp
158iyza,jtatbfg,"The [Coalton programming language](https://github.com/coalton-lang/coalton) is a strongly, statically, strictly typed programming language with eager evaluation (a la ML) and type classes (a la Haskell).",0.4333333333333333,Haskell
158iyza,jtatbfg,"Its implementation—an optimizing compiler—is ""just"" a Lisp macro, which makes it a DSL that one can use within or adjacent to Common Lisp.",-0.3,Lisp
158iyza,jtatbfg,Has Lisp historically (and sometimes anachronistically) been hyped up beyond rationality?,0.0,Lisp
158iyza,jtb7mjl,"I think, and others who I know and talk to and work with, unfortunately only for fun at the moment, in the lisp/scheme world agree with me (and you read the sentiment online often), is that when you are lucky enough to have a career where you can do fulltime Common Lisp or, even better, where you go in and out of lisp to other languages and then back, that you keep wondering, with greater and greater confusion, why everyone is making their life so hard and often quite painful.",0.05972222222222221,Lisp
158iyza,jtb7mjl,"I have been programming for over 30 years, starting with basic and I like programming languages for being programming languages (I don’t care what is the best tool for the job ; i like a language or I don’t or I have to use it because of the job) and I keep coming back to Common Lisp as the winner.",0.13999999999999999,Lisp
158iyza,jtb0zdt,"If you can stick through the few boring bits (the course was aimed at engineers at MIT so most examples have to do with engineer-y things like modeling electrical circuits etc), then I think it'll leave you with a sense of awe and an understanding of why people make the claims they make about Lisp.",-0.2333333333333333,Lisp
158iyza,jtb0zdt,"EDIT: It's not a course on Lisp, it's a course on the essence of what we call ""Computer Science"" (the very beginning of the very first lecture talks about how CS is not really a good term for this).",0.05833333333333335,Lisp
158iyza,jti9ptd,"If OOP is pragmatic like Windows, and FP is elegant like Mac, then Lisp is more like Linux where _everything_ is hackable and you're free to do anything.",0.4666666666666666,Lisp
158iyza,jti9ptd,"I seriously believe we have still only just dipped our toes into what Lisp can actually do, and there are more techniques left to discover",0.03333333333333334,Lisp
158iyza,jtarnpd,"Common Lisp is similar to Chinual Lisp, is vast, and not really a strictly functional language.",-0.1,Lisp
158iyza,jtarnpd,"Scheme is minimalistic and strongly functional, and very pure and beautiful, but not terribly useful for complex applications (Racket is a expanded version that's better suited for that).",0.26865079365079364,Scheme
158iyza,jtarnpd,"Clojure is also strongly functional, but introduces other data types such as vectors, has interop with Java and includes constructs specially designed for concurrency.",0.1663690476190476,Clojure
158iyza,jtarnpd,"Clojure is also strongly functional, but introduces other data types such as vectors, has interop with Java and includes constructs specially designed for concurrency.",0.1663690476190476,Java
158iyza,jtc1o5a,"Programming in Lisp is like programming directly in an abstract syntax tree that can modify itself, with all the wonder and horror this entails.",0.1,Lisp
158iyza,jtav0ds,"From what I can gather, Lisp is truly magical:  * It can be both compiled and interpreted (or both at the same time) * It can be both statically and dynamically typed * It can be both imperative and functional * Code can be data, and data can be code * It can be implemented entirely in itself starting from a minimal version that can be described in one page, right up to Clisp that needs 1000 pages  It can do everything, and there is nothing it can't do.",0.11428571428571428,Lisp
158iyza,jtcqjd8,"advantages that are no longer unique to Lisp), and it also depends on your use case.",0.375,Lisp
158iyza,jtcqjd8,"Personally, I find statically typed functional languages (ML, Haskell, etc.)",0.0,Haskell
158iyza,jtcf3l7,"I've done a few hobby projects in Common Lisp, and to me, the magic of Lisp is not entirely the macros.",0.0,Lisp
158iyza,jtcf3l7,"Macros are a part of that, and a part of the reason it's easier to build those tools in Lisp than in other languages, but it's not the whole thing.",0.037500000000000006,Lisp
158iyza,jtcf3l7,"It's fairly trivial in Common Lisp to write games while they are running, deploy a stubbed out webserver and remotely live-code it into existence, debug and modify a Kafka processor while it is mid-stream and running in the test Kubernetes cluster, and so on.",0.09999999999999998,Lisp
158iyza,jtcf3l7,All with the safety harness of the condition-capturing REPL and pervasive data inspector in Common Lisp REPLs.,-0.3,Lisp
158iyza,jtcf3l7,"Macros help by reducing boilerplate and helping humans to reason about the program, but it's not entirely the reason people are devoted to Lisp.",-0.05,Lisp
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,COBOL
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,ALGOL
158iyza,jtrab9n,"Of those, the language with the greatest staying power has been COBOL, and by a country mile.",1.0,COBOL
158iyza,jtrab9n,COBOL systems have been running continuously under maintenance for approximately since computers had transistors.,-0.4,COBOL
158iyza,jtrab9n,Lisp absolutely has syntax.,0.2,Lisp
158iyza,jtrab9n,What makes Lisp interesting is the semantics.,0.5,Lisp
158iyza,jtrab9n,"For a long time PL researchers tried experimenting with extensible syntax as we know the term ""syntax"" from languages like BASIC and Perl.",-0.025,Perl
158iyza,jtrab9n,"Therefore, to your question about why macros are such a big deal, I think it is because the *elemental core* of LISP (eval/apply) has a paucity of semantics *and so did every other language* for the first 50 years of Lisp's existence.",0.03125,Lisp
158iyza,jtrab9n,That is why I think it's disingenuous to call Lisp a superpower.,0.0,Lisp
158iyza,jtbgz75,I like the Lisp family a lot.,0.0,Lisp
158iyza,jtbgz75,But the real answer imo is that it was 30 years ago when Lisp was super awesome compared to mainstream alternatives.,0.5111111111111111,Lisp
158iyza,jtbgz75,"(Yes, there were other forward-looking alternatives like SML and Prolog, and I liked them too.",0.2375,Prolog
158iyza,jtbgz75,But Lisp was more generally practical.),0.275,Lisp
158iyza,jtbugo6,"I suspect that Lisp would do well here in terms of text size, but not so much less in terms of constructs e.g.",-0.16666666666666666,Lisp
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Rust
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Haskell
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,C++
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Python
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Scala
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Rust
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Haskell
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,C++
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Python
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Scala
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Java
158iyza,jtbugo6,"(compared to Rust baseline somewhat more expressive with more syntactic sugar and no borrow-checker to make happy)  OCaml 1.15x -- LR parser generator and tree rewriting for parsing, as well as a regex->NFA->DFA conversions for lexing.",0.65,Rust
158iyza,jtbugo6,(Rust and OCaml seem similarly expressive except that OCaml needs interface files and Rust doesn’t.),0.8,Rust
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,TypeScript
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Rust
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Haskell
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Python
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,C
158iyza,jtcpyue,"Sure, if you have Haskell experience, these things do not seam like a big deal in comparison BUT, coming from an imperative world... the transition is quite different.",0.16666666666666666,Haskell
158iyza,jtcpyue,Lisp is an insanely small target.,-0.25,Lisp
158iyza,jtcuzrq,"The things i miss most from Clojure when working in other languages: 1. live REPL 2. data-orientation (flexible data structures with good equality semantics) 3. sane but flexible scoping rules (both lexical and dynamic binding)  But the primary problem with Clojure (and other Lisps) is its small, fragmented community and the lack of backing by a top company like MS/Meta/Google/etc.",0.19292929292929292,Clojure
158iyza,jtchfyt,Ruby is basically a modern lisp.,0.2,Ruby
158iyza,jtd9q02,"This semantic flexibility is doubly present in a lisp like Clojure, whose implementation is partially realized as a _host language library_ (which people don’t often realize).",-0.05,Clojure
158iyza,jtd9q02,"Thus you get to _apply_ the tool of homoiconic s-expressions to the JVM, Node/browser, Dart, native, etc.",0.0,Dart
158iyza,jtchxup,I  think Lisp should *always* blow your socks off.,0.0,Lisp
158iyza,jtchxup,"The [metacircular evaluator](https://www.youtube.com/watch?v=OyfBQmvr2Hc) in and of itself is mind blowing, then the next step is [Destroy some New Buildings](https://lobste.rs/s/yj31ty/collapsing_towers_interpreters)  Yet Rich Hickey is probably [late fifties, early 60s](https://www.reddit.com/r/Clojure/comments/833xur/just_curious_how_old_is_rich_hickey/)  and didn't start playing with Common Lisp until his mid 40s?",-0.023579545454545454,Lisp
158iyza,jtchxup,He then made Common Lisp 2.0 for the JVM creating Clojure.,-0.3,Lisp
158iyza,jtchxup,He then made Common Lisp 2.0 for the JVM creating Clojure.,-0.3,Clojure
158iyza,jtchxup,Lisp is fractally profound and can rediscovered at any age.,0.08333333333333333,Lisp
158iyza,jtb3xyp,> Continuations are typically available  Not outside Scheme.,0.2,Scheme
158iyza,jtauhf2,"Of course, this syntax itself must be documented (something many macro writers do a bad job of), and its meaning (i.e., semantics) must also be explained, but beyond that, its implementation should be as concerning as how a Fortran compiler might optimize away a sequence of additions and multiplications as SIMD instructions.",-0.09999999999999992,Fortran
158iyza,jten12s,"In case anyone else was wondering ... ""Chinual Lisp"" is not a typo, and apparently refers to Lisp Machine Lisp: [https://en.wikipedia.org/wiki/Lisp\_Machine\_Lisp](https://en.wikipedia.org/wiki/Lisp_Machine_Lisp)",-0.35,Lisp
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,Lisp
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,Forth
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,Prolog
158iyza,jtb4zls,"(The language is named Common Lisp or CL, I believe we've had this exact discussion before anyway.)",-0.024999999999999994,Lisp
158iyza,jtxbd9n,"The main drawback of Lisp is the repulsive syntax, which is only really good if people seriously want some kind of metaprogramming, reflection, logical artificial intelligence.",0.11190476190476191,Lisp
158iyza,jtxbd9n,"Maybe there was potential (eg Planner, 3-Lisp) but Lisp stopped developing in that direction very early on (even regressed a bit since McCarthy's days) and what it offers is not useful enough for most people to accept a syntax they don't like.",0.09666666666666668,Lisp
158iyza,jtckffl,"You can of course programmatically manipulate program structure of programs in non-homoiconic languages, like Python or Java or even C/C++ too.",0.0,Python
158iyza,jtckffl,"You can of course programmatically manipulate program structure of programs in non-homoiconic languages, like Python or Java or even C/C++ too.",0.0,Java
158iyza,jtckffl,But it is easier in a homoiconic language like Lisp since you can treat program tokens as first class citizens and don't need to manipulate them via string processing routines and regexes or some specialized API.,0.25,Lisp
158iyza,jtctcol,"SML, Haskell, OCaml, ...  Prolog would also be a popular choice for such tasks.",0.3,Haskell
158iyza,jtctcol,"SML, Haskell, OCaml, ...  Prolog would also be a popular choice for such tasks.",0.3,Prolog
158iyza,jtctcol,"Elixir is also a very capable language, so it should not be a surprise that it handles such a simple task very well.",0.115,Elixir
158iyza,jtctcol,Elixir has macros.,0.0,Elixir
158iyza,jtctcol,The difference to Lisp is that Lisp code is written in its data syntax and that macros in Lisp are relatively unrestricted.,0.0,Lisp
158iyza,jtctcol,"See https://elixir-lang.org/getting-started/meta/macros.html   In the Elixir example we have the macro named macro_unless in a module:       defmodule Unless do        defmacro macro_unless(clause, do: expression) do         quote do           if(!unquote(clause), do: unquote(expression))         end       end      end  In Lisp I would define it interactively in an editor+repl or the repl directly:      CL-USER 1 > (defmacro unless1 (clause &body body)                   `(if (not ,clause)                        (progn                          ,@body)))     UNLESS1       $ iex macros.exs      iex> require Unless     iex> Unless.macro_unless true, do: IO.puts ""this should never be printed""     nil   What does the Elixir macro transform the expression to?",0.22499999999999998,Elixir
158iyza,jtctcol,"See https://elixir-lang.org/getting-started/meta/macros.html   In the Elixir example we have the macro named macro_unless in a module:       defmodule Unless do        defmacro macro_unless(clause, do: expression) do         quote do           if(!unquote(clause), do: unquote(expression))         end       end      end  In Lisp I would define it interactively in an editor+repl or the repl directly:      CL-USER 1 > (defmacro unless1 (clause &body body)                   `(if (not ,clause)                        (progn                          ,@body)))     UNLESS1       $ iex macros.exs      iex> require Unless     iex> Unless.macro_unless true, do: IO.puts ""this should never be printed""     nil   What does the Elixir macro transform the expression to?",0.22499999999999998,Lisp
158iyza,jtctcol,"In Lisp we can macroexpand the expression, too:      CL-USER 2 > (macroexpand-1                  '(unless1 true                     (print ""this should never be printed"")))      (IF (NOT TRUE)         (PROGN (PRINT ""this should never be printed"")))  The result looks like normal Lisp source code and like Lisp data, at the same time.",0.08124999999999999,Lisp
158iyza,jtctcol,"CL-USER 3 > (eval *)     NIL  We could also create the source code with the usual Lisp operators for list manipulation:      CL-USER 8 > (defmacro unless1 (clause &body body)                   (list 'if (list 'not clause)                         (cons 'progn body)))     UNLESS1      CL-USER 9 > (macroexpand-1                  '(unless1 true                     (print ""this should never be printed"")))      (IF (NOT TRUE) (PROGN (PRINT ""this should never be printed"")))  There is a certain look and feel to this way of programming programs.",0.07785714285714285,Lisp
158iyza,jtctcol,"Treating code as data, without changing the representation, is a part of what makes Lisp special.",0.35714285714285715,Lisp
158iyza,jtctcol,"Lisp does not have the nice surface syntax of Elixir, but then it also does not have the complex code representation.",0.15,Lisp
158iyza,jtctcol,"Lisp does not have the nice surface syntax of Elixir, but then it also does not have the complex code representation.",0.15,Elixir
158iyza,jtctcol,"Depends, but it is something which makes Lisp different.",0.0,Lisp
158iyza,jtdc2uo,"Haskell was actually pretty easy to pick up, learn you a Haskell is super approachable.",0.33888888888888885,Haskell
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,Haskell
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,Clojure
158iyza,jv9rvlo,"In Python, the way modules work makes it impossible to reliably patch a module once it's been loaded.",-0.6666666666666666,Python
158iyza,jv9rvlo,"In JavaScript, modules are hermetically sealed, so you have zero visibility into them from the REPL, so you can't change them.",0.0,JavaScript
158iyza,jv9rvlo,"And all of these languages have stack-unwinding exceptions, meaning that even if you can patch definitions at runtime (like you can in Ruby), you can't do Lisp-style interactive programming because the debugger can't be launched until after the stack unwinds.",0.0,Ruby
158iyza,jv9rvlo,"Decades have passed in which all new programming languages just copy C++'s exception mechanism, or reject it and implement C-style error handling instead.",0.13636363636363635,C++
158iyza,jtcuj21,"Document processing software, big data analytics, urban transportation planning systems, cloud backup service providers, AI, Google…  (cool read, 2014: pgloader switching from Python to CL https://tapoueh.org/blog/2014/05/why-is-pgloader-so-much-faster/)  ping /u/smthamazing for the ""mostly historical?""",0.0875,Python
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,Lisp
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,Rust
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,Java
158iyza,jtcscy1,"So, the CL version was beating (in speed) the Rust version.",0.0,Rust
158iyza,jtcscy1,"Of course, he wasn't writing the most efficient Rust code.",0.5,Rust
158iyza,jtcscy1,"The Rust community came to give a hand, sent PRs on his repository, they had lengthy discussions, they tried different approaches, and ultimately they got a very fast Rust program (that's in the follow-up article).",0.08666666666666667,Rust
158iyza,jtcscy1,"So even if the final Rust version beats it, 1) they run in the same ballpark (SBCL produces very fast code and is often at the top of the benchmarks, a little slower than C or sometimes beating it), 2) this says a lot about a developer's efficiency IMO (and we didn't even talk about workflows and the CL productivity: very short write-compile-test cycles, interactive debugging etc).",0.09541666666666666,Rust
158iyza,jtcscy1,"So even if the final Rust version beats it, 1) they run in the same ballpark (SBCL produces very fast code and is often at the top of the benchmarks, a little slower than C or sometimes beating it), 2) this says a lot about a developer's efficiency IMO (and we didn't even talk about workflows and the CL productivity: very short write-compile-test cycles, interactive debugging etc).",0.09541666666666666,C
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,Lisp
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,C
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,Perl
158iyza,jv9xtgd,"The best way to explain the power of macros is by comparing them with React, which, due to JavaScript's lack of macros, requires its own compiler.",0.4916666666666667,JavaScript
158iyza,jv9xtgd,"If browsers ran Common Lisp instead of JavaScript, React would've used read macros instead of needing a separate compiler.",-0.3,Lisp
158iyza,jv9xtgd,"If browsers ran Common Lisp instead of JavaScript, React would've used read macros instead of needing a separate compiler.",-0.3,JavaScript
158iyza,jte091q,"Lisp also pioneered OO, including Flavors (which originated ""mixins"") and CLOS.",0.0,Lisp
158iyza,jtcx993,In Lisp it is relatively simple to extend the language incrementally.,0.0,Lisp
158iyza,jtcx993,In this case this is Lisp with added macros and the target language is also Lisp.,0.0,Lisp
158iyza,jtcx993,"See for example the SBCL (an implementation of Common Lisp, mostly in Common Lisp) compiler itself.",-0.3,Lisp
158iyza,jtcx4lo,Many of the stated advantages of Lisp have nothing to do with macros.,0.5,Lisp
158iyza,ju8i0wq,"I don't know if you can be effective with Lisp without using macros, but in other languages the meta programming stuff like reflection and eval can often be avoided or relegated to libraries that do stuff like (de)serialization for you  Also lol I totally get that.",0.31875,Lisp
158iyza,ju8i0wq,"I can stand it for like maybe a month or two and then I've gotta take a break for my own well-being, otherwise I get grouchy  (Edit: also yes, Forth is different)",0.3,Forth
158iyza,jtdctf5,"Common Lisp supports and extensively uses dynamic scoping, it just has to be explicitly requested for a given variable.",-0.09999999999999999,Lisp
158iyza,juhiupj,"so  ""chinual lisp"" stands for ""Lisp machine manual lisp"".",0.0,Lisp
158iyza,juhiupj,"I never heard such abbreviation for ""Lisp machine lisp"".",0.0,Lisp
158iyza,jtxsdjb,"I remember using a thin syntax wrapper around C, for the first substantial program I wrote in it, to take care of some of the rough edges.",-0.08333333333333333,C
158iyza,jtxsdjb,"For Lisp, a project I played with once let me write code in a universal syntax of my choice, which was then translated to a range of languages.",0.0,Lisp
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,Python
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,Lua
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,C
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,Lisp
158iyza,jtxsdjb,"So for a `Fibonacci` benchmark in that syntax, it produced this Lisp source which runs under CLisp:      ; Lisp source output          (defun start ()       (format t ""~a"" (fib 36))       (format t ""~%"")     )          (defun fib (n)       (if (< n 2)           (return-from fib n)           (return-from fib (+ (fib (- n 1)) (fib (- n 2))))       )     )          (start)  But there was a problem: my universal syntax didn't have its own semantics and capabilities, those still belonged to the target language.",0.3,Lisp
158iyza,jtxsdjb,"Most languages, their syntax is also their identity: you can tell if you're coding in Python or in Lisp.",0.5,Python
158iyza,jtxsdjb,"Most languages, their syntax is also their identity: you can tell if you're coding in Python or in Lisp.",0.5,Lisp
158iyza,jtxsdjb,"Still, if I'd somehow got a job where I had to produce Lisp code, I would probably use such a conversion tool.",0.0,Lisp
158iyza,jtdb0dg,"I get that some stuff demands quite a lot (like Haskell, which is brilliant but also, y'know, Haskell) but some of them are pretty easy to pick up.",0.5277777777777778,Haskell
158iyza,jtciqbr,Like Sun pouring $500m into PR and marketing for Java.,0.0,Java
158iyza,jup79g5,Forth is like HaikuOS.,0.0,Forth
158iyza,jtk9oq4,"If you quote it, it is just code (data):      '(defun yey ()        (if (< 2 3) (message ""yey"")))  For example you can ask for the first element of the list:      (first '(defun yey ()               (if (< 2 3) (message ""yey""))))  => defun  Of you can ask for nth element of the list:       (nth 3 '(defun yey ()               (if (< 2 3) (message ""yey""))))  => (if (< 2 3) (message ""yey""))  You can also eval that 3 element as any code:      (eval (nth 3 '(defun yey ()                (if (< 2 3) (message ""yey"")))))  => ""yey""  Now imagine setting up a code and evaluating it in some other language like C++ or Python.",-0.4107142857142857,C++
158iyza,jtk9oq4,"If you quote it, it is just code (data):      '(defun yey ()        (if (< 2 3) (message ""yey"")))  For example you can ask for the first element of the list:      (first '(defun yey ()               (if (< 2 3) (message ""yey""))))  => defun  Of you can ask for nth element of the list:       (nth 3 '(defun yey ()               (if (< 2 3) (message ""yey""))))  => (if (< 2 3) (message ""yey""))  You can also eval that 3 element as any code:      (eval (nth 3 '(defun yey ()                (if (< 2 3) (message ""yey"")))))  => ""yey""  Now imagine setting up a code and evaluating it in some other language like C++ or Python.",-0.4107142857142857,Python
158iyza,jtk9oq4,"Indexing in Emacs Lisp is as in C, from 0, 1, ... N-length, and (cadr list) is same as (nth 1 list), I have jused that one just because it would look more ugly with (nth 1 (nth 2 ...)).",-0.06666666666666665,Lisp
158iyza,jtk9oq4,"Indexing in Emacs Lisp is as in C, from 0, 1, ... N-length, and (cadr list) is same as (nth 1 list), I have jused that one just because it would look more ugly with (nth 1 (nth 2 ...)).",-0.06666666666666665,C
158iyza,jtk9oq4,"Anyway, it is a very contrived and toy example, but try to rewrite it in Python or C++, and you will see a difference in code you use for the manipulation (program you write) and code you manipulate since there will be lots of string manipulations.",-0.65,Python
158iyza,jtk9oq4,"Anyway, it is a very contrived and toy example, but try to rewrite it in Python or C++, and you will see a difference in code you use for the manipulation (program you write) and code you manipulate since there will be lots of string manipulations.",-0.65,C++
158iyza,jtk9oq4,In Lisp the system does it for you (more or less) so you can write your programs as the code you manipulate is actually live program code.,0.15656565656565657,Lisp
158iyza,jtk9oq4,But look at JS or Python and how they write code they send back into the interpreter.,0.0,Python
158iyza,jtk9oq4,Compare to Lisp and property lists.,0.0,Lisp
158iyza,jtk9oq4,"Due to implementation of JS they of course can't do that, but if JS was a Lisp ...  > Any reasonable language infrastructure would manipulate program representations through ASTs  Would it?",0.037500000000000006,Lisp
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,Python
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,C
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,C++
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,Java
158iyza,jtk9oq4,Do you have access to the AST of your program when you type your programs in C++ or Java normally?,0.15,C++
158iyza,jtk9oq4,Do you have access to the AST of your program when you type your programs in C++ or Java normally?,0.15,Java
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,Java
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,Lisp
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,C
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,C++
158iyza,jtmkm1x,"In my view, Lisp only slightly increases the effective range of action from non-Lisp languages, but those differences put together bring you from something like 90% coverage on the best non-Lisp languages (e.g.",0.30666666666666664,Lisp
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,Haskell
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,Ruby
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,Elixir
158iyza,jtmkm1x,"Lisp languages may be less popular due to the initial work to familiarize yourself with the syntax (and many historical factors as well), but they have technical advantages that to my knowledge have only been matched by languages others consider to be Lisps or Lisp-equivalents (including the same gripes about too little syntax and universal open/close markers (usually parentheses))  &#x200B;  *The original draft of this post was a bit of a ramble elaborating on the above, kept here because I don't want to waste all that writing:*  &#x200B;  Most languages (and in truth most computing frameworks, period) try to make the \[default\] user interface (or developer interface, if you prefer; developers are the users of languages, after all!)",0.0982843137254902,Lisp
158iyza,jtmkm1x,"I'm unfamiliar with Elixir, but from your and lispm's examples here it seems to fit the same mold.",0.2,Elixir
158iyza,jtmkm1x,"Facilities like C's macro system (horrible though it is), or Elixir's apparently-better macro system extend this space to contain all possible language features; but the areas that aren't covered by the core language tend to have different usability characteristics, making them much slower to develop.",-0.2,C
158iyza,jtmkm1x,"Facilities like C's macro system (horrible though it is), or Elixir's apparently-better macro system extend this space to contain all possible language features; but the areas that aren't covered by the core language tend to have different usability characteristics, making them much slower to develop.",-0.2,Elixir
158iyza,jtmkm1x,"&#x200B;  Lisp languages don't exactly fit the above pattern, because their first priority is to make the conceptual core of the language as simple as possible.",0.13,Lisp
158iyza,jtmkm1x,Common Lisp also adds *some* focus on the user (i.e.,-0.3,Lisp
158iyza,jtmkm1x,"developer) interface, Scheme barely focused on anything but simplicity in its formative years and is now trying to make up for that mistake, and Racket is bound by some limits of Scheme but is otherwise excellent.",0.525,Scheme
158iyza,jtmkm1x,"But one important implication of Lisp's generality is the language-oriented programming paradigm, the ability to design toolkits that make arbitrary areas of possibility-space easier to navigate.",0.15000000000000002,Lisp
158iyza,jtmkm1x,*And* you still maintain the significant difficulty-reduction Lisp provides for tasks which *nobody* has written a framework for.,0.375,Lisp
158iyza,jtmkm1x,"(Note: In practice, only toy libraries like with-c-syntax bother to paper over S-expressions, since making use of Lisp's unique benefits requires the relationship between homoiconicity and macros, a relationship which would be covered up by complex syntax.",0.025000000000000005,Lisp
158iyza,jtmkm1x,"It's reasonably easy to do (especially compared to most other languages), and has to some extent already been done, but if you're familiar with Lisp you likely won't want to do it)  There's also no artificial, language-induced constraints on where your packages can be used.",0.2119047619047619,Lisp
158iyza,jtmkm1x,"You don't have to arbitrarily divide your users into ""Users"" and ""Developers""; any development work you do advances the entire system of ""people using Lisp software"".",-0.05,Lisp
158iyza,jtmkm1x,"&#x200B;  All the above points are, as far as I know, unique to Lisp languages.",0.15833333333333333,Lisp
158iyza,jtmkm1x,"Even lispm's Elixir example, though far more attractive than the other mainstream languages I've had the misfortune to become skilled at, sets a distinct format which macros have to follow, and which seems both less readable and more inconvenient to write than your example of ordinary Elixir code.",0.15583333333333332,Elixir
158iyza,jtmkm1x,I agree that it takes some time to familiarize yourself with Lisp syntax.,0.0,Lisp
158iyza,jtmkm1x,"And I can appreciate the benefits of creating libraries that make writing *most* code easier, rather than *all* code (I've actually been designing such an abstraction layer for Common Lisp, though work is too busy to have gotten it to the implementation stage yet).",0.06000000000000001,Lisp
158iyza,jtmkm1x,"To me, that's far more unpalatable than any of Lisp's weaknesses.",0.3,Lisp
158iyza,jthujoj,">I love parentheses (but highly prefer Scheme and Racket over Common Lisp), but the ""power"" of Common Lisp is overstated.",0.015000000000000013,Scheme
158iyza,jthujoj,">I love parentheses (but highly prefer Scheme and Racket over Common Lisp), but the ""power"" of Common Lisp is overstated.",0.015000000000000013,Lisp
158iyza,jthujoj,I vastly prefer Common Lisp over Scheme&Racket.,-0.15,Lisp
158iyza,jthujoj,I vastly prefer Common Lisp over Scheme&Racket.,-0.15,Scheme
158iyza,jthujoj,Not really in Lisp.,-0.1,Lisp
158iyza,jthujoj,"In Lisp the rules are more like: if one needs a linguistic abstraction, write a macro.",0.3,Lisp
158iyza,jthujoj,"Btw., the numbers of top-level macros in my Lisp Machine (an emulator running on my MacBook Pro)  world (the running Lisp image, which is an operating system) is 6955.",0.0,Lisp
158iyza,jtdk0bh,">I get that some stuff demands quite a lot (like Haskell, which is brilliant but also, y'know, Haskell)  I don't think that they demand a lot (at least not to be productive), but they usually *do* demand that you learn *some* new way of thinking about things.",0.12159090909090911,Haskell
158iyza,jtdk0bh,"That's why Haskell seems so alien to people - ""How am I supposed to do anything if I can't mutate a variable?"".",-0.25,Haskell
158iyza,jv9xg7p,"Copy the executable to another machine that doesn't have Artichoke, Rust, or anything else installed.",0.0,Rust
158iyza,jv9xg7p,"Run the executable file and get into a new REPL (when you save a Lisp image, it comes with the REPL and the compiler).",0.13636363636363635,Lisp
158iyza,jv9xg7p,"Since this is Ruby we're talking about, this was probably a Web server, so you have to re-run the HTTP request that originally caused the error, probably twice (once to reproduce the error and get into the debugger, and again once you've reloaded the corrected server).",0.375,Ruby
158iyza,jv9xg7p,"If the server was written in Lisp, the debugger would come up automatically when the error is signalled.",0.0,Lisp
158iyza,jv9xg7p,"The program stops on the expression that is equivalent to Ruby's `raise` statement, before the error is actually thrown.",0.0,Ruby
158iyza,jv9xg7p,Can Ruby do *that?,0.0,Ruby
158iyza,jv9xg7p,"While it has *some* of the required functionality (unlike Python, it *can* patch definitions in memory), it's missing the ability to handle exceptions *before* unwinding the stack (the Lisp debugger is just an exception handler), and its debugger lacks the ability to re-run stack frames, so it does you no good to be able to dynamically patch a definition.",-0.01666666666666668,Python
158iyza,jv9xg7p,"While it has *some* of the required functionality (unlike Python, it *can* patch definitions in memory), it's missing the ability to handle exceptions *before* unwinding the stack (the Lisp debugger is just an exception handler), and its debugger lacks the ability to re-run stack frames, so it does you no good to be able to dynamically patch a definition.",-0.01666666666666668,Lisp
158iyza,jv1fe8e,But you can also load Forth as an OS and bypass all ideas of kernels and syscalls and file systems and desktop environments and everything,0.0,Forth
158iyza,jtdxq8p,"Well, that and the fact that 40% or tutorials start with category theory, 30% say ""you don't need maths for Haskell!""",0.0,Haskell
158iyza,jtdxq8p,"I agree that the actual concepts behind programming in Haskell are not just easy to understand, but they're also much more simple than the alternatives.",0.10666666666666666,Haskell
158iyza,jtdxq8p,"I like Haskell and the ideas which created it, but the documentation is often super confusing and relies heavily on the consumer of the API knowing all the buzzwords (Monad, monad transformer, monoid, etc.).",-0.05555555555555556,Haskell
158iyza,jte27gz,">I like Haskell and the ideas which created it, but the documentation is often super confusing and relies heavily on the consumer of the API knowing all the buzzwords (Monad, monad transformer, monoid, etc.).",-0.05555555555555556,Haskell
158iyza,jte27gz,"It's not much harder to understand what a monoid is than to understand inheritance for example, and I was taught that in my second-ever lecture on C++.",0.05,C++
158iyza,jte27gz,"And I'm fully supportive of that reluctance when all you care about is to write a couple Python scripts to scrape a website or whatever, but when this is your profession and you care about writing good quality software then that's a very different story and it practically becomes your duty to spend some time working these concepts.",0.39999999999999997,Python
158iyza,jte3oah,"We're fully on the same page, but people aren't starting on Haskell, and even if they were it's still not very accessible compared to say, Elm.",-0.04807692307692307,Haskell
158iyza,jte3oah,"We're fully on the same page, but people aren't starting on Haskell, and even if they were it's still not very accessible compared to say, Elm.",-0.04807692307692307,Elm
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,Haskell
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,Lisp
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,Java
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,JavaScript
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,C++
158iyza,jteca32,"Then, in C++, you have the infamous:      #include <iostream>     int main() {        std::cout << ""Hello world!\n"";       return 0;     }  If you've never seen code in this format before, you have to mentally parse the following syntax/semantic objects (accompanied with their fancy terminologi):  1. the `#include` (compiler directives) 2. the `<iostream>` (header files) 3. the `int main()` (type declaration, function arguments) 4. the `{...}` (scope) 5. the `std::cout` (namespaced qualifiers) 6. the `<<` (stream operator) 7. the `\n` (line break character sequence) 8. the `;` (expression terminator) 9. the `return 0` (return statement, which at first made me think ""what does it mean to return in my code, why am I returning a seemingly random number, and to whom?"")",-0.10364583333333334,C++
158iyza,jteca32,"I won't even bother breaking down Java's:      public class HelloWorld     {       public static void main(String[] args)         {           System.out.println(""Hello world!",0.11736111111111111,Java
158iyza,jteca32,""");         }     }  Here's hello world in Haskell and Lisp, for comparison:      // Haskell     main = putStrLn ""Hello world!""",0.20833333333333331,Haskell
158iyza,jteca32,""");         }     }  Here's hello world in Haskell and Lisp, for comparison:      // Haskell     main = putStrLn ""Hello world!""",0.20833333333333331,Lisp
158iyza,jteca32,"// Lisp     (print ""Hello world!"")",0.0,Lisp
158iyza,jteca32,And yet these languages build up on theory that's widely considered much more esoteric than that of C++ or Java.,0.2,C++
158iyza,jteca32,And yet these languages build up on theory that's widely considered much more esoteric than that of C++ or Java.,0.2,Java
158iyza,jteca32,"I'm not saying that this makes them beginner-friendly languages (your first \~100 Haskell compiler errors can be cryptic gibberish, and Lisp's `car` and `cdr` historic baggage is confusing and unattractive, to put it mildly), but out of the three I think it's clear which one makes it easier to get your feet wet as a complete beginner.",0.054761904761904755,Haskell
158iyza,jteca32,"I'm not saying that this makes them beginner-friendly languages (your first \~100 Haskell compiler errors can be cryptic gibberish, and Lisp's `car` and `cdr` historic baggage is confusing and unattractive, to put it mildly), but out of the three I think it's clear which one makes it easier to get your feet wet as a complete beginner.",0.054761904761904755,Lisp
158iyza,jteemhx,But a course that's brain dead enough to get you started with programming on C++ or Java isn't going to be better at teaching you any amount of input beyond hello world.,0.09999999999999999,C++
158iyza,jteemhx,But a course that's brain dead enough to get you started with programming on C++ or Java isn't going to be better at teaching you any amount of input beyond hello world.,0.09999999999999999,Java
158iyza,jteemhx,"``` print(""Hello World"") ``` Seems more straight forward than Haskell to me.",0.35,Haskell
158iyza,jteemhx,"Mainly though, I agree with you- what I was trying to say is that Haskell is easy and much simpler (well, GHC is a massive complex project with language extensions yadda yadda but you get my point) but very *very* few people are learning Haskell as their first language.",0.06999999999999999,Haskell
158exhb,,"Alas, Vale's compiler is still written in Scala which doesn't have linear types, so I had a bug.",-0.4,Scala
158exhb,jt9yg02,"""I did X but forgot to do Y"" - I'm also getting warned by this by elm-review - a linter for the Elm language - and specifically its set of NoUnused rules.",0.0,Elm
158exhb,jtlkp67,For example in C++ the compiler guarantees your destructors get called and therein you release everything you acquired.,0.0,C++
158exhb,jtbrw4p,"There's a talk on it that compares Idris and Scala: https://www.youtube.com/watch?v=fV2no1Rkzdw  I take example from them to here:  ``` testFile : FileIO () testFile = catch (   do open ""testFile"" Read     str <- readFile    putStrLn (show str)    ls <- Count :- get    close    putStrLn (show ls))  (\err => putStrLn (""Handled: "" ++ show err)) ```  In this example, if you remove the ""close"" line, the program simplely won't compile.",0.0,Scala
158exhb,jtesizv,"There are implementation of session types in Rust, which only has support for affine types (not fully linear).",0.0,Rust
158exhb,jtakh26,It's Haskell :)  Isn't your example about forgetting to do Y?,0.5,Haskell
158exhb,jtaq6ii,"That explains it, I never learned Haskell ;) Definitely my achilles heel.",0.125,Haskell
158exhb,jtaq6ii,"If the user only exposes one way to consume X's result (specifically, the operation Y) then the compiler makes sure we can never forget to do Y.  I heard that LiquidHaskell has linear types, so the difference between Haskell and LiquidHaskell might have a better answer for you than I can give.",0.3333333333333333,Haskell
157dlmc,,"I don't see this to be a thing in major languages, but in my language, this is possible: (note that `=` is pattern matching, will succeed only if LHS = RHS) ``` a = [5, 6] [1, 2, 3, 4, 5, 6, 7, 8] = [1, 2 .. [3, 4] .. a, 7, 8] [1, 2, 3, 4, 5, 6, 7, 8] = [.. [1, 2, 3, 4], 5, 6, 7, 8] ``` The idea behind this is just Lisp's `splice-unquote`.",-0.21749999999999997,Lisp
157dlmc,jt58f8n,"Or you could copy Python's prefix-star and get `[1,2,3,4,*a,7,8]` which I think Guido got right.",0.2857142857142857,Python
157dlmc,jt458vw,"Answer on my own:  Elixir's `|` seems fine, I expect binary operation to be rarely used in my language to might as well use `bor` or something else.",0.4388888888888889,Elixir
157dlmc,jt8viqx,"For this I'd use a flatten function, like in good ol' PHP.",0.7,PHP
157dlmc,jt835jd,"I use `...` for varargs in my language just as in Lua, so I can't do it.",0.0,Lua
157dlmc,jtofuci,Weird Haskell.,-0.5,Haskell
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,Perl
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,Ruby
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,Crystal
157dlmc,jtfjebf,Rust serves as a good reminder of that failure.,0.19166666666666662,Rust
157dlmc,jtpbg3p,"And you use the same union type syntax as languages like TypeScript and Scala 3, where it is _not_ discriminated.",0.0,TypeScript
157dlmc,jtpbg3p,"And you use the same union type syntax as languages like TypeScript and Scala 3, where it is _not_ discriminated.",0.0,Scala
157dlmc,jtpfzgy,TypeScript's unions are not tagged.,0.0,TypeScript
157dlmc,jtpfzgy,"> TypeScript and Scala 3, where it is not discriminated.",0.0,TypeScript
157dlmc,jtpfzgy,"> TypeScript and Scala 3, where it is not discriminated.",0.0,Scala
157dlmc,jtpfzgy,"It means if `a | b` is not a tagged union, then you must discriminate yourself either by using intersected properties of the subtypes, as in TypeScript, or a by making it a dependent type on some external state, as do C-style anonymous unions.",0.0,TypeScript
157dlmc,jtpfzgy,The type variables being scoped address this issue by not requiring type specialisation rules as are present in C++ templates.,0.0,C++
157dlmc,jtpfzgy,"That said, this is a purely syntactic issue, which C++ solves exactly in the same way the code I posted does.",0.15476190476190477,C++
157dlmc,jtpfzgy,"I have a compiler that translates this code      f: (Int | String) -> Int     f (x: Int) = x     f (s: String) = s.length  into Assembly code roughly equivalent to this:      Int f₀(Int x) { return x; }     Int f₁(String s) { return length(s); }     Int f(Union<Int, String> x)     {         if(x.is<Int>()) {             return f₀(x.as<Int>());         }         else {             return f₁(x.as<String>());         }     }  This follows the System V ABI for AMD64, and all three routines are callable from C/C++ compilers adhering to it.",-0.425,Assembly
157dlmc,jtpfzgy,GCC outputs the same code when I write the code in C++.,0.0,C++
157dlmc,jtprgj3,"But then you're not really designing a ""weird Haskell"" as you stated above, since many important Haskell things will no longer be possible, such as polymorphic recursion (used to traverse nested data types) and GADTs, to name just a couple.",0.042857142857142864,Haskell
157dlmc,jtprgj3,"(I would assume so, since you keep referring to Java and C++ overloading, which both include subtyping-based overloading.)",0.0,Java
157dlmc,jtprgj3,"(I would assume so, since you keep referring to Java and C++ overloading, which both include subtyping-based overloading.)",0.0,C++
157dlmc,jtqzw76,"> you're not really designing a ""weird Haskell""     Oh I was describing the syntax/pseudocode I use, rather than what I'm actually doing in my free time.",-0.04999999999999999,Haskell
1576cdw,jt3v8aj,"This is the Mutability XOR Aliasing issue raised by Rust, which it addresses via its Borrowing restrictions (preventing mutation), and that Val addresses via its ""subscripts"" (preventing aliasing).",0.0,Rust
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,Haskell
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,Python
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,JavaScript
1576cdw,jt4w3oe,"I think it would probably be possible to combine something like Rust's alias analysis for mutable pointers with `fip` functions, so you'd have an opt-in borrow checker that you need to enable whenever you wanted mutable pointers into your data structures (where you'd initially need to acquire a uniqueness guarantee, probably by inspecting the reference counts).",0.0,Rust
1576cdw,jt4a20l,Because looking it up it seems that union field access in Rust is indeed unsafe.,0.0,Rust
1576cdw,jt4ssug,"""Unions or equivalent"" includes tagged unions (like Rust's enums).",0.0,Rust
1576cdw,jt4ssug,"Rust stops us from doing this because of ""aliasable XOR mutable"":      error[E0506]: cannot assign to `changeable` because it is borrowed       --> src/lib.rs:17:5        |     9  |     let ptr: &&str = match &changeable {        |                            ----------- `changeable` is borrowed here     ...     17 |     changeable = PointerOrInt::SomeInt(12345);        |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `changeable` is assigned to here but it was already borrowed     18 |          19 |     println!",0.0,Rust
1576cdw,jt9rjij,"That is, not just a machine type^1 , but a more complex contraption with object header, etc...  ^1 _Not a Lisp machine type, an x86 or ARM machine type._",0.1,Lisp
1576cdw,jt59cso,"FWIW Rust absolutely does have untagged unions, for C interoperability.",0.2,Rust
1576cdw,jt59cso,"FWIW Rust absolutely does have untagged unions, for C interoperability.",0.2,C
1576cdw,jtefdau,"This is what borrow-checking (Rust) or subscripts (Val) ""solve"", and I don't see how partial read barriers can solve that.",-0.1,Rust
1576cdw,jtjhvio,"- Or the escape of the interior pointer, which is what Rust's borrow checking does.",0.0,Rust
156wrxx,,"E.g., languages like Swift, Haskell, Agda, etc.",0.0,Swift
156wrxx,,"E.g., languages like Swift, Haskell, Agda, etc.",0.0,Haskell
156wrxx,jt1z53v,At least in Haskell you don't define an operator compared to another one.,-0.3,Haskell
156wrxx,jt1z53v,"In something like C# and C++ you can only override existing operators, so that follows their existing precedences.",0.0,C
156wrxx,jt1z53v,"In something like C# and C++ you can only override existing operators, so that follows their existing precedences.",0.0,C++
156wrxx,jt34k06,"Haskell will require that you disambiguate the operator by giving its fully qualified name - for example, `A.??`.",0.0,Haskell
156wrxx,jt259zp,As compared to languages like Python or Scala where operators are methods (magic or otherwise) that get called on their left-hand side.,0.5,Python
156wrxx,jt259zp,As compared to languages like Python or Scala where operators are methods (magic or otherwise) that get called on their left-hand side.,0.5,Scala
156wrxx,jt2gtdj,"Scala actually does have varying precedence for custom operators, but that precedence is determined by the first character of the operator.",0.125,Scala
156wrxx,jt95o3k,"Java pretty much killed it off, and quickly too.",0.12777777777777777,Java
156v4mf,,"Consider variable declaration in C vs Python:  C: int age = 21;  Python: age = 21  I don't understand why static types can't be an option for otherwise dynamically typed languages, especially given the capability of type inference, it seems like a small difficulty to allow the programmer to specify a type for their variables in a language that uses dynamic typing.",0.0625,C
156v4mf,,"Consider variable declaration in C vs Python:  C: int age = 21;  Python: age = 21  I don't understand why static types can't be an option for otherwise dynamically typed languages, especially given the capability of type inference, it seems like a small difficulty to allow the programmer to specify a type for their variables in a language that uses dynamic typing.",0.0625,Python
156v4mf,jt1ltke,"I’ll let others address the nuances around static/dynamic typing as a philosophy and simply point out that Common Lisp supports type specifications, but doesn’t require them.",-0.15,Lisp
156v4mf,jt1oq23,"The part about static vs dynamic typing has already been addressed, but I'll point out that in terms of providing or omitting the type, Python has optional type annotations (`a: int = 2`), while C++ allows types to be inferred (`auto a = 2`), and so is the case for most other languages I know",0.21875,Python
156v4mf,jt1oq23,"The part about static vs dynamic typing has already been addressed, but I'll point out that in terms of providing or omitting the type, Python has optional type annotations (`a: int = 2`), while C++ allows types to be inferred (`auto a = 2`), and so is the case for most other languages I know",0.21875,C++
156v4mf,jt6h98l,"Just a bit of reference, dlang, also known as D, allows you to not worry types by having an auto keyword.",0.0,D
156v4mf,jt1og7k,"See Hindley/Milner for the most common base  Hybrid strategies exist, like in JVM bytecode all ""objects"" are dynamic at runtime, but the Java compiler enforces type safety at compile time.",-0.15000000000000002,Java
156v4mf,jt1og7k,"JRuby)  (Edit: for the purposes of the OP, which I think is more about type _inference_ than static/dynamic typing, and to not put Java into the very-verbose bucket it was born in... Java also keeps getting more and more inference powers.",0.5,Java
156v4mf,jt1og7k,"Who knows how far they'll go, but Java's proven strategy is to leverage the ""last mover"" advantage and make decisions with a lot of experts and prior existing work)",0.03333333333333333,Java
156v4mf,jt1povu,"Python type hints look weird to me, compared to C/C++, and typescript is fully statically typed, so the type can't be omitted, correct?",-0.5,Python
156v4mf,jt1q52y,">Common Lisp supports type specifications, but doesn’t require them.",0.0,Lisp
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,Python
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,C
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,C++
156v4mf,jt1uktq,"This is because Python is dynamically typed by default, and type hinting is a feature that was introduced to help make Python code more understandable and easier to debug.",0.5,Python
156v4mf,jt1uktq,"In Python, type hints are optional, which means they don't change how the code runs, but they do provide a way for tools and IDEs to give better support for Python development.",0.5,Python
156v4mf,jt1uktq,"As for TypeScript, it is indeed a statically typed superset of JavaScript.",0.0,TypeScript
156v4mf,jt1uktq,"As for TypeScript, it is indeed a statically typed superset of JavaScript.",0.0,JavaScript
156v4mf,jt1uktq,"So in TypeScript, types can't be omitted in the sense that any variable or function you declare will have a type, whether explicitly declared by you or inferred by TypeScript.",0.0,TypeScript
156v4mf,jt1uktq,"However, TypeScript does allow a degree of flexibility with types using the ""any"" type when you need it.",0.0,TypeScript
156v4mf,jt1uktq,"Although it's generally recommended to avoid using ""any"" as much as possible to benefit from TypeScript's type checking features.",0.02500000000000001,TypeScript
156v4mf,jt2174l,"For Python, Mypy, PyRight, PyType, and Pyre all do this exact thing",0.25,Python
156v4mf,jt36eae,"There are other fun ones out there too -- I think Groovy counts, but Clojure does not.",0.0875,Groovy
156v4mf,jt36eae,"There are other fun ones out there too -- I think Groovy counts, but Clojure does not.",0.0875,Clojure
156v4mf,jt36eae,"I'll assert that getting a `ClassCastException` _at runtime_ is just as dynamic as getting a fatal `TypeError` _at runtime_ in Python or Ruby for `1 + ""hello""`.",0.0,Python
156v4mf,jt36eae,"I'll assert that getting a `ClassCastException` _at runtime_ is just as dynamic as getting a fatal `TypeError` _at runtime_ in Python or Ruby for `1 + ""hello""`.",0.0,Ruby
156v4mf,jt36eae,"Beyond that, I don't know how you'd get _more_ dynamic than `invokedynamic` without just being as untyped as Forth.",0.25,Forth
156v4mf,jt3ie8f,"It sounds like saying C is as dynamic as python because CPython is written in C.  I mean you can make it as ""dynamic"" as those languages but pay the price of complexity.",-0.10416666666666667,C
156szm0,,I've been looking at different langs such as C that use variadic arguments but I find it extremely unsafe and not really that practical.,-0.05625,C
156szm0,jt1fzf5,"Java, Golang, and Python all treat varargs as syntatic sugar for an array/slice/tuple.",0.0,Java
156szm0,jt1fzf5,"Java, Golang, and Python all treat varargs as syntatic sugar for an array/slice/tuple.",0.0,Python
156szm0,jt1csaa,Languages like C# and JS just turn the variadic part into an array.,0.0,C
156szm0,jt1csaa,"In case of C# that happens at compile time, decompiled code will show the construction of an array.",0.0,C
156szm0,jt19jhm,"Object Pascal / Delphi sort of handles this, similar to a list of single dimension array, where you can get the type or number of items.",-0.03571428571428571,Pascal
156szm0,jt19jhm,"Object Pascal / Delphi sort of handles this, similar to a list of single dimension array, where you can get the type or number of items.",-0.03571428571428571,Delphi
156szm0,jt19jhm,"In a C alike syntax it would be:       void printf        ( items[ ] )      {        int Count = count(items);        typeinfo T = typeof(items[0]);        if ( T = string )           ...;      }      ...     printf(""Hello World"", 5, FALSE, NULL );  This approach may require some Run Time Type Information...",-0.4000000000000001,C
156szm0,jt4a4gl,"In C, because the language is severely feature-poor, we have printf (and not a lot else) that uses it for convenient string formatting (and is full of security holes to boot!)",0.4375,C
156szm0,jt4a4gl,"Here's a list of things that people use variadics for:  - Nicer syntax for passing a list as an argument - Implicit builder patterns - Compensating for the lack of first-class tuple types - Compensating for the lack of generics over function types  Rust has something that strongly resembles printf, but in fact it is a macro that abstracts a builder pattern.",0.4333333333333333,Rust
156szm0,jt4a4gl,"I code a lot of Rust, and I have never missed not having variadic functions.",0.0,Rust
156szm0,jt2566x,"The version is C can have arguments of any mixed types, but the types are not specified and the compiler cannot check them when calling such functions.",0.0,C
156szm0,jt2566x,"I've not implemented them myself (other than when implementing C), but I did have a design for variadic parameters that looked like this:      proc F(int a, b, c ...) =  Parameters `a b c` would all have type `int`, but the ellipsis denotes that `c` represents a set of 0 or more variadic parameters, each of type `int`.",0.1875,C
156szm0,jt26s39,"Basically, imagine how Python does it, then apply it to a static subroutine in Assembly.",0.5,Python
156szm0,jt26s39,"Basically, imagine how Python does it, then apply it to a static subroutine in Assembly.",0.5,Assembly
156szm0,jt26s39,"For example, in Python, we demure the beginning of out varargs with `*arg`.",0.0,Python
156szm0,jt26s39,Make sure to add something like `argc` in your Assembly code too.,0.5,Assembly
156szm0,jt1ccd9,"C# requires you to type the array, or use the base `object` type.",-0.8,C
156szm0,jtdhpzn,Rust is a prime example of no-varargs going horribly wrong.,-0.5,Rust
156szm0,jt3ef3q,That's because varargs introduce ambiguity when there's partial application involved as in Haskell.,-0.1,Haskell
156szm0,jt275uu,They only serve as a footgun on C style string formatting.,0.0,C
156szm0,jt3nc5l,As seen in Rust.,0.0,Rust
156szm0,jtdtd1q,Varargs would remove ~80% of macro uses in Rust code in the wild.,0.1,Rust
156szm0,jt2mvwc,"Your options are an untyped language (fair enough), or a typed language with untyped variadics (what C does), or a dependently-typed language (where the type of your variadics would be something like `[(t:Type), t]`).",0.35,C
156szm0,jt5ugih,in C# `new [] { ... }` can become pretty bulky.,0.19318181818181818,C
156szm0,jtdybgc,"80% of Rust macro uses are derive macros, so no, that is simply untrue.",0.0,Rust
156szm0,jtfj6yq,60% of Rust macro uses is `vec!`.,0.0,Rust
156szm0,jtg65l9,"Every single time a Rust type has a `#[derive(...)]` annotation, that's a macro invocation for each type derived.",-0.07142857142857142,Rust
156szm0,jtg65l9,That makes up the vast majority of Rust macro usage.,0.0,Rust
156szm0,jtg65l9,"As for `vec!`, it will intrigue you to know that this macro is in fact merely a first-class citizen among a group of very similar forms of syntactic sugar:  C# 10 has some interesting syntactic sugar that rewrites initializer lists into repeated applications of `ICollection<T>.Add`, and C++ has it's own entire thing of dark magic.",0.1357142857142857,C
156szm0,jtg65l9,"As for `vec!`, it will intrigue you to know that this macro is in fact merely a first-class citizen among a group of very similar forms of syntactic sugar:  C# 10 has some interesting syntactic sugar that rewrites initializer lists into repeated applications of `ICollection<T>.Add`, and C++ has it's own entire thing of dark magic.",0.1357142857142857,C++
156szm0,jtg65l9,"Go has direct syntax, as does D. As far as I can tell, Java does use its vararg feature, sure, but that is far from the norm.",0.19999999999999998,Go
156szm0,jtg65l9,"Go has direct syntax, as does D. As far as I can tell, Java does use its vararg feature, sure, but that is far from the norm.",0.19999999999999998,Java
156szm0,jtg65l9,"So, apart from `println!` and friends which ""use macros to emulate varargs"", and that fact that varargs are really just a poor man's macros, what _other_ Rust macros do you know of that emulate varargs?",-0.10833333333333334,Rust
156szm0,jt3r6xc,It's an experiment in how much static checking one can do in a language that has no explicit types (think classless Python).,0.5,Python
156szm0,jt9l373,"C has had dynamic typing since its inception, and C++ has had statically typed heterogeneous lists since 3.0 in 1991.",0.0,C
156szm0,jt9l373,"C has had dynamic typing since its inception, and C++ has had statically typed heterogeneous lists since 3.0 in 1991.",0.0,C++
156ng13,jt225wp,"The meaning most of us give it today rather corresponds to the concepts introduced with Simula 67 and continued with Smalltalk-76/80, C++ and Java, to name a few.",0.15,C++
156ng13,jt225wp,"The meaning most of us give it today rather corresponds to the concepts introduced with Simula 67 and continued with Smalltalk-76/80, C++ and Java, to name a few.",0.15,Java
156ng13,jtl3xra,This is the paper that eventually led to try/catch and checked exceptions in Java.,0.0,Java
156ng13,jt1hzel,InProceedings of the international conference on APL: part 1 1979 May 30 (p. 340).,0.0,APL
156ng13,jt1hzel,"we have   ""Three different paths in the development of generic-concept languages have been followed by APL, Algol 68, and **object-oriented** languages such as SIMULA 67 and Smalltalk.""",0.0,APL
156ng13,juj4nce,Java.,0.0,Java
156ng13,jujg5ju,Java.,0.0,Java
156ng13,jt6b7zu,"Whitewater were acquired by Borland for their resource editor, which ended up packaged with Borland C++, and Actor was left to wither.",0.0,C++
156ng13,jto1lx2,Iirc I ended up using VB for the first (and last) time for a few days some time around 2000 because Delphi was playing up.,0.016666666666666663,Delphi
156ng13,jto1lx2,I went back to Delphi.,0.0,Delphi
156ng13,jto1lx2,"> were acquired by Borland for their resource editor, which ended up packaged with Borland C++  (and Delphi, I presume, not to rub it in about VB... 😁)  > Actor was left to wither.",0.0,C++
156ng13,jto1lx2,"> were acquired by Borland for their resource editor, which ended up packaged with Borland C++  (and Delphi, I presume, not to rub it in about VB... 😁)  > Actor was left to wither.",0.0,Delphi
156ng13,jto1lx2,Was it similar to how Erlang doesn't really follow the model or was it worse than that?,-0.06666666666666667,Erlang
156ng13,jtpa8x5,"Interestingly, Self pioneered the kind of JIT techniques now used by Java and JavaScript VMs, so we're all benefitting from the pioneers of early OOP still.",0.4000000000000001,Java
156ng13,jtpa8x5,"Interestingly, Self pioneered the kind of JIT techniques now used by Java and JavaScript VMs, so we're all benefitting from the pioneers of early OOP still.",0.4000000000000001,JavaScript
156ng13,jtpa8x5,"Just as Smalltalk bears little relation to later OO languages, Self bears little relation of prototype-based programming as it manifests in JavaScript.",-0.125,JavaScript
156joln,jszx631,"Dennis M. Ritchie rewrote McIlroy's roff in PDP-11 assembly for Version 1 AT&T UNIX, Joseph F. Ossanna improved roff and renamed it nroff for Version 2 AT&T UNIX, then ported nroff to C as troff, which Brian W. Kernighan released with Version 7 AT&T UNIX.",0.0,C
156joln,jszx631,"In 1989, James Clark re-implemented troff in C++, naming it groff.",0.0,C++
156ggyr,,"If lifetime is not ended manually, lifetime is automatically ended at the end of function as in all C style languages.",0.0,C
156ggyr,jt0uck1,"Clojure has a similar feature called *transducers*, though they're just a slight simplification on *foldl*.",-0.08333333333333333,Clojure
156ggyr,jt361xo,"In Julia, even easier, just prefix function with a '.",0.0,Julia
156ggyr,jt070od,Python comprehension lists follow a specific syntax.,0.0,Python
156bfwc,jsze94h,Look at the crap of C++ we are in we all understand that.,-0.8,C++
15661oq,jsysf6g,Try looking into a language called APL.,0.0,APL
15661oq,jsyu1or,"APL works on matrices, my language is programmed WITH matrices.",0.0,APL
155t03q,jsw56s2,"Python only got pattern matching in [3.10](https://peps.python.org/pep-0636/), which eases writing, but it would appear that due to the lack of static typing, there's no compile-time exhaustiveness checking.",0.125,Python
155t03q,jszslgj,"I am developing [Cwerg](http://cwerg.org), a new C-like language, primarily in Python.",0.2681818181818182,Python
155t03q,jszslgj,"The idea is to proto-type it in Python and once the design is stable to re-implement it in another more performant language, e.g.",0.5,Python
155t03q,jszslgj,C++.,0.0,C++
155t03q,jszslgj,I am actively working on the frontend in Python.,-0.13333333333333333,Python
155t03q,jszslgj,"It is disappointing, though, that there is still no good performance story for Python even if you have no deps to speak of and do not use a lot of the dynamic features of the language * using type annotations is key both for correctness and the IDE support it enables * having two implementations is super valuable, it make them both more deterministic * I cannot imagine developing Cwerg in any other way.",-0.034523809523809526,Python
155t03q,jszslgj,The iteration time with Python is just unparalleled.,0.0,Python
155t03q,jszslgj,C++ by comparison is painfully slow.,-0.30000000000000004,C++
155t03q,jszslgj,"* I firmly believe, that it would have been slower to develop the compiler in C++ only.",-0.1,C++
155t03q,jsybj7w,"Because you're better off with Haskell, a ML, or a Lisp.",0.5,Haskell
155t03q,jsybj7w,"Because you're better off with Haskell, a ML, or a Lisp.",0.5,Lisp
155t03q,jsz9v4b,Even C's type system is better than nothing.,0.5,C
155t03q,jsxg4am,Because Haskell and similar are pretty much strictly and fairly objectively better for compiler dev.,0.2375,Haskell
155t03q,jsxhitb,"I'm writing my bootstrap compiler in C++, but all of my code generation tools so far are written in python.",0.1,C++
155t03q,jsx3wm4,I did generate Assembly with Python.,0.0,Assembly
155t03q,jsx3wm4,I did generate Assembly with Python.,0.0,Python
155t03q,jsym6x3,Ruby is better for this kind of stuff anyway.,0.55,Ruby
155t03q,jsz18om,"It's funny, y'know, because I could write a compiler much quicker in Python, and it would certainly be less error-prone, than if I wrote it in say, C++.",0.09444444444444444,Python
155t03q,jsz18om,"It's funny, y'know, because I could write a compiler much quicker in Python, and it would certainly be less error-prone, than if I wrote it in say, C++.",0.09444444444444444,C++
155t03q,jsz18om,"Maybe I should prototype mine in Python and reïmplement it in C++ when mature...  Also, all the people lamenting Python's pattern-matching, I think this is only half the puzzle.",-0.022222222222222216,Python
155t03q,jsz18om,"Maybe I should prototype mine in Python and reïmplement it in C++ when mature...  Also, all the people lamenting Python's pattern-matching, I think this is only half the puzzle.",-0.022222222222222216,C++
155t03q,jsz18om,"A large part of compiler development is text processing, which Python is quite intuitive for...",0.21428571428571427,Python
155t03q,jsvwaoc,"I'll go ahead and answer my own question and say that it's probably because a lot of people prefer static typing, but then nobody makes compilers in Java either.",0.55,Java
155t03q,jsxtdw8,"It doesn't use a compiler    is an interpreted language, which means the source code of a Python program is converted into bytecode that is then executed by the Python virtual machine",0.0,Python
155t03q,jsyx63z,"Speaking as someone whose last few compiler projects were written in Python :P  For a one person project on a toy language it's fine, but I think for more complex compilers with multiple contributors Python doesn't scale as well as other languages do.",0.13020833333333334,Python
155t03q,jsyx63z,"Python is easy to write but also easy to make mistakes/introduce bugs that can be tricky to debug in a complex piece of software like a compiler, mitigating those risks requires extra work that you wouldn't need to do in other languages, so unless you have a specific reason to make your compiler in Python usually other languages are better.",0.10208333333333333,Python
155t03q,jsz2g9o,"Mainly, because it seems 95% of programming-language hobbyists are also inveterate Haskell or ML fans.",0.16666666666666666,Haskell
155t03q,jsz2g9o,"Sure you can do compilers with pattern-matching, but then you can also write a C compiler in C, or a Pascal compiler in Pascal.",0.5,C
155t03q,jsz2g9o,"Sure you can do compilers with pattern-matching, but then you can also write a C compiler in C, or a Pascal compiler in Pascal.",0.5,Pascal
155t03q,jsz2g9o,If that's Python (as it is for me) then go right ahead and build your bootstrap therein.,0.2857142857142857,Python
155t03q,jsz2g9o,Here's why: Nothing stops big companies from doing big software engineering on Python.,0.0,Python
155t03q,jt9dizp,"I started writing mine in Python, in the end I'll probably switch to like Rust but I find it easier to prototype in Python ([link to my compiler so far](https://github.com/SamG101-Developer/SPP-Compiler-2/tree/master/src)).",0.0,Python
155t03q,jt9dizp,"I started writing mine in Python, in the end I'll probably switch to like Rust but I find it easier to prototype in Python ([link to my compiler so far](https://github.com/SamG101-Developer/SPP-Compiler-2/tree/master/src)).",0.0,Rust
155t03q,jsz10v8,Python is _not_ a crappy language,0.0,Python
155t03q,jsxscnu,Including Python.,0.0,Python
155t03q,jsyiqqe,Haskell?,0.0,Haskell
155t03q,jt5n38k,Oils is using both ASDL and pgen2 with C++ back ends as well.,0.0,C++
155t03q,jt5n38k,"It's been all over the blog, not particularly organized, but I may write up an architecture description later:  https://www.oilshell.org/blog/2022/03/middle-out.html  https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL  I've indeed found it  useful to borrow metalanguages from Python itself.",0.07222222222222223,Python
155t03q,jt5n38k,"Oils is made faster via a translator from statically typed Python to C++ called ""mycpp"".",0.0,Python
155t03q,jt5n38k,"Oils is made faster via a translator from statically typed Python to C++ called ""mycpp"".",0.0,C++
155t03q,jt5n38k,It would basically be like if:  - shell was a good language - the C preprocessor and shell were the SAME language (they are kinda  similar if you squint?),0.2333333333333333,C
155t03q,jswbcd3,Java is too verbose.,0.0,Java
155t03q,jswbcd3,People typically choose Java only if they want to write a language that targets JVM.,-0.08333333333333333,Java
155t03q,jswbfjf,"People absolutely do use Java, many resources like Crafting Interpreters and Modern Compiler Implementation use Java, it was the choice in the course I took and doesn't seem to be uncommon in general.",0.35,Java
155t03q,jswbfjf,"Also [Vinegar](https://github.com/catseye/Vinegar) is an example of a proof-of-concept implementation in Python, and [Thun](https://joypy.osdn.io/) is a Joy interpreter written in Python.",0.8,Python
155t03q,jsz9nfx,"Python's niche is, apparently, gluing together useful code that is *not* written in Python.",0.175,Python
155t03q,jsyvgp3,"OCaml is another good option, it has nice FP features but is a bit more flexible than Haskell.",0.6,Haskell
155t03q,jsyvgp3,"The initial compiler for Rust was written in OCaml, before it was self-hosted.",0.0,Rust
155t03q,jsyydwr,Scala is very cool too.,0.45499999999999996,Scala
155t03q,jsxi4iv,"> Python has a de-facto standard testing framework, pytest that makes it very simple, and it has a first party stdlib solution unittests, although that is considered too verbose today.",0.08333333333333333,Python
155t03q,jswl9uv,You can write Java without it being verbose so long as you throw out getters/setters and just use public fields.,-0.025,Java
155t03q,jswjask,Wondering whether it \*is\* possible to target JVM \*without\* wring a compiler in Java?,0.0,Java
155t03q,jsx8qxf,One step closer to Kotlin.,0.0,Kotlin
155t03q,jsyvlpx,"Relevant to both this thread and your comment, [compiler written in Python targeting JVM](https://yangdanny97.github.io/blog/2021/08/26/chocopy-jvm-backend)",0.4,Python
155t03q,jsx1hxb,"Yeah, the Scala compiler is written in Scala and the Kotlin compiler is mostly Kotlin",0.5,Scala
155t03q,jsx1hxb,"Yeah, the Scala compiler is written in Scala and the Kotlin compiler is mostly Kotlin",0.5,Kotlin
155t03q,jt83vp9,"So instead I chose to do what Python does, requring everything to be defined by the time of first usage.",0.25,Python
155t03q,jt83vp9,"Probably, rtime code will also be able to interact with ctime constructs through a specific interface, similar to how Python allows C extension libraries.",0.16666666666666666,Python
155t03q,jt83vp9,"Probably, rtime code will also be able to interact with ctime constructs through a specific interface, similar to how Python allows C extension libraries.",0.16666666666666666,C
155t03q,jt83vp9,"I've actually considered just making a Python library to simplify writing programs as compilation scripts, but have decided against it.",0.0,Python
155t03q,jt83vp9,"While both Lua and Python are self-implemented (if observed from within the language), the runtime language on top of them would have to be integrated into the same mechanism in order to be sufficiently uniform, and that would make it poorly suited for performance-sensitive runtime evaluation",0.033333333333333326,Lua
155t03q,jt83vp9,"While both Lua and Python are self-implemented (if observed from within the language), the runtime language on top of them would have to be integrated into the same mechanism in order to be sufficiently uniform, and that would make it poorly suited for performance-sensitive runtime evaluation",0.033333333333333326,Python
155t03q,jt9m28p,Though I'd also say Julia's metaprogramming and compilation model could be related.,0.0,Julia
155rqm1,jsy9497,"Minor tip i got from the (very readable but informal) Go specification is, if your language is syntactically heterogeneous, to pick apart grammar productions in bundles that make semantic sense, and for each syntactical term, give a semantical meaning.",0.07500000000000001,Go
155rqm1,jswcy3a,You iterated all the way from C to S and transpilong to C++?,0.0,C
155rqm1,jswcy3a,You iterated all the way from C to S and transpilong to C++?,0.0,C++
155rqm1,jswcy3a,"I am not sure why do you have so much similarity to C++ in your STL, are you transpiling to C++?",-0.024999999999999994,C++
155rqm1,jszukxw,"honestly reddit is great for specific articles on bits of language design, also finding blogs of other language designers like Graydon's who's put a couple stuff out there about Rust etc.",0.31875,Rust
155rqm1,jsvukq4,"It allows splitting inheritance per base class, like Rust's splitting impls on a struct per trait.",-0.8,Rust
155rqm1,jsxkbws,I'd probably go with always mandating `{}` like Rust does.,0.0,Rust
155cisi,jsty31j,After way to many `NullPointerException`s in Java in the past.,0.125,Java
155cisi,jsty31j,[enum `Option`](https://doc.rust-lang.org/std/option/) in Rust.,0.0,Rust
155cisi,jsty31j,"For instance in [Kotlin](https://kotlinlang.org/docs/null-safety.html#nullable-types-and-non-null-types), if we have a `val s: String`, then `s` is guaranteed to be a `String`.",0.0,Kotlin
155cisi,jsty31j,"TypeScript has [union types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types), which allow a type to be specified like, e.g.",0.0,TypeScript
155cisi,jsty31j,"function f(x: number | string | null) {         if (typeof x === ""number"") {             console.log(""x is a number"");         } else if (typeof x === ""string"") {             console.log(""x is a string"");         } else {             console.log(""x is null"");         }     }          f(123);     f(""Hello World"");     f(null);  Something similar is possible in Kotlin using [sealed classes](https://kotlinlang.org/docs/sealed-classes.html) and the [`is` operator](https://kotlinlang.org/docs/typecasts.html#is-and-is-operators).",0.0,Kotlin
155cisi,jsty31j,"Here's a tiny AST example:      sealed class Expr      class Const(val num: Int) : Expr()     class Add(val lhs: Expr, val rhs: Expr) : Expr()     class Sub(val lhs: Expr, val rhs: Expr) : Expr()      fun eval(expr: Expr): Int =         when (expr) {             is Const -> expr.num             is Add -> eval(expr.lhs) + eval(expr.rhs)             is Sub -> eval(expr.lhs) - eval(expr.rhs)         }       fun main() {         println(eval(Const(1)))         println(eval(Add(Const(1), Sub(Const(4), Const(2)))))     }  Given that `expr` is a `sealed class`, then Kotlin enforces that all classes derived from `Expr` is matched in the [`when` expression](https://kotlinlang.org/docs/control-flow.html#when-expression).",0.19166666666666665,Kotlin
155cisi,jstwdge,"In Kotlin, nullable references form a separate type hierarchy (X?).",0.0,Kotlin
155cisi,jstwdge,There were also C dialects with non-nullable pointer types.,0.0,C
155cisi,jsu04qy,You can study how Dart or Swift implemented their null-safe types.,0.0,Dart
155cisi,jsu04qy,You can study how Dart or Swift implemented their null-safe types.,0.0,Swift
155cisi,jsunmvn,"This largely corresponds with how it is done in C, although C doesn't have a dedicated `NULL` literal, it uses `0` (sometimes, `NULL` is defined as `(void*)0`).",0.21428571428571427,C
155cisi,jsunmvn,"I can use `nil` in dynamic code like this:      f := fopen(""file"",""r"")     # call C function via FFI     if f = nil then            # could not open file  If a language does not support the concept of `nil` or `NULL`, and you want to call functions via FFIs like my example, then you will a workaround.",0.0,C
155cisi,jsu5nnv,"For example, a byte with null example would support the values of:       0 ... 255 , NULL  The concept of ""null"" did exist before on Lisp, but used ""nil"" instead.",0.0,Lisp
155cisi,jsu5nnv,"Before Java retake Lisp usage of null, null was used as the empty value of pointers.",-0.1,Java
155cisi,jsu5nnv,"Before Java retake Lisp usage of null, null was used as the empty value of pointers.",-0.1,Lisp
155cisi,jsv1mzp,"After all, there's literal-list syntax for both terms and types in Haskell.",0.0,Haskell
155cisi,jsy60o6,For languages in the C lineage (e.g.,0.0,C
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,C
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,C++
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,Java
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,C
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,C++
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,Java
155cisi,jsy60o6,"For languages in the Lisp lineage (dynamically typed, e.g.",0.0,Lisp
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,Lisp
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,Python
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,Ruby
155cisi,jsy60o6,"SML, Rust, Haskell), there typically isn't really a notion of NULL, there are only [sum types](https://en.wikipedia.org/wiki/Tagged_union), which represent things that can be one of several possible values.",0.05,Rust
155cisi,jsy60o6,"SML, Rust, Haskell), there typically isn't really a notion of NULL, there are only [sum types](https://en.wikipedia.org/wiki/Tagged_union), which represent things that can be one of several possible values.",0.05,Haskell
155cisi,jsur9sh,"In Kotlin, is flow typing used to narrow a `String?` to a `String` after a null check?",-0.2,Kotlin
155cisi,jsu2kta,Kotlin uses null to represent optionals.,0.0,Kotlin
155cisi,jstydrx,"At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W).",0.25,ALGOL
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,C
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,Java
155cisi,jsutsgq,"> C doesn't have a dedicated NULL literal, it uses 0 (sometimes, NULL is defined as (void*)0).",0.0,C
155cisi,jsusbzs,"In Rust for example, it's defined in the standard library (not in the compiler itself), any user could've defined it.",0.0,Rust
155cisi,jsuf6xv,"Which is something that can come up, when iterating, mapping, filtering, and flattening [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html)s and [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html)s in Rust at least.",-0.3,Rust
155cisi,jsuuh3m,"Yes, Kotlin features a limited form of flow-sensitive typing and calls it [smart casts](https://kotlinlang.org/spec/type-inference.html#smart-casts).",0.07142857142857142,Kotlin
155cisi,jsvz3lq,"In case of Kotlin, decision to have special case type hierarchy for nullable types (and not having union types in the language, although this question was raised regularly in scope of Kotlin/JS and interoperability with TypeScript) was primarily a type inference performance concern.",0.2523809523809524,Kotlin
155cisi,jsvz3lq,"In case of Kotlin, decision to have special case type hierarchy for nullable types (and not having union types in the language, although this question was raised regularly in scope of Kotlin/JS and interoperability with TypeScript) was primarily a type inference performance concern.",0.2523809523809524,TypeScript
155cisi,jsv6plv,Kotlin uses [nullable types](https://en.wikipedia.org/wiki/Nullable_type) which are more like [union types](https://en.wikipedia.org/wiki/Union_type) than [option types](https://en.wikipedia.org/wiki/Option_type).,0.5,Kotlin
155cisi,jsv6plv,Nullable types are more convenient to work with in many cases and are more familiar to imperative programmers coming from languages like Java with `null`.,0.46875,Java
155cisi,jsuahmn,syntax in Kotlin.,0.0,Kotlin
155cisi,jsuyxll,The mistake was to make nulls implicit like in C or Java.,0.0,C
155cisi,jsuyxll,The mistake was to make nulls implicit like in C or Java.,0.0,Java
155cisi,jsuxxdd,"(The code also looked suspiciously like C++, unless C23 also has `auto`, and the name of the file it tries to compile is `main.cpp`.)",-0.1,C++
155cisi,jsuv9df,Kotlin: https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiJmdW4gbGVuKHM6IFN0cmluZz8pOiBJbnQge1xuICAgIHJldHVybiBzLmxlbmd0aFxufSJ9  TypeScript: [https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA](https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA),-0.75,Kotlin
155cisi,jsuv9df,Kotlin: https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiJmdW4gbGVuKHM6IFN0cmluZz8pOiBJbnQge1xuICAgIHJldHVybiBzLmxlbmd0aFxufSJ9  TypeScript: [https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA](https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA),-0.75,TypeScript
155cisi,jsvcb6k,> Kotlin uses nullable types which are more like union types than option types.,0.5,Kotlin
155cisi,jsudtqj,syntax in Kotlin.,0.0,Kotlin
155cisi,jsudtqj,Similar sugar exists in Rust and possibly other languages as well.,-0.0625,Rust
155cisi,jsudtqj,In Kotlin you can define methods on null types.,0.0,Kotlin
155cisi,jsu91sy,"Regarding your first point: I'm not sure how this is done in Rust but in other languages I know, None is a valid assignment for Option<T> for all T. In Kotlin, an optional type would be T?",-0.041666666666666664,Rust
155cisi,jsu91sy,"Regarding your first point: I'm not sure how this is done in Rust but in other languages I know, None is a valid assignment for Option<T> for all T. In Kotlin, an optional type would be T?",-0.041666666666666664,Kotlin
155cisi,jsu91sy,and similarly null is valid for any T. In Scala None is Option[Nothing] with Nothing being the subtype of every type.,0.0,Scala
155cisi,jsu91sy,"Regarding the second point, the same can also be done with null, again, like in Kotlin.",0.0,Kotlin
155cisi,jsuwgps,"At least in the context of Kotlin (believe me, I have no particular feelings for the language other than that I find it interesting) this is not correct.",-0.002083333333333326,Kotlin
155cisi,jsuwgps,In Kotlin you cannot use a value of type T?,0.0,Kotlin
155cisi,jsuwgps,You can (again Kotlin) assign null to a variable of an optional type the same as you can assign None to any variable of type Option<T>.,0.0,Kotlin
155cisi,jsuwgps,"And well in, say Java, you would have to consider every non-primitive type optional.",0.0,Java
155cisi,jsuwgps,But Java just does not have any advanced features when it comes to null.,0.4,Java
155cisi,jsuwgps,Basically      // Kotlin     let a: A?,0.0,Kotlin
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,Rust
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,Java
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,Kotlin
155cisi,jsuwgps,= ...     a = b     // Rust     let a: Option<A> = ...     let b: Option<B> = ...     a = b     // Java     A a = ...     B b = ...     a = b  But this is hardly interesting.,0.5,Rust
155cisi,jsuwgps,= ...     a = b     // Rust     let a: Option<A> = ...     let b: Option<B> = ...     a = b     // Java     A a = ...     B b = ...     a = b  But this is hardly interesting.,0.5,Java
155cisi,jsuskdq,I dislike Rust's use of 'try_thing' being the call that returns the Result.,0.0,Rust
155cisi,jsycs7a,JavaScript has this and I gotta say my personal opinion is that having two different nulls is even worse than having null,-0.13333333333333333,JavaScript
155cisi,jsue3dl,How do you do this in Kotlin?,0.0,Kotlin
155cisi,jsue3dl,Rust doesn't any additional syntax for Option.,0.0,Rust
155cisi,jsue3dl,As seen in Kotlin's special syntax for nullable types.,0.35714285714285715,Kotlin
155cisi,jsuvn1j,"Somewhat related, in Rust I've long wanted a crate-level attribute to disallow potential panics, i.e.",-0.016666666666666666,Rust
155cisi,jsv0nxd,"The same programmers wouldve been getting nulls and other UB in C++ though, so in a way, things are a bit better.",0.125,C++
154sacf,jsqofsf,The C++ generic algorithms library has both std::for_each (which just visits each element) and std::accumulate (which acts similarly to a fold).,0.0,C++
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,JavaScript
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,C++
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,Rust
154sacf,jsrshrg,"Also if you're looking for a very general functional looping construct, you may want to implement something like Scheme's [named let](https://weinman.cs.grinnell.edu/courses/CSC151/2014F/readings/named-let-reading.html).",0.06500000000000003,Scheme
154sacf,jss14mo,"This is typically called `map` (in Haskell, this is specifically called `fmap`).",-0.16666666666666666,Haskell
154sacf,jss14mo,"This is typically called `reduce`, `fold` (in Haskell, this is specifically called `foldl` which has a closely related sister function called `foldr`), `accumulate`, etc.",-0.08333333333333333,Haskell
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,JavaScript
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,Rust
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,Python
154sacf,jstrbxr,`reduce` comes from APL and it is so named because it uses a function to *reduce* the dimension of the data being processed.,0.0,APL
154sacf,jssghrg,This is why I’m in favor of how Ruby supports multiple names for the same method.,0.0,Ruby
154sacf,jsql3dp,To me it sounds like a `mapM_` (in Haskell terminology).,0.0,Haskell
154qygu,jsqtuup,"Many prebuilt types like ""i32"" or prebuilt functions like the ""main"" function in C, or the ""and"", ""or"" operators in SQL are examples of ""predefined idents"".",0.3333333333333333,C
154apa1,jsp4r7q,"However while the two following sentences are true, they do not give a clear view of the domain:   - Go is meant to write servers (any program can be transformed in a server)  - C is meant to write programs (literally what a _programming_ language is meant to do)",0.15,Go
154apa1,jsp4r7q,"However while the two following sentences are true, they do not give a clear view of the domain:   - Go is meant to write servers (any program can be transformed in a server)  - C is meant to write programs (literally what a _programming_ language is meant to do)",0.15,C
154apa1,jsnyz2b,"Sometimes they are created using intricate Assembly libraries, as some pthreads implementations which have no access to clone\* system calls do.",0.0,Assembly
154apa1,jsnyz2b,"Even if that host is the microprogram of the CPU, for example, when you compile C code with -ffreestanding, the host still exists, it's the microprogram.",0.0,C
154apa1,jsntsyp,"Bash can't generate random numbers natively, but some program with that ability is expected.",-0.3,Bash
154apa1,jsntixq,Sy many languages have semantic constraints on what structures you can create (see doubly linked lists in safe Rust).,0.3333333333333333,Rust
1548d01,jspltil,"It would take me a bit of time to dust off my C skills and take a closer look at your code, but I might get to it at some point.",0.0,C
1548d01,jspy5vl,Always glad to see something written in C in these days.,0.5,C
153zpve,jspkhkp,Just look at lambdas in C++: they compile to an instance of an anonymous struct with fields for all captured values and an overloaded call operator.,0.0,C++
153h7x0,jsjg0u9,"Python PL makes it sweet to write in, but hellish to even write a generator for.",0.35,Python
153h7x0,jsodlh5,I'm using Python for my host and some day I would like to generate native code after I get all the semantic kinks ironed out.,0.0,Python
153h7x0,jslmlys,"Ah, the reason I chose to implement this in Python was because the Chocopy is a subset of Python.",0.0,Python
153h7x0,jslmlys,"Therefore I didn't need to write a parser at all, I just parsed it into the Python AST using the built-in `ast` module and converted that into my own AST.",0.6,Python
153h7x0,jslmlys,When people take the class at Berkeley they use Jflex for the parser since the skeleton code for their assignments is in Java.,0.0,Java
153h7x0,jskozjj,Do you mean you think Python is a bad language to use for implementing another language?,-0.5062499999999999,Python
153h7x0,jskufyt,"I'm not sure how much of a CFG Python grammar is, but it seems very hard to parse by hand at least.",-0.18229166666666669,Python
153h7x0,jskufyt,It was in Go but I implemented it in C and it worked just fine.,0.4166666666666667,Go
153h7x0,jskufyt,It was in Go but I implemented it in C and it worked just fine.,0.4166666666666667,C
153h7x0,jsm1xca,I think writing a subset of Python is not going to be that hard.,-0.2916666666666667,Python
153bfuu,jsj33j7,Similar to Eiffel?,0.0,Eiffel
153bfuu,jsj5266,"However, Eiffel checks preconditions/postconditions at runtime, raising an exception if they’re not met.",0.0,Eiffel
153bfuu,jsky0fk,"(As an outsider my impression is that this happens in all these systems, for example Dafny, Why3 and Liquid Haskell, because automated solvers do not scale in many cases, and they become increasingly slow and brittle before they stop working completely.",0.09999999999999998,Haskell
15369z8,jsjdnt9,"I would look into [SPARK](https://docs.adacore.com/spark2014-docs/html/lrm/), which is a subset of the Ada language that supports formal verification of programs using an automated theorem prover.",0.0,Ada
15369z8,jsjdnt9,"Both Ada and SPARK have facilities for safety critical programs, especially real-time embedded systems.",0.0,Ada
15369z8,jsia2v4,"Check out Dafny, F*, TLA+, and check out how the seL4 OS was verified, even though it’s written in C: https://www.cs.columbia.edu/~junfeng/09fa-e6998/papers/sel4.pdf.",0.0,C
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,C
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,Go
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,Rust
15369z8,jsj0bou,"As a practical example, where most C code will accept an index in an array as `size_t` which may fail at runtime (or worse: trigger a buffer overrun), the most correct type, whose use can never fail, is `Index (xs: List a) = { i ∈ ℕ₀ | i < |xs| }` (where `ℕ₀` includes 0).",0.06999999999999999,C
15369z8,jsi1owa,"Have you checked ADA, Rust & Zig?",0.0,Rust
15369z8,jslgj51,You'd probably want to allow programmers to manually assert the complexity of a function where the compiler is unable to deduce it (similar to Rust's `unsafe`).,-0.25,Rust
15369z8,jsils9p,"You can check for example:  https://www.scattered-thoughts.net/writing/how-safe-is-zig/ https://andrewkelley.me/post/unsafe-zig-safer-than-unsafe-rust.html  I think Rust is the best of the 3, but each one teaches good lessons.",0.85,Rust
15369z8,jsils9p,"I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  ```pascal var    Day : Set of 1..31;    Month : Set of 1..12;  ```  and that certainly is very useful to make safe APIs!",0.3608928571428571,Delphi
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,Ada
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,Rust
15369z8,jslyqx8,"> I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  It's fairly incomplete, unfortunately:   1.",0.15714285714285714,Delphi
15369z8,jslyqx8,"In my Rust code, instead, I have library code to create a generic strong type facility with arbitrary invariant validation:      struct Tagged<T, D>(T, PhantomData<fn(D)->D>);      impl<T, D> Tagged<T, D> {         pub fn new(value: T) -> Result<T, D::Error>         where             D: ValidateInvariant<T>,         {             D::validate(&value)?",0.11111111111111109,Rust
15369z8,jslyqx8,"In my Rust code, instead, I have library code to create a generic strong type facility with arbitrary invariant validation:      struct Tagged<T, D>(T, PhantomData<fn(D)->D>);      impl<T, D> Tagged<T, D> {         pub fn new(value: T) -> Result<T, D::Error>         where             D: ValidateInvariant<T>,         {             D::validate(&value)?",0.11111111111111109,D
15369z8,jsirk34,I believe this is already present in Rust with `Range` and `RangeInclusive`.,0.0,Rust
15369z8,jsirk34,You can write something like: ```rust let range = 1..31; // range.start() = 1 // range.end() = 31 ``` I'm not sure how different are the ranges you mentioned from Rust's.,-0.125,Rust
152hv8q,jsg4mxc,"Well, there are dynamically typed functional languages, like Lisp.",0.0,Lisp
152hv8q,jsgciv9,Like APL.,0.0,APL
152hv8q,jsgk55e,"Wow, APL is a great beast, I tried few times to learn it.",0.2333333333333333,APL
152hv8q,jsgpg2o,"APL programmers used to send each other one-liners and ask, ""OK, what does this do?""",0.1875,APL
152hv8q,jsgpg2o,APL is probably one of the most difficult languages to learn.,0.0,APL
152hv8q,jstxycf,"But I had an inherent interest in APL's design, so...",0.0,APL
1529hgn,jscsecw,"> if a developer has any idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects  Java’s `URL.equals()` would like a word.",0.16,Java
1529hgn,jsczxqu,"It would be so nice to enforce that some C++ callback can’t allocate memory on the heap, take a lock, yield, etc.",0.6,C++
1529hgn,jsczxqu,"I’m not sure if it’s enough to persuade people to use some language over C++, but that doesn’t mean the feature lacks value.",-0.1875,C++
1529hgn,jsd204y,Maybe it's also similar to type checking in the sense that people didn't like static types because most people were familiar with Java or C++ style types which were really limited back then.,0.21726190476190477,Java
1529hgn,jsd204y,Maybe it's also similar to type checking in the sense that people didn't like static types because most people were familiar with Java or C++ style types which were really limited back then.,0.21726190476190477,C++
1529hgn,jsd0kx7,"But it's ok, security vulnerabilities are not on every programmers' minds (let's ignore those flashbacks featuring my PHP teacher), so surely there are no other cases of such hippy concepts getting in the way of profit, such as _security_, _correctness_, _data races_, _the VM crashing at runtime because user code tried to log by writing onto nothing_, or the entire idea of ""accessing an object"" through a reference which may be NULL - which Hoare himself calls his Billion Dollar Mistake - which can neither be modelled as an effect nor have any economical cost.",0.19464285714285715,PHP
1529hgn,jsd4d0y,"Think Scala, think Common Lisp quotes.",-0.3,Scala
1529hgn,jsd4d0y,"Think Scala, think Common Lisp quotes.",-0.3,Lisp
1529hgn,jsd015f,"Moreover, the value that it returns is totally immutable, like all values in Haskell.",0.0,Haskell
1529hgn,jsd98n6,"OO languages already have something for this: It's called dependency injection, and the truck-sized hole in DI for Java is the global package scope.",0.0,Java
1529hgn,jsdmf1a,I'm kinda persuaded by the bold argument that if a language feature has any merit at all Java would have stolen it by now.,0.3333333333333333,Java
1529hgn,jsdfdz1,"I notice that Java in characteristic fashion solved the problem by adding a second sort of `switch` statement which also isn't very good, but at least it doesn't have fallthrough.",0.1358333333333333,Java
1529hgn,jsd443x,"In Haskell, the IO monad isn't actually an 'effect' it is just a description of an effectful computation in a state-monadic/continuation-passing form.",0.0,Haskell
1529hgn,jsd3b5b,Optimizing C compilers have been moving code around for years which can make code harder to debug.,-0.1,C
1529hgn,jsgznmn,"I think the JavaScript implementation of async/await is a bit confusing for asynchronous error handling, like how `.catch` is used on Promise directly but `try/catch` otherwise.",-0.09999999999999999,JavaScript
1529hgn,jsgznmn,I think it has value in JavaScript.,0.0,JavaScript
1529hgn,jsf6vh9,Python's @contextmanager decorator needs a generator function that suspends once,0.0,Python
1529hgn,jsg7tx1,"The language I'm slowly working on in my free time is porting an Effect System to Assembly and binary code, where `mov [rax], rdi` has type `{ in rdi: a, rax: mem a; writes rax }`.",0.04999999999999999,Assembly
1529hgn,jsdes2m,I mainly want to forbid cases like this (using Rust in this example):      println!,0.20833333333333331,Rust
1529hgn,jsdes2m,"For panics, I meant something like panics in Rust that are basically implemented as a `throw` with `catch_unwind` being a `try/catch`.",0.0,Rust
1529hgn,jsktpww,I think that's how C# does it but not completely sure.,-0.25,C
1529hgn,jswrpx1,"Checked exceptions (as implemented in Java) can't be used alongside polymorphism; either a polymorphic function throws no exceptions, rendering it incorrect, or it throws any exception, despite the fact that when used it will only throw a subset.",0.0,Java
1529hgn,jswrpx1,"This can be solved via effect polymorphism, but Java lacks that feature.",0.0,Java
1524b7f,jscffe1,Some of the recent work I'm aware of (but this is outside my core area) is Max Bolingbroke's [Cambridge Haskell Supercompiler](https://github.com/batterseapower/chsc).,0.08333333333333333,Haskell
1520pt9,jsem8fm,I think that was clearest when they presented this Python program:      def g(x):         return         x - 10  And then cited students struggling to predict the exact error as an example of their evidence that they struggled with a transition from functional to imperative programming.,0.25,Python
1520pt9,jsem8fm,"Or even more surprisingly, a lot of concern with whether students understand that a function that doesn't explicitly return a value in Python will actually return a `None` that can be assigned to a variable.",0.39999999999999997,Python
1520pt9,jsnhneb,The style of Lisp is much better at teaching imo.,0.5,Lisp
151nyde,,I call it 'Creole C'.,0.0,C
151nyde,,Or maybe 'Pidgin C'.,0.0,C
151nyde,jscwwpj,"Well with this in mind, I assumed creole C to be just some sort of C with fancy extentions.",0.0,C
151j3gf,jsa7gy9,"The Future of C ...""  C != C++",0.0,C
151j3gf,jsa7gy9,"The Future of C ...""  C != C++",0.0,C++
1516vdp,js8h8rc,This is sort of what C does.,0.0,C
1514w59,js6vhrt,"- context free grammars: good - compiler switches: bad - compiler warnings: bad - follow C ABI: good - built-in doc generator: good - built-in test framework: good - manual memory management: will require more programmer time - multiple pointer types: bad - portability should be easy - builtin UTF-8: good - too many choices: bad - special debug and assert functionality: good - pointless flexibility like both `l` and `L` for large integer literals: bad - user extensibility (operator overloading, custom literals, implicit conversions) relieves pressure on the language - greppable syntax (e. g. for finding casts) - redundancy in syntax: semicolons good - underscores in number literals: good - composability: good - macros: bad, don't work",0.18498964803312637,C
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,C
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,C++
1514w59,jsahs8w,"Well, I ended up going back to C, because of several otherwise reasonable limitations of Zig.",0.06666666666666667,C
1514w59,js7ho5j,"C macros, certainly horrible (if you don't use them correctly + easy make parenthesis mistakes especially when you are starting out (nowadays I only do that when I am running on caffeine at 3AM) or redefine syntax).",-0.11333333333333333,C
1514w59,js710du,abused  Example of a good macro in C:      #define CAST     CAST(float)(a)/b;  `CAST` is defined an empty string.,0.3,C
1514w59,js7s7yl,"I often use C macros for stuff like `#define FOO(str) assert(foo_api(context, state, str, strlen(str)) != -1)` (passing lots of common arguments, doing validation of the return, etc.",-0.3,C
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,Java
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,Python
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,Ruby
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,C
1514w59,jsc9a36,"On the other hand, Rust's doc generator is great.",0.3375,Rust
1514w59,jsa7yqs,I did watch it and I think he straw-manned Lisp a little bit.,-0.1875,Lisp
1514w59,jsa7yqs,"I'm a hobbyist Common Lisper and, in my experience, macros are not a barrier to any major CL project or the reason Lisp hasn't become ""popular"".",0.12083333333333333,Lisp
1514w59,jsa7yqs,"Certainly, if the industry finds things like Java's Lombok acceptable (which is horrifying under the hood), most uses of macros in Common Lisp shouldn't offend anyone.",-0.12142857142857143,Java
1514w59,jsa7yqs,"Certainly, if the industry finds things like Java's Lombok acceptable (which is horrifying under the hood), most uses of macros in Common Lisp shouldn't offend anyone.",-0.12142857142857143,Lisp
1514w59,jsk1xgv,"If I mouseover a C++ macro in VS Code, it will at least show me what it expands to and ctrl+click mostly works.",0.1,C++
1514ibb,js75h2w,"Some time ago I wrote a *generalized uncurry* in Haskell which could eliminate the need for multiple distinct operators like above, at the expense of having to define instances for each product type (though I'm sure this could be automated with TH).",0.2,Haskell
1514ibb,js75h2w,"data Point = Point Double Double     instance Uncurry (Double -> Double -> r) Point r where       uncurry f (Point x y) = f x y      data Size = Size Double Double     instance Uncurry (Double -> Double -> r) Size r where       uncurry f (Size w h) = f w h  And its uses can be chained, as in:      drawRectangle >$ point >$ size  Where      drawRectangle :: Double -> Double -> Double -> Double -> Render ()  This is the how arguments are passed in Haskell's Cairo bindings.",0.0,Haskell
1514ibb,js8iuou,"But despite what the Haskell hive-mind thinks, in my day job multi-argument functions are the norm, so that cutesy composition operators would not earn their keep.",0.0,Haskell
1514ibb,js7gkkc,"If you really want to replace this operator, most random symbols are OK. For example `|` like in Unix or `&` like in Haskell.",0.175,Haskell
1514ibb,js7glyj,I used: `value` ``` `` ``` `function1` ``` `` ``` `function2`  Because my PL grammar has infix function call notation like in Haskell: `1` ``` ` ``` plus ``` ` ``` `2`,0.0,Haskell
1514ibb,js7joy7,"Haskell uses `.`, but for function composition from left to right.",0.14285714285714285,Haskell
1514ibb,js7joy7,"Haskell also has `>>>`, which works like the pipe operator we know.",0.0,Haskell
1514ibb,js7joy7,"Clojure has an interesting approach to this using a macro, where you only need to write the arrow once.",0.25,Clojure
1514ibb,jsa7urp,"There are parallels to Unix pipes, and also to concatenative programming in general  I have a project called Z where I was trying to explore something like this space in Java",0.05000000000000002,Java
1514ibb,js8ey5c,Then you can reverse (<- or <<) for binding assignment a la Haskell or [LiveScript](http://livescript.net/).,0.0,Haskell
1514ibb,jsc97q9,"> But despite what the Haskell hive-mind thinks, in my day job multi-argument functions are the norm, so that cutesy composition operators would not earn their keep.",0.0,Haskell
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,Clojure
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,Lisp
1512nfo,,"Today I tried to search a little for other ""prior art"", and stumbled upon this [page](https://forums.swift.org/t/multiplication-by-juxtaposition/64128), about adding this to Swift.",-0.10416666666666667,Swift
1512nfo,,The proposal includes the code needed to implement the feature in Swift.,0.0,Swift
1512nfo,,"I don't know Swift, but it seem the author of the proposal saw in necessary to restrict implicit multiplication to having the right operand being parenthesised.",0.14285714285714285,Swift
1512nfo,,"The implementation was rather surprising, but - given I don't know Swift - looks both elegant and efficient.",0.6,Swift
1512nfo,,"There are languages (in particular functional programming languages, I think) that allow function calls without parenthesised arguments, and these typically use the first as a fixed syntax for function application (in combination with currying), and at least one (Perl) that uses a - shall we call it ""heuristic"" - mix: if the function name is followed by an opening parenthesis, only the parenthesised expression is taken to be its argument, otherwise as many arguments as needed are taken, possibly the rest of the expression.",0.06875,Perl
1512nfo,,Or something like that - with Perl you can't always be sure.,0.5,Perl
1512nfo,,"If A = B = C, for example ℝ, then it's just a ""plain old"" multiplication, but if A is ℝ and B and C are vector or matrix types, then it is scalar multiplication, and if A is a function type, then it is application of a function B→C, unless B is a function type also, in which case it is function composition.",-0.057142857142857134,C
1512nfo,js6n3dd,"You just take any function `foo: (A, B) -> C` and overload the function application operator for `A` with parameter type `B` as `foo(a, b)`.",-0.75,C
1512nfo,js6n3dd,"If you don't care about being too general, and just want to compose functions of type `A -> B` and `B -> C` for `A`, `B`, and `C` being fixed types, you can create dummy types for `A -> B` and `B -> C` and overload their function application operators as above.",0.05000000000000001,C
1512nfo,js6n3dd,"For the more general case of `A`, `B`, and `C` being arbitrary, I believe the language needs a higher level of polymorphism than the simple scheme above.",0.11666666666666668,C
1512nfo,js6zwws,"And if you disambiguate with parenthesises (because TIL people write `sin` without parenthesises), you get `(sin a) (cos b) + (cos a) (sin b)` where all you need is to implement function semantics for those such that `((n : ℝ) : ℝ -> ℝ) = n × _` (there's some typeclass magic you can use to achieve that in Haskell).",0.25,Haskell
1512nfo,js779up,"> and at least one (Perl) that uses a - shall we call it ""heuristic"" - mix: if the function name is followed by an opening parenthesis, only the parenthesised expression is taken to be its argument, otherwise as many arguments as needed are taken, possibly the rest of the expression.",0.05,Perl
1512nfo,js779up,Or something like that - with Perl you can't always be sure.,0.5,Perl
1512nfo,js7btbm,"The CST will then contain ""juxt"" nodes like:      ""sin a cos b"" →     {kind: ""juxt"", children: [         { kind: ""name"", symbol: ""sin"", type: ""R→R"" },         { kind: ""name"", symbol: ""a"", type: ""R"" },         { kind: ""name"", symbol: ""cos"", type: ""R→R"" },         { kind: ""name"", symbol: ""b"", type: ""R"" } ] }          and ""sin k t"" →     { kind: ""juxt"", children: [         { kind: ""name"", symbol: ""sin"", type: ""R→R"" },         { kind: ""name"", symbol: ""k"", type: ""R"" },         { kind: ""name"", symbol: ""t"", type: ""R"" } ] }  Now suppose we want the rule that ""plain implicit multiplication"" of two values of the same type A, giving a value also of type A, must result in calling the function `mulAAA:A×A→A`.",0.2835164835164835,R
1512nfo,js7hpdi,The fact that juxtaposition was an operator suggested you code have Ruby like power to make DSL’s too.,0.0,Ruby
1512nfo,js7r3sf,"Given your choice of syntax for your example, I guess you are a Haskell programmer.",0.0,Haskell
1512nfo,js7r3sf,"I apologise for never having been able to figure out Haskell (and admittedly, I haven't tried *too* hard), but I am sure that Haskell programmers may have some interesting insights to share on this.",0.3020833333333333,Haskell
1512nfo,js7tots,":-) I have used Perl5 quite a lot in the past (ca 1994-20-something - had it not been for Perl5 and MacPerl, I'd probably have chosen Python back then).",0.08333333333333333,Python
1512nfo,js9rmlp,"C cheats by having its grammar depend on semantic analysis, because of the `(a)*b` ambiguity.",0.0,C
1512nfo,js9rmlp,"'""'{n} codepoint* '""'{n}` (C#'s and friends shouldn't be too dissimilar I would think, unless they define this rule in plain English), which I guess you can (ab)use to introduce complex states in a parser rule.",-0.1714285714285714,C
1512nfo,jsawn5d,"Absolutely, even a ""puritan"" language like Pascal has to ""cheat"" to distinguish between assignment and procedure call, IIRC.",0.2,Pascal
1512nfo,js9ey1u,"Let D = A×B, then its f:D→C.",0.0,D
1512nfo,js9ey1u,":-)  Forgive me for saying this, and it is not personal, but I think that if there is one thing I find annoying with Haskell, it is the way some Haskell users casually present concepts from Haskell as if they are the only ""true"" way to view things, which to me is jarring and reductionistic.",0.008333333333333323,Haskell
1512nfo,jsjweab,"I mean I can see at least three different meanings to `x + y / z * w` (PEMDAS with multiplication first, C with division first, and what my mate Benji would expect me to understand and vice-versa with _fraction last_).",-0.018750000000000006,C
1512nfo,js9givt,"Fair point, but Haskell can express both.",0.7,Haskell
1512nfo,jsb04qa,"I suppose this is also a ""problem"" for Haskell, although being side-effect free, maybe not.",0.4,Haskell
15128pq,,This syntax is inspired by and similar to that in Haskell.,0.0,Haskell
15128pq,,So Haskell function call as such becomes a sequence in my language.,0.0,Haskell
15128pq,,Hence ```foo x y``` in Haskell is written as ```foo@ x y``` in my lang.,0.0,Haskell
15128pq,,Hence ```foo x (bar y) (baz z)``` in Haskell is written as ```foo@ x bar@ y; bas@ z``` in my lang.,0.0,Haskell
15128pq,js6jsav,>Hence foo x (bar y) (baz z) in Haskell is written as foo@ x bar@ y; bas@ z in my lang.,0.0,Haskell
15128pq,js7o7da,I was just following Haskell style.,0.0,Haskell
15128pq,jsaz762,"In fact languages like C++, which provide short-circuiting for default logical operators, when they are overloaded, there is no short-circuiting because they lack lazy evaluation.",0.0,C++
150xbp3,jshcb0f,"For example, in Python, lists, sets, and dicts can't be used as keys in a dict and functions that take lists/sets/dicts as arguments can't use the built-in function memoization mechanisms.",0.0,Python
150xbp3,jshcb0f,"One reason I think the Go community demanded generics so vociferously is that the built-in `slice` and `map` types lacked a lot of common functionality, like `sort()`, `reverse()`, `min()`, etc.",-0.3,Go
150xbp3,jskjaow,Elixir has both of these and I love it.,0.5,Elixir
150xbp3,jscj3nk,"The Swift way of `.Variant` is much better, I fully agree.",0.5,Swift
150xbp3,jscj3nk,Rust's requirement for giving the explicit path (or using a local import) just causes line noise for no tangible benefit (at least in my experience).,-0.15,Rust
150xbp3,jsfzvay,[Higher Kinded Types in Haskell](https://serokell.io/blog/kinds-and-hkts-in-haskell)  [Higher Kinded Types in Scala](https://www.baeldung.com/scala/higher-kinded-types),0.25,Haskell
150xbp3,jsfzvay,[Higher Kinded Types in Haskell](https://serokell.io/blog/kinds-and-hkts-in-haskell)  [Higher Kinded Types in Scala](https://www.baeldung.com/scala/higher-kinded-types),0.25,Scala
150xbp3,jsfxvq5,"In Haskell, this exact functionality is given by the `Functor` type class:  ```haskell class Functor f where   fmap :: (a -> b) -> (f a -> f b) ```  Which is then used as:  ```haskell showInts :: (Functor f) => f Int -> f String showInts = fmap show ```  Here we say `f` is ""something that looks like a generic collection"".",-0.3125,Haskell
150xbp3,jsfxvq5,"It would be like if in C# you could have an interface be specified something like:  ```csharp interface ICollection1 where this<TElem> {   this<TRes> FMap<TRes>(Func<TElem, TRes> f); } ```  whereby the interface `ICollection1` can only be implemented for types that take a generic argument to begin with.",0.0,C
150xbp3,jsfxvq5,"The only two languages I know of that elegantly support higher order generics, is Haskell and Scala.",0.25,Haskell
150xbp3,jsfxvq5,"The only two languages I know of that elegantly support higher order generics, is Haskell and Scala.",0.25,Scala
150xbp3,jshe5zb,I think C++ has that.,0.0,C++
150xbp3,jshgms3,C++ has enough jank that everything is possible but nothing is easy.,0.14444444444444446,C++
150xbp3,jshgms3,Haskell has higher order generics with enough discipline and ergonomics that large parts of the standard library are built around it.,0.11607142857142858,Haskell
150uorm,,"I was just playing around with CPP, making a general macro file called `makaronidefs.h` as I had done prior with [MangoMacs](https://gist.github.com/Chubek/bc96fc7cff2d90cb255ccd973c5ca9e8) but MangoMacs was for Assembly and I wanted something for cross-compiler C. That is besides the point.",0.02500000000000001,Assembly
150uorm,,"So I thought to myself, what if I use CPP on Python, I wrote this [shell](https://pastebin.com/6uYJNbe7), I call her Shelly Duval because she's terrified and does not poll for some reason.",0.0,Python
150uorm,,I will be writing it in C because I also wanna learn cross-platform systems programming and I have been looking for a hook.,0.0,C
150uorm,js5c29k,Do you mean text preprocessor like the one in C / C++ ?,-0.3125,C
150uorm,js5c29k,Do you mean text preprocessor like the one in C / C++ ?,-0.3125,C++
150uorm,js5c29k,"In the GNU C preprocessor , you need to check the source code directly.",0.1,C
150uorm,js5c29k,"I started a C / C++ preprocessor alike tool, some time ago, used two small grammars, one for the tokens and lexer, another for the syntax rules and parsers.",-0.25,C
150uorm,js5c29k,"I started a C / C++ preprocessor alike tool, some time ago, used two small grammars, one for the tokens and lexer, another for the syntax rules and parsers.",-0.25,C++
150ovi7,,"For example, if we say JavaScript is a TC language, that will make the lexer for JS an oracle for `TMjs` right?",0.2857142857142857,JavaScript
150ovi7,js5b5re,"Since checking whether a string is a member of the language called JavaScript takes more than one step, it's not done by an oracle.",0.5,JavaScript
150fsjk,js40vnh,Lua developers have invented a technique for version 5.x to capture variables implicitly even with a single-pass compiler.,0.0,Lua
150fsjk,js40vnh,"Umka's main design principle is *Explicit is better than implicit*, taken from the Python Zen.",0.3333333333333333,Python
150fsjk,js40vnh,"I cannot say I understand how it applies to Python (which is too *implicit* for me), but to Umka it applies quite literally.",0.0,Python
150fsjk,jschgnb,"So the main design goal was to have a statically typed language with an interpreter as small as Lua, Squirrel or Wren.",-0.04166666666666667,Lua
150er0h,,"An easy way to speed it up is to use an optimising compiler (which for me means transpiling to C and using `gcc-O3`), which might improve things by up to 40%.",0.43333333333333335,C
150er0h,,"For a production compiler, fine, but I also no longer have the C transpiler anyway; I prefer to go it alone.",0.4166666666666667,C
150er0h,,(Note that 50% of Tiny C's speed is thanks to being compiled with something better than Tiny C!),0.175,C
150er0h,js4lhi0,Many languages especially C still seem fixated on 32-bit integers.,0.25,C
150er0h,jsax8kz,"When this compiler *was* optimised, via transpilation to C, performance when building large inputs improved up to 40%.",0.21428571428571427,C
1507h3a,js3hk3w,Do you have any notes on how it compares to similar languages like Lua or Lily?,0.0,Lua
1507h3a,js7k5qg,"I really like [Ruby Koans](https://www.rubykoans.com/) as a way to get introduced to a language, so I wrote a similar interactive tutorial for two of my past language projects.",-0.016666666666666663,Ruby
1507h3a,js3kcmz,"I haven't used lua in something like 10 years, but my C API for Toy's interpreter resembles it somewhat, or at least has analogues.",-0.3,C
1504ozy,js3oazn,"Languages like Lisp typically use a reader, and languages like  Forth have a compilation mode that doesn't do anything like parse/lex  (dt, for example, also does not need or want a traditional lexer or parser)  Also this is usually about the early stages of a language, which makes a lot of sense for a new language guide.",-0.03606060606060606,Lisp
1504ozy,js3oazn,"Languages like Lisp typically use a reader, and languages like  Forth have a compilation mode that doesn't do anything like parse/lex  (dt, for example, also does not need or want a traditional lexer or parser)  Also this is usually about the early stages of a language, which makes a lot of sense for a new language guide.",-0.03606060606060606,Forth
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,Python
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,Go
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,C
14zwh6r,,"Kind of the area of systems administrators and linux distro maintainers and enthusiasts, where very obfuscated AWK, Perl, Python, and others live, but aiming for a more accessible syntax.",0.3622727272727273,Perl
14zwh6r,,"Kind of the area of systems administrators and linux distro maintainers and enthusiasts, where very obfuscated AWK, Perl, Python, and others live, but aiming for a more accessible syntax.",0.3622727272727273,Python
14zwh6r,,"Early versions waffled between languages, I settled on Rust for a while, then renamed it and re-implemented in Zig with some improvements to the approach.",0.1,Rust
14zoylt,jrz8f99,Haskell uses a newtype keyword.,0.0,Haskell
14zoylt,jrz8f99,"In Ada, they are called derived types and are written like: `type Derived is new BaseType;` while type aliases are called subtypes and omit the `new` keyword (e.g.",0.13636363636363635,Ada
14zoylt,jrzaohf,"For example, in Rust, structs can be written with named fields, but also as tuple structs, which work really well for types that just wrap a single other type:      // named fields     struct MyNewtype {         wrapped: PredefinedType     }      // tuple struct     struct MyNewType(PredefinedType)  The compiler knows that `MyNewType` is identical to `PredefinedType`, so they optimise the same, but they can't be used the same any more — you can't pass a `MyNewType` to a place that's expecting a `PredefinedType`, and vice versa.",0.08392857142857142,Rust
14zoylt,jrz852z,Haskell uses `newtype` which is a zero-cost abstraction.,0.0,Haskell
14zoylt,js2azgo,D uses [`Typedef`](https://dlang.org/library/std/typecons/typedef.html).,0.0,D
14zoylt,jsbj2uu,I have called this [strong typing](https://en.wikipedia.org/wiki/Strong_and_weak_typing) but this may just be influence from a old lint program which added strong typing to C++.,0.3222222222222222,C++
14zoylt,jrzma68,In a plain C alike:      struct PointA     {         int X;         int Y;     } ;           struct PointB     {         int X;         int Y;     } ;        Should be considered two different types.,-0.10714285714285714,C
14znygr,,"I know about Oberon and Turbo Pascal, which were famous for their fast compilation speed, but I was curious about more current research.",0.22000000000000003,Pascal
14znygr,js1rfbr,The DMD compiler for D is pretty fast.,0.225,D
14znygr,jrzcnmw,"Note that Tcc's speed depends in part in being built (as a C application) using `gcc -O3`, or via some optimising compiler.",0.0,C
14znygr,jrzcnmw,Transpiling to C and using `gcc-O3` would give a boost of 30-40%.,0.0,C
14znygr,jrzuys5,I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,C++
14znygr,jrzilr5,"This is Hapran Xu's proof of concept about creating a multi tier JIT compiler for Lua other than LuaJIT, which is already a work of art.",-0.125,Lua
14znygr,js07ob0,I'd call Go's speed 'healthy'.,0.5,Go
14znygr,js07ob0,The tests I did a few years ago (on a slower machine) put Go's lines-per-second rate in the high 5-figures; the faster ones were well into 6 figures.,-0.020000000000000004,Go
14znygr,js07ob0,"But sometimes all you want to do is turn a bunch of source code into executable code as quickly as possible, and so long as it does a reasonable job, I don't care,  C is commonly used as a target language, so the code has already been verified; in this case you don't need complex analysis.",-0.09,C
14znygr,jrzxese,> I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,C++
14znygr,jrzzymg,"Because, even on my machine, which is not that fast, a fast compiler like Tiny C can generate executable code at up to 10MB per second (so 7 minutes doing that would produce a 4GB executable, although it would probably run out of memory long before).",0.07,C
14znygr,jrzzymg,"Regarding C code, people don't mind faster compilers, but from innumerable threads about this in various forums, they are unwilling or unable to move away from mainstream but slow compilers like `gcc`, and switch to `tcc`, which can be 20 times faster than even `gcc-O0`.",-0.26666666666666666,C
14znygr,jrzzymg,"From your comments it sounds like you are using C++, which has various features not conducive to fast compilation.",0.1,C++
14znygr,js1umyf,"It's different from ones like C, in only supporting one target at a time.",0.08333333333333333,C
14znygr,js1umyf,"It can be made to work on ARM and Linux via intermediate C, but I'm pulling support on that.",0.0,C
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,Pascal
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,Fortran
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,Ada
14znygr,js4ok0x,"Wirth actually worked on Algol68, before he left to create Pascal (via Algol W maybe?)",0.0,Pascal
14znygr,js4ok0x,It filled that role far better than Algol68 *or* Pascal!,0.375,Pascal
14znygr,juc4cqg,"I mean, they are not terrible: here I compare Clang/LLVM, run via `Zig CC` as that is the only way I can get it to work on Windows, with my compilers, on a 40Kloc C input:      Compiler        Input   Opt  Build Time   Runtime          Zig cc -O0      qc.c    -O0   2 secs      5.8** secs     Zig cc -O3      qc.c    -O3  10           4.6     bcc             qc.c    --    0.18        5.8     mm              qc.m    --    0.1         5.5  `bcc` is my C compiler, which itself is not optimised, and is further handicapped by needing an ASM stage.",0.046875,C
14znygr,js3obdq,Also: C&P is seriously impressive.,1.0,C
14znygr,js3obdq,Using C++ templates and linker relocations to create and specialize these stencils is pretty mind-bending!,0.3125,C++
14znygr,juc5hw7,Llvm does actually do 260 passes by default in Rust.,0.0,Rust
14ytm57,,"And defining a fluid Rust or JS-like chainable API is easy to write and think about I think, but perhaps declarative state is ""better""?",0.3111111111111111,Rust
14ytm57,jrxspmx,many configuration APIs in TypeScript have fields that can only be specified in tandem or not at all.,0.25,TypeScript
14ytm57,jrxspmx,"Rust and other affine type systems can do this, but it's difficult and causes a combinatorial explosion of types.",-0.3125,Rust
14yacuw,jrschae,"I just think it is a pity that even when a language like C allows all letterlike Unicode codepoints in identifiers, the standards committee forgets to add ""×"" and ""·"" as multiplication symbols synonymous to ""\*"", or even better only for multiplication, not pointer dereferencing, which would still be absolutely trivial.",0.15000000000000002,C
14yacuw,jrschae,"The curly braces, for those of us who still remember mathematics before we learned C or Perl or one of the many other languages that overloads them with several meanings, are mainly used for set notation, as set descriptors or set builders.",0.13541666666666666,C
14yacuw,jrschae,"The curly braces, for those of us who still remember mathematics before we learned C or Perl or one of the many other languages that overloads them with several meanings, are mainly used for set notation, as set descriptors or set builders.",0.13541666666666666,Perl
14yacuw,jrwvvr6,"Then αβ may mean many different things, depending on A and B. even worse, let's introduce γ of type C and the expressions: (αβ)γ, α(βγ), and αβγ.",-0.1925,C
14yacuw,jrwvvr6,"There actually is precedent for that in programming languages: In Perl, a function can have an unparenthesised comma-separated argument list, but if the first expression after the function name is parentheses, then it is assumed to contain all arguments to the function.",0.125,Perl
14yacuw,jrwvvr6,"But this means that interpreting αβγ correctly as (αβ)γ or α(βγ) not only depends on the type of A, B and C, but also of whether the expressions are parentheses or not.",0.0,C
14yacuw,jrx6ck1,"Fortran and Ada use the same syntax for both, although both use round brackets for the purpose.",-0.1,Fortran
14yacuw,jrx6ck1,"Fortran and Ada use the same syntax for both, although both use round brackets for the purpose.",-0.1,Ada
14yacuw,jrx6ck1,Ada I think specifically wanted to blur the distinction between the two.,0.0,Ada
14yacuw,jt6o09q,"Yes, we also have those under the name ""generics"" or Haskell name them type variables.",0.0,Haskell
14yacuw,jsapg83,"Haskell treats type parameter application syntactically the same as function application (both with space as the operator char), though it doesn't have syntactic sugar form of array indexing, array element value get is a vanilla infix operator `!`, as in `a !",0.0,Haskell
14yacuw,jru65jt,"(And this would not be worse than many other languages' conventions/heuristics for ""semicolon insertion"": JavaScript, Go, ...)",-0.00833333333333334,JavaScript
14yacuw,jru65jt,"(And this would not be worse than many other languages' conventions/heuristics for ""semicolon insertion"": JavaScript, Go, ...)",-0.00833333333333334,Go
14yacuw,jrwy1vm,For example Haskell.,0.0,Haskell
14xy759,,"So far I think [Rust](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html) has the best error messages in the terminal, where it draws red lines using `^` or `~` with arrows and descriptions inline with the code.",0.3666666666666667,Rust
14xy759,,It appears Rust drew inspiration from [Elm](https://elm-lang.org/news/compiler-errors-for-humans) for error styles.,0.0,Rust
14xy759,,It appears Rust drew inspiration from [Elm](https://elm-lang.org/news/compiler-errors-for-humans) for error styles.,0.0,Elm
14xy759,jrq26ho,Maybe Rust has few implementations so it's easy to get those mixed up (unless such things are baked into the language specification; I don't know).,0.058333333333333334,Rust
14xy759,jrq26ho,"C on the other hand has loads, of which one of the most interesting is Clang's when running on Windows.",0.2916666666666667,C
14xy759,jrq2tu2,Iirc I heard praises for Elixir or was it Elm?,0.0,Elixir
14xy759,jrq2tu2,Iirc I heard praises for Elixir or was it Elm?,0.0,Elm
14xy759,jrqdfwq,Coalton drew inspiration from Rust & Elm.,0.0,Rust
14xy759,jrqdfwq,Coalton drew inspiration from Rust & Elm.,0.0,Elm
14xy759,jrpt5f8,There is also another notable Rust error rendering lib: [ariadne](https://github.com/zesterer/ariadne).,-0.125,Rust
14xy759,jrpt5f8,"So you can get the same beautiful error rendering in your own projects :D  Also, just to be clear, `rustc` uses it's own internal lib for error rendering.",0.45000000000000007,D
14xy759,jrssh0z,"Rust's tooling is heavily standardized by the language — compiler (`rustc`), package manager, auto doc generator, formatter, linter, etc, and they are all available with the tool `cargo` that one installs through the typical installation.",0.011111111111111118,Rust
14xy759,jrssh0z,"Having multiple implementations of the Rust compiler is generally not sought after as well, so it's accurate to think of `rustc`'s diagnostics as the language's own diagnostics.",0.24375000000000002,Rust
14xy759,jrssh0z,"It's also worth noting that since Rust's compilation model is relatively strict, much of the compiler diagnostics are essential feedback, especially while learning the language — hence the UX choices made.",0.1,Rust
14xy759,jrqyel7,Probably Elm - its error messages are quite good,0.7,Elm
14xuna4,jrph9w1,"I don't know about LLVM IR specifically, but I had difficulty converting C# IL to WASM because it used goto statements instead of loops.",0.0,C
14xuna4,jrqsduk,GHC (Haskell) does short cut fusion based on a set of rewrite rules like `map g .,0.0,Haskell
14xuna4,js4ktkm,"You may think of LLVM as being at a similar level to C, with perhaps some more detailed information.",0.3,C
14xuna4,jrptkfu,"I am currently experimenting with function inlining in JavaScript, and I'm unsure how to handle multiple returns in a function.",0.0,JavaScript
14xuna4,js7xcl7,"The Rust compiler has two AST-ish levels, I believe.",0.0,Rust
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,Lisp
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,C
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,Lua
14xms09,,"Thus this is not an issue:      let f1 = function f do         let x = 10         invoke f     end          let f2 = function do         let x = 20         let inner-fn = function do             print x # Will print '20', not '10'         end     end  ('invoke' is a function can be used to call functions taking no arguments)  The interpreter is written in C (C99), and the core interpreter (not counting any libraries) is just around 1k lines of code, and can be embedded by compiling it to a library and including the interpreter.h header.",0.0,C
14xms09,,It is possible both to call Beryl functions from C and C functions from Beryl.,0.0,C
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,TypeScript
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,Haskell
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,Rust
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,C++
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,C++
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,Java
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,C
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,Scala
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,Kotlin
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,TypeScript
14xmlma,jro34g9,This is part of why C++ is famously so slow to compile and leads to such large codesize.,-0.02857142857142859,C++
14xmlma,jro34g9,This is why it can be such a challenge to maintain and use third-party C++ libraries that use a lot of templates.,0.0,C++
14xmlma,jro34g9,This is even worse in C++ because of overloading and [SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error).,-0.4,C++
14xmlma,jro34g9,"In C++, if a call fails (i.e.",-0.5,C++
14xmlma,jro34g9,(I guess that makes C++ templates more like a logic language?),0.5,C++
14xmlma,jro34g9,This is why compile errors from templates in C++ are hell.,0.0,C++
14xmlma,jro34g9,"Java generics were very successful, so many languages since then went down a similar (but not identical) path.",0.3298611111111111,Java
14xmlma,jrojr67,Note that GADTs can't work in an approach like C++ templates.,0.0,C++
14xmlma,jrojr67,GADTs _could_ work in Rust if Rust allowed erasing some of the generic types; otherwise it also won't work.,0.0,Rust
14xmlma,jrojr67,C++ already supports template template parameters.,0.0,C++
14xmlma,jrotsua,"> I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages  Check out [D](https://dlang.org).",-0.022222222222222237,C++
14xmlma,jrotsua,"> I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages  Check out [D](https://dlang.org).",-0.022222222222222237,D
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,Ruby
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,Python
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,PHP
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,D
14xmlma,jrotsua,"In fact, [Design-By-Introspection](https://www.youtube.com/watch?v=HdzwvY8Mo-w) is a core tenet of D doctrine.",0.0,D
14xmlma,jrotsua,"If I knew more about Lisp, I'd have posted a Lisp metaprogramme that typechecks itself AOT.",0.5,Lisp
14xmlma,jrovxh2,"If List<T> is covariant (eg because it’s a read-only data type), and your language has subtyping and variance (like Java or TypeScript), saying a variable has type List<T> means it will hold a List or some subtype of List, each element of which is of type T or a subtype of T.  And the different elements can have different types (heterogeneity).",0.0,Java
14xmlma,jrovxh2,"If List<T> is covariant (eg because it’s a read-only data type), and your language has subtyping and variance (like Java or TypeScript), saying a variable has type List<T> means it will hold a List or some subtype of List, each element of which is of type T or a subtype of T.  And the different elements can have different types (heterogeneity).",0.0,TypeScript
14xmlma,jrpg2cf,There is also the in-development language [Hackett](https://github.com/lexi-lambda/hackett) which uses the approach described in the paper to unify Racket style macros with a Haskell style type system.,0.0,Haskell
14xmlma,jro6tff,I think Rust generics are much more like C++ templates than you realise.,0.5,Rust
14xmlma,jro6tff,I think Rust generics are much more like C++ templates than you realise.,0.5,C++
14xmlma,jro6tff,"The compiler will generate different instances of Container for each type parameter, just as C++ will.",0.0,C++
14xmlma,jro84cz,"For custom types Rust - like many others - uses a kind of ""sublanguage"" that is processed during compilation to elaborate the type system.",0.5333333333333333,Rust
14xmlma,jro84cz,"On the opposite side, Zig has a novel approach: instead of using a separate syntax to define types, the constructor is an actual Zig function (evaluated at comptime):  ``` fn Vec(comptime T: type) type {     return struct {         buf: []T,         len: usize,          // methods...     }; } ```  While it may seem that we are breaking some kind of academic barrier by executing code to create types, in the end the result is identical to the Rust example: a builtin type constructor (the `struct`) parametrized by a type value.",-0.030000000000000006,Rust
14xmlma,jro84cz,"Rust just uses a special syntax to describe it, but it's a comptime computation all the same.",0.17857142857142858,Rust
14xmlma,jro84cz,"There are practical differences: by having a more restricted syntax/semantics for the type system (like Rust does) you get the benefit of error messages that are naturally simpler to understand; plus, Rust generics cannot loop forever (afaik).",0.3,Rust
14xmlma,jrnteuv,It's more like an arrow (as understood in Haskell).,0.5,Haskell
14xmlma,jroimbo,"That Zig in particular does not do it (nor do dynamic C++ templates for that matter), is a detail of that particular implementation.",0.1111111111111111,C++
14xmlma,jroimbo,"Nowadays with its `concept`s, even C++ supports this.",0.0,C++
14xmlma,jrom2ol,This is not fully true anymore: C++'s `concept`s allow to constrain type arguments.,0.35,C++
14xmlma,jrom2ol,In fact D's entire metaprogramming doctrine relies on CTFE to typecheck type arguments (eg.,0.0,D
14xmlma,jrom2ol,"eg: `Additive = { a ∈ Type | ∀(x ∈ a, y ∈ a): x + y }`   or in C++:      template<typename a>     concept Additive = requires(a x, a y) { x + y; };",0.0,C++
14xmlma,jrocse6,"From a code generation perspective, they're the same, but from a type checking perspective, they're two different ends of a spectrum, with C++ on the now-disfavored ""compile time dynamic typing"" end.",0.0,C++
14xmlma,jro9pl3,"Using Rust and Zig as examples: the first models mathematical functions with programming functions and type arrows with generics; Zig, on the other hand, decides that its functions are a good enough model for both mathematical functions and type arrows.",0.13749999999999998,Rust
14xmlma,jrosuli,"This is a common issues with C++ templates, for example:      template <typename F, typename... Args>     auto invoke(F fun, Args&&... args) {         auto result = fun(std::forward<Args>(args)...);          return result;     }  This looks perfectly reasonable.",0.06666666666666667,C++
14xmlma,jroi5in,"You don't need Dependent Typing: type constraints, including C++'s concepts, can be modelled after Refinement Types alone, though they of course are less general.",-0.05833333333333332,C++
14xmlma,jropcwi,"You can achieve both in a single language with either a reflective interface and CTFE (as in D, `void f(T)(T x) if(typeid(T).whatever)`), or with types as first-class values, as in      double (x: 'a) if (isAdditive 'a) = x + x  Refinement (or Dependent) Types can achieve the same thing, and simplifies type signatures:      Additive = { a ∈ Type | ∀(x ∈ a, y ∈ a).",-0.023809523809523808,D
14xmlma,jro0mdn,"\*The name ""arrow"" comes from the Category Theory, but the way I use it is a bit more pragmatic, more related to Haskell's typeclass inspired by the mentioned theoretical concept",0.25,Haskell
14wxw2c,jrpvwo8,"I don't know about Rust, but GHC has numerous fancy features that require constraints.",0.0,Rust
14wxw2c,jrpvwo8,Already in the surface language in GHC Haskell we can write type [equality constraints](https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/equality_constraints.html).,0.0,Haskell
14wwl1h,jrldr9n,Nope - It's just a big image for now :D,0.5,D
14wu604,jrn30rp,What is the Scala influence on Vale?,0.0,Scala
14wu604,jrjy1bv,"I'm hoping that by combining them with generational references we can finally make our programs as fast as Rust or as flexible as Java or wherever we want in-between (we need a term for this, perhaps gradual optimization?)",0.1,Rust
14wu604,jrjy1bv,"I'm hoping that by combining them with generational references we can finally make our programs as fast as Rust or as flexible as Java or wherever we want in-between (we need a term for this, perhaps gradual optimization?)",0.1,Java
14wu604,jrp2exs,Vale has a general rule that a function or struct needs to be marked `exported` to be visible to C or the OS.,0.07500000000000001,C
14vvgnw,jrf6ewn,"I would argue this makes your automata objects, and thus your language OOP, though in a different sense from Java.",0.0,Java
14vvgnw,jrhc2oi,Cell program gets compiled literally into Java or C# code.,0.0,Java
14vvgnw,jrhc2oi,Cell program gets compiled literally into Java or C# code.,0.0,C
14vvgnw,jrhc2oi,Are they saying the Java code compiled from Cell is 2-3 times faster and less memory intensive than an “equivalent Java program”?,-0.16666666666666666,Java
14vvgnw,jrhc2oi,That simply sound like they are comparing to a terribly written Java program.,-0.3,Java
14vvgnw,jrhc2oi,Or are they using the Cell to C++ the compiler?,0.0,C++
14vvgnw,jrhc2oi,Anything is 2-3 times faster and use less memory in C++ compared to Java.,-0.16666666666666666,C++
14vvgnw,jrhc2oi,Anything is 2-3 times faster and use less memory in C++ compared to Java.,-0.16666666666666666,Java
14vvgnw,jrf2lg0,Java is faster than c#?,0.0,Java
14vvgnw,jrivdfp,"In this regards, they're more like messages in the actor paradigm (Erlang), but automata are not actors either, because actors have their own thread of execution while automata are ""passive"" entities, just jike objects in OOP.",0.55,Erlang
14vvgnw,jrhkjyy,"You could call that a terrible Java implementation, but it might be the Java implementation many developers would write.",-0.25,Java
14vvgnw,jrhkjyy,Most Java developers are not thinking about data oriented design and cace locality.,0.5,Java
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,C++
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,Java
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,C
14vvgnw,jrimmwg,"The performance results shown on the website are for the C++ code generator, which is obviously the fastest of the three.",0.0,C++
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,Java
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,C++
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,Python
14vvgnw,jrimmwg,"The thing is, the kind of code that even a very good compiler/transpiler would generate when compiling any higher-level language to C++ is not the same as manually written C++ code.",0.5033333333333333,C++
14vvgnw,jrimmwg,"The Java and C# code it's compared to are written in an OOP style, and I think this is stated clearly in the article and the benchmark page.",0.10000000000000002,Java
14vvgnw,jrimmwg,"The Java and C# code it's compared to are written in an OOP style, and I think this is stated clearly in the article and the benchmark page.",0.10000000000000002,C
14vvgnw,jrimmwg,"You can certainly squeeze better performance from Java by ditching OOP altogether and using data oriented programming techniques, or the ECS architecture, but that's certainly not the kind of programming style Java was designed around, and it definitely takes an extra effort on the part of the programmer to do so.",0.20119047619047623,Java
14vvgnw,jrimmwg,"And note that the title of the post is ""Why functional relational programming is faster than **OOP**"", not ""Why functional relational programming is faster than Java when the latter is used with the lowest-level programming style possible"".",0.0,Java
14vvgnw,jrimmwg,"Although I'm not sure the latter is not true, I haven't tried but I don't think Java is the ideal implementation language for data oriented design and the ECS architecture.",0.11875000000000001,Java
14vvgnw,jrhcq6s,"C# has some specific advantages in the doesn’t-always-have-to-box area, which Java will match in a year or two with a similar capability.",0.0,C
14vvgnw,jrhcq6s,"C# has some specific advantages in the doesn’t-always-have-to-box area, which Java will match in a year or two with a similar capability.",0.0,Java
14vvgnw,jrhcq6s,Otherwise Java tends to be a bit faster with long running applications.,-0.05,Java
14vvgnw,jrinedu,"The hand-written Java code used in the comparison is indeed written in an OOP style, but why do you think that's a terrible implementation?",-1.0,Java
14vvgnw,jrinedu,Isn't that the natural  thing to do when programming in Java?,0.1,Java
14vvgnw,jrinedu,When Java was first released (in 1995) OOP was all the rage and nobody was even talking about data oriented design and the Entity/Component/System architecture.,0.25,Java
14vvgnw,jrhlk79,"This looks to have more details:  https://www.cell-lang.net/benchmarks-relational.html  Based on that page, they are comparing to the Cell via C++.",0.5,C++
14vvgnw,jrhlk79,"That said, towards the bottom they have a comparison of Vell embedded in Java to Cell via C++.",0.0,Java
14vvgnw,jrhlk79,"That said, towards the bottom they have a comparison of Vell embedded in Java to Cell via C++.",0.0,C++
14vvgnw,jrhlk79,Generally speaking the java version looks to be about 6% slower than the C++ version specifically for the CSV test (though it can be much slower than that for specific examples).,0.08333333333333333,C++
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,Java
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,C++
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,Java
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,C++
14vvgnw,jripx0m,The thing that stops you from doing it and the reason people use Java the first place is the platform agnostic property of JVM.,0.25,Java
14vvgnw,jripx0m,"Python or JS cannot be easily complied to C++ because they are interpretative; I don’t know any good way it can be done, and if someone manage to create a good compiler many will be using it.",0.5833333333333333,Python
14vvgnw,jripx0m,"Python or JS cannot be easily complied to C++ because they are interpretative; I don’t know any good way it can be done, and if someone manage to create a good compiler many will be using it.",0.5833333333333333,C++
14vvgnw,jrosmiv,It seems to matter how the programs are written ;-)  Do the fastest C# programs use hand-written vector instructions?,0.25,C
14vvgnw,jrh45ei,Edit: The Rust Book has a fairly decent quick discussion of the different stances: https://doc.rust-lang.org/book/ch17-01-what-is-oo.html,0.16666666666666666,Rust
14vvgnw,jrh4clv,"I recently learned that Erlang evidently doesn't formally comply to the original idea, and was like wait what?",0.20833333333333334,Erlang
14vvgnw,jrhnh9s,Being in a language like Java doesn't mean you need to use tons of OOP features.,-0.3125,Java
14vvgnw,jrip26t,"No, the difference in performance between the generated C++ and Java code is much larger than that.",0.0,C++
14vvgnw,jrip26t,"No, the difference in performance between the generated C++ and Java code is much larger than that.",0.0,Java
14vvgnw,jrip26t,Java makes a terrible compilation target for a language like Cell.,-1.0,Java
14vvgnw,jrip26t,"The generated Java code is still competitive with hand-written OO Java code, sometimes faster, sometimes slower, but trying to compile Cell into Java (or C#) code in like trying to fit a round peg in a square hole.",0.1,Java
14vvgnw,jrip26t,"The generated Java code is still competitive with hand-written OO Java code, sometimes faster, sometimes slower, but trying to compile Cell into Java (or C#) code in like trying to fit a round peg in a square hole.",0.1,C
14vvgnw,jrip26t,The C++ code generator is more recent and has been redesigned from the ground up to achieve better performance.,0.3333333333333333,C++
14vvgnw,jrip26t,At least some of that work could be backported to the Java version.,-0.3,Java
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,C++
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,Java
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,C
14vvgnw,jrndlwg,"As for Go being significantly faster than Java, I just looked at ***The Computer Language Benchmarks Game***, and that doesn't seem to be the case: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html).",-0.25833333333333336,Go
14vvgnw,jrndlwg,"As for Go being significantly faster than Java, I just looked at ***The Computer Language Benchmarks Game***, and that doesn't seem to be the case: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html).",-0.25833333333333336,Java
14vvgnw,jrndlwg,"Go seems to be slightly faster than Java in most (but not all tests), but the difference is really minimal.",0.07777777777777779,Go
14vvgnw,jrndlwg,"Go seems to be slightly faster than Java in most (but not all tests), but the difference is really minimal.",0.07777777777777779,Java
14vvgnw,jrndlwg,"Although Go seems to have improved lately, the last time I checked (a few years ago) Java was clearly faster, and I've to admit I wasn't aware of Go's improvements.",-0.029999999999999992,Go
14vvgnw,jrndlwg,"Although Go seems to have improved lately, the last time I checked (a few years ago) Java was clearly faster, and I've to admit I wasn't aware of Go's improvements.",-0.029999999999999992,Java
14vvgnw,jrndlwg,"But now I'm curious, I'm going to rewrite the benchmarks in Go and see what happens.",-0.1,Go
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,Go
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,C
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,Java
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,C++
14vvgnw,jrndlwg,"I'm not aware of a tool that can automatically convert, say, non-trivial Java code into equivalent C++ and produce a significant speedup.",0.125,Java
14vvgnw,jrndlwg,"I'm not aware of a tool that can automatically convert, say, non-trivial Java code into equivalent C++ and produce a significant speedup.",0.125,C++
14vvgnw,jrndlwg,"I even tried a couple of native compilers for Java, and they were actually slower than the JVM.",0.0,Java
14vvgnw,jrndlwg,"In the Java and C# version of the benchmark I didn't follow the principle of encapsulation religiously, but only because it was irrelevant to what I was interested in, which is performance.",-0.0625,Java
14vvgnw,jrndlwg,"In the Java and C# version of the benchmark I didn't follow the principle of encapsulation religiously, but only because it was irrelevant to what I was interested in, which is performance.",-0.0625,C
14vvgnw,jrmbpfx,"Erlang processes really are quite similar, from an intuitive perspective, to actors: They represent a distinct thread of control and communicate by asynchronous messages.",0.16666666666666666,Erlang
14vvgnw,jrmbpfx,"First, Erlang apparently has a process registry that lets you look up a PID.",0.15,Erlang
14vvgnw,jrmbpfx,"In principle you could simulate a registry with actor messages, but in Erlang it's part of the semantics.",0.0,Erlang
14vvgnw,jrmbpfx,"Second, Erlang has selective receive, which lets you process messages in the order you care about them and save the rest for later.",0.0,Erlang
14vvgnw,jrmbpfx,"The last difference is that crashing is not one of the three things actors are theoretically allowed to do, which means that Hewitt doesn't define any sort of supervisory tree the way Erlang does.",0.0,Erlang
14vvgnw,jrmbpfx,"On that front, Erlang seems superior for at least thinking about robustness in the face of failure.",0.027777777777777752,Erlang
14vvgnw,jrhq2gg,Most Java programs are not performance critical and most devs rightfully don’t care about speed when weighed against readability and potential for reuse.,0.25,Java
14vvgnw,jrhq2gg,When speed is required though there are many Java programs properly optimized to be fast and have better memory footprint.,0.3,Java
14vvgnw,jrhq2gg,Since the compiler here specially optimize for performance when it generates the code and care not about readability it is only fair to compare with another Java program that is also written to optimize for performance.,0.3523809523809524,Java
14vvgnw,jrnt3xh,You are for sure right that automatic Java to C++ converter has uneven performance.,0.1952380952380952,Java
14vvgnw,jrnt3xh,You are for sure right that automatic Java to C++ converter has uneven performance.,0.1952380952380952,C++
14vvgnw,jrnt3xh,Our own rewrite test on Go was actually even slightly faster than C++ but it could be many factors at play.,0.23333333333333334,Go
14vvgnw,jrnt3xh,Our own rewrite test on Go was actually even slightly faster than C++ but it could be many factors at play.,0.23333333333333334,C++
14vvgnw,jrnt3xh,"It was harder to get devs and libraries are insufficient, so we went for C++ anyways.",-0.1,C++
14vvgnw,jrnt3xh,"Maybe I am biased because I looked at Java and scala before and scala tends to be slightly slower, so I had preformed opinion that was hard to change.",-0.22916666666666669,Java
14vvgnw,jripulv,That sounds like the first definition the Rust Book discusses.,0.25,Rust
14vvgnw,jrjmua8,"So no, that's *not OOP*, not the way Simula, Java and C++ see it.",0.0,Java
14vvgnw,jrjmua8,"So no, that's *not OOP*, not the way Simula, Java and C++ see it.",0.0,C++
14vvgnw,jrjmua8,It just happened that the benefits of this approach are most obvious to people working in C++ - a language that suffered from the OOP craze badly.,-0.06666666666666661,C++
14vvgnw,jrjpx4s,"Sure if you're learning C, then it makes sense to learn about what's happening in memory, but if you're learning a higher level language of a different paradigm, talking about what happens in the machine may undermine their understanding.",0.25,C
14vvgnw,jrpvp8s,"message passing (hence ""what I called 'objects'""), versus the more common modern C++ take of ADTs.",0.13333333333333333,C++
14vm3kw,,"I have played with Rust, Nim, Zig, Go and saw that none of them use classes (they have their own way to define something similar to an interface though).",0.3,Rust
14vm3kw,,"I have played with Rust, Nim, Zig, Go and saw that none of them use classes (they have their own way to define something similar to an interface though).",0.3,Go
14vm3kw,jreyzx5,in TypeScript a class can `implements` another class.,0.0,TypeScript
14vm3kw,jreyzx5,"Rust where any type can implement a trait, in some OOP languages you can't implement interfaces for non-class types - A class is a container for data    - ex.",0.0,Rust
14vm3kw,jreyzx5,"""dataclass"" in Python - A class is a mechanism to protect data from other classes (note: **not** other objects.",-0.03125,Python
14vm3kw,jrevmsn,"Most of the good parts of object-oriented programming can be accomplished or done better with modules, functions as first-class values, and Rust traits (or, better yet, Haskell type classes).",0.48,Rust
14vm3kw,jrevmsn,"Most of the good parts of object-oriented programming can be accomplished or done better with modules, functions as first-class values, and Rust traits (or, better yet, Haskell type classes).",0.48,Haskell
14vm3kw,jrevmsn,"If you care about an interface, use an interface (a Rust trait).",0.0,Rust
14vm3kw,jrgn3dk,When Java added closures (it sort of had something like it already with anonymous inner classes) different ways of composing stuff together other than inheritance became much more palatable.,0.09375,Java
14vm3kw,jrgn3dk,"So my thesis is that closures, dependency injection, design for test, and possibly performance improvements in compilers/run-time for higher order programming may have played a big part on the Java side in the move away from inheritance based abstraction.",0.08333333333333333,Java
14vm3kw,jrgn3dk,I think a similar story may be true for C++.,0.175,C++
14vm3kw,jrgn3dk,"Java debuggers are much better now so maybe single stepping would work for less complex scenarios but if it isn't readable like a book, the code isn't as readable as it could be.",-0.009523809523809504,Java
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,Java
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,C
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,Python
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,JavaScript
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,Ruby
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,TypeScript
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,Kotlin
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,Scala
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,Crystal
14vm3kw,jrqn7d7,"Swift, too, it's only one year older than Rust.",0.08333333333333333,Swift
14vm3kw,jrqn7d7,"Swift, too, it's only one year older than Rust.",0.08333333333333333,Rust
14vm3kw,jrncoii,"That will have a headache, (even though my live is Elixir, and Erlang), if that will be pushed to be used everywhere, I would start to hate it as well.",-0.33181818181818185,Elixir
14vm3kw,jrncoii,"That will have a headache, (even though my live is Elixir, and Erlang), if that will be pushed to be used everywhere, I would start to hate it as well.",-0.33181818181818185,Erlang
14vm3kw,jrf2nx0,Rust has classes.,0.0,Rust
14vm3kw,jricwsa,"When I think about such topics, I always look at how it is with Rust, and I always say: okay, that's the way.",0.25,Rust
14vm3kw,jricwsa,"With Rust, you can define *methods* for your *struct*, so it's basic OOP, encapsulation is supported.",0.0,Rust
14vm3kw,jrnbhq6,"If you take away inheritance than a Java style class is really just a namespace with polymorphism, and parametric polymorphism (ie generics in arguments or functions) is possible without classes.",0.1,Java
14vm3kw,jrgkd6x,In Java Style OOP the only mechanism for reuse and encapsulation is inheritance.,0.0,Java
14vm3kw,jrgkd6x,is that Java’s OOP became popular to a large part due to the relatively easy implementation via virtual function tables.,0.2806547619047619,Java
14vm3kw,jrhionm,Go packages even look like classes.,0.0,Go
14vm3kw,jrhionm,Your knowledge would be a great help  Do what you want but you can't ignore the fact that the vast majority of code in production today is written either in java or C#.,0.4,C
14vm3kw,jrg6e5q,"A notable counter-example would be Kotlin, an OOP language presumably made by people who weren't satisfied with Java.",0.5,Kotlin
14vm3kw,jrg6e5q,"A notable counter-example would be Kotlin, an OOP language presumably made by people who weren't satisfied with Java.",0.5,Java
14vm3kw,jrg6e5q,Although the class-based design of Kotlin is still likely influenced by what is convenient to implement on the JVM.,0.0,Kotlin
14vm3kw,jrhwj1w,people who program in C++ are busy endlessly fighting with templates and implicit behavior.,-0.012499999999999997,C++
14vm3kw,jrhzbr2,A class is a Pascal record type with functions glued on … ?,0.0,Pascal
14vm3kw,jrfgeoy,It reminds me of JavaScript and similar languages where you are/were required to construct your own classes by hand (an extra boilerplate).,0.125,JavaScript
14vm3kw,jrf2kjh,I don't think structures as in Rust are the same as classes in Java except data inheritance.,0.0,Rust
14vm3kw,jrf2kjh,I don't think structures as in Rust are the same as classes in Java except data inheritance.,0.0,Java
14vm3kw,jrf2kjh,"The point of classes is that one is able to tie data and behaviour together, whereas this is the thing Rust is trying to avoid by having strictly separate `struct` and `impl` blocks, which can be located in different files and even crates (through traits).",0.25,Rust
14vm3kw,jrewepg,"From the beginning, I was assuming that Rust doesn't implement OOP because of the lack of classes/inheritance (one of the four pillars of OOP).",0.0,Rust
14vm3kw,jrewepg,For instance Rust have struct and Nim has object as product types (there are also tuples) that can implement stateful struct (Nim has also inheritance now that I remember),0.0,Rust
14vm3kw,jrf1qlb,"> Rust traits (or, better yet, Haskell type classes).",0.5,Rust
14vm3kw,jrf1qlb,"> Rust traits (or, better yet, Haskell type classes).",0.5,Haskell
14vm3kw,jrf1qlb,How would Haskell type classes even work in a non-Haskell language?,0.0,Haskell
14vm3kw,jrqzti4,"I was happy to know by discussing with other redditors there are still languages that implement classes in the classical way (Like Grace, Swift and Crystal you mentioned).",0.225,Swift
14vm3kw,jrqzti4,"I was happy to know by discussing with other redditors there are still languages that implement classes in the classical way (Like Grace, Swift and Crystal you mentioned).",0.225,Crystal
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,TypeScript
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,Scala
14vm3kw,jrh8sjc,> In Java Style OOP the only mechanism for reuse and encapsulation is inheritance.,0.0,Java
14vm3kw,jrglmfv,I also think that Java recieve a big boost throught promotions made to organizations (which facilitate it's adoption).,0.0,Java
14vm3kw,jrih3g3,I saw that CLOS (Common Lisp Object System) don't follow the classical definition of class/hineritance we see in other OO languages.,-0.14166666666666666,Lisp
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Go
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Java
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,C
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,Java
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,C
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,COBOL
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Kotlin
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Go
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Rust
14vm3kw,jrgdwf8,"Not just convenient to implement, but also compatible with the Java ecosystem.",0.0,Java
14vm3kw,jri19oj,"If it requires inheritance in the Java style, i.e.",0.0,Java
14vm3kw,jrfl7du,"In the TypeScript example below, `BThing` is a subtype of `AThing`.",0.0,TypeScript
14vm3kw,jrf9xra,"No matter where the methods are defined in Rust, the behavior is still tied to the underlying data.",0.0,Rust
14vm3kw,jrf9xra,When you write:  ``` dog.bark(); ```  there's no difference between Rust and Java.,0.0,Rust
14vm3kw,jrf9xra,When you write:  ``` dog.bark(); ```  there's no difference between Rust and Java.,0.0,Java
14vm3kw,jrh5zkf,"""Haskell type classes"" are just type classes as implemented in Haskell.",0.0,Haskell
14vm3kw,jrh5zkf,"Type classes can be implemented in other languages such as ML, Scala, or C++20.",-0.0625,Scala
14vm3kw,jrh5zkf,Rust traits specifically don't provide higher kinded types.,0.25,Rust
14vm3kw,jri21l6,"In Java in particular, pretty much anything you can do with inheritance, you can do with interfaces and delegation.",0.20555555555555557,Java
14vm3kw,jrik91b,"Ad-hoc polymorphism is achieved using methods on generic functions, with methods specialised on all arguments, rather than methods on objects; I can only think of Dylan and Julia being influenced by the generic function model.",0.0,Julia
14vm3kw,jrik91b,an abstract class in Java).,0.0,Java
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Go
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Java
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,C
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Kotlin
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Go
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Rust
14vm3kw,jrl2se8,Will be used for new projects  Kotlin has inheritance so does Go as I pointed out.,0.13636363636363635,Kotlin
14vm3kw,jrl2se8,Will be used for new projects  Kotlin has inheritance so does Go as I pointed out.,0.13636363636363635,Go
14vm3kw,jrgmssd,"> No matter where the methods are defined in Rust, the behavior is still tied to the underlying data.",0.0,Rust
14vm3kw,jrgmssd,"In Java, the visibility is tied to the type (class) whereas in Rust the visibility is tied to the module.",0.0,Java
14vm3kw,jrgmssd,"In Java, the visibility is tied to the type (class) whereas in Rust the visibility is tied to the module.",0.0,Rust
14vm3kw,jrfbjwd,"The dot syntax in Rust is a syntax sugar for the full syntax `T::f` or `<T as I>::f`, where `f` is a function taking `self` as the first argument.",0.3,Rust
14vm3kw,jrfbjwd,"In Java, methods are bound to data because you necessarily need an object to call methods upon, unless I'm missing some trick to bypass that.",-0.1,Java
14vm3kw,jrfcdll,"There are no ""higher-kinded type classes"" in Haskell; there are higher-kinded types.",0.0,Haskell
14vm3kw,jrnkluj,"For instance, in Rust, one trait B can extends an other trait A.",-0.125,Rust
14vm3kw,jrlcrg7,"As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,Kotlin
14vm3kw,jrgbss4,"[TypeScript playground link](https://www.typescriptlang.org/play?#code/FAb2wAgh6aIQQCoAsCWA7A5hVBnCAhhLgK4BGALgJ4AOAphAPYBmEAQihppDHAO7I6AJwYc0WHPgIBjaXRoU6AEwA0xRpIScsPavS3jsAXmIUhXXbVHbjp8xIA+EdCQC2ZYeCjMS6aRVRGdBwAOTplJEMAChoCIQJXAC4DLgBKCBAAXy8IABs6CggyG2SxLggTACJBXNzGSsJ8Mp0eWAQhTDc6dEKWCD0GAHJmzEHNdEZCglxcVEx0AjJ8-o1Y+NcC4SZWAYhByK5BgDoeVDCImyjiw1TwbNActpHNIlJKK22UnSg2gWEGA4SPCEWTyRSqdSaEaWfSA2y4MzlJwudyeKC7Z4mBH2bg8Hx+AJBULhJRwmJxBLJOHpLI5fKFa5cUo2CoQap0Wr1RrsGyPOAAeQA0qdzqTLoysLdgNkgA)      // BThing is a subtype of AThing     // where AThing is accepted, so is BThing     type AThing = string | number     type BThing = string  Yes, interfaces can also have a subtype relationship.",0.0,TypeScript
14vm3kw,jrgbss4,"For example in Java, an interface can `extends` another interface.",0.0,Java
14vm3kw,jrgbss4,Rust also has trait subtyping.,0.0,Rust
14vm3kw,jris11n,"If you implement something like this in, say, C, you may have come up with an OO design but that does not make C an OO language.",0.0,C
14vm3kw,jrfhu39,Python.,0.0,Python
14vm3kw,jrfe9yn,This is exactly how C++ implements class methods.,0.25,C++
14vm3kw,jrfe9yn,Rust isn't doing anything different here.,0.0,Rust
14vm3kw,jrfe9yn,What makes Rust different is the ergonomics of `impl` blocks and the flexibility of type classes.,0.0,Rust
14vm3kw,jrgcbem,Rust currently doesn’t have this; only a type can implement a trait.,0.0,Rust
14vm3kw,jrnoz46,The foundation of Rust is based off of OCaml and it takes all of its best traits.,1.0,Rust
14vm3kw,jrnoz46,"I don't love Rust because the slow compilation just makes it really hard to enjoy, if it was faster than I would.",0.07708333333333332,Rust
14vm3kw,jrn1jam,">As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,Kotlin
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Go
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Java
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,C
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Ruby
14vm3kw,jrn1jam,Rust doesn't.,0.0,Rust
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,C++
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,Java
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,Rust
14vm3kw,jrfx4wk,"Rust and C++ implement ""objects"" very differently.",0.0,Rust
14vm3kw,jrfx4wk,"Rust and C++ implement ""objects"" very differently.",0.0,C++
14vm3kw,jrfx4wk,"Rust determines what function to call at compile time, this is not (necessarily) true for C++.",-0.175,Rust
14vm3kw,jrfx4wk,"Rust determines what function to call at compile time, this is not (necessarily) true for C++.",-0.175,C++
14vm3kw,jrfx4wk,C++ has a very different implementation using [vtables](https://en.wikipedia.org/wiki/Virtual_method_table).,0.0,C++
14vm3kw,jrfx4wk,"In simple cases, C++ method call dispatch can be optimized at compiled time, thus resulting in a similar outcome to rust, but this is not the norm.",0.0,C++
14vm3kw,jrfzbpr,"It has associated functions (albeit namespaced a bit weirdly, but that's just a C quirk, right?",-0.10714285714285715,C
14vm3kw,jrfzbpr,"Yes, you technically call them as free functions, but that's how Rust and C++ work under the hood, so is there really any semantic difference?",0.20000000000000004,Rust
14vm3kw,jrfzbpr,"Yes, you technically call them as free functions, but that's how Rust and C++ work under the hood, so is there really any semantic difference?",0.20000000000000004,C++
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,C
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,Rust
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,Java
14vm3kw,jrgiozk,"At least in the C# implementation of a partial class (part of the issue of all this terminology is there is no mathematical or robust definition of a `class`, so we need to specify which language's interpretation of a `class` we mean).",-0.178125,C
14vm3kw,jrgiozk,A partial class can almost be thought of as a purely syntactic concatenation of two files (almost like a C #include directive).,0.057142857142857134,C
14vm3kw,jrgiozk,"In Rust, visibility/encapsulation is determined by the **module**, not the type.",0.0,Rust
14vm3kw,jrgiozk,The same rules of visibility apply to these functions just like any other kind of entity in Rust.,0.15833333333333333,Rust
14vm3kw,jrneuzy,Classes that come from Java and C# have their own way of working (This is how a learned OOP by the way).,0.6,Java
14vm3kw,jrneuzy,Classes that come from Java and C# have their own way of working (This is how a learned OOP by the way).,0.6,C
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,Java
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,C
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Go
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Java
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,C
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Ruby
14vm3kw,jrneuzy,Rust doesn't.,0.0,Rust
14vm3kw,jrneuzy,Rust is rigid in this point (I don't know if it's because of safety or to create a sound type system).,0.4,Rust
14vm3kw,jrit5f3,OP asked why languages lie Rust don’t have classes.,0.0,Rust
14vm3kw,jrfhehb,"But I concede that Rust makes it *easier* to seperate data and impl, and Java makes *conflation* the happy path.",0.8,Rust
14vm3kw,jrfhehb,"But I concede that Rust makes it *easier* to seperate data and impl, and Java makes *conflation* the happy path.",0.8,Java
14vm3kw,jrilbyx,"Without inheritance, C++ does compile-time dispatch.",0.0,C++
14vm3kw,jrilbyx,"For trait objects (boxed), Rust does runtime dispatch, pretty sure with vtables.",0.375,Rust
14vm3kw,jrghbx7,"~~C is fundamentally different from Java & Rust, because it has no private members.",0.0,Java
14vm3kw,jrghbx7,"~~C is fundamentally different from Java & Rust, because it has no private members.",0.0,Rust
14vm3kw,jrghbx7,"Languages like Haskell not, because of immutability and lack of side effects.",0.0,Haskell
14vm3kw,jrghbx7,Rust & Java allow arbitrary side effects and mutation of their associated instance.,-0.1,Rust
14vm3kw,jrghbx7,Rust & Java allow arbitrary side effects and mutation of their associated instance.,-0.1,Java
14vm3kw,jrhp47u,"I'm not very familiar with Rust, I hoped that comparing to C# would help me understand.",-0.14423076923076922,Rust
14vm3kw,jrhp47u,"I'm not very familiar with Rust, I hoped that comparing to C# would help me understand.",-0.14423076923076922,C
14vm3kw,jrflnf1,"Yes, you can perhaps imitate the Rust's behaviour with static methods (modulo syntax), but that wouldn't be in the nature of Java for sure.",0.5,Rust
14vm3kw,jrflnf1,"Yes, you can perhaps imitate the Rust's behaviour with static methods (modulo syntax), but that wouldn't be in the nature of Java for sure.",0.5,Java
14vm3kw,jrnig92,"Like Rust or Go, methods are defined separately of data structures.",0.0,Rust
14vm3kw,jrnig92,"Like Rust or Go, methods are defined separately of data structures.",0.0,Go
14vm3kw,jrns1wd,I have visited the official [FAQ for Go](https://go.dev/doc/faq) and they stated that they don't implement type/data inheritance.,0.0,Go
14vm3kw,jrnjz4i,You can also look at D for another example.,0.0,D
14vm3kw,jrnw34p,I have visited the official FAQ for Go and they stated that they don't implement type/data inheritance.,0.0,Go
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,C++
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Rust
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Go
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Scala
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Kotlin
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Julia
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Elixir
14vm3kw,jro13ss,But it shows that Go use the type embedding (among other methods like traits or mixins or protocols) to mitigate this drawback.,-0.125,Go
14vm3kw,jro13ss,TBH I am more in favor of the Go type embedding,0.5,Go
14vbyy3,,"Well and good: the model is turtles all the way down, just like Lisp's eval/apply.",0.2722222222222222,Lisp
14vbyy3,jrcq0mr,IIRC Cloud Haskell embeds actors in a lazy language.,-0.25,Haskell
14vbyy3,jrd0nrv,Cloud Haskell ...,0.0,Haskell
14vbyy3,jrd0nrv,"Cloud Haskell decrees that *because Haskell,* messages happen in a monad, which is no surprise.",0.0,Haskell
14vbyy3,jrd0nrv,Gymnastics in section 3 deal with Haskell not being anything like Erlang.,0.0,Haskell
14vbyy3,jrd0nrv,Gymnastics in section 3 deal with Haskell not being anything like Erlang.,0.0,Erlang
14vbyy3,jrmnwdd,"It might not be exactly how Haskell implementations work on the inside, but you can think of an entire Haskell program's evaluation as being driven by the *need* for that outside-world resulting from all the I/O actions they perform, in order as determined by their functional dependencies embedded in all that monadic fancy footwork that do-notation desugars into.",0.125,Haskell
14vbyy3,jrmnwdd,And Haskell's way of saying that is wrapped up in its relationship with the I/O monad.,0.0,Haskell
14va6m9,jrdskmq,And I decided long ago that the best use of my time is to just work on improving Haskell tooling.,0.475,Haskell
14va6m9,jre41jj,enums in C and many other languages only allow \`[atoms](https://langdev.stackexchange.com/questions/1970/what-is-the-type-and-correct-name-of-a-member-of-an-enumeration/1971#1971)\` to be values with the same underlying simple type.,0.075,C
14va6m9,jre41jj,Having the type representation do both jobs is good but for reasons unknown they chose to name their construct after the less general concept (a C stlye enum) rather than the more general one (a discriminated union).,0.17222222222222225,C
14va6m9,jre41jj,The type representation being (using Haskell like syntax)  data union = typeA | typeB | typeC,0.0,Haskell
14va6m9,jrfqag8,I wonder if Swift checks all the boxes...,0.0,Swift
14va6m9,jrdnkdj,"I’ve used macros in Lisp-like languages and the preprocesser in C extensively, but felt like it was a feature I could live without, so I left it off the list.",0.04545454545454545,C
14va6m9,jrdnkdj,"This is cool, and it’s fun to take advantage of Lisp’s syntax to do so, but I’ve always felt like code that relies too much on macros becomes difficult to reason about.",0.08749999999999997,Lisp
14va6m9,jrdnkdj,"In C, I see the preprocessor as mainly used for performance, debug flagging, higher order programming, and generics.",0.20833333333333331,C
14va6m9,jre5wni,"Enums in C carry tags, but no data.",0.0,C
14va6m9,jre5wni,"Unions in C carry data, but no tags.",0.0,C
14va6m9,jre5wni,"Rust ADTs carry both (or one, or neither).",0.0,Rust
14va6m9,jre5wni,"Swift did too, so the small amount of emerging consensus as to what to call ADTs in C-like languages is nice.",0.175,Swift
14va6m9,jrgjx3o,"It might, though I’ve never used Swift as I’m outside the Apple development world.",0.0,Swift
14v92v5,,And by dead I mean in *this* sense (from Monty Python's Parrot sketch):  >He's not pining!,-0.2953125,Python
14v92v5,,"IN MEMORIAM  *Conceived in the spring of 2001 as a fusion of Perl and Python, Parrot, the illegitimate love child of Guido van Rossum and Larry Wall, was born as version 1.0 on 17.",0.5,Perl
14v92v5,,"IN MEMORIAM  *Conceived in the spring of 2001 as a fusion of Perl and Python, Parrot, the illegitimate love child of Guido van Rossum and Larry Wall, was born as version 1.0 on 17.",0.5,Python
14v92v5,jrcph68,"Imagine a Smalltalk with a good static type system (Griesemer introduced a similar one to Go), a highly optimized VM (Bak and Holze were the wizards behind V8), and an integration with the Web that was never fully realized.",0.19199999999999998,Go
14v92v5,jrgdgdy,"You've heard of Ada, but nobody knows of Babbage.",0.0,Ada
14v92v5,jrgdgdy,(Named after collaborators Ada Lovelace and Charles Babbage.),0.0,Ada
14v92v5,jrbkpty,HyperCard  ActionScript,0.0,ActionScript
14v92v5,jrcqcuy,"Eiffel, Oberon.",0.0,Eiffel
14v92v5,jrccdbt,Pascal,0.0,Pascal
14v92v5,jrdxe02,Eiffel.,0.0,Eiffel
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,Pascal
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,Ada
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,C++
14v92v5,jrc8bn8,Not sure about ActionScript.,-0.25,ActionScript
14v92v5,jrdoys0,> ActionScript  Now you made me sad.,-0.5,ActionScript
14v92v5,jrdoys0,"ActionScript was Flash's version of Javascript, based on the same ECMAScript standard, but *better*.",0.16666666666666666,ActionScript
14v92v5,jrc5m1y,> ActionScript  RIP - We had some good times,0.7,ActionScript
14v92v5,jrdhmul,"Modula-3  I have a habit of picking the wrong horse, and was **so** chuffed to have picked a nice, clean GC'ed language with modules as my next language after C, instead of C++.",0.11666666666666667,C
14v92v5,jrdhmul,"Modula-3  I have a habit of picking the wrong horse, and was **so** chuffed to have picked a nice, clean GC'ed language with modules as my next language after C, instead of C++.",0.11666666666666667,C++
14v92v5,jrfmlnt,Eiffel's last update was a few months ago.,-0.1,Eiffel
14v92v5,jrcds5r,"But object pascal versions are still alive, Delphi and other OSS like Free pascal and Lazarus.",0.125,Delphi
14v92v5,jrcds5r,And I would not be surprised if Pascal is still used as first language on some places,0.175,Pascal
14v92v5,jrhmv4z,"I love OOSC as a book, and found Eiffel: The Language ""interesting"", but the new version was a more complex and less beautiful language.",0.2885281385281385,Eiffel
14v92v5,jrhmv4z,"One thing that made me question Meyer's sincerity as a language developer was how in OOSC, he argued passionately that Eiffel had no case statement, because with OOP, it wasn't needed.",-0.05,Eiffel
14v92v5,jrhmv4z,"Then in the next Eiffel version a case statement had been added, with no acknowledgement that the previous stance had been wrong.",-0.2222222222222222,Eiffel
14v92v5,jrhmv4z,"I just now had a look at the EiffelStudio site, and it would seem that Eiffel is still alive.",0.1,Eiffel
14v92v5,jrjebiz,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal,  There were a slew of PL/\* languages around the end of the 70s.",0.4333333333333333,Pascal
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,Pascal
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,Fortran
14v92v5,jrjebiz,"I did later buy a book about C, but I was unimpressed and sold it again (at quite a loss actually).",0.0,C
14v92v5,jrjebiz,"But then Fortran has changed a lot more, and it's still 'Fortran'.)",0.5,Fortran
14v92v5,jru11ss,"It was a hodge podge of languages: Python for the AI/gameplay scripting, C++ for the game engine, an XML-based in-house GUI editor for creating interactions, and a visual programming tool for animation state machines.",-0.2,Python
14v92v5,jru11ss,"It was a hodge podge of languages: Python for the AI/gameplay scripting, C++ for the game engine, an XML-based in-house GUI editor for creating interactions, and a visual programming tool for animation state machines.",-0.2,C++
14v92v5,jreeo2b,What semantics do JavaScript classes have or lack that you find makes them “improper”?,0.0,JavaScript
14v92v5,jreao66,*Added sigh*  What is it with people thinking that C syntax is clear or stylish?,0.3,C
14v92v5,jribhrl,Actually I meant gnu Eiffel/Smart Eiffel projects.,0.0,Eiffel
14v92v5,jrkkuyu,"PLZ/SYS was intended as a system programming language, and the idea was that mainstream languages like BASIC, FORTRAN and COBOL would also be developed for this Pcode system, which ran on Zilogs RIO system for Z80, and on ZEUS (Unix) for the Z8000.",0.05,COBOL
14v92v5,jregpyw,"JavaScript didn't have classes back then, only prototype-based inheritance.",0.0,JavaScript
14v92v5,jregpyw,"Which is powerful, but doesn't lead to a very smooth experience for beginners who were expecting ""Java in the browser"".",0.41000000000000003,Java
14v92v5,jrj08ah,"Why should they maintain for example CHILL or Eiffel, if there are no users of the languages?",0.0,Eiffel
14v92v5,jrd0n4w,"Ive been developing with Delphi since Delphi 3 and while the IDE and developer experience is (mostly) absolutely phenomenal, the language/compiler itself lacks a lot of features or are implemented in a very annoying way which are handled much more nicely in modern languages.",0.05,Delphi
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,Delphi
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,C
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,Rust
14v92v5,jrd0n4w,I use Delphi for new projects because Ive built a huge framework which provides most of the functionality I miss over the years.,0.34545454545454546,Delphi
14v92v5,jrd0n4w,"But I feel like I will switch to Rust as soon as a matured, native and multi os GUI platform is available... :/",0.07500000000000001,Rust
14v92v5,jrnuxjw,"Like I said, it's a lot simpler in some ways than Pascal (it doesn't even have a Boolean type, nor does it have floating point), but its syntax is interestingly strange in that "","", "";"" and "":"" are considered delimiters that are entirely ignored (except for separating tokens like space), which results in the weird reversed Algol-like declaration syntax: ""a b c integer"".",-0.18333333333333335,Pascal
14v8lsz,jrbwf6j,Its ideas are mixing TypeScript's type system and general syntax with fuctional features such as immutability and flow control without loops (like Ruby - you use functors i.e.,0.02500000000000001,TypeScript
14v8lsz,jrbwf6j,Its ideas are mixing TypeScript's type system and general syntax with fuctional features such as immutability and flow control without loops (like Ruby - you use functors i.e.,0.02500000000000001,Ruby
14v8lsz,jree2if,"I agree it's not the ergonomic or simple (kinda like Python having you join arrays for performance) but it's not bad, especially if they have a reason not to give a concatenation operator or method to strings.",0.11666666666666664,Python
14v8lsz,jre6gsz,": Pascal, Modula2, Oberon, Python 2, [Seed7](https://seed7.sourceforge.net), ...",0.0,Pascal
14v8lsz,jre6gsz,": Pascal, Modula2, Oberon, Python 2, [Seed7](https://seed7.sourceforge.net), ...",0.0,Python
14v8lsz,jre6gsz,": Oracle, SQLite, SQL Server, MySQL, PostgreSQL, ...  Java generics also use `<>` (this is neither concatenation nor not equal).",0.0,Java
14v8lsz,jre6gsz,"For that reason [Seed7](https://seed7.sourceforge.net) uses [&](https://seed7.sourceforge.net/libraries/string.htm#(in_string)&(in_string)) for string concatenation (Basic, Ada, and other languages also decided for `&`):      msg := ""hello world"" & "" @ "" & timestamp();  This string concatenation does no type conversions (unlike the `+` string concatenation of Java).",-0.0625,Ada
14v8lsz,jre6gsz,"For that reason [Seed7](https://seed7.sourceforge.net) uses [&](https://seed7.sourceforge.net/libraries/string.htm#(in_string)&(in_string)) for string concatenation (Basic, Ada, and other languages also decided for `&`):      msg := ""hello world"" & "" @ "" & timestamp();  This string concatenation does no type conversions (unlike the `+` string concatenation of Java).",-0.0625,Java
14v8lsz,jrei91v,"For example Lua uses `..`, which strikes me as unintuitive, while your `<>`, as  u/ThomasMertes mentioned, often means `not equal`, as it does in my syntax, so may be confusing to some.",-0.15,Lua
14v8lsz,jrei91v,"So that impenetrable C++ code I sometimes come across could really be quite simple after all, if I just ignore 90% of the syntax?",0.1,C++
14v8lsz,jrefwoh,Lua uses `..` but I don't like it that much.,0.2,Lua
14v8lsz,jrl5l2s,"In Python, for instance, there's both, and the file example would be `open(f""{path}{file}{ext}"")`.",0.0,Python
14v8lsz,jrla25r,"If the destination is represented as `D`, then my version results in these operations behind the scenes:      D := """"     D +:= path     D +:= file     D +:= ext  So the string adds are still there, but now they're the slightly more elaborate inplace versions!",0.43125,D
14v8lsz,jrlc657,"In Python specifically, more complex expressions are allowed, but that doesn't have to be so in your language.",0.1,Python
14v8lsz,jrlc657,"Not in Python (nor some other languages with unicode strings), because `str` is immutable for good reasons.",0.2875,Python
14v8lsz,jrlc657,"However, it has drawbacks, and could've been better off if implemented in a slightly different way (`Option<&T>` in Rust, for instance, is optimized to represent `None` with a null reference, but unlike a raw null pointer, this cones with convenient and simple compile-time guarantees).",0.0673076923076923,Rust
14uttxo,jr9ddjb,"This IMO qualifies, check the use of EBNF notation in the Go language specification: https://go.dev/ref/spec#Notation",0.0,Go
14uttxo,jrbqegb,Go to statements         4.4.,0.0,Go
14usw9q,,"For chaining calls I have pipelines, as in F#, Elixir or Elm: `1 |> isNegative ==> isNegative(1)`.",0.0,Elixir
14usw9q,,"For chaining calls I have pipelines, as in F#, Elixir or Elm: `1 |> isNegative ==> isNegative(1)`.",0.0,Elm
14usw9q,jre5xfc,"The Elm and Purescript documentation compliments this really well, since you get the type of your ""hole"" and just search for it across the available packages.",0.30000000000000004,Elm
14usw9q,jre5xfc,The only downside is that the Haskell syntax for declaring generic parameters for whatever reason puts the generic constraints before the argument/return types.,0.0,Haskell
14usw9q,jre5xfc,"This can make it quite opaque to scroll through purescript or Haskell docs, but with Elm docs it's quite nice.",0.6,Haskell
14usw9q,jre5xfc,"This can make it quite opaque to scroll through purescript or Haskell docs, but with Elm docs it's quite nice.",0.6,Elm
14usw9q,jre5xfc,"(Seriously, polymorphism is nice but does Haskell have to be *that* polymorphic?)",0.13333333333333333,Haskell
14upgz1,jr8ylk2,Many developers use C as their destination P.L.,0.5,C
14upgz1,jr966ni,I guess you should know some principles on how Assembly works.,0.0,Assembly
14upgz1,jr9dtpu,"I can say that if you target C or C++ as your final target, it would suffice.",0.0,C
14upgz1,jr9dtpu,"I can say that if you target C or C++ as your final target, it would suffice.",0.0,C++
14upgz1,jr9dtpu,"Especially if you want to define a language like JavaScript, there's no point to work with LLVM, SSA or assembly.",0.0,JavaScript
14upgz1,jratcwd,"LIBFFI is one heavyweight and complex solution, consisting of C code plus various platform-specific ASM files.",-0.15,C
14upgz1,jratcwd,"It requires a C compiler to process, and is generally horrible to build and an undesirable dependency.",-1.0,C
14upgz1,jrawjzz,"Unless you're writing another ""C replacement language"" as a design goal, the compilation step can happen later.",0.0,C
14upgz1,jr8zpyc,So ABI stability simply because C's ABI is stable for platforms.,0.0,C
14upgz1,jr9996h,"* It can also be run from the terminal in the way Python scripts are ""interpreted"" (fast-compiled to bytecode and then run on a VM, except mine will be fast-compiled to WASM and run via a WASI runtime).",0.0,Python
14upgz1,jr9996h,"* Most likely, like Python, a file will represent a single module, with directories being used to group them (though Rust's crate tree structure also looks appealing as the basic build unit).",0.18571428571428572,Python
14upgz1,jr9996h,"* Most likely, like Python, a file will represent a single module, with directories being used to group them (though Rust's crate tree structure also looks appealing as the basic build unit).",0.18571428571428572,Rust
14upgz1,jreospd,I'm familiar with C and know basic pointer arithmetic (and manipulating C arrays with it).,0.1875,C
14upgz1,jr9kkd1,"These are some characteristics of my own systems language:  * Primarily supports Windows on x64 via direct native code generation * Other 64-bit platforms can be supported via transpilation to C, although that doesn't cover all language features * The compiler is fast enough to run programs directly from source (up to a certain size anyway; 500K lines would take one second to compile) * There is no REPL; this would be impractical in this language as it is strictly AOT: all code must be compiled before calling the entry point * There was an experimental, discrete VM target with an interpreter.",0.15892857142857145,C
14upgz1,jr9lzet,"Also, preferably it should be a ""quick 0 to 60"" type language like C (and Go and Zig from what I hear).",0.3333333333333333,C
14upgz1,jr9lzet,"Also, preferably it should be a ""quick 0 to 60"" type language like C (and Go and Zig from what I hear).",0.3333333333333333,Go
14uc5t2,jrobor3,It has the same kind of esoteric vibes that APL and Nock give off!,0.375,APL
14ua5dx,jr70895,"I'm pretty sure Swift does it, so do HotSpot (VM) and Go.",0.375,Swift
14ua5dx,jr70895,"I'm pretty sure Swift does it, so do HotSpot (VM) and Go.",0.375,Go
14ua5dx,jreh2nv,The idea for Swift was initially to just move allocations to the heap for ref counting or on the stack depending on what the analysis showed.,0.0,Swift
14ua5dx,jr7c7hy,"I considered a lot of programming languages to write my compiler in (C, Zig, F#, OCaml, Standard ML, Crystal,...), and when I got bored of my indecisiveness about languages, I picked V without thinking about it much.",-0.09999999999999999,C
14ua5dx,jr7c7hy,"I considered a lot of programming languages to write my compiler in (C, Zig, F#, OCaml, Standard ML, Crystal,...), and when I got bored of my indecisiveness about languages, I picked V without thinking about it much.",-0.09999999999999999,Crystal
14ua5dx,jr7nhrt,"a borrow checker as in Rust), or a runtime cost (e.g.",0.0,Rust
14ua5dx,jr6gckn,If I'm not mistaken that's how Rust does it.,0.0,Rust
14ua5dx,jrdbwnz,I took following snippet from generated C code: ``` void _v_free(voidptr ptr) {     #if defined(_VPREALLOC)     {     }     #elif defined(_VGCBOEHM)     {     }     #else     {     }     #endif } ``` `_v_free` is the the function which is suppose to do the deallocation.,0.0,C
14ua5dx,jr6ytec,"It is possible, but as a note, Rust doesn't prevent all leaks.",0.0,Rust
14ua5dx,jr8z3jv,&#x200B;  >If I'm not mistaken that's how Rust does it.,0.0,Rust
14ua5dx,jr8z3jv,"Other programming languages have offered viable solutions, different strategies, and alternate directions, besides what Rust is doing.",-0.041666666666666664,Rust
14ua5dx,jr7utm5,"smart pointers in C++, but basically this is the idea behind destructors.",-0.09285714285714287,C++
14ua5dx,jr93g82,"C#, for example, uses the `stackalloc` keyword for this.",0.0,C
14ua5dx,jr9oy8u,"I'm not a Rust aficionado so maybe I'm not fully understanding the implications of ""borrow checker"", but for a language without mutable references, you just need a type system utilizing some kind of substructural logic that fits your use case, be it linear, affine etc.",0.6,Rust
14ua5dx,jr6nmku,"Not necessarily, COBOL for example divides variables into sections, where each section has a specific lifetime requirement.",0.0,COBOL
14ua5dx,jr6nmku,COBOL slightly abstracts this lifetime requirement in the syntax.,-0.16666666666666666,COBOL
14ua5dx,jr6nmku,"In COBOL you can't return a variable from a function's  local-storage or working-storage directly, you have to move it into the linkage section.",0.1,COBOL
14ua5dx,jr6nmku,"Also, you can't return or pass file descriptors around in COBOL, that would be unsafe since it has native resources associated with it, so file descriptors are only valid in the scope that they were declared.",0.0,COBOL
14ua5dx,jr6j14y,"Yes if you do it the Rust way, but I wonder if there's another set of constraints that would work.",0.0,Rust
14ua5dx,jr8091o,"As a note to the note, off the top of my head the only two cases of leaks that Rust doesn't catch is 1) explicitely leaking and 2) Reference-counted cycles.",0.25,Rust
14ua5dx,jr7udyp,in Python),0.0,Python
14ua5dx,jr995py,Depends on what kind of Rust.,0.6,Rust
14ua5dx,jr995py,"AFAIK a restrictive Rust without unsafe, forget, Rc and Arc (and maybe some other features) could probably do it.",-0.125,Rust
14ua5dx,jr7uzhx,"I've no idea if this is supposed to be a performant version of it, or if that relies on using Tiny C backend.",0.0,C
14ua5dx,jr7uzhx,"This is about the same time as Tiny C working on a version in pure C, but the executable was 23MB.",0.07142857142857142,C
14ua5dx,jrc6hen,How about you go back to shilling Rust then.,0.0,Rust
14ua5dx,jr6o5z9,I haven't studied COBOL and I couldn't grasp any of that.,0.0,COBOL
14ua5dx,jr7um54,People acting like Rust is the only way are fooling themselves.,0.0,Rust
14ua5dx,jryljtv,in Python  [Python's GC handles cyclic references without leaking memory.,0.0,Python
14ua5dx,jr79v4u,COBOL source code is syntactically separated into divisions and sections.,0.0,COBOL
14ua5dx,jr79v4u,"The key thing here, is that COBOL doesn't allow you to return variables directly from other sections.",-0.008333333333333331,COBOL
14ua5dx,jrc5rfm,"In one like C and like mine, applying gcc-class optimisation might only double performance, but at a cost of taking up to 100 times longer to build, so it's not worth doing for routine development.",-0.049999999999999996,C
14u1brp,jr5k9do,"This problem occurs in C too, where the types are `T*[]` for `array of pointer`, and `T(*)[]` for pointer to array, or somthing like that.",0.25,C
14u1brp,jr5k9do,"It was actually solved by Algol68 (four years before C first appeared), by using a left-to-right syntax.",0.125,C
14u1brp,jr5k9do,"C tried to make it correspond, and the result was disastrous.",-0.7,C
14u1brp,jr5q4zw,I've had a similar problem working with C where this can become ambiguous.,0.0,C
14u1brp,jr6h62s,"I never really liked how TypeScript has `Array<T>` (good - ""Array of T"") but then has a syntax sugar of `T[]`, which feels backwards.",0.19999999999999998,TypeScript
14u1brp,jra5psl,Just read through the linked page and wanted to say that Ruby handles array indexing the same way!,0.0,Ruby
14u1brp,jr65x1m,This issue was notorius in C++ until C++11 and required you to put an extra space.,0.0,C++
14u1brp,jr62sz8,"It's ugly, but you rarely see this in actual C code.",-0.13333333333333333,C
14u1brp,jr62sz8,"The reason: nobody uses pointers to arrays (`T(*)[]`) in C; the universal idiom is to use a `T*` type instead (pointer to the first element), even though this is unsafe: `A` might not be an array, but C allows indexing of pointers anyway.",0.16666666666666666,C
14u1brp,jr62sz8,"Yet another is pointer-to-function `F`, called as `(*F)(x)`, but this is rarely seen too, because one of C's quirks allows you to just use `F(x)`.",0.3,C
14u1brp,jr62sz8,"So, it's all very well saying that having extraneous parentheses is OK, but even C,  not averse to punctuation, avoids using them as much as possible!",0.2333333333333333,C
14u1brp,jr62sz8,"Personally I prefer a postfix dereference operator (mine was based on Pascal's `^`), but as I said it's your choice.",0.0,Pascal
14u1brp,jr62sz8,"Go with `@`, whether prefix or postfix, and see what sample programs look like.",0.0,Go
14tvuta,jr4kw0w,"As far as programming history goes, don't forget about the array languages, like APL.",0.1,APL
14tvuta,jr4kw0w,"In fact, Jeremy Gibbons has an article, [Origami Programming](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf), which explains (via Haskell) more than you ever wanted to know about reduce.",0.5,Haskell
14tvuta,jr4kaj7,Probably APL.,0.0,APL
14tvuta,jre45ig,"I believe it was John Backus doing research for good functional primitives, and he found out that 90% of for loops in the Fortran compiler were either filter, map, or reduce.",0.7,Fortran
14tvuta,jr51b2v,"That said, some commentators have mentioned APL, and quoting the Wikipedia page linked above:  > Plankalkül has drawn comparisons to the language APL",0.25,APL
14tvuta,jr509ln,"I’ve always assumed Lisp, but since it’s older than I am, and older than most living people for that matter, I guess it doesn’t matter too much at this point.",0.2583333333333333,Lisp
14tvuta,jr9g2dz,"When I said ""earlier Lisps"" I was thinking Scheme but of course Scheme is notoriously minimalistic.",0.0,Scheme
14tvuta,jr9g2dz,Tbh it doesn't make sense to have a Lisp without filter map reduce.,0.0,Lisp
14tvuta,jr9g2dz,"Edit: having read the document, Lisp 1 does indeed not have built in filter or reduce functions.",0.0,Lisp
14tvuta,jr9g2dz,"There's a select, which is like first() in C#, and a reduce, which is unrelated to functional array manipulation.",0.25,C
14tvuta,jr9g2dz,"Edit 2: I read through the Chinual and found that, in Lisp Machine Lisp, filter is called ""subset"" or ""rem-if-not"".",0.0,Lisp
14tvuta,jr4s8c5,"This is probably close to correct, but with the following caveats:  * Original APL did not have a real `map` construct where you could apply an arbitrary function to each element of an array.",0.11875,APL
14tvuta,jr4s8c5,"Instead, all APL operations were implicitly rank-polymorphic.",0.0,APL
14tvuta,jr4s8c5,"The actual APL version of `map` (called ""each"") is much younger.",0.0,APL
14tvuta,jr4s8c5,"* APL's `filter` operation was also somewhat different, as it took a boolean array instead of a function.",0.0,APL
14tvuta,jr4s8c5,"* APL's `reduce` was pretty much what you'd expect it to be however, although limited to a handful of built-in functions IIRC.",0.1261904761904762,APL
14tvuta,jr4s8c5,"The connecting thread here is that APL didn't have first class functions, so the modern filter/map/reduce operations would not be expressible.",0.225,APL
14tvuta,jr4s8c5,"I'm not sure when they first occurred in their modern form, but I think Lisp was the first reasonably widespread language with first class functions, so I'd point to somewhere in that vicinity.",0.15,Lisp
14tvuta,jr9gb05,"Yeah, the fact that it's the oldest functional language and that it's list-based and loops through recursion makes it a safe bet for being the first to implement filter map reduce, but surprisingly older versions of Scheme don't have built in implementations of filter and reduce, and somehow I was dumb enough not to consider there are other old Lisps besides Scheme.",0.0738095238095238,Scheme
14tk6p4,js2t9ev,"I did want to minimize people bringing old baggage, and I like that in C++ for many years the idea of a concept suggested signature-based polymorphism (aka duck typing).",0.3,C++
14tjakk,jr2ybnf,">Most programming languages I know use `}` for all of those things,  That's C having far more influence than it deserves.",0.3,C
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,Pascal
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,Lua
14tjakk,jr2ybnf,"Plus there are a couple  more categories: the ones using S-expressions so `)` is used for everything, and those using no terminator at all (like Python and Nim).",0.5,Python
14tjakk,jr2ybnf,"As for the reasons for those using only `End`, with Pascal and Algol60, `Begin ... End` are a form of parentheses just like `{ ... }` and `( ... )`.",0.0,Pascal
14tjakk,jr5747e,Erlang has many ways of ending block structures and it's a mess.,0.1625,Erlang
14tjakk,jr5lia7,> That's C having far more influence than it deserves.,0.3,C
14tjakk,jr4jc1w,"HTML template languages often have ways of separating delimiters like this, so that the meta-level template blocks don’t have to be strictly nested in the object-level HTML blocks.",0.0,HTML
14tjakk,jr663lx,"Take this example from C (which often allows braces to be optional: yet another possibility):      if (a) {b; c;} else {d; c;}  The two blocks are separated by `} else {`; think of how many ways there are of placing those, occupying anything from 1 to 3, lines, with  `}` possibly sharing with the previous line,  maybe `{` with the next.",0.08333333333333334,C
14tjakk,jr663lx,"C's approach is to use no braces for a block of one statement, and braces otherwise, but that can be odd too:      if (a) b; else {d; c;}  Also, a syntax that doesn't have parentheses around the condition, needs something that separates `a` from `b`; another brace?",-0.16666666666666666,C
14tjakk,jr4rvt5,"Past that, it seems like what you're getting at is meta-programming, especially with the HTML part.",-0.125,HTML
14tjakk,jr4rvt5,"As someone said, that's essentially just goto:      retryable: someAction();     if(allowRetry() && shouldRetry()) {         backoff();         goto retryable;     }  That's actually shorter, although that's partially due to C syntax, and IMO much easier to follow mentally.",-0.004999999999999999,C
14tjakk,jr4rvt5,"Second, the HTML example looks like it's more or less just permuting over the combinations of essentially singly nested arrays.",0.0654761904761905,HTML
14tjakk,jr4xrrc,"C also has something I'd perceived as an ambiguity:      do ; while (c) {}  Does that `while` end the `do` statement, or does it start a new `while` statement?",0.13636363636363635,C
14tjakk,jr3ndba,"BTW I sometimes use an alternate, more compact syntax with parentheses:      if a then b else c fi       # or:     ( a | b | c )          record R = ... end          # or:     record R = (...)  This form is more suitable for one-liners.",0.00833333333333334,R
14t96qf,,"Great examples are Crystal and Codon (a Python ""subset"", which treats the language like a statically typed one).",0.8,Crystal
14t96qf,,"Great examples are Crystal and Codon (a Python ""subset"", which treats the language like a statically typed one).",0.8,Python
14t96qf,,"I am barely convinced that such a language would enable the compiler to do even deeper and interesting optimizations than the classical ones (but still mind blowing) applied to languages such as C, C++ (an example is Zig, which is even more optimizable AFAIK because of its very clever approach to Meta Programming, isn't it?",0.18095238095238095,C
14t96qf,,"I am barely convinced that such a language would enable the compiler to do even deeper and interesting optimizations than the classical ones (but still mind blowing) applied to languages such as C, C++ (an example is Zig, which is even more optimizable AFAIK because of its very clever approach to Meta Programming, isn't it?",0.18095238095238095,C++
14t96qf,,"The compiler informs you that \`data\` must be something iterable, which means it must implement attributes      fn len()    // used in foreach and return     fn nth(idx) // used in foreach  and then each iterated element should implement specific attributes as well      static default // used as base for the sum     fn add()       // used to sum all the elements  &#x200B;  **Why I don't like the idea of making type annotations just optional**  What seems to happen in Crystal code is that users just end up using explicit typing over implicit one, because:  * The language allows you to do it, so for Crystal users it's easier to just reject a new way to code and continue using the classic approach with types * The compiler doesn't explain to you why a function raises compilation errors when you pass a wrong argument  &#x200B;  **Ways to make it easier for the user to spot wrong arguments**  Using this approach may be hard for the user to understand what to pass to a certain function of an X library, maybe not well documented.",-0.11937229437229441,Crystal
14t96qf,,"One solution would be just printing some sort of compile time stack trace of function instantiations, like Clang does when using \`auto\` on parameters in C++.",0.0,C++
14t96qf,jr1a3ha,"You can do that in any sort of MLy language to be honest, especially if you don't use advanced type-level magic like it's common in Haskell.",0.24,Haskell
14t96qf,jr1l2ty,You can see this in action when using complicated C++ templates or writing Haskell code without enough type annotations.,-0.13333333333333333,C++
14t96qf,jr1l2ty,You can see this in action when using complicated C++ templates or writing Haskell code without enough type annotations.,-0.13333333333333333,Haskell
14t96qf,jr1l2ty,"There's a good reason why the Haskell community has developed the convention that all top-level declarations should have type declarations, and why Rust promoted that contention to a rule.",0.39999999999999997,Haskell
14t96qf,jr1l2ty,"There's a good reason why the Haskell community has developed the convention that all top-level declarations should have type declarations, and why Rust promoted that contention to a rule.",0.39999999999999997,Rust
14t96qf,jr1jd1k,"Haskell in particular was designed such that in _any valid Haskell program_, with no type annotations at all, the types can be fully inferred.",0.08333333333333333,Haskell
14t96qf,jr30r3j,"ReScript is syntactic sugar on OCaml (same AST, different parser) designed to transpile to JavaScript, and the syntax is more comfortable if you’ve come from a C or JS background.",0.225,JavaScript
14t96qf,jr30r3j,"ReScript is syntactic sugar on OCaml (same AST, different parser) designed to transpile to JavaScript, and the syntax is more comfortable if you’ve come from a C or JS background.",0.225,C
14t96qf,jr2ma88,"I see the many comments that so and so functional language that does it, frankly no one cares, it's imperative and C level performance or go home.",0.5,C
14t96qf,jr1kwo9,Modern Java has this.,0.2,Java
14t96qf,jr6nl67,I guess there is a good reason Rust requires explicit types at the function boundary and why functional languages have this at least as the best practice.,0.4666666666666666,Rust
14t96qf,jr51m0f,"Using typeclasses ala Haskell, a and b would be inferred as: `(Read a, Num a) => a` That is, some type a, for which the appropriate methods (in this case read and (+)) are defined, but we don't yet know concretely what it is.",0.325,Haskell
14t96qf,jr3n3c9,It is common to write Rust code that requires explicit type annotations.,-0.3,Rust
14t96qf,jr274pq,I already don't write types in Rust until I have to (due to ambiguity and choices).,-0.125,Rust
14t96qf,jrh8kdo,"It's an interesting language, but it does not match C for performanc https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/ocaml-gpp.html, and thus is useless for a variety of cases, e.g.",0.0,C
14t96qf,jr3cpw4,The implementation of ML languages is not based around copying the body of a function like Crystal.,0.0,Crystal
14t7ig2,jr4znt0,"Val originates from taking Swift's double nature of both reference and value semantic, and pushing the value semantic part and only it to the maximum.",0.0,Swift
14t7ig2,jr4znt0,"Also, they think Val is easier to understand than Rust lifetimes and borrow checker, and therefore decided to try and develop Val as a mainstream programing language.",0.0,Rust
14ssjiv,jr13j4h,It's something of a paradox :)  What I think is:  - It's 10x-100x harder to write a production C compiler (Clang/LLVM) than a toy C compiler - It's 10x-100x harder to write a production shell (our goal) than a toy shell - C/C++ are ~10x bigger than shell?,0.07500000000000001,C
14ssjiv,jr13j4h,"Open source is really like those sci-fi books where the civilization is running, but nobody knows how the tech works anymore  Shell is sprayed all over the foundations of software, both at build time and runtime (and it's more popular now than EVER!",0.3625,Shell
14ssjiv,jr13j4h,"due to the cloud and embedded systems becoming Linux systems)  But there are lots of parts that only a few people know about  ---  To be honest we still need a lot of help, and I think the people on this sub have the right skills - e.g https://www.oilshell.org/blog/2023/03/roadmap.html  If anyone likes generating C++ code, there are some exciting projects there, like ""boxless optimization"" to remove a level of boxing from the interpreter  Generating C++ is the best of both worlds IMO -- you don't have all the pitfalls of writing it by hand (e.g.",0.28883928571428574,C++
14snerw,jqzzirf,:D,1.0,D
14sbn35,,"That makes such a loop a *list-comprehension*, a slightly different beast, which in Python has dedicated syntax:      x = [elem + 2 for elem in [1,2,3,4]]  In Pyret, the same example is:      x = for map(elem from [list: 1,2,3,4]):       elem + 2     end  Pyret is touted as being *designed to serve as an outstanding choice for programming education*, so I'm surprised it makes the basics so hard: the original BASIC gave you `for i = a to b`; I couldn't tell you how it would be in Pyret.",0.08541666666666667,Python
14sbn35,jqwyo6c,Pyret is pretty much a Scheme with a facelift to make it more accessible.,0.33125,Scheme
14sbn35,jqxf5hw,"I can't speak for the Pyret designers, but: when you have `for i = a to b`, you have `for i = a to b` and you need a whole lot more other things that will need to be taught as well, such as list comprehensions in Python.",0.14375,Python
14sbn35,jqxf5hw,"(I invented this kind of 'for' expression, in a post to comp.lang.lisp in the 90s where it was a Lisp macro called 'with'.",0.6,Lisp
14sbn35,jqxf5hw,Later it went into [my own Lisp](https://github.com/darius/cant) as 'for'.,0.3,Lisp
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,Ruby
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,Julia
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,Lisp
14sbn35,jqxi2l2,">It's used to demonstrate functions-as-values,  That was demonstrated by `d-dx` (another source of confusion: I haven't used minus signs inside identifiers since I wrote some COBOL.",-0.1,COBOL
14sbn35,jqxkwif,">(I invented this kind of 'for' expression, in a post to comp.lang.lisp in the 90s where it was a Lisp macro called 'with'  Yes I noticed that Lisp was also open-ended when it came to loops, with endless flexibility and possibilities (from looking at CLisp).",0.2375,Lisp
14sbn35,jr06ve7,"(My `head` and `tail` functions were named after the Haskell versions, but mine are not lazy.)",0.125,Haskell
14sbn35,jqzcs0w,"To give an example in a language I'm more familiar with, Haskell's `take`, which takes n amount of items from the start of a list and returns a new list of those items, is auto-curried.",0.3371212121212121,Haskell
14sbn35,jqzcs0w,"This is why most Haskell functions don't pass the ""object"" first (in this case the list) because it's the most likely to vary rather than being fixed.",0.27,Haskell
14sbn35,jqxwsy0,"The idea is only that if you wrote out the call by hand, it'd have a readability problem exactly like the readability problem of (Scheme)  ``` ((lambda (x y z) ...)    (compute-foo)    (compute-bar)    (compute-baz)) ```  which the `let` expression was invented to improve on.",0.125,Scheme
14sbn35,jqwxut3,"If I would pick a language to teach beginners for ease of teaching it would neither be Python, JS nor a functional language of any kind.",0.6,Python
14sbn35,jqyet2k,"Maybe that's how it works in languages like Lisp, but I'd implement loops using lower-level features, not higher-level ones.",0.0,Lisp
14sbn35,jqxqaql,"And from looking at open-source projects, it's not common elsewhere either (except programs written in Rust which seem to do little else except pattern-matching).",-0.018750000000000003,Rust
14sbn35,jr0janv,It means I can also do simple embellishments:      for i in range do         redo          # various multi-level loop controls         exit         next     else              # (from Python) execute on normal exit     end  It becomes harder to incorporate this stuff when the concept of iteration revolves around traversing some linear data structure instead of just existing independently.,0.008333333333333331,Python
14sbn35,jqz4fgo,"Going back to Pyret, from what I've read, the designers see equational reasoning about programs as a big deal and not just for the Haskell freaks who like big words like ""equational reasoning"".",0.0,Haskell
14sbn35,jqxudbq,Throwing someone head first in Scheme might be significantly harder than easing them into functional programming with Pyret.,0.075,Scheme
14sbn35,jqxudbq,However the question is whether it compares favourably with say Pascal or BASIC if the intention is *just to teach people the basics of programming*.,0.0,Pascal
14sbn35,jqxudbq,"If the intent is to later just use functional programming, then clearly using something like BASIC or Pascal would point people in the whole wrong direction – they'd have to do a 180 to get aligned with functional programming.",-0.039999999999999994,Pascal
14s9pnm,,"It seems to be common knowledge that the D compiler has very fast clean compile times, even though it's packed to the brim with language features.",0.10888888888888891,D
14s9pnm,,"**Question:** Are there any blog posts or articles digging into the design of the D compiler, or some of its implementation choices?",0.0,D
14s9pnm,,"There a handful of articles on the [official D blog](https://dlang.org/blog/), but they mostly don't cover compiler internals.",0.5,D
14s9pnm,,And the personal blogs of some of the D contributors seems rather sparse.,0.0,D
14s9pnm,jqxpuem,There's quite a lot of info on the compiler source on the D Wiki.,0.0,D
14rjg05,jqygp6g,"So like, TLDR, we can write C code to an API that generates code like the way LLVM does, but with more cowbell?",0.5,C
14rfz9f,jr9hcvp,"Rust also has exceptions, and they're very frequently used.",0.13,Rust
14rfz9f,jraenfd,"What would be ""Rust exceptions""?",0.0,Rust
14rfz9f,jrata2a,"Yes, Rust's panic is a form of unchecked exception, which can be caught with catch_unwind.",0.0,Rust
14rfz9f,jrata2a,It's essentially the same as in Java or C++.,0.0,Java
14rfz9f,jrata2a,It's essentially the same as in Java or C++.,0.0,C++
14re46t,,I’m considering utilizing C as a compilation target for an unannounced language;  1.,0.0,C
14re46t,,Any good libraries for building C Source?,0.7,C
14re46t,,Any good libraries aside from TinyC to compile the C into an Executable?,0.7,C
14re46t,jqrs2af,"This is my experience from a previous language that I've abandoned:  - C compilers don't like huge generated functions, had to use TinyCC to even able to compile (the self build of a compiler took about 2mins still, painfully slow for the development - don't try to selfhost too early) - the generated binaries were huge (I did inline some stuff but mostly things like refcounting and other small rudimentary stuff, still it added up a lot) - the performance boost (when I managed to compile it in GCC by splitting the huge functions) is not much unless your language is pretty much just C with a different syntax, you're still required to do your own optimizing compiler if you want performance gains - general linking with arbitrary function names (eg.",0.1387254901960784,C
14re46t,jqry4o4,My [language project](https://norstrulde.org/language84/) uses C as a target language.,0.0,C
14re46t,jqry4o4,"If you follow the “browse” links and look for files named “84_stable.c” and “c.84”, you can find the generated C code and the compiler component that writes it out for each release of the self-hosted compiler.",0.0,C
14re46t,jqry4o4,"At the start, I would put all of the generated C code into one giant C function with lots of labels and gotos.",0.0,C
14re46t,jqry4o4,"Later, I changed my approach to iteration and that made it easier to turn source functions into isolated C functions.",0.0,C
14re46t,jqry4o4,"One trick I found helpful was to use the C extensions provided by gcc and clang for things like arithmetic overflow checking, scoped labels, and statement expressions.",0.0,C
14re46t,jqrqv56,There are some very good Scheme implementations that compile to c like chicken.,0.15499999999999997,Scheme
14re46t,jqtqyi6,"I've used C as an optional backend (for when I want code to build on Linux instead of Windows, or make use of an optimising compiler).",0.0,C
14re46t,jqtqyi6,"When used as an IL for my own systems language, which although not much higher level than C, it still has enough mismatches:  * My `int` types, literals etc are `i64/u64`; C's literals are `i32/u32` * My string literals have a type roughly equal to `u8*`; C's strings are `char*`, but `char` is a type with unspecified signedness that is neither `i8` nor `u8` * If I want to use C's `puts()` say from my language, via its FFI, I will need to declare `puts` in my syntax using `u8*` equivalant.",0.11875,C
14re46t,jqtqyi6,"When transpiling those, the declarations have to be written as C syntax, but compilers will complain that my `puts(u8*)` doesn't match the standard library version.",0.125,C
14re46t,jqtqyi6,* My arrays have value semantics; C's arrays always decay to pointers * My syntax is expression-based (statements and expressions can be mixed).,0.0,C
14re46t,jqtqyi6,"C isn't, unless you target gnu C (as supported by gcc).",0.0,C
14re46t,jqtqyi6,"* C has lots of UB that can get in the way, for things that are well-defined in both my language and my intended targets (for example, signed integer overflow) * Many constructs in my language, like a 3-way comparison `if f()=g()=h()`, end up being evaluated twice or more in the C (`if (f()==g() && g()==h())`); these all need attention * I use new features like slices, multiple function returns, multiple assignment, which I simply haven't bothered with.",0.18939393939393936,C
14re46t,jqtqyi6,"(To transpile a program to C, I have avoid those features and many more) * All my records (structs) effectively use `pack(1)`, although the majority of fields are properly aligned.",0.4,C
14re46t,jqtqyi6,"* When generating C, the sizes of pointers are hard-coded as either 4 or 8 (or just 8 now as I only do 64 bits), so a particular C rendering can only be compiled as `-m32` or `-m64`, whereas proper C code will work as either * I sometimes use inline assembly.",0.041666666666666664,C
14re46t,jqtqyi6,"This is generally accepted, except for Tiny C where you have to use the ridiculous option `-fdollars-in-identifiers`.",-0.09444444444444444,C
14re46t,jqtqyi6,"* C has complex rules to do with mixed arithmetic, which in no way match mine.",-0.15,C
14re46t,jqtqyi6,My whole-program compiler will produce a one-file C rendering of the whole application.,0.2,C
14re46t,jqtqyi6,"There is already a problem where, after taking a few tens of milliseconds to produce the C, it will hit a brick wall as soon as gcc is invoked, but large inputs of tens of thousands of lines combined with `-O2` or `-O3` will make it even slower.",0.007142857142857131,C
14re46t,jqtqyi6,This is where Tiny C is a better match for the output of my compiler.,0.25,C
14re46t,jqtqyi6,"When someone else is responsible for compiling the resulting C, the results can vary.",0.2,C
14re46t,jqtqyi6,"My aims with generating C were mostly met (although it would cramp my coding style as I needed to use cruder features sometimes): I could run code on Linux, and optimisation usually gave a useful speedup.",0.18333333333333335,C
14re46t,jqtqyi6,"The generated C, while I made an attempt to keep it structured, mostly looked dreadful; the mangled names didn't help.",-0.25,C
14re46t,jqtqyi6,"I've also experimented with generating low-level, unstructured C code, with few of C's data types (eg.",-0.2,C
14re46t,jqtqyi6,"I even tried generating from a separate linear IL into C code, but that was awful - so many redundant temporaries and copies, that you *need* an optimising compiler to tidy it all up.",-0.024999999999999994,C
14re46t,jqtqyi6,"Here is my transpiler in action on a 40KLoc project `qq`; `tm` is a timing tool:      c:\qx>tm mm qq                       # Using direct native codegen     Compiling qq.m---------- to qq.exe     TM: 0.09          c:\qx>tm mc -tcc qq                  # Via C and Tiny C     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: tcc  -oqq.exe qq.c c:\windows\system32\user32.dll -luser32 c:\windows\system32\kernel32.dll -fdollars-in-identifiers     TM: 0.27          c:\qx>tm mc qq                       # Via C and gcc -O0     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: gcc -m64   -oqq.exe qq.c -s     TM: 6.36          c:\qx>tm mc -opt qq                  # Via C and gcc -O3     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: gcc -m64  -O3 -oqq.exe qq.c -s     TM: 49.51  If I need optimisation (the main reason I would do this on Windows), transpiling to C can take 500 times longer to build.",0.09166666666666667,C
14re46t,jqtqyi6,"But if this is your main way of getting a binary, then Tiny C is the best bet for routine builds unless your programs are small.",0.22916666666666669,C
14re46t,jqsh0ua,> Any good libraries for building C Source?,0.7,C
14re46t,jqsh0ua,"I used both llvm-ir (text) and C. I like the C code better but maybe it's because I wrote that second so it was less rough  I didn't use the tcc lib, I used the binary by spawning multiple processes",0.046666666666666676,C
14re46t,jqtybly,Somehow related: [a list of open source compilers that can generate C code](https://github.com/dbohdan/compilers-targeting-c).,-0.25,C
14re46t,js16hsm,"I have a [public domain 128 bit integer library](https://github.com/aeldidi/int128) which you can use if you want to do that, since C doesn't actually have 128 bit integers.",0.0,C
14re46t,jqs4g9l,"If your language matches C well, then it’s *fine*, as long as you really thoroughly understand the pitfalls of defined behaviour in C. It’s very helpful as a first step for getting something running and interoperating with other code.",0.1486111111111111,C
14re46t,jqs4g9l,"Still I do wish for a better “portable assembler”, because C isn’t quite it.",0.5,C
14re46t,jqs4g9l,"You can also use a C backend as a jumping-off point to start generating native code, or retargetable code (LLVM, JVM, CIL, whatever).",0.0,C
14re46t,jqtnsw8,">the generated binaries were huge (I did inline some stuff but mostly things like refcounting and other small rudimentary stuff, still it added up a lot)  That doesn't look like the fault of using C; presumably the generated C code was also huge?",0.18500000000000005,C
14re46t,jqv3tuf,"It also used generics implemented as specialized copies, that added a lot, but even without that the generated C code of the individual functions was big due to refcnts, handling of exceptions when calling functions and other small stuff that added up.",-0.1,C
14re46t,jqv3tuf,"But maybe the C compilers would handle calling a lot of inlined functions better than directly embedding it, I haven't tested that.",0.3,C
14re46t,jqv3tuf,The main problem is that the C optimizer can't optimize out redundant refcnt operations or other high-level things.,-0.052777777777777785,C
14re46t,jqv3tuf,And I think most people who want to output to C are in the mindset that they wouldn't need to care about optimizations by doing that.,0.5,C
14re46t,jqv3tuf,There was just generation of C code so I don't have a comparison unfortunatelly.,0.0,C
14rdg9d,jr1zb9g,"I'd be interested to see what his opinions are today on the extensibility of languages, and how both Scheme and Java have fared on growth here.",0.25,Scheme
14rdg9d,jr1zb9g,"I'd be interested to see what his opinions are today on the extensibility of languages, and how both Scheme and Java have fared on growth here.",0.25,Java
14rdg9d,jqtbjm7,Java is a brand name for a computer programming language.,0.0,Java
14rdg9d,jqtbjm7,I shall speak of The Java Programming Language™ a great deal more in this talk.,0.65,Java
14rdg9d,jqtbjm7,I have to say the full phrase The Java Programming Language™ for there is a guy who works where I do who deals with the laws of marks of trade and he told me I have to say it that way.,0.35,Java
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,Fortran
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,APL
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,Pascal
14rdg9d,jr2hzfz,"Obviously there is a peak, or an answer, to Gossling and Java community at the time, we should not forget that it was a time when Java was marketed heavily as a simpler (better) C++ by trashing some C++ features, in particular operator overloading and multiple inheritance.",0.09333333333333334,Java
14rdg9d,jr2hzfz,"Obviously there is a peak, or an answer, to Gossling and Java community at the time, we should not forget that it was a time when Java was marketed heavily as a simpler (better) C++ by trashing some C++ features, in particular operator overloading and multiple inheritance.",0.09333333333333334,C++
14rdg9d,jr2hzfz,"I don't know if Bjarne & Co have seen this talk and have taken a big note from it, but recent C++ development, C++ 11 and further seem to reflect what Steel is talking about big language, extending the language, so the new add-ons feel the same as the language itself, and so on.",0.022727272727272724,C++
14rc8yc,jqsousg,"Haskell for example, treats the variables as nullary functions, and therefore no distinction.",0.0,Haskell
14rc8yc,jqsb3bj,"Eiffel uses ""feature"" for pretty well exactly this purpose.",0.25,Eiffel
14rc8yc,jqumghg,"Symbol, taken from Lisp.",0.0,Lisp
14rc8yc,jr4gu4m,"In Scheme et al, an environment maps **symbols** to **values**.",0.0,Scheme
14ra832,jqr8iif,"Sure it has it's flaws, but I wanted to spend my time on language design not writing optimisers, and there is no other reusable backend with the same performance and transpiling to C is ugly and fragile.",-0.02749999999999999,C
14ra832,jqrc6vj,"I do sometimes use a C backend (although C makes a poor IL), but I know that in that case, the minimal dependency to turn that C into executable binary is under 0.25MB of the Tiny C compiler (a 1.6MB installation, but I only need 2-3 files of it).",-0.125,C
14ra832,jr21znr,"Big things like LLVM, Web Browser(HTML, CSS, js), OS-APIs, SQL (vs the actual relational model that is truly simple), C++, etc is that are BIG.",0.0,HTML
14ra832,jr21znr,"Big things like LLVM, Web Browser(HTML, CSS, js), OS-APIs, SQL (vs the actual relational model that is truly simple), C++, etc is that are BIG.",0.0,C++
14ra832,jr21znr,"And if you are making C++, LLVM, *THE* way.",0.0,C++
14ra832,jqryx4q,"Rust has some bindings for it, but then I couldn't fully work through documentation on how to use llvm either way.",0.0,Rust
14ra832,jqspcsh,"Rust does work on different backends, but these have rather low priority and are mostly not ment to replace the LLVM-backend.",-0.08333333333333333,Rust
14ra832,jqtzzay,"Well it seems to be the main bottleneck of several compilers including Zig, Crystal, Odin (and probably Rust)",0.08333333333333333,Crystal
14ra832,jqtzzay,"Well it seems to be the main bottleneck of several compilers including Zig, Crystal, Odin (and probably Rust)",0.08333333333333333,Rust
14ra832,jqrdxuc,Why transpiling to C is ugly and fragile?,-0.35,C
14ra832,jqr8l9x,They mostly compare it to other backends like C and gccjit,0.1875,C
14ra832,jqrsp2b,Nim transpiles to C quite successfully.,0.75,C
14ra832,jqtk2n7,The Rust compiler uses LLVM and it definitely isn't written in C++,0.0,Rust
14ra832,jqtk2n7,The Rust compiler uses LLVM and it definitely isn't written in C++,0.0,C++
14ra832,jqsaywh,"Can you expand a little more, is your compiler written in Rust and you also interface with cranelift using its Rust library API, i.e.",0.15625,Rust
14ra832,jqsrev7,"I feel like generating text as an internal representation is hard to do elegantly, and unless you want to hook into the AST of some C compiler you will be generating text.",0.06944444444444443,C
14ra832,jqsrev7,"And if you do, you essentially defeat the point as that C compiler will act like LLVM.",0.0,C
14ra832,jqsrev7,"Not only that, unless you are targeting one C compiler, on a single operating system, you will have to account for their differences, and write a lot of tedious logic that locates and calls the compiler.",-0.19047619047619047,C
14ra832,jqsrev7,"A final reason for my newest language is that I explicitly do not want some of C's UB, e.g.",0.0,C
14ra832,jqsrev7,Both of those things require more compiler specific hacks to implement on top of C.,0.3333333333333333,C
14ra832,jqs35iw,C is not the prettiest language to begin with first of all.,0.25,C
14ra832,jqs35iw,"A great example is the Koka language, if you look in the C headers and source files, almost everything is static and inline in order to not incur extra runtime overhead.",0.43333333333333335,C
14ra832,jqsryvf,"If you want to generate C, generate C, it's ugly, but it's an easy way to prototype when you are only targeting one platform and C compiler.",-0.08888888888888886,C
14ra832,jqvcb9i,their own C compiler backend,0.6,C
14ra832,jqu0259,A valid alternative is usually a C backend,-0.25,C
14ra832,jqtgmfu,[C--](https://en.wikipedia.org/wiki/C--) is another option it inspired Cmm in Haskell,0.0,C
14ra832,jqtgmfu,[C--](https://en.wikipedia.org/wiki/C--) is another option it inspired Cmm in Haskell,0.0,Haskell
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,Rust
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,Kotlin
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,Scala
14ra832,jqu8v55,"I think the characterization of C as ""ugly and fragile"" is _not_ a principled analysis - we should be talking more about some of the benefits you mentioned: expressiveness, performance, interop, distributability, binary size, debugability  and compile time of the target, and whether it was worth the pain.",0.02500000000000001,C
14ra832,jqs9q6l,Any inspiration from Holy C?,0.0,C
14ra832,jqtx0lg,"But... what will the Zig devs actually accomplish, with this R&D opportunity?",0.0,R
14ra832,jqtx0lg,"But... what will the Zig devs actually accomplish, with this R&D opportunity?",0.0,D
14ra832,jqtx0lg,"But then again, I'm not trying to write a C replacement.",0.0,C
14ra832,jqt4cit,"The other is that you end up with something you're happy with, but the community as a whole is less happy, a la like Graydon's talk about his vision for Rust.",0.30166666666666664,Rust
14ra832,jqsd6kf,Holy C of TempleOS?,0.0,C
14ra832,jqsd6kf,"No, my stuff was from much earlier than that (from '81), and actually I had nothing to do with C at all, until the 90s when it started turning up in APIs (specifically, Win16 API).",0.0,C
14ra832,jqrzpdo,> Debug build backend for the Rust compiler.,0.0,Rust
14r2pkq,jqv95hv,"HTML is in there as well, and I assume it's not a string?",0.0,HTML
14r2pkq,jqv95hv,It also outputs HTML and TS.,0.0,HTML
14r2pkq,jqvcx6n,Also the language implements an HTML-like variant it's not really HTML.,-0.1,HTML
14r2pkq,jqvcx6n,"The output is different languages because your app should eventually has a server (can be implemented using any language but I chose to compile to Node.js) and a client app (which should be HTML, CSS, and JS because that's what run on the browser).",0.0,HTML
14r2pkq,jqvezh5,"Check this todo app example built using the DSL: [https://github.com/algorizr/thoth/blob/main/examples/todo.thoth](https://github.com/algorizr/thoth/blob/main/examples/todo.thoth)  The code responsible for parsing HTML elements can be found here in the repo: [https://github.com/algorizr/thoth/blob/main/src/analyzer/parsing/helper.ml#L121](https://github.com/algorizr/thoth/blob/main/src/analyzer/parsing/helper.ml#L121)  Also, the code responsible for checking the UI code for any sementic errors can be found here: [https://github.com/algorizr/thoth/blob/main/src/analyzer/type\_checler/xra\_checker.ml](https://github.com/algorizr/thoth/blob/main/src/analyzer/type_checler/xra_checker.ml)  Sorry, the code is not documented and not very clean so it can be a little hard to read.",-0.3300213675213675,HTML
14qv5lp,,"- [How Rust solved dependency hell](https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell) - [Addressing the shortcomings of peer dependencies](https://hackmd.io/@dzearing/BJifNnpsq)  To be brief, have these issues been solved in dependency/package management, or is it still an open question?",0.0,Rust
14qv5lp,jqpj5gs,In C#/Nuget you get one version per library but with build time checks for possible compat issues.,0.0,C
14qv5lp,jqpjuz3,"Well, first off, my thesis of “it isn’t just Rust or JS that has this problem, you know”… I’m not going to call it conclusively demonstrated, but I’ve found some strong support and a couple decent counterpoints.",0.2833333333333333,Rust
14qv5lp,jqpjuz3,There are potentially a lot of unexpected dependencies hiding in even a quite small C program.,-0.049999999999999996,C
14qv5lp,jqpjuz3,"A medium-sized Rust project can easily tip the scales at 2-300 crates, which is still rather more dependencies than anything I’ve looked at here, but that’s explained by the simple fact that using libraries in C is such a monumental pain in the ass that it’s not worth trying for anything unless it’s bigger than… well, a base64 parser or a hash function.",0.13055555555555556,Rust
14qv5lp,jqpjuz3,"A medium-sized Rust project can easily tip the scales at 2-300 crates, which is still rather more dependencies than anything I’ve looked at here, but that’s explained by the simple fact that using libraries in C is such a monumental pain in the ass that it’s not worth trying for anything unless it’s bigger than… well, a base64 parser or a hash function.",0.13055555555555556,C
14qv5lp,jqqchsv,"Rust's Cargo is quite clearly well regarded, but it is complicated.",-0.19999999999999998,Rust
14qv5lp,jqqchsv,"For my language, I copied the principles of the Go package manager.",0.0,Go
14qv5lp,jqqgu26,Julia's dep management works great for me,0.8,Julia
14qv5lp,jqsrf2v,"For example if you have libA depending on libC v1.1 and libB depending on libC v1.2, in your approach the application that uses both A and B can not pass C typed objects between A and B, because the identifiers wouldn't match?",0.0,C
14qv5lp,jqy3chz,Fwiw here is the result in Rust.,0.0,Rust
14qv5lp,jqy3chz,"And once again, Rust error messages take the cake at letting you know what’s going on.",0.0,Rust
14qv5lp,jqt9zxt,"That is true, the application using both A and B would have to map the data between the two different versions of C. However, I would not recommend using something related to C when using A and B, A and B should stand on their own.",0.2375,C
14qv5lp,jreikpc,A language can also go further than Rust does to support this.,0.0,Rust
14qn9of,jqqlomc,\> No parser   \> Just start with the AST     So... Lisp.,0.0,Lisp
14qc538,jqn7w3d,Something like what you have here combined with TypeScript's type narrowing?,0.0,TypeScript
14q21pz,jqlaati,https://godbolt.org is my favorite for C,0.5,C
14pzzs6,jqnnl2d,I think Lua is a good example of doing documentation well.,0.7,Lua
14pzzs6,jqnnl2d,"[The API is documented in a single HTML file on the website](https://www.lua.org/manual/5.4/manual.html) that has both the high level descriptions of the language and architecture, as well as documentation for each public-facing function.",0.04428571428571429,HTML
14pzzs6,jqlswwc,I think your Rust example is a good example of documentation that \*doesn't\* clutter the code unduly.,0.7,Rust
14pzzs6,jqmwwjd,"Either way, one thing to learn from the Rust documentation project may be ways to automate testing of code samples in docs so they stay in sync as the code evolves.",0.0,Rust
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,Rust
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,Python
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,C
14pzzs6,jqouds0,"I do this a lot more for Python than other languages (since doc comments break up the function definition and implementation, annoying) but it can help make it less spaced out.",-0.14791666666666667,Python
14pzzs6,jqpb6oy,"Haskell can infer most of the types, people really do write them into the code mostly as a means of documentation because they're that useful, and can say a lot more than you can in English with significantly-fewer characters and significantly less room for (mis)interpretation.",0.2619047619047619,Haskell
14psfd7,,"(DRY = Don't Repeat Yourself)  This is a bit of C code I encountered today:      uint64_t maxOR(uint64_t a, uint64_t b, uint64_t c, uint64_t d) {         ....     }  The problem for me is that declaration: 4 parameters, all with the same type, but the type has to be written 4 times.",-0.033333333333333326,C
14psfd7,,"This style is common across lots of languages, but C has that extra-cluttery typename, so that I can barely make out the parameter names.",-0.125,C
14psfd7,,"C could at least have gone with `u64`:      u64 maxOR(u64 a, u64 b, u64 c, U6 d) {             # (typo left in)  Now it is much less objectionable, but I would have gone further to:      u64 maxOR(u64 a, b, c, d) {  While C is a lost cause, I wonder why other languages do this as well: create extra maintenance, extra things to check, extra things you can get wrong (one of those types could have been `int64_t` \- not easy to spot in that sea of `uint64_t`).",-0.13083333333333336,C
14psfd7,,"Funnily enough older C allowed you to do this, or along these lines:      u64 maxOR(a, b, c, d) u64 a, b, c, d; {  In my own syntaxes, it usually something like:      func maxor(u64 a, b, c, d)u64 =                # `=> u64` is optional  Types are only repeated when there are no parameter names (as in, FFI declarations, but I can choose to add names to enable keyword parameters).",0.10333333333333332,C
14psfd7,jqjtzp8,Eiffel manages this.,0.0,Eiffel
14psfd7,jqkp1uh,"Go has this:      func(a, b int, z float64) bool { return a*b < int(z) }  In this example, `a` is also type `int`.",0.0,Go
14psfd7,jqlmgw6,"if you're willing to use C++ you could avoid the repeated explicit types  auto maxOR(uint64\_t a, decltype(a) b, decltype(a) c, decltype(a) d) -> decltype(a) {  // return type same as param 'a' type  (even though it's more typing as in input device and just making them all template params of a single typename T would probably make more sense)",0.2357142857142857,C++
14psfd7,jqqp0gu,"And as usual, this has been true since Algol times, but C screwed it up, maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something.",-0.0638888888888889,C
14psfd7,jqqp0gu,"Much as I love C, it is cluttered and inconsistent as few other languages (most of C's own deplorable descendants aside, of course.)",0.11249999999999999,C
14psfd7,jqqp0gu,"And don't get me started on declarators, qualifiers, specifiers, storage classes, attributes, initializers and whatever - suffice it to say that C's declaration syntax is just abominable in general.",0.05000000000000002,C
14psfd7,jqsxijw,"Changing the language's notation may be an option in Perl, but it is not an option for me.",0.0,Perl
14psfd7,jqk2pvr,"In C, four struct members with identical types, followed by one of a different type to address your other point, could be written like this:      struct {         uint64_t a, b, c, d;         int64_t  e;     }  Unless you specifically wanted one member per line (for example if the members weren't related), you wouldn't use separate types like this:      struct {         uint64_t a; uint64_t b; uint64_t c; uin64_t d;         int64_t  e;     }  At least, the choice is there.",-0.10625,C
14psfd7,jqk2pvr,"With mixed types, I still use a comma separator between them (just as C does actually); I could have made it stronger with a semicolon, as used the top struct example.",0.16666666666666666,C
14psfd7,jqk2pvr,"I'd write that as this (here I've chosen to use capitalisation to mark the types better; it is case-insensitive):      proc pout(Int n, j, k, Real x1, x2, x3, x4) =  In C however it would be:      void pout(int n, int j, int k, double x1, double x2, double x3, double x4) {  Which is more readable?",0.17142857142857143,C
14psfd7,jqk3m84,I think Pascal and Ada would be similar to this.,0.0,Pascal
14psfd7,jqk3m84,I think Pascal and Ada would be similar to this.,0.0,Ada
14psfd7,jqmtw9v,"Here is C's famous `for`\-loop which for some inexplicable reason, every other language likes to copy:      for(index = 0; index < N; ++index) {...}  Notice THREE instances of the loop index variable, with two needless repetitions!",-0.2125,C
14psfd7,jqqxvnv,">maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something  It shouldn't be hard in C, or any harder than it normally is to parse types that wrap themselves around names, since it will know exactly what every identifier is when encountered.",-0.056666666666666664,C
14psfd7,jqqxvnv,"&#x200B;  >Much as I love C,  You do?",0.5,C
14psfd7,jqqxvnv,"We need such language, but C is a very poor example of it.",-0.26,C
14psfd7,jqqxvnv,This is legal C:      long unsigned const const int typedef long const const T;  It defines T as an alias for `const u64`.,0.03333333333333334,C
14psfd7,jqqxvnv,"Thinking of it, C legalises repetition in several places:      int a, a, a, a, a, a;         // at module scope          void F(int a, int b);     void F(int a, int b);         // parameter names can match ...     void F(int c, int d);         // ... or not     void F(int b, int a);         // ... or be switched     void F();                     // or just forget about them          const const const int;        // like my earlier example     L1:; int L1; goto L1;         // L1 is a variable AND a label!",0.0,C
14psfd7,jqqxvnv,But taking pot-shots at C is too easy (and too much fun).,0.3666666666666667,C
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,TypeScript
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,Rust
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,Elm
14piaj7,jqio7u8,"Maybe that `<=` is wrong; changing it to `>=` makes it work, but it goes wrong now with `A + B + C`.",-0.5,C
14o068e,jqc1q2j,in JavaScript they are kind of similar—because it's a dynamic language with first-class functions/closures—but not the same).,0.19999999999999998,JavaScript
14o068e,jqc1q2j,"In a language like JavaScript, you can nest function definitions, but you are allocating memory if you do so!",0.0,JavaScript
14o068e,jqa94gs,"Haskell pretty much does this (in a roundabout way): [edited this part out to to inaccuracy]  Using that philosophy, your `main` could look like this:      // The ""null"" program: exits immediately with code 0     // main has type: Int     main = 0  Using a more complex example:      // Says ""hello"" to the first provided argument, or exits with code 1     // main has type: [String] -> Int     main args: [String] = match (first_of args):         Some name:             println (concat ""Hello, "" name)             exit 0         None:             exit 1  Defining a type (here `Option t` is the ""type"" and `Some t`/`None` are the constructors and possible values):      type Optional t:         Some t | None          foo = Some 3 // Has type ""Option Int"" and value ""Some 3""     bar = None // Has type ""Option t"" for any type ""t"" and value ""None""  Defining a typical function:      // Square has type: Int -> Int     square n: Float = n*n  Defining a typical variable:      pi = 3.14159 //...",-0.053125000000000006,Haskell
14o068e,jqa94gs,"There are many ways to go about it, this syntax is just an example of Haskell's semantics that I've adapted into a Python-esque indent-based syntax style.",0.5,Haskell
14o068e,jqarqkc,Scala 3 also supports classic brackets as well as a custom indent-based syntax.,0.16666666666666666,Scala
14o068e,jqafpqw,"I don't think it's bad, it's not unlike JavaScript in a way, so it's not necessarily unfamiliar.",-0.3499999999999999,JavaScript
14o068e,jqana0u,It can easily be desugared from the C syntax into an assignment.,0.43333333333333335,C
14o068e,jqa7dtq,"In Scheme, `(define (f args) body)` is really just syntactic sugar for `(define f (lambda (args) body))`.",0.2,Scheme
14o068e,jqaonfj,"> Haskell pretty much does this (in a roundabout way): Everything is a function (even single values), and ""types"" are just special kinds of functions (functions that ""hold on"" to their arguments for later de-structuring).",0.14714285714285716,Haskell
14o068e,jqaonfj,"Normal ""variables"" are also just functions, so in a roundabout way everything is a variable in Haskell.",0.15,Haskell
14o068e,jqaonfj,"Not everything is a function in Haskell, certainly not single values (`""foo""` isn’t a function, it’s a string).",0.03571428571428571,Haskell
14o068e,jqaonfj,"It’s somewhat more accurate to say “everything is a _value_ in Haskell”, since functions are values, but even that isn’t very helpful really since there are plenty of non-value concepts in the language.",0.325,Haskell
14o068e,jqbtbbc,Haskell only allows this at the top level.,0.25,Haskell
14o068e,jqaggnr,"Another angle: would you consider Python to be a language where ""everything is a variable"" like this?",0.0,Python
14o068e,jqb9ex6,I consider Python a language where every top-level user identifer (ie.,0.0,Python
14o068e,jqb9ex6,This is what makes Python somewhat difficult to optimise.,-0.5,Python
14o068e,jqb9ex6,"The only names in Python you can't change are the keywords, and anything else that is a hard-coded built-in.",0.0,Python
14o068e,jqbsg16,"In Scheme, everything is a *value*, including the symbols themselves.",0.0,Scheme
14ngaly,jqca2ti,"I've been chipping away at the (bytecode) compiler, which is *significantly* faster than the (written in Python) interpreter -- and since I'm out of Python-land I can actually do deep recursion.",0.1875,Python
14ngaly,jqca2ti,"I wrote the compiler in D -- not because I know or have a great affinity for D, but because I wanted something familiarly C-ish but with niceties like less pointer chasing, dynamic arrays, and strings that make sense -- but I'm starting to feel the pain of writing something in a less-well-known host language, and so started something in C++ for static analysis to both practice and see if that's a better option.",0.2869047619047619,D
14ngaly,jqca2ti,"I wrote the compiler in D -- not because I know or have a great affinity for D, but because I wanted something familiarly C-ish but with niceties like less pointer chasing, dynamic arrays, and strings that make sense -- but I'm starting to feel the pain of writing something in a less-well-known host language, and so started something in C++ for static analysis to both practice and see if that's a better option.",0.2869047619047619,C++
14ngaly,jq7bdod,I'm rewriting everything in Haskell as I couldn't stop thinking that something can be incredible wrong with the python code I wouldn't know until it is a problem.,0.2,Haskell
14ngaly,jq7bdod,"Right now I have almost ported the parser, 150 grammar rules from python to Haskell!",0.3571428571428571,Haskell
14ngaly,jq8hffa,"For example, I have written a small tool which takes C Headers as input and produces glue code to call them from my lang.",-0.25,C
14ngaly,jq9wcbd,Realised I was just reinventing a worse version of Rust.,-0.4,Rust
14ngaly,jqikc4o,[https://github.com/Gwenio/abyss-lisp](https://github.com/Gwenio/abyss-lisp)  A Lisp based on Kernel.,0.0,Lisp
14ngaly,jqb41jz,"I'm working in Ruby so creating a whole DSL for my ideas is pretty simple, plus it makes everything go very smoothly from one part of the compiler to the other.",0.16899999999999998,Ruby
14ngaly,jqmrxur,"Timings include transpilation to C, but that is insignificant.",0.0,C
14ngaly,jqmrxur,"(I'm no longer able to transpile M6 to C, so the build-times above could have been even better, but since no app takes longer than 0.1 seconds to build, I wouldn't notice in practice.",0.3333333333333333,C
14ngaly,jqmrxur,**EDIT**: I've managed to transpile `mm6.exe` (M6 compiler) into C and therefore to optimise it via `gcc-O3`.,0.0,C
14ngaly,jqmrxur,Build-times for these apps are now up to 700 times faster than `gcc-O3` building C renderings of those same apps.,0.0,C
14ngaly,jqsr0lp,"Previously it was implemented in Rust, and a tenant of a different experimental language/VM called Rail with different semantics and goals.",-0.016666666666666663,Rust
14ngaly,jqsr0lp,Moving from Rust was motivated by the ease of cross-compiling and the relative tiny-ness of the produced executables.,0.0,Rust
14ngaly,jqxcrhf,"I already dabbled in a simple Lisp-y thing in Rust (an interpreter) and then got to somewhere halfway through Writing a Compiler in Go (in Golang, just keeping the syntax Lisp-y)  As I am going to have afternoons free for the next two weeks, I decided to pick this idea up.",0.13333333333333333,Rust
14ngaly,jqxcrhf,"I already dabbled in a simple Lisp-y thing in Rust (an interpreter) and then got to somewhere halfway through Writing a Compiler in Go (in Golang, just keeping the syntax Lisp-y)  As I am going to have afternoons free for the next two weeks, I decided to pick this idea up.",0.13333333333333333,Go
14ngaly,jqgxsod,"I've also done a bunch to clean up the internals, and Sophie is now available on the command-line without mentioning Python thanks to some packaging goop, which is nice for usability.",0.3916666666666667,Python
14ngaly,jqm37of,"So far my IR is pretty simple, but can be used to implement a subset of C, the next things i want to add are floating point numbers, malloc/free built-ins, global register allocator and eventually FFI.",0.06999999999999999,C
14ngaly,js2ri3a,If interested you can find the [constraint gathering code in C# here](https://github.com/cdiggins/plato/blob/main/PlatoAst/Constraints.cs).,0.25,C
14ngaly,jswo747,Wrote a summary here:  https://jevko.github.io/writing/2023-07-20-lambda.html  Also recently ported my little lambda-calculus-based language to from JS to C: https://codeberg.org/xtao-org/last.c  Been fun debugging the minimal refcounting garbage collector.,0.003124999999999996,C
14ngaly,jswo747,;D,0.25,D
14ngaly,jt322uh,"I'm thinking about implementing a language... (which, if successful, will serve as a second language to my Lua game framework Lyte2D.)",0.11666666666666665,Lua
14ngaly,jt322uh,I'm torn between Python and TS.,0.0,Python
14ngaly,jt322uh,Leaning towards Python syntax.,0.0,Python
14ngaly,jrl870h,I've just done something else that I should have done long ago: cut most ties with the C language.,0.225,C
14ngaly,jrl870h,That language can come up when dealing with APIs; when trying to build open source stuff; when used as a transpiler target; comparing benchmarks between my language and C; when optimising my apps via the transpiler (see the EDIT PS of my first post).,0.125,C
14ngaly,jrl870h,"So, I've deleted the various C compilers I had lying around: gcc, tcc and Clang, although that last barely worked.",0.016666666666666666,C
14ngaly,jrl870h,"I've archived my `mc` transpiler (M to C compiler), which already only existed in an older compiler version, and which didn't support the full M language.",0.1722222222222222,C
14ngaly,jrl870h,"I will still retain my own `bcc` C compiler, but that's of little help in either optimising, or working on Linux!",0.1828125,C
14ngaly,jrl870h,It includes an option to do the bulk of the work in translating some C APIs into my syntax.,0.0,C
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,C++
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,C
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,TypeScript
14ngaly,jt42vke,I'm torn between Python and TS.,0.0,Python
14ngaly,jt42vke,Leaning towards Python syntax.,0.0,Python
14ng0eq,jq8a2qd,Does anyone know of an implementation for Rust ?,0.0,Rust
14neutn,jqag99u,Scheme is lovely.,0.5,Scheme
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Go
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Objective-C
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Swift
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Rust
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Java
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,C
14n9a4g,jq6ehdb,"Ruby, as a language, was *fine*, but Ruby on Rails made it *wildly popular*.",0.5083333333333333,Ruby
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,C
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,C++
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,Objective-C
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,PHP
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,R
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,Lua
14n9a4g,jq9579b,"Popularity isn't all of it: the difference between what you achieve privately and a monster language like C++, say, with its vast choice of implementations, tools and libraries, is like that between a home movie and a $100m Hollywood production that employs a crew of a thousand.",0.0,C++
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,C
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,Java
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,Go
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,Rust
14n9a4g,jqc515c,Though Lua is perhaps not the best example because it wasn't aimed at the niche they found.,1.0,Lua
14n9a4g,jqc515c,"It was designed as a general-purpose scripting language but someone at Lucasfilm Games read about it in Dr Dobbs' Journal and thought it was way better than their in-house scripting language, and so Lua got into gamedev and it sort of snowballed.",0.5,Lua
14n9a4g,jqgr4m9,I trust it's more interesting than Paul Graham's claim that Lisp was the magic sauce behind getting Yahoo to buy him out?,0.275,Lisp
14n9a4g,jq6itm8,"It's worth mentioning that various ""web"" languages, such as Python and Ruby, didn't have corporate sponsors initially.",0.06,Python
14n9a4g,jq6itm8,"It's worth mentioning that various ""web"" languages, such as Python and Ruby, didn't have corporate sponsors initially.",0.06,Ruby
14n9a4g,jq6itm8,"Guido didn't go to work for Google and get their support, until a fairly long time into Python's history.",-0.05,Python
14n9a4g,jqoxa9m,"Go read old BYTE magazines, there were ads for compilers back then!",0.05,Go
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,Swift
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,Go
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,Rust
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,C
14n9a4g,jqoxa9m,"- Java was started as an _inducement_ to a Sun employee to remain at the firm, basically a bribe -- ""do whatever you feel like so long as you stay here"".",-0.125,Java
14n9a4g,jqoxa9m,"I would generalize this to ""most R&D""; almost always it's started outside company planning -- government or academic labs, occasional personal projects -- and companies join in funding once it's already underway.",0.1,R
14n9a4g,jqoxa9m,"I would generalize this to ""most R&D""; almost always it's started outside company planning -- government or academic labs, occasional personal projects -- and companies join in funding once it's already underway.",0.1,D
14n9a4g,jq69rtt,"If you measure success by having as much adoption as newer languages like C# or Swift, your odds are going to be very low without a major backer.",0.140625,C
14n9a4g,jq69rtt,"If you measure success by having as much adoption as newer languages like C# or Swift, your odds are going to be very low without a major backer.",0.140625,Swift
14n9a4g,jqew37k,"[There's a nice writeup of the history on Lua's website if anyone wants more of the story, which is pretty interesting](https://www.lua.org/history.html).",0.3875,Lua
14n9a4g,jqjmknq,"Another part of the story that's important, is **LuaJIT** was primarily responsible for game industry popularity, and it is not part of the core Lua development.",0.0666666666666667,Lua
14n9a4g,jqjmknq,"Whereas, Lua devs' primary goal was to be easily embedded on all platforms.",0.4166666666666667,Lua
14n9a4g,jqjmknq,"Because they did not agree on goals, and architecture necessary to achieve the different goals, Lua did not incorporate LuaJIT performance increases.",0.0,Lua
14n9a4g,jqjmknq,They were compatible at Lua version 5.1 and then the 2 developments went their separate ways.,0.0,Lua
14n9a4g,jqjmknq,"Meanwhile Lua proper is on version 5.4.6, with 5.1 being quite awhile ago in the Lua rear view mirror.",0.0,Lua
14n9a4g,jqjmknq,Lua also doesn't attempt to retain backwards compatibility.,0.0,Lua
14n9a4g,jqjmknq,This prevents any long term ecosystem from stabilizing around Lua.,-0.05,Lua
14n9a4g,jqjmknq,"Like to the extent game devs care about Lua, they're likely to use 5.1 forever.",-0.2,Lua
14n9a4g,jqjmknq,"Personally as a lone wolf indie game developer, I pretty much gave up on the idea of Lua 1) because its ecology is rearguard and will never amount to anything, and 2) I personally can't think about 3D math in terms of Lua.",0.008333333333333331,Lua
14n9a4g,jq6g6gq,"*Or*, they might get some new corporate suit manager who cuts costs, hires new people, and orders everybody to rewrite everything in C++.",0.0909090909090909,C++
14mno1w,jq6m8ml,"As if that wasn't enough, most of the comments in the issue thread are clear that low-friction integration with C++ builds is a big part of why many people are using Zig.",0.22000000000000003,C++
14mno1w,jq3n5vl,"There's no way I am porting the entirety of LLVM, it's dependencies and a C++ compiler.",0.0,C++
14mno1w,jq6485u,"Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,Go
14mno1w,jq6485u,"Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,C
14mno1w,jq6485u,And it's usually compared to Java which had/ has decades of more speed optimizations behind it.,-0.05000000000000001,Java
14mno1w,jq6485u,Yet I have seen no complaints that Go is slower than Java.,0.0,Go
14mno1w,jq6485u,Yet I have seen no complaints that Go is slower than Java.,0.0,Java
14mno1w,jq6485u,LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C
14mno1w,jq6485u,LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C++
14mno1w,jq6485u,"Lastly, I'm really interested to see how the C interop will go.",0.25,C
14mno1w,jq6485u,Their easy inclusion of C files was a big selling point early on.,0.17777777777777778,C
14mno1w,jq7fwgb,"Haven't seen it mentioned anywhere, but one solution for not having to deal with C++ compilation is to simply compile LLVM to WebAssembly and convert it back to C.  Mozilla already uses that approach for sandboxing ([link](https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/)).",0.0,C++
14mno1w,jq5rtoo,"He wrote the Datalight C compiler from scratch, including the codegen back-end.",0.0,C
14mno1w,jq5rtoo,"That same back-end has been in a lot of different compilers, including the Symantec C++ compiler which also holds the distinction of being the first compiler to turn C++ directly into a binary format without first transpiling to C.  This codegen back-end has been actively maintained and updated since the 1980s and is now part of the Digital Mars C++ compiler, and the reference compiler for D (also created by Walter).",0.06666666666666667,C++
14mno1w,jq5rtoo,"That same back-end has been in a lot of different compilers, including the Symantec C++ compiler which also holds the distinction of being the first compiler to turn C++ directly into a binary format without first transpiling to C.  This codegen back-end has been actively maintained and updated since the 1980s and is now part of the Digital Mars C++ compiler, and the reference compiler for D (also created by Walter).",0.06666666666666667,D
14mno1w,jq5rtoo,"Impressive as all that is, it didn't take long for people to lift the front-end from the reference D compiler and slap it on top of both LLVM and GCC back-ends, and within the D community it's generally preferred to use either LDC (LLVM D Compiler) or GDC (GNU D Compiler) when deploying code to production because they both have better optimization, cross-compilation support, more arch targets, and are just generally more feature-rich.",0.42857142857142855,D
14mno1w,jq5yx74,The C backend is not the replacement backend.,0.0,C
14mno1w,jq5yx74,"LLVM does not have a C backend, that's an extra bonus that zig offers.",0.05,C
14mno1w,jq5hwlh,"To be fair, ""delegate everything to the C compiler"" is easier than integrating with LLVM in the first place.",0.475,C
14mno1w,jq5s4xf,C++ is still fumbling with const/constexpr/consteval.,0.0,C++
14mno1w,jq6qbia,Java isn't somehow the gold standard here.,0.0,Java
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,Go
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,C
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,C++
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,Rust
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,C
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,C++
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,Go
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,Java
14mno1w,jq6qbia,"Some of Go's slowness is due to language specification decisions which cannot be amended now \[1\], but a *lot* is due to reinventing optimizations that other compilers have had for years, and Zig is currently enjoying via LLVM even if LLVM integration itself takes some work.",0.03125,Go
14mno1w,jq6qbia,"That's *despite* Go having Google's weight behind it, and a huge Go footprint at Google making a ripe target for optimization with ROI.",2.7755575615628914e-17,Go
14mno1w,jq6qbia,"It's also part of why idiomatic Rust *can be* faster than idiomatic C, because it's like having the speed of `restrict` everywhere with none of the UB.",0.0,Rust
14mno1w,jq6qbia,"It's also part of why idiomatic Rust *can be* faster than idiomatic C, because it's like having the speed of `restrict` everywhere with none of the UB.",0.0,C
14mno1w,jq8u5gg,>  Their easy inclusion of C files was a big selling point early on.,0.17777777777777778,C
14mno1w,jq8u5gg,Zig being a drop-in replacement for your entire C++ toolchain is *still* one of the three major selling points advertised on the website.,0.03125,C++
14mno1w,jqkofc3,"> Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,Go
14mno1w,jqkofc3,"> Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,C
14mno1w,jqkofc3,And it's usually compared to Java which had/ has decades of more speed optimizations behind it.,-0.05000000000000001,Java
14mno1w,jqkofc3,Yet I have seen no complaints that Go is slower than Java.,0.0,Go
14mno1w,jqkofc3,Yet I have seen no complaints that Go is slower than Java.,0.0,Java
14mno1w,jqkofc3,Go prioritizes compiler speed over final executable speed.,0.0,Go
14mno1w,jqkofc3,Using LLVM would be a non-starter for them (see Rust).,0.0,Rust
14mno1w,jqkofc3,Zig on the other hand wants to be a sort of competitor to C. And being a competitor to C means that you need fast executables.,0.09166666666666667,C
14mno1w,jqkofc3,C is spoiled with a ton of work being put into optimizing compilers.,0.0,C
14mno1w,jqkofc3,> LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C
14mno1w,jqkofc3,> LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C++
14mno1w,jqkofc3,It’s filled with people who are complaining that their multi-language projects (including C++) rely on Zig’s current compiler architecture.,0.2,C++
14mno1w,jq97mwp,I do something of the sort by having a path to generate C source code.,0.0,C
14mno1w,jq97mwp,"Then I can apply `gcc-O3`, or I can even get Clang, which just about works (it doesn't have working standard C headers, or a linker), to generate LLVM IR.",0.0,C
14mno1w,jq5rw4a,"Just targeting LLVM text IR (similar to what llvmlite does in Python) is just text generation, and can still be fed into LLVM tools or the API via IR parsers.",0.0,Python
14mno1w,jq5rw4a,"But, it decouples you from troubles of linking and versions of the LLVM C++ codebase.",0.0,C++
14mno1w,jqknlv8,There’s also the advantage that C++ has that you have more control over your API by having to explicitly declare it “const” (_edit_: or maybe I’m thinking of “constexpr”?).,0.5,C++
14mno1w,jqknlv8,(It goes without saying: doing something better than C++ is not an achievement in current year.),0.25,C++
14mno1w,jwcm3hn,Switching from debug to release builds in C++ can alone gain an order of magnitude in performance - and all you had to do was flip a switch in the compiler.,0.0,C++
14mno1w,jqr2ce0,So that maps semantically to unsafe C functions dealing with void\* parameters.,0.0,C
14mno1w,jqr2ce0,"The ""how"" is a separate concern - in other mainstream languages such as Rust there is a duplicated mechanism within the language: ""generics"".",-0.0625,Rust
14mno1w,jqr2ce0,"For example, instead of a separate \`where\` clause mechanism as in Rust, it could be  done much more ergonomically IMO if we simply had Zig's \`comptime\` combined with DBC (design-by-contracts).",0.25,Rust
14mno1w,jq64i5n,"You’re limited by what the hardware and OS let you do, and they’re heavily influenced by C, so the only way of going “faster than C” is to address a *limitation* imposed by C that makes it hard to write a fast program conveniently/correctly/reliably/&c.",-0.07261904761904761,C
14mno1w,jq96jj5,"I think partially Andrew Kelley could have worded the proposal better (putting proposal in the title, not using future tense such as ""this will remove C++ compilation""), and partially they are getting the feedback they asked for.",-0.00555555555555555,C++
14mno1w,jqdniwa,Yet I do still have a path (via a C backend) to optimise *some* programs (since the translation is not 100%).,0.0,C
14mno1w,jq8bc6v,It might take many years to gain parity with all possible use cases of a C replacement.,0.25,C
14mhu3o,,"These types function similarly to how they work in TypeScript, so if you've ever wanted to know more about how TypeScript's type system works this might be helpful.",0.25,TypeScript
14mhu3o,jq78ltw,"I was just talking about how they function in the type checker, TypeScript style unions.",0.0,TypeScript
14mhu3o,jq3g2bq,"Consider:      class A a     class B b     class (A c, B c) => C c      baz :: (A c, B c) => (c -> c) -> c -> c      quux :: C c => c -> c  Where we want to be able to use a value of the type `C c => c -> c` where type `(A c, B c) => c -> c` is expected - eg, call `baz quux`, but we don't want to allow a value of `(A c, B c) => c -> c` to be used where `C c => c -> c` is expected.",-0.11249999999999999,C
14m98qv,jq0s9gk,"`a := []int{}`  `b := [10]int{}`  `c := map[string]string{}`  I've given up trying to understand the decisions that drove Go's design, I just use the recommended practices at this point.",0.0,Go
14m98qv,jq1rvy5,"`v := make([]int, 10)` is shorthand for      var v []int     {         var tmp [10]int         v = tmp[:]     }  while `v := make([]int, 0, 10)` is short for      var v []int     {         var tmp [10]int         v = tmp[:0:len(tmp)]     }  Because slices are so common in Go, `make` is an extremely useful convenience.",0.125,Go
14lcvm1,jpy89b2,The C programming language has five decades of backwards-compatible cruft layered on.,0.0,C
14lcvm1,jpy89b2,"You can't make silk purse from a sow's ear, and you can't test quality into a system, and you can't call C a tool-chain that provides any assurance of reliable or safe software.",0.5,C
14lcvm1,jpy89b2,"I mean it may look like C, but any nontrivial property is undecidable.",-0.3125,C
14lcvm1,jpxdgsw,"There are high-quality C parsers (e.g., libclang), so it makes no sense not to just use those.",0.0,C
14lcvm1,jpxdgsw,"It’s a worthy discussion, since some languages (e.g., C++) are not context-free.",0.3333333333333333,C++
14lcvm1,jq0jzxi,Im going to deanonymize myself with that but here it is :D  [https://mlsec.org/docs/2023-eurosp.pdf](https://mlsec.org/docs/2023-eurosp.pdf),1.0,D
14k9c5x,jpr1ry2,are handled by the underlying Fortnite game engine (presumably written mostly in C++).,0.04999999999999999,C++
14k3frc,jpq54j8,:D so it's like a C on your A-F tier [ranking](https://www.youtube.com/watch?v=AzLqTgC0E0s)?,1.0,D
14k3frc,jpq54j8,:D so it's like a C on your A-F tier [ranking](https://www.youtube.com/watch?v=AzLqTgC0E0s)?,1.0,C
14k3frc,jprtgib,"Check out Mercury if you haven't already, it's a blend between Prolog and Haskell including support for linear types and typeclasses.",0.0,Prolog
14k3frc,jprtgib,"Check out Mercury if you haven't already, it's a blend between Prolog and Haskell including support for linear types and typeclasses.",0.0,Haskell
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Lisp
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,C
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Haskell
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,C++
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Rust
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Python
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Forth
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,D
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Java
14j52c8,jplonyh,C++ uses `FT CT::*` for a reason.,0.0,C++
14iz6jf,,I'm working on a *“TypeScript but better”* type of language.,0.5,TypeScript
14iz6jf,,"The language would get statically typed errors for free, with better support for error subtyping than Rust's monad-based *Result* as a bonus.",0.45,Rust
14iz6jf,,"If I tell them to use monads or effects for state mutations, most of them will just return to JavaScript land instead.",0.5,JavaScript
14iz6jf,jpkchd1,">this isn't really OOP  There [doesn't seem to be consensus](https://doc.rust-lang.org/book/ch17-00-oop.html) whether Rust is OOP or not – it lacks inheritance, but has instantiation, delegation, limited encapsulation, etc.",0.0642857142857143,Rust
14iojtb,jpi7ceb,IMO it is executed much better than yours because Lisp is a much better suited language.,0.5,Lisp
14iojtb,jpics4d,"I never used Lisp, but I'll check it out for sure!",0.625,Lisp
14iojtb,jpidn1a,"However, the concept applies to UI quite gracefully, so consider using a Lisp next.",0.0,Lisp
14ic9c8,jpgcylu,"Information about which libraries are used (like, the standard C library containing the `printf()` function) is stored differently, and those libraries are stored in different locations in your file system.",0.0,C
14ic9c8,jpgcylu,"Alternately, you could do like Java does it: Compile to some bytecode, and then have a bytecode interpreter or JIT-compiler that translates the bytecode to each platform.",0.0,Java
14ic9c8,jpgca7n,"It's maybe not quite what you meant, one count argue Python and Lua scripts can also be run on any computer that has the interpreter installed, but JVM languages are still compiled and most machines have the interpreter installed, so it runs everywhere in practice.",0.5,Python
14ic9c8,jpgca7n,"It's maybe not quite what you meant, one count argue Python and Lua scripts can also be run on any computer that has the interpreter installed, but JVM languages are still compiled and most machines have the interpreter installed, so it runs everywhere in practice.",0.5,Lua
14ic9c8,jpk105w,"This class of languages includes everything from Python to Java, depending on what you need.",0.0,Python
14ic9c8,jpk105w,"This class of languages includes everything from Python to Java, depending on what you need.",0.0,Java
14ic9c8,jpga18d,"A Java program, once compiled, can be run everywhere for example.",0.0,Java
14i037i,jpdxm47,I am a bit confused by the mention of Haskell.,-0.4,Haskell
14i037i,jpdxm47,The integer type you are using for Haskell is not the correct one to look at this issue because it is not a 32-bit integer *or* a 64-bit integer.,0.0,Haskell
14i037i,jpdxm47,"Also, Haskell has no implicit type conversions at all.",0.0,Haskell
14i037i,jpdxm47,"If you give no type signature to `g`, it will default to `Integer` which is [Haskell's infinite precision integer type](https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Integer.html#t:Integer).",0.0,Haskell
14i037i,jpdxm47,"Also, Haskell's issue with negative literals is a bit different than what you're describing.",-0.15,Haskell
14i037i,jpdxm47,The reason this can be a problem in a different way than other languages is because the Haskell function call syntax is juxtaposition: `f x` is `f` applied to `x`.,-0.0625,Haskell
14i037i,jpdxm47,This is what `NegativeLiterals` does in the context of Haskell and GHC.,0.0,Haskell
14i037i,jpgd95p,Rust has no implicit conversion.,0.0,Rust
14i037i,jpe9rex,(I created a whole thread about this exact question [here](https://www.reddit.com/r/C_Programming/comments/14gyl0a/why_long_really_needs_to_be_deprecated/?utm_source=share&utm_medium=web2x&context=3) in the C subreddit; the replies were not sympathetic.),0.06666666666666667,C
14i037i,jpemm38,Why are you mentioning Python and JavaScript?,0.0,Python
14i037i,jpemm38,Why are you mentioning Python and JavaScript?,0.0,JavaScript
14i037i,jpemqjz,"I actually tested it like this:      #include <stdio.h>      long f(void){return -1;}     long g(void){return 0xFFFFFFFF;}      int main(void) {         printf(""%f\n"",(double)f());         // both -1.000000         printf(""%f\n"",(double)g());     }  with a conversion to double, since in C, because you have to tell `printf` whether an expression is signed or unsigned, that influences the result.",-0.025,C
14i037i,jpg74d6,"The main repository is:  https://gitlab.com/mail.umlcat  I'm working in both a FreePascal version and a Plain C version, but it could be migrated to other P.L.",-0.057539682539682536,C
14i037i,jpfju5d, >Why are you mentioning Python and JavaScript?,0.0,Python
14i037i,jpfju5d, >Why are you mentioning Python and JavaScript?,0.0,JavaScript
14i037i,jpfybhd,Rust doesn't have a prefix decrement operator: `--x` is also equal to `x`,0.0,Rust
14i037i,jpfzn23,This is special behavior Java has that you didn't clarify which is confusing because the code example you generalize to multiple other languages depends on this behavior.,-0.01696428571428571,Java
14hcw00,,"I'm designing a statically-typed compile-to-JavaScript language, like a better TypeScript, based on looking at the patterns in my code that are a pain to express in TypeScript or that require sacrificing performance for flexibility or readability.",0.5,TypeScript
14hcw00,,"The type system will be simple enough to have a spec, and nominal (like Java), but ""modern.""",0.06666666666666667,Java
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,Java
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,JavaScript
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,C
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,Rust
14hcw00,,"There are different ways to represent a set of integers in JavaScript, for example a built-in Set, or you could use a sorted array of integers, or a sorted typed array (e.g.",0.0,JavaScript
14hcw00,,"So if you have some noun and want to perform a verb on it—suppose it's some custom data structure called ""List"" and you want to get the ""length""—the best thing for the JavaScript engine is if you just call a function like ""listLength"".",1.0,JavaScript
14hcw00,,"It doesn't happen in TypeScript, for obvious reasons.",0.0,TypeScript
14hcw00,,"In Haskell or ML, it is also verboten for types to affect behavior, because you are not supposed to have to specify any type annotations; the type system is designed around the goal of whole-program type inference (which is a non-goal for me).",0.0,Haskell
14hcw00,,(I think Scala can do something like this.),0.0,Scala
14hcw00,,The duplicated code might be identical—in which case it still could benefit the JavaScript engine by being monomorphic—or it might have different inlined—or macro-expanded—code based on the differently instantiated type parameters.,0.0,JavaScript
14hcw00,,"(Scala can make sure instances that are associated with different ""parent"" instances aren't used interchangeably, but as much time as I've spent reading about Scala's type system and calculus, I don't think it's what I need.)",0.15,Scala
14hcw00,,"Modules, instead of being singletons like in TypeScript, would have parameters and type parameters that form the ""configuration"" or context of the module.",0.0,TypeScript
14hcw00,,Maybe this was the idea with C++.,0.0,C++
14hcw00,jpamyvk,"My day job is C# code and it always irks me that I have to do ""Go To Implementation"" to just look at the code that's being called.",0.0,C
14hcw00,jpamyvk,"My day job is C# code and it always irks me that I have to do ""Go To Implementation"" to just look at the code that's being called.",0.0,Go
14hcw00,jpamyvk,"I consider the entire notion of ""Go To Implementation"" to be a code smell because it implies that there's only a single implementation.",-0.023809523809523808,Go
14hcw00,jpamyvk,"In TypeScript, my preferred approach is actually a map (object literal) of strings to functions.",0.0,TypeScript
14hcw00,jpamyvk,There's a follow-up by someone else ['Modules Matter Most' for the Masses](https://www.pathsensitive.com/2023/03/modules-matter-most-for-masses.html) that explained it better IMO and has TypeScript code examples.,0.5,TypeScript
14hcw00,jpamyvk,"I also found [Encoding ML-style modules in Rust](https://blog.waleedkhan.name/encoding-ml-style-modules-in-rust/) helpful in the sense of explaining this ""functional"" language feature in terms of an imperative language but it does require familiarity with Rust.",0.0,Rust
14hcw00,jpblsad,> However—and this is the point—the purpose of having different implementations of an interface here is not so we can do some kind of late-bound dynamic dispatch...  What you're describing here reminds me of how templates are used in the C++ STL.,0.19999999999999998,C++
14hcw00,jpblsad,"For example, C++ has for a long time had names like [InputIterator](https://en.cppreference.com/w/cpp/named_req/InputIterator).",-0.05,C++
14hcw00,jpblsad,"Another, weirder example is C# extension methods.",0.0,C
14hcw00,jpblsad,(I think Scala can do something like this.),0.0,Scala
14hcw00,jpblsad,Kotlin too.,0.0,Kotlin
14hcw00,jpblsad,"However, it's not perfect, and there are cases where Kotlin needs to box the wrapped primitive into an object.",-0.5,Kotlin
14hcw00,jpblsad,"Technically, the Kotlin approach isn't restricted to primitives.",0.0,Kotlin
14hcw00,jpblsad,Haskell has the same general idea with [newtype](https://wiki.haskell.org/Newtype).,0.02500000000000001,Haskell
14hcw00,jpblsad,"---  FWIW, if you haven't, you might want to look at Go.",0.0,Go
14hcw00,jpblsad,"To be clear, I'm not recommending Go.",0.10000000000000002,Go
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,C++
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,C
14hcw00,jpb5qkw,"Structs are great for memory usage, and they are fast to get the size and the type itself isn't actually important, it's just a way to more easily see the data (C# Spans have a similar goal).",0.38888888888888884,C
14hcw00,jpb5qkw,"(Later versions try to add more C and C++ features like ""enum"", but its hardly required, and just an easier way to write constants.)",0.06944444444444443,C
14hcw00,jpb5qkw,"(Later versions try to add more C and C++ features like ""enum"", but its hardly required, and just an easier way to write constants.)",0.06944444444444443,C++
14hcw00,jpbfa3n,Insightful blog post but just wanted to mention that behavior can in fact depend on types in Haskell trough the use of type classes.,0.0,Haskell
14hcw00,jpitaev,"I guess I am talking about a specific set of circumstances where you have a high-level, statically-typed language, somewhere between Java and Haskell, and you can write modules that have types as parameters, and types can have ""methods,"" but in many cases the substitution is done at compile time (and this can be relied on, both for performance purposes and for the sake of language features that rely on it).",0.25,Java
14hcw00,jpitaev,"I guess I am talking about a specific set of circumstances where you have a high-level, statically-typed language, somewhere between Java and Haskell, and you can write modules that have types as parameters, and types can have ""methods,"" but in many cases the substitution is done at compile time (and this can be relied on, both for performance purposes and for the sake of language features that rely on it).",0.25,Haskell
14hcw00,jpdskxi,"I'm not a huge fan of Go for other reasons either, but I do actually really like shaped types as opposed to named types.",-0.041666666666666685,Go
14hcw00,jpdskxi,"The advantage, for me, that Go has over OCaml is its explicitness.",0.0,Go
14hcw00,jpdskxi,My major gripe with Go here is that there's no way to let the compiler verify conformance so you're stuck writing a test for every interface you want to make sure conforms and the test is likely only calling a dummy method that accepts the interface.,0.140625,Go
14hcw00,jpdskxi,"Go has some interesting ideas, but is a bit too DIY for my taste to use regularly.",0.25,Go
14hcw00,jpe493c,> My major gripe with Go here is that there's no way to let the compiler verify conformance so you're stuck writing a test for every interface you want to make sure conforms and the test is likely only calling a dummy method that accepts the interface.,0.140625,Go
14hcw00,jpe493c,"If Go added a succinct way to say ""this struct should implement that interface"", I think I would at least be neutral on the topic.",-0.3,Go
14hcw00,jpe493c,"> Go has some interesting ideas, but is a bit too DIY for my taste to use regularly.",0.25,Go
14hcw00,jpe493c,"I think it's trying to be a better C, and I think it largely succeeds at that.",0.6,C
14hcw00,jpe493c,And I think that attitude has ossified in the Go community.,0.0,Go
14hcw00,jpe493c,I remember when generics came to Java 5 (almost 20 years ago) and it was such a huge improvement in the language.,0.20000000000000004,Java
14hcw00,jpe97da,"If Go added a succinct way to say ""this struct should implement that interface"", I think I would at least be neutral on the topic.",-0.3,Go
14hcw00,jpe97da,"With Go syntax, it'd probably be an expansion of tags, like `type MyStruct struct 'implements:[InterfaceA, InterfaceB]' {}` (single quotes because Reddit apparently doesn't like letting us escape ticks).",-0.010714285714285711,Go
14hcw00,jpe97da,I think anyone who's worked in Java is familiar with the inconsistency of the `@Override` annotation.,0.375,Java
14hcw00,jpe97da,">I think it's trying to be a better C, and I think it largely succeeds at that.",0.6,C
14hcw00,jpe97da,"I will give Go that it's a very consciously designed language and a lot of it does contribute to their goals, i.e., there should generally be one way to do things, enforcing KISS, and making the code as easy or easier to read than it is to write.",0.20444444444444446,Go
14gwj0t,jp85094,"I cant use sqlite or postgress for 2 reason first i want to perform the queries on the fly without recreating db from git files and also i want to add a custom queries fit git like push, blame... etc  I started it to test the idea and learning rust and i want it to be wild usages in the near future,  BTW, In the demo i am running queries on the offical Rust analyzer repo.",0.2750000000000001,Rust
14gqgsj,,"I'm pretty sure I've seen this somewhere in the past for Haskell a couple of years back, and maybe some other langs.",0.075,Haskell
14gqgsj,,"Example of unformatted code (Haskell):      data Row = Row {colA :: String, colB :: String}      table :: [Row]     table =     [ Row ""xxxxxx"" ""xx"",       Row ""x"" ""xxxx"",       Row ""xxxxxxxx"" ""xxxx""     ]  Example of the auto-formatted code:      table :: [Row]     table =     [ Row ""xxxxxx""   ""xx"",       Row ""x""        ""xxxx"",       Row ""xxxxxxxx"" ""xxxx""     ]   Obviously the data could just put put in `.csv` / `.tsv` files.",-0.5,Haskell
14gqgsj,jp72n2t,I embed a small bit of Emacs Lisp code that I can manually run to realign things when I make changes.,-0.25,Lisp
14ghevk,jp661h3,So in Prolog Syntax I assume you want something like this.,0.0,Prolog
14ghevk,jp661h3,I hear also some  forms of Prolog support limited version of it.,-0.07142857142857142,Prolog
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,Haskell
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,Prolog
14gcuev,,"&#x200B;  I wanted to ask you how Swift accomplished to define primitive types like `Int`, `Bool` and `Character` in its standard library without having a compiler instrinsic type (I don't know if they exist but I haven't seen them).",0.1,Swift
14gcuev,jp4synt,"Sorry to not answer the question in the title (I don't know about Swift), but [here](https://github.com/nim-lang/Nim/blob/devel/lib/system/basic_types.nim) is how Nim does it (this module is implicitly imported).",-0.5,Swift
14gcuev,jp4z9fz,"Based on the docs, there is a very magic `Builtin` object available for the stdlib: https://www.swift.org/standard-library/  You can also try looking at the source code for the stdlib, but I don't know enough Swift to make sense of anything.",0.35000000000000003,Swift
14gcuev,jpc5r67,"I don't know how Swift does it, but I've done it by making primitive types into ""external"" classes.",0.0,Swift
14g8vwb,,"For processing operations, consider concatenative languages such as Forth, whose operands are on a stack.",0.0,Forth
14g8vwb,jp4d4ak,If you used queues as the underlying data structure in Forth rather than stacks you'd introduce a lot of problems with memory moving around.,0.0,Forth
14g8vwb,jp4itsc,"As Forth illustrates, groups of stack operations can be reasoned about in isolation as an unit that consumes the top N values and pushes M values, making stack-based models very composable.",0.35,Forth
14g8vwb,jp5w8pp,"When coupled with the natural levels of language/supervision (cf Erlang's 5 levels), the upshot is a complete solution for arbitrarily complex computational systems that is fully consistent with arbitrary machine code provided it follows the simple actor model rules.",0.008333333333333337,Erlang
14g8vwb,jp9o3dx,"See LabVIEW G, Simulink, Verilog, Cal for examples of languages.",0.0,Verilog
14g8vwb,jp6wux2,"For instance, Forth’s “retain” is an enqueue, and “restore” is just waiting for the value to come around again.",0.0,Forth
14g8vwb,jp6wux2,One is left-to-right composition of functions:      f : A → B     g : B → C     h : C → D      f g h : A → D     ≅     λs0:A.     let s1:B = f(s0) in     let s2:C = g(s1) in     let s3:D = h(s2) in     s3  The other is right-to-left composition of continuation transformers.,-0.125,C
14g8vwb,jp6wux2,One is left-to-right composition of functions:      f : A → B     g : B → C     h : C → D      f g h : A → D     ≅     λs0:A.     let s1:B = f(s0) in     let s2:C = g(s1) in     let s3:D = h(s2) in     s3  The other is right-to-left composition of continuation transformers.,-0.125,D
14g8vwb,jp6wux2,f : (B → Z) → (A → Z)     g : (C → Z) → (B → Z)     h : (D → Z) → (C → Z)      f g h : (D → Z) → (A → Z)     ≅     λk0:(D→Z).,-0.75,C
14g8vwb,jp6wux2,f : (B → Z) → (A → Z)     g : (C → Z) → (B → Z)     h : (D → Z) → (C → Z)      f g h : (D → Z) → (A → Z)     ≅     λk0:(D→Z).,-0.75,D
14g8vwb,jp4iab6,"Let's assume that it would be a concatenative language, not Forth, and that stacks are not a desired paradigm of computation.",0.0,Forth
14g8vwb,jp482n6,I mentioned concatenative languages and Forth.,0.0,Forth
14g8vwb,jp6u7s3,Assembly or machine code is generally what gives *the ability to* make function calls in higher level languages.,0.15000000000000002,Assembly
14g8vwb,jpa0i4b,Verilog's delayed actions and JavaScript's event-based concurrency are examples of ordering work via a priority queue.,0.0,Verilog
14g8vwb,jpa0i4b,Verilog's delayed actions and JavaScript's event-based concurrency are examples of ordering work via a priority queue.,0.0,JavaScript
14g8vwb,jp4r2ad,I'm not trying to prove a better Haskell or something.,0.5,Haskell
14g8vwb,jp4szga,"The main reason I thought in terms of *only* a queue, is because concatenative languages such as Forth create a great deal of brevity by assuming there's some implicit data you're working on.",0.24166666666666667,Forth
14g8vwb,jp4szga,"I like the brevity offered by Forth, and I like postfix notation just fine, because that's the actual natural order of ASM instructions.",0.17222222222222225,Forth
14g8vwb,jp59yme,Well I was thinking a Forth style global data structure that everything (not separately allocated) gets pushed or popped from.,0.0,Forth
14g8vwb,jp769hr,"Some key differences:  * You send a ""message"" (think procedure/function call that doesn't return -- there's no returned value, no error codes returned, no promise/future, etc, nothing whatsoever is returned) to an ""address"" (think email address, but obviously low level, almost at the level of a machine address but not quite that simple) of an actor (think ""process"" in the general sense and think extremely lightweight, so maybe 256 bytes per ""process"" max -- see Ponylang whose actors/processes are 256 bytes each; I think Scala's are around the same size, or maybe 512 bytes per).",-0.012499999999999997,Scala
14g8vwb,jp8cred,"Secondly, regardless, I'm pretty certain that hand-written assembly for the majority of applications is going to be organized as lists of calls or procedures much like C, simply because it's the intuitive way to organize things.",0.13285714285714287,C
14g8vwb,jp97ljd,That would be a higher level job for the C code of the 3D graphics device driver.,0.25,C
14g8uyu,jp44ey2,It's basically an attempt to find methods of memory safety that are simple enough to retrofit onto C++.,0.0,C++
14g8uyu,jp44ey2,"I'm also thinking about adding a section to the end, briefly going over all the other methods of memory safety that I know, in case someone else can think of a method for making them fit C++.",0.09166666666666667,C++
14g8uyu,jp6kbkg,"""Making C++"" ...  Why try to revive something that is dead by design?",-0.2,C++
14g8uyu,jp4iya6,"Also make sure to relate to prior work in this area (comparing pros/cons--in your talk, I mean, as that would be interesting to the broader C++ audience; no need to reply here):  - -fbounds-safety, https://discourse.llvm.org/t/rfc-enforcing-bounds-safety-in-c-fbounds-safety/70854 - -Wlifetime, e.g., https://godbolt.org/z/_midIP, https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/ - SAL annotations, https://learn.microsoft.com/en-us/cpp/code-quality/understanding-sal?view=msvc-170 - GCC 13 -Wdangling-reference, https://developers.redhat.com/articles/2023/06/21/new-c-features-gcc-13 - “safe libc++” mode, https://libcxx.llvm.org/UsingLibcxx.html#enabling-the-safe-libc-mode - RFC: C++ Buffer Hardening: https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734  - Safe Buffers Programming Model under which any pointer arithmetic is considered unsafe and clang warns about it  - -Wunsafe-buffer-usage initial commit https://reviews.llvm.org/D137346, docs https://reviews.llvm.org/D136811 - [RFC] Lifetime annotations for C++: https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377 	- See also: Comparison with other work in this area: https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377#heading--other-work 	- https://github.com/google/crubit/blob/main/docs/lifetimes_static_analysis.md 	- implementation: https://github.com/google/crubit/tree/main/lifetime_analysis",0.1953125,C++
14g8uyu,jp5zofh,"Well I'm sure you already know [my views](https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html), but the ""brutal"" truth is that anyone who cares about safety and isn't burdened by legacy codebases will use Rust, and so the people still stuck on C++ are the ones who can't just up and migrate their codebase to a new-fangled ad-hoc subset of C++.",-0.1875,Rust
14g8uyu,jp5zofh,"Well I'm sure you already know [my views](https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html), but the ""brutal"" truth is that anyone who cares about safety and isn't burdened by legacy codebases will use Rust, and so the people still stuck on C++ are the ones who can't just up and migrate their codebase to a new-fangled ad-hoc subset of C++.",-0.1875,C++
14g8uyu,jp5zofh,"Also, the design of C++ is fundamentally limited in ways that make it difficult to retrofit safety on top anyway.",-0.023809523809523798,C++
14g8uyu,jp4t8f9,* Something more like Rust's Arc<Mutex<T>> would work.,0.5,Rust
14g8uyu,jp4mzx5,"Edit: Added ""Our ultimate goal is to find simple ways to make C++ memory-safe, simple enough that they can be accomplished via static analysis or linters, without extending the language.""",0.11666666666666665,C++
14g8uyu,jp6v6t3,"So, for most of these places its not easy to simply pivot from C++ to Rust.",0.09444444444444444,C++
14g8uyu,jp6v6t3,"So, for most of these places its not easy to simply pivot from C++ to Rust.",0.09444444444444444,Rust
14g8uyu,jp6cn6i,"I think a lot of people think the same as you do, but there are a few reasons I don't share that worldview:   * If someone actually wanted absolute safety, they'd use a language safer than Rust, perhaps something like Typescript.",0.0,Rust
14g8uyu,jp6cn6i,"Most popular Rust crates have some usage of unverified `unsafe`, either directly or in non-stdlib dependencies.",0.4000000000000001,Rust
14g8uyu,jp6cn6i,"People who use Rust are pragmatic folks who are fine [sacrificing _some_ speed for safety](https://verdagon.dev/blog/myth-zero-overhead-memory-safety), and _some_ safety for their low-level goals.",0.4166666666666667,Rust
14g8uyu,jp6cn6i,"* I believe that with some improvements, C++ can also occupy a sweet spot in that vicinity.",0.35,C++
14g8uyu,jp6cn6i,"And if we can provide a smooth, gradual on-ramp to it (such as described in the draft) that's easier than Rust, then we might actually make it to a memory-safe world faster than we would with a slow global migration to Rust, which I think you would agree is a good thing.",0.13333333333333333,Rust
14g8uyu,jp6cn6i,"* `unsafe`, and the entire C++-to-Rust migration story, suggests that non-memory safe code can coexist with (and gradually transition to) safe code, which hints it's also possible to migrate to a safe subset of C++, or Vale, or CppFront or Carbon if they ever choose to add safety.",0.3,C++
14g8uyu,jp6cn6i,"* There are still some reasons to use C++, such as existing libraries whose paradigms Rust can't reason about (UI, OO, etc), existing frameworks that still use C++ (Unreal), and existing programs that still use C++ (Spanner).",0.0,C++
14g8uyu,jp6cn6i,"* There are still some reasons to use C++, such as existing libraries whose paradigms Rust can't reason about (UI, OO, etc), existing frameworks that still use C++ (Unreal), and existing programs that still use C++ (Spanner).",0.0,Rust
14g8uyu,jp6cn6i,I see a path forward for C++.,0.0,C++
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,Kotlin
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,Swift
14g8uyu,jp6cn6i,I'd hesitate to say that Rust's future supremacy is a brutal truth.,-0.4375,Rust
14g8uyu,jp4usus,"FWIW, `int main() {}` is legal and standard (including omitting the explicit `return 0;` statement)--and shorter than the `void` version (which is sufficiently out of place in either C or C++ code to be distracting here, I think), https://en.cppreference.com/w/cpp/language/main_function  > The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.",0.13999999999999999,C
14g8uyu,jp4usus,"FWIW, `int main() {}` is legal and standard (including omitting the explicit `return 0;` statement)--and shorter than the `void` version (which is sufficiently out of place in either C or C++ code to be distracting here, I think), https://en.cppreference.com/w/cpp/language/main_function  > The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.",0.13999999999999999,C++
14g8uyu,jp4usus,"More on the friendly nitpicking side ;-) Using `std::endl` (I cannot bring myself to omit `std::`) other than as an explicit buffer flushing operation for a non-error output stream is going to raise some eyebrows, too: C++ Weekly - Ep 7 Stop Using std::endl, https://www.youtube.com/watch?v=GMqQOEZYVJQ",0.25,C++
14g8uyu,jp55a2n,"No problem, glad the nitpicking can be useful :-)  As for the `std::endl`: Generally I'd go with the isocpp.org FAQ, https://isocpp.org/wiki/faq/input-output#endl-vs-slash-n or the C++ Core Guidelines, https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio50-avoid-endl  In my context `'\n'` is also shorter to type than `std::endl`--with the context being never `using namespace std;`, https://isocpp.org/wiki/faq/coding-standards#using-namespace-std (yes, even for short snippets of code that I need to fit on the slides in a presentation--it can be even more useful for talks as the audience can quickly tell at a glance whether I'm talking about, say, `std::sort`, `llvm::sort`, https://developers.redhat.com/blog/2019/10/18/extend-c-capabilities-with-llvm-stlextras-h, or more likely `std::ranges::sort` nowadays).",0.30757575757575756,C++
14g8uyu,jp54mps,"I updated the article to add this near the top (in response to another comment):  > Our ultimate goal is to find simple ways to make C++ memory-safe, simple enough that they can be checked via static analysis tooling or linters, without extending the language.",0.2,C++
14g8uyu,jp54mps,"Some things feel Rust-esque (borrowless affine style and simplified borrowing, definitely), but the other parts (gen refs, constraint refs, shared_ptr) are specifically to make things easier than Rust.",-0.0625,Rust
14g8uyu,jp5c8oz,"I'm saying that we don't need to change anything in the C++ compiler (clang, GCC, etc) or the C++ standards.",0.0,C++
14g8uyu,jp5c8oz,"I suspect you mean ""We need to change how we use C++, which in practice is just like changing the language"", which is a reasonable stance TBH, even though I don't necessarily share the definition.",-0.0375,C++
14g8uyu,jp6kr58,"If you squint, it's what Rust's borrow checker is doing too since you can choose to use `unsafe` anywhere you'd like (minus the opt-out/opt-in distinction).",-0.1,Rust
14f99ui,joz2wx9,"Languages like TS, Crystal are able to infer things to a limited extent, and certain advanced techniques like semantic subtyping and [algebraic subtyping](https://lptk.github.io/files/[v6.2]%20mlstruct.pdf) can provide complete or almost complete inference, though it may take some time to understand these approaches.",0.20714285714285718,Crystal
14f99ui,joyurgi,"Python tools like mypy or pyright have overloads, which let you specify the output given specific inputs (especially with the Literal type).",0.0,Python
14f99ui,jp06h0q,"If you're looking more generally for ""I have a type union A | B | C, but here there's only A | B"".",0.18333333333333335,C
14f99ui,jp06h0q,"It's a type system built after the fact on top of Erlang, and infers types (that are unions of values) from the code.",0.5,Erlang
14f99ui,jp06h0q,"The advantage of this approach to typing is that the type system can express the types A, A | B, and A | B | C with no trouble.",0.1,C
14f99ui,jp0fjw1,"In Haskell, you would write something like       {-# LANGUAGE FunctionalDependencies #-}  -- implies MultiParamTypeClasses      class Fooable a b | a -> b where         -- | a -> b is the functional dependency                                              -- implying that the type of b depends on the type of a.         foo : a -> b      instance Fooable Array Array where         foo = fooArray      instance Fooable Float Float where         foo = fooFloat  If you then call `foo` with an array argument, it will infer the result type to be array so you need not specify it.",0.0,Haskell
14f99ui,jp0fjw1,---  Another possibility to consider is C++ function template specialization:      template <typename T>     T foo(T x);      template<>     float foo<float>(float x) { ... }      template<>     array foo<array>(array x) { ... }  Function template parameters can be inferred from the argument type (but cannot be inferred from return type).,0.0,C++
14f5wp0,,The compiler is written in Kotlin without using any 3rd party dependencies and is around ~300 lines.,0.0,Kotlin
14f5wp0,,"If people are curious or find my work useful I'll upload the code and provide a Kotlin script that can be easily executed like ``` qc template.qc ""{ //JSON vars here }"" ```  What are your thoughts?",0.2111111111111111,Kotlin
14f5wp0,jplg2bf,"Another possible approach for this is doing something similar to what a Lisp does: build up a data structure representing the AST, and dump that out to a string.",0.0,Lisp
14f5wp0,jplg2bf,"Then you can write functions that generate a 'sub-AST', akin to Lisp macros.",0.0,Lisp
14f5wp0,jplg2bf,"Haskell tends to be quite nice for this (for example because it allows you to define custom infix operators, and is quite good at dealing with recursive data types).",0.6499999999999999,Haskell
14e8erj,jpse5ao,So if you have a program written in COBOL in 1965 then it will run fine in 2365 on the Star-Ship Enterprise if you only present it to a COBOL compiler designed to target the Majel Barrett Architecture.,0.1388888888888889,COBOL
14dlbc8,joztdsm,"This is basically equivalent to using a per-type arena allocator in C, which is not memory safe by any reasonable standard.",0.2333333333333333,C
14dlbc8,jozhkao,"Or perhaps also about unsafe languages guarded with sanitizing tools, e.g., like C with AddressSanitizer?",0.4,C
14dlbc8,jor31j7,However to me it felt like I had roughly as many `if` checks as I would need in C++,0.5,C++
14dlbc8,joyagx3,ATS gets to zero-cost memory safety much closer than most others including Rust.,0.35,Rust
14dkx6p,josoi9l,"For a couple examples of recent _adoption_ of PEG,   * Python is moving from a LL(1) parser to a PEG parser: https://peps.python.org/pep-0617/ * Zig's grammar is specified as a PEG: https://github.com/ziglang/zig-spec/blob/master/grammar/README.md",0.0,Python
14dkx6p,jotu9nl,Languages like C usually resolved the dangling else conflict by an ad hoc disambiguation criteria.,-0.25,C
14de1dr,joszfjl,This is exactly what should have been happening for Elm in the last 5 years.,0.125,Elm
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,C
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Java
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Ruby
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Prolog
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Lisp
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,C++
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,PHP
14daokr,jrbb5ty,An example could be C++ references.,0.0,C++
14daokr,jrbb5ty,"C++ also has pointers which it ""inherited"" from C. So now it has to equivalent features that basically do the same, but in different ways, and they also interact in weird ways.",-0.16666666666666666,C++
14daokr,jrbb5ty,I guess Stroustrup's reason may have been that this meant that C++ could have backwards compatibility with C. In my opinion this came at a high price.,0.16,C++
14daokr,jrbb5ty,"C++ was attempting that, but failed: it added a new kind of pointers - yet at the same time it changed the meaning of struct types.",0.05909090909090908,C++
14daokr,jrbb5ty,Look at Object Pascal to see how OOP could be added without messing up with the base Pascal language.,-0.8,Pascal
14daokr,jrbb5ty,"By the looks of what went into C23, I expect the next version of C to include lambdas - but why does the latest version then not at least have nested functions, a simple and useful feature that already exists as incompatible proprietary extensions in the two probably most influential compiler systems GCC/GNUC and Clang, and was standard in Algol- and Pascal-derived languages going back to the late 60es and 70es?",0.07777777777777778,C
14daokr,jrbb5ty,"Why isn't there a language close to being as simple as original C or Pascal/Modula-2, with all the lessons added that we ought to have learnt in 75 years of computers and programming language design.",0.1875,C
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,C
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,C++
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Java
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Swift
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Go
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Rust
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Scheme
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Perl
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Python
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,PHP
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Ruby
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Haskell
14daokr,jrbb5ty,"Other scripting languages fill this niche now, perhaps mainly Javascript and Python (until recently Php), and before them it was BASIC.",0.010416666666666664,Python
14daokr,jrbb5ty,"And of course there are the immortal dinosaurs, FORTRAN and COBOL, and maybe even their offspring PL/1.",0.0,COBOL
14daokr,jop8s0h,"They usually come back to the same archetypes:  Algol C likes, lisps, MLs  Edit : for non dead languages :)",0.009999999999999998,C
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Python
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Haskell
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Rust
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Go
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,TypeScript
14daokr,jop3dvi,"Why would I use a language without even syntax highlighting where I'd need to run the compiler to see typos when I can just use typescript or Kotlin with a full IDE, autocomplete, linting etc.",0.35,Kotlin
14daokr,josx2j0,The only language that I'd call dead is Elm.,-0.1,Elm
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,Prolog
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,Forth
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,APL
14daokr,joqaqug,"To be fair, almost every new language did become popular because it was very similar to an existing popular language (almost always C, and C is quite similar to Algol).",0.33939393939393936,C
14czkbu,joppssr,I recommend  - https://davidchristiansen.dk/tutorials/nbe/ in Racket or https://davidchristiansen.dk/tutorials/implementing-types-hs.pdf in Haskell - https://github.com/AndrasKovacs/elaboration-zoo,0.0,Haskell
14czkbu,joqqa0o,It seems like something along the lines of Rust's shared vs unique references might be useful here.,0.3375,Rust
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,JavaScript
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,C++
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,Rust
14cxmbr,jona67v,"Better to:  \- support all reasonable operations on all containers (push-back, push-front, delete, insert, etc)    \- use the same interface for all containers so it's easy to move between them   \- make the tradeoffs clear in documentation     Otherwise people will invent their own containers that do what they want, then you'll get two standard libraries (look at boost vs C++ STL ugh), and then everyone will use both, and then everything will be a mess.",0.15648148148148147,C++
14cxmbr,jooloet,"See for example [""Q: Remove element by value in Go list""](https://stackoverflow.com/questions/31080285/remove-element-by-value-in-go-list).",0.0,Go
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,Lisp
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,C
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,Rust
14cxmbr,joonxut,"Clojure is good here, even if it means sometimes weird decisions at first glance.",0.15,Clojure
14cxmbr,jot5z43,Historically boost could be viewed as a feeder for getting libraries into the ISO C++ standard.,0.0,C++
14cxmbr,jot5z43,For a better example of the two conflicting standard libraries problem consider Tango and Phobos from the early days of [D](https://en.wikipedia.org/wiki/D_(programming_language)).,0.19999999999999998,D
14cv7tg,joqnjz7,"The last few months has been implementing threads, getting a second backend, implementing cross language inline (so C++ code inlines into bolin builds), improving codegen so the optimizer doesn't need to deal with sloopy codegen, now recently syntax changes, etc  There's going to be quiet a few months before we'll have a killer app with all the syntax it uses fully implemented.",-0.05714285714285715,C++
14cu0id,joof9xj,"On a Pentium4 machine, the register machine required 32.3% less time to execute standard benchmarks if dispatch is performed using a C switch statement.",-0.08333333333333333,C
14cu0id,joof9xj,Designing your runtime around the constraints of the hardware can be the difference between your language being ~10x slower than C versus ~100x slower than C.,0.0,C
14cu0id,jop6u3u,Here's a recent article about [arbitrary decisions in Rust](https://graydon2.dreamwidth.org/307291.html).,-0.05,Rust
14cu0id,jooo6tr,"The reasons Java went stack only were, one to avoid to look like another processor codes and avoid been sued.",0.0,Java
14cqhj1,,"I came across the paper and presentation [*Generalized Evidence Passing for Effect Handlers*](https://www.microsoft.com/en-us/research/uploads/prod/2021/03/multip-tr-v4.pdf), (and it's Haskell implementation [EvEff](https://hackage.haskell.org/package/eveff)) which describes the process Koka's compiler uses when compiling effect handlers to C, but it is a completely over my head and I am not very familiar with programming language papers.",-0.022115384615384606,Haskell
14cqhj1,,"I came across the paper and presentation [*Generalized Evidence Passing for Effect Handlers*](https://www.microsoft.com/en-us/research/uploads/prod/2021/03/multip-tr-v4.pdf), (and it's Haskell implementation [EvEff](https://hackage.haskell.org/package/eveff)) which describes the process Koka's compiler uses when compiling effect handlers to C, but it is a completely over my head and I am not very familiar with programming language papers.",-0.022115384615384606,C
14cqhj1,jon1fac,"I think what happens in C is that the handler is called immediatly and then if you need to suspend, a global variable is set and the function return (if you don't need to suspend, the handler just return the value), then every function above in the call stack will check if the global variable is set and if so will add the continuation to the list and the return.",0.0,C
14cqhj1,joon6w8,"I'd like to explain how the ""bubbling"" works in analogy to how the `Result` monad works in a strict language like OCaml or Rust.",0.0,Rust
14cqhj1,jom1aqd,"I did notice that the EvEff implementation uses a free monad, but I believe in the compilation to C the monad is compiled away rather than interpreted at runtime.",0.4,C
14chayf,,"I have absolutely no idea how to approach parsing, so much so that I got bored and am currently rewriting the lexer in like 3 other languages (the implementation on GitHub is in Go).",-0.10500000000000001,Go
14chayf,jolqbch,"There are many ways to go about implementing a parser, but if you are just getting started and the jargon about LR, LL(1), context-free grammars is going over your head, here's what I would recommend (I'm also gonna assume you're gonna use Go because you mentioned Go):  You probably want to have expressions in your language.",0.5,Go
14chayf,jolr2p4,I have write [a blog about writing a parser in Haskell](https://terenceng03.github.io/blogs/parser_combinator.html).,0.0,Haskell
14chayf,jom28iu,"I'm going to use C as the example language to parse, where every top level item is a declaration of some sort, could be variables, types, function prototypes/forwards, or function definitions.",0.5,C
14chayf,jom28iu,"When a C function is defined, language statements are allowed (a block is required to start).",0.0,C
14chayf,jom28iu,"For C, expressions may also appear in declarations, so the declaration parser needs a subset of an expression parser, where in some sense, basically only unary operators are allowed (with an exception for constant expressions such as for initializers and array bounds, which allow binary operators as well).",0.0,C
14chayf,jom28iu,"A language like C requires complete forward declarations, so can logically combine symbol table construction, scoping maintenance, as well as symbol resolution with parsing.",0.175,C
14chayf,joq1bvt,"Check out ""Writing an Interpreter in Go"" by Thorsten Ball.",0.0,Go
14camve,,"Is the idea that the linters take the AST (like a Rust linter, how does it work in Rust?",0.0,Rust
14camve,jok4xpl,"For example the transformation `x == False` -> `x is False` is suggested by some Python linters, but since operators can be overloaded this can cause the program to break.",-0.4000000000000001,Python
14c83jy,,"I don't like how TypeScript does it and makes it so the global is extended, because then you can't have different versions of the type at the same time.",0.0,TypeScript
14c83jy,jol0mo7,"Swift allows new members to be declared in extensions, but they have some limitations.",0.13636363636363635,Swift
14c83jy,joleoek,It might be worth looking into extension methods in [Kotlin](https://kotlinlang.org/docs/extensions.html) and [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/).,0.3,Kotlin
14c83jy,joleoek,It might be worth looking into extension methods in [Kotlin](https://kotlinlang.org/docs/extensions.html) and [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/).,0.3,Swift
14c83jy,joleoek,"Alternatively, you can do similar things in Rust with traits.",0.0,Rust
14c83jy,joleoek,"In Rust, however, that ""I follow this interface"" declaration is separate from the class declaration, which means you can declare methods on classes that you didn't write.",0.0,Rust
14c83jy,joleoek,"For example, in Rust, `Vec` is the built-in equivalent of Javascript's `Array`.",0.0,Rust
14c83jy,joleoek,"I could write a `CanSlice` trait in my own code, and implement it for the built-in `Vec` type, and then as long I've imported the trait and Rust knows about it, I can use the `slice` method from my trait on the built-in type.",0.27499999999999997,Rust
14c83jy,joleoek,"Rust normally exports an `Iterator` trait, which has a bunch of different ways of iterating over collections.",0.075,Rust
14c83jy,jokn1n1,"The inconsistencies push you to try to add methods, but this problem does not exist in the first place if you go with plain functions first (see Haskell and typeclass methods).",0.04642857142857143,Haskell
14c83jy,jok7aiy,Look at Ruby for prior art.,0.0,Ruby
14c83jy,jomlyug,"I like how Rust does this particular thing, though it could go further.",0.08333333333333333,Rust
14c3wkr,,So I've started to work on this new programming language that aims for building machine learning systems (like what Python has being doing so well in recent years).,0.06818181818181818,Python
14c3wkr,,"I have thought of some of these small features that might be interesting for AI/ML people:  * better performance over Python (which should be the same case for different sorts of hardware); * better compile time checking, which minimises run time error (such as strongly typed, but would not require a type keyword when initialising variables like Python, so a type inferencing system is required); * better native support for AI/ML code/utils, like built-in tensor types, functions, etc.",0.2425925925925926,Python
14c3wkr,jok7lut,"Additionally, almost all of the runtime on large models is spent doing matrix multiplications that are implemented in C, so the python overhead matters very little.",-0.04315476190476192,C
14c3wkr,jok7lut,Honestly I think there's not much that can easily be improved on vs Python.,0.3111111111111111,Python
14c3wkr,jolfwx6,Even Fortran was better at this than many modern languages.,0.39999999999999997,Fortran
14c3wkr,jokppjp,"So because this language is planing to support JIT compiling, a notebook style debugging / documenting system should be relatively easy to implement, so this means dynamic compiling, or more specifically, it will have a compiler and an interpreter, which will support features like interactive debugging and interactive command line tools like Python's idle.",0.3111111111111111,Python
14c3wkr,jokppjp,"In terms of the actual performance gain over Python, you are right, the critical part of ML computation is handled with C. However, seeing what Mojo's LLVM & MLIR system can do, I'm confident that with careful optimisation, there are still some potential for these languages to improve upon C's performance, especially in exotic hardware like GPUs, TPUs and NPUs.",0.24081632653061225,Python
14c3wkr,jokppjp,"In terms of the actual performance gain over Python, you are right, the critical part of ML computation is handled with C. However, seeing what Mojo's LLVM & MLIR system can do, I'm confident that with careful optimisation, there are still some potential for these languages to improve upon C's performance, especially in exotic hardware like GPUs, TPUs and NPUs.",0.24081632653061225,C
14c3wkr,jokppjp,"Even if there is little performance gain over C, MLIR will provide much better scalability to different hardware without the need for changing much code.",0.128125,C
14c3wkr,jokppjp,"Python is a great language, especially for AI/ML, to dramatically improve the performance of large models like large transformer models, the change has to be low level, so in the implementation of the language used to build the model, or hardware improvements.",0.2457142857142857,Python
14c3wkr,jokppjp,"It is hard to build on top of or even surpass Python in some areas, without sacrificing existing develop&debug experience, but like what I mentioned before, it is not impossible.",0.18055555555555555,Python
14c3wkr,jov7prv,"So, Haskell's port of torch does this, but it requires type-level integer addition.",0.0,Haskell
14c2017,,"Hi  A few years ago Ive written a virtual processor runtime and a simple compiler for a somewhat self designed/dialect of a low level assembler language, all written in C++ as a learning project.",-0.06666666666666667,C++
14c2017,,:)   I since would like to rewrite the runtime environment/virtual processor part in Rust.,0.5,Rust
14c2017,,"Feel free to check out the repositories: (Warning, not the best docs and certainly not the best c++ haha)   Virtual Processor/Rumtime Environment  - https://github.com/pointermess/FlexRTE-X  Assembler/Compiler/FlexASM to FlexRTE Executable  - https://github.com/pointermess/FlexASM-Compiler  Some docs if interested  FlexASM Quick Start - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexASM%20QuickStart%20Guide.md - https://github.com/pointermess/FlexRTE-X/blob/master/SystemCalls.md - https://github.com/pointermess/FlexASM-Compiler/tree/master/examples  Flex Executable Format (Basically the generated ""machine""/byte code from my asm dialect)  - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexApplication%20Excutable%20Format.md   Thanks for your time   For the lulz, my unfinished attempt at a tiny C compiler, comes with tokenizer, ast parser and representation.",0.25261904761904763,C
14c2017,jokcrsl,If you just use `malloc` (C) or `new` (C++) then it will typically attempt full allocation.,0.10656565656565657,C
14c2017,jokcrsl,If you just use `malloc` (C) or `new` (C++) then it will typically attempt full allocation.,0.10656565656565657,C++
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,R
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,D
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,C++
14bz7jf,joikybk,Look at Ada and it's subset Spark.,0.0,Ada
14bz7jf,jozyn5i,The first talks about how a JS and Go program that are textually almost identical have very different security properties.,0.125,Go
14bz7jf,jozyn5i,- I worked on Go's [html/template](https://pkg.go.dev/html/template) library which touches on design of DSLs for [securely composing network messages](https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition) from untrusted and trusted strings.,0.4,Go
14bz7jf,joj4bkb,Look at papers about Rust.,0.0,Rust
14bz7jf,joj4bkb,Rust took a lot of stuff from Cyclone and then put it in a security critical path.,0.0,Rust
14bz7jf,joklvnx,Haskell and Rust should provide plenty of opportunities to write real code with strong static guarantees.,0.37777777777777777,Haskell
14bz7jf,joklvnx,Haskell and Rust should provide plenty of opportunities to write real code with strong static guarantees.,0.37777777777777777,Rust
14bz7jf,joklvnx,"You could also look into properly dependently-typed languages, but they tend to lack a large ecosystem, so I'd say Haskell is currently the farthest you can go.",0.07142857142857142,Haskell
14bz7jf,jp0c941,"For example, Java's stronger typing makes it easy to preserve invariants around what messages an object can respond to.",0.43333333333333335,Java
14bz7jf,jokthru,"Ada forces you to make objects aliased if you need to access them through another object and it limits their scope and usage, you can extend it in unsafe ways in which  you have to specify, i.e.",0.0,Ada
14bz7jf,jokthru,Parallel blocks are in Ada 2022.,0.0,Ada
14blzws,jogwzfc,Obviously ignore the fact that Java messed up the default treatment of arrays.,0.0,Java
14blzws,jogqayy,"Got your point, thanks for your answer :D  Currently I'm unable to write your counter-example in TS because it seems that TS isn't smart enough, but if the type system allowed me to exploit the invariant of `f` and `s` having the same type I would have had some surprises at runtime if `Pair<U | V>` and `Pair<U> | Pair<V>` were considered equal.",0.13061224489795917,D
14blzws,jolb0lo,Thanks for the clarifications anyway :D,0.6,D
14b8c0r,,"Egel is implemented in C++ without an explicit garbage collector, parallel evaluation is simply spawning of another root node, and the graph -or parts of the graph- can be serialized, shipped, or saved to disc.",0.0,C++
14b8c0r,,"import ""egel_rpc.ego""          using System          def main =          let C = rpc_client ""localhost:50001"" in              rpc_call C [_ -> [X -> X] ] 42  In the above example, a lambda is sent to server, that returns the identity function to the client, and the client applies that to the constant 42.",0.05555555555555555,C
14b8c0r,,"import ""prelude.eg""      import ""egel_rpc.ego""          using System using List          def main =          let C = rpc_client ""localhost:50001"" in              rpc_call C [_ -> from_to 1 1000 ] |> sum   It works reasonably well but I am still wrinkling out the features.",0.18333333333333335,C
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,Java
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,Python
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,Rust
14acrae,,"Rust went the GAT way, and all pure functional languages that have HKTs that I know don't monomorphize.",0.21428571428571427,Rust
14acrae,,"C++ and D template metaprogramming come somewhat close, but are not exhaustively type-checked like proper implementations of HKTs.",0.0,C++
14acrae,,"C++ and D template metaprogramming come somewhat close, but are not exhaustively type-checked like proper implementations of HKTs.",0.0,D
14acrae,jobtxo7,But HKT is perfectly compatible with monomorphization and it would work fine in Rust.,0.7083333333333334,Rust
14acrae,jo9vza1,"Also, Haskell has its equivalent of GATs through functional dependencies.",0.0,Haskell
14acrae,jo9vza1,"Finally, functional languages face different tradeoffs than Rust does.",0.0,Rust
14acrae,jo9vza1,"By contrast, for a language like Rust, different types are represented differently on the stack, so even something as simple as hard-coding the size of stack allocations can be a big win.",0.16,Rust
14acrae,jobul1u,"I think they are as expressive as Haskell's HKTs (you can define abstractions for functors, monads, etc), but notationally much more cumbersome.",0.65,Haskell
14acrae,jobul1u,"`(Type -> Type) -> Type`) things get quite hairy, and while I think the module language is strong enough to express it, it becomes quite a Turing tarpit compared to Haskell.",0.21666666666666665,Haskell
14acrae,jocqg4b,"From what I've heard, Standard Chartered's Haskell variant Mu also uses monomorphization, I'm guessing it must support HKTs, otherwise, it wouldn't really be Haskell-like, but I don't have first-hand knowledge of it.",0.1,Haskell
14acrae,joc5z8s,">so far these languages only allow parameterisation over types, not type constructors  C++ has ""template template"" parameters though.",0.05,C++
14a79va,jo9731m,"*/     	free(p);  /* error: `p` has already `moved` */     }  Even wrote a POC C parser so I could extend the type system and enforce this, but never completed it because life caught up.",0.0,C
14a79va,jo91kix,"I liked lot of parts for instance:  ""As any C programmer knows, we carefully track who owns the data,"" "" We have a mental distinction between owning pointers and non-owning pointers.""",0.13333333333333333,C
14a79va,job9xz0,"For example:      users = [userAlice, adminBob, evilCharlie]     adminIDs = [1]     ...     users.remove(0) // Alice deleted her acouunt     ...     for index in adminIDs:         giveSecretsTo(users[index])         // whoops, just gave secrets to Evil Charlie!",-1.0,Alice
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,Rust
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,C
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,C++
14a79va,joizi09,"Here's another example:      users = [alice, bob, charlie]     gifts.append({recipient_id=1, item=""Apple""}) // Give Bob an apple     ...     users.remove(0) // Delete Alice     ...     for gift in gifts:         users[gift.recipient_id].send_message(""You got a ""+gift.item)         // Whoops, just told Charlie he got an apple instead of Bob  A more safe way to approach this would be with a map from globally unique IDs to users: `users = {alice.id: alice, ...}`.",0.4583333333333333,Alice
14a79va,jodn5rt,> a segfault isn't guaranteed in C or C++  Yep!,0.0,C
14a79va,jodn5rt,> a segfault isn't guaranteed in C or C++  Yep!,0.0,C++
149vqg4,,"I know that TypeScript allows you to specify array types like this: [Header, ...Body[], Tailer].",-0.75,TypeScript
149vqg4,jo7d336,"There are some nice languages for implementing state machines, like Ragel, which can emit code in C and C++.",0.6,C
149vqg4,jo7d336,"There are some nice languages for implementing state machines, like Ragel, which can emit code in C and C++.",0.6,C++
149vqg4,jo7guzo,"Clojure spec allows you to type collections using regular expressions, but they are only checked at testing/runtime, not statically.",0.0,Clojure
149vqg4,jo8j38j,Or like in Rust if something is marked [must_used](https://doc.rust-lang.org/std/hint/fn.must_use.html) it can be used to trigger the problem.,0.1,Rust
149vqg4,jo8hree,Erlang bit syntax is somewhat related to this.,0.0,Erlang
149vqg4,jodi9wk,"In Rust, it's usually done manually via session types:      pub fn stream() -> (Sender<Header>, Receiver<Header>);      pub struct Sender<T>(...);      impl Sender<Header> {         #[must_use]         pub fn send_header(self, header: Header) -> Sender<BodyPart>;     }      impl Sender<BodyPart> {         #[must_use]         pub fn send_body(self, body: BodyPart) -> Self;          pub fn send_tailer(self, tailer: Tailer) -> Sender<Header>;     }  So, that's cool, we have a state machine that enforces the sequence Header, followed by any number of BodyParts, followed by Tailer.",0.04999999999999999,Rust
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,Rust
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,C
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,Python
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,JavaScript
149vqg4,jo9bibi,"I'm don't know much Erlang, so I'm wondering is there a difference between giving the ascii code points as numbers      <<82,73,70,70>>:4/binary-little, %""RIFF""  compared to specifying it with the ascii string itself      <<""RIFF"">>:4/binary-little,  The latter would feel a bit more ergonomic to use.",0.2333333333333333,Erlang
149vqg4,jo8nwkr,"Unless you mean that thing which TypeScript calls tuples, because that is pretty much what I'm interested in.",0.096875,TypeScript
149vqg4,jo9evma,"IIRC, in Erlang a string is just syntactic sugar around a binary.",0.0,Erlang
149vqg4,jo9evma,The code I pasted was lifted directly from an actual program I wrote while learning Erlang.,0.05,Erlang
149fzge,jo6vuh7,This is basically the C++ approach.,0.0,C++
149fzge,jo6vuh7,"This is basically the Java approach, especially since generics are erased at runtime.",0.0,Java
149fzge,jo8ydgo,"In the case of C++, template instantiation is *roughly* similar to macro expansion.",0.0,C++
149fzge,jo8ydgo,I don't know how clever C++ compilers are at reusing work.,0.16666666666666666,C++
149fzge,joajp8g,"Again, I'm not quite sure how C++ compilers work under the covers.",0.5,C++
148szdv,,"As I'm sure many of you will be aware, when implementing a new language, the ability to call C code from it is very useful because of the ubiquity of existing software and libraries in said language, and because in most OSes it's the only way you can talk directly to the OS.",0.29704545454545456,C
148szdv,,"This had me thinking, gee it'd be great if I could automatically import the stdlib declarations from C headers into my language without having to write special ""glue"" code for each declaration I want to import...",0.5785714285714286,C
148szdv,,"I figured I could use a minimised C parser that is only designed to understand declarations (no definitions, function implementations or whatever), to parse any C header file that is requested, and then comb the declarations out of there.",0.0,C
148szdv,,"This should work fine for all C code which only consists of declarations, however there's a big issue here: what about macros?",0.1388888888888889,C
148szdv,,Edit: I'm wondering whether I should look into using SWIG for this and consume the XML parse tree it outputs for C headers on my end...,0.0,C
148szdv,jo1snic,">the ability to call C code from it is very useful because of the ubiquity of existing software and libraries in said language, and because in most OSes it's the only way you can talk directly to the OS.",0.2475,C
148szdv,jo1snic,"These just happen to be low level machine types, they are not specific to C.  But it is unfortunate that APIs for such libraries are very often expressed as C header files, using C syntax, which is really unsuitable for describing cross-language interfaces, for many reasons some of which you've discovered:  * It is necessary to parse C declaration syntax * Nested includes need algorithms (which are implementation-defined) to locate header files, together usually with a location for system headers, and a bunch of search locations for others * Headers may include conditional blocks using `#if`, `#ifdef` and so on.",0.01666666666666667,C
148szdv,jo1snic,"* Macro may expand to arbitrary C expression syntax * Instead of enumerations, headers may use tons of `#defines` to declare global constants.",-0.05,C
148szdv,jo1snic,There isn't really a simple solution that doesn't involve at least half of a C compiler.,-0.15555555555555556,C
148szdv,jo1snic,It does involve a home-made C compiler.,0.0,C
148szdv,jo1snic,"Some macro are simple, but others can contain arbitrary C code, expressions or statements.",-0.05,C
148szdv,jo1snic,Now you need a transpiler *from* C to your language (the other way is more common!).,0.0,C
148szdv,jo1snic,"Sorry I don't have a solution for you, and don't really like solutions that involve a C compiler (I think Zig bundles Clang for example).",-0.15,C
148szdv,jo1up8e,luajit ffi does a similar thing and it just ignores the macros....      it expects fully preprocessed C headers.,0.0,C
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,Pascal
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,C
148szdv,jo2yqa4,"A more modern approach is to write a tool to do a rough parse of the preprocessed C headers (I once wrote [a simple regex-based PHP script for that](https://github.com/uliwitness/Forge/blob/2c9e3245896342d10875629c1817bce909872a17/headerimport.php) for Apple platforms) and then add an ""overlay"" of hand-written code in your language that can replace parts of the automated import, or provide a more native interface.",0.22000000000000003,C
148szdv,jo2yqa4,"A more modern approach is to write a tool to do a rough parse of the preprocessed C headers (I once wrote [a simple regex-based PHP script for that](https://github.com/uliwitness/Forge/blob/2c9e3245896342d10875629c1817bce909872a17/headerimport.php) for Apple platforms) and then add an ""overlay"" of hand-written code in your language that can replace parts of the automated import, or provide a more native interface.",0.22000000000000003,PHP
148szdv,jo2yqa4,"Swift does that very well, but I think Perl does something similar.",0.1,Swift
148szdv,jo2yqa4,"Swift does that very well, but I think Perl does something similar.",0.1,Perl
148szdv,jo2yqa4,"Swift allows this by annotating API so it gets imported ""hidden"" and can only be used by the overlay.",-0.08333333333333333,Swift
148szdv,jo2yqa4,"In any way, as C API is often not complete anymore, you'll likely end up writing a different script for each platform, one to parse Apple's Swift interfaces, one for Microsoft's C# interfaces etc.",-0.016666666666666666,C
148szdv,jo2yqa4,"In any way, as C API is often not complete anymore, you'll likely end up writing a different script for each platform, one to parse Apple's Swift interfaces, one for Microsoft's C# interfaces etc.",-0.016666666666666666,Swift
148szdv,jo2yqa4,You might even write it so that it generates little C adapter functions based on attribute annotations and other things a particular platform's headers contain (e.g.,-0.04861111111111111,C
148szdv,jo2yqa4,Apple's headers use a proprietary 'nullable' attribute on all C headers to provide information C usually doesn't have).,-0.25,C
148szdv,jo3jzmq,In general as many others have mentioned C headers are a nasty pice of code and you'll effectivly need a full C compiler to parse them.,-0.024999999999999994,C
148szdv,jo3jzmq,Solutions to this problem include  a) Just have C or large parts of it as a subset in you language.,0.21428571428571427,C
148szdv,jo3jzmq,This is for the most part what C++ does.,0.5,C++
148szdv,jo3jzmq,"(More technically however most C headers still have to use ifdef CPP wrapped extern ""C"" blocks to get the name mangling right.)",0.3214285714285714,C
148szdv,jo3jzmq,"b) Just like a) but instead of really being a real subset, we parse C files with a different tokenizer, that remapps common tokens like ""if"", ""for"" and ""int"" onto specialized C version.",0.02500000000000001,C
148szdv,jo3jzmq,This would allow you to not being forced to have C constructs to take all the sweetspots.,-0.30000000000000004,C
148szdv,jo3jzmq,c) Have a bindgen tool like Rust's cbindgen.,0.0,Rust
148szdv,jo3jzmq,This uses libclang to parse you code and then create somehow meaningfull Rust code from it.,0.0,Rust
148szdv,jo4z5u8,It also supports some limited amount of C++ bindings which further complicates things.,-0.03571428571428571,C++
148szdv,jo3dix7,"In what I can only describe as _thoroughly annoying_, it turns out that stdlib implementations often don't just contain macros that we have to handle, but actual C code too (not just prototypes)!",-0.26666666666666666,C
148szdv,jo3jn0g,"It's almost like this problem is so annoying that I'm better off just building a library that documents the structure of the C stdlib in a machine-readable way using data structures, from which then any needed C glue code can be generated to lift out macro definitions and what-not...",-0.15000000000000002,C
148szdv,jo1t4cu,"I am really curious about your tool that parses C headers, would you mind linking to it, if it's openly available?",0.15000000000000002,C
148szdv,jo4wpme,C isn’t portable at all either without tons of macros.,0.0,C
148szdv,jo2zp1g,"I won't be wanting to parse function definitions like `int main(){}`, only declarations such as `int rand();`...  Re typedefs, yes I am already anticipating needing to do some kind of typedef-tree lookup in my parser for this (looking at preprocessed C source made it abundantly clear of the need to do so!).",0.17833333333333332,C
148szdv,jo2zzmf,"On adapting things, I've already contended with that at the bare minimum, I will need to write some additional C code of my own to be patched onto the end of any stdlib headers that define macros that I might want to use in my lang...",0.325,C
148szdv,jo2zwac,"I've thought about doing that, but I'd really like to avoid writing a whole C macro processor if I can possibly avoid it...",0.13333333333333333,C
148szdv,jo2zwac,I'd ideally like to take the cleanest fairly robust route towards turning a C header into a bunch of symbol definitions to import.,0.8,C
148szdv,jo37oxd,"Oh wait, I think I misunderstood —do you mean, process all C stdlib headers whilst my language compiler is being compiled?",-0.3125,C
148szdv,jo2zos6,The tool is based on a C compiler I created a few years ago.,-0.2,C
148szdv,jo2zos6,"I assume you're on Linux, but if you want to try it out, as an example of how it might work, try downloading this single-file C rendering of my compiler, which is for Linux:  [https://github.com/sal55/langs/blob/master/temp/cc.c](https://github.com/sal55/langs/blob/master/temp/cc.c)  This should be built using `gcc cc.c -occ -lm -ldl -fno-builtin`.",-0.75,C
148szdv,jo2zos6,"And C source may use names that are keywords in my syntax, although some are taken care of.",0.0,C
148szdv,jo2zos6,"In general however it will have trouble compiling arbitrary C code, even just the headers.",-0.08333333333333333,C
148szdv,jo2zos6,"Sometimes, a single DLL exists that corresponds to the C module name, in which case I can remove the `$`.",-0.07142857142857142,C
148szdv,jo2zos6,"In general, it will consist of C expression syntax, that needs to be translated by hand.",0.05000000000000002,C
148szdv,jo2zos6,ETA: [this](https://github.com/sal55/langs/blob/master/temp/cc_export.m) is the exports module of my C compiler that handles the `-mheaders` option.,-0.75,C
148szdv,jpfyoed,So why import the raw standard C library?,-0.11538461538461539,C
148szdv,jpfyoed,"C arrays and strings don't know their length, something most modern languages have built in.",0.35,C
148szdv,jpfyoed,"So it may be worth taking a step back, and instead of importing the C standard library, creating your own library that is implemented using standard C calls so it's portable.",0.18,C
148szdv,jpfyoed,Especially C's string manipulation is rudimentary.,0.0,C
148szdv,jpfyoed,So why even bother with C calls that don't support that?,0.0,C
148szdv,jo31t1x,"An initial workaround I can think of, at least for the stdlib, is to special-case them with some additional C code to extract them.",-0.15,C
148szdv,jo31t1x,"Apparently, you can ask GCC to dump macro names ~~(but not values)~~ with different options:    https://stackoverflow.com/questions/24388575/print-all-defined-macros   _Correction: I get both names **and** values when I use it!_   In any case, it seems to me the ideal would be to have a way to extract object-like macro definitions from C headers, but have the macro processing done separately...",0.3166666666666667,C
148szdv,jo33vha,"Those intrinsics, for example:      #define _mm256_mask_cvt_roundps_ph(A,B,C,D) _mm256_mask_cvtps_ph ((A), (B), (C), (D))  may be necessary for the *implementation* of SDL, where it will pull in the same system headers (or might not be needed at all, and they are just there), but they are certainly not needed to just use the SDL library via its API, so they don't need to be part of your bindings for the library.",-0.03571428571428571,C
148szdv,jo33vha,"Those intrinsics, for example:      #define _mm256_mask_cvt_roundps_ph(A,B,C,D) _mm256_mask_cvtps_ph ((A), (B), (C), (D))  may be necessary for the *implementation* of SDL, where it will pull in the same system headers (or might not be needed at all, and they are just there), but they are certainly not needed to just use the SDL library via its API, so they don't need to be part of your bindings for the library.",-0.03571428571428571,D
148szdv,jo3728d,"Also, unintuitive things like remembering that C's canonical `bool` is actually named `_Bool`..!",0.0,C
148szdv,jo3hcar,"In real code, there is the possibility of a clash between struct tag names and ordinary identifiers, since few languages have copied those peculiar namespaces from C.",-0.08333333333333333,C
148szdv,jo3m09o,"In original C code outside of macros, then `123ULL` would have `u64` type, however such constants I don't think occur in declarations, except perhaps as enum values, but C limits those to `int` values (maybe some apply extensions for wider types).",0.125,C
148szdv,jo3m09o,"When it comes to C runtime functions that users of my language want to call, then I write those bindings manually.",0.0,C
148szdv,jo3m09o,"While there can be over 1000 functions in the C runtime, I only define a few dozen.",-0.1,C
148pni0,jo1grje,"IMO, Kernel captures the essence of computation much more than Scheme, even though the languages look similar on the surface.",0.25,Scheme
148pni0,jo2l4ou,"The linker merges some variables together for languages following the C model but even then things get way more interesting with dynamic linking and multi-threading thrown in (especially with the ""C"" model).",0.2,C
148pni0,jo2l4ou,"Java doesn't have ""global variables"" though it has static class level variables which suffer some of the same downsides as truly ""global"" variables.",0.125,Java
148pni0,jo2l4ou,"Java also doesn't have dynamic scope (which at least one Scheme, MIT-Scheme supports via fluid-let and dynamic-wind (apparently conceptualized by RMS)).",-0.08333333333333333,Java
148pni0,jo2l4ou,"Java also doesn't have dynamic scope (which at least one Scheme, MIT-Scheme supports via fluid-let and dynamic-wind (apparently conceptualized by RMS)).",-0.08333333333333333,Scheme
148pni0,jo2l4ou,Steve Yegge claims dependency injection (aka Guice) is related to Java not having dynamic scope and I'm inclined to hear him out a bit.,0.0,Java
148pni0,jo2l4ou,"What SICP never showed was how this might end up optimized, by a smart enough compiler, to exactly create what say a Java compiler might produce (namely a shared method table plus an array of values (aka instance variables).",0.15476190476190477,Java
148pni0,jo2l4ou,"I believe MIT-Scheme got reasonably close with ""multi-closures"" which I think only need a level of indirection plus interning to behave more like Java style dispatch.",0.2333333333333333,Java
148pni0,jo2l4ou,People weren't writing Scheme code in an OOP style so at best chicken and the egg to incentivize certain work.,0.20476190476190478,Scheme
148pni0,jo2l4ou,"Of course to compare with C++ where much dynamic dispatch is actually statically done, that might be a heavier lift.",0.0,C++
148pni0,jo2dwbj,"From a certain perspective, therefore, there are no ill-typed Scheme, Python, BASIC, etc.",0.10714285714285714,Scheme
148pni0,jo2dwbj,"From a certain perspective, therefore, there are no ill-typed Scheme, Python, BASIC, etc.",0.10714285714285714,Python
148pni0,jo5sho8,"He carefully read the entire ""Lambda: The Ultimate..."" series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system.",-0.0875,Scheme
148pni0,jo369a6,"There are examples of tools which reject badly typed or insufficiently typed dynamic languages statically, such as Erlang's dialyzer.",-0.23333333333333328,Erlang
148pni0,jo369a6,I know because I spent a long time there myself before I learned Scheme and then later Kernel (which I discovered when searching for solutions to problems I had with macros and quotation).,-0.05000000000000001,Scheme
148pni0,jo369a6,"The presence of preprocessors, never-ending extensions to Haskell and tools like TemplateHaskell demonstrate that static typing is clearly less expressive than we want it to be.",0.37777777777777777,Haskell
148pni0,jo40cfm,"And I don't dispute that the profusion of extensions to Haskell shows *something*, but I'd argue it is more about the limitations of *Haskell* than the limitations of type-checking as a convention.",0.5,Haskell
148pni0,jo40cfm,"The choice to use, say, TemplateHaskell rather than C++ means someone sees a certain benefit to making that particular compromise.",0.19047619047619047,C++
148pni0,jo3pw4k,"For example, in Dart:      extension IntExt on int {       int get increment => this + 1;     }      main() {       var n = 1;       print(n.increment); // ""2"".     }",0.16666666666666666,Dart
148pni0,jo3pw4k,You can't make a functioning C++ implementation without a type checker.,0.0,C++
148pni0,jo3pw4k,"> In the case of something more interesting like indirect method calls, the static type annotations do not direct semantics;  Sure, dynamic dispatch doesn't require static types, as Smalltalk, JavaScript, Ruby, etc.",0.35000000000000003,JavaScript
148pni0,jo3pw4k,"> In the case of something more interesting like indirect method calls, the static type annotations do not direct semantics;  Sure, dynamic dispatch doesn't require static types, as Smalltalk, JavaScript, Ruby, etc.",0.35000000000000003,Ruby
148pni0,jo3i6kw,I would consider overloading in Haskell.,0.0,Haskell
148k8qy,,"If you'd ever wanted to just brain dump language ideas that should be in C, here's the time someone would actually appreciate it.",0.0,C
148k8qy,jo18f0p,"For start, few things that I miss in og C and just can't refuse this opportunity to rant about them, even though they are pretty specific and mostly don't make sense in your C3:  * typedefs nested inside structs etc.",0.1375,C
148k8qy,jo18f0p,"* Post-assignment operators (like post-increment/decrement, but generic assignment operation) - I don't have a good idea how the syntax should look like, but it's just really inconsistent, that C has post- variants specifically for `++`, `--`, but not for anything else.",0.3,C
148k8qy,jo1ej96,Go has this and it's a huge headache when it comes to dealing with databases.,0.4000000000000001,Go
148k8qy,jo0y60j,That's my number one feature for any low-level language trying to improve upon C.,0.0,C
148k8qy,jo1a6ql,">If you'd ever wanted to just brain dump language ideas that should be in C,  In C, or in C3?",0.0,C
148k8qy,jo1a6ql,The feature list you recently posted for the latter already covers most of the things people want to have in C. (Other than C++ features without being C++; that seems a very common desire.),-0.0030000000000000027,C++
148k8qy,jo1a6ql,The enhancements you've already made to C are plenty to be going on with.,0.0,C
148k8qy,jo3vbpb,"I'd like sum types (Rust `enum`s) and pattern matching, but that seems to conflict with 'zero is initialization'.",0.0,Rust
148k8qy,jo0g9vr,For a moment I though that the CONST passive-agressive was a C like feature,0.0,C
148k8qy,jo0n4is,Memory safety through the borrow checker is Rust's main feature.,0.16666666666666666,Rust
148k8qy,jo0n4is,"But it requires things like move semantics, which is very different from C semantics.",0.0,C
148k8qy,jo0n4is,"As C3 is an evolution on C, it doesn't fit well.",0.4,C
148k8qy,jo1v08a,Rust's memory safety is via the type system.,0.0,Rust
148k8qy,jo1v08a,The OP's response mentioning Rust's borrow checker suggests that you're talking past each other.,-0.1875,Rust
148k8qy,jo1f3df,"that don't pollute global namespace  Is that particularly useful in C because of headers and no namespacing, or is there something else you want it for?",0.15,C
148k8qy,jo1gvbd,"> Go has this and it's a huge headache when it comes to dealing with databases  Ok, so I'm not sure how the problem arises there, but I would assume that fields are passed by reference as pointers, in which case you have `null` as null and everything should be fine.",0.2666666666666667,Go
148k8qy,jo13y56,Meanwhile C is commonly used as a target or intermediate language by such higher level languages as Nim or Haskell.,-0.016666666666666663,C
148k8qy,jo13y56,Meanwhile C is commonly used as a target or intermediate language by such higher level languages as Nim or Haskell.,-0.016666666666666663,Haskell
148k8qy,jo13y56,"BTW the thread isn't about C or C++, but ideas suitable for that level of language.",0.55,C
148k8qy,jo13y56,"BTW the thread isn't about C or C++, but ideas suitable for that level of language.",0.55,C++
148k8qy,jo50bbv,"When you say sum types and mention Rust, I assume you basically mean tagged unions?",-0.3125,Rust
148k8qy,jo50bbv,"That is not necessarily difficult, but I've found it somewhat hard to find good syntax for it that meshes with C syntax.",0.21944444444444441,C
148k8qy,jo50bbv,"Plus in C at least I run into the case where a single ""tag"" field affects the interpretation of multiple separate union members in a struct.",-0.12380952380952381,C
148k8qy,jo50bbv,"I extended the switch in C to take arbitrary ""case"" expressions, making it a lot like pattern matching but without the binding.",-0.1,C
148k8qy,jo3eurl,"Best solution I found so far how to solve this runtime-overhead-free in og GCC C is by defining zero-length array of the handle type inside the node type ([like here](https://github.com/MarkusSecundus/Shell/blob/main/datastructs/ultimate_list.h)) and then using `__typeof__(node->_handle_typeinfo[0])` or something like that xDD, which is just so insanely ugly.",0.1333333333333334,C
148k8qy,jo1krmo,"(C3 also has some ability to annotate for null safety)  Let's say you have three fields in a postgres database a, b, and c. All are nullable but C has a default value.",0.0,C
148k8qy,jo1krmo,"If you only insert a, and b then C will get the default value specified in the database and not null as above.",0.0,C
148k8qy,jo1krmo,"It works great in Erlang, PgPsql, crystal etc.",0.8,Erlang
148k8qy,jo1arpb,"Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,C
148k8qy,jo1arpb,"Plenty of people would dearly love C++ to die, and that's not really commentary on C.",0.2,C++
148k8qy,jo1arpb,"Plenty of people would dearly love C++ to die, and that's not really commentary on C.",0.2,C
148k8qy,jo339yr,"So we could imagine something like this:  ```c typedef struct { int; char; } mytuple;  mytuple foo = { 42, 'c' }; int x = foo.0; char y = foo.1; ```  We take the `.X` syntax from Rust and simply re-use other C syntax.",-0.0625,Rust
148k8qy,jo339yr,"So we could imagine something like this:  ```c typedef struct { int; char; } mytuple;  mytuple foo = { 42, 'c' }; int x = foo.0; char y = foo.1; ```  We take the `.X` syntax from Rust and simply re-use other C syntax.",-0.0625,C
148k8qy,jo0oolk,"Compiling LLVM and LLD by hand will always work, but not everyone has the time to spend compiling those... :D",1.0,D
148k8qy,jo2w75f,So for example you can do dynamic calling in C3 by just doing a regular call on the `any` type (so like Go's `interface{}`):      Foo f;     Bar b;     any x = &f;     any y = &g;     x.test(); // Calls `test` on Foo     y.test(); // Calls `test` on Bar  But in order to make this happen and fit for C more ceremony in terms of *defining* `test()` is needed.,0.225,Go
148k8qy,jo2w75f,So for example you can do dynamic calling in C3 by just doing a regular call on the `any` type (so like Go's `interface{}`):      Foo f;     Bar b;     any x = &f;     any y = &g;     x.test(); // Calls `test` on Foo     y.test(); // Calls `test` on Bar  But in order to make this happen and fit for C more ceremony in terms of *defining* `test()` is needed.,0.225,C
148k8qy,jo2w75f,"It works great in Erlang, PgPsql, crystal etc.",0.8,Erlang
148k8qy,jo1v7l9,">Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,C
148k8qy,jo1v7l9,"(Now they target C, LLVM, WebAssembly, Javascript, JVM, and other such ubiquitous layers.)",-0.0625,C
148k8qy,jo1v7l9,>that's not really commentary on C  Which is why discussing it here is off-topic.,-0.1,C
148k8qy,jo2wcdm,"Don't forget p-code, which first showed up in the late 60s, then going mainstream with the Pascal compilers in the 70s.",-0.024999999999999994,Pascal
148k8qy,jo1x0m1,Why C ?,0.0,C
148k8qy,jo1x0m1,"Forth was easily ported, for instance...",0.43333333333333335,Forth
148k8qy,jo2xzr0,"Languages with C backends, like Nim and Zig, are portable because C is, again, *ubiquitous*.",0.0,C
148k8qy,jo2xzr0,There are portable Forth systems ... they are portable because *they are written in C*.,0.0,Forth
148k8qy,jo2xzr0,There are portable Forth systems ... they are portable because *they are written in C*.,0.0,C
148k8qy,jo2xzr0,"And Forth is an interpreted language ... there are no good reasons to write a Forth backend for a compiler and several good reasons to write a C backend, including efficient interop with the existing extensive C ecosphere.",0.0875,Forth
148k8qy,jo2xzr0,"And Forth is an interpreted language ... there are no good reasons to write a Forth backend for a compiler and several good reasons to write a C backend, including efficient interop with the existing extensive C ecosphere.",0.0875,C
148k8qy,jo2xzr0,"As u/till-one already pointed out, whining about C and C++ is off topic.",0.0,C
148k8qy,jo2xzr0,"As u/till-one already pointed out, whining about C and C++ is off topic.",0.0,C++
148k8qy,jo2xzr0,And Forth is even more off topic.,0.5,Forth
148k8qy,jo2xzr0,"I already answered your question of why C is a good backend target, and I'm not even sure you're not pulling my leg by bringing up Forth.",0.6,C
148k8qy,jo2xzr0,"I already answered your question of why C is a good backend target, and I'm not even sure you're not pulling my leg by bringing up Forth.",0.6,Forth
148k8qy,jo31fo6,It's clear that C is just riding a historical headwind.,0.05000000000000001,C
148k8qy,jo31fo6,"I'm saying, why C as opposed to other languages that did exist at that level?",-0.125,C
148k8qy,jo31fo6,The history of C and its near competitors is hardly off-topic.,-0.09583333333333334,C
148k8qy,jo31fo6,"Forth did not, historically, achieve portability by being written in C.  It achieved it by being mostly written in *Forth*, with not that much machine-specific code necessary.",0.175,Forth
148k8qy,jokla92,"As you say, C is omnipresent.",0.0,C
148k8qy,jokla92,And I actually like C quite a lot.,0.0,C
148k8qy,jokla92,"But C is already perfectly good at being C-like (being the most C-like language there is - the real thing, by definition.)",0.4666666666666666,C
148jook,,A good example is a Bash program that compiles a Bash string to an executable.,0.7,Bash
147rwl1,jocsebm,I chose Java because it is a awesome object oriented language and I wanted something different from C++.,0.5,Java
147rwl1,jocsebm,I chose Java because it is a awesome object oriented language and I wanted something different from C++.,0.5,C++
147k92s,,"Hello everyone, i started this project one week ago, it's a query language with a syntax very similar to SQL written in Rust Programming language to perform CURD operations on .git files, for now, it only supports selecting but will implement more operations.",0.16666666666666666,Rust
147k92s,jnxc7by,Given that your project is also written in Rust you could just include the prql-compiler crate and have that generate SQL/GQL which you then process as before.,0.0,Rust
147k92s,jnvxih4,"Currently, I am working on improving code structures then I will add the option to be used as a library because already i need to use it inside another project :D",0.5,D
147k92s,jnyzrx4,"As an objective benchmark (which I just thought of), the difference between Google search results for ""I hate Java"" and ""I hate SQL"" (as phrases in quotes) is two orders of magnitude in favor of SQL.",-0.5333333333333333,Java
147k92s,jnyzrx4,"The difference between ""I love Java"" and ""I love SQL"" is one order of magnitude in favor of SQL.",0.5,Java
147k92s,jnyxjax,"I am very interested in Compiler and Programming languages, so when trying to practice as much as I can for example I created a port for Turtle graphics [https://github.com/AmrDeveloper/Turtle](https://github.com/AmrDeveloper/Turtle), last two weeks I was reading a book called Building git, it is about building git from scratch and start learning rust then got the idea of merging the idea and create a language to run on .git files and on the started i think of implementing it as some language like Lua but i found that SQL like will be easier for this case",0.17500000000000002,Lua
147k92s,jnvy6no,"Great to hear :) I have use for something like this in a python project, do you think it would be possible to wrap the rust library in C to facilitate import to python?",0.43333333333333335,C
147k92s,jnvzmoj,"I don't know if it possible, this is my first Rust project :D, we can search about it",0.4166666666666667,Rust
147k92s,jnvzmoj,"I don't know if it possible, this is my first Rust project :D, we can search about it",0.4166666666666667,D
147k92s,jnw509e,"There is PyO3 project, created specifically to facilitate developing python modules in Rust.",0.0,Rust
14783jp,,For the problem I'm trying to solve the union and intersection types correspond roughly to TypeScript's.,-0.1,TypeScript
14783jp,jnvitvb,"It is being used to try to add static types to Elixir for example, see [this blog post](https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/).",0.5,Elixir
14783jp,jo2k866,Hot news: [Elixir's “Set Theoretical Type System” prototype/demo/showcase](https://news.ycombinator.com/item?id=36299214).,-0.16666666666666666,Elixir
147657x,jnusw0r,I'm using C for my language so I can't use any fancy OOP.,0.0,C
147657x,jnvufrv,"Given how messy type solvers can get with generics and type inference, it also helps that I don't have to be writing that logic in C (my interpreter is in C89)  I'm kind of curious what other people's approaches are as well  If I had all the time and money in the world though, I would be building an interpreter that can make optimizations based on static types.",0.13499999999999998,C
147657x,jnzqi1v,"I have runtime types, so instructions like 'add', 'sub' perform action on runtime types.I want move out types from VM, but the main problem is order-independent declaration.I don't want to implement forward declaration like in C or C++.",0.13333333333333333,C
147657x,jnzqi1v,"I have runtime types, so instructions like 'add', 'sub' perform action on runtime types.I want move out types from VM, but the main problem is order-independent declaration.I don't want to implement forward declaration like in C or C++.",0.13333333333333333,C++
1475h9o,jntz751,They might generate source code for another language (eg C); or generate some intermediate language like LLVM; or generate assembly *source code* like ASM.,0.0,C
1475h9o,jntyywr,Figure out its grammar (see the back of the classic ANSI C book for C's grammar) and the semantics for that grammar.,0.08333333333333333,C
1475h9o,jntvw7d,"Will you make it like an existing language, like Basic, C, or Lisp?",0.0,C
1475h9o,jntvw7d,"Will you make it like an existing language, like Basic, C, or Lisp?",0.0,Lisp
1475h9o,jntvw7d,Making a Basic interpreter in Python: https://youtube.com/playlist?list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD  Making a Lisp interpreter: https://youtube.com/playlist?list=PLWUx_XkUoGTrXOU0pFa_OVGA-6voiIEAt,0.0,Python
1475h9o,jntvw7d,Making a Basic interpreter in Python: https://youtube.com/playlist?list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD  Making a Lisp interpreter: https://youtube.com/playlist?list=PLWUx_XkUoGTrXOU0pFa_OVGA-6voiIEAt,0.0,Lisp
1475h9o,jnvhwu9,"* Compile your language to another one, preferably to C, and compile the generated C source for the final product.",0.0,C
1475h9o,jnvhwu9,"Writing a transpiler can be pretty easy, especially, if your language is similar to C (even Python is a C-like language, with a slightly different syntax).",0.13666666666666666,C
1475h9o,jnvhwu9,"Writing a transpiler can be pretty easy, especially, if your language is similar to C (even Python is a C-like language, with a slightly different syntax).",0.13666666666666666,Python
1475h9o,jnzq8we,Another common recommendation:  * Thorsten Ball's [Writing A Compiler In Go](https://compilerbook.com/),-0.3,Go
14759gv,,It sits on top of another language (Java) and is interpreted.,0.5,Java
146xui4,,"So I was learning a bit of Haskell recently, and thought wouldn't it be nice if we could write foldl and foldl' as one polymorphic function?",0.3,Haskell
146qyyc,,"Hello, I'm writing a C compiler for fun, and I would like my compiler to go from source code to SSA IR in one pass.",0.3,C
146qyyc,jnrtqtn,"In C, preprocessing is done first as a strictly textual replacement and then the lexer is run in the next step.",0.125,C
146qyyc,jnsdpgv,"A ""traditional"" C compiler operates on streams.",0.0,C
146qyyc,jnrvaxt,I've done a C preprocessor in a single pass.,-0.07142857142857142,C
146qyyc,jnrvaxt,"This way, you will be able to offload the work to a separate C compiler to get started (use it with `-E` to get preprocessed input for your compiler), and get back to your own CPP later.",0.275,C
146qyyc,jnrvaxt,You say you're doing this for fun; I can tell you from experience that writing a C preprocessor is not fun!,0.056249999999999994,C
146qyyc,jnsnqi4,"Macros in C never operate on ""old ones""; they only operate on subsequently processed text.",0.03333333333333333,C
146qyyc,jnsnqi4,"I'm not aware of any examples in C in which a single pass that includes macro expansion would not work, but if you are, then please share the problems that you're aware of, using examples.",0.01785714285714286,C
146qyyc,jnterwr,"C translation is specified to be an ... 8-phase process, at least in whatever old draft of C23 I have laying around.",-0.09999999999999999,C
146qyyc,jo0p5rf,"In the example you gave in this comment (which I know you said was invalid C but it needs to be lexed to figure that out in the first place, right?",0.26785714285714285,C
146qyyc,jnsrlhp,"Yup, preprocessor isn't valid C, instead it is a second language meant to define ways to rewrite and modify text files.",0.0,C
146qyyc,jnsa5w5,"Yeah, I imagine you could still just do any replacements between reading the text and outputting the AST, either before or after the lexer tokenises depending on whether you want to preprocess the raw text (as the C preprocessor does) or tokens (no idea if it would be useful to process tokens prior to generating the AST nodes vs processing the AST nodes like in a macro system)",0.023076923076923068,C
146qyyc,jnsdc0d,"The C pre-processor transforms an intermediate tokenized stream of so called ""pre-processor"" tokens into a different stream of the same.",0.0,C
146qyyc,jnsrbn1,I thought code like this could be a problem  &#x200B;  \#define PLUS +   int main() {     int i = 0;     return i+PLUS;        }  &#x200B;  But apparently that's not valid C code.,0.10833333333333334,C
146qyyc,jnt7nbc,"I don't think the second scenario is possible, the preprocessor wouldn't produce binary (in C or C++ at least, I don't know of any other langs that use preprocessing) it's just text replacement",-0.10625,C
146qyyc,jnt7nbc,"I don't think the second scenario is possible, the preprocessor wouldn't produce binary (in C or C++ at least, I don't know of any other langs that use preprocessing) it's just text replacement",-0.10625,C++
146noct,,"Oh, and it's a hacked Haskell, so the sequencing primitive turns into do-notation, and the *don't-memoize* operator turns into the IO monad.",0.0,Haskell
146noct,,"Arguably, do-notation is just the ALGOL semicolon in disguise.",0.0,ALGOL
146noct,,"The only resolution to this paradox -- at least in the Haskell worldview -- seems to be that `IO` is highly magical, so that functions in that monad must be recalculated rather than memoized.",0.06666666666666667,Haskell
146noct,jnrlgmc,Also note that the final IO monad in that post is not equivalent to the one in Haskell and will probably not hold up under aggressive GHC-style optimizations and inlining (more on this later).,0.16666666666666666,Haskell
146noct,jnrlgmc,>do-notation is just the ALGOL semicolon in disguise  It's not.,0.0,ALGOL
146noct,jnrlgmc,"`seq` is the ALGOL semicolon in diguise (well, up to weak head normal form anyway).",-0.1125,ALGOL
146noct,jnrlgmc,"`(>>=)` on its own does not perform any sequencing (that is what `seq`, a primitive that cannot be implemented in Haskell directly, is for).",0.4000000000000001,Haskell
146noct,jnrlgmc,"Haskell's semantics never ""rewrite under a lambda"" (unlike, e.g.",0.0,Haskell
146noct,jnrlgmc,But optimizations do exist and that is why Haskell's `IO` is defined more intelligently than `() -> a`.,0.65,Haskell
146noct,jnrlgmc,"The full definition looks like this (which would still be fine if Haskell could rewrite under lambdas)      newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)  Note that `RealWorld` is a phantom argument that is only necessary to distinguish between effectful `IO` and pure `ST`, `State#` is a zero-sized type, and `(# , #)` is an unboxed tuple.",0.1961904761904762,Haskell
146noct,jnrlgmc,This is used to implement Haskell's infamous lazy IO.,-0.375,Haskell
146noct,jnwkmfd,Haskell even has an extension for this (`-XStrictData`) that makes constructor fields strict by default.,0.0,Haskell
146noct,jnwb1q8,"What about Haskell’s approach, where it’s lazy by default but you simply put a `!` before a data type field that you want to be strict (and also you can use `seq` for strictness in expressions)?",-0.125,Haskell
146noct,jnz4nco,"This is Haskell's ""lol no generics"" and GHC fixed it recently with [unlifted datatypes](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/primitives.html#unlifted-datatypes) in a very late response to the [famous blog post by Bob Harper](https://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/).",0.202,Haskell
146noct,jo1q05p,"I had to read the comment a couple times, but I think it is an analogy to how people talk about the lack of generics in Go?",0.0,Go
146noct,jo367sv,"In analogy to Go's ""lol no generics"" (which has been a joke for years and finally fixed), there is the ""lol no values"" joke about Haskell (which has been finally fixed).",0.45000000000000007,Go
146noct,jo367sv,"In analogy to Go's ""lol no generics"" (which has been a joke for years and finally fixed), there is the ""lol no values"" joke about Haskell (which has been finally fixed).",0.45000000000000007,Haskell
146noct,jo2z5bs,So it’s not that Haskell would supposedly not have generics.,0.0,Haskell
146noct,jo2z5bs,It’s like the situation with Go.,0.0,Go
146au5t,jnpeau5,C .,0.0,C
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,PHP
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,Haskell
146au5t,jnvqb7t,I'm implementing a subset of C++ with WebAssembly and custom VM targets.,0.0,C++
1464vgx,jnvqz2m,"However, I've seen that one of the C++ classes used internally by JIT has a tempdir member and I'm sure `FILE*`s are stored somewhere too, so I think the way I really want to be approaching it is to acquire them.",0.175,C++
1460agz,jno3eyj,And with the compiler written in Haskell no less!,0.10416666666666666,Haskell
1460agz,jnolpqn,How was writing the compiler in Haskell though?,0.0,Haskell
1460agz,jnz3qm9,"Well, if you like Haskell you could look into the [CPU example in Clash](https://yager.io/CPU/CPU1.html)",0.0,Haskell
1460agz,jnouyjx,"I am in the UK, but not the North so that was someone else :D",1.0,D
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,C
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,TypeScript
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,Rust
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,Go
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,C++
145llww,jnncqhz,C# uses (as far as I'm aware anyway) a relatively standard bidirectional inference algorithm.,0.11666666666666665,C
145llww,jnncqhz,"But at this point, there is no way for C# to know which type would be appropriate!",0.625,C
145llww,jnncqhz,"`IEnumerable<out T>`, C# doesn't do this, even though it could).",0.0,C
145llww,jnncqhz,"Similarly, TypeScript infers `never []`, which is sound, because it means that the array is effectively immutable (there is no way to construct values of type never), so *all* elements of the list vacuously have any type you want (there are none).",0.3333333333333333,TypeScript
145llww,jnncqhz,"Rust on the other hand is (roughly) Hindley-Milner based, so it doesn't have to work out every type immediately.",-0.1125,Rust
145llww,jnncqhz,"In Rust, `Vec::new()` will return `Vec<_a>`, where `_a` is a *unification variable*.",0.0,Rust
145llww,jnncqhz,"In other words, instead of committing to a type immediately, Rust infers a placeholder for it.",-0.125,Rust
145llww,jnncqhz,"Later, instead of checking for type equality directly, Rust will perform unification and work out the values of these unification variables.",0.05,Rust
145llww,jnncqhz,"Rust's syntax for function types is not great, so I am going to use something a bit more Haskelly here.",0.04999999999999999,Rust
145llww,jnncqhz,"Now, Rust knows that `_a = &str` and so it knows that the *real* type of `list` should be `Vec<&str>`.",0.2,Rust
145llww,jnncqhz,"In Rust's type system (without unions), what you described is exactly what is going to happen.",0.25,Rust
145llww,jnncqhz,"It is a bit long, but very detailed and it features a full implementation in Haskell",0.2733333333333334,Haskell
145llww,jnol753,TypeScript is actually an... [interesting example](https://www.typescriptlang.org/play?#code/PQKhCgAIUgVBPADgU0gSwHYDNkCdkYDGqA7mgC4AWkARgK5oA25mkAFAIK64CG8AlFBhDIASWx4AzpAAGPDPADaAXRm065SJOTIAttPIB7Wqh5aUhND0aRCh3YiZ5bPbZCOQ6GNFnjpNjDzkeELA4OCMyAFokpoAvJAq4MDAkJAAegD8ETHkAHSIdJKUbABEwbGlgikZ2Yy5yalZ4QAmyISB+JAAbjy4WvbIAMKGGC0UaKMAXLSGhpHy4ZHRsQBMkAlJNWnN4D7skoMjYxOj-JAA3lBpkPVrBUUl5ciV1am14AC+kMiMblc3W65VYPYpsACMqwAzG8dtlPktgY0PskwCIECh0BJ8ERSBRqEU8ABaNpYTDIFqQFpBMzkJDIEToyioSQ8XSoADWmEphiwnm8ZMIQUmGCphheGAA5JpDIRCHRcAAaOD0gDKhFwaEQ5BEACsippMDhcAZme5DIh3PS8qFwnTMbB8MgADywAB8G2uaQAPpdIFyxjNJQssJLIAjAb6Lv7uUGMIY2pLldTyDwZrBlYRKEwWjj007XW6VOHwlgvIQWKNILoeBzkAAZZA8LCFtj8fM6QuXL2QfDkBWi6MBlozUoh0olhHgMtESuimt1gByCZd7rYKbTcEz2cYuYIHdXReUG0SynbcAL7u7gL7A79w7jK6TVJp25zOMnSyitybfISC4bX822RD5ll7OZ4mrWtkGXNoIWhZVFBDM8QKyIA) because it depends on compiler settings.,0.25,TypeScript
145llww,jnol753,The TypeScript [checker.ts code](https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts) is a single 50k LOC file so I'm probably not going to be able to understand the implementation.,0.2142857142857143,TypeScript
145llww,joy4x67,C# doesn't add covariance to `List` because it is backed by a mutable array.,0.0,C
145llww,joy4x67,The mistake was made with arrays and inherited from Java:      Tiger[] tigers = new Tiger[] { new().... };     Animal[] animals = tigers;     animals.Add(new Giraffe());  Crashes because `Giraffe` may use more memory than the `Tiger` array slot provides or someone might inspect the `Tiger` array after the giraffe was added.,0.25757575757575757,Java
145llww,jnlzppe,RE: #3 - One example is [TypeScript unifies](https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEA3W8DOB7AtiAwugdsAJYAuRBAXPAEbroQhT4BQzDJ8ERqHAvPAG0AuqyIAzeAAoM2PIVLl8ASngBvZvE2duJAHQAHAK6oAFpIBEJED3NLmAX3ggIqBOq3aeB42YCMAJgBmO3tWLh5mAHpI+AA9AH5WaPgAQQAfACF4bngoNENqEgBPfQR0CXSMtJxmYtL4ABVrPikeGCJ8AHN4NPh8Q0xqEBgVEAAPK0JUVpJ2rp6+gaGYBdp6RmV4ePhZwwQqMSgXECiYrQTmIA) that situation as `List<A|B>`.,0.0,TypeScript
145llww,jnortte,"My compiler is also written in Rust and has basically the same idea of a ""database"" (a struct of arenas) that gets updated as we churn through the HIR.",0.0,Rust
145llww,jno18ya,"For `Any`, are you referring to the [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any) kind of any which turns off the type checker completely, or are you referring to the [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) kind of any that is the top type?",0.44999999999999996,TypeScript
145llww,jno18ya,"For `Any`, are you referring to the [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any) kind of any which turns off the type checker completely, or are you referring to the [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) kind of any that is the top type?",0.44999999999999996,Kotlin
145llww,jnoh7f5,Go).,0.0,Go
145llww,jno2edb,"I refer to `Any` in the TypeScript sense, which seems common among numerous tools.",-0.15,TypeScript
145llww,jno2edb,Kotlin's choice of terminology there is confusing - is it what is often called `BaseObject` (since often there are primitive types that don't extend `Object`)?,-0.3,Kotlin
145llww,jnoj6on,Go).,0.0,Go
145llww,jnoj6on,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,Pascal
145llww,jnoj6on,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,ALGOL
145llww,jno5umm,"If I understand correctly, from a type system perspective Kotlin has no primitive types, so `Any` is the top type, the superclass of every class.",0.5,Kotlin
145llww,jno5umm,"So yeah, in other languages that might be called `Object`, and like Java `Object` it has methods `equals`, `hashCode`, `toString`.",-0.125,Java
145llww,jno5umm,Unlike Java `Object` it really is the top type because there are no primitives.,0.35,Java
145llww,jno5umm,"I believe Kotlin compiles the `Int` ""class"" into JVM primitive integers when possible, but that's an implementation detail of the JVM code generation not the type system (Kotlin has other compilation targets like JS or experimental WASM compilation).",-0.008333333333333331,Kotlin
145llww,jnollaj,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,Pascal
145llww,jnollaj,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,ALGOL
145kps7,jnlvtnf,[Here's an implementation in Common Lisp](https://github.com/stylewarning/computable-reals).,-0.3,Lisp
145hkld,,On Elm's homepage there's a reference to a John Carmack tweet praising the Elm compiler: [https://twitter.com/ID\_AA\_Carmack/status/735197548034412546?s=20](https://twitter.com/ID_AA_Carmack/status/735197548034412546?s=20)   I've been using Better Exceptions with the python interpreter and I hate developing without it.,-0.35000000000000003,Elm
145hkld,jnmszq0,Try Steel Bank Common Lisp.,-0.3,Lisp
145hkld,jnlg34z,"The Rust language compiler is known for generally having good error messages, and being much more clear in what the issue is compared to other languages.",0.24500000000000002,Rust
145hkld,jnmzh04,"C++ aside, what languages do you think have compilers with incomprehensible error messages?",0.0,C++
145hkld,jnqafzn,"Elm's error messages are famously detailed, but I sure did hit a lot of them while banging my head against its standard JSON library.",0.3,Elm
145hkld,jnqafzn,"In contrast, Python's a bit more terse, and I agree that static types are nice, but json.loads(...) is practically a godsend in comparison.",0.5333333333333333,Python
145hkld,jnnk0x7,"Gotchaaa, the short loop of development sounds like what I’ve heard from Clojure devs.",0.0,Clojure
145hkld,jnlgox8,A great compiler might be the push that gets me to finally try Rust.,0.4,Rust
145hkld,jnn37gu,"Not exactly compiled, but Groovy.",-0.125,Groovy
145hkld,jnnp8tc,"Sure, Clojure was created by a guy who was proficient in Common Lisp and tailored it specifically to his needs.",0.1,Clojure
145hkld,jnnp8tc,"Sure, Clojure was created by a guy who was proficient in Common Lisp and tailored it specifically to his needs.",0.1,Lisp
145hkld,jnnp8tc,"It's more opinionated a language as well and it's easier to write ""line-of-business"" applications in it which can leverage existing Java ecosystem (which is important for many enterprises).",0.4666666666666666,Java
145hkld,jnnp8tc,He also decided not to incorporate many Common Lisp features (some because they don't really play well with Java and some because he decided they were detrimental to the style of programming he promotes) and added some extra (which are either external libraries in CL or don't exist at all).,0.08,Lisp
145hkld,jnnp8tc,He also decided not to incorporate many Common Lisp features (some because they don't really play well with Java and some because he decided they were detrimental to the style of programming he promotes) and added some extra (which are either external libraries in CL or don't exist at all).,0.08,Java
145hkld,jnnp8tc,Problem with Clojure is that you often see Java stack traces and Java exceptions.,0.0,Clojure
145hkld,jnnp8tc,Problem with Clojure is that you often see Java stack traces and Java exceptions.,0.0,Java
145hkld,jnnp8tc,"Not a problem for me, I have written more Java than any other language (yes, I was paid to do so, that was the reason :-D ).",0.4583333333333333,Java
145hkld,jnnp8tc,"If you really decide to dig into Common Lisp (it's not everybody's cup of tea), check this linter as well: [https://github.com/g000001/lisp-critic](https://github.com/g000001/lisp-critic) , or this wrapper over Lisp Critic which can work very well in your CI/CD pipelines if you use them: [https://github.com/40ants/40ants-critic](https://github.com/40ants/40ants-critic) .",-0.27999999999999997,Lisp
145hkld,jnls7z8,"Wouldn’t say Rust is exclusively for “low-level programming”, depending on which definition you are using.",0.0,Rust
145hkld,jnls7z8,Rust has a lot of modern language features,0.2,Rust
145hkld,jnm5k5i,It's worth noting that the Rust compiler team [draws a lot of inspiration from Elm](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html)   > Those of you familiar with the Elm style may recognize that the updated --explain messages draw heavy inspiration from the Elm approach.,0.15833333333333335,Rust
145hkld,jnm5k5i,It's worth noting that the Rust compiler team [draws a lot of inspiration from Elm](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html)   > Those of you familiar with the Elm style may recognize that the updated --explain messages draw heavy inspiration from the Elm approach.,0.15833333333333335,Elm
145hkld,jnumeat,"Elm evidently treats `type` definitions as like a nominal reference-type, but `type alias`es as structural composite things without any implied referencing.",0.25,Elm
145hkld,jnnx60b,"Mmmmm okay, I found: ""He also decided not to incorporate many Common Lisp features \[...\] some because he decided they were detrimental to the style of programming he promotes"" especially interesting because programming style is so personal.",0.33999999999999997,Lisp
145hkld,jnllsu2,"(Right now, I think this about Ruby and TailwindCSS).",0.2857142857142857,Ruby
145hkld,jnqdfj2,"Ironically, Clojure has pretty bad error messages.",-0.22499999999999992,Clojure
145hkld,jnlw3tg,I just thought you should give Rust a try even if you’re not writing performance and memory safety sensitive programs.,0.1,Rust
145dugl,jnl2pjl,"Some ecosystems like Cloud Haskell did it for static closures (known ahead of time, like functions within the same code base which get explicitly marked as such), which is easier but it won't work for arbitrary database servers.",-0.05000000000000001,Haskell
145dugl,jnn7zhy,See [javactrl](https://github.com/javactrl/javactrl) for a Java implementation of continuations that is serializable,0.0,Java
145dugl,jnnhfy4,Adam Dunkels' [Protothreads](http://dunkels.com/adam/pt/) library is an implementation of stackless coroutines based on C macros that resolve to state machines.,0.0,C
145d24u,jnmj4pz,"It can generate C, Go and my language.",0.0,C
145d24u,jnmj4pz,"It can generate C, Go and my language.",0.0,Go
145d24u,jnmj4pz,"Go was about 85K (array writes) on my PC, clang was 95K (array writes, clang compiles 230K lines of sqlite in <2s) and mine... well... let's just say I doubt anyone is getting my speeds anytime soon.",0.0,Go
145d24u,jnnw186,"One of Go's selling point was that it was fast to compile, so I'd expect them to have benchmarks, but maybe they are internal to Google.",0.1,Go
145d24u,jnnwdfl,"About Go being advertised as fast to compile, then yes I fully agree with you, they should have provided benchmarks to back their claims.",0.1,Go
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,C
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,D
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Lua
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Python
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Ruby
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Perl
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Rust
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Pascal
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Go
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Lisp
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Julia
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Dart
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Java
145c4ih,jnmrm95,"Alternatively, take a look at the Array languages like APL, J, or BQN.",0.0,APL
145c4ih,jnwumrk,"Code generation is the key, just use something like Rust or Go, create a rule engine with a tiny local DB and apply rules around annotations etc on compilation time.",0.0,Rust
145c4ih,jnwumrk,"Code generation is the key, just use something like Rust or Go, create a rule engine with a tiny local DB and apply rules around annotations etc on compilation time.",0.0,Go
145c4ih,jnkaf6n,I believe Eiffel works that way,0.0,Eiffel
145c4ih,jnmb8n9,Clojure can [add watchers](https://clojuredocs.org/clojure.core/add-watch) to its mutable containers.,0.0,Clojure
145c4ih,jnmb8n9,Tcl can [add traces](https://www.tcl.tk/man/tcl8.4/TclCmd/trace.html#M14) to variables in a similar way.,0.0,Tcl
145c4ih,jnmwfws,This is like a require statement in Eiffel.,0.0,Eiffel
145c4ih,jnmxvcq,"Only because I haven’t seen anyone mention it, the https://dynamicland.org project uses a Lua dialect extended with `When` statements that function similar to what you’re describing.",0.0,Lua
145c4ih,jnn3f9j,Prolog programs are essentially a series of rules.,0.0,Prolog
145c4ih,jnnsegx,"C# has attributes, which I only know the basics of - this gives a kind of metadata to a specific function or variable.",0.19999999999999998,C
145c4ih,jnncfzt,"For example if would be neat if `fun(A, B): C` could be made into a time-dependent value, by just adding an operator, like `fun!",0.375,C
145c4ih,jnncfzt,"(Signal<A>, Signal<B>): Signal<C>`.",0.0,C
145c4ih,jnncfzt,"I think Haskell does something with Monads and the ""do""-notation and Scala with ""for""-notation.",0.0,Haskell
145c4ih,jnncfzt,"I think Haskell does something with Monads and the ""do""-notation and Scala with ""for""-notation.",0.0,Scala
145c4ih,jnldgmb,Something like Common Lisp would make this approachable.,-0.3,Lisp
145c4ih,jnkfi3g,JavaScript example:  ``` function* rules() {   let a = 0;   if (a == 0) {     yield a++;   } }  function main() {   let rules = rules();   let a = rules.next().value;   console.log(rules.next().value); } ```,0.16666666666666666,JavaScript
145c4ih,jnojxnn,Look at Ada’s aspects which is nicked from Eiffel.,0.0,Ada
145c4ih,jnojxnn,Look at Ada’s aspects which is nicked from Eiffel.,0.0,Eiffel
145bk89,jnk448q,[Elm](https://elm-lang.org/) does this.,0.0,Elm
145b3eg,jnqby21,Perl has something like a pronoun in the form of `$_` and `@_` but they have precisely defined semantics.,0.4,Perl
145b3eg,jnkh6av,"I haven't come across this concept in particular before, but reading that page it is clearly about universal and existential quantifiers, and [Haskell totally lets you use them if you want](https://serokell.io/blog/universal-and-existential-quantification) - in fact, things are implicitly universally quantified by default.",0.05333333333333333,Haskell
145b3eg,jnkh6av,"We can translate of the donkey sentence to type-level Haskell, which reads something like:  ```haskell class Farmer f where class Donkey d where class Owns f d where class (Farmer f, Donkey d, Owns f d) => Beats f d where     beat :: f -> d -> () ```  The type of `beat` is actually `forall f d .",0.0,Haskell
145b3eg,jno5s4u,"(Farmer f, Donkey d, Owns f d) => BEATS(F,D)` *is the correctly encoded donkey sentence that fixes the out of scope variable*.",0.0,D
1457g52,jnk4ryj,I'm not very familiar with C# but your memory manipulation looks *very* expensive.,-0.39711538461538465,C
1457g52,jnk4ryj,I think shifts are safe in C#?,0.5,C
1457g52,jnk7a9r,>   >I'm not very familiar with C# but your memory manipulation looks very expensive.,-0.39711538461538465,C
1452482,,"From what I've heard, other languages, such as Zig and C++, include an additional interpreter for it's *comptime* evaluation.",-0.0625,C++
1452482,,"Please enlighten me :D  My language is meant to be transpiled down to C, as I didn't want to mess with LLVM docs.",0.22314814814814818,D
1452482,,"Please enlighten me :D  My language is meant to be transpiled down to C, as I didn't want to mess with LLVM docs.",0.22314814814814818,C
1452482,,"I was thinking the compiler could take that AST nodes that are necessary for comp-time evaluation and transpile only them to C.      int32_t add (int32_t a, int 32_t b) {         return a + b;     }     int main (void) {         return add(1, 2); // 3     }  Then this C code, as explained in the begging, would get compiled down to an executable and executed.",0.002777777777777768,C
1452482,,"fn sub (i32 a, i32 b) -> i32 {         return a - b;     }     fn main () -> void {         i32 x = 3;         i32 y = sub(10, 3);     }  This would then get transpiled down to C and from C down to the final executable.",-0.03611111111111113,C
1452482,jnipmud,"I do this by making every AST an expression and then make sure to rewrite the AST to statements where necessary for C code generation  The hard part is doing name resolution at right stage, I also allow compile time closures to close over bindings of runtime values and pass them around as first class objects so it gets a bit tricky.",0.1488095238095238,C
1452482,jnmd1h4,This is not dissimilar to how macros tend to work in Common Lisp implementations - the function for a macro is compiled just as any other function is.,-0.2125,Lisp
1452482,jnj0d59,"The only downside I can see in using libgccjit for this, is that currently they only support compiling to binary (file) or memory, but not both at once (you'd need to compile twice if your compile-time function is to be executed at both compile-time and run-time, as C++'s `constexpr` supports).",0.0,C++
1452482,jnke4ut,I think Rust and C++ are a bit more complicated because they have limitations on what can be done at compile time and at least for Rust there are a bunch of extra checks to confirm you aren’t doing anything that they consider undefined,-0.075,Rust
1452482,jnke4ut,I think Rust and C++ are a bit more complicated because they have limitations on what can be done at compile time and at least for Rust there are a bunch of extra checks to confirm you aren’t doing anything that they consider undefined,-0.075,C++
1452482,jnilz2v,This is pretty much what Scala 3 does I think.,0.225,Scala
1452482,jnnbp5h,Although instead of compiling an .exe i will try out C JIT compilers such as libgccjit or tccjit.,0.0,C
1452482,jnnehff,"Compiling to an executable will definitely hurt, but what about JITing C?",0.0,C
1452482,jniviyw,"And the typed ASTs are then passed to one of a few library functions that output any of C, Javascript, GLSL or webassembly  >inline AST to require a specific keyword  This is something like a lisp 'quote' function which I thought about but I think they would be unhygienic macros right?",0.028571428571428564,C
144owz5,jno0cif,You can use intersection types in [Scala 3](https://docs.scala-lang.org/scala3/book/types-intersection.html)!,0.0,Scala
144owz5,jno0cif,"I think TypeScript also has them, but I can't find the docs page.",0.0,TypeScript
144ekk3,jniisgd,"What is particularly interesting to me is that if we look at the usual syntax of GADTs (Generalized Algebraic Data Types), as found in OCaml or Haskell for example, it resembles TF a lot.",0.125,Haskell
143bzzd,,In this one we add call expressions to Wanda and make it so the reader produces linked lists like any worthy Lisp.,0.3333333333333333,Lisp
143fgv6,,"From what I understand, looking at Lisp/Scheme compilers, macros are expanded before compilation, and having them saved in variables would prevent the compiler to know what to expand to (unless the variable can be resolved at compile time, which might be why Scheme has let-syntax instead of just let for macros).",0.0,Scheme
143fgv6,,"Haskell is able to compile them, but I was reading Simon Peyton Jones books and it looks like that requires a very different compilation scheme.",0.25,Haskell
143a6qa,jnb2xoh,"Using the file system + a list of search directories (like `-I` for C and C++ includes, and `-L` for `.so`/`.dll` files) actually gives all the freedom necessary for implementing a package manager.",0.0,C
143a6qa,jnb2xoh,"Using the file system + a list of search directories (like `-I` for C and C++ includes, and `-L` for `.so`/`.dll` files) actually gives all the freedom necessary for implementing a package manager.",0.0,C++
143a6qa,jn9q6jf,"And even if I had rustc errors, I set its output format to JSON to catch them and then use source maps to track down the Letlang code that produced the faulty Rust code.",-0.15555555555555559,Rust
143a6qa,jn9r7pa,">And even if I had rustc errors, I set its output format to JSON to catch them and then use source maps to track down the Letlang code that produced the faulty Rust code.",-0.15555555555555559,Rust
143a6qa,jn9vvkk,"This happens to be true for `A = int`, but not for anything else, so if you interpret type parameters as parametric (which you should, because that is how they work in most statically typed languages except C++), it is still a contract violation.",0.425,C++
1437nai,,It gave some examples like Rust not including a Random package (since one for cryptography would be unsuitable for day to day [i.e.,-0.5,Rust
142qw6x,jn5xafa,Java did not choose type erasure because of backwards compatibility.,0.0,Java
142qw6x,jn5xafa,C# does not erase generic types.,0.0,C
142qw6x,jn5yddy,"> All realizations using reference types can share the same compiled code  That can be true for a lot of generics such as collections, though if we have a type bound on a generic parameter `T extends ISpaceship` and want to call `.launch()` on an instance of `T`, then a language like Vale or Rust would need different instantiations to call the correct function...",0.06999999999999999,Rust
142qw6x,jn5yddy,"I think Java doesn't need to, not sure about C#.",-0.25,Java
142qw6x,jn5yddy,"I think Java doesn't need to, not sure about C#.",-0.25,C
142qw6x,jn5w9cy,why Python does not need generics?,0.0,Python
142qw6x,jn6iij4,">  though if we have a type bound on a generic parameter `T extends ISpaceship` and want to call `.launch()` on an instance of `T`, then a language like Vale or Rust would need different instantiations to call the correct function...",0.0,Rust
142qw6x,jn6iij4,"I think Java doesn't need to, not sure about C#.",-0.25,Java
142qw6x,jn6iij4,"I think Java doesn't need to, not sure about C#.",-0.25,C
142qw6x,jn6iij4,Same with C#.,0.0,C
142qw6x,jn6iij4,The reason Rust (and I assume Vale) need monomorphization to call trait methods is because those trait methods are dispatched *statically*.,0.0,Rust
142qw6x,jn6iij4,Java and C# can compile a generic method once for all type arguments because any method called on an instance of the type argument is a virtual call going through the instance's v-table.,0.0,Java
142qw6x,jn6iij4,Java and C# can compile a generic method once for all type arguments because any method called on an instance of the type argument is a virtual call going through the instance's v-table.,0.0,C
142qw6x,jn6iij4,"In Rust, since trait calls are statically dispatched, the calls at runtime are faster.",0.0,Rust
142qw6x,jn66r9v,Java references are similar to dyn Trait in Rust.,0.0,Java
142qw6x,jn66r9v,Java references are similar to dyn Trait in Rust.,0.0,Rust
142pydn,,Relish  is a homegrown LISP I have written from scratch using only safe Rust  (with the exception of libc calls in POSIX job control libraries).,0.25,Rust
142pydn,,You (could possibly) wish your shell config looked this cool: [(My shell config)](https://pastebin.com/tRZPx9ff)  Relish called in CI: [(Tests for optional features written in Relish)](https://gitlab.com/whom/relish/-/blob/main/snippets/userlib-tests.rls)  Homoiconicity put to work for shell use: [(Shell command binding generator)](https://gitlab.com/whom/relish/-/blob/main/snippets/genbind.rls)  (Docs are linked to in the Readme),-0.38,Shell
142pydn,jn8e1al,Closer to Scheme or Cl ?,0.0,Scheme
142pydn,jnd8nuu,Emacs as any other Lisp has its own symbol tables too :).,0.325,Lisp
142pydn,jnd8nuu,"I am not sure what you mean that Relish keep it's symbol tables  synchronized to the environment, but as any process, Emacs as well reflects changes in its process environment, to the level that programmers who write lisp applications in Emacs Lisp care about the environment.",-0.28125,Lisp
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,Bash
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,Lisp
142pydn,jnd8nuu,The comment you have quoted is talking about combining shell commands with Lisp forms.,0.0,Lisp
142pydn,jnd8nuu,"But you can use Elisp in Eshell and as long as you are keeping yourself in the Lisp land you can combine lisp forms as normally in Lisp, which makes Eshell equal to Relish in that regard (just with a more powerful Lisp).",0.18,Lisp
142pydn,jn9xgj0,(Also not too familiar with Rust).,0.375,Rust
142pydn,jnef157,"> you can use Elisp in Eshell and as long as you are keeping yourself in the Lisp land you can combine lisp forms as normally in Lisp, which makes Eshell equal to Relish in that regard (just with a more powerful Lisp).",0.18,Lisp
142pydn,jng9v9e,"> (l ping -c COUNT (get-api-domain)) Here COUNT is either used verbatim or expanded to whatever value that variable references  Your example is trivial in Emacs Lisp and Eshell:      (defmacro l (&rest args)       (let ((cmd))         (dolist (arg (nreverse `(,@args)))           (push arg cmd))         (shell-command-to-string (format ""%S"" cmd))))  The mockup:      (defun get-api-domain ()       'api.trashcan.services)     (defvar COUNT 4)      Eshell just did it:      c:/emacs/help-remote $ (l ping -c COUNT (get-api-domain))  Perhaps better with something that does not require admin priviledge?",-0.3333333333333333,Lisp
142pydn,jng9v9e,"> (l ping www.google.com)  The answer:      c:/emacs/help-remote $ (l ping www.google.com)             Pinging www.google.com [142.250.74.36] with 32 bytes of data:         Reply from 142.250.74.36: bytes=32 time=143ms TTL=53         Reply from 142.250.74.36: bytes=32 time=20ms TTL=53         Reply from 142.250.74.36: bytes=32 time=24ms TTL=53         Reply from 142.250.74.36: bytes=32 time=14ms TTL=53          Ping statistics for 142.250.74.36:         Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),     Approximate round trip times in milli-seconds:         Minimum = 14ms, Maximum = 143ms, Average = 50ms  But that is totally missing the point, since Eshell does not have to do anything like creating that macro but can just execute shell syntax directly, and even combine it with Emacs Lisp functions:          Welcome to the Emacs shell          ~ $ ping -c COUNT (get-api-domain)     Access denied.",-0.00833333333333336,Lisp
142pydn,jng9v9e,"Or what about this:      ~ $ (message ""Hello"") > greeting.txt     ~ $ ls | grep greeting     (standard input):greeting.txt  There are limitations of course when it comes to shell syntax, but on Lisp side, Eshell can do anything Relish can and much more.",0.25,Lisp
142pydn,jng9v9e,"It is a bit similar idea to yours, but Emacs Lisp itself provides for what Relish does, in quite trivial manner, while Eshell adds shell syntax and let you mix the two seemlesly.",0.0,Lisp
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,C
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,D
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,Julia
142ixw5,jn4v85p,As is `Lua`.,0.0,Lua
142ixw5,jnbw66m,"Yeah, as much as I love D, characterizing it as faster than C seems wrong.",0.0,D
142ixw5,jnbw66m,"Yeah, as much as I love D, characterizing it as faster than C seems wrong.",0.0,C
142ixw5,jnbw66m,"D's performance is C-like for most things, but it is generally a little slower, and occasionally *much* slower.",0.1708333333333333,D
142ixw5,jnbw66m,According to https://programming-language-benchmarks.vercel.app/d-vs-c D only outperformed C on one microbenchmark (nsieve).,0.0,D
142ixw5,jnbw66m,According to https://programming-language-benchmarks.vercel.app/d-vs-c D only outperformed C on one microbenchmark (nsieve).,0.0,C
142ixw5,jnbw66m,"From my limited experience with Julia, it's the same kind of mixed bag.",0.13214285714285715,Julia
142ixw5,jnbw66m,"Julia outperforms C on matrix operations, but slightly underperforms C on pretty much everything else.",0.09444444444444444,Julia
142ixw5,jnbw66m,"Julia outperforms C on matrix operations, but slightly underperforms C on pretty much everything else.",0.09444444444444444,C
142ixw5,jnbw66m,"D has three compilers -- the reference implementation (DMD), the GCC implementation (GDC) and the LLVM implementation (LDC).",0.0,D
142ixw5,jnbw66m,"When gauging the performance of Lua, does one use luac as the standard, or luajit?",0.0,Lua
142iq4o,jne0dm6,"To paraphrase a famous quote, those who do not learn from Erlang are doomed to reimplement it.",0.5,Erlang
142cxoh,,"So I just write a simple script to test how fast you can sum all numbers up to a certain amount...      //the test case (toy)     fn test_sum(key: int, val: int) {     	fn sum(n: int) {     		if (n < 2) {     			return n;     		}          		return n + sum(n - 1);     	}          	var result: int const = sum(val);     	print string key + "": "" + string result;     }          for (var i: int = 0; i <= 10; i++) {     	test_sum(i, i * 1000);     }  And then I wrote the [exact same code in JavaScript and C](https://github.com/Ratstail91/Toy/tree/main/scripts/test_sum), and compared them.",0.11071428571428571,JavaScript
142cxoh,,"So I just write a simple script to test how fast you can sum all numbers up to a certain amount...      //the test case (toy)     fn test_sum(key: int, val: int) {     	fn sum(n: int) {     		if (n < 2) {     			return n;     		}          		return n + sum(n - 1);     	}          	var result: int const = sum(val);     	print string key + "": "" + string result;     }          for (var i: int = 0; i <= 10; i++) {     	test_sum(i, i * 1000);     }  And then I wrote the [exact same code in JavaScript and C](https://github.com/Ratstail91/Toy/tree/main/scripts/test_sum), and compared them.",0.11071428571428571,C
142cxoh,,"The result was quite good, IMO -  C : JavaScript : Toy = 1.00 : 16.25 : 109.50  For a language implementation built from the ground up in six months, I'm quite surprised that it's less than than one order slower than JS, and only roughly 2 orders slower than C.  I know this is a pretty simple way of testing speed, but I figured I'd put it up to see what others thought.",0.11190476190476191,C
142cxoh,,"The result was quite good, IMO -  C : JavaScript : Toy = 1.00 : 16.25 : 109.50  For a language implementation built from the ground up in six months, I'm quite surprised that it's less than than one order slower than JS, and only roughly 2 orders slower than C.  I know this is a pretty simple way of testing speed, but I figured I'd put it up to see what others thought.",0.11190476190476191,JavaScript
142cxoh,,&#x200B;  Edit: NEVERMIND I should learn to run tests multiple friggin' times  C	0.002s	1  JS	0.064s	32  Py3	0.070s	35  Toy	0.430s	215,0.0,C
142cxoh,jn42p4d,"With C, I got a timing of pretty much zero seconds, even unoptimised; at any rate hard to disinguish from the time taken to run an empty program.",0.01458333333333333,C
142cxoh,jn42p4d,"The benchmark also isn't the same: some use nested functions, the C at least doesn't do that.",-0.15,C
142cxoh,jn42p4d,"A better benchmark should run a bit longer (on Windows at least, measuring very fast runtimes is hard), and the C should not be affected by optimisation too much.",0.07366666666666667,C
142cxoh,jn42p4d,Measuring against upoptimised C might be fairer: you are still comparing interpreted code against native.,0.0,C
142cxoh,jn717ig,"Now I could put together a `Fibonacci` test like this:      fn fib(n:int) {         if (n<3) {             return 1;         } else {             return fib(n-1)+fib(n-2);         }     }          for (var i: int = 1; i <= 36; i++) {         var res:int =fib(i);         print string i + "" "" + string res;     }  I tested this with `toyrepl` and compared with other products I had lying around:       PicoC      81,000    seconds (extrapolated)      toyrepl       340      A68G           16    (Algol68 interpreter)      CPython 3.11    7      Q-fn            5.4      Lua 5.4         3.7      Q-asm           1.35 (Q is my dynamic language)      PyPy            0.7      LuaJIT          0.33      C               0.2  unoptimised      C               0.11 optimised  This shows a wider disparity than your test.",-0.0625,Lua
142cxoh,jn717ig,"Now I could put together a `Fibonacci` test like this:      fn fib(n:int) {         if (n<3) {             return 1;         } else {             return fib(n-1)+fib(n-2);         }     }          for (var i: int = 1; i <= 36; i++) {         var res:int =fib(i);         print string i + "" "" + string res;     }  I tested this with `toyrepl` and compared with other products I had lying around:       PicoC      81,000    seconds (extrapolated)      toyrepl       340      A68G           16    (Algol68 interpreter)      CPython 3.11    7      Q-fn            5.4      Lua 5.4         3.7      Q-asm           1.35 (Q is my dynamic language)      PyPy            0.7      LuaJIT          0.33      C               0.2  unoptimised      C               0.11 optimised  This shows a wider disparity than your test.",-0.0625,C
142cxoh,jn717ig,"Notes:  * Fibonacci can be a challenging benchmark, especially if your function calls are slow * I don't know if `toyrepl` is optimised or is the fastest way of running this program * PyPy and LuaJIT use JIT, so I wouldn't pay much attention to those timings; JIT always gives astonishing results on microbenchmarks * Pico C is a C interpreter, and not a fast one.",0.13333333333333333,C
142cxoh,jn4zsze,The C entry was just curiosity.,0.0,C
142cxoh,jn5h1j7,"You may be right in this case, but I've seen people's benchmarks ""my language is almost as fast as C!""",0.26785714285714285,C
141z4k2,jn3u2hs,FYI: Did you know LOGO is actually Lisp without all those parentheses?,0.0,Lisp
141z4k2,jn6skpf,Pascal was a teaching language.,0.0,Pascal
141z4k2,jn6skpf,Python started life as a teaching language.,0.0,Python
141sjvi,jn1lw2d,"----  Several companies in fact do profit(now or in the past) with programming languages: MS, Borland, Apple, Amazon, Ericcson, IBM, Informix, FoxPro, SAP (and a lot of ERP/app Bussines makers), kdb+, APL, RDBMS & NoSQL makers, Some game makers, etc  It would be best if you *opened your mind* about how *exactly* this fit in the idea (I think you will not see at first how Apple ""profit"" from programming languages!",0.1875,APL
141sjvi,jn200fy,"Not for Python, not for Zig, not for Apple, *NOBODY* makes money on that *particular* aspect of the game.",-0.11666666666666668,Python
141sjvi,jn200fy,There's no doubt that Apple released Swift so that developers would release iPhone-only applications.,0.0,Swift
141sjvi,jn200fy,"Python was a teaching language, but Guido can write a number on paper and someone will pay it.",0.0,Python
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Go
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Dart
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Swift
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Rust
141sjvi,jp6z1lr,Look at Objective-C for instance.,0.0,Objective-C
141sjvi,jp6z1lr,"It achieved that by taking the language people had used so far, C, and adding a few small constructs on top that made it easy to do polymorphism, dynamism and message sending _only when you needed it_.",0.09722222222222222,C
141sjvi,jp6z1lr,So Objective-C runs any of your old C code.,0.1,Objective-C
141sjvi,jp6z1lr,So Objective-C runs any of your old C code.,0.1,C
141sjvi,jp6z1lr,"(compatibility) Also, if you need to optimize for speed, you are able to replace object-oriented code with plain C code for those important tight loops.",0.12678571428571428,C
141sjvi,jp6z1lr,"I wouldn't try being the next C# or C++ at this point, though.",0.0,C
141sjvi,jp6z1lr,"I wouldn't try being the next C# or C++ at this point, though.",0.0,C++
141qm6g,jn1vh0p,"I liked how the article talked about tail calls at the *end*  “I got argued into not having them because the project in general got argued into the position of ""compete to win with C++ on performance"" and so I wound up writing a sad post rejecting them which is one of the saddest things ever written on the subject”",0.1566666666666667,C++
141qm6g,jna20d9,I definitely think there's space in the ecosystem for a natively compiled language mid-way between Go and Rust:   - More heavily typed than Go.,0.09999999999999999,Go
141qm6g,jna20d9,I definitely think there's space in the ecosystem for a natively compiled language mid-way between Go and Rust:   - More heavily typed than Go.,0.09999999999999999,Rust
141qm6g,jna20d9,- Not quite as low-level as Rust: green threads + no-lifetimes.,-0.2,Rust
141qm6g,jna43dp,"Well, you weren't wrong, and you weren't right either :)  As Graydon mentions, his Rust wouldn't have been _better_, it would have been _different_.",0.15714285714285714,Rust
141qm6g,jna43dp,"I really like today's Rust, but part of it is because I _love_ performance/pedal-to-the-floor code, and today's Rust offers me that in a nice package.",0.35,Rust
141qm6g,jna43dp,"Don't like the syntax, can't program like it were Java or Python, etc...",0.0,Java
141qm6g,jna43dp,"Don't like the syntax, can't program like it were Java or Python, etc...",0.0,Python
141qm6g,jna43dp,"Rust clashes with that because the ownership/borrowing discipline is just plain new to many, and it takes time getting used to it.",0.14069264069264067,Rust
141qm6g,jna43dp,"Most people who stuck to hit -- who reach the ""hindsight"" part -- agree that Rust has changed the way they approach programming even in other languages, and that their programs are better for it.",0.2916666666666667,Rust
141qm6g,jn2ok7n,"Rust has TCO, not guaranteed tail callss which the article talks about  See https://github.com/phi-go/rfcs/blob/guaranteed-tco/text/0000-explicit-tail-calls.md",0.0,Rust
141qm6g,jna4yq0,"Rust is successful because of its ecosystem and tooling, not because of lifetime annotations and async/await.",0.75,Rust
141qm6g,jymlfl5,"But I think, in a lot of ways, Haskell is this language.",0.0,Haskell
141qm6g,jymlfl5,"I know, I know, it’s Haskell!",0.0,Haskell
141qm6g,jymlfl5,"But I happen to believe that much of what makes it truly so impressive is often unsung:  * Many of Rust’s features, such as traits and enums, come more or less directly from Haskell.",0.30476190476190484,Rust
141qm6g,jymlfl5,"But I happen to believe that much of what makes it truly so impressive is often unsung:  * Many of Rust’s features, such as traits and enums, come more or less directly from Haskell.",0.30476190476190484,Haskell
141qm6g,jymlfl5,"It includes Go-style channels and queues for cross-thread communication (and, incidentally, it did before Go so much as existed), plus an efficient implementation of software transactional memory largely based around optimistic, lock-free transactions.",0.20714285714285713,Go
141qm6g,jymlfl5,"* Despite its reputation, the Haskell type system is legitimately simpler than Rust’s.",0.0,Haskell
141qm6g,jymlfl5,"* Despite its reputation, the Haskell type system is legitimately simpler than Rust’s.",0.0,Rust
141qm6g,jymlfl5,The trait metaprogramming routinely used in Rust would make most Haskellers’ heads spin.,0.5,Rust
141qm6g,jymlfl5,"* `cabal`, Haskell’s equivalent to `cargo`, is not nearly as polished or friendly, and it is sadly somewhat old and crufty.",-0.018749999999999996,Haskell
141qm6g,jymlfl5,* The library ecosystem is pretty solid for most of the usual things people do with languages like Go.,0.125,Go
141qm6g,jymlfl5,Writing Haskell is not doing mathematics.,0.0,Haskell
141qm6g,jymlfl5,"Haskell is a programming language, and writing Haskell is programming.",0.0,Haskell
141qm6g,jymlfl5,"And if you’re coming from Rust, you’ll find it remarkably easy to pick up.",0.43333333333333335,Rust
141qm6g,jp6s22n,Maybe Crystal?,0.0,Crystal
141qm6g,jnmgti2,"> As Graydon mentions, his Rust wouldn't have been better, it would have been different.",0.25,Rust
141qm6g,jnmgti2,"> I really like today's Rust, but part of it is because I love performance/pedal-to-the-floor code, and today's Rust offers me that in a nice package.",0.35,Rust
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,C
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,C++
141qm6g,jneuhmo,Rust is tuned to be good at mutable aliasing.,0.7,Rust
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,C
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,C++
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Go
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Java
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,JavaScript
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Python
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Ruby
141qm6g,jneuhmo,"Rust is somewhat unique in that it deals with the mutable aliasing problem head-on, and actually ""solves"" it... at an ergonomic cost.",0.1875,Rust
141qm6g,jp8wsog,"Not for me ;)  I favor type-classes over inheritance and Result over exceptions, so... no, not Crystal.",0.25,Crystal
141qm6g,jnn6m4u,"I remember playing with Forth and Haskell, and boy was my whole world turned upside down.",0.022222222222222213,Forth
141qm6g,jnn6m4u,"I remember playing with Forth and Haskell, and boy was my whole world turned upside down.",0.022222222222222213,Haskell
141qm6g,jnn6m4u,"I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,Rust
141qm6g,jnn6m4u,"I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,C++
141qm6g,jnn6m4u,"I still remember the joy when Mutable XOR Aliasing kicked in, and how it helped me better structure (and debug) my C++ code afterwards.",0.65,C++
141qm6g,jnn6m4u,"Before Rust, I would sometimes have a ""gut feeling"" that a piece of code may be trouble, and I would try to think of various execution paths to see if any would be problematic... and when I couldn't find any, I'd leave with a dread feeling in my guts, not quite convinced it was alright, and quite afraid it would still blow-up in my face one day.",-0.26666666666666666,Rust
141qm6g,jnn6m4u,"All of this doesn't mean you should absolutely learn Rust, that you're not a good programmer if you don't, or anything like that.",-0.15416666666666665,Rust
141qm6g,jnn6m4u,"It just means that learning Rust may require more effort than learning another language more similar to what you're used to, and that you won't get any benefit if you don't stick long enough for the concepts to click.",0.19,Rust
141qm6g,jn38ofk,"I think the point is that in C++ you can't just write a function that would blow the stack without TCO, as the compiler is free to just not do it (and probably won't in a debug build, even if it would in release).",0.4,C++
141qm6g,jn38ofk,"So it can only be treated as a possible optimization that might make some programs faster, but not as free rein to write C++ as if it was a functional language.",0.13333333333333333,C++
141qm6g,jno6e5v,"Go ahead, tell me what I did wrong.",-0.5,Go
141qm6g,jno6e5v,Go ahead and tell me why my code is wrong.,-0.5,Go
141qm6g,jno6e5v,"> I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,Rust
141qm6g,jno6e5v,"> I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,C++
141qm6g,jno6e5v,"Before thinking I might have no idea what I'm talking about feel free to try out my compiler and reproduce my build speed https://bolinlang.com/ There's likely no way a person can get that kind of performance without knowing what their doing  > All of this doesn't mean  So many words and it doesn't seem like you ever thought maybe a person has no issues with manual memory management, C++ code and has valid reasons not to like rust  In the article graydon says ""Performance: A lot of people in the Rust community think ""zero cost abstraction"" is a core promise of the language.""",0.2375,C++
141qm6g,jno6e5v,"Before thinking I might have no idea what I'm talking about feel free to try out my compiler and reproduce my build speed https://bolinlang.com/ There's likely no way a person can get that kind of performance without knowing what their doing  > All of this doesn't mean  So many words and it doesn't seem like you ever thought maybe a person has no issues with manual memory management, C++ code and has valid reasons not to like rust  In the article graydon says ""Performance: A lot of people in the Rust community think ""zero cost abstraction"" is a core promise of the language.""",0.2375,Rust
141qm6g,jno6e5v,But I think the C and C++ standard library has 'ok' performance in some areas and slow in others.,0.06666666666666665,C
141qm6g,jno6e5v,But I think the C and C++ standard library has 'ok' performance in some areas and slow in others.,0.06666666666666665,C++
141qm6g,jno6e5v,Here's my language beating C in one area and C++ was painfully slow here https://bolinlang.com/more_optimal_standard  Since you brought up understanding how to write code multiple times I'll bring up for the third time that you should tell me what's wrong with the code in my example.,-0.2,C
141qm6g,jno6e5v,Here's my language beating C in one area and C++ was painfully slow here https://bolinlang.com/more_optimal_standard  Since you brought up understanding how to write code multiple times I'll bring up for the third time that you should tell me what's wrong with the code in my example.,-0.2,C++
141qm6g,jnoeq4x,"> Go ahead, tell me what I did wrong.",-0.5,Go
141qm6g,jnz8qel,I know that languages like Python and Go don't do it because they are determined to have intact stack traces for debugging.,0.0,Python
141qm6g,jnz8qel,I know that languages like Python and Go don't do it because they are determined to have intact stack traces for debugging.,0.0,Go
141qm6g,jnz8qel,But for C++ that sort of thing wouldn't be a priority...,0.0,C++
141qm6g,jnohhc7,Go ahead.,0.0,Go
141qm6g,jyldotb,"So if you have a loop header A invoking an iterator B that yields values to a loop body C, you get A calls B with the pointer-to-C, and B calls C for each step, just as if you'd passed a lambda / closure as C.  But there are details that differ:    * C can't escape, so you get the lifetime nesting of everything that you expect.",0.0,C
141qm6g,jyldotb,"* The variable-environment of C is extends the frame of A, so a frame-pointer from A is passed to B, and then back to C to run in, so variables in the loop body live across multiple calls back from B to C. The calls from B to C extend the _stack_ pointer of B with register spills and reloads (extending B's frame) but use the _frame_ pointer from A-and-C to find the environment for C.   * There's a loop-control protocol (continue, break, early-return) encoded in a token passed back and forth.",0.02727272727272727,C
141qm6g,jyldotb,"I think a similar translation scheme exists in the C++ coroutine stuff that's in LLVM now, but I haven't looked at the exact details.",0.125,C++
141mbnr,jn0wyot,"""Array languages"" like APL and its descendants can also be understood that way.",0.0,APL
141mbnr,jn0zk0b,"That said, I feel like you would run into practical problems as far as implementation goes - recursion in a language like Haskell mainly ""works"" (is efficient and reasonable for large inputs) because Haskell is able to optimize tail recursion so as to avoid stack overflows or ballooning memory requirements.",0.2361904761904762,Haskell
141mbnr,jn0zk0b,I would recommend looking at a language like Python and trying to write a meaningful program only using those higher order functions (or perhaps a few more you implement yourself) and seeing how far you can get.,0.19166666666666668,Python
141mbnr,jn1fox9,APL?,0.0,APL
141mbnr,jn1fox9,-   wikipedia https://en.wikipedia.org/wiki/APL_(programming_language)   try APL https://tryapl.org/,0.0,APL
141mbnr,jnds98h,"In Python you can write:      def makeRecursive(f):         return lambda args: f(f, args)          @makeRecursive     def factorial(alsoFactorial, n):         return 1 if n == 1 else n * alsoFactorial(alsoFactorial, n-1)      assert factorial(6) == 720  There is also a paper on why fold is awesome, but I haven't read it: http://www.cs.nott.ac.uk/~pszgmh/fold.pdf",1.0,Python
141mbnr,jn1hila,"If you like JavaScript, I wrote about implementing the “Mockingbird” in JS—plus some related combinators—here:  http://raganwald.com/2018/08/30/to-grok-a-mockingbird.html",0.0,JavaScript
141m6a4,jn0w2oy,"I like the Python variant of this - when you have several strings after each other in the code, they get concatenated to a single string.",-0.06547619047619048,Python
141m6a4,jn0w2oy,"I'd also ask myself if generic interpolation makes sense - I've found the ""choose when to interpolate"" from Python (prefix to activate interpolation, allow strings to be either single or double quote delimited) to be slightly better than the ""Default to interpolation with need to escape, use single quotes to avoid it"" from Perl/Ruby/Shell.",0.07142857142857144,Python
141m6a4,jn1fa0u,What about just escaping the line break like you do in C?,0.0,C
141m6a4,jn1fa0u,And it will be familiar syntax to anyone who ever wrote a non-trivial macro in C xD,0.375,C
141m6a4,jn22xkd,"But if I learned anything at all from PHP, it's that you shouldn't mix large literal binary or text data into your programming language.",0.21428571428571427,PHP
141m6a4,jn22xkd,"Whatever fills in the template can be responsible for formatting stuff as HTML, or the correct number of digits after the region-specific decimal separator, etc.",0.2,HTML
141m6a4,jn1ys1m,"I like the way that Python does this: you can enclose multiple string literals (without commas in between them) in parentheses to create a single string literal, ex:      x = (         ""this is a long string""         ""literal broken across many lines""         ""goodbye""     )      y = ""this is a long stringliteral broken across many linesgoodbye""      assert x == y  In its absence, languages that support compile-time macros like Rust also have an easy way of doing this:      let x: &'static str = concat!",0.027033730158730156,Python
141m6a4,jn1ys1m,"I like the way that Python does this: you can enclose multiple string literals (without commas in between them) in parentheses to create a single string literal, ex:      x = (         ""this is a long string""         ""literal broken across many lines""         ""goodbye""     )      y = ""this is a long stringliteral broken across many linesgoodbye""      assert x == y  In its absence, languages that support compile-time macros like Rust also have an easy way of doing this:      let x: &'static str = concat!",0.027033730158730156,Rust
141m6a4,jn2wam8,"That said, regarding breaking up strings: you can make up a syntax for that, like adjacent C strings concatenating together or JS' backslash, or, even simpler, you can make a semantic guarantee that manual concatenation of literals is done at compile-time.",0.0,C
141m6a4,jn210pj,Just one voice of opposition: The implicit concatenation of Python has been a source of weird bugs for me.,-0.5,Python
141m6a4,jndv751,"80 chars come from punched cards used for Fortran programs etc, and at that time nobody thought of CRT terminals.",0.0,Fortran
141m6a4,jn2cegl,Something like Go's template library should solve this.,0.0,Go
141m6a4,jn4qb7q,"ahaha :D It was just an opinion of mine, no annoyance intended.",1.0,D
1414ryo,,"A big reason why newer programming languages aren’t used in industry is because of the sheer amount of existing libraries and resources that already exist for it; for example, ML models are currently mainly built in Python because of the existence of libraries like numpy and pytorch, even though Python may not be the most efficient language for the task.",0.16666666666666666,Python
1414ryo,jmykhzd,"Google's Carbon is compatible with C++, and allows C++ to be inlined with Carbon.",0.0,C++
1414ryo,jmykhzd,"D is (mostly) a superset of C.  C can frequently be compiled as D.  Also, D can call gluelessly into (most) C libraries.",0.3666666666666667,D
1414ryo,jmykhzd,"D is (mostly) a superset of C.  C can frequently be compiled as D.  Also, D can call gluelessly into (most) C libraries.",0.3666666666666667,C
1414ryo,jmykhzd,"Perl has a bunch of Inline:: modules, allowing other languages to be used within perl scripts.",-0.125,Perl
1414ryo,jmyo0xm,"There are attempts to have a ""common runtime"", like the Java and dotnet virtual machines, but these are very opinionated and are a poor fit for many languages.",0.08,Java
1414ryo,jmyrvkn,"Well, HTML5 allows you to mix CSS (called ""inline CSS""), HTML and JavaScript in a single file, although it is discouraged.",-0.07142857142857142,HTML
1414ryo,jmyrvkn,"Well, HTML5 allows you to mix CSS (called ""inline CSS""), HTML and JavaScript in a single file, although it is discouraged.",-0.07142857142857142,JavaScript
1414ryo,jmyukpd,"EDIT: Also, the old [Arity/Prolog32](http://petergabel.info/ArityProlog32/ArityProlog32/) Prolog compiler allowed users to combine C and Prolog code in the same file, albeit the C code was limited in nature.",0.009523809523809526,Prolog
1414ryo,jmyukpd,"EDIT: Also, the old [Arity/Prolog32](http://petergabel.info/ArityProlog32/ArityProlog32/) Prolog compiler allowed users to combine C and Prolog code in the same file, albeit the C code was limited in nature.",0.009523809523809526,C
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,Lisp
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,Scheme
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,Java
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,Python
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,JavaScript
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,Lua
1414ryo,jn04rjh,"I don't know about _research_, but we did have a component based development environment in the '97 timeframe, built in Java, that did enable different languages to be used to build software, specifiable down to the method level.",-0.07777777777777779,Java
1414ryo,jn04rjh,"In other words, the same class could have one method written in Java, another in BASIC, and another in JavaScript -- not that that was the goal.",-0.041666666666666664,Java
1414ryo,jn04rjh,"In other words, the same class could have one method written in Java, another in BASIC, and another in JavaScript -- not that that was the goal.",-0.041666666666666664,JavaScript
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,C
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,Fortran
1414ryo,jn010bw,"Some languages, like D, also allow you to literally [mark a class as COM](https://dlang.org/spec/interface.html#com-interfaces) and all instances will be callable from other binaries in different languages, without any kind of C FFI.",0.15833333333333333,D
1414ryo,jn010bw,"Some languages, like D, also allow you to literally [mark a class as COM](https://dlang.org/spec/interface.html#com-interfaces) and all instances will be callable from other binaries in different languages, without any kind of C FFI.",0.15833333333333333,C
1414ryo,jn0q9a4,by writing some extensions in C or by using [FixNative](https://www.fixscript.org/docs/native/) or other libraries).,-0.125,C
1414ryo,jn0q9a4,"While I'm not sure how much such language mixing is useful, there are enough of real world examples where it turned out just fine (PHP, SQL, HTML, regexps, etc.)",0.11111111111111112,PHP
1414ryo,jn0q9a4,"While I'm not sure how much such language mixing is useful, there are enough of real world examples where it turned out just fine (PHP, SQL, HTML, regexps, etc.)",0.11111111111111112,HTML
1414ryo,jn0v9mz,"> mainly built in Python because of the existence of libraries like numpy and pytorch, even though Python may not be the most efficient language for the task.",0.3333333333333333,Python
1414ryo,jn0v9mz,A PHP or ASP file is designed to contain HTML portions.,0.0,PHP
1414ryo,jn0v9mz,A PHP or ASP file is designed to contain HTML portions.,0.0,HTML
1414ryo,jn0v9mz,Those HTML portions are designed to contain JavaScript and CSS portions.,0.0,HTML
1414ryo,jn0v9mz,Those HTML portions are designed to contain JavaScript and CSS portions.,0.0,JavaScript
1414ryo,jn0v9mz,"For example, JavaScript has both ""null"" and ""undefined"", a distinction that may be lost when handing data back and forth with another language.",0.0,JavaScript
1414ryo,jmyumnb,Don't forget the [inline-java](https://github.com/tweag/inline-java) package for Haskell.,0.0,Haskell
1414ryo,jn6amot,Making the language X which can embed Y Z A B C D E is already quite a feat.,0.0,C
1414ryo,jn6amot,Making the language X which can embed Y Z A B C D E is already quite a feat.,0.0,D
1414ryo,jn6amot,"Like if you come up with Gunkface, a language capable of embedding Python, the Python Software Foundation is *not* going to adjust itself to make sure it can embed Gunkface.",0.35,Python
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,Haskell
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,C
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,C++
1414ryo,jn13hh1,"It might sound like I'm clutching at straws here, but there are certainly languages with `|]`, such as OCaml and F# which use them for array literals, but also, Haskell itself, which uses it for quasiquotes.",0.20476190476190478,Haskell
1414ryo,jmyx17g,"It has a very opinionated architecture, like Java, in that everything is an object.",0.2,Java
1414ryo,jmyx17g,There's no Haskell for .NET for example (it was attempted and abandoned).,0.0,Haskell
1414ryo,jmz7jj6,"I have never written any Kernel (I have heard of it though), and I have a few questions as someone who writes quite a bit of Scheme.",-0.2,Scheme
1414ryo,jmz7jj6,All of what you said about environments here seems to also be true in Scheme.,0.35,Scheme
1414ryo,jmz7jj6,Is the environment system very different from Scheme?,0.0,Scheme
1414ryo,jn0glw0,Not a problem in Scheme either.,0.0,Scheme
1414ryo,jn0glw0,"Now try to add `and` and `or` to it, and you see a problem: These are not first-class procedures in Scheme, they're second-class, because they do short-circuiting evaluation.",0.0,Scheme
1414ryo,jn0glw0,"(This exact problem is what led me to Kernel in the first place: I was writing an interpreter in Scheme and came across several awkward points like this, before I found Kernel and everything seemed much more intuitive to me).",0.08,Scheme
1414ryo,jn0glw0,I consider the Kernel approach to be the duel of the Scheme approach.,0.0,Scheme
1414ryo,jn0glw0,"In Scheme, everything is implicitly evaluated, unless explicitly quoted.",0.0,Scheme
1414ryo,jn0glw0,> All of what you said about environments here seems to also be true in Scheme.,0.35,Scheme
1414ryo,jn0glw0,Is the environment system very different from Scheme?,0.0,Scheme
1414ryo,jn0glw0,"There are limitations on how you can create your own environments in Scheme, but almost none in Kernel.",0.6,Scheme
1414ryo,jn0glw0,Scheme environments are middle-class.,0.0,Scheme
140s7im,,"``` fn main(arg: type): result_type @event {} ```  ## Function Calls & Statements They're a lot like what they are in Java, C, etc.",0.0,Java
140s7im,,"``` fn main(arg: type): result_type @event {} ```  ## Function Calls & Statements They're a lot like what they are in Java, C, etc.",0.0,C
140s7im,,"I don't think this can replace Java for Minecraft servers, but it should have it's own little niche where it can support both high-level and low-level control.",0.20625,Java
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,JavaScript
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,Rust
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,Python
140s7im,,"However, I don't want to go as far as a language like Haskell - it should be easily readable without problem to most C-style developers.",0.3444444444444444,Haskell
140s7im,,I also don't like Java's verbosity - it's nice while debugging but it's painful to write without IDE tooling (which I don't always have access to).,-0.04999999999999999,Java
140s7im,,"And currently, it's hard for new people to get into the Spigot realm - most people dive in without knowing any Java, so giving them some language that can fit inbetween the realms of Skript's englishness and Java's verbosity would be nice.",0.2689393939393939,Java
140s7im,,"## Example So, for example, here's a simple Hello World in Java.",0.0,Java
140s7im,,"This allows this language to (hopefully) be **extremely** fast (speed is one of my priorities for this) using a bytecode interpreter and it's in Rust instead of Java, which should be a nice little speedup.",0.2041666666666667,Rust
140s7im,,"This allows this language to (hopefully) be **extremely** fast (speed is one of my priorities for this) using a bytecode interpreter and it's in Rust instead of Java, which should be a nice little speedup.",0.2041666666666667,Java
140s7im,jn0anwd,"## Programming Style  Be consistent in your approach, and avoid mixing syntax patterns (i.e., variable definition: `Type identifier = expr` in C family languages).",0.25,C
140s7im,jn0anwd,"You could aim to make your language more like Python, JS.",0.5,Python
140s7im,jn0c2ce,"My personal preferences are Ballerina, Python, or Go.",0.0,Python
140s7im,jn0c2ce,"My personal preferences are Ballerina, Python, or Go.",0.0,Go
140s7im,jn16wv0,"I decided to change it around a bit and line it up a bit closer to JavaScript, which was my original goal, something like JS but with some nice changes and less verbose (although verbosity is opt-in-able if you like, stuff like types).",0.26944444444444443,JavaScript
140s7im,jn16wv0,I'm gonna implement it over Valence Framework in Rust ([https://github.com/valence-rs/valence](https://github.com/valence-rs/valence)) so it can go fast and have both low-level and high-level control.,0.2,Rust
140hy0r,jmw9656,"It teaches Scheme bit by bit, building up to implementing a metacircular evaluator for the same language.",0.0,Scheme
13zzzfc,,"If you were to build an opinionated formatter like `gofmt` or `prettier` for a non-braced language like Python, how would you format it?",0.0,Python
13zzzfc,jmttv9r,Python has `elif`.,0.0,Python
13zzzfc,jmtvkct,Actually this made me think of a \`branch\` structure like this:  ``` branch      <some_very_long_condition>     and <some_very_long_condition>     and <some_very_long_condition>     or <some_very_long_condition>     then          <statement>         <statement>         <statement>      <condition> and <condition>     then          <statement>         <statement>      (<condition> and <condition>)     and (         <some_very_long_condition>         or <some_very_long_condition>     )     then          <statement>         <statement> ```  Which is a glorified JavaScript's `switch (true)\,0.0,JavaScript
13zzzfc,jmvizir,Python also has a match/case system now: structural pattern matching.,0.0,Python
13ztlms,jmswmat,"I like the fact that it jokes about rust's name shadowing and also JavaScript's quirkiness, it's kinda funny, also this language would strangely be usable unlike other esoteric programming languages",0.025000000000000005,JavaScript
13ztlms,jmv709g,> ❌ Rust Foundation (owned by the DreamBerd Foundation - please consider renaming)  This might be the best thing I've read all day,1.0,Rust
13ztlms,jx0zexx,"toadpond, i once discovered your programming language DreamBerd (now renamed to C, probably to abide by the naming laws) on a youtube short, and then I red through the documentation laughing my ass off the hilarius and implausible ideas, and I am asking, will it be OK if I make a meme programming language inspired by DreamBerd?",0.16666666666666666,C
13ztlms,jmuiwe4,"In Java at least there's the excuse the specification ""simply"" required absolutely everything to be in a Class because it was the 90s and OO was cool.",0.04,Java
13ztlms,jmtcqjj,"You're drunk, but you're at the bar in good company with C++ `friend`s",0.09999999999999998,C++
13ztlms,jn2mis5,"I'm not sure exactly how useful this is, but I think you might be interested in Parsing Expression Grammars (PEGs) (such as [LPEG](http://www.inf.puc-rio.br/~roberto/docs/peg.pdf) in Lua) and perhaps [Abstract Syntax Definition Languages](https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers) (ASDLs) as potential source of inspiration for Language Language if you weren't already aware of them.",0.1142857142857143,Lua
13ztlms,jmvzqin,"This is valid Perl to print  foo   bar      $x = foo;     print $x, ""\n"";          sub foo() {         bar     }     $y = foo;     print $y",0.0,Perl
13ztlms,jp160mr,https://www.mcmillen.dev/sigbovik/  93% of Paint Splatters are Valid Perl Programs,0.0,Perl
13zjq3y,,Our approach was greatly influenced by Java because at that time Ballerina was initially a JVM-based interpreted language.,0.4,Java
13zh58i,jmrc873,Haskell lists are extremely efficient for that so there's no need for a special abstraction.,0.11607142857142858,Haskell
13zezki,jmzmdyh,:D Thanks for the link.,0.6,D
13zcm5i,,Needing some way to tie those `t`s to the element type of the array I thought about adding a language feature to annotate the type of a function either at the top-level (like Haskell) or inline (like OCaml).,0.0,Haskell
13zcm5i,,"So the `capacity_of` function takes the length of an array and rounds it up to the next power of two:        let capacity_of n =         if n=0 then 0 else Int.next_pow_two(n-1)  Now the `resize` function appends `dn` elements onto the end of `a` in-place using C's `realloc`:        let resize(a, dn) =         let n2 = length a + dn in         Array(n2, C.realloc(ptr a, capacity_of n2 * size_of t))  Even if I added a `realloc` instrinsic there's still no way to tie the type of the input array to the type of the output array in my language today.",0.0,C
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,C
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,C++
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,Java
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,JavaScript
13zcm5i,jmr3oqy,"An example is the Haskell [ListLike](https://hackage.haskell.org/package/ListLike-4.7.8/docs/Data-ListLike.html) class, which provides generic operations over types which behave like lists.",0.0,Haskell
13zcm5i,jmrc0ky,"(Like C#'s indexer properties for example)  Similarly, Lists in Haskell are given special treatment, but are not very special.",0.07326007326007326,C
13zcm5i,jmrc0ky,"(Like C#'s indexer properties for example)  Similarly, Lists in Haskell are given special treatment, but are not very special.",0.07326007326007326,Haskell
13zcm5i,jmvwb87,> Arrays are built in to C  I wouldn't say that C has proper array support.,0.0,C
13zcm5i,jmvwb87,This is actually one of the biggest complaints I hear from C programmers.,0.0,C
13zcm5i,jmsl8qe,"JavaScript's built in array type supports the stack protocol, so it's both.",0.0,JavaScript
13zcm5i,jmsl8qe,"Since arrays are growable in JavaScript (which you need for them to support being used as stacks), the internal representation of an array has an indirection.",0.0,JavaScript
13zcm5i,jmsl8qe,A reference to a JavaScript array is a reference to a reference to an allocated block of memory.,0.0,JavaScript
13zcm5i,jmsl8qe,"If you have fixed-sized arrays as your primitive (like C, Java, and C#), then you can avoid that double indirection in places where you know you don't need to be able to grow the array.",0.25,C
13zcm5i,jmsl8qe,"If you have fixed-sized arrays as your primitive (like C, Java, and C#), then you can avoid that double indirection in places where you know you don't need to be able to grow the array.",0.25,Java
13zcm5i,jmsl8qe,(Like C#'s indexer properties for example)  The syntax is an orthogonal question.,0.0,C
13zcm5i,jmw68fz,"Array decay is certainly annoying, but C absolutely has arrays built into the language as a fundamental construct.",-0.30000000000000004,C
13zcm5i,jmt74ci,"Even indexer properties in C# are not completely first-class, because you can't specify `x[N]` where `x` is a polymorphic variable over all types which support indexing.",-0.05,C
13zcm5i,jmt74ci,"If you throw away the indexer property and just have methods, then these can be treated exactly the same as any other method - they're first-class, and you can separate out the setter and getter, which you can't do in C# because of the limitation of properties (which are second-class).",0.041666666666666664,C
13zcm5i,jmt74ci,"let peek collection index = collection[index]      f peek c  A first-class solution is to have operators and methods be interchangeable with syntax, as Haskell does.",0.0,Haskell
13zcm5i,jmwq34x,"For instance, there's also no size or aliasing information, so C still pales in comparison to languages like FORTRAN, Futhark, Chapel, etc.. when it comes to array support.",0.0,C
13y6nol,,"The stage 1 uses C as backend, as input to gcc.",0.0,C
13y6nol,,Should my stage 2 mainly target LLVM or C?,0.16666666666666666,C
13y6nol,,"But it's also known to be slow at compiling, also with `-O0`, while C has tcc which would speed up my c-to-exe step.",-0.30000000000000004,C
13y6nol,,Also targetting C would keep the ability to get my executable as optimized as the LLVM one.,0.0,C
13y6nol,,Now a couple of questions: * if targetting C: are all those string manipulations going to slow down my compilation anyway?,-0.2277777777777778,C
13y6nol,jmlf2sx,"LLVM also does not help you implement the C ABI, nor a lot of other things you get for free lowering to C. It does give you control, but that control often means you have to do a bunch of research in order to implement it right.",0.1869047619047619,C
13y6nol,jmlf2sx,"Several projects using LLVM later ends up eyeing other options (Rust, Zig, Odin etc)  Personally my project is using LLVM, so I’ve had to tackle these issues and every time I’ve felt I’m “done” digging into details, I’ve later discovered I was completely wrong.",-0.10416666666666667,Rust
13y6nol,jmlf2sx,"On the other hand, it’s great being able to tailor the debug info and not have a dependency on an external C compiler.",0.29375,C
13y6nol,jmlj3wh,>if targetting C: are all those string manipulations going to slow down my compilation anyway  Let's try it with some of my tools.,-0.2277777777777778,C
13y6nol,jmlj3wh,"`mc` is a transpiler that, with `-c`, turns it into a single C source file; oh and `tm` is a timing tool:      c:\qx>tm mm qc     Compiling qc.m---------- to qc.exe     TM: 0.10          c:\qx>tm mc -c qc     M6 Compiling qc.m---------- to qc.c     TM: 0.09          c:\qx>tm mc -tcc qc     M6 Compiling qc.m---------- to qc.exe     W:Invoking C compiler: tcc  -oqc.exe qc.c c:\windows\system32\user32.dll -luser32 c:\windows\system32\kernel32.dll -fdollars-in-identifiers     TM: 0.33  Building directly takes 0.1 seconds; turning it into C source (and it is very busy source of 43,000 lines) is marginally faster.",0.05285714285714286,C
13y6nol,jmlj3wh,But then you need to invoke the C compiler.,0.0,C
13y6nol,jmlj3wh,"Overall the process is slower than a direct build, but 0.3 seconds to build an app like this is still reasonable, compared with:      c:\qx>tm mc -opt qc     M6 Compiling qc.m---------- to qc.exe     W:Invoking C compiler: gcc -m64  -O3 -oqc.exe qc.c -s     TM: 51.09  This invokes `gcc -O3`, and takes 50 seconds.",0.10000000000000002,C
13y6nol,jmlj3wh,"`gcc -O0` takes 6.5 seconds, 25 times as slow as tcc (factoring out the C generation), but the generated code is not much better.",-0.275,C
13y6nol,jmlafpy,It's a bit odd to be stating that LLVM is slower than C when clang is itself powered by LLVM.,-0.16666666666666666,C
13y6nol,jmn3zxe,"For my project's C code generator, there is some string manipulation (mostly concatenation, no searching or substring operations on already ""generated"" code - I also use a header and footer template though there is only a few dozen lines in each), BUT this could be (and perhaps should have been) hidden.",0.03333333333333333,C
13y6nol,jmn3zxe,"A way to do this would be to create an AST for the C code and then just ""pretty print"" it to obtain C source code to pass to the C compiler.",0.25,C
13y6nol,jmn3zxe,tcc has been helpful to reduce the time to run my conformance tests but this is mostly because I don't do any kind of separate compilation so I compile my standard library once for each test case and I don't do any parallel building of test cases yet (so I'm using a single core unless the C compiler itself is multi-threaded).,0.20571428571428574,C
13y6nol,jmlooty,"LLVM is notoriously slow, generating c & feeding that through tcc will be faster, & then fallback on llvm codegen for release builds  Alternatively you can roll your own simple x86 backend, which will be much faster than either gcc or llvm  > if targetting C: are all those string manipulations going to slow down my compilation anyway?",0.007407407407407386,C
13y6nol,jmm3ujr,"I’ve been thinking about targeting C for a long time, and I’ve been drawing up some ideas where based on string length and possibly other heuristics I either use ropey structures (which would be used anyways for incremental compilation via LSP) and use kernel file ops for file appending, and for smaller strings just roll a StringBuilder.",-0.05833333333333333,C
13y6nol,jmpuuly,My C generation looks like SSA so I have many variables which doesn't seem to slow down tcc,0.01481481481481479,C
13y6nol,jmlq7z9,[Heres a godbolt link](https://godbolt.org/z/Wvzn9GcKv) demonstrating this approach with some C code.,0.0,C
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,C
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,Rust
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,D
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,Pascal
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,Pascal
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,D
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,C
13y6nol,jmmamnq,"The *major* advantage is that you can compile Rust and others to small `.wasm` modules, simplifying the bootstrapping and FFI.",-0.09375,Rust
13y6nol,jmmp2pf,"> LLVM also does not help you implement the C ABI,  Can you elaborate?",0.5,C
13y6nol,jmmeaft,">On the other hand, it’s great being able to tailor the debug info and not have a dependency on an external C compiler.",0.29375,C
13y6nol,jmmeaft,"On the other hand, the minimal dependency for C is a 1.6MB (not GB) Tiny C installation.",-0.075,C
13y6nol,jmmeaft,"And for the C code I sometimes generate, I only need 2-3 files totalling under 0.25MB.",0.0,C
13y6nol,jmmeaft,"At the user-site, yes, a C installation will be needed.",0.0,C
13y6nol,jmmeaft,"Otherwise, Tiny C is small enough to bundle.",-0.08333333333333333,C
13y6nol,jmlax1r,"> It's a bit odd to be stating that LLVM is slower than C when clang is itself powered by LLVM  C has a lot of compilers (some of them are very fast, for example tcc which is not powered by llvm for sure, and one passes c code).",0.1977777777777778,C
13y6nol,jmnyvga,Lua is one of the fastest lightest high level scripting lang there is designed for embedded systems in the mid 90's when they had less juice then your average ant.,-0.03916666666666666,Lua
13y6nol,jmnyvga,I kinda want to now I may spend rest of my life writing my own modules and possibly trying to erase luarocks from my mind.Yes btw I KNOW the new luajit or luajr I think is still very much a work in progress as mentioned librarys and a bunch more stuff but I for one would love Lua to be at least on people's mind when there looking at embedded systems.,0.24233766233766232,Lua
13y6nol,jmm8cra,CIL is very flexible; you can even do pointer arithmetic; I would say whatever you can do with standard C you can also do with CIL.,0.1,C
13y6nol,jmmtc0w,"Yet, `bcc` is limited in throughput by needing to use intermediate ASM source code (`tcc` is straight to binary in one pass), so there are two lots of lowering to source code, first to C, then to ASM.",0.1261904761904762,C
13y6nol,jmlchby,"I didn't mention gcc in response to anything you've written, but because gcc and clang are the two major C compilers.",0.0625,C
13y6nol,jmmg0lp,"Which is why my `mc` transpiler product, if it also invokes the C compiler, defaults to gcc; Tcc requires the `-tcc` option.",0.0,C
13y6nol,jmmg0lp,"Because the problem with gcc (I think you found this with LLVM) is that the translation to C is so fast, invoking gcc is like driving into a brick wall.",0.2,C
13y6nol,jmlhhwv,Tiny C runs on ARM too.,0.0,C
13y6nol,jmnm664,"However, I'm using a weird and non-standard ABI that is just C compliant enough to let me use all the C runtime and POSIX functions I want to.",-0.25,C
13y6nol,jmw7hf9,Weighing in at just 12.5kLOC of C it is only 0.17% of the 7.3MLOC in LLVM.,0.0,C
13y35a5,jmlvjdj,"Zig is rooted in pragmatism & trying to be a better C, and its main focus is systems programming.",0.3333333333333333,C
13y35a5,jmmcagl,"Is like before Rust, a language that *not* fill (enough!)",0.0,Rust
13y35a5,jmmcagl,"So doing a lang you start with was is *very well know first* and then, maybe, you start adding complex things like:  - Type checking - Limited Type inference (hard) - Full Type inference (VERY hard) - Macros (hard) - Good macros (harder) - Generics (even harder) - RC (easy) - Gc (very hard to very very hard) - Novel GC replacements like Rust borrow checking (almost God tier hard until recently?)",-0.040662202380952396,Rust
13y35a5,jmnkxbn,"Let me give one reason that confuses me:  C++ template metaprogramming is compile-time code execution, and it is very different from the usual conceptions of dependent types.",-0.125,C++
13y35a5,jmnkxbn,"Macro systems like m4 or the macros of Scheme and Common Lisp can offer compile-time (or ""pre-compile-time"") code execution, but they are not type systems at all, let alone dependent ones!",-0.375,Scheme
13y35a5,jmnkxbn,"Macro systems like m4 or the macros of Scheme and Common Lisp can offer compile-time (or ""pre-compile-time"") code execution, but they are not type systems at all, let alone dependent ones!",-0.375,Lisp
13y35a5,jmo1tbx,At least compared to some C++ template error messages I have seen in the past.,-0.275,C++
13y35a5,jmsby4t,At least compared to some C++ template error messages I have seen in the past.,-0.275,C++
13xzgbs,,"Have a presentation on a selected programming language that I don't know yet, (so python, java, C++ and Scheme/Racket are out) and next week I need to send in 3 suggestions for my presentation.",0.0,C++
13xzgbs,jmk7oc5,"OCaml has objects lol  Or Common Lisp, CLs objects are pretty cool.",0.275,Lisp
13xzgbs,jmk4qtq,"My first and unusual suggestion is ( commercial) Delphi / ( Open Source) FreePascal which is considered for many obsolete, which is not, because it's very detailed in it's design, besides supporting procedural and object orientation also supports modules.",0.24571428571428572,Delphi
13xzgbs,jmk4qtq,"The third could be JavaScript due functional programming, object orientation and dynamic declaration of properties and methods.",-0.041666666666666664,JavaScript
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,Go
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,Kotlin
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,Swift
13xzgbs,jmkrbia,Scala should suit you because you can compare it with your Java language.,0.0,Scala
13xzgbs,jmkrbia,Scala should suit you because you can compare it with your Java language.,0.0,Java
13xzgbs,jmkrbia,And C# is “not too exotic”(tm) and I can help you answer the questions and give you pointers to documentation.,0.5,C
13xzgbs,jmkw15s,What about R?,0.0,R
13xzgbs,jmlut64,"Second for smalltalk, also [IOLang](https://iolanguage.org) is super great, and of course the mighty Lua",0.3833333333333333,Lua
13xzgbs,jmp57nv,Kotlin might be an interesting one since I'd love to dip my toes a bit in app making.,0.5,Kotlin
13xw8jg,,I've been a C++ developer for 20 years.,0.0,C++
13xw8jg,,I spent many years honing my craft under the scrutinizing look of C++ chat on StackOverflow.,0.2,C++
13xw8jg,,"I was obsessed with C++ templates for a long time, but now I've toned it down a lot (because they negatively affect compilation time, readability and cause disproportional complexity).",-0.2513888888888889,C++
13xw8jg,,"I've dabbled in Haskell 15 years ago, from the YAHT tutorial (anyone remember that?).",0.0,Haskell
13xw8jg,,"I've also played a bit with Clojure but didn't go deep into macros, which is probably where the exciting stuff begins?",0.15,Clojure
13xw8jg,jmjpkwa,"Personally, the last language that 'blew my mind' was Elixir.",0.0,Elixir
13xw8jg,jmjpkwa,"Coming from the world of mutexes and complicated sharing, Elixir makes everything so much easier.",-0.15,Elixir
13xw8jg,jmjyizy,Prolog / Datalog.,0.0,Prolog
13xw8jg,jmjyizy,I heard Prolog made writing interpreters so easy it was banned in competitions!,0.5416666666666667,Prolog
13xw8jg,jmju3ry,Scheme and/or Haskell.,0.0,Scheme
13xw8jg,jmju3ry,Scheme and/or Haskell.,0.0,Haskell
13xw8jg,jmju3ry,Haskell is also a beautiful language - thinking functionally will expand your mind since you’re very experienced with imperative programming,0.925,Haskell
13xw8jg,jmjqd93,"Avoiding the esoteric languages, my vote is APL.",0.0,APL
13xw8jg,jmjqd93,"I've been working with C++ for over a decade, and APL is one of the few languages that revert me to the layman's position of ""it's magic, got it.""",0.15,C++
13xw8jg,jmjqd93,"I've been working with C++ for over a decade, and APL is one of the few languages that revert me to the layman's position of ""it's magic, got it.""",0.15,APL
13xw8jg,jml3fa4,"A few ideas:  - [Uxntal](https://100r.co/site/uxn.html) - essentially a forth-like assembly language  for a small virtual computer - [Futhark](https://futhark-lang.org/) - use a functional language to program the gpu - [Haskell](https://haskell.org) - a general-purpose functional language with many unique properties (purely functional, lazy, expressive types, STM, etc).",0.04880952380952382,Haskell
13xw8jg,jml3fa4,"You mentioned you dabbled in Haskell, why not try it again?",0.0,Haskell
13xw8jg,jml3fa4,"(I've written about [7 things I learned from Haskell](https://gilmi.me/blog/post/2022/12/13/learned-from-haskell), and my book is linked at them bottom if you're interested :) ) - [Zig](https://ziglang.org) - might hit closer to home with your C++ background, but is doing a few new and interesting things in that space.",0.2372727272727273,Haskell
13xw8jg,jml3fa4,"(I've written about [7 things I learned from Haskell](https://gilmi.me/blog/post/2022/12/13/learned-from-haskell), and my book is linked at them bottom if you're interested :) ) - [Zig](https://ziglang.org) - might hit closer to home with your C++ background, but is doing a few new and interesting things in that space.",0.2372727272727273,C++
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,Haskell
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,Lisp
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,Rust
13xw8jg,jmktye5,"Personally I'm fond of Ruby (yes, under the hood, Ruby is a smalltalk dialect.)",0.0,Ruby
13xw8jg,jmjz8an,"Prolog, or another of the logic programming languages maybe?",0.0,Prolog
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,Fortran
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,Pascal
13xw8jg,jmju1e7,And one more was `K` (related to `J` and `APL`).,0.25,APL
13xw8jg,jmkrpnr,https://red-lang.org  A modern take on Lisp with a focus in DSLs.,0.2,Lisp
13xw8jg,jmk2hqk,"Rust was mine, and I know it’s a popular one for this sort of thing.",0.6,Rust
13xw8jg,jmjzcm6,Watch this video about writing meta interpreters in Prolog.,0.0,Prolog
13xw8jg,jmld3d9,"Coming from C++ you can expect a much shorter, more elegant and expressive and ergonomic version of what you already know, with added metaprogramming in the language itself.",0.5,C++
13xw8jg,jmld3d9,What you will especially like is that you can take any C++ project and integrate it with Nim with no overhead at all.,0.0,C++
13xw8jg,jmld3d9,"I used it to run write a quick, one-off genetic algorithm to guess future user behavior of a legacy C++ app by calling into the actual code with Nim- yet the programming still felt quick-n-easy.",0.1111111111111111,C++
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,JavaScript
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,C
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,C++
13xw8jg,jmld3d9,"Write a cross-platform GUI app using C++ libraries, get done faster and have it be more pleasant.",0.6166666666666667,C++
13xw8jg,jmld3d9,Leverage decades-old C libraries and give them your own usability spin.,0.6,C
13xw8jg,jmld3d9,"Then there's the community projects... probably the most amazing one is futhark, which leverages LLVM to auto-generate Nim-bindings for any C library.",0.55,C
13xw8jg,jmjw1z3,"Go deeper in Haskell, learn Racket and read Beautiful Racket to see what the fuss about language oriented programming is all about.",0.85,Go
13xw8jg,jmjw1z3,"Go deeper in Haskell, learn Racket and read Beautiful Racket to see what the fuss about language oriented programming is all about.",0.85,Haskell
13xw8jg,jmkda76,"Erlang blew my mind two decades ago, and it has remained blown.",0.0,Erlang
13xw8jg,jmkda76,"I would avoid, for now, Elixir.",0.0,Elixir
13xw8jg,jmkda76,"While it inherits much of what Erlang provides, there's a whole lot more piled on top that obscures the elegance and simplicity of the Erlang approach.",0.35,Erlang
13xw8jg,jmk6k4z,Raku  At first glance it seems like a more polished version of Perl with more features.,0.4166666666666667,Perl
13xw8jg,jmjppu7,Ada?,0.0,Ada
13xw8jg,jmlhru4,> I was obsessed with C++ templates  You might be into [Spiral's](https://github.com/mrakgr/The-Spiral-Language) staging capabilities.,-0.5,C++
13xw8jg,jmlkdgw,Rust for changing the natural patterns I've always used in imperial programming,0.1,Rust
13xw8jg,jmll3m2,"Actually, from what you describe as the ""major breakthroughs in programming"", you should definitely have a look at Common Lisp.",-0.059375,Lisp
13xw8jg,jmll3m2,"I'd recommend you start by installing SBCL + Quicklisp and a editor that supports Lisp (Emacs is not required, but it's a good choice if you already know how to use it).",0.7,Lisp
13xw8jg,jmll3m2,"A good book to get you started is ""Common Lisp: A Gentle Introduction To Symbolic Computation"".",0.19999999999999998,Lisp
13xw8jg,jmll3m2,"More advanced books are ""Let over Lambda"" and ""On Lisp"".",0.45,Lisp
13xw8jg,jmkkz8d,Top contender : [https://mercurylang.org/](https://mercurylang.org/)  It's like if Prolog and Haskell had a baby.,-0.125,Prolog
13xw8jg,jmkkz8d,Top contender : [https://mercurylang.org/](https://mercurylang.org/)  It's like if Prolog and Haskell had a baby.,-0.125,Haskell
13xw8jg,jmjllt1,Try Rust and play with it a little bit.,-0.1875,Rust
13xw8jg,jmli0od,"Datalog is a nice simple one that's very powerful and then there's something like Idris, it's Haskell but abstract.",0.33,Haskell
13xw8jg,jmlnbb2,The first is APL.,0.25,APL
13xw8jg,jmlnbb2,I was told it wasn't so much a language as a religion (by one of the developers of the Fortran language).,0.2,Fortran
13xw8jg,jmlnbb2,The other is Elixir!,-0.15625,Elixir
13xw8jg,jmma7a4,Julia.,0.0,Julia
13xw8jg,jmma7a4,And also the syntax is Pythonic but the performance is like C++.,0.0,C++
13xw8jg,jmkb0nj,Rust is the best answer I can give you.,1.0,Rust
13xw8jg,jmkb0nj,"It’s not a VASTLY different paradigm from languages like C++ in the way that things like Haskell are, but it’s way more pragmatic than either C++ or Haskell.",0.25,C++
13xw8jg,jmkb0nj,"It’s not a VASTLY different paradigm from languages like C++ in the way that things like Haskell are, but it’s way more pragmatic than either C++ or Haskell.",0.25,Haskell
13xw8jg,jmkb0nj,"Rust reaches for a higher-level of abstraction with the adoption of some functional-programming concepts, but maintains a level of tramsparency between the code you write and the low-level semantics.",0.0,Rust
13xw8jg,jmkb0nj,"Rust has got a bit of a bad reputation on here for its cult-like level of recommendation, but I don’t think that’s worth paying much attention to.",-0.06666666666666661,Rust
13xw8jg,jmkb0nj,It’s the only language I know of that has a chance of being “the thing to now use anywhere we used to choose C++”,0.0,C++
13xw8jg,jmkiyev,Prolog or Agda.,0.0,Prolog
13xw8jg,jmkiyev,The gap between Haskell’s type system and Agda’s type system about as large as the gap between C’s and Haskell’s.,0.21428571428571427,Haskell
13xw8jg,jmkiyev,The gap between Haskell’s type system and Agda’s type system about as large as the gap between C’s and Haskell’s.,0.21428571428571427,C
13xw8jg,jmkgua2,*Erlang or any BEAM language* - and the secret here is the BEAM VM.,-0.4,Erlang
13xw8jg,jmltlgh,Scheme was great for me.,0.8,Scheme
13xw8jg,jmltlgh,"For statically typed FP I prrfer OCaml over Haskell, I find it more pragmatic and very nice to use.",0.64,Haskell
13xw8jg,jmm1lze,"There are a lot of good languages out there with novel ideas, such as Nim, Zig, and of course Rust.",0.35,Rust
13xw8jg,jmm7tue,Forth  APL  Brainfuck  OOK!,0.0,Forth
13xw8jg,jmm7tue,Forth  APL  Brainfuck  OOK!,0.0,APL
13xw8jg,jmmlf7r,Rust will blow your mind.,0.0,Rust
13xw8jg,jmntfhc,"Try Ada, it has structured programming as a key design idea.",0.0,Ada
13xw8jg,jmkdh9z,I really enjoyed coding in Ruby (not Rails).,0.5,Ruby
13xw8jg,jmka845,"Rust, man  It seems like stuff you know on the surface, so I'm sure it doesn't sound exciting, but once you go all in on Rust, it'll change your entire life I promise",0.3,Rust
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,C
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,C++
13xw8jg,jmldl42,"JavaScript will most likely, as yout stated: blow your mind and make you question everything you've believed in - I'm not sure though if that's the way you wanted your mind to be blown.",0.08333333333333333,JavaScript
13xw8jg,jmmz9x1,I guess Lisp could do the same when you go deep enough.,0.0,Lisp
13xw8jg,jmn7onn,Odin might not blow your mind but it will definitely make you go “man I wish C was like this!”,0.0,C
13xw8jg,jmnaam1,Something similar can be done in *Ada* when you define a type for everything.,0.0,Ada
13xw8jg,jmnaam1,I've seen highly efficient implementations of cryptographic algorithms in Ada that read like a book.,0.16,Ada
13xw8jg,jmnaam1,"Other than that, I'd also recommend *Prolog* and *Mercury* like others have.",-0.125,Prolog
13xw8jg,jmo9zqs,"Basically the same data structures as Python, but a completely different evaluation model: “goal-directed” evaluation.",0.0,Python
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,Scala
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,Java
13xw8jg,jmr90vx,"Considering your rich background in C++ and Haskell, along with your interest in functional programming paradigms, I wouldn't necessarily predict that [Ballerina](https://ballerina.io) will ""blow your mind.""",0.1875,C++
13xw8jg,jmr90vx,"Considering your rich background in C++ and Haskell, along with your interest in functional programming paradigms, I wouldn't necessarily predict that [Ballerina](https://ballerina.io) will ""blow your mind.""",0.1875,Haskell
13xw8jg,jmrkk26,Have you tried Lisp (as in common Lisp)?,-0.3,Lisp
13xw8jg,jmrkk26,"I know Clojure is ""a lisp,"" but I've never tried it myself, and you saying that you never really dove into the macros makes me think you didn't really experience the parts of Lisp I'm thinking about.",0.05,Clojure
13xw8jg,jmrkk26,"I know Clojure is ""a lisp,"" but I've never tried it myself, and you saying that you never really dove into the macros makes me think you didn't really experience the parts of Lisp I'm thinking about.",0.05,Lisp
13xw8jg,jmrkk26,"Basically, Lisp starts out as a pretty simple programming language that can do ""a few things.""",0.016666666666666663,Lisp
13xw8jg,jmrkk26,The process of writing a complex program in Lisp is basically extending the Lisp language itself to become a domain-specific language.,-0.3,Lisp
13xw8jg,jmx55dc,CHICKEN Scheme uses continuation  passing style (CPS) so functions never return but rather continue executing the continuation (rest of progeam).,-0.6,Scheme
13xw8jg,jmmffep,Elixir was a huge game changer for me.,2.7755575615628914e-17,Elixir
13xw8jg,jmk1274,\+1 for Prolog.,0.0,Prolog
13xw8jg,jmk1274,"Mercury is also worth a try if you like strong types, but it helps if you've dabbled a little in Prolog first.",0.19895833333333332,Prolog
13xw8jg,jml8n2t,"Yep, Prolog for sure.",0.5,Prolog
13xw8jg,jml8n2t,Prolog does the “logic programming” thing so much better compared to logic libraries in other languages.,0.1875,Prolog
13xw8jg,jml8n2t,"Also, the fact that it’s homoiconic like Lisp allows so much cool metaprogramming stuff.",0.35,Lisp
13xw8jg,jml6as4,I will giving a talk later this year at Gophercon UK about how I implemented it in Go using concurrency.,0.0,Go
13xw8jg,jmjslli,Scheme was a stretch but not mind-bending in any way.,0.0,Scheme
13xw8jg,jmjslli,But array processing languages like APL and J are a total mind melt and a blast.,0.0,APL
13xw8jg,jmk821y,>APL  Just curious.,-0.1,APL
13xw8jg,jmk821y,Last time I used APL was on an IBM 5100 which had an APL keyboard.,0.0,APL
13xw8jg,jmkdrpv,"APL was my first programming language, back around 1972.",0.125,APL
13xw8jg,jmkdrpv,"Decades later when I discovered Functional Programming, it felt familiar to APL, in the sense of composing programs from expressions returning values.",0.1875,APL
13xw8jg,jml7xpd,"Modern, very good documentation, a bit less confusing than APL imo.",0.16083333333333333,APL
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,C++
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,Rust
13xw8jg,jmlorlg,"While Rust without a doubt puts a big emphasis on compile-time verification, things like integer overflows still happen, and are not caught by the compiler.",0.0,Rust
13xw8jg,jmkfjds,I found Erlang to be underwhelming as a programming language.,0.0,Erlang
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,Erlang
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,Elixir
13xw8jg,jmlx2yk,The thing that elixir has over Gleam and Erlang is it’s meta programming capabilities.,0.0,Erlang
13xw8jg,jmlx2yk,"Elixir is really good and doing scientific computing, data analytics, machine learning, etc.",0.7,Elixir
13xw8jg,jmlx2yk,where as Erlang isn’t great for it.,0.8,Erlang
13xw8jg,jmlx2yk,"Lib, does macro black magic to get Elixir to run on GPUs, etc)",0.16666666666666669,Elixir
13xw8jg,jmn7bnw,First time when I got introduced to Scala.,0.25,Scala
13xw8jg,jmlag0y,"For an experienced c++ dev, the Rust experience will probably be “oh this is nice, finally some built in tooling“ and then “why can’t I build my linked list example, get out of my way Rust I know what I’m doing”.",0.4666666666666666,Rust
13xw8jg,jmlag0y,"Rust is great if you come directly from the front end world and want to do some lower level development, or just prioritize safety over convenience, but Rust is just a more unpractical c++ imo.",0.4666666666666666,Rust
13xw8jg,jn628j7,"I never really liked Python and when Julia came out I liked it way more right away, and now it has more libraries and support than it used to",0.31714285714285717,Python
13xw8jg,jn628j7,"I never really liked Python and when Julia came out I liked it way more right away, and now it has more libraries and support than it used to",0.31714285714285717,Julia
13xw8jg,jn61zmx,"Lol one big issue with Ada is you need a bootstrapped GCC 10 to compile it, and then you need to compile gcc 11, and then gcc 12, and then gcc13, and 14 if you really want.",0.3333333333333333,Ada
13xw8jg,jmkbty4,"I mean, they've done some Haskell, so that's not mind blowing anymore and it would be the obvious go-to answer.",-0.15625,Haskell
13xw8jg,jmng36m,">I guess Lisp could do the same  Did you ever see DSSSL, which was the predecessor of XSLT?",0.0,Lisp
13xw8jg,jmjvqq0,"Erlang obviously, LFE is like Common Lisp but BEAM, Gleam is a new BEAM language.",-0.05454545454545454,Erlang
13xw8jg,jmjvqq0,"Erlang obviously, LFE is like Common Lisp but BEAM, Gleam is a new BEAM language.",-0.05454545454545454,Lisp
13xw8jg,jmnp19u,"Ecstasy supports a very similar model of concurrency:  * Ecstasy ""services"" are like Erlang processes: Objects that represent async execution and a domain of owned/managed state.",0.0,Erlang
13xw8jg,jmnp19u,"mutable data) only exists within the realm of a service; this is different from Erlang, which does not allow mutable data for the most part.",0.16666666666666666,Erlang
13xw8jg,jmkjcv6,"There are other BEAM languages, although probably not as developed/popular as Elixir.",-0.125,Elixir
13xw8jg,jml50dw,I think there's a BEAM-style concurrency library in Rust but it might not have taken off.,0.0,Rust
13xw8jg,jml50dw,There's also some mentions of BEAM-style concurrency using new lightweight Java threads?,0.13636363636363635,Java
13xw8jg,jml50dw,But probably someone is experimenting with it in Clojure by now.,0.0,Clojure
13xw8jg,jml633k,"Yeah Idris or LeanProver or Coq since you have worked with Haskell the syntax is kind of similar, but being able to then also prove programs are correct is mind blowing.",0.3666666666666667,Haskell
13xw8jg,jmkx0gj,Damn I’ll have to add Prolog to my list of languages to try.,0.0,Prolog
13xw8jg,jmkx0gj,So far APL is at the top,0.3,APL
13xw8jg,jmkba7m,"https://tryapl.org/  Also, I think Dyalog will install a custom keyboard map just for APL.",0.0,APL
13xw8jg,jmmaq0v,"I now dabble with both APL and BQN which have prefix key system, where you hit  a prefix, then a key after that to get the symbol you want.",0.0,APL
13xw8jg,jmll702,Curry (similar to Haskell but with logic features added),0.0,Haskell
13xw8jg,jmmcgjs,The thing I found interesting about Erlang is that it's basically microservices and Kubernetes two decades before everyone was raving about how this new concept was going to revolutionize the industry.,0.3181818181818182,Erlang
13xw8jg,jmn74ws,"I understand Elixir's appeal, it's just not for me.",0.0,Elixir
13xw8jg,jmn74ws,If I wanted Ruby I would learn Ruby.,0.0,Ruby
13xw8jg,jmkp77p,Do people really think Carp is harder than Rust?,0.05,Rust
13xw8jg,jmkp77p,"When I had used it, with no Rust experience, I figured Carp out in a few hours.",-0.2,Rust
13xw8jg,jmkp77p,"Rust, on the other hand, has such dense syntax and an endless list of features that it was not something I figured out in a few hours.",-0.1125,Rust
13xw8jg,jmkwz0i,"Also, you can make a lot of Erlang pids.",0.0,Erlang
13xw8jg,jmmy8iy,Go absolutely does not.,0.2,Go
13xw8jg,jmli2tg,Go concurrency is not identical but it is *really* similar...,0.0,Go
13xw8jg,jmngjuo,"All of those ways are reasonably efficient  Notably, “strip suffix” _should_ be `semidet`, but a typical Prolog implementation will actually be `nondet`, so it will do an extra iteration just to tell the caller “no more results”.",0.04722222222222222,Prolog
13xw8jg,jmp08zv,"Yes, Prolog has first-class support for nondeterminism.",0.0,Prolog
13xw8jg,jmp08zv,There is a joke that Prolog only has one algorithm: exponential backtracking search.,0.0,Prolog
13xw8jg,jmp08zv,"This is indeed a joke, but it's true that writing exponential backtracking search is much easier in Prolog than in most other languages.",0.23125,Prolog
13xw8jg,jn14owr,Elixir is superficially similar to ruby the syntax looks similar but the semantics are completely different,0.0,Elixir
13xw8jg,jmlou1s,"In my case I've used more Rust than C++, but now recently I've found myself going back to C++ due to convenience.",0.09375,Rust
13xw8jg,jmlou1s,"In my case I've used more Rust than C++, but now recently I've found myself going back to C++ due to convenience.",0.09375,C++
13xw8jg,jmlou1s,"Convenience of being a more mature language with generally larger, more popular and more feature rich libraries for a much broader usecases than Rust.",0.34687500000000004,Rust
13xw8jg,jmlou1s,"There are fun PoC projects like Bevy and (now archived) amethyst, but actual real world development is done in C++ and that's where the cutting edge is (e.g.",-0.024999999999999994,C++
13xw8jg,jmlou1s,"Also I have tried to use Rust for ""low level hackery"", like creating an injectable dynamic library that can hook functions of an application, and it's more of a hassle in Rust than with C++.",0.16666666666666666,Rust
13xw8jg,jmlou1s,"Also I have tried to use Rust for ""low level hackery"", like creating an injectable dynamic library that can hook functions of an application, and it's more of a hassle in Rust than with C++.",0.16666666666666666,C++
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,C++
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,C
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,Rust
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,Rust
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,C++
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,C
13xw8jg,jmlou1s,"However, if there is a project where security is the #1 concern of an application together with performanc, then Rust could be a good fit.",0.55,Rust
13xw8jg,jna3kda,"I didn’t know about that Ada overlay though, so thanks for the link.",0.2,Ada
13xw8jg,jmm335q,"While the actor model used by Erlang and communicating sequential processes which inspired Go are in some ways two sides of the same coin, Go is missing out on a lot of the things that make Erlang great:  - Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.30000000000000004,Erlang
13xw8jg,jmm335q,"While the actor model used by Erlang and communicating sequential processes which inspired Go are in some ways two sides of the same coin, Go is missing out on a lot of the things that make Erlang great:  - Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.30000000000000004,Go
13xw8jg,jmm335q,"In Go, all goroutines share one big global mutable heap.",0.0,Go
13xw8jg,jmm335q,"Go's memory model is built on racy concurrent mutation of global state, where Erlang doesn't have mutation of global state whatsoever, and very little global state to begin with beyond the code server.",-0.060937500000000006,Go
13xw8jg,jmm335q,"Go's memory model is built on racy concurrent mutation of global state, where Erlang doesn't have mutation of global state whatsoever, and very little global state to begin with beyond the code server.",-0.060937500000000006,Erlang
13xw8jg,jmm335q,"- Erlang is built on asynchronous messaging, which is much more flexible.",0.5,Erlang
13xw8jg,jmm335q,"Go channels use synchronous, bounded, blocking messaging - The Erlang/OTP framework provides extensive built-in support for building fault-tolerant concurrent applications, including declarative structuring of supervision hierarchies, and a ""let it crash"" philosophy intended to enable self-healing applications, with extensive exception reporting capabilities.",0.0,Go
13xw8jg,jmm335q,Go has none of that.,0.0,Go
13xw8jg,jmm2k2o,"The only difference is that concurrent processes communicate by sending messages over channels in Go, where concurrent processes communicate by sending messages directly each other in Elixer.",-0.008333333333333331,Go
13xw8jg,jmm2k2o,There are different consequences in how they are implemented in Go vs OTP.,0.0,Go
13xw8jg,jmm2k2o,"Yes, Go and Erlang have differences beyond their concurrency systems.",0.0,Go
13xw8jg,jmm2k2o,"Yes, Go and Erlang have differences beyond their concurrency systems.",0.0,Erlang
13xw8jg,jmm551p,"> Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.6,Erlang
13xw8jg,jmm551p,"In Go, all goroutines share one big global mutable heap.",0.0,Go
13xw8jg,jmm551p,Mutability can be a pain point in Go.,0.0,Go
13xw8jg,jmm551p,"> Erlang is built on asynchronous messaging, which is much more flexible.",0.5,Erlang
13xw8jg,jmm551p,"Go channels use synchronous, bounded, blocking messaging  I disagree that Erlang style asynchronous messaging is more flexible.",0.5,Go
13xw8jg,jmm551p,"Go channels use synchronous, bounded, blocking messaging  I disagree that Erlang style asynchronous messaging is more flexible.",0.5,Erlang
13xw8jg,jmm551p,You have to synchronize actors manually by essentially implementing TCP-lite if you want that kind of behavior using Erlang actors.,0.3,Erlang
13xw8jg,jmm551p,I don't think it's fair to say Erlang actors are more flexible.,0.6,Erlang
13xw8jg,jmm551p,Go has none of that.,0.0,Go
13xw8jg,jmm551p,CSP in Go can be implemented on a fault tolerant runtime - it just isn't.,0.0,Go
13xw8jg,jmmedgo,Go's concurrency model (CSP ) and Erlang/BEAM's (Actor) are different.,0.0,Go
13xw8jg,jmmedgo,")*  Go's model does allow shared state, but the idiomatic way to handle shared state is to ""share memory by communicating"", i.e., to use channels to pass the state around, these are not messages, and should not be confused with such.",-0.2,Go
13xw8jg,jmmedgo,"In Go's CSP model, goroutines (lightweight threads) communicate primarily through channels which can be thought of as typed pipes that allow you to send and receive values with the channel operator, <-.",0.4,Go
13xw8jg,jmmedgo,"There is no direct channel of communication as in Go; instead, each actor has a mailbox for incoming messages.",-0.05,Go
13xw8jg,jmmedgo,"In Go, goroutines and channels are the main concurrency primitives.",0.16666666666666666,Go
13xw8jg,jmmedgo,"In Go, error handling tends to be done through multiple return values and the error type.",0.0,Go
13xw8jg,jmmedgo,"Go’s channels provide a mechanism for guaranteed delivery – if a goroutine sends a message on a channel, another goroutine will receive it.",0.0,Go
13xw8jg,jmmedgo,"the Actor model and Go's CSP model both provide robust frameworks for handling concurrency, they embody different philosophies and offer different sets of trade-offs.",0.0,Go
13xw8jg,jmmybn0,Except Go isn't pure CSP as there's no restrictions on memory sharing at all.,0.21428571428571427,Go
13xw8jg,jmm89xe,> I disagree that Erlang style asynchronous messaging is more flexible.,0.5,Erlang
13xw8jg,jmm89xe,Erlang has blocking *receive*.,0.0,Erlang
13xw8jg,jmm89xe,Joe Armstrong did a great job of covering the tradeoffs here in his book Programming Erlang.,0.8,Erlang
13xw8jg,jmm89xe,> You have to synchronize actors manually by essentially implementing TCP-lite if you want that kind of behavior using Erlang actors.,0.3,Erlang
13xw8jg,jmm89xe,"It's one of the most common patterns in all of Erlang, and it's built into the framework that ships with the language.",0.1,Erlang
13xw8jg,jmm89xe,"Go, on the other hand, bakes this into the language at a very very deep level, rather than it being a framework implemented in lower-level, more flexible primitives.",0.125,Go
13xstwh,jmkukxt,"There's a bunch of Lox implementations in Rust:  https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust  If you understood the book, and as I see from other comments that you're more at home with Rust than C, then can you kind of imagine the book with these as the code examples?",0.325,Rust
13xstwh,jmkukxt,"There's a bunch of Lox implementations in Rust:  https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust  If you understood the book, and as I see from other comments that you're more at home with Rust than C, then can you kind of imagine the book with these as the code examples?",0.325,C
13xstwh,jmj5iff,If you know how to program then you can do the C part of that book.,0.0,C
13xstwh,jmj5iff,"Rust is different for sure, but you can probably extrapolate and figure it out.",0.25,Rust
13xstwh,jmj5iff,"C is a small language, it doesn't have any special features.",0.053571428571428575,C
13xstwh,jmjz7uc,You can checkout the [Rust implementations of clox](https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust) interpreter.,0.0,Rust
13xstwh,jmjz7uc,It might teach you how to express the ideas presented in the book in idiomatic Rust.,0.0,Rust
13xstwh,jmjcu4n,Can write but need deep compiler expert that first masters Rust.,0.125,Rust
13xstwh,jmj0sgp,Because im not as good with C as I am in Rust,0.7,C
13xstwh,jmj0sgp,Because im not as good with C as I am in Rust,0.7,Rust
13xstwh,jmj6b0j,"Rust has so many feautures to make things faster, i preferred learning from a ""rusty"" source then porting C to Rust, so I can learn the many features of the language, i will try to implement clox again tho",0.5,Rust
13xstwh,jmj6b0j,"Rust has so many feautures to make things faster, i preferred learning from a ""rusty"" source then porting C to Rust, so I can learn the many features of the language, i will try to implement clox again tho",0.5,C
13xpicd,,The nearest such feature is something that C calls 'X-macros\`.,0.0,C
13xpicd,jmitixg,"General solutions I am aware of:  * Code generation, of with X-macros is a clever hack to work within the limitations of the C preprocessor.",0.15555555555555556,C
13xpicd,jmitixg,"For example, Java enums have built-in methods to retrieve the name of an enum value.",0.0,Java
13xpicd,jmitixg,"I want to highlight Java enums here, which I think are a fairly elegant solution following the ""turn it into a language feature"" approach.",0.25,Java
13xpicd,jmk81cr,"Just for fun, I implemented the [same kind of thing in TypeScript here](https://www.typescriptlang.org/play?target=7#code/PTAEGcBcENISwMakgTwA4FNymgJw6AgPa74KQA2KocAdgGYakYAmoAFABZEBuTovfpE4EeeONABGFLAEoAUMVpRQAbRb4A5rWgBbLABpQW8HABeh4xk10WiLAF1QAXmREAKgFc0MgPL0AQVJoFHB2VXlQKLUAIhYABhijAA4jGNxEhwNI6NU4gEYk0FTQdMKsnKi8lkKUtNwAJhiK6NjoRKMAFnrM7Na86FrQbtLccuyHBXkQUABhCkQAa1KAJU9aGLcIDAJhAgoiTUUiZSIZADoDzXYNax19cAUlcDOMS8P2E3M5Y9OLq8+1ls9ke8jB4OmACpIZFIaAAOIYWhMRCgejrchwE6EE58XDwWiaHDBFAAWiI9FJkG8MmwkCIyBpGHJlLwuBC4CMumgdBgdDoR1AcKgsFRqEw4HOsOA0zAvloVAg3AA7rQ0SRQN4ttSfFgBPRQDJCcJQPFSSMENA1cQ0ChgGhoFBdgzlSRlvQNVbqEbNMJ5OjaJjsfSvLr-EF2aEbrBoAAuNSTeOqBz+jHwYMeJnhkngAA8AQAfNGYEmAg5k7JS8mUwGg2qQ1nAjn80YAEJFlgx0tt8uJtQBZNt6upwPp+uZsNNyN5gJtoyzDtd-tzua9yv9wegVub2bD2tjtyhvxTjktrfzowAEUXJeX57mV7XVayW53m8vw5mcF0uv0tBgY4jnWh6NhGHLFnGmq0IstBEKqyYVqAADelQ4sokCGkivqcC4oCdjAqjxA4AD8lxYSaxHEaaYKtPg1K4GqYEoOc9C4EQujsEhmHGjhAC+RjsAA+kYcCyC4BZ4TG5zcmg7BwJAGC6OJNAKboqhwJMCi8fIQA).",0.3,TypeScript
13xpicd,jmlgmai,">Just for fun, I implemented the same kind of thing in TypeScript here.",0.3,TypeScript
13xkz1o,jmssmg9,"Instead of passing by value with great difficulty, why not support Rust's `&mut`?",0.8,Rust
13xkz1o,jmhznwf,The great thing about Haskell etc.,0.8,Haskell
13xkz1o,jmmu0jf,"It depends on the language, but in C, you can get the address of a variable that lives on the stack, and if you're not careful, the pointer can outlive the stack frame it points to.",0.05,C
13xkz1o,jmj6my6,"Monads were adopted by Haskell as a way of achieving purity without needing uniqueness types that Clean had adopted - so I'd say there is, in some sense, a fundamental connection there.",0.3666666666666667,Haskell
13xkz1o,jmj6my6,[Phillip Wadler's Monads For Functional Programming paper](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf) gives a pretty good overview of why the Haskell developers went with monads.,0.475,Haskell
13xkz1o,jmiofcc,Just like in Haskell `IO ()` is the unit type in a context where input/output is possible.,0.0,Haskell
13xkz1o,jmiui3g,"For example, take the function `putChar :: Char -> IO ()` from [Haskell](https://hoogle.haskell.org/?hoogle=putChar).",0.0,Haskell
13xkz1o,jmiui3g,"This is especially important in strict functional languages like Haskell, where all functions are pure and side effects are prohibited.",0.5071428571428571,Haskell
13xkz1o,jmiui3g,Haskell gets around this restriction by making the side effect part of the type.,0.0,Haskell
13xkz1o,jmiyct4,"Yeah, I know Haskell and how IO works.",0.0,Haskell
13xkz1o,jmiyct4,"It could be defined as, in Haskell terms,  ```` newtype Random a = Random (Rng -> (a, Rng)) ````  where `Rng` is a known random number generator type (it could be a parameter to `Random` though).",-0.5,Haskell
13xkz1o,jmiyct4,"(GHC has a language option to enable linear types, but I haven't written any Haskell long before this was added, so I'm not sure how it works).",-0.15,Haskell
13xdkmr,jmhhy9q,"Just did some benches, the code is [here](https://gist.github.com/yndc/6691f1cc0dcc31de59fffa13d5afa0d3) (C++).",0.0,C++
13xdkmr,jmhhy9q,"To simulate padding, I used different data types in C++ (`short, int, long long` to store the same `char` type (1 byte).",-0.02,C++
13xdkmr,jmhjsis,"For example, C# has special annotations like `[FieldOffset(n)]` to let users customize exactly how data is aligned.",0.3035714285714286,C
13xdkmr,jmhjsis,Overlapping memory can even be used to model C unions.,0.0,C
13xdkmr,jmhjsis,"Still, this makes C# a lot better at native code interop than Java.",0.5,C
13xdkmr,jmhjsis,"Still, this makes C# a lot better at native code interop than Java.",0.5,Java
13xdkmr,jmi7spx,"Yeah C# keeps the default alignment as an implementation detail, unless you manually specify the alignment via annotations.",0.0,C
13xdkmr,jmhydpq,"Any C compiler will align 64-bit entities at 8-byte boundaries, I'd be surprised if other languages did anything different.",-0.008333333333333331,C
13xdkmr,jmi3b79,"Both Java and C# seem to default to system pointer size alignments, which is 8 byte for 64 bit machines.",0.0,Java
13xdkmr,jmi3b79,"Both Java and C# seem to default to system pointer size alignments, which is 8 byte for 64 bit machines.",0.0,C
13x7r6s,jmqq9gc,This may be partially why Go switches stacks when calling into C,-0.1,Go
13x7r6s,jmqq9gc,This may be partially why Go switches stacks when calling into C,-0.1,C
13x3q8g,jmhbbk7,"And that's beside the mention of ""great success""... Rust wasn't even around in 2002, and I don't think any language other than MLKit used regions at the time.",0.325,Rust
13x3q8g,jmhc2wm,"By C, I believe they're referring to Cyclone, which was being worked at around the same time.",0.0,C
13x2iv3,jmfvkzo,"When I first hacked my type system together, only structs were nullable, and they all were (like Java I guess).",0.125,Java
13x2iv3,jmfvkzo,I finally buckled down and figured out the syntax and semantics of the Imperative Shell part of my FC/IS language.,-0.07777777777777779,Shell
13x2iv3,jmfvkzo,"I need to look into a bug that may still be lurking in the multiple dispatch, add a little more built-in IO, add a `rune` type for compatibility with Go, and bring the docs up to date.",0.10416666666666667,Go
13x2iv3,jmmjcbm,"It was originally in D, but I was never able to setup a debugger on Windows, so I've swiched to C# (that I'm more used to) and quickly was able to fix some bugs that were haunting me for months and finally advanced again.",0.30972222222222223,D
13x2iv3,jmmjcbm,"It was originally in D, but I was never able to setup a debugger on Windows, so I've swiched to C# (that I'm more used to) and quickly was able to fix some bugs that were haunting me for months and finally advanced again.",0.30972222222222223,C
13x2iv3,jmj3b7c,The Cara language (https://cara-lang.com): right now I'm rewriting the interpreter in Elm (it was previously in TypeScript and before that in OCaml).,0.05952380952380952,Elm
13x2iv3,jmj3b7c,The Cara language (https://cara-lang.com): right now I'm rewriting the interpreter in Elm (it was previously in TypeScript and before that in OCaml).,0.05952380952380952,TypeScript
13x2iv3,jnt1ses,I was finally inspired to get started after reading Graydon Hoare’s post on how Rust would have looked different if he could make all the decisions.,0.0,Rust
13x2iv3,jnt1ses,"One of the things that struck me is that Hoare didn’t want capture groups in Rust, and I realized from my own immediate disagreement that I really like closures, so I decided to put together some ideas for a language that used scopes (closures) as it’s “atomic” unit.",0.4,Rust
13x2iv3,jnt1ses,"It would be a systems level language with managed memory like rust but draw several inspirations from Julia, another language I really enjoy.",0.2,Julia
13x2iv3,jo8qvxq,"There are still functions in some ways via a trait system kind of like Rust (also where and polymorphism appears), but it's not quite the same.",0.3,Rust
13x2iv3,jo8qvxq,These procedures can also have embedded C code which is how you interact with external stuff and how the core and standard libraries are implemented.,0.0,C
13x2iv3,jo1uusi,"A couple years into it, I discovered the D programming language and fell in love.",0.5,D
13x2iv3,jo1uusi,"D is already pretty close to what I wanted ZACL to be, and much more mature.",0.2833333333333333,D
13x2iv3,jo1uusi,It seemed to me that I should be able to implement ZACL's value-add features as a D framework.,0.5,D
13x2iv3,jo1uusi,"That proved a lot more difficult than I thought, and I've lowered my sights for that D framework.",0.0,D
13x2iv3,jo1uusi,"One of the ways I am toning down my ambitions is to make at least the first version a transpiler instead of a compiler, targeting C as its IR and using gcc as its back-end.",-0.06851851851851853,C
13x2iv3,jo1uusi,"* Extending the struct type to include class-like capabilities, pretty much identical to D's structs.",0.225,D
13x2iv3,joqkhwz,"I’m implementing my language, sammy-lang, in C++ using LLVM.",0.0,C++
13x2iv3,joqkhwz,My previous version is written in JavaScript and compiles to JavaScript.,-0.16666666666666666,JavaScript
13x2iv3,joslvvk,"I'm continuing to work on [pliron](https://github.com/vaivaswatha/pliron) (an MLIR like extensible compiler IR framework written in Rust), and recently added infrastructure for [automatic verification of interface (trait) implementations](https://github.com/vaivaswatha/pliron/wiki/Automatically-Verifying-Implementation-of-Interfaces).",0.0,Rust
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,Python
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,D
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,C
13x2iv3,jnrkjfg,"I needed to change my grammar from what I'd _like_ to write to something else just to appease the LR gods) - in TypeScript I used a simple recursive descent - sure, probably less performant, but I had the freedom to eg.",0.11111111111111112,TypeScript
13x2iv3,jnrkjfg,"I am for some reason way better at using ML languages than ALGOL ones, and was having trouble getting my head around some things, like the semantics of modules, private declarations etc.",0.09999999999999999,ALGOL
13x2iv3,jnrkjfg,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,TypeScript
13x2iv3,jnrkjfg,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,Elm
13x2iv3,jns74ix,"The code didn't change much, probably I was writing unidiomatic D to begin with haha (C# was already my daily language).",0.13333333333333333,D
13x2iv3,jns74ix,"The code didn't change much, probably I was writing unidiomatic D to begin with haha (C# was already my daily language).",0.13333333333333333,C
13x2iv3,jns74ix,"Now I have some extra seconds of start up time (D compiler was very fast), but my interpreter is still too simple for me to be able to tell if I got a speed improvement or regression.",0.19,D
13x2iv3,jnrovs1,"I needed to change my grammar from what I'd like to write to something else just to appease the LR gods) - in TypeScript I used a simple recursive descent - sure, probably less performant, but I had the freedom to eg.",0.11111111111111112,TypeScript
13x2iv3,jnrovs1,"I am for some reason way better at using ML languages than ALGOL ones, and was having trouble getting my head around some things, like the semantics of modules, private declarations etc.",0.09999999999999999,ALGOL
13x2iv3,jnrovs1,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,TypeScript
13x2iv3,jnrovs1,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,Elm
13wopmk,jmcva5l,"Some C and C++ programmers mistakenly believe that other programmers avoid these low level languages because they are bad programmers, but it's precisely the opposite: they understand the value of ruling out as many types of errors as possible.",0.01071428571428574,C
13wopmk,jmcva5l,"Some C and C++ programmers mistakenly believe that other programmers avoid these low level languages because they are bad programmers, but it's precisely the opposite: they understand the value of ruling out as many types of errors as possible.",0.01071428571428574,C++
13wopmk,jmcve6m,"I agree with his initial point that it’s good to pick whatever language you want to use/are good at, with some guidelines based on the situation, but I also feel like his dismissal of any criticisms of C as a language choice doesn’t make as much sense.",0.39999999999999997,C
13wopmk,jmcve6m,"Like, it’s inarguable that C has both safety and expressiveness flaws that other languages improve upon to various degrees, so while sure, use C if that’s what you feel like using, I don’t see why people suggesting you use another language that avoids some of its major flaws is a bad thing.",-0.05249999999999997,C
13wopmk,jmcve6m,You can simply just not take their advice if you really want or need to use C.,0.1,C
13wopmk,jmcolqt,"I get where the author is coming from, but I think the title should be changed to something like - why you shouldn't listen to anyone telling you not to write your compiler in C",0.0,C
13wopmk,jmdkgoj,"No, C is not hard because ""manual memory management is hard"".",-0.07291666666666667,C
13wopmk,jmdkgoj,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C
13wopmk,jmdkgoj,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C++
13wopmk,jmdkgoj,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C++
13wopmk,jmdkgoj,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C
13wopmk,jmdkgoj,Can you write stable and fast code using C?,0.2,C
13wopmk,jmdkgoj,"In the end, the important thing is that you actually write your compiler, your interpreter, your parser ...  (Disclaimer: I write C and C++ every day at work because we have no choice for our use case.",0.2,C
13wopmk,jmdkgoj,"In the end, the important thing is that you actually write your compiler, your interpreter, your parser ...  (Disclaimer: I write C and C++ every day at work because we have no choice for our use case.",0.2,C++
13wopmk,jmdkgoj,I like C++.,0.0,C++
13wopmk,jmcw959,C is **usually** a bad choice for writing a compiler.,-0.6999999999999998,C
13wopmk,jmcw959,"Of course, manual memory management, lack of features, etc are possible to make do with, and plenty of people do because they have other reasons to use C.  But it's still more difficult, more expensive, so if you're not a team of programmers working on a high speed compiler for all platforms, you absolutely should not use C. In my extremely limited experience it's quite cumbersome to write compilers and tests in C due to the lack of meaningful abstraction.",0.04896103896103896,C
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,Pascal
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,C
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,C++
13wopmk,jmcprpt,That was before Java & Python mainstream days.,0.0,Java
13wopmk,jmcprpt,That was before Java & Python mainstream days.,0.0,Python
13wopmk,jmcprpt,I could done it in Object and Class ( and Modular ) Oriented Pascal.,0.0,Pascal
13wopmk,jmcprpt,"(s) done in new P.L., several are using Functional Programming, which is not a new trend, because early Lisp developers where also using it.",0.042045454545454546,Lisp
13wopmk,jmcprpt,"I recently switched from Object Pascal to Plain C, for another hobbyist compiler project, for the simple reason that I need it to be portable/ crossplatform as possible, even if I preferred Object Oriented Pascal.",-0.05357142857142857,Pascal
13wopmk,jmcprpt,"I recently switched from Object Pascal to Plain C, for another hobbyist compiler project, for the simple reason that I need it to be portable/ crossplatform as possible, even if I preferred Object Oriented Pascal.",-0.05357142857142857,C
13wopmk,jmi8pdq,So I do think C is a fine choice for this.,0.4166666666666667,C
13wopmk,jmi8pdq,"That said, if someone is so defensive of C that they genuinely see no downside the lack of safety, I don't really understand why they'd be motivated to design a programming language in the first place and I don't think I'd be interested in anything they produced...",0.275,C
13whdk5,,"I wouldn’t use it personally because I like basic shit like python and JavaScript, but I’m interested in programming langauge design and want to hear the communities opinions (critical but be nice it’s obviously a long time passion project for the creator)",0.0857142857142857,JavaScript
13whdk5,jmbm7yr,"It is not however a new construct, it looks like the arithmetic `if` that used to be in Fortran (maybe it still is?",0.13636363636363635,Fortran
13whdk5,jmfxc4w,">it looks like the arithmetic `if` that used to be in Fortran  Yes, the `3-way if` example was inspired by the arithmetic `if` of Fortran.",0.0,Fortran
13whdk5,jmpqbyi,Seed7 was inspired by:  * The basic concepts of Pascal and Modula-2 and that they lead to a well structured compiler without complicated parsing tricks.,-0.25,Pascal
13whdk5,jmpqbyi,* How Ada tried to improve over Pascal with the negative consequence that parsing and compiling Ada is extremely complicated.,-0.4,Ada
13whdk5,jmpqbyi,* How Ada tried to improve over Pascal with the negative consequence that parsing and compiling Ada is extremely complicated.,-0.4,Pascal
13whdk5,jmpqbyi,I took the idea of exceptions from Ada and rejected its overloading concept that leads to ambiguous sub-expressions.,0.0,Ada
13whdk5,jmpqbyi,* The pragmatism of C where it is important to get things done.,0.4,C
13whdk5,jmpqbyi,You don't have C dialects like in Pascal and you have a capable standard library everywhere.,0.1,C
13whdk5,jmpqbyi,You don't have C dialects like in Pascal and you have a capable standard library everywhere.,0.1,Pascal
13whdk5,jmpqbyi,* The aim of Java to create libraries that are portable and independent from the world of C libraries.,0.0,Java
13whdk5,jmpqbyi,* The aim of Java to create libraries that are portable and independent from the world of C libraries.,0.0,C
13whdk5,jmpqbyi,: You would import a Pascal library and the rest of the program would be in Pascal.,0.0,Pascal
13whdk5,jmpqbyi,"Java did it, but these libraries require the use of the JVM.",0.0,Java
13whdk5,jmpqbyi,"There are of course many C libraries, but using them directly would expose Seed7 with all the low-level C concepts that I want to avoid.",0.3,C
13whdk5,jmpqbyi,So it was necessary to create driver libraries to interface C libraries (that might also differ between operating systems).,0.0,C
13whaja,jmbnga3,"If C3 is intended as a C replacement, then surely that would make a stronger case for it.",0.5,C
13whaja,jmbnga3,"If I didn't have my own better-than-C systems language, then yes I would use C too, for all of its problems and quirks.",0.6,C
13whaja,jmcd49j,"Later, if you wish to use C or C++, you can do use the same techniques by kind of mechanically translating the ideas in your head into idiomatic C or C++.",0.19999999999999998,C
13whaja,jmcd49j,"Later, if you wish to use C or C++, you can do use the same techniques by kind of mechanically translating the ideas in your head into idiomatic C or C++.",0.19999999999999998,C++
13whaja,jmcd49j,My issue with recommending C is how it relates to the poor way beginners go about learning compilers.,-0.4,C
13whaja,jmcd49j,"You get these people who kind of want to create a language for novelty purposes and then design a very complex system on paper and then want to implement it all in C. These people almost always end up paralysed by analysis paralysis, riddled by the pollution of the problem domain as it appears in C, and just end up yak shaving all these silly concerns - it is not unusual in amateur circles to find people yak shaving the same old lexer or parser for months!",-0.07357142857142858,C
13whaja,jmcd49j,are fond proponents of things like using garbage collection (even in C) and using languages from the ML family.,0.0,C
13whaja,jmcd49j,"It's not correct to be like ""well, Clang uses C++, therefore C++ must be ideal for hobbyist compiler implementation"".",0.9,C++
13whaja,jmdmgii,"No, C is not hard because ""manual memory management is hard"".",-0.07291666666666667,C
13whaja,jmdmgii,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C
13whaja,jmdmgii,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C++
13whaja,jmdmgii,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C++
13whaja,jmdmgii,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C
13whaja,jmdmgii,Can you write stable and fast code using C?,0.2,C
13whaja,jmdmgii,(Disclaimer: I write C and C++ every day at work because we have no choice for our use case.,0.0,C
13whaja,jmdmgii,(Disclaimer: I write C and C++ every day at work because we have no choice for our use case.,0.0,C++
13whaja,jmdmgii,I like C++.,0.0,C++
13whaja,jmbljy0,"> The C3 compiler is written in C, and there is frankly no other language I could have picked that would have been a substantially better choice.",0.28125,C
13whaja,jmbljy0,"The vast majority of the heavy lifting is done by LLVM and, yet, this project is still over 65kLOC of C code.",-0.1,C
13whaja,jmbljy0,A hand-rolled parser (no lex/yacc) including 222 lines of C code to parse an int.,0.0,C
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Haskell
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Swift
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Rust
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Scala
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,C
13whaja,jmbljy0,"Even if I was forced to use C I'd at least use `flex`, `bison` and as many libraries as I can get for all the tedious string manipulation and conversion.",-0.15000000000000002,C
13whaja,jmcoxgl,"I get where the author is coming from, but I think the title should be changed to something like - why you shouldn't listen to anyone telling you not to write your compiler in C..",0.0,C
13whaja,jmbfxoj,"> And doing an OO-style C++, or worse, Java, would just have pushed the compiler to slower and more bloated, with no additional benefits ...",0.04999999999999999,C++
13whaja,jmbfxoj,"> And doing an OO-style C++, or worse, Java, would just have pushed the compiler to slower and more bloated, with no additional benefits ...",0.04999999999999999,Java
13whaja,jmbfxoj,"I agree with Java (because of all dynamic allocation overhead and JVM dependency), but C++ is very well suited for compiler implementation (neither slower nor bloated, but easier to maintain) when moderately and judiciously used.",0.06666666666666667,Java
13whaja,jmbfxoj,"I agree with Java (because of all dynamic allocation overhead and JVM dependency), but C++ is very well suited for compiler implementation (neither slower nor bloated, but easier to maintain) when moderately and judiciously used.",0.06666666666666667,C++
13whaja,jmbfxoj,"I used both - C and C++ - to write compilers; both work well for the purpuse, but the latter makes a lot of things easier.",0.0,C
13whaja,jmbfxoj,"I used both - C and C++ - to write compilers; both work well for the purpuse, but the latter makes a lot of things easier.",0.0,C++
13whaja,jmbfxoj,"EDIT: just had a look at the C3 language; looks interesting, a bit like Oberon+ with a C syntax ;-) Nice to see that generic modules are considered useful by more language designers.",0.3583333333333334,C
13whaja,jmbfxoj,The LLVM backend looks a bit like a kludge; why not just a C cross-compiler?,0.0,C
13whaja,jmbnorn,"If there is a case where “use C to implement your language” is good advice, it’s probably limited to people who are writing languages that are similar to C.  “You can do anything in C if you’re good enough” is not an argument I usually expect from people who are investing effort into creating new languages.",0.1735621521335807,C
13whaja,jmbq5kh,">  > If C3 is intended as a C replacement, then surely that would make a stronger case for it.",0.5,C
13whaja,jmcfd0q,"What I **don't** like is when someone comes in and says *""I want to write a compiler and I'm thinking of doing it in C""* and then someone just vomits their opinions all over the whole discussion claiming it's impossible to write compilers in C, and how if you don't have feature X (usually pattern matching and sum types are listed as the magical components needed) it's impossible to write a compiler.",-0.17666666666666664,C
13whaja,jmcfd0q,"That said, I know a lot of people trying out in particular *Rust* as a language to implement languages in because everyone is recommending it.",0.16666666666666666,Rust
13whaja,jmcfd0q,And then they try to learn Rust and implement a compiler at the same time.,0.0,Rust
13whaja,jmcfd0q,"In the case of C, there is a very gentle introduction to creating a compiler in C with Crafting Interpreters.",0.26,C
13whaja,jmcfd0q,Following that makes C a breeze to use.,0.0,C
13whaja,jmcfd0q,"Maybe if someone had written something similar in Rust then learning compilers and learning Rust at the same time would be more successful for people, but we're not there yet.",0.3125,Rust
13whaja,jmcfd0q,So for that you'd stay away from C and so on.,0.0,C
13whaja,jmmptt3,"I personally do think that C is better them what you might think, given that a compiler is actually not heavyly involved in string processing.",0.16666666666666666,C
13whaja,jmmptt3,"The biggest issue with C IMO is that you have no structural matching and ADTs and have to emulate these features on a near constant base, since transfering ADTs is indeed a core part of a compiler.",-0.23333333333333336,C
13whaja,jmc51bt,>A hand-rolled parser (no lex/yacc) including 222 lines of C code to parse an int.,0.0,C
13whaja,jmc51bt,"I can save 20 lines on mine by using C's `strtod` to turn text into a float, once it has been isolated and freed of separators etc.",0.0,C
13whaja,jmbrra5,SURELY that is just some bad requirement by C?,-0.09999999999999992,C
13whaja,jmbrra5,"C surely doesn't have a `DEFAULT` statement, right?",0.39285714285714285,C
13whaja,jmbsqrw,"I worked with lowering to C, and while it has advantages, it also gives you less control and more need for additional installs.",0.16666666666666669,C
13whaja,jmcch93,> C++ is very well suited for compiler implementation  Tree rewriting is tedious in C++ due to the lack of sum types and pattern matching.,-0.14166666666666666,C++
13whaja,jmbg2f8,"Yes, I agree and that's why I qualified it, writing ""OO-style C++"" and not ""C++""",0.0,C++
13whaja,jmbpmdz,"> If there is a case where “use C to implement your language” is good advice, it’s probably limited to people who are writing languages that are similar to C.  That doesn't follow.",0.20952380952380953,C
13whaja,jmbpmdz,Only really esoteric languages like BF offer comparably-complicated implementations in C and other languages.,0.025000000000000005,C
13whaja,jmcilgc,"It cannot be argued that it's the most productive to go about certain parts of compilers in C. If we look at a screenshot from Andrew Appel's book ""Modern Compiler Implementation in C"":  [https://i.imgur.com/zEFlfIy.png](https://i.imgur.com/zEFlfIy.png)  You can see that it's basically matching over the structure of a tagged union encoding of the IR trees (as part of how to do tree tiling instruction selection), right.",0.09000000000000001,C
13whaja,jmcilgc,"Although, it can just be written directly in OCaml, Standard ML, Haskell, Scala, etc.",0.05,Haskell
13whaja,jmcilgc,"Although, it can just be written directly in OCaml, Standard ML, Haskell, Scala, etc.",0.05,Scala
13whaja,jmcilgc,"So, as much as I agree that it's possible, it's by no means the most illuminating, productive, or maintainable approach to take (using C).",0.2333333333333333,C
13whaja,jmcilgc,"I usually don't actively dissuade people already using C, but it is painful to avoid the classic ""in OCaml, this is just..."" replies.",-0.2222222222222222,C
13whaja,jmumjz3,"_Note: the C and C++ compilation models are a bit ""odd"", since each file leads to a separate process invocation.",-0.16666666666666666,C
13whaja,jmumjz3,"_Note: the C and C++ compilation models are a bit ""odd"", since each file leads to a separate process invocation.",-0.16666666666666666,C++
13whaja,jmc7y14,"> I can save 20 lines on mine by using C's strtod to turn text into a float, once it has been isolated and freed of separators etc.",0.0,C
13whaja,jmc7y14,There must be C libraries that already do almost all of this for you.,0.0,C
13whaja,jmc7y14,Maybe if you want to support some exotic number representation you'll need to write an extra line of code but writing 222 lines of code and then concluding that C rules is lunacy.,0.25,C
13whaja,jmc9tl5,"As soon as you step outside the features of C, LLVM is flakey, e.g.",0.0,C
13whaja,jmcb66r,Even if I was writing that in C I'd use `flex` and a string conversion library.,0.0,C
13whaja,jmcb66r,SURELY that is just some bad requirement by C?,-0.09999999999999992,C
13whaja,jmcb66r,"C surely doesn't have a DEFAULT statement, right?",0.39285714285714285,C
13whaja,jmcb66r,Hence your argument that C is blub doesn't hold water.,0.0,C
13whaja,jmbv6wy,C has had a default statement since K&R.,0.0,C
13whaja,jmbv6wy,C has had a default statement since K&R.,0.0,R
13whaja,jmcya2a,"> Tree rewriting is tedious in C++  What language would you then recommend for this purpose, and can you reference an example which demonstrates the specific advantage compared to C++?",-0.25,C++
13whaja,jmbg99g,Even OO-style C++ is ok when judiciously used; e.g.,0.5,C++
13whaja,jmcnuvz,Someone who really wants a “better C” is unlikely to enjoy writing their compiler in Haskell and someone who wants dependent types is unlikely to enjoy writing it in C. This is a coarse generalization of course.,0.08750000000000001,C
13whaja,jmcnuvz,Someone who really wants a “better C” is unlikely to enjoy writing their compiler in Haskell and someone who wants dependent types is unlikely to enjoy writing it in C. This is a coarse generalization of course.,0.08750000000000001,Haskell
13whaja,jmcoekc,"I don't know if the code in ""Modern Compiler Implementation in C"" is a good argument against C, given that it supposedly had all C auto-translated from the original ML sources or some such.",0.31875,C
13whaja,jmdv5z9,"When I once attempted a C compiler from scratch, I spent around 90 days, for an indifferent result that could nevertheless turn some C source programs into runnable binaries for x64.",-0.1,C
13whaja,jmdv5z9,"(I was able to build and run Lua, Seed7 and SQLite3 - nearly half a million lines - with varying success.)",0.2111111111111111,Lua
13whaja,jmdv5z9,Including 1.5 to 3 days to write a full C preprocessor.,0.35,C
13whaja,jmdv5z9,"My actual C compiler is a 100% self-contained 1MB executable, and compiles C code at about half the speed of Tiny C.",-0.05555555555555555,C
13whaja,jmccp0x,"LLVM IR is more of an assembly language for a generic machine, while C is a portable language abstracting PDP-like machines.",0.25,C
13whaja,jmccp0x,"Rust targets LLVM IR as well, does it make LLVM IR a Rust-like language?",0.0,Rust
13whaja,jmccp0x,"You can do oneliners in Haskell that are unreadable but would take 10 lines of human readable C.  If I need Haskell's features, I'll choose Haskell.",0.0,Haskell
13whaja,jmccp0x,"If I need C's features, I'll choose C. LOC is not a feature.",0.0,C
13whaja,jmcd0mw,>Even if I was writing that in C I'd use flex and a string conversion library.,0.0,C
13whaja,jmbws6m,"With additional installs I mean that if one lowers to C, a C compiler needs to be installed for the platform, and on several platforms that means a lot of downloads.",-0.15625,C
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Haskell
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Rust
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Swift
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Scala
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Kotlin
13whaja,jmd2lz0,Scheme and Lisp have good libraries to help with this.,0.7,Scheme
13whaja,jmd2lz0,Scheme and Lisp have good libraries to help with this.,0.7,Lisp
13whaja,jmd2lz0,> and can you reference an example which demonstrates the specific advantage compared to C++?,0.0,C++
13whaja,jmcql6k,"The C wasn't auto translated, not that part of the book anyway.",0.0,C
13whaja,jmcql6k,"Most people dissuading people from C aren't saying it's impossible, they just don't want them to spend so long doing it (I'm sure you have your own articles where you've pondered C3's design for over a decade).",0.17666666666666667,C
13whaja,jme6tp4,"However, few are written in C.  The nearest I can think of is something like a [C parser written in OCaml](https://github.com/jhjourdan/C11parser) or the static analyzer [Frama-C](https://frama-c.com/).",0.15,C
13whaja,jme6tp4,"Even if there were, who is to say that two C compilers are comparable?",0.0,C
13whaja,jme6tp4,OCaml vs C for a decent sized program should be comparable.,0.16666666666666666,C
13whaja,jme6tp4,C is likely to be much slower in a first cut but has the potential to be ~3x faster than OCaml if you devote enough time to optimising it.,0.09,C
13whaja,jme6tp4,"> When I once attempted a C compiler from scratch, I spent around 90 days, for an indifferent result that could nevertheless turn some C source programs into runnable binaries for x64.",-0.1,C
13whaja,jme6tp4,"(I was able to build and run Lua, Seed7 and SQLite3 - nearly half a million lines - with varying success.)",0.2111111111111111,Lua
13whaja,jme6tp4,That's incredible and a great target but I don't know of anyone writing C compilers in OCaml.,0.8500000000000001,C
13whaja,jme6tp4,"Rust was originally written in OCaml but I don't know of anyone rewriting it in C.  > Applying that factor, I would have been able to do that in 5-10 days?",0.4375,Rust
13whaja,jme6tp4,Including 1.5 to 3 days to write a full C preprocessor.,0.35,C
13whaja,jme6tp4,If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,C
13whaja,jme6tp4,Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,C
13whaja,jme6tp4,"> My actual C compiler is a 100% self-contained 1MB executable, and compiles C code at about half the speed of Tiny C.  That's awesome but surely when you look at your compiler you see lots of repeating patterns in the code?",0.2666666666666667,C
13whaja,jmcf8ra,"> LLVM IR is more of an assembly language for a generic machine,  Let's look at the features:  * Functions (C and LLVM IR but not asm).",0.25,C
13whaja,jmcf8ra,* Arguments (C and LLVM IR but not asm).,0.0,C
13whaja,jmcf8ra,* Return value (C and LLVM IR but not asm).,0.0,C
13whaja,jmcf8ra,* Structs (C and LLVM IR but not asm).,0.0,C
13whaja,jmcf8ra,* Only fixed-width registers (asm but neither C nor LLVM IR).,0.0,C
13whaja,jmcf8ra,* Arbitrary jumps (asm but neither C nor LLVM IR).,-0.1,C
13whaja,jmcf8ra,* Raw stack (asm but neither C nor LLVM IR).,-0.23076923076923078,C
13whaja,jmcf8ra,LLVM IR is just a parsed and sanitised C with some additions like extra calling conventions and optional TCO.,0.0,C
13whaja,jmcf8ra,"You can do oneliners in Haskell that are unreadable but would take 10 lines of human readable C. >  > If I need Haskell's features, I'll choose Haskell.",0.0,Haskell
13whaja,jmcf8ra,"If I need C's features, I'll choose C. LOC is not a feature.",0.0,C
13whaja,jmbxul2,> a C compiler needs to be installed for the platform  Not sure whether this is a valid point; never came across a platform where there wasn't a standard C compiler easily available; even C++98 is virtually available everywhere with little effort; after all that's the main reason why e.g.,0.08819444444444445,C
13whaja,jmbxul2,I am using C or C++ for my compilers.,0.0,C
13whaja,jmbxul2,I am using C or C++ for my compilers.,0.0,C++
13whaja,jmd2jk3,"Products and sum types are ADTs, and C++ have both.",0.0,C++
13whaja,jmd2jk3,"- `std::variant` is the equivalent to Rust enums  - `std::optional` is the Maybe monad  - `std::expected` is the Either monad  By your logic, Rust enums and the Maybe/Either monads are the poor man's sum types.",-0.4,Rust
13whaja,jmd2jk3,"In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Rust
13whaja,jmd2jk3,"In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Haskell
13whaja,jmd2jk3,"`std::holds_alternative` and `std::get` are the equivalent of Rust's `if let` expressions, which are a form of pattern matching.",0.0,Rust
13whaja,jmbueco,"Well, LLVM is not exactly an example of ""moderate"" C++, is it?",-0.0625,C++
13whaja,jme6p3q,"But I mind people saying ""It's impossible to write a compiler in C, there isn't a worse choice, you need to have sum types and pattern matching to write a compiler"".",-0.5333333333333333,C
13whaja,jmeeo3v,>If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,C
13whaja,jmeeo3v,"You could just use an existing C compiler, it would be even quicker!",0.0,C
13whaja,jmeeo3v,>Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,C
13whaja,jmeeo3v,I could write a long article on what makes C hard to compile.,-0.17083333333333334,C
13whaja,jmeeo3v,"Plus, and this is the bit that takes man-years, is ensuring it will work for the billions of lines of existing C code.",0.0,C
13whaja,jmeeo3v,(So much for C being portable!),0.25,C
13whaja,jmcgjxq,LLVM doesn't implement the C ABI aside from placing things in the right registers.,0.2857142857142857,C
13whaja,jmcgjxq,LLVM has no concept of unions (which makes implementing some parts of C very very gnarly) 3.,0.26,C
13whaja,jmcgjxq,"Saying ""LLVM IR is like C"" is frankly a clown.",0.0,C
13whaja,jmeearg,Like Rust and Swift that both clock in at about 50% of the time spent in the frontend.,-0.1,Rust
13whaja,jmeearg,Like Rust and Swift that both clock in at about 50% of the time spent in the frontend.,-0.1,Swift
13whaja,jmbz03i,\> Not sure whether this is a valid point; never came across a platform where there wasn't a standard C compiler easily available  Windows requires downloading MSVC or doing things through Mingw which is a problem in itself.,0.05000000000000001,C
13whaja,jmd5fwy,"Can you speak to the ergonomics of C++ features such as using `std::variant` for full encoding of ASTs, type representations, etc.",0.175,C++
13whaja,jmd5fwy,"Tells me a lot that your language is written in Rust and not C++, in spite of the fact you've noted C++ does have pretty poor versions of all of the things mentioned.",-0.07500000000000001,Rust
13whaja,jmd5fwy,"Tells me a lot that your language is written in Rust and not C++, in spite of the fact you've noted C++ does have pretty poor versions of all of the things mentioned.",-0.07500000000000001,C++
13whaja,jmd7b13,"> Products and sum types are ADTs, and C++ have both.",0.0,C++
13whaja,jmd7b13,> std::variant is the equivalent to Rust enums > std::optional is the Maybe monad > std::expected is the Either monad  In a loose sense.,-0.07692307692307693,Rust
13whaja,jmd7b13,"> By your logic, Rust enums and the Maybe/Either monads are the poor man's sum types.",-0.4,Rust
13whaja,jmd7b13,"This is getting off topic but, FWIW, the issue with Rust in this context is the inability to pattern match through an `Rc`.",0.0,Rust
13whaja,jmd7b13,"> In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Rust
13whaja,jmd7b13,"> In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Haskell
13whaja,jmd7b13,Both Rust and Haskell have actual sum types and pattern matching with few limitations.,-0.1,Rust
13whaja,jmd7b13,Both Rust and Haskell have actual sum types and pattern matching with few limitations.,-0.1,Haskell
13whaja,jmd7b13,"> std::holds_alternative and std::get are the equivalent of Rust's if let expressions, which are a form of pattern matching.",0.0,Rust
13whaja,jmd7b13,"Here's a little OCaml function to locally rebalance a red-black tree:      let balance = function       | `Black, z, `Node(`Red, y, `Node(`Red, x, a, b), c), d       | `Black, z, `Node(`Red, x, a, `Node(`Red, y, b, c)), d       | `Black, x, a, `Node(`Red, z, `Node(`Red, y, b, c), d)       | `Black, x, a, `Node(`Red, y, b, `Node(`Red, z, c, d)) ->           `Node(`Red, y, `Node(`Black, x, a, b), `Node(`Black, z, c, d))       | a, b, c, d -> `Node(a, b, c, d)  Please can you translate those 7 lines of sum types and pattern matches into C++ using `std::variant` and `std::visit`?",-0.14236111111111108,C++
13whaja,jmd7b13,That would be great but I've been hearing that C++ is about to get these features for 20 years now...,0.8,C++
13whaja,jmbvwbz,"It's an example of ""by the book"" C++ OO.",0.0,C++
13whaja,jmew4hr,I've done a few in C (I think you saw my 99-line JIT).,-0.2,C
13whaja,jmew4hr,> > If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,C
13whaja,jmew4hr,"You could just use an existing C compiler, it would be even quicker!",0.0,C
13whaja,jmew4hr,>  > > Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,C
13whaja,jmew4hr,>  > I could write a long article on what makes C hard to compile.,-0.17083333333333334,C
13whaja,jmew4hr,"Plus, and this is the bit that takes man-years, is ensuring it will work for the billions of lines of existing C code.",0.0,C
13whaja,jmew4hr,(So much for C being portable!),0.25,C
13whaja,jmew4hr,I suppose C is a different kettle of fish.,0.0,C
13whaja,jmcyi2k,In C functions accept many values but can return only one value.,0.25,C
13whaja,jmcyi2k,"> Even so, many features you listed are available in many programming and assembly languages that are nothing like C.  You didn't say ""programming languages unlike C"".",0.4666666666666666,C
13whaja,jmcyi2k,Functions and structs alone put LLVM IR much closer to C than any asm.,0.2,C
13whaja,jmcx4xl,> LLVM doesn't implement the C ABI aside from placing things in the right registers.,0.2857142857142857,C
13whaja,jmcx4xl,"> LLVM has no concept of unions (which makes implementing some parts of C very very gnarly)  Well, ok. You bitcast between structs to emulate unions.",0.38,C
13whaja,jmcx4xl,My point is that they're C style not tagged or discriminated unions like sum types in most modern languages.,0.35,C
13whaja,jmcx4xl,> LLVM IR is in SSA form  True but neither C nor asm are SSA.,0.35,C
13whaja,jmcx4xl,> LLVM IR is built around basic blocks  Ok but how is that more like asm and less like C?,0.20833333333333334,C
13whaja,jmcx4xl,C has block statements.,0.0,C
13whaja,jmcx4xl,In C and LLVM they cannot.,0.0,C
13whaja,jmd7bh7,"My language (letlang) is written in Rust because of the ecosystem: logos, rust-peg, etc...  Not because of the language's syntax and features.",0.0,Rust
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,Haskell
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,C++
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,Erlang
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,Elixir
13whaja,jmd7bh7,"The first draft of my language was done in Python, prior to the \`match\` statement.",0.125,Python
13whaja,jmd7bh7,"My choice of Rust is not based on the syntax/features of the language, therefore it does not invalidate my argument.",0.0,Rust
13whaja,jmczytr,"Not by your ridiculous standards, still that's what they are, and that's what C functions are usually translated to (if not inlined).",-0.29166666666666663,C
13whaja,jmczytr,"> You didn't say ""programming languages unlike C""  ""programming and assembly"", at least quote me correctly.",-0.3,C
13whaja,jmczytr,> Functions and structs alone put LLVM IR much closer to C than any asm  [HighLevel ASM records](https://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLARef/HLARef_html/HLAReference.htm#pgfId-1003858) disagree with you.,0.2,C
13whaja,jmdv5ng,"CCC does not implement the C ABI, It just packs things in the right registers.",0.2857142857142857,C
13whaja,jmdv5ng,My point is that they're C style  Being able to bitcast between types is not doing C unions.,0.5,C
13whaja,jmdv5ng,"Oh, so you think this is equivalent to C scopes?",0.0,C
13whaja,jmdv5ng,"> Ok but how is that more like asm and less like C  You're the one suggesting that the transformation C -> LLVM IR was a trivial one, not me.",0.2777777777777778,C
13whaja,jmdv5ng,In C and LLVM they cannot.,0.0,C
13whaja,jmd9xsy,"Yet, in response, they get replies that sometimes imply it's not tedious (""but.. but.. C++ has a shit version of this"").",0.024999999999999994,C++
13whaja,jmca4n1,"Nor is it my favourite, but hopefully this explains why I was saying ""OO C++"" is a bad idea with this definition of ""OO C++""",-0.6999999999999998,C++
13whaja,jmdb8zw,"Not by your ridiculous standards, still that's what they are, and that's what C functions are usually translated to (if not inlined).",-0.29166666666666663,C
13whaja,jmdb8zw,"The fact that C functions are usually translated to labels, calls and returns does not mean labels, calls and returns are functions.",-0.046875,C
13whaja,jme1zwh,">  > CCC does not implement the C ABI, It just packs things in the right registers.",0.2857142857142857,C
13whaja,jme1zwh,">  > Oh, so you think this is equivalent to C scopes?",0.0,C
13whaja,jme1zwh,"> > > LLVM IR is built around basic blocks > > > > Ok but how is that more like asm and less like C >  > You're the one suggesting that the transformation C -> LLVM IR was a trivial one, not me.",0.20833333333333334,C
13whaja,jme1zwh,In C and LLVM they cannot.,0.0,C
13whaja,jme7wzp,"The problem is when someone asks ""how do I solve this problem in my compiler written in C?""",0.0,C
13whaja,jme7wzp,"and the answer is ""You can't write a compiler in C, you should use Rust or Ocaml!""",0.0,C
13whaja,jme7wzp,"and the answer is ""You can't write a compiler in C, you should use Rust or Ocaml!""",0.0,Rust
13whaja,jme3z49,When I said that LLVM doesn't have scopes I am referring to C nestable scopes.,0.0,C
13w4l1z,,My goal is to have enough knowledge to try building a compiler for a simple functional programming language (something similar to Haskell or Ocaml I gusss?),0.0,Haskell
13w4l1z,jm9we7j,"Boom, now you have most of Scheme.",0.5,Scheme
13w4l1z,jmf2kht,"Go back and read about System F, universal/existential types, and higher-order polymorphism.",0.0,Go
13w4l1z,jmf2kht,"Note that implementing something like Haskell or OCaml would require learning about modules/typeclasses, but at that point you'll have enough knowledge to find those resources yourself.",0.0,Haskell
13w4l1z,jmami22,"Elixir and Rust also have hygienic macros, if I’m not mistaken.",0.0,Elixir
13w4l1z,jmami22,"Elixir and Rust also have hygienic macros, if I’m not mistaken.",0.0,Rust
13w4l1z,jmf2d6q,"They're significantly better than C's preprocessor macros, but they are not quite as robust as Racket's.",0.5,C
13w4l1z,jmf2d6q,"(A few searches indicate that Rust's macros are not hygienic over things like type parameters or something, and Elixir's fall short because their hygiene is rooted in a late resolution system.",-0.16666666666666666,Rust
13w4l1z,jmf2d6q,"(A few searches indicate that Rust's macros are not hygienic over things like type parameters or something, and Elixir's fall short because their hygiene is rooted in a late resolution system.",-0.16666666666666666,Elixir
13w3cw3,jmd8op6,"I recommend being familiar with both and the relevant literature prior to these papers you've linked: see TIL and David Tarditi's PhD thesis, see Compiling with Continuations, look at MLton's IRs, look at Haskell's Core language, etc.",0.25833333333333336,Haskell
13w2oya,jmax0da,"C is faster in terms of execution time, not development time.",0.0,C
13w2oya,jmax0da,"No one has ever said ""I'll develop this in C because it will take me half the time"".",-0.16666666666666666,C
13w2oya,jmax0da,"If anything C should be a good example of this, where you choose a programming language that's less productive in order to benefit in terms of performance once the project is complete.",0.2111111111111111,C
13w2oya,jmb35jf,"From a language perspective Java is lacking, there is no doubt.",0.0,Java
13w2oya,jmb35jf,"When I see seasoned Java developers move to Kotlin which also makes it very easy, I still observe old patterns being followed: mutable state and huge objects.",0.32833333333333337,Java
13w2oya,jmb35jf,"When I see seasoned Java developers move to Kotlin which also makes it very easy, I still observe old patterns being followed: mutable state and huge objects.",0.32833333333333337,Kotlin
13w2oya,jmb35jf,Whereas the Scala code bases I have seen are much better.,0.5,Scala
13vxdez,jm8h03p,I have been working on something with similar goals (also in Haskell!,0.0,Haskell
13vsbrh,,"The APL language has multidimensional arrays as a first-class data type, but up to now only vectors (lists) can be written literally in code.",0.0,APL
13vsbrh,,Dyalog is considering adding a general notation for arrays to APL.,0.05000000000000002,APL
13vsbrh,jm9v35o,"I am not a habitual APL user, but I was under the impression you could lay out your code pretty much how you liked, and there was a reshape operator for vectors.",0.35000000000000003,APL
13vsbrh,jmbiiyz,APL distinguishes between lists of lists and N-dimensional arrays.,0.0,APL
13vsbrh,jmbiiyz,"You could always use reshape \`⍺⍴⍵\` to create N-dimensional arrays in APL, but now your source code can visually reflect the structure:      [ 'abc' 'def'       (1 2) (3 4) ]  The above example is APLAN syntax equivalent to the APL expression:  `2 2⍴'abc' 'def' (1 2) (3 4)`  Lastly, the diamond here is not an operator in that it doesn't accept arguments and return results - but rather it is *syntax* for constructing higher dimensional arrays and namespaces.",-0.1,APL
13vsbrh,jmbiiyz,"In the same way you're unlikely to call the parentheses and commas in an ALGOL-style function call `myFunction(param1,param2)` ""operators"", we wouldn't call APL Array Notation ""functions"" in APL.",-0.25,APL
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,PHP
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,C++
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,Rust
13vozxh,jm7888e,This is what Rust works hard to prevent.,-0.2916666666666667,Rust
13vozxh,jm8l40j,"Java is infamous for failing badly here, even within its chosen paradigm.",-0.5999999999999999,Java
13vozxh,jm9cj7q,In my current project we are working with Kotlin and make heavy use of [data classes](https://kotlinlang.org/docs/data-classes.html) which is essentially the same thing.,-0.05,Kotlin
13vozxh,jmcp0lm,"Pony, an actor language, uses what it calls [reference capabilities](https://tutorial.ponylang.io/reference-capabilities/index.html) to govern data sharing: Immutable data can be freely shared between actors, isolated data (like C++'s unique\_ptr) can be passed from one actor to another by giving up ownership, and regular data can do whatever except being passed to another actor.",0.2,C++
13vozxh,jm77cu5,"If I understand the PHP case correctly, there will be no mutable version of a class if you declare the class `readonly`.",0.0,PHP
13vozxh,jm77cu5,"The C++ analogy would be a class with every member (and member function) being `const`, I guess.",0.0,C++
13vozxh,jm7uvxy,"Rust's references are closest to Affine types, because there is a requirement to use them at most once (borrowing aside), but there is no hard requirement that they must be used, as with a linear type system.",0.3229166666666667,Rust
13vozxh,jm7uvxy,Rust does allow violating any uniqueness guarantees due to unsafe code.,-0.125,Rust
13vozxh,jm7uvxy,[Austral](https://borretti.me/article/introducing-austral#linear) attempts to have Rust style borrowing with the additional linearity constraint.,0.0,Rust
13vozxh,jo9f4l0,The person you're replying to is using `struct` and `class` in ways that are consistent with the Swift programming language.,0.25,Swift
13vozxh,jo9f4l0,"In Swift, classes are reference types that are similar to heap-allocated objects in other popular languages (except that Swift uses reference counting for garbage collecting rather than a tracing garbage collector), whereas structs are value types, such that even when you mutate a struct-holding variable, it behaves as though you're re-assigning that variable with a new copy of the value.",0.12227272727272727,Swift
13vozxh,jmiyr89,"In Java, arrays are mutable so you have to be careful about sharing them.",-0.1,Java
13vozxh,jmiyr89,``` byte[] bytes = new byte[10]; // fill bytes f(bytes); // f might hold onto a reference to bytes ```  But there's no way for a Java program to modify a zero length array so it can be safely shared.,0.3181818181818182,Java
13vozxh,jmiyr89,But Java's type system does not allow specifying the array length as part of the array type.,0.0,Java
13vozxh,jmiyr89,"So in Java, you can't distinguish, without first adding to the type system, between an array that is safe to share and one that is not.",0.375,Java
13vozxh,jma5ab9,"I've looked at Clean, Pony and Rust but only done much with Rust.",0.18888888888888888,Rust
13vozxh,jma5ab9,I don't fully understand what the type system of Clean or Pony offer that's practically different than that of Rust which seems more limited but enough.,0.15904761904761905,Rust
13vozxh,jma5ab9,One thing that I imagine Pony can handle better than Rust is for cyclic data.,0.5,Rust
13vozxh,jma5ab9,"I found [A Comparison of the Capability Systems of Encore, Pony and Rust (pdf)](https://uu.diva-portal.org/smash/get/diva2:1363822/FULLTEXT01.pdf) that summaries them in the introduction as:  > The conclusion is that Rust has an advantage in its capability system compared to the other two, but because the languages have very different strengths and weaknesses it depends on the programmer's personal preference of which is the best one for her or him.",0.275,Rust
13vozxh,jmizp83,Java is arguably an interpreted language until it's JITed so maybe my example is relevant.,0.4,Java
13vozxh,jmizp83,"Fyi, Java's specified semantics require that any use of the `new` operator that completes normally completes with a reference with an identity different from any previously available reference: `new byte[0] != new byte[0]`.",0.16553030303030303,Java
13vozxh,jmcw26w,"Haskell originally had a main function `IO a -> IO b`, where you would have to pass and return the IO reference around for anything that was effectful, until monads and typeclasses were added.",0.2708333333333333,Haskell
13vozxh,jmcw26w,"The Axum language was C#-like, and could interact with a variant of C# which had `static` (aka global) removed and replaced with an `isolated` keyword, which would be more like a static thread local.",0.3,C
13vozxh,jmcw26w,"I think the idea in both of these languages is to make actor based systems more accessible to non purely functional programmers, but get many of the benefits of languages like Erlang.",0.39732142857142855,Erlang
13vozxh,jmcw26w,Rust's design is clearly descended from C++'s move semantics and `unique_ptr`.,0.10000000000000002,Rust
13vozxh,jmcw26w,Rust's design is clearly descended from C++'s move semantics and `unique_ptr`.,0.10000000000000002,C++
13vozxh,jmcw26w,These were a bit of a trade-off because they were designed to keep backward-compatibility in mind with older versions of C++.,0.16666666666666666,C++
13vozxh,jmcw26w,"Rust fixed this by enforcing no use-after-move at compile time, and the rest of the language was then designed around that model.",0.1,Rust
13vozxh,jmjuag8,"Yeah, Java's abnormal in any number of ways.",0.0,Java
13vozxh,jmjuag8,But Java arrays are mutable and it is only the sheerest coincidence that they also have fixed size at allocation time.,0.05,Java
13vozxh,jmjuag8,"Given the business strategy around Java, it all makes sense.",0.0,Java
13vozxh,jmnod8e,The JVMs `native` mechanism to connect Java methods to (mostly) C code and the JVM embedding ABI both assume that Java arrays do not change size and may not be `realloc`ed or reduce in size when native code calls back into Java code.,0.25,Java
13vozxh,jmnod8e,The JVMs `native` mechanism to connect Java methods to (mostly) C code and the JVM embedding ABI both assume that Java arrays do not change size and may not be `realloc`ed or reduce in size when native code calls back into Java code.,0.25,C
13vozxh,jmnod8e,My understanding is that not having a type that maps straightforwardly to C arrays would complicate a lot of that supporting C code.,0.3125,C
13vozxh,jmq7xgo,I was infatuated with Haskell for a while but came to the realization that the world is inherently dynamic and trying to shoehorn everything into static types just means adding more and more layers of abstraction.,0.26,Haskell
13vozxh,jmq7xgo,"In this case though, I'm using it as a transpiler to C, because I want low level access to the processor and memory for performance reasons.",0.0,C
13vozxh,jmskyat,When I first looked at OCaml I think it didn't handle parallel threads and F#/.Net is more likely to be accepted into the mainstream even with its C#/CLR interop baggage.,0.1875,C
13vozxh,jmstxe2,"The JVM ecosystem and languages like Scala are obviously much simpler on android, but not much help on iOS.",0.05,Scala
13vozxh,jmstxe2,"For most things, the syntax is more terse than C#, and it has better defaults.",0.5,C
13v7xul,jm50ake,"Like C# Roslyn Analyzers, or the Roc IDE.",0.0,C
13v7xul,jmqqx5k,For example you typically write a comment `/** */` over a method name in C++ or Java.,-0.16666666666666666,C++
13v7xul,jmqqx5k,For example you typically write a comment `/** */` over a method name in C++ or Java.,-0.16666666666666666,Java
13v7xul,jmqqx5k,"(In Python it's `"""""" """"""`.)",0.0,Python
13v7xul,jmqqx5k,You can also declare a method in Java and have it throw an `UnsupportedOperationException`.,0.0,Java
13v7xul,jmqqx5k,"As opposed to that, in Scala, you can have it return `???`.",0.0,Scala
13usqwq,,"I first noticed it in Rust that the language designers are very comfortable with just declaring ""X is UB"" (undefined behaviour) instead of providing sensible behaviour for edge-cases.",0.385,Rust
13usqwq,,"Currently, I'm refreshing my knowledge of C and found that newer C standards introduced UB where previously it was up to the implementation to define behaviour.",0.16666666666666669,C
13usqwq,jm2a34t,"(I'm talking about C, I'm not really familiar with how Rust does or uses UB.)",-0.1875,C
13usqwq,jm2a34t,"(I'm talking about C, I'm not really familiar with how Rust does or uses UB.)",-0.1875,Rust
13usqwq,jm2cf6s,Iirc especially early C standards left lot of behavior implicitly undefined which I suspect was recognized as problematic.,0.1,C
13usqwq,jm2cf6s,Especially for C standard they also have to take into account existing implementations; while the standard is written in prescriptive tone in actuality it is more just descriptive.,0.125,C
13usqwq,jm27jei,"I may be wrong but I feel like it's more a matter of being the case that once you define a behaviour you can't undefine it, and I know Rust in particular is extremely careful (for backward compatability reasons) about what behaviour it declares as stable.",0.016666666666666663,Rust
13usqwq,jm29sjw,"In Rust, this is trivial.",0.0,Rust
13usqwq,jm29sjw,"I'd never heard of the ""zero sized allocations are UB"" thing before, because it's not something Rust programmers ever have to worry about, unlike in C.",0.0,Rust
13usqwq,jm29sjw,"I'd never heard of the ""zero sized allocations are UB"" thing before, because it's not something Rust programmers ever have to worry about, unlike in C.",0.0,C
13usqwq,jm343lg,"> I first noticed it in Rust that the language designers are very comfortable with just declaring ""X is UB"" (undefined behaviour) instead of providing sensible behaviour for edge-cases.",0.385,Rust
13usqwq,jm343lg,"Rust has two ""modes"": safe and unsafe.",0.5,Rust
13usqwq,jmab5lx,"In the current UB arms race between C and C++ compilers, what programmers *think* UB means is ""whatever the CPU does is what should happen"", but the way that the language-lawyering compiler developers interpret it is ""the compiler is allowed to assume that UB never happens"".",0.0,C
13usqwq,jmab5lx,"In the current UB arms race between C and C++ compilers, what programmers *think* UB means is ""whatever the CPU does is what should happen"", but the way that the language-lawyering compiler developers interpret it is ""the compiler is allowed to assume that UB never happens"".",0.0,C++
13usqwq,jmab5lx,This is part of the semantics of C++.,0.0,C++
13usqwq,jmab5lx,"C++ is meant to support object identity, which means that if you call \`operator new\` twice in a row, without deleting one of those objects, it must return different pointers.",0.0,C++
13usqwq,jm40t9d,I am not entirely sure why you think allocating zero memory in Rust is undefined behaviour.,-0.25,Rust
13usqwq,jm40t9d,"Perhaps if you’re implementing extremely low-level data structures, you may need to be concerned about some unsafe APIs, but most people writing Rust will never need to worry about this.",0.1875,Rust
13usqwq,jm40t9d,"Rust strives to make as much of the language as possible undefined-behaviour free (or “safe”, in Rust parlance).",0.275,Rust
13usqwq,jm4co16,"In practice, this is not a thing you often rub up against if you're not working in a language like C, because most languages don't let you wantonly break their constraints; they will have some combination of static and dynamic checks and restrictions on basic language functionality to ensure that you play within their rulesets.",0.25,C
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,C
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,Rust
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,Haskell
13usqwq,jm2b7ko,Sounds like Rust is a good language to avoid.,0.7,Rust
13usqwq,jm7p2zu,"In Rust, integer overflow is defined as a panic.",0.0,Rust
13usqwq,jm7p2zu,The C version will most likely loop forever (it is UB after all.,0.25,C
13usqwq,jm588a8,"My view about C's UB is that I don't care for it, especially for things that I don't consider UB, like signed integer overflow.",0.0,C
13usqwq,jm588a8,"Quite often I've had a language where such overflow is well-defined, and desired target machines where it is well defined, but if using intermediate C between the two, now you have to run the gauntlet of some bloody-minded C compiler messing up your code and doing whatever the hell it likes.",0.0,C
13usqwq,jm588a8,Why is it UB in C?,0.0,C
13usqwq,jm588a8,"Even if writing in C, you're going to end up with different behaviour across compilers and with with the same compiler, depending on options.",0.0,C
13usqwq,jm588a8,"C is supposed to be a lower level language where you call the shots, but apparently not; the compiler does.",-0.025,C
13usqwq,jm2hw2m,"This was the case with early C, but is nowadays not really a factor because everything is so standardized.",0.0,C
13usqwq,jm3cbmx,Annex J in the C standard is invaluable.,0.0,C
13usqwq,jm2bqg9,">it's not something Rust programmers ever have to worry about,  ""Ever"" is doing a lot of work here.",0.0,Rust
13usqwq,jm2bqg9,"People do write low level code in Rust (with custom allocators and whatnot, though that part is unstable), it's just that the most common cases for memory allocation are already covered by `std`.",0.06666666666666667,Rust
13usqwq,jm3xohk,"> I'd never heard of the ""zero-sized allocations are UB"" before, because it's not something Rust programmers ever have to worry about, unlike in C.  Somewhat amusingly, you have this backwards.",0.6,Rust
13usqwq,jm3xohk,"`malloc(0)`, `new T[0]`, and `Alloc().allocate(0)` (for any `Alloc` implementing the Allocator requirements) are not undefined in C and C++; they all return a value which is unspecified except that it may be subsequently deallocated with `free`, `delete`, or `deallocate`, respectively (this may be null or another singleton, or it may be the address of an actual allocation, but either way the user is not allowed to dereference it).",0.10727272727272727,C
13usqwq,jm3xohk,"`malloc(0)`, `new T[0]`, and `Alloc().allocate(0)` (for any `Alloc` implementing the Allocator requirements) are not undefined in C and C++; they all return a value which is unspecified except that it may be subsequently deallocated with `free`, `delete`, or `deallocate`, respectively (this may be null or another singleton, or it may be the address of an actual allocation, but either way the user is not allowed to dereference it).",0.10727272727272727,C++
13usqwq,jm3xohk,"In Rust, by contrast, a type implementing `std::alloc::GlobalAlloc` _may_ invoke undefined behavior when passed 0 (though the default `std::alloc::System` allocator does not, as it also implements `std::alloc::Alloc`, which has a stronger set of requirements).",0.0,Rust
13usqwq,jm36y53,"`unsafe` is *far* from the only kind of UB in Rust, and it's scary that people still believe that.",0.04999999999999999,Rust
13usqwq,jmgd6m4,"This is a bigger problem in Rust than in C or other similar unsafe languages because Rust requires a LOT of invariants from your code, and really will do crazy things if you mess up any of the subtle details of pointers and aliasing, etc..",-0.1476190476190476,Rust
13usqwq,jmgd6m4,"This is a bigger problem in Rust than in C or other similar unsafe languages because Rust requires a LOT of invariants from your code, and really will do crazy things if you mess up any of the subtle details of pointers and aliasing, etc..",-0.1476190476190476,C
13usqwq,jm3uea8,"Per DonaldPShimoda's exposition higher up: C has ""undefined"" and also has ""implementation defined"" and ""unspecified"".",0.25,C
13usqwq,jm4fn50,> I am not entirely sure why you think allocating zero memory in Rust is undefined behaviour.,-0.25,Rust
13usqwq,jpuitya,What UB does eg JavaScript have?,0.0,JavaScript
13usqwq,jm2idkd,"I assure you, the existence of UB in Rust is grossly mischaracterized by OP.",0.0,Rust
13usqwq,jm352kh,> Sounds like Rust is a good language to avoid.,0.7,Rust
13usqwq,jm3jiyy,The size of an `int` in C is an implementation-defined behavior.,0.0,C
13usqwq,jm3jiyy,The order of evaluation of arguments to a function in C is an unspecified behavior.,0.0,C
13usqwq,jmaqer2,"It should be noted that in C, infinite loops (with non-constant conditions) themselves are undefined behavior (unless you perform IO, access a volatile/atomic value, or a small number of other exceptions of ""observable behavior"" inside of the loop).",-0.1875,C
13usqwq,jmaqer2,"So unless there's a black-box function call inside, a C compiler is free to assume *all* loops terminate.",0.4,C
13usqwq,jm2hx3w,"In Rust, most of the way one can invoke UB is by deliberately circumventing the strong guarantees the language provides  (using `unsafe { ...",0.4666666666666667,Rust
13usqwq,jm2hx3w,The problem that C(++) has compared to Rust is that any piece of code can have UB and innocuous looking code can be UB.,0.0,C
13usqwq,jm2hx3w,The problem that C(++) has compared to Rust is that any piece of code can have UB and innocuous looking code can be UB.,0.0,Rust
13usqwq,jm2hx3w,"Rust is quite literally designed with the property that the safe subset of the language will never introduce UB, almost like a mamaged language such as Java.",0.25,Rust
13usqwq,jm2hx3w,"Rust is quite literally designed with the property that the safe subset of the language will never introduce UB, almost like a mamaged language such as Java.",0.25,Java
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,Rust
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,C
13usqwq,jm3g53x,Can you give an example of user-error UB in safe Rust?,0.5,Rust
13usqwq,jm2hf2o,> Are you  saying that it impossible for a Rust program to call the `malloc` function of the C library via whatever FFI it has?,-0.6666666666666666,Rust
13usqwq,jm2hf2o,> Are you  saying that it impossible for a Rust program to call the `malloc` function of the C library via whatever FFI it has?,-0.6666666666666666,C
13usqwq,jm2hf2o,"Calling functions through FFI in Rust requires `unsafe`, so if you restrict your code to safe Rust then it's not (directly) possible.",0.25,Rust
13usqwq,jm4sjwp,"I'm most familiar with what Rust does as that's the systems language I use the most, and for the most part I think that what they label as UB is rather sensible, [according to this partial list](https://doc.rust-lang.org/reference/behavior-considered-undefined.html), at least.",0.24583333333333332,Rust
13usqwq,jm4sjwp,"For what it's worth, I do agree that UB should probably be a last resort, or reflecting of some problems with the backend (if you transpile to C or are working on top of LLVM or something), instead of being the first thing you reach for.",0.2625,C
13usqwq,jp710jy,"I think the point @BobSanchez47 is making is that Rust has objects that you just create, so few devs ever really call `alloc()`.",0.0,Rust
13usqwq,jp710jy,Whereas C always requires you to call `malloc(sizeof(MyStruct))` to get something roughly equivalent.,-0.1,C
13usqwq,jp710jy,"For all I know, Rust might have more UB in total than C, but only in gnarly low-level API nobody ever uses, making it UB-free in practice.",0.16666666666666666,Rust
13usqwq,jp710jy,"For all I know, Rust might have more UB in total than C, but only in gnarly low-level API nobody ever uses, making it UB-free in practice.",0.16666666666666666,C
13usqwq,jm2s7l7,C++),0.0,C++
13usqwq,jm42l7l,"In particular, Rust still hasn’t pinned down exactly what constitutes undefined behaviour when it comes to pointer aliasing and provenance, so any proof that undefined behaviour is impossible relies on a non-settled definition of UB.",-0.10138888888888889,Rust
13usqwq,jm37gjm,You can brick a system with Python if you really want to.,0.2,Python
13usqwq,jm37gjm,"Rust, being a very low-level systems programming language needs to give you access to the tools you need to... program systems.",0.2,Rust
13usqwq,jm3t9vz,"I know that it's not how C works, but by golly, the way it currently works is just too bizarre and arguably far more dangerous than it should be.",0.08,C
13usqwq,jm2qwph,And Rust developers LOVE happy paths.,0.65,Rust
13usqwq,jm2qwph,"But alas, Rust is not the only language there is.",-0.2,Rust
13usqwq,jm2jsvz,"Well, if I'm going down anyway, let's make it official:  *I dislike Rust, but not nearly much as its trigger-happy mob of fans.",-0.1277777777777778,Rust
13usqwq,jm3812x,Then how would Rust allow FFI with C/C++/whatever else that handles raw pointers?,-0.23076923076923078,Rust
13usqwq,jm56iqd,"> Rust, being a very low-level systems programming language   If Rust is 'very low level', that would make mine the other side of assembly.",0.025000000000000005,Rust
13usqwq,jm45dge,Hmm but it is _useful_ (for C) to have these dark corners where the behavior is undefined.,0.075,C
13usqwq,jm2x3ix,"> But alas, Rust is not the only language there is.",-0.2,Rust
13usqwq,jm3ygax,Writing a memory safe language that is free from UB is barely any work (I could do it in a day); writing a memory safe language that is as performant as C is a substantial amount of work (it takes dozens of developers working together 5+ years); writing a memory safe language that is free from UB and as performant as C is literally impossible.,0.2404761904761905,C
13usqwq,jm4cfkr,"> there would have at least been runtime checks on whether specific pointers can be dereferenced  Rust has ""managed pointers"" that are guaranteed to always be safe to de-reference: borrows!",0.10833333333333334,Rust
13usqwq,jm3j46e,"For actually performance-critical systems programming, generally nothing above C or even ASM is tolerable, this does not mean there aren't any other languages that do more, and this does not mean a certainly constrained design isn't lazy.",0.07797619047619048,C
13usqwq,jm3j46e,"I'm good enough to program in C, CUDA or ASM for things that need to be programmed in those.",0.35,C
13usqwq,jm3btvp,"My criticism is not that this stuff isn't checked, but that `safe` Rust is lazily defined, not as things that can be done safely, but as things that the authors think should be deemed safe.",0.3125,Rust
13usqwq,jm3btvp,"If this means a systems language, for example, in Go you would receive an error.",0.0,Go
13usqwq,jm3btvp,"Well, there is a lot to learn from other language designers, the question is only if the Rust community wants to.",0.025000000000000005,Rust
13usqwq,jm3gnyd,"> My criticism is not that this stuff isn't checked, but that `safe` Rust is lazily defined, not as things that can be done safely, but as things that the authors think should be deemed safe.",0.3125,Rust
13usqwq,jm3gnyd,"> If this means a systems language, for example, in Go you would receive an error.",0.0,Go
13usqwq,jm3gnyd,"Go has a GC, I don't even consider it for this discussion.",0.0,Go
13usqwq,jm3gnyd,"--  So, do I have to take this as ""I don't want what Rust wants to be, a GC-less safe language with optional access to unsafe low level details""?",0.2333333333333333,Rust
13usqwq,jm3i2ym,"Go, for example, does this.",0.0,Go
13usqwq,jm3i2ym,"It's not like Rust doesn't compromise on performance for the sake of safety generally, this shouldn't come to a surprise.",0.05000000000000002,Rust
13usqwq,jm3i2ym,"> Go has a GC, I don't even consider it for this discussion.",0.0,Go
13usqwq,jm3i2ym,"> So, do I have to take this as ""I don't want what Rust wants to be, a GC-less safe language with optional access to unsafe low level details""?",0.2333333333333333,Rust
13usqwq,jm3i2ym,You don't have to take it as anything - it's not like any individual in particular has any power to change Rust.,0.08333333333333333,Rust
13usqwq,jm3i2ym,"And at this point to counter this laziness you would need a new language most likely, Rust is too far gone.",0.18409090909090908,Rust
13usqwq,jm3i2ym,"Those insights you can apply to all languages, not only Rust.",0.0,Rust
13usqwq,jm3p0c1,"Rust was born for writing an efficient, parallel, but memory safe browser, not just as a random language.",0.0,Rust
13usqwq,jm3p0c1,"If I say I want to know how Rust could have been better, I mean with this goal in mind.",0.09375,Rust
13usqwq,jm4x5zc,"here's the thing, Rust's type system ensures that a value's type never changes.",0.0,Rust
13usqwq,jm4x5zc,"Instead of complicating the type system to such an extent (as what you're suggesting isn't just about freshly allocated pointers, at the very least you have to also propagate that additional type info down the line), Rust simply says - if you want to ensure this is always in a valid state, use wrapper types (like Box, which is a wrapper around a pointer).",-0.04911111111111112,Rust
13usqwq,jm4x5zc,"This offloads the burden from the language developers to create safe wrappers for all potential use cases of unions, pointers, C FFI, to the developers, which makes much more sense as the language devs can't possibly cover all such cases (and if you're suggesting ""don't cover all cases, only some"", where do you draw the line?)",0.16666666666666666,C
13usqwq,jm3sw7p,"The goal of Rust is providing safety, which is what my proposal does.",0.0,Rust
13usqwq,jm3sw7p,"> Rust was born for writing an efficient, parallel, but memory safe browser, not just as a random language.",0.0,Rust
13usqwq,jm3sw7p,You reject this because the very notion of this solution insults your perception of Rust and perhaps even your notion of oneself.,0.2,Rust
13usqwq,jm3sw7p,"But realize that Rust is not the only language with lazy design, in fact, I'm sure there is laziness in every language to an extent, so there is no reason to outright defy this so much.",0.1125,Rust
13uh17j,,"I'm pretty firmly convinced that using a more dedicated teaching language is a better approach than having beginners just start with Python/JavaScript/other language goes here and I'm not really here to discuss that, so I'm not really interested in comments like ""Just use Python because x, y, and z.""",0.1375,Python
13uh17j,jm2gx57,"TypeScript) to introduce various type concepts gradually - **Mutability**: Immutable by default, but with the possibility for opt-in mutability.",0.0,TypeScript
13uh17j,jm2gx57,"I've seen people learn Python via Jupyter Notebooks and then be completely lost trying to make their own program - **Easy to run**: As a beginner, one of my frustrations was ""I just want to run the code"".",0.37777777777777777,Python
13uh17j,jm2drem,"Something like Scheme, with SICP as an example of how to teach.",0.0,Scheme
13uh17j,jm2drem,"If you grasp SICP, you not only learn Scheme, you learn how to implement it, or how features of programming languages in general are implemented.",0.02500000000000001,Scheme
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,C
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,Python
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,JavaScript
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,C++
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,Java
13uh17j,jm268jg,https://hedycode.com/ is a great example of teaching to program by gradually building up to Python.,0.8,Python
13uh17j,jm268jg,I'd also recommend Elm as a source of inspiration.,0.0,Elm
13uh17j,jm3k9jr,"For beginners I'd probably have a language that requires type signatures on everything (including locals) with the ability to relax the requirement later - I also agree that algebraic data types are great for learning - loops, probably a single keyword for all kinds akin to go - low boilerplate (as somebody mentioned Java is terrible with this - it also requires everything to be in a class which is just silly and pedantic) - comprehensive package management that makes it easy for students to build fun little projects without needing to add to a config file.",-0.0325595238095238,Java
13uh17j,jm3k9jr,"Students don't need to worry about perf, but could get discouraged with long compile times - I agree with another commenter's mentions of immutability by default - ""everything is a pointer"" (a la Java) is also probably quite beneficial to students - it's a difficult concept and one that can be tackled down the line.",-0.2351851851851852,Java
13uh17j,jm7osyn,I've thought about this a bit - I actually think introducing a non-programmer to a pure functional language (like Haskell) *could* be a good idea (though it certainly has its limitations and detractors).,0.28214285714285714,Haskell
13uh17j,jm7osyn,"So, to answer your question, I would take Haskell and simplify it to within an inch of its life, mostly in terms of the type system and syntax.",0.5,Haskell
13uh17j,jm2dwn6,Or is the thread really about how to teach people to code in Rust or other such modern language?,0.06875,Rust
13uh17j,jm2yava,"It's one of the reasons why Python is better than some languages for this purpose, but has its own issues.",0.55,Python
13uh17j,jm2yava,"Pascal has an ecosystem outside its use in academics, so not only can students learn CS with the language, the language and its ecosystem are large enough to accommodate higher levels of skill.",0.09285714285714286,Pascal
13uh17j,jp8y6ii,Having to declare variables in a VAR section that has to be below the CONST section both of which have to be at the top of my function like Pascal will put unnecessary obstacles between learners and the successes that keep them coding.,0.01666666666666666,Pascal
13uh17j,jp8y6ii,You can always move on to C later if you want to teach them how to associate errors where the compiler got confused with the actual error location.,-0.13333333333333333,C
13uh17j,jm3kqpu,And a type checker something like TypeScript's where 90% of the time all you need to annotate is your functions and it can infer the rest.,0.0,TypeScript
13uh17j,jm6oeqp,Somebody on the C subreddit specifically asked about a simple graphics library; one suggestion was GTK3!,0.0,C
13uh17j,jm2raw2,People say it a lot in regards to learning Haskell or something after C (or something).,0.0,Haskell
13uh17j,jm2raw2,People say it a lot in regards to learning Haskell or something after C (or something).,0.0,C
13uh17j,jm81jhp,When I moved on from C++ I had to unlearn loads of accepted wisdom because it turned out to be completely wrong:  * Simula-style OOP sucks.,-0.4,C++
13uh17j,jm81jhp,* C++ isn't conducive of good performance.,0.7,C++
13uh17j,jm81jhp,Basically everything C++ added to C had already been done better before C++ was invented.,0.5,C++
13uh17j,jm81jhp,Basically everything C++ added to C had already been done better before C++ was invented.,0.5,C
13uh17j,jm3lm20,"Where I would argue for recursion over loops stems from my experience in teaching programmers using JavaScript where, once they learn how to think I'm terms of recursion, it's often been easier to move to iteration without losing the intuition for recursion in the process.",0.0,JavaScript
13uai8f,, All I need is a sample how to call a language server written in C that can  be empty like //put your code here.,-0.1,C
13uai8f,jm065nf,I guess you need to choose the IDE client (vs code etc) I’m not sure how the commands are sent (maybe stdin in C and maybe sockets.. no idea where to configure this) There are sample projects but for some reason for me particularly they write a about everything but not about the bits I need so it is very frustrating reading.,-0.20111111111111113,C
13uai8f,jm0f0cm,lets say my server is in C where do I specify the port for instance..these are the parts that are driving me crazy :-/,-0.425,C
13u5ie6,jlzbsm0,"(Since you mention Clang so are using C, if the parameter type uses `const`, it may not be necessary to make a copy, as that stops the callee writing into the struct.)",0.0,C
13u5ie6,jm4d16y,If you want to pass data to or from C you need to get your hands dirty and implement the ABIs.,-0.6,C
13u5ie6,jm4d16y,LLVM by default will just do some simple best effort when you don’t lower according to the C ABI.,0.5,C
13u5ie6,jlzgraa,"Take this example code:      struct S {       int a;       float b;       long c;     };     float f(struct S arg) {       return arg.a + arg.b + arg.c;     }     void test() {       struct S arg;       arg.a = 1;       arg.b = 2.f;       arg.c = 3;       float val = f(arg);     }  My implementation would generate something like this (if, of course, it was made to parse C):      define float @f({ i32, float, i64 } arg) {       %0 = extractvalue { i32, float, i64 } arg, 0       %1 = extractvalue { i32, float, i64 } arg, 1       %2 = sitofp i32 %0 to float       %3 = fadd float %2,  %1       %4 = extractvalue { i32, float, i64 } arg, 2       %5 = sitofp i64 %4 to float       %6 = fadd float %3, %5       ret float %6     }          define void @test() {       %0 = insertvalue { i32, float, i64 } undef i32 1, 0; My initialization is a bit shorter here because of how I initialize structs       %1 = insertvalue { i32, float, i64 } %0, float 2.000000e+00, 1       %2 = insertvalue { i32, float, i64 } %1, i64 3, 2       %3 = call float @f({ i32, float, i64 } %2)     }  But Clang emitted this (data layout, attributes, and metadata are omitted):      %struct.S = type { i32, float, i64 }          ; Function Attrs: noinline nounwind optnone uwtable     define dso\_local float @f(i64 %0, i64 %1) #0 {       %3 = alloca %struct.S, align 8       %4 = getelementptr inbounds { i64, i64 }, ptr %3, i32 0, i32 0       store i64 %0, ptr %4, align 8       %5 = getelementptr inbounds { i64, i64 }, ptr %3, i32 0, i32 1       store i64 %1, ptr %5, align 8       %6 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 0       %7 = load i32, ptr %6, align 8       %8 = sitofp i32 %7 to float       %9 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 1       %10 = load float, ptr %9, align 4       %11 = fadd float %8, %10       %12 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 2       %13 = load i64, ptr %12, align 8       %14 = sitofp i64 %13 to float       %15 = fadd float %11, %14       ret float %15     }          ; Function Attrs: noinline nounwind optnone uwtable     define dso\_local void @test() #0 {       %1 = alloca %struct.S, align 8       %2 = alloca float, align 4       %3 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 0       store i32 1, ptr %3, align 8       %4 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 1       store float 2.000000e+00, ptr %4, align 4       %5 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 2       store i64 3, ptr %5, align 8       %6 = getelementptr inbounds { i64, i64 }, ptr %1, i32 0, i32 0       %7 = load i64, ptr %6, align 8       %8 = getelementptr inbounds { i64, i64 }, ptr %1, i32 0, i32 1       %9 = load i64, ptr %8, align 8       %10 = call float @f(i64 %7, i64 %9)       store float %10, ptr %2, align 4       ret void     }  IIRC, C requires all variables to have addresses, while my language doesn't, but what I don't get is why \`%6\`-\`%9\` in \`test\` are used to load everything out in the form of \`i64\`s, only to reinterpret that again inside \`f\`.",-0.025,C
13u5ie6,jm3dlum,"The C ABI is typically ""just"" the ABI the kernel designed for system calls from user-space: C adopts this ABI on a per platform/per OS basis simply so that those system calls can be modeled directly in C.  So, to some degree, you're asking why Linux system calls on x64 were chosen to pass your struct as two 64-bits registers :)",0.10833333333333334,C
13tjaz7,,"I've re-implemented the ALT interpreter almost 20+ times for the past 1.5 years (Scala mostly), but this time I've implemented it in typescript - so it runs in the browser!",0.1875,Scala
13ta9vj,jlu3la2,"Not exactly tagged pointers, but Swift keeps track of unused bits and bit patterns and tries to use them to store discriminator of the tagged union.",-0.1125,Swift
13ta9vj,jlu3la2,And I think lower bits of the pointer are assumed to be unused (probably only in cases when reference is known to point to pure Swift object).,0.10714285714285714,Swift
13ta9vj,jlvjioz,GHC (Haskell) uses pointer tagging to store constructor tags for algebraic data types as an optimization.,0.0,Haskell
13ta9vj,jlxbkrg,Objective-C runtime makes extensive use of tagged pointers and values.,0.0,Objective-C
13ta9vj,jlygs6z,"Java was a disaster in so many ways that I find it difficult to learn from beyond ""don't do anything remotely like this"".",-0.03333333333333333,Java
13ta9vj,jlz9ecz,This is one of the design goals for Swift for example.,0.0,Swift
13ta9vj,jlz9ecz,"Swift has ""real"" compiled polymorphic generics, where the same compiled code can be applied to different types (via indirection).",0.06666666666666667,Swift
13ta9vj,jlyp7dy,"Because this:      let max m n = if m>=n then m else n  is far less efficient than this:      let max (m:int) n = if m>=n then m else n  Even if you just do this:      let min(m, n) = if m<=n then m else n     let min_int(m, n) = min(m, n)  It compiles `min_int` into a tail call to `min` which is:      _camlTest__min_267:       sub     sp, sp, #32       str     x30, [sp, #24]     L101:       str     x0, [sp, #8]       str     x1, [sp, #0]       adrp    x8, _caml_lessequal@GOTPAGE       ldr     x8, [x8, _caml_lessequal@GOTPAGEOFF]       bl      _caml_c_call     L102:       cmp     x0, #1       b.eq    L100       ldr     x0, [sp, #8]       ldr     x30, [sp, #24]       add     sp, sp, #32       ret     L100:       ldr     x0, [sp, #0]       ldr     x30, [sp, #24]       add     sp, sp, #32       ret  That's virtual calls to generic functions via a C API.",-0.022222222222222216,C
13ta9vj,jlyhd3b,Having tried Lisps and Haskell I must say that the only place I have ever seen arbitrary precision by default work is computer algebra systems.,-0.05,Haskell
13ta9vj,jlzpspe,Ok but Lisp is also grindingly slow.,0.09999999999999998,Lisp
13ta9vj,jlzmlac,> This is one of the design goals for Swift for example.,0.0,Swift
13ta9vj,jlzmlac,"Swift has ""real"" compiled polymorphic generics, where the same compiled code can be applied to different types (via indirection).",0.06666666666666667,Swift
13ta9vj,jlzt6vx,> Ok but Lisp is also grindingly slow.,0.09999999999999998,Lisp
13ta9vj,jlztzjr,> Lisp is also grindingly slow  [That so?,-0.30000000000000004,Lisp
13ta9vj,jm26kv1,"Apple spent considerable amount of engineering resources on implementing this type of generics in Swift, I doubt they would just do it for the fun of it.",0.09999999999999999,Swift
13ta9vj,jm009qp,"> Tracing is a data miss factory;  In Lisp, sure.",0.5,Lisp
13ta9vj,jm2e2ke,"> Apple spent considerable amount of engineering resources on implementing this type of generics in Swift, I doubt they would just do it for the fun of it.",0.09999999999999999,Swift
13ta9vj,jm2e2ke,Swift also uses RC.,0.0,Swift
13ta1b6,jlu5z6o,I'm not aware of any but the languages I know that do this are MMA/WL and Erlang.,-0.125,Erlang
13ta1b6,jlw6qwi,"So if you wanted to expose a DEQUE written in C to a language akin to Python, then your PY\_INCREF and PY\_DECREF could manage things that way, and the interface to memory management would all work out.",0.0,C
13ta1b6,jlw6qwi,"So if you wanted to expose a DEQUE written in C to a language akin to Python, then your PY\_INCREF and PY\_DECREF could manage things that way, and the interface to memory management would all work out.",0.0,Python
13t91mw,,"I'm bored of headers system in C, I want to start an experimental project for compiling C source without the need of forward declarations, and maybe add then support for generics and some runtime safety check as well.",-0.2,C
13t91mw,,"I have got some idea about how to parse C without a symbol table (I don't want to parse with it, since it would make forward declarations necessary again), but I have seen that D compiles this correctly      void main() {         Person* p = new Person(""John"", 30);     }          struct Person {         string name;         int age;     }  How does the compiler do this?",0.101010101010101,C
13t91mw,,"I have got some idea about how to parse C without a symbol table (I don't want to parse with it, since it would make forward declarations necessary again), but I have seen that D compiles this correctly      void main() {         Person* p = new Person(""John"", 30);     }          struct Person {         string name;         int age;     }  How does the compiler do this?",0.101010101010101,D
13t91mw,jluepx0,D uses unlimited lookahead and disallows certain expression statements (which allows `foo * bar;` to unambiguously be parsed as a declaration).,0.21428571428571427,D
13t91mw,jltw7um,IIRC D uses multi-pass compilation.,0.0,D
13t91mw,jltx6iv,But more importantly C's current syntax makes it impossible to parse usages of types before declarations.,-0.055555555555555546,C
13t91mw,jltx6iv,In other words C parsers will parse a statement differently if it starts with an ident which is the same as a previously declared type rather than a function for example.,-0.07291666666666666,C
13t91mw,jlu2kj3,I believe the D parser does multiple passes.,0.0,D
13t91mw,jlu2kj3,"[Heres a talk by Walter on the internals of the D compiler](https://www.youtube.com/watch?v=bNJhtKPugSQ) \- 20 minutes in lists the passes  D is also open source, so you could also [take a look at the code](https://github.com/dlang/dmd/tree/master/src)  Good luck, ✌",0.35,D
13t91mw,jltxmgz,Zig began as a fork of C without the preprocessor and evolved into something quite remarkable.,0.75,C
13t91mw,jlujngw,"I don't know D's syntax, but my language has out-of-order definitions, and there it causes ambiguities in parsing declarations involving user-defined types.",0.0,D
13t91mw,jlujngw,"In examples like the following, out-of-order definations are invaluable:      record R = (int data; ref S link)     record S = (int data; ref R link)  Some languages get tied up in knots doing stuff like this.",-0.5,R
13t91mw,jlu76rr,"Thanks for the answer, I actually know how to parse context-free grammars without a symbol table, but D does not seem to be context-free, it has the same problem with declarations like C (`Person* var;`)  &#x200B;  >If there are ambiguities, you can still parse them into a tree which allows ambiguous forms, and the ambiguities can be resolved in later passes.",0.05,D
13t91mw,jlu76rr,"Thanks for the answer, I actually know how to parse context-free grammars without a symbol table, but D does not seem to be context-free, it has the same problem with declarations like C (`Person* var;`)  &#x200B;  >If there are ambiguities, you can still parse them into a tree which allows ambiguous forms, and the ambiguities can be resolved in later passes.",0.05,C
13t91mw,jlvhtf8,"> Person *var;  C deals with this via the Lexer Hack; the `typedef` must always terminate before any use of the `typedef`’d name (AFAIK—maybe you could use it in VLA dimensions), so you know it’s a typename.",0.0,C
13t91mw,jlvhtf8,"C++ has the same restriction at block, global, and namespace scopes, but not within `struct`s or `class`es.",0.0,C++
13t91mw,jlvhtf8,"Even without templates, it’s quite possible that a C++ class won’t be able to finish/resolve the parse until reaching the end of the `struct`/`class` body:   	struct Foo { 		Foo(const T &) {T *var; var=0; static_cast<void>(var);} 		typedef Foo T; 	};  With C++ templates (which, when environmentally-unlimited, are themselves a fully Turing-Complete sub-language), parsing becomes undecidable.",0.25,C++
13t91mw,jlvhtf8,Aaaaaaaaaaall of this complication results from C’s gahddangfangled declaration syntax and the contortions everything has to undergo in order to maintain it.,0.0,C
13t91mw,jlvhtf8,"It *does* make some sense to be able to do things like `&a := &b` for alias creation, but not using C type/declarator syntax, in either event, ’s fer damn sure, mmhmm.",0.5,C
13t91mw,jlvhtf8,"So the first and easiest thing to do would be *eliminate the cause of the Hack,* translate C code to your internal form at import, and move forward unconstrained.",0.125,C
13t91mw,jlvhtf8,"(You could even do this up properly and create a tool to build yourlanguage-native modules and library assemblies from C libraries/refs thereunto, their headers/refs thereunto, and any accompanying ancillary assets and autogenerators, all as an archive.",0.0,C
13t91mw,jlvhtf8,`:` is only used in C (in some relevant way—not counting e.g.,0.2,C
13t91mw,jlvhtf8,"Labels can do like Java and apply either to `{`braced`}` compound statements (`foo: {}` for the rough equivalent of `foo: (void)0;`) or control statements for use with `continue` and `break`, use a `label` keyword (`foo: label …` or `label(foo) …`; cf.",-0.5333333333333333,Java
13t91mw,jlvhtf8,"For ternary, you can use `if`/`else` as actual operators, rather than as statement markers, do Python’s unpleasant-in-practice `y if x else z` which makes it unclear whether `x` or `y` should be evaluated first, use `if`/`then`/`elif`/`else` as operators (`if x then y else z`), or use matching (switch !",0.15625,Python
13t91mw,jlvhtf8,"You can even depart from the C type system and come up with structural sum/product/union/intersection types that can be converted to/from structs and unions with or without discriminants—e.g., `S >< T` or `struct(S, T)` →roughly the effects of  	// Given 	typedef __typeof(sizeof 0) __Size; 	#define __MKREF(quals, T)typedef struct {\ 		__typename(T) quals *ptr;\ 	} T##Ref 	typedef struct {unsigned len; char c[];} __CStr; 	__MKREF(__const, __CStr); 	typedef struct __Type__STAG__ __Type; 	__MKREF(__const, __Type); 	typedrf struct __Attrs__STAG __Attrs; 	__MKREG(__const, __Attrs); 	enum __types_FldVariety { 		__types_TUPLE_ELEM, __types_UNION_ELEM, 		__types_ISECT_ELEM, __typed_SUM_ELEM, 		__types_STRUCT_FIELD, __types_UNION_FIELD, 		__types_LOCAL_VAR, __types_MODULE_VAR, 		__types_LIB_VAR, __types_PRIV_VAR, 		__types_LOCAL_LABEL, __types_ENUM 	}; 	struct __types_FldInf { 		union { 			__umax uvalue; 			__imax ivalue; 			__bfrmax bfrvalue; 			const void *pvalue; 			struct {__Size offset, align, size;}; 		}; 		__CStrRef name; 		__TypeRef type; __AttrsRef attrs; 		enum __types_FldVariety variety; 	}; 	#define __CStrRef_NIL … 	#define __AttrsRef_NIL … 	#define __TypeRef_FOR(...)… 	…  	#ifndef __product___S___T 	typedef struct { 		S __product_fld_0; 		T __product_fld_1; 	} __product___S___T; 	inline const struct __types_FldInf __product___S___T__FIELDS[2] = { 		{ 			.offset=offsetof(__product___S___T,__product_fld_0), 			.align=alignof(S), .size=sizeof(S), 			.name=__CStrRef_NIL, 			.type=__TypeRef_FOR(S), 			.attrs=__AttrsRef_NIL, 			.variety=__types_TUPLE_ELEM 		}, { 			.offset=offsetof(__product___S___T, __product_fld_1), .align=alignof(T), .size=sizeof(T), 			.name=__CStrRef_NIL, .type=__TypeRef_FOR(T), .attrs=__AttrsRef_NIL, 			.variety=__types_TUPLE_ELEM 		} 	}; 	#define __product___S___T __typename(__product___S___T) 	#endif  (which could easily be exported in a simpler table form and autogenned from that, even staying within C/++ using xmacros or xincludes), and `S -|- T` or `union(S, T)` as  	#//etc.",0.43333333333333335,C
13t91mw,jlubmby,"C has clear keywords to tell you whether something is an enum, struct, typedef etc, to allow you to parse unambiguously.",0.10000000000000002,C
13t91mw,jluc53n,"The zig compiler also compiles C and you can mix and match as required (as far as I can recall) - so yeah, there's that.",0.1,C
13t91mw,jlubcdj,**C to Python Example.,0.0,C
13t91mw,jlubcdj,**C to Python Example.,0.0,Python
13t91mw,jlubcdj,**  C:      int C = 5;  Python:     C = 5  **Are your source P.L.,0.0,C
13t91mw,jlubcdj,**  C:      int C = 5;  Python:     C = 5  **Are your source P.L.,0.0,Python
13t8usy,jlvy2o0,"C++ meanwhile just keeps invalid references in the lexical scope after a move, but nullifies them.",0.0,C++
13t8usy,jltzu4k,"It's implemented in Rust, and I use the im-crate, which provides immutable data structures.",0.0,Rust
13t8usy,jltzu4k,"So if a structure is shared, and the original is dropped, the Rust persistent data structure takes care of that under the hood.",0.375,Rust
13t8usy,jltzu4k,"There are basically two layers of memory management: the one I program, and the one that is provided by the immutable data structures in Rust.",0.0,Rust
13syh3m,jlsixt9,"For example in Rust there is crated named ""syn"" that can parse rust code and represent it in a data struct, so you can also generate this struct as your transpiler output and then deserialize into plain rust code.",-0.21428571428571427,Rust
13syh3m,jlsr58u,There are a couple C to Rust transpilers that you can look at for an example.,0.0,C
13syh3m,jlsr58u,There are a couple C to Rust transpilers that you can look at for an example.,0.0,Rust
13syh3m,jlt2xb9,"When not generating binary output files, I've used textual output as C source files, ASM source files, and IL source codes, all formats that were then processed by separate tools.",0.0,C
13syh3m,jlt2xb9,"The C version was the most challenging since the output is structured, and nested (unless you are generating very low level C - not recommended).",0.3333333333333333,C
13syh3m,jot0bj5,They are often used in web development to convert modern code written in languages like TypeScript or ES6 into backward-compatible versions that can run on older versions.,0.18333333333333335,TypeScript
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Swift
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Kotlin
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Objective-C
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Java
13syh3m,jltx508,"I like to compare an old ""Pascal vs C"" comparison about string manipulation.",0.1,Pascal
13syh3m,jltx508,"I like to compare an old ""Pascal vs C"" comparison about string manipulation.",0.1,C
13syh3m,jlsvod4,I thought about transpiling to JavaScript through TypeScript's compiler.,0.0,JavaScript
13syh3m,jlsvod4,I thought about transpiling to JavaScript through TypeScript's compiler.,0.0,TypeScript
13syh3m,jlsvod4,"TypeScript's compiler is available as [an API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API), so the idea is to inject a compliant AST and have it do its magic.",0.45,TypeScript
13syh3m,jlso0r2,"If I were to translate my AST into Lua syntax, for example, how would it actually write that Lua?",0.0,Lua
13syh3m,jlsptvv,Are you trying to transpile to a Lua program that would be as close as possible to something a person would write?,0.0,Lua
13syh3m,jlsptvv,You could recursively traverse the AST with each node outputting a string that is the Lua code semantically equivalent to what the AST node represents.,0.0,Lua
13syh3m,jlsptvv,"However, if you are trying to transpile to a highly optimized subset of Lua, the code generation may be more akin to emitting a low-level language.",0.33,Lua
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,TypeScript
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,JavaScript
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,C++
13syh3m,jlt1n33,Here are some examples of transpilers which output Lua:   https://github.com/rochus-keller/Oberon/blob/master/ObLuaGen2.cpp  https://github.com/rochus-keller/Som/blob/master/SomLuaTranspiler.cpp,0.0,Lua
13syh3m,jltgz3s,[(Computerphile videos)](https://www.youtube.com/@Computerphile/search?query=parser)  JavaScript or Python have a buildt-in function that transforms a string into a dictionary.,0.0,JavaScript
13syh3m,jltgz3s,[(Computerphile videos)](https://www.youtube.com/@Computerphile/search?query=parser)  JavaScript or Python have a buildt-in function that transforms a string into a dictionary.,0.0,Python
13syh3m,jlzj32y,:D,1.0,D
13syh3m,jlss16m,"Lua was just an example, but yeah, that's kind of what I want.",0.6,Lua
13syfpk,,"I've been wondering how languages call functions from their host language, like Lua and C#.",0.0,Lua
13syfpk,,"I've been wondering how languages call functions from their host language, like Lua and C#.",0.0,C
13syfpk,,"I know Lua has a Metatable, and C# needs bindings/metadata, I think, but I'm not sure where it goes beyond that.",-0.25,Lua
13syfpk,,"I know Lua has a Metatable, and C# needs bindings/metadata, I think, but I'm not sure where it goes beyond that.",-0.25,C
13syfpk,jlsn93y,"When Lua calls a C function, it passes a pointer to the interpreter's stack to the C function, the C function has to manually pop off the parameters from the interpreter's stack, and if it returns something to the interpreter the C function pushes it back on the stack.",0.0,Lua
13syfpk,jlsn93y,"When Lua calls a C function, it passes a pointer to the interpreter's stack to the C function, the C function has to manually pop off the parameters from the interpreter's stack, and if it returns something to the interpreter the C function pushes it back on the stack.",0.0,C
13syfpk,jlsrdqp,"When C code calls into Lua, a value representing a lua function is pushed to the lua stack, along with it's arguments, then a lua c api function is called that pops the lua function and some number of arguments off of the stack and calls the given function with that number of arguments.",0.0,C
13syfpk,jlsrdqp,"When C code calls into Lua, a value representing a lua function is pushed to the lua stack, along with it's arguments, then a lua c api function is called that pops the lua function and some number of arguments off of the stack and calls the given function with that number of arguments.",0.0,Lua
13syfpk,jltmthm,Here's a practical example with a naive hypothethical Lua interpreter written in Python.,-0.3,Lua
13syfpk,jltmthm,Here's a practical example with a naive hypothethical Lua interpreter written in Python.,-0.3,Python
13syfpk,jltmthm,"# Lua     function inc (n)         return n + 1     end     a = 5     ---     b = inc(n)     print(b)  To keep track of the local scope, the host will probably have something like a map from names to values.",0.0,Lua
13syfpk,jltmthm,"At the `---` point, that map looks like this:      # Python     scope = {         ""inc"": LuaFunction(name=""inc"", args=[""n""], fn=<function ...>),         ""a"": LuaInteger(5),     }  The Lua statement `b = inc(n)` is then equivalent to      # Python     scope[""b""] = scope[""inc""].fn(scope[""a""])  in the host language.",0.0,Python
13syfpk,jltmthm,"At the `---` point, that map looks like this:      # Python     scope = {         ""inc"": LuaFunction(name=""inc"", args=[""n""], fn=<function ...>),         ""a"": LuaInteger(5),     }  The Lua statement `b = inc(n)` is then equivalent to      # Python     scope[""b""] = scope[""inc""].fn(scope[""a""])  in the host language.",0.0,Lua
13syfpk,jltmthm,"Now to answer your question, if you want the ""print"" function in Lua to invoke the host's ""print"", you just need to format it in a way that's compatible with the example call above, and inject it into the `scope` map.",0.0,Lua
13syfpk,jltmthm,"In this case, wrap it in a `LuaFunction` object:      # Python     host_print = lambda value_to_print: print(""From Lua:"", value_to_print.to_pystring())     scope[""print""] = LuaFunction(name=""print"", args=[""value_to_print""], fn=host_print)  Now when Lua does       # Lua     print(b)  it's executed as      # Python     scope[""print""].fn(scope[""b""].to_string())  Which is equivalent to calling Python's ""print"" like so:      # Python     print(""From Lua:"", LuaInteger(6).to_string())  You can also do it the other way around, calling Lua from Python.",-0.125,Python
13syfpk,jltmthm,"In this case, wrap it in a `LuaFunction` object:      # Python     host_print = lambda value_to_print: print(""From Lua:"", value_to_print.to_pystring())     scope[""print""] = LuaFunction(name=""print"", args=[""value_to_print""], fn=host_print)  Now when Lua does       # Lua     print(b)  it's executed as      # Python     scope[""print""].fn(scope[""b""].to_string())  Which is equivalent to calling Python's ""print"" like so:      # Python     print(""From Lua:"", LuaInteger(6).to_string())  You can also do it the other way around, calling Lua from Python.",-0.125,Lua
13syfpk,jltmthm,"After the Lua code has finished executing:      # Python     b = scope[""inc""].fn(LuaInteger(5))     print(b.to_pyint())  and you've called a Lua function from Python.",0.0,Lua
13syfpk,jltmthm,"After the Lua code has finished executing:      # Python     b = scope[""inc""].fn(LuaInteger(5))     print(b.to_pyint())  and you've called a Lua function from Python.",0.0,Python
13syfpk,jltmthm,"- Designing your VM to work with host primitives (pure `int` instead of `LuaInteger(int)`) - Injecting variables into the local scope works well (Python's `print` is itself implemented like that), but allows the guest to mess around with it in counterproductive ways (`print = exit; print(0)` is perfectly valid Python).",0.2598214285714286,Python
13syfpk,jltmthm,"I consider this a plus to prevent confusion and improve security, but if you want maximally flexible guests, you can:  - Inject all builtins (`scope.update(locals())` puts all Python's local names in the scope map).",0.0,Python
13syfpk,jlslmri,The Lua interpreter is a C program.,0.0,Lua
13syfpk,jlslmri,The Lua interpreter is a C program.,0.0,C
13syfpk,jlslmri,"If you download [the source](https://www.lua.org/download.html) and unpack it, you'll find a `src/` directory which contains the C code that does the [lexing](https://en.wikipedia.org/wiki/Lexical_analysis) and [parsing](https://en.wikipedia.org/wiki/Parsing) of Lua code, which eventually results in calling code elsewhere in the codebase (e.g.",0.0,C
13syfpk,jlslmri,"If you download [the source](https://www.lua.org/download.html) and unpack it, you'll find a `src/` directory which contains the C code that does the [lexing](https://en.wikipedia.org/wiki/Lexical_analysis) and [parsing](https://en.wikipedia.org/wiki/Parsing) of Lua code, which eventually results in calling code elsewhere in the codebase (e.g.",0.0,Lua
13syfpk,jlslmri,"In terms of the situation where Lua is embedded in a larger program, details about how it works in that context can be found in [this section of the Lua reference manual](https://www.lua.org/manual/5.4/manual.html#4).",0.0,Lua
13syfpk,jlslmri,"However, Lua doesn't have to be embedded in a larger program; it can also be run [standalone](https://www.lua.org/manual/5.4/manual.html#7).",0.0,Lua
13syfpk,jlslmri,"For example, the [Prosody XMPP chat server](https://en.wikipedia.org/wiki/Prosody_(software)) is written in Lua.",0.0,Lua
13syfpk,jlslmri,"Finally, and more generally, programming languages often have a '[foreign function interface](https://en.wikipedia.org/wiki/Foreign_function_interface)' (FFI) allowing a language to call functionality of another language (often C).",0.10625000000000001,C
13syfpk,jltg7d3,"I recently wrote a scripting language, and the way this worked for that is the host language (Java) had to tell the scripting system which static methods it wanted the scripts to be able to call, but could call instance methods freely.",0.35,Java
13syfpk,jltmtwi,"C has a standardized ABI, or a way to call a function from other machine code independently of the language.",-0.0625,C
13syfpk,jltmtwi,It's how you can just call C functions in python without any issues in the REPL.,0.0,C
13syfpk,jltmtwi,"C# goes a bit further by having a lot of compatibility with C. You can still use pointers, including function pointers, to call C functions.",0.0,C
13syfpk,jltmtwi,You can also declare a function as `extern` and then call that native function from normal C# code as if it were written in C#.,0.15,C
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,C
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,Java
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,C++
13syfpk,jlwvdhf,Though if your host language is C++ you *could* just write horrifying undebuggable templates instead.,-0.9,C++
13syfpk,jluspse,"A long time ago, I had a little C program/library that worked with a bunch of different languages, both calling into the languages and being called by the languages.",-0.07916666666666666,C
13syfpk,jluspse,"In the end, there's two problems: - Given the name of a function in the scripting language, how can you call the right C function?",0.2857142857142857,C
13syfpk,jluspse,"- How can you pass the right ""stuff"" so the C function works correctly and doesn't get horked?",0.2857142857142857,C
13syfpk,jluspse,A simple way is that the C program will pass a dictionary that maps strings that are the function names to function pointers.,0.0,C
13syfpk,jluspse,"If the C program has a ""shared library"" or ""DLL"" interface, the OS will have some functions that can paw through  the library and return a dictionary that maps strings to function pointers.",0.0,C
13syfpk,jluspse,"Of all the languages, Erlang had a ton of documentation saying how hard it was to do this, but it was actually easy.",0.07083333333333333,Erlang
13syfpk,jluspse,"And Perl had a ton of documentation saying how easy it was, but it was actually impossible in the general case (because Perl could work differently depending on what compiler you used to compile Perl, but that wasn't specified by anyone).",-0.045833333333333316,Perl
13syfpk,jlucpj1,"No, C has no standard ABI.",0.0,C
13syfpk,jlucpj1,"When a specific C compiler  exposes some function name in the the .OBJ or .o files that it's making, it will often use the common calling convention for whatever system it's on.",-0.15,C
13syfpk,jlucpj1,"On the old VAX/VMS system, for example, there was a detailed spec for how all languages were supposed to surface functions and also for listing the functions that were going to be called; the DEC C compiler followed those conventions so that it was (mostly) easy to for a program to be composed of modules written in multiple languages.",0.23333333333333334,C
13syfpk,jluhfx0,But there is a standard ABI across C programs compiled for the same platform - even if it isn't necessarily coupled to the C language - and other languages make use of that.,-0.03125,C
13syfpk,jluqt2c,"An older version of the same thing was old Mac applications, where the common calling convension for C wasn't compatible with the ""pascal"" calling convention used by the OS.",-0.008333333333333331,C
13shh4m,,"I've toyed around with compilers for a while, one (successful) lisp-like to asm, and one (less successful) C to asm; but never anything quite as complex as citrus.",0.25833333333333336,C
13shh4m,jlq4fl2,"It's a little overwhelming, but you can take a look at Rust's [internal documentation](https://rustc-dev-guide.rust-lang.org/mir/index.html).",0.10416666666666667,Rust
13shh4m,jlq4fl2,"Depending on your language semantics, you may want to look at other compilers for inspiration, such as OCaml or Haskell.",-0.0625,Haskell
13shh4m,jlq5h09,"I looked at old books for this, and I'm currently going through this book: Retargetable C Compiler, A: Design and Implementation https://a.co/d/awDr2B8  It's an old book but it's actually one of the better instruction books I've found.",0.13999999999999999,C
13shh4m,jlq5h09,It walks you on the design of an ANSI C compiler called lcc.,0.0,C
13shh4m,jlq5h09,Only downside is that some of the source is written K&R style.,0.0,R
13shh4m,jlq2yt2,"Even if you don't use C++, LLVM has bindings to most languages, so everything should still be similar.",0.25,C++
13s3f9c,jloddn1,"(I think I used something like `DPRINTF` in C, which either passed on its args to `printf`, or was an empty macro, but printing anything in C was a pig anyway.)",-0.1,C
13s3f9c,jloycur,"Julia does something similar to this; only expressions not terminated by a semicolon return a value, and only statements that return a value get printed at the REPL.",0.0,Julia
13rztfp,,This would allow creation of lazy lists that appear in functional languages like Haskell.,-0.25,Haskell
13rztfp,jlnj0gj,Dart does this.,0.0,Dart
13rztfp,jlnj0gj,"Dart also has `late` as a modifier for variable declarations, which does more or less what you describe here.",0.011111111111111118,Dart
13rztfp,jlnj0gj,"(In Dart, we check this at runtime and throw an exception if a cyclic initialization is encountered.)",0.0,Dart
13rztfp,jlnj0gj,"### Async/await  Dart, like several other languages, also has async/await.",-0.0625,Dart
13rztfp,jlnj0gj,The answer for Dart is that it doesn't: You simply can't use await inside the initializer for a late variable.,-0.15,Dart
13rztfp,jlnj0gj,We don't have that in Dart and in practice it means that sometimes you end up having to use nullable non-lazy variables and implement the lazy initialization yourself.,-0.25,Dart
13rztfp,jlo3dux,"Kotlin sort of provides this, though not as a first-class language feature.",0.0,Kotlin
13rztfp,jlo3dux,"But `by` instead invokes a Kotlin language feature called [""property delegation""](https://kotlinlang.org/docs/delegated-properties.html).",0.0,Kotlin
13rztfp,jlo3dux,I think Kotlin's approach is quite nice.,0.6,Kotlin
13rztfp,jlpzztq,"Scala has `lazy val` and ""by name"" parameters.",-0.25,Scala
13rztfp,jlolvvl,"Here is how you could do it in Java      class Lazy<A> {         // Supplier<A> is a function that takes no arguments and returns an A         private Supplier<A> thunk;         private A result;              public Lazy(Supplier<A> thunk){             this.thunk = thunk;             this.result = null;         }         public A force() {             // This means the thunk has already been forced             if (thunk == null) {                 return this.result;             } else {                 let result = thunk();                 // remove the thunk to allow it to be garbage collected                 thunk = null;                 this.result = result;                 return result;             }         }     }  Now, it might still make sense to add `lazy` expressions to the language, because allocating a closure might be more expensive than computing the result and with an expression, the compiler can make the decision to do either (if the computation is pure).",-0.03730158730158731,Java
13rztfp,jlqjjwd,Kotlin supports this but as a subset of a much more powerful operator called `by`.,0.4,Kotlin
13rztfp,jlnks8t,>Recursive references  The standard answer in a language like Haskell is that your program simply doesn't halt.,0.0,Haskell
13rztfp,jlo5rhu,"Yeah, I think this is heavily inspired by C#.",-0.2,C
13rztfp,jlo5rhu,"In the case of C#, you often want to write code that's still fairly fast for a JITed language, and explicitly seeing what's going on is a part of that.",0.2,C
13rztfp,jlqaxm5,D has a `lazy` keyword that is _only_ for function parameters and is essentially just syntax sugar for wrapping the value in a lambda as per usual.,-0.125,D
13rztfp,jlo9ub0,"To be fair, what you describe handles the `lazy { ... }` part of the Kotlin code.",0.22499999999999998,Kotlin
13rztfp,jlo9ub0,"That would be more like:      class Wrapper {         private var fooImpl = new Lazy<int>(() => 42);                  public int Foo => fooImpl.Value     }  (There might be a better way to do that now, but my C# experience is fairly old at this point.)",0.20606060606060606,C
13rztfp,jlo9ub0,"With C#, you'd use `foo.Value`.",0.0,C
13rztfp,jlo9ub0,"In Kotlin, if you just use `lazy { ... }`, you'd then use `foo.value`.",-0.25,Kotlin
13rztfp,jlot3y2,"The type isn't inferred because as far as I remember, C# only infers generic type parameters in method calls, not in constructors.",0.03333333333333333,C
13rztfp,jlqkn8l,D's system instead requires requires functions types to be augmented with some lazyness feature.,0.0,D
13rztfp,jlognnc,To my knowledge that's still the state of the art in C#.,0.0,C
13rztfp,jlpoigu,"I'd rather have the option to use lazies (even ""hidden lazies"" using Kotlin property delegation) than to be prevented from using them at all.",-0.16666666666666666,Kotlin
13rztfp,jlprj08,"And C# now has Roslyn Analyzers: basically compiler plugins that you can write as simple C# code, in parallel packages (""projects"" in a ""solution"") and that just run and do work at compile time.",0.0,C
13rnxrk,jlmscga,"If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Haskell
13rnxrk,jlmscga,"If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Rust
13rnxrk,jlmmu3g,Pass 2 is name resolution which must be done first (this also depends on language; in C you only need one pass).,0.125,C
13rnxrk,jlnurwv,"Actually Python does that for me, but ... ISTR making it explicit by calling `string.intern(...)`.",0.0,Python
13rnxrk,jlpmes8,"This arrangement works for something like C, where you can only reference stuff above.",0.0,C
13rnxrk,jlpk67r,>I would be very surprised if there wasn't some black magic that let you do this in TypeScript.,0.15444444444444447,TypeScript
13rnxrk,jlpk67r,But I still needed your explanation & the TypeScript explanation above to level me up in understanding enough to code it.,0.0,TypeScript
13rnxrk,jltk9ut,"> If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Haskell
13rnxrk,jltk9ut,"> If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Rust
13rnxrk,jltk9ut,"FWIW, if you're using Rust or OCaml I recommend just decorating the tree externally using a separate hash table.",0.0,Rust
13rjs77,jlqbck8,:D,1.0,D
13rij54,jlkgzpe,I encourage you to look at *raw string literals* in C# 11.,-0.23076923076923078,C
13rij54,jlmdy39,Two are heredoc syntaxes      <<-SQL     SELECT * FROM food     WHERE healthy = true     SQL  And indent saving version      page = <<-HTML        Heredocs are cool & useful     HTML  You also have the %Q and %q formats these do or do not allow interpolation and let you choose the delimiterer for example %Q{..} or %Q/../ or whatever.,0.375,HTML
13rij54,jlkk8vs,"C# raw strings look cool, this is indeed a very similar idea.",0.039743589743589734,C
13rij54,jlkk8vs,":      `dedent         This is a text         across multiple         lines, which will         NOT have indentation space before each line     `  EDIT: see also [this comment](https://www.reddit.com/r/ProgrammingLanguages/comments/13rij54/multistrings_a_simple_syntax_for_heredocstyle/jlkpuun/) showing how to achieve the exact behavior of C# with a multistring which uses ' instead of linebreaks as separators.",0.125,C
13rij54,jlkk8vs,JavaScript has a similar feature known as [tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).,0.0,JavaScript
13rij54,jlki85v,"Yep, Rust's seems like a good implementation of the basic feature.",0.35,Rust
13rij54,jlki85v,Rust's syntax could be easily extended to support that.,0.43333333333333335,Rust
13rij54,jlki85v,"A similar thing can also be achieved with combining raw strings with other language features (as long as such are available, which is true for Rust).",0.049175824175824175,Rust
13rij54,jllkn76,;D,0.25,D
13rij54,jlklp7u,"C#:      indented4 =          """"""             {                 ""Name"": ""Zaphod""             }         """""";          nonindented =          """"""         {             ""Name"": ""Zaphod""         }         """""";  Here indented4 will have this value (indented 4 spaces):          {             ""Name"": ""Zaphod""         }   And nonindented:      {         ""Name"": ""Zaphod""     }",-0.75,C
13rij54,jlkotne,"***      `    |       {           ""Name"": ""Zaphod""       }     `  (a bit wacky, but short)      `dedent+         |             {                 ""Name"": ""Zaphod""             }     `  (the first line is discarded in the output; the position of `|` there dictates where to stop dedenting, effectively acting as the closing delimiter in C#)      `dedent++         |   {         |       ""Name"": ""Zaphod""         |   }     `  discard everything in every line up to and including `|` (must be space) -- I think Scala does something similar.",0.15,C
13rij54,jlkotne,"***      `    |       {           ""Name"": ""Zaphod""       }     `  (a bit wacky, but short)      `dedent+         |             {                 ""Name"": ""Zaphod""             }     `  (the first line is discarded in the output; the position of `|` there dictates where to stop dedenting, effectively acting as the closing delimiter in C#)      `dedent++         |   {         |       ""Name"": ""Zaphod""         |   }     `  discard everything in every line up to and including `|` (must be space) -- I think Scala does something similar.",0.15,Scala
13rij54,jlkotne,"In the end, you could choose to implement a variant which would work exactly like C#, allowing the closing delimiter to be indented.",0.25,C
13rij54,jlktfup,I'm sure C++ brings much excitement with its implementation.,0.35,C++
13rij54,jlkpuun,"So you could implement the `dedent` tag to work exactly like in C#, perhaps getting the best of both worlds.",0.625,C
13rij54,jlks874,":D), just to inspire people like you and start a discussion.",1.0,D
13rhbhd,,"I've written a lot of C, and I won't deny that it does come up to bite you, I still don't understand the hatred.",0.0,C
13rhbhd,,No one complains if a C function returns -1.,0.0,C
13rhbhd,,This is normal behavior when invalid inputs are given to a language that doesn't have advanced error handling like Rust.,0.275,Rust
13rhbhd,,"However, seeing people discuss them you'd think anyone who doesn't use Rust is a caveman for allowing NULL pointers to exist in their programming languages.",0.0,Rust
13rhbhd,,"As if this post wasn't controversial enough, I'm going to assert something else even more controversial: The level Rust goes to in order to prevent NULL pointers is ridiculously over the top for the majority of cases that NULL pointers are encountered.",0.29444444444444445,Rust
13rhbhd,jlk7xv6,With pointers in C the problem is you never know if the pointer returned by a function may be zero or not.,0.0,C
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,Python
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,C
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,Java
13rhbhd,jlki7kh,"In the type system of, say, C, there is no difference between a valid pointer pointing to an integer, and the invalid NULL pointer.",0.0,C
13rhbhd,jlki7kh,"Objective-C treats all nulls like ""empty"" values of their type, so a null interpreted as a number is zero, accessing a field of a null object returns another null, etc.",-0.1,Objective-C
13rhbhd,jlk9htg,I really don't see how Rust's avoidance of null pointers is over the top.,0.35,Rust
13rhbhd,jlk9htg,"I wouldn't even say Rust avoids it, it just doesn't fit into the language design given that it has Option.",0.4,Rust
13rhbhd,jlk9htg,"In C you can practically toss `(void*) 0` into anything, and in Java you can also set any type to `null`.",0.25,C
13rhbhd,jlk9htg,"In C you can practically toss `(void*) 0` into anything, and in Java you can also set any type to `null`.",0.25,Java
13rhbhd,jlk9htg,"Languages that make that distinguishment are a lot easier to reason about (whether that's in the language itself like Kotlin, or in the library like Rust).",0.0,Kotlin
13rhbhd,jlk9htg,"Languages that make that distinguishment are a lot easier to reason about (whether that's in the language itself like Kotlin, or in the library like Rust).",0.0,Rust
13rhbhd,jlk9htg,There's also the security issue that they bring alongside languages like C which is honestly enough to warrant avoiding them.,0.0,C
13rhbhd,jlkszdn,Kotlin has nulls and its type system makes it perfectly safe (and convenient) to use them whenever you need them to represent the absence of value.,0.24375,Kotlin
13rhbhd,jlkak57,"Also, I don't think having null in a language like C that has basically no seatbelts around raw pointers anyway and where only pointers can be null is much of an issue.",-0.010256410256410256,C
13rhbhd,jlkak57,"In C, returning NULL is not much worse than returning -1.",0.2,C
13rhbhd,jlkak57,It's just that most languages besides C don't use garbage values except null to indicate errors.,0.5,C
13rhbhd,jlkak57,">The level Rust goes to in order to prevent NULL pointers is ridiculously over the top for the majority of cases that NULL pointers are encountered  This is a strange argument IMO, because Rust *doesn't* do much to prevent null pointers.",0.07916666666666668,Rust
13rhbhd,jlkak57,"Rust doesn't *prevent* null, it just doesn't introduce null because there is no reason to do so if you have a generic, ergonomic `Option` type.",0.0,Rust
13rhbhd,jlkak57,Raw pointers in Rust [can absolutely be null](https://doc.rust-lang.org/std/ptr/fn.null.html).,-0.015384615384615385,Rust
13rhbhd,jlkak57,">outside of that it seems the level of hatred is extreme, and many things are blamed on NULL pointers that actually are flaws with language semantics rather than the NULL pointers themselves  In C, I agree (see above), but in high level languages, or languages with even slightly more expressive type systems, null values are absolutely an inherent flaw since they add an invalid garbage value to every single type",0.2181746031746032,C
13rhbhd,jlkf3r8,> No one complains if a C function returns -1.,0.0,C
13rhbhd,jlkyqjw,"I'm not a low level programmer, and it's probably different when you don't have Rust semantics and still want to do very controlled low level code, but the whole point of having a type system is that you *can* guarantee stuff about your code.",0.08,Rust
13rhbhd,jlkyqjw,"It's hard to make it readable with C syntax and no ability to compose functions (like a pipe operator), and we should create languages that do their best to be readable without a debugger.",0.35416666666666663,C
13rhbhd,jlkyqjw,"Rust does a pretty good job at this, ML languages do a great job at this, but C does a terrible job.",0.1875,Rust
13rhbhd,jlkyqjw,"Rust does a pretty good job at this, ML languages do a great job at this, but C does a terrible job.",0.1875,C
13rhbhd,jlkyqjw,C++ is the worst case scenario.,-1.0,C++
13rhbhd,jlkguud,Java).,0.0,Java
13rhbhd,jlk8j80,Rather than languages like ML and Rust which often times tell you what to do to fix things with types.,0.0,Rust
13rhbhd,jlkuvl0,"Because everyone's favourite language now is either Rust, or something of its ilk.",0.0,Rust
13rhbhd,jlw3r0s,"So, Java is a great leap forward in the specific sense that null-pointer has a defined behavior which is unlikely to lead to escalated privileges.",0.10000000000000002,Java
13rhbhd,jlm6o3t,"'no'; ```  Rust option without using `?`:  ``` let a = foo.map(|f| f.a).unwrap_or(""no""); ```",0.0,Rust
13rhbhd,jlk7a76,Not every language can or should be Rust that checks your inputs every step of the way.,0.0,Rust
13rhbhd,jllt9ja,> Kotlin has nulls and its type system makes it perfectly safe  Doesn't that mean its not `null` by definition?,0.09375,Kotlin
13rhbhd,jlkbu2x,"People write off C as a language simply because it cannot express optional types, when I’m saying that reaction is over the top for most cases.",0.3333333333333333,C
13rhbhd,jlkbu2x,"C is probably the worst example to illustrate my point, since the consequences are the most severe in C.   However, despite the responses I’m receiving, most languages do not have good methods of expressing errors.",0.175,C
13rhbhd,jlkbu2x,"Actually, only Rust is capable of not doing either of those things as far as I’m aware.",0.1375,Rust
13rhbhd,jlkbu2x,"However, there’s a reason 99% of all code ever written was not in Rust.",0.0,Rust
13rhbhd,jllsevc,> > No one complains if a C function returns -1.,0.0,C
13rhbhd,jllsevc,"C# is a much higher-level language than C. What do you think of [`System.String.IndexOf` returning `-1` for ""not found""](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-7.0) instead of `null` or a nullable or option type?",0.2,C
13rhbhd,jlkqddd,"Rust, Haskell and OCaml, a type like `Int` *only* contains valid integers.",0.0,Rust
13rhbhd,jlkqddd,"Rust, Haskell and OCaml, a type like `Int` *only* contains valid integers.",0.0,Haskell
13rhbhd,jlkl07t,"For example, a string in Java can be the empty string (`""""`), but it can also be `null`.",-0.1,Java
13rhbhd,jlkl07t,"For example, in Java, I can have a value of type `User` that may or may not be null.",0.0,Java
13rhbhd,jlkl07t,"In Rust, there's no built-in null, but there is the library type `Option` which can represent a value that may or may not be present.",0.0,Rust
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,Kotlin
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,Rust
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,Haskell
13rhbhd,jlmjao4,"They've been around in familiar forms for ~50 years or so dating back to Pascal and ML (possibly earlier, I don't know).",0.125,Pascal
13rhbhd,jlmecjs,"Languages such as Ada have improved upon this with the use of ranges; a day of the week can be precisely represented as `1..7`, rather than as a `u8`.",0.2,Ada
13rhbhd,jlk8eh8,"Python has exceptions as the default mechanism for error handling, and choosing to return an empty string instead of throwing an exception is a bad design decision in most cases.",-0.09999999999999994,Python
13rhbhd,jlkmq2d,"Null is just a value in Python like any other one, and you can definitely accidentally get a `None` where you were expecting a `str`, but you can also get an `int` or a `User`, or a whatever else in the same place.",-0.041666666666666664,Python
13rhbhd,jlkmq2d,"Python, by default, has no typing system, so nulls aren't worse than any other value!",-0.278125,Python
13rhbhd,jlkbyjp,Not in languages such as Haskell and Rust.,0.0,Haskell
13rhbhd,jlkbyjp,Not in languages such as Haskell and Rust.,0.0,Rust
13rhbhd,jlkbyjp,"Even in C# and others, it is very much possible to create types that cannot be constructed in a safe manner to have invalid values.",0.25,C
13rhbhd,jlkbyjp,"Haskell lets you define list type that does not have an empty constructor, in (safe) Rust a string containing other than valid UTF-8 is impossible (and in unsafe Rust it is UB), and so on.",-0.09791666666666665,Haskell
13rhbhd,jlkbyjp,"Haskell lets you define list type that does not have an empty constructor, in (safe) Rust a string containing other than valid UTF-8 is impossible (and in unsafe Rust it is UB), and so on.",-0.09791666666666665,Rust
13rhbhd,jllzf83,"Kotlin has `null`, it's just that the language will not let you dereference a `null` value.",0.0,Kotlin
13rhbhd,jlkoqxn,">People write off C as a language simply because it cannot express optional types, when I’m saying that reaction is over the top for most cases  While it is probably not the worst thing C does, I don't think this perception is over the top.",0.1,C
13rhbhd,jlkoqxn,"Sure, C could use something other than optional, but the way C uses garbage values for failure is pretty awful.",-0.13833333333333334,C
13rhbhd,jlkoqxn,"What C calls ""error handling"" really falls into two categories: Errors and nonexistence.",0.2,C
13rhbhd,jlkoqxn,"There is an argument to be made for *checked* exceptions that need to be handled at some point (Rust uses `Result`), but most languages have an answer to this.",0.5,Rust
13rhbhd,jlkoqxn,"Many languages still throw an exception since they expect the programmer to check if the map contains the value first, but the correct behavior is arguably to return an `Option` or something similar (like an explcitly nullable type in Kotlin).",0.25,Kotlin
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Java
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Scala
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Rust
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Haskell
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Elm
13rhbhd,jlkoqxn,Kotlin and C# have explicit opt-in nullable types.,0.0,Kotlin
13rhbhd,jlkoqxn,Kotlin and C# have explicit opt-in nullable types.,0.0,C
13rhbhd,jlkoqxn,Previous versions of C# used to use `out` parameters.,-0.16666666666666666,C
13rhbhd,jlkoqxn,"Go arguably does the wrong thing with it's `if err != null` checks, but I don't think anyone in this sub considers go's behavior well designed.",-0.625,Go
13rhbhd,jlkoqxn,">However, there’s a reason 99% of all code ever written was not in Rust.",0.0,Rust
13rhbhd,jlkoqxn,"Because 99% of the time, that level of safety is not mission critical  Rust is not much safer than most statically typed high-level languages.",0.13333333333333333,Rust
13rhbhd,jlkoqxn,"If performance and predictability are not mission critical, you don't need to use Rust, althought that doesn't mean that using Rust is a bad choice in that case.",-0.3374999999999999,Rust
13rhbhd,jlmck17,"There's several things about C headers that make them bad:  - C has only one namespace, so anything included from a header is dumped into that namespace; people still create namespaces, but they have only nominal support.",-0.17499999999999996,C
13rhbhd,jlmck17,"- The C preprocessor operates in a strictly linear manner, making separate and parallel compilation difficult and introducing unexpected dependencies between files.",-0.13333333333333333,C
13rhbhd,jlmck17,This is why so much focus is put on making C and C++ parsers fast.,0.2,C
13rhbhd,jlmck17,This is why so much focus is put on making C and C++ parsers fast.,0.2,C++
13rhbhd,jlk95ku,"I mean like in Python, where error checking is not a default or enforced practice.",-0.3125,Python
13rhbhd,jlp9j5v,> There's several things about C headers that make them bad:  Right.,-0.13809523809523805,C
13rhbhd,jlp9j5v,"> C has only one namespace, so anything included from a header is dumped into that namespace; people still create namespaces, but they have only nominal support.",0.0,C
13rhbhd,jlp9j5v,"> The C preprocessor operates in a strictly linear manner, making separate and parallel compilation difficult and introducing unexpected dependencies between files.",-0.13333333333333333,C
13rhbhd,jlp9j5v,This is why so much focus is put on making C and C++ parsers fast.,0.2,C
13rhbhd,jlp9j5v,This is why so much focus is put on making C and C++ parsers fast.,0.2,C++
13rhbhd,jlmiznx,"Yes, even C has them now (as `_BitInt(N)`).",0.0,C
13rhbhd,jlkafoo,"I'd encourage you to read [PHP: A Fractal of Bad Design](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/), not necessarily because you need to know about why PHP is bad but because, to make it clear how PHP violates them, it argues very forcefully for some pretty basic principles of _good design_.",-0.01874999999999996,PHP
13rhbhd,jlkafoo,Here's an excerpt that's relevant:  > Parts of PHP are practically designed to produce buggy code.,0.45,PHP
13rhbhd,jlkafoo,"> In C, functions like strpos return -1 if the item isn’t found.",0.0,C
13rhbhd,jlkafoo,"> > In, say, Python, the equivalent .index methods will raise an exception if the item isn’t found.",0.0,Python
13rhbhd,jlkafoo,"> > In PHP, these functions return false.",-0.4000000000000001,PHP
13rhbhd,jlkafoo,"If you use FALSE as an index, or do much of anything with it except compare with ===, PHP will silently convert it to 0 for you.",-0.0666666666666667,PHP
13rhbhd,jlkafoo,"Here, PHP has actively created a subtle trap for me to fall into, and I have to be vigilant even with such mundane things as string operations and equality comparison.",-0.15833333333333333,PHP
13rhbhd,jlkafoo,PHP is a minefield.,0.0,PHP
13rhbhd,jlkbdgd,"_BUT_, because Java has nullability on _every_ non-primitive type, you totally _can_ write:      ValidatedString foo = null;  And now there's no way for any downstream functions to enforce at compile time that the input to a function _cannot_ be`null`.",0.0,Java
13rhbhd,jlkbdgd,Put another way: I'm going to give you some Java method signatures.,0.0,Java
13rhbhd,jlkbdgd,"For some further reading, I recommend looking into why `Optional<T>` is one of the big candidates for Java's Project Valhalla, which will allow you to define custom non-nullable value types.",0.0,Java
13rhbhd,jlpc7vd,"I'm not a C programmer, so for me and any other first time user they seem to only offer confusion and nothing else.",0.041666666666666664,C
13rhbhd,jlpc7vd,But since I've only dabbled in C I'll ask this with an open mind- what trade offs are there?,0.0,C
13rhbhd,jlpx7bw,I'm thinking beyond C but I'd say some advantages are:  * Clear machine-verified API.,0.10000000000000002,C
13rhbhd,jll9srd,"Some languages like TypeScript or modern C# still have null, but only for types that have explicitly been marked as nullable.",0.10000000000000002,TypeScript
13rhbhd,jll9srd,"Some languages like TypeScript or modern C# still have null, but only for types that have explicitly been marked as nullable.",0.10000000000000002,C
13rhbhd,jlq0oml,"Just my two cents here, but in my experience using languages where order matters (basically just Python), it only ever feels like it gets in my way when I'm trying to make a clean API, but as I said earlier I'm not really sure what header files have to do with that.",0.029166666666666674,Python
13rhbhd,jlqa1vc,"> Just my two cents here, but in my experience using languages where order matters (basically just Python), it only ever feels like it gets in my way when I'm trying to make a clean API, but as I said earlier I'm not really sure what header files have to do with that.",0.029166666666666674,Python
13rhbhd,jlkiop1,"You're the one who brought up programmers who have to work with legacy languages; but this subreddit isn't about that, and we can say ""C sucks"" without concern.",-0.3,C
13qqp2t,,I made a translator that converts C to my esolang (with entirely different logic structure).,0.0,C
13qqp2t,,"How is that different from say, a translator that converts C in english to C in german.",0.0,C
13qqp2t,jlgd5ff,"In software-land, examples are [Flow](https://flow.org/) which is a language whose creators refuse to call it that, and all the C dialects (GNU C, Objective-C, nesC, NQC, NXC, ...) which will depend on who you ask.",0.0,C
13qqp2t,jlgd5ff,"In software-land, examples are [Flow](https://flow.org/) which is a language whose creators refuse to call it that, and all the C dialects (GNU C, Objective-C, nesC, NQC, NXC, ...) which will depend on who you ask.",0.0,Objective-C
13qqp2t,jlgd5ff,"Then we call languages in the Lisp family ""Lisp dialects,"" for no particular technical reason.",-0.041666666666666664,Lisp
13qqp2t,jlgd5ff,"That's also how you can run Java Bytecode on .Net and vice-versa ([XMLVM](http://www.xmlvm.org/overview/), [IKVM.NET](https://en.m.wikipedia.org/wiki/IKVM.NET)).",0.0,Java
13qqp2t,jlgrbop,The underlying language is equivalent to C.,0.0,C
13qqp2t,jlgf6pr,translating call/cc from Scheme to Clojure.),0.0,Scheme
13qqp2t,jlgf6pr,translating call/cc from Scheme to Clojure.),0.0,Clojure
13qqp2t,jlg9utv,"There is no actual answer, you could, for example, grab C and just add a feature from OOP and call it ""C with classes"" (true story).",0.175,C
13qqp2t,jlgu2sz,"C to your esolang might be, depending on what your lang can do.",0.0,C
13qqp2t,jlhd81r,"Assembly is the ""narrow waist"" of how we instruct computers to do things.",-0.2,Assembly
13qqp2t,jlhd81r,Assembly isn't perfect since obviously there are a handful of different instruction sets for various manufacturers,0.25,Assembly
13qqp2t,jljftyg,"If you write a program in C, it's going to look very different than a program in Haskell as a result of its features, is there immutability by default?",0.0,C
13qqp2t,jljftyg,"If you write a program in C, it's going to look very different than a program in Haskell as a result of its features, is there immutability by default?",0.0,Haskell
13qqp2t,jljftyg,"Sure, you could translate a program from C to Haskell or vice versa, but it's gonna look horrible if you exactly do in one language what you do with the other.",-0.09375,C
13qqp2t,jljftyg,"Sure, you could translate a program from C to Haskell or vice versa, but it's gonna look horrible if you exactly do in one language what you do with the other.",-0.09375,Haskell
13qqp2t,jljftyg,"There's also the fact that Haskell needs a runtime to actually execute the code, so the C translation will effectively have to reimplement the Haskell runtime to be equivalent.",0.3,Haskell
13qqp2t,jljftyg,"There's also the fact that Haskell needs a runtime to actually execute the code, so the C translation will effectively have to reimplement the Haskell runtime to be equivalent.",0.3,C
13qqp2t,jlk5a7b,"If your lang is just C with different keywords, it has the same semantics as C and is considered C-like (or ALGOL-like more broadly), but that doesn't preclude it from being an esolang.",0.140625,C
13qqp2t,jljgfy2,"It's a derivative of Haskell, but it's a new language.",0.13636363636363635,Haskell
13qqp2t,jlgm29p,And where does Prolog fit?,0.4,Prolog
13qqp2t,jlgm29p,Forth?,0.0,Forth
13qqp2t,jlh64sg,All of those can be collapsed under Lisp ;),0.25,Lisp
13qqp2t,jljhm4t,"Python 2 Python, despite it being a different formal language than Python 3.",0.0,Python
13qqp2t,jlj58qk,"(2) The abstract semantics of Haskell don't specify a way to do I/O, nor is it precluded.",0.0,Haskell
13qqp2t,jlj58qk,"One could easily imagine a runtime for Haskell which printed every string in the program as soon as it was created in much the same way that one can graft I/O machinery onto the _implementation_ of any abstract machine, including a Turing machine.",0.2111111111111111,Haskell
13qqp2t,jljrt1v,"If language A supports self-modification and language B doesn't, then there will be no straightforward translation of A -> B, even when passing through another language C (eg.",-0.1875,C
13qqp2t,jlib57j,It sounds like you're describing [reader macros](https://lisper.in/reader-macros) :D,1.0,D
13qm38j,,again 2 lifetimes involved  Rust has some examples that can be used: [https://doc.rust-lang.org/rust-by-example/scope/lifetime.html](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).,-0.75,Rust
13q76pm,jle6tsk,"(I would also be peeved if it had turned out to be Forth, combinatory logic, a universal Turing machine, or the lambda calculus.)",0.0,Forth
13q76pm,jlno7vz,"Crenshaw was 100% hand-rolled recursive-descent, but he was aiming at a much-simplified Pascal.",0.0,Pascal
13q76pm,jlsmsgr,"Like most people on this subreddit, I *couldn't* create my own programming language by following OP's instructions because my own programming language isn't a dialect of Lisp.",0.42500000000000004,Lisp
13q76pm,jlsmsgr,Java).,0.0,Java
13q76pm,jlhiomk,"As it is, this looks like just another Lisp.",0.0,Lisp
13q76pm,jlhuclg,"> As it is, this looks like just another Lisp.",0.0,Lisp
13q76pm,jlhuclg,"And C++ looks like just another C — at least, at the outset.",-0.3,C++
13q76pm,jlhuclg,"And C++ looks like just another C — at least, at the outset.",-0.3,C
13q76pm,jlhuclg,"Nobody who knows what they're talking about looks at Rust code and says ""Ah yes, the critical essence of Rust is that its syntax is mostly C-like but with more noise.""",0.3333333333333333,Rust
13pzzah,jlcuu2n,"So are D and C# if you count [`in`](https://dlang.org/spec/function.html#in-params) as the default, instead of the actual default.",0.0,D
13pzzah,jlcuu2n,"So are D and C# if you count [`in`](https://dlang.org/spec/function.html#in-params) as the default, instead of the actual default.",0.0,C
13pzzah,jlcuu2n,"Rust is another [precedent](https://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=46f628468f8d2db9728f221417ed570f), but from another angle: when you move a value into a function, nobody can observe mutations, so a compiler is free to pass-by-reference all moved objects.",0.4,Rust
13psmjy,jlcqjg5,Common for functional or C like impl languages.,-0.3,C
13psmjy,jlcqjg5,"And you can't hide the token allocations into the parser nodes - it might then be better to batch lex rather than a streaming lexer that an LL benefits from * C style lists to build the tree enables keeping the list in the parser node allocation too  Kind regards,  M ✌",0.55,C
13psmjy,jlcihts,I can only give a C++ answer.,0.0,C++
13psmjy,jlcihts,Do you want a C++ answer?,0.0,C++
13psmjy,jlcihts,For example on my machine Go does around 85K and that is thought to be 'fast',0.2,Go
13psmjy,jlbmih8,It may even be impossible to make efficient depending on comparability constraints (see the design of Python and the poor syntax decisions with C++).,-0.5333333333333333,Python
13psmjy,jlbmih8,It may even be impossible to make efficient depending on comparability constraints (see the design of Python and the poor syntax decisions with C++).,-0.5333333333333333,C++
13pi1ox,,"So I've been steadily working on my language Vortex, and even though most of the work has gone into updating the internal interpreter code to make it run a little smoother, there are some interesting developments that I'd like to share:  **More Libraries:**  Vortex offers C interoperability out of the box and I've been building the language out using dynamic libraries.",0.19739583333333333,C
13pd2ho,,"* passable language intrinsic functions and/or standard library - string operations, sorting, hash map, basic statistics (sum, product, avg, var, std) * able to generate standalone binaries (not requiring interpreter at runtime)  Basically Fortran if it was invented in 2014 instead of 1954.",0.16666666666666666,Fortran
13pd2ho,jl91azx,"Well Rust is the most popular modern language with a huge ecosystem that is like that, but it also requires you to learn a more modern approach than ""newer Fortran"".",0.4000000000000001,Rust
13pd2ho,jl91azx,"Well Rust is the most popular modern language with a huge ecosystem that is like that, but it also requires you to learn a more modern approach than ""newer Fortran"".",0.4000000000000001,Fortran
13pd2ho,jl9151d,Ada can do all of those things.,0.0,Ada
13pd2ho,jl9151d,"The GNAT compiler is a gcc frontend, so is just as fast as C if you turn off bounds checking and avoid certain constructs.",0.20714285714285713,C
13pd2ho,jl9c6dc,"C++ itself checks all of these boxes, so is there something else you're looking for?",0.0,C++
13pd2ho,jlaq6gu,"Check out [D](https://dlang.org/), in particular since you mention metaprogramming.",0.16666666666666666,D
13pd2ho,jlaq6gu,"Here's operator overloading in D:      struct C     {         int x;         C opBinary(string op)(in C obj) const         {             mixin(""return C(x "", op, "" obj.x);"");         }                  unittest         {             const a = C(21);             const b = C(2);             const c = a * b;             assert(c.x == 42);         }     }  Here's more funky code:      static foreach(T; AliasSeq!",0.5625,D
13pd2ho,jlaq6gu,"Here's operator overloading in D:      struct C     {         int x;         C opBinary(string op)(in C obj) const         {             mixin(""return C(x "", op, "" obj.x);"");         }                  unittest         {             const a = C(21);             const b = C(2);             const c = a * b;             assert(c.x == 42);         }     }  Here's more funky code:      static foreach(T; AliasSeq!",0.5625,C
13pd2ho,jlaq6gu,"It also has both LLVM and GCC frontends, checking the ""as fast as C"" part.",0.2,C
13pd2ho,jlaq6gu,"In fact there's an entire subset of the language called D As Better C, where runtime features (GC, RTTI, exceptions) are disabled and you keep everything else.",0.09999999999999999,D
13pd2ho,jlaq6gu,"In fact there's an entire subset of the language called D As Better C, where runtime features (GC, RTTI, exceptions) are disabled and you keep everything else.",0.09999999999999999,C
13pd2ho,jlcu8hf,Crystal?,0.0,Crystal
13pd2ho,jl9szyr,Do a front-end for C++ code instead.,0.0,C++
13pd2ho,jl9szyr,"That is, transpile your ideal language into C++ source code.",0.9,C++
13pd2ho,jl9szyr,"Or maybe, since you don't seem bothered about syntax, just use C++ directly.",0.1,C++
13pd2ho,jl9szyr,"A solution in C++ would be clunky, but that language is clunky anyway.",0.0,C++
13pd2ho,jlblp7v,Fortran?,0.0,Fortran
13pd2ho,jlafkx9,Since no one has mentioned it yet...Julia.,0.0,Julia
13pd2ho,jl9tvpy,C is bad for generics.,-0.6999999999999998,C
13pd2ho,jl9tvpy,"I mean, it pulls in the C runtime.",-0.3125,C
13pd2ho,jl9tvpy,> Basically Fortran if it was invented in 2014 instead of 1954.,0.0,Fortran
13pd2ho,jlsh3an,"It has an F#, C, and a Python backend.",0.0,C
13pd2ho,jlsh3an,"It has an F#, C, and a Python backend.",0.0,Python
13pd2ho,jl91s1c,"Zig is quite intriguing to me, as is Rust.",0.30000000000000004,Rust
13pd2ho,jl91s1c,The biggest downside I was seeing to Rust is that OpenMP/MPI support is... Not?,0.0,Rust
13pd2ho,jl91s1c,"Is Rust not an imperative, procedural language?",0.0,Rust
13pd2ho,jl9249l,"I know Ada has massively fallen out of favor, even with its creator, which is somewhat surprising if it has the listed features... Am I the only one that thinks these things would be highly desirable, or do you have any good info on why it is not used so much anymore?",0.29333333333333333,Ada
13pd2ho,jl9249l,"EDIT: This thread is ancient, but covers some of the benefits/questions I had about Ada [https://www.reddit.com/r/programming/comments/b39vd/ask\_reddit\_realworld\_c\_vs\_ada\_experiences/](https://www.reddit.com/r/programming/comments/b39vd/ask_reddit_realworld_c_vs_ada_experiences/) Sounds pretty cool tbh.",0.3,Ada
13pd2ho,jl98k91,"Well Flang, or new-flang, or whatever they want to call it - the new, not production ready, Fortran compiler for LLVM requires special compiler flags to even generate an executable.",0.23116883116883116,Fortran
13pd2ho,jl98k91,The issue is really that the standard committee governing Fortran seems to have no interest in adding features to the language that would actually improve it.,0.06666666666666667,Fortran
13pd2ho,jl98k91,They won’t fix that or add an actual ‘do parallel.’ Basically the governing body running Fortran is happy to do nothing but maintain legacy codes that are replaced by C++ more and more every year.,0.36,Fortran
13pd2ho,jl98k91,They won’t fix that or add an actual ‘do parallel.’ Basically the governing body running Fortran is happy to do nothing but maintain legacy codes that are replaced by C++ more and more every year.,0.36,C++
13pd2ho,jlsk1y1,"To follow up here, I took a look at Crystal and implemented my test code incremental prime sieve.",0.0,Crystal
13pd2ho,jlsk1y1,"For nearly the same algorithm (couldn’t figure out how to jump out of nested loops) I can generate 100-1000ish primes as quickly as Fortran (gfortran, ifort, ifx, and AOCC flang), but some inefficiency catches up for 1M-10Mish type values, and Crystal goes from 50% to 100% longer runtime.",0.14444444444444446,Fortran
13pd2ho,jlsk1y1,"For nearly the same algorithm (couldn’t figure out how to jump out of nested loops) I can generate 100-1000ish primes as quickly as Fortran (gfortran, ifort, ifx, and AOCC flang), but some inefficiency catches up for 1M-10Mish type values, and Crystal goes from 50% to 100% longer runtime.",0.14444444444444446,Crystal
13pd2ho,jlsk1y1,"Overall it seems like a pretty cool language, I just think a lot of languages try to claim “we’re as fast as C” by writing some test case in the best way possible for their new language, which so happens to correspond to a rather slow way to do things in the victim language.",0.1734848484848485,C
13pd2ho,jlsk1y1,"This happens a lot when people want to rag on Python for example, so they do some compiled language and loop a bunch, copy paste that to python and say they’re 10000% faster.",0.0,Python
13pd2ho,jlbm6y6,> Do a front-end for C++ code instead  Fortran has better array handling than C++ so maybe write a front-end for Fortran?,0.5,C++
13pd2ho,jlbm6y6,> Do a front-end for C++ code instead  Fortran has better array handling than C++ so maybe write a front-end for Fortran?,0.5,Fortran
13pd2ho,jl9tbkk,"A solution in C++ would be clunky, but that language is clunky anyway.",0.0,C++
13pd2ho,jl9tbkk,"C++ is a pig and just another 40 year old, bloated kitchen sink language.",0.1,C++
13pd2ho,jlaumgs,"It would be somewhat insulting to describe Julia as ""Fortran invented in 2014"", but FWIW I think their user base is trying to solve the same kinds of problems ie writing heavy numerical code.",-0.5,Julia
13pd2ho,jlaumgs,"It would be somewhat insulting to describe Julia as ""Fortran invented in 2014"", but FWIW I think their user base is trying to solve the same kinds of problems ie writing heavy numerical code.",-0.5,Fortran
13pd2ho,jlad3db,"Rust has all the features you mentioned (i.e ADTs, pattern matching, closures....) and still uses LLVM.",0.0,Rust
13pd2ho,jlad3db,I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,C
13pd2ho,jl93r24,"As for it being more modern, calling Rust imperative and procedural is right but falls a bit short.",0.2464285714285714,Rust
13pd2ho,jl93r24,"And there are plenty of functional idioms that are usually favored when writing idiomatic Rust over C-style flow control structures + state mutation, although it's far from being what's popularly known as a ""proper"" functional language.",0.375,Rust
13pd2ho,jl93r24,"I'd describe it as something between ""what C++ would be if designed from scratch with decades of pain as learning material"" and ""systems OCaml"".",0.0,C++
13pd2ho,jl93lno,"Early Ada compilers were expensive and often buggy, which tainted people's perception of the language.",-0.2,Ada
13pd2ho,jl93lno,"Combined with a few high profile project failures and the dominance of UNIX and C, Ada lost traction.",-0.020000000000000004,C
13pd2ho,jl93lno,"Combined with a few high profile project failures and the dominance of UNIX and C, Ada lost traction.",-0.020000000000000004,Ada
13pd2ho,jl93lno,Modern Ada is a different story.,0.1,Ada
13pd2ho,jl93lno,"Ada's certainly got some historical baggage, but it's worth a try if you're looking for a language with an emphasis on safety and maintainability.",0.1714285714285714,Ada
13pd2ho,jl9byfe,It is easy to learn for anyone who knows an ALGOL family language.,0.43333333333333335,ALGOL
13pd2ho,jl9byfe,"The rules about pointer scoping/usage are very restrictive in order to avoid dangling pointers and take some getting used to, but you don't need to use pointers nearly as often as in C since you have in/out parameters and the ability to return variable-sized arrays/objects by value from functions.",0.15000000000000002,C
13pd2ho,jl94dt4,"Ada was designed by committee *and it showed, good and hard*.",0.20416666666666664,Ada
13pd2ho,jl94dt4,"Oh, and the particular vision of object-orientation espoused by then-current Ada was totally unlike the hot, sexy C++ that was making waves in industry at the time.",0.22916666666666666,Ada
13pd2ho,jl94dt4,"Oh, and the particular vision of object-orientation espoused by then-current Ada was totally unlike the hot, sexy C++ that was making waves in industry at the time.",0.22916666666666666,C++
13pd2ho,jlt22f1,"But yea they shouldn't say things like ""fast as C"" that's dumb.",-0.0875,C
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,C
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,C++
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,JavaScript
13pd2ho,jl9zar1,"If its syntax is not an obstacle, you might look at Python, especially its Numpy add-on.",0.0,Python
13pd2ho,jl9zar1,"Python itself is dead slow, but Numpy AIUI does its array processing using fast native code libraries.",-0.09999999999999999,Python
13pd2ho,jlb11ac,I think the creators of Julia would not hate that comparison.,0.4,Julia
13pd2ho,jlb11ac,And indeed some old Fortran codebases for numerical modelling are being rewritten in Julia for easier maintenance/development,0.1,Fortran
13pd2ho,jlb11ac,And indeed some old Fortran codebases for numerical modelling are being rewritten in Julia for easier maintenance/development,0.1,Julia
13pd2ho,jlb17g9,"> Rust has all the features you mentioned (i.e ADTs, pattern matching, closures....) and still uses LLVM.",0.0,Rust
13pd2ho,jlb17g9,> I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,C
13pd2ho,jlb17g9,"I also beat C on hailstones (Collatz), Sieve of Eratosthenes, ray tracer and Ackermann.",0.0,C
13pd2ho,jl9484m,Really I am searching for something more powerful than what I can do in Fortran but not the absolute hell that is C++.,0.3,Fortran
13pd2ho,jl9484m,Really I am searching for something more powerful than what I can do in Fortran but not the absolute hell that is C++.,0.3,C++
13pd2ho,jl9484m,"Thanks for responding, I will have to give Rust a go.",0.2,Rust
13pd2ho,jlauwee,"Bear in mind I'm saying this as a long term Python fan, but I probably still wouldn't make a new whitespace sensitive language.",0.06212121212121211,Python
13pd2ho,jltw0hp,"this jumps to the next iteration of the outer NUM_CHECKER loop                     end if                 end do prime_checker                 prime_ii = prime_ii + 1                 primes(prime_ii) = num                 unprimes(prime_ii) = num             end do num_checker         else if (n.eq.1) then             primes = 2         end if     end subroutine incremental_sieve ```   In Crystal, I implemented this as: ``` def incremental_sieve(n : Int32)     primes = Array(Int32).new(n)     primes.push(2)     primes.push(3)     unprimes = Array(Int32).new(n)     unprimes.push(2)     unprimes.push(3)     prime_ii = 2     num = 3     while prime_ii < n         num = num + 2         limit = Math.sqrt(num).to_i         is_prime = true         checking_primes = true         i = 1         while checking_primes             if primes[i] > limit                 checking_primes = false             else                 while unprimes[i] < num                     unprimes[i] = unprimes[i] + primes[i]                 end                 if unprimes[i] == num                     is_prime = false                     checking_primes = false                 end                 i = i + 1             end         end         if is_prime             prime_ii = prime_ii + 1             primes.push(num)             unprimes.push(num)         end     end     return primes end ```  I needed the is_prime value since I didn't see a way to jump from the inner loop `while checking_primes` to the next iteration of my main loop `while prime_ii < n`.",-0.03703703703703706,Crystal
13pd2ho,jrqgw72,  > > I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,C
13pd2ho,jrqgw72,"I also beat C on hailstones (Collatz), Sieve of Eratosthenes, ray tracer and Ackermann.",0.0,C
13pd2ho,jt8nj02,Recursive calls could use a different ABI but C compilers tend to push all calls through the ABI even when it is really inefficient.,0.1,C
13pd2ho,jlvtwor,"In Fortran you can name the different loops, and your basic loop control \`exit\` and \`cycle\` (for \`break\` and \`next\`) can be applied to a named loop outside the currently executing one if so desired.",0.0,Fortran
13pd2ho,jlvtwor,"In C or Fortran, you can also accomplish this behavior with \`goto\`.",0.0,C
13pd2ho,jlvtwor,"In C or Fortran, you can also accomplish this behavior with \`goto\`.",0.0,Fortran
13pd2ho,jlefwyo,Go see how Algol was created to see design by committee.,0.0,Go
13p3hbq,jl7kql3,"One interesting strategy is available in Prolog, which is a dynamically typed language: In Prolog, you can *ask* the system whether certain cases can arise *at all*, by posting *queries* on the toplevel, to which the Prolog system will respond in the form of *answers*.",0.37142857142857144,Prolog
13p3hbq,jl7kql3,"This is a bit similar to what other languages (also functional languages, and also statically typed functional languages such as Haskell) call a ""REPL"", a *read-eval-print-loop*.",-0.041666666666666664,Haskell
13p3hbq,jl7kql3,"However, in Prolog, the ability to post queries goes far beyond the ""eval"" of functional languages, because in Prolog, you can *generalize* parts of the query by using logic variables instead of concrete values.",0.125,Prolog
13p3hbq,jl7kql3,""", and the Prolog systems answers ""No"", then you can rely on *all* more specific queries to also fail.",0.0,Prolog
13p3hbq,jl7kql3,"This reasoning works as long as you program in the pure core of Prolog, where such logical reasoning is admissible.",0.10357142857142856,Prolog
13p3hbq,jl7kql3,"For illustration, here is an example: Suppose we have defined a Prolog predicate called `length/2`, which is supposed to relate a list to its length.",0.0,Prolog
13p3hbq,jl7kql3,The ability to express such extremely general test cases is a major attraction of logic programming languages like Prolog.,0.037500000000000006,Prolog
13p3hbq,jl7j1xv,"For example, both Ruby and JavaScript have very strong community-driven linters that report errors without running the program.",0.5633333333333334,Ruby
13p3hbq,jl7j1xv,"For example, both Ruby and JavaScript have very strong community-driven linters that report errors without running the program.",0.5633333333333334,JavaScript
13p3hbq,jl7uy8v,"Python, are currently spending a lot of effort adding on various type systems.)",0.0,Python
13p3hbq,jl8e5xp,This has been my experience with Common Lisp.,-0.3,Lisp
13p3hbq,jlqy6rt,Erlang has exhaustive pattern matching and guards on functions.,0.0,Erlang
13p3hbq,jl8mfeg,"Additionally, Erlang has a very resilient runtime failure recovery system, which helps when errors _do_ slip through.",-0.05833333333333335,Erlang
13p3hbq,jl7xesc,See Python and Erlang's dialyzer for some examples.,0.0,Python
13p3hbq,jl7xesc,See Python and Erlang's dialyzer for some examples.,0.0,Erlang
13p3hbq,jl9ple7,```  if we were to extend the JS syntax to have Enums like in Rust ``` const (Some x) = Option.Some(20) // weird pseudo syntax ```  The fault with JS is if say XYs is not iterable it'll throw an error but it doesn't throw when XYs doesn't contain 2 elements.,-0.5,Rust
13p3hbq,jl860qo,"It's not quite ""dynamic typing"" *dynamic typing*, but you can look into what Python (and others, like TypeScript) does: gradual typing!",0.0,Python
13p3hbq,jl860qo,"It's not quite ""dynamic typing"" *dynamic typing*, but you can look into what Python (and others, like TypeScript) does: gradual typing!",0.0,TypeScript
13p3hbq,jl860qo,The reason why languages like Python and TypeScript offer gradual typing is because they have to maintain backwards-compatibility with software written without types.,0.0,Python
13p3hbq,jl860qo,The reason why languages like Python and TypeScript offer gradual typing is because they have to maintain backwards-compatibility with software written without types.,0.0,TypeScript
13p3hbq,jl8iqk6,"Just out of curiosity, I've transliterated your Prolog queries into Idris 1 (a dependently-typed language) REPL inputs to see how it fares and apart from the verbosity, it works just as well (in this specific scenario):      Idris> the (length ['a', 'b', 'c'] = 3) Refl     Refl : 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = 3) (\_, _, _, _ => Refl)     \underscore, underscore, underscore, underscore => Refl : (a : Type) -> a -> a -> a -> 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = _) (\_, _, _, _ => Refl)     ... 11 lines omitted ...         3 = ([__])  For clarification, `Idris> ` is the prompt prefix and if an expression of the form `the (… = …) Refl` comes back without a type error (and it doesn't contain any holes), then the proposition `… = …` is true.",-0.10833333333333334,Prolog
13p3hbq,jl7ub22,"TypeScript, because the abstractions leak and they're not really designed by people who understand type systems.",-0.1,TypeScript
13p3hbq,jma9mgb,Similarly Elixir which runs on the same BEAM VM as Erlang.,0.0,Elixir
13p3hbq,jma9mgb,Similarly Elixir which runs on the same BEAM VM as Erlang.,0.0,Erlang
13p3hbq,jl9hft9,"I have worked a fair bit in Erlang, and yes, immutability is great, but it mainly makes sure you can read code and won't make certain dumb mistakes.",0.3343253968253969,Erlang
13p3hbq,jl9hft9,"Erlang also has a type system now (sort of), so even if the virtual machine is dynamically typed, you can still run static analysis on the code analysing types.",0.5,Erlang
13p3hbq,jl9hft9,"Look up Erlang Dialyzer, it's a great tool.",0.8,Erlang
13p3hbq,jl8345x,"The folks behind TypeScript understand type systems very well, thank you.",-0.1,TypeScript
13p3hbq,jl8345x,"Whether those tradeoffs amount to something shitty or not is subjective, but for the most part I honestly really like it...I know Haskell, Ocaml, Coq, Idris, etc.",0.35,Haskell
13p3hbq,jl8345x,perfectly well but TypeScript is my go-to for productivity work.,1.0,TypeScript
13p3hbq,jla4m8i,"I'm certainly not saying that there isn't metaprogramming in Haskell and Rust, but it is decidedly second-class, and it is not used in the same way.",-0.05357142857142857,Haskell
13p3hbq,jla4m8i,"I'm certainly not saying that there isn't metaprogramming in Haskell and Rust, but it is decidedly second-class, and it is not used in the same way.",-0.05357142857142857,Rust
13p3hbq,jla4m8i,TH and proc macros in Rust are labor saving devices.,0.0,Rust
13p3hbq,jla4m8i,"In Ruby and CommonLisp, metaprogramming is a primary modeling tool.",0.4,Ruby
13p3hbq,jl8l0pd,"> I know Haskell, Ocaml, Coq, Idris, etc.",0.0,Haskell
13p3hbq,jl8l0pd,perfectly well but TypeScript is my go-to for productivity work.,1.0,TypeScript
13p3hbq,jl8l0pd,"The language I find most productive is actually Scala but that's mostly due to the extensive collections library, which lets you express many algorithms as high-level compositions of collection primitives.",0.175,Scala
13p3hbq,jl7l59u,"I was asking in general, but a common dynamic language I like to use is Scheme.",-0.08333333333333333,Scheme
13p3hbq,jl958a9,"There's various other ways, too, where Ocaml's rigidity makes it less pleasant than TypeScript with its extreme flexibility.",0.06333333333333332,TypeScript
13p3hbq,jl958a9,"Also, don't underestimate how powerful TypeScript can be in capable hands (namely Giulio Canti's).",0.25,TypeScript
13p2x9h,,"Of course, this isn't Haskell's monadic do syntax, but as we all know, applicatives are as good as monads.",0.7,Haskell
13p2x9h,jl9vkk2,Why does Haskell add do syntax for >>== chains?,0.0,Haskell
13p2x9h,jl9vkk2,Haskell would work fine without too.,0.4166666666666667,Haskell
13p2x9h,jl9vkk2,"In Haskell, in Ocaml, or other functional languages.",-0.125,Haskell
13p2x9h,jl9wk22,def f = (|> ((+) 1) |> ((*) 2))  It would in Haskell.,-0.25,Haskell
13o1r8a,jl2ad0r,"I have made something similar, a PicoBlaze assembler and emulator in JavaScript (can be run in a modern browser): https://flatassembler.github.io/PicoBlaze/PicoBlaze.html",0.1,JavaScript
13nyb26,jl1jvbz,I like Rust's approach.,0.0,Rust
13nyb26,jl3fezd,Elm has even better and always shows the type of the result of the evaluation.,0.5,Elm
13nyb26,jl33cl8,I thought I ran across something like a *debug-print* while (trying to) learn me a Haskell (for great good).,0.75,Haskell
13nyb26,jl2ghlc,"In C#, everything (even value types) derive from an `object` base class that implements a few important methods, including a `.ToString()` that defaults to printing the fully qualified name of the type.",-0.19999999999999998,C
13nyb26,jl4ohva,Ada has an 'Img attribute which is compiler-defined.,0.0,Ada
13nyb26,jl4prn9,"Since you already know OCaml, give Rust a try.",0.0,Rust
13nyb26,jl4prn9,"Like in Haskell, you can in Rust put a clause on the structs and suddenly your structs have new possibilities.",0.06818181818181818,Haskell
13nyb26,jl4prn9,"Like in Haskell, you can in Rust put a clause on the structs and suddenly your structs have new possibilities.",0.06818181818181818,Rust
13nyb26,jl4syzs,Rust's `dbg!,0.0,Rust
13nyb26,jl1mmpr,It seems similar to what another poster says Rust does.,0.0,Rust
13nyb26,jl4d7i0,Haskell,0.0,Haskell
13nyb26,jl2opcz,"I don't speak D, but I'm pretty sure that's wrong for debugging - we want escaped strings, among other things.",0.03125,D
13nyb26,jl3g9bc,>I thought I ran across something like a debug-print while (trying to) learn me a Haskell (for great good).,0.75,Haskell
13nyb26,jl3g9bc,Converting the value to a string to be printed uses the Show type class (similar to Debug in Rust) and is completely pure.,0.10714285714285714,Rust
13nyb26,jl2o2c6,"That said, in Java and C# it's possible to semi-automatically implement `Debug` using reflection to actually print the fields.",0.0,Java
13nyb26,jl2o2c6,"That said, in Java and C# it's possible to semi-automatically implement `Debug` using reflection to actually print the fields.",0.0,C
13nyb26,jl1wwxp,"I use Rust for like everything and I never really find it all that annoying, usually what’s more annoying is when something doesn’t implement debug, but that’s rare, most Rust devs just, derive what they need, it makes life easier, and for most use cases “it just works”.",-0.01874999999999999,Rust
13nyb26,jl1wwxp,"Like procedural macros in Rust are god tier, just, muah",0.0,Rust
13nyb26,jl9o9k2,"I think that if you're worried that adding derive would become annoying, then Rust isn't for you.",-0.8,Rust
13nyb26,jl4q55x,Don't forget Common Lisp.,-0.3,Lisp
13nyb26,jl4q55x,I'd recommend Paul Grahams ANSI Common Lisp book.,-0.3,Lisp
13nyb26,jl1x4e3,"In Rust it becomes almost instinctual, like yeah when you create a new type you usually just by default write the derives you need and forget about it",-0.05681818181818182,Rust
13nyb26,jl3ajcy,My primary language is Elixir.,0.4,Elixir
13nyb26,jl5cy4t,Yep and Rust's `dbg!` inspired Elixir's [dbg](https://elixir-lang.org/getting-started/debugging.html#dbg),0.0,Rust
13nyb26,jl5cy4t,Yep and Rust's `dbg!` inspired Elixir's [dbg](https://elixir-lang.org/getting-started/debugging.html#dbg),0.0,Elixir
13ntrt7,jl240aw,When I tried Dart once it took 6 seconds to compile Hello World.,0.0,Dart
13ntrt7,jl3fxx4,"On my much weaker machine, Tiny C can turn source code into executable binary at a speed pushing 1 million lines per second (probably several million lps on yours), and generating 5-10MB per second of native code.",0.04,C
13ntrt7,jl4utrs,> When I tried Dart once it took 6 seconds to compile Hello World.,0.0,Dart
13ntrt7,jl4kxn6,"You're seriously trying to convince me that I should get mad at the fastest compiled language implementation I have ever used (with the possible exception of Go), because I need to wait 6 seconds for a full build?",-0.15208333333333332,Go
13ntrt7,jl4kxn6,"Sure, your language and C are low level and simple enough that they don't need much computational effort to be type checked and translated to machine code, and if you're content with that, that's great!",0.2833333333333333,C
13ntrt7,jl4kxn6,Scala and GHC are slow.,-0.30000000000000004,Scala
13ntrt7,jl4kxn6,Rust is slow.,-0.30000000000000004,Rust
13ntrt7,jl53jpb,">Sure, your language and C are low level and simple enough that they don't need much computational effort to be type checked and translated to machine code, and if you're content with that, that's great!",0.24,C
13ntrt7,jl53jpb,And yet there are slow C compilers too!,-0.37500000000000006,C
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,Rust
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,Haskell
13ntrt7,jl6maue,"Generic ```ocaml let min(m, n) = if m<=n then m else n ``` is indeed not optimized, but it is still one C function call.",0.0,C
13ntrt7,jla3ij9,My favorite language is Haskell.,0.5,Haskell
13ntrt7,jl6pk95,"> Generic ocaml let min(m, n) = if m<=n then m else n is indeed not optimized, but it is still one C function call.",0.0,C
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,C
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,D
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Dart
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Go
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Java
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Julia
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Rust
13ntrt7,jl9ry7y,(A C++ test would have just used the same C test code.),0.0,C++
13ntrt7,jl9ry7y,(A C++ test would have just used the same C test code.),0.0,C
13ntrt7,jla45l3,"I went with the approach from [Practical type inference for arbitrary rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf) (which is also the one taken by GHC), except that mine doesn't do deep subsumption (even the authors of that paper view its introduction as a mistake now and modern Haskell doesn't include it anymore) and is constraint based rather than immediately performing unification.",-0.175,Haskell
13nht65,,* [Game Code](https://github.com/kjosib/sophie/blob/main/examples/guess_the_number.sg) written in Sophie * [Teletype Declarations](https://github.com/kjosib/sophie/blob/main/sophie/sys/teletype.sg) also in Sophie * [Teletype Adapter](https://github.com/kjosib/sophie/blob/main/sophie/adapters/teletype_adapter.py) Python module  I've modeled these I/O actions as a variant-record type with four cases:  * `done` is the stopped process.,-0.4,Python
13nht65,,## Taking this to the next level  Python's PRNG is pretty excellent.,0.4166666666666667,Python
13nht65,,"Supposing I pass the `teletype_adapter` a functional-process that emits numbers, I can just call that function instead of the Python PRNG from within the `teletype_adapter` module.",0.0,Python
13nht65,jl5q6bs,"This could be applied as a twist on Rust's ownership for example, once the variable is sent in a function its ownership is ""abandoned"" instantly and all you are left with is a handle to a new state.",0.04545454545454545,Rust
13nd9di,jkzf7ua,">Matches C execution speed, occasionally Bolin is faster  I am new to this programming languages thing.",0.06818181818181818,C
13nd9di,jl3ct3n,"I just extracted the files into `C:\bolin` under Windows, then switched to WSL and went to the `bolin\linux\bin` directory where there was an executable.",0.0,C
13nd9di,jl3ct3n,"If it can use a tcc backend, that sounds like it uses C intermediates, therefore gcc could work too (and there should be a option to just produce the C file).",0.0,C
13nd9di,jkzh2ai,"Our standard library has a few functions that may inline where C and C++ standard library does not, and no copying on fread/fgets https://bolinlang.com/more_optimal_standard  For the most part they're roughly the same speed",0.03333333333333333,C
13nd9di,jkzh2ai,"Our standard library has a few functions that may inline where C and C++ standard library does not, and no copying on fread/fgets https://bolinlang.com/more_optimal_standard  For the most part they're roughly the same speed",0.03333333333333333,C++
13nd9di,jl2267c,"I'm not experienced with that, but I'm curious to know a) how it works and b) how it differs from Rust.",-0.25,Rust
13nd9di,jl4z8sk,"For example, you mention that it makes use of tcc, which means that it uses intermediate C?",0.0,C
13nd9di,jl4z8sk,"But is that Clang used for processing LLVM stuff, or processing C source code?",0.0,C
13nd9di,jl50ohz,"Since I now know where `mm.exe` lives, in `C:\m\bin\` (or I can use `C:/m/bin/` internally), I can use that path (say I store it in `homepath`), to access a dependency such as `homepath + ""mm_help.txt""`, or `homepath+""../lib/etc...""`.",0.0,C
13nd9di,jl5rza3,I didn't want to write a plain C version since AVX2 has been supported for over a decade.,-0.21428571428571427,C
13nb6tq,,"// single digit error             case +1:             case -1:             case +10:             case -10:             case +100:             case -100:             printf(""Almost there, you'll get it next time!\n"");         }     }  Yes, this actually works in C and C++ 😂 I wonder if that is by design or accident?",-0.023809523809523808,C
13nb6tq,,"// single digit error             case +1:             case -1:             case +10:             case -10:             case +100:             case -100:             printf(""Almost there, you'll get it next time!\n"");         }     }  Yes, this actually works in C and C++ 😂 I wonder if that is by design or accident?",-0.023809523809523808,C++
13nb6tq,jl06dmm,"lets you do stuff like this: ```c switch(x){    ...    if(0){      case 1:; //initialization specific to 1    }    if(0){      case 2:; //initialization specific to 2    }    // logic shared by 1,2    break;    ... } ``` Yes, it definitely IS ugly, but in some places, especially in language like C where it's problematic to use lambdas for sophisticated code organization, it can help with keeping DRY.",-0.04444444444444443,C
13nb6tq,jl0fx4d,">language like C where it's problematic to use lambdas for sophisticated code organization, it can help with keeping DRY.",0.21666666666666667,C
13nb6tq,jl0fx4d,"I don't have a solution right now except for this which works for a few use-cases (here, it permanently jumps like the C example, it doesn't return):      case x                  # more general form of switch     when 1 then println ""one"";  recase 3     when 2 then println ""two"";  recase 3     when 3 then println ""three""     ...  (\*\* Actually from this perspective it doesn't sound too bad!",0.022959183673469403,C
13nb6tq,jl0fx4d,"Compared to that C `switch` example, it's the picture of elegance.",0.0,C
13nb6tq,jl156pk,"In C#, I'd just put that `print(""three"")` inside a delegate or local function and then invoke it at the end of `case 1`, `case 2`.",0.0,C
13nb6tq,jl156pk,"In C, one could ofc just make a macro and use it in the same way (I guess compiler would probably de-duplicate the code back tbh, but it still would be a terrible code smell because global macro namespacing and everything xD )  `recase` is a pretty interesting concept.",-0.041666666666666664,C
13n8v25,jky8bmy,(The C language also have \ line continuation that is something extra to complicate code - stay away from this kind of problem !),0.375,C
13n8v25,jkyhl86,That could in theory be done in lots of separate stages (the C standard is defined as though that happens).,0.0,C
13n8v25,jkygm5k,C's `\` line continuation is weirder than many realise.,0.5,C
13n8v25,jkygm5k,"My C lexer didn't bother with this (I didn't know about it), but if needed, there is an optional separate pass to splice lines split with `\`, then normal lexing is done on that.",0.15,C
13n8v25,jkyy3p7,```c #define M\ ACRO 1  MACRO ``` expands to 1.  https://godbolt.org/z/Ta156Pr5s  this is insane and should be removed from C.,-1.0,C
13n7lb8,jkz3nhx,What do you think of [Tutorial D](https://www.dcs.warwick.ac.uk/~hugh/TTM/DBE-Chapter11.pdf)?,0.0,D
13n7lb8,jloffqs,"This ""D"" is a specification of features for a family of languages, while TutorialD is a particular quick-and-dirty-ish implementation for use in teaching classes about relational algebra.",0.16666666666666666,D
13n7lb8,jloffqs,"Links to that and other implementations can be found here: [https://www.dcs.warwick.ac.uk/\~hugh/TTM/projects.html](https://www.dcs.warwick.ac.uk/~hugh/TTM/projects.html)  Also my Tailspin language has tried to take influences from the ""D"" specification, although I don't pretend to follow it entirely, and it is still incomplete (no connection to databases, no specific filtering syntax) [https://github.com/tobega/tailspin-v0/blob/master/TailspinReference.md#relations](https://github.com/tobega/tailspin-v0/blob/master/TailspinReference.md#relations)  I'll certainly promote the idea that having relations and relational algebra in a language is very useful.",-0.045119047619047614,D
13n7lb8,jkz0o47,APL,0.0,APL
13morox,jl5ygm0,"> They (Taffy) just ask you to write Rust, and we ask you to learn much easier fastn lang (https://fastn.com/ftd/)  > ftd is designed for everyone, not just programmers.",0.2,Rust
13lzxgd,jksuoyw,"Generics in Rust and especially C++ are slow, because they are implemented via momomorphization, i.e.",-0.15000000000000002,Rust
13lzxgd,jksuoyw,"Generics in Rust and especially C++ are slow, because they are implemented via momomorphization, i.e.",-0.15000000000000002,C++
13lzxgd,jksuoyw,"C++ is especially bad in this regard, since it needs to re-typecheck every single instantiation.",-0.5357142857142857,C++
13lzxgd,jksuoyw,"But Generics in Java, OCaml, Haskell, or most high level langauges for that matter don't slow down compilation.",0.0511111111111111,Java
13lzxgd,jksuoyw,"But Generics in Java, OCaml, Haskell, or most high level langauges for that matter don't slow down compilation.",0.0511111111111111,Haskell
13lzxgd,jksuoyw,"Value types are not heap alllocated, so these are compiled via monomorphization like in C++ and Rust, with the caveat, that they are monomorphized *lazily at runtime*.",-0.25,C++
13lzxgd,jksuoyw,"Value types are not heap alllocated, so these are compiled via monomorphization like in C++ and Rust, with the caveat, that they are monomorphized *lazily at runtime*.",-0.25,Rust
13lzxgd,jkst0hi,"This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,Rust
13lzxgd,jkst0hi,"This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,C++
13lzxgd,jktghpf,"The C++ compiler has to work with human-readable text, which adds some overhead.",0.0,C++
13lzxgd,jktghpf,Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C
13lzxgd,jktghpf,Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C++
13lzxgd,jktghpf,"For example, in C++, `std::array<int, 1>` and `std::array<int, 2>` are different types, while C# has no equivalent of that and you would just use `int[]` for both.",0.0,C++
13lzxgd,jktghpf,"For example, in C++, `std::array<int, 1>` and `std::array<int, 2>` are different types, while C# has no equivalent of that and you would just use `int[]` for both.",0.0,C
13lzxgd,jktghpf,"Or take `Compare` of `std::map`, which is a template parameter, while in C# the equivalent would use an `IComparer<T>` object, so the type of the collection stays the same.",0.0,C
13lzxgd,jku5saj,C++ and Rust are extremely slow at compiling generic functions.,-0.15000000000000002,C++
13lzxgd,jku5saj,C++ and Rust are extremely slow at compiling generic functions.,-0.15000000000000002,Rust
13lzxgd,jku5po7,The story for Java is a lot deeper than that.,0.0,Java
13lzxgd,jkv5ot0,It's worth noting that most of those things you talk about in Java etc.,0.4,Java
13lzxgd,jkv5ot0,"Notably this implies *not* doing type-erasure like Java does - instead, pass the vtables at runtime as an extra argument.",0.25,Java
13lzxgd,jkw47jy,"> C++ is especially bad in this regard, since it needs to re-typecheck every single instantiation.",-0.5357142857142857,C++
13lzxgd,jkw47jy,"Quick note about C++ compilation, type-checking of generics is done in two passes:   1.",0.3333333333333333,C++
13lzxgd,jkvwu25,I don't buy that it is slow to compile; the compilers for Rust and C++ that have been mentioned are slow anyway for lots of other reasons.,-0.2416666666666667,Rust
13lzxgd,jkvwu25,I don't buy that it is slow to compile; the compilers for Rust and C++ that have been mentioned are slow anyway for lots of other reasons.,-0.2416666666666667,C++
13lzxgd,jkvwu25,"After all languages where you have to do manual monomorphisation, like C, are not slow to compile.",0.15000000000000002,C
13lzxgd,jkw4df9,"> This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,Rust
13lzxgd,jkw4df9,"> This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,C++
13lzxgd,jkw4df9,AFAIK the Rust compiler already performs a few (lightweight) optimizations on the generic code itself (at MIR level) prior to generating the backend IR for each set of generic arguments and handing it off to the backend.,-0.05,Rust
13lzxgd,jku55mq,"> The C++ compiler has to work with human-readable text, which adds some overhead.",0.0,C++
13lzxgd,jku55mq,At least on my own benchmark suite .NET is competitive with C++ on register heavy tests (sometimes beating C++) and generally loses out on memory intensive tasks.,-0.05,C++
13lzxgd,jku55mq,> Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C
13lzxgd,jku55mq,> Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C++
13lzxgd,jku55mq,"For example, in C++, std::array<int, 1> and std::array<int, 2> are different types, while C# has no equivalent of that and you would just use int[] for both.",0.0,C++
13lzxgd,jku55mq,"For example, in C++, std::array<int, 1> and std::array<int, 2> are different types, while C# has no equivalent of that and you would just use int[] for both.",0.0,C
13lzxgd,jku55mq,"C# specifically has `int[,]` for 2D arrays.",0.0,C
13lzxgd,jku55mq,"> Or take Compare of std::map, which is a template parameter, while in C# the equivalent would use an IComparer<T> object, so the type of the collection stays the same.",0.0,C
13lzxgd,jku55mq,Conversely you have .NET's `Dictionary` where its monomorphization generally seems to produce faster code than C++ hash tables AFAICT.,0.05000000000000002,C++
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,C++
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,Rust
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,C
13lzxgd,jku72p4,"The important difference between Java and C# is that in Java, monomorphization is an Optimization, while in C#, it is a compilation strategy.",0.4,Java
13lzxgd,jku72p4,"The important difference between Java and C# is that in Java, monomorphization is an Optimization, while in C#, it is a compilation strategy.",0.4,C
13lzxgd,jku72p4,"This manifests in the fact that Java does not allow polymorphic functions over value types, because it cannot compile them via the usual generic compilation.",-0.125,Java
13lzxgd,jku72p4,"In fact, AOT compiled languages like Haskell also employ monomorphization as an optimization, though not nearly as thoroughly as in JIT compilers (it's usually called Specialization when it's just an optimization, at least in the Haskell world)",-0.19999999999999998,Haskell
13lzxgd,jkw50dt,"> After all languages where you have to do manual monomorphisation, like C, are not slow to compile.",0.15000000000000002,C
13lzxgd,jkw50dt,"I remember a talk from Bryan Cantrill, where he explained learning Rust by naively translating a C program he had.",-0.3,Rust
13lzxgd,jkw50dt,"I remember a talk from Bryan Cantrill, where he explained learning Rust by naively translating a C program he had.",-0.3,C
13lzxgd,jkw50dt,"After he was done -- ie, the Rust program was compiling and seemingly working as the C program had -- he checked the performance and was surprised that the Rust program outperformed the C one, when the former had not been optimized.",0.05,Rust
13lzxgd,jkw50dt,"After he was done -- ie, the Rust program was compiling and seemingly working as the C program had -- he checked the performance and was surprised that the Rust program outperformed the C one, when the former had not been optimized.",0.05,C
13lzxgd,jkw50dt,"Wanting to understand how that came to be, he profiled both, and realized that his C program used hand-written data-structures that had been selected for their simplicity -- since they had been re-implemented in the program -- and that were type-erased.",0.0,C
13lzxgd,jkw50dt,"In contrast, the Rust program relied on the standard data-structures: generic, highly tuned, etc...",0.05333333333333334,Rust
13lzxgd,jkva4fq,">C# specifically has int[,] for 2D arrays.",0.0,C
13lzxgd,jlb3iat,"Actually, something I'd like to see explored -- though it's likely easier in Rust than C++^1 -- is _partial_ monomorphization.",-0.03333333333333333,Rust
13lzxgd,jlb3iat,"^1 _The C and C++ standards mandate that different functions, which includes different template instantiations of a template function, have a distinct address.",0.09999999999999999,C
13lzxgd,jlb3iat,"^1 _The C and C++ standards mandate that different functions, which includes different template instantiations of a template function, have a distinct address.",0.09999999999999999,C++
13lzxgd,jkwklwv,"It may be [The Summer of Rust, August 2018](https://www.youtube.com/watch?v=YKv_IDN0zCA), an informal talk (no slide, just him sitting on a chair) as it seems to be his first talk about Rust according to http://dtrace.org/blogs/bmc/2018/02/03/talks/.",0.25,Rust
13lzxgd,jkwklwv,> Cantrill appears to be a Rust evangelist so it would be surprising if he'd chosen an example that performed worse in Rust!,0.09999999999999998,Rust
13lzxgd,jkwklwv,"He didn't use to be, Cantrill used to work for Sun Microsystems then Oracle, nigh exclusively in C. This was his first foray in Rust, and he was clearly skeptic; he'd old enough to have seen many ""C-killers"" after all.",0.19,Rust
13lzxgd,jkwklwv,> My brief experience with Rust seemed to show that Debug mode produced code that was 10 times slower then Release mode; was that non-optimised version using Debug mode?,0.0,Rust
13lzxgd,jkwklwv,"Rust and C++ are on par, typically.",-0.16666666666666666,Rust
13lzxgd,jkwklwv,"Rust and C++ are on par, typically.",-0.16666666666666666,C++
13lyst8,jkshc2t,"Java, however, proves that even if you're stuck with shitty stack-based *bytecode* for legacy-loading reasons, it's still possible to turn it into register-based code for interpretation.",0.15,Java
13lyst8,jksvanv,"Anton Ertl has written several papers about this kind of optimisation in the context of Forth, which you may find useful.",0.3,Forth
13lyst8,jktbmks,"(If transpiled to C, where it ends up as a regular `switch` inside a loop, then `gcc-O3` can't manage any better.)",0.25,C
13lta2u,jkrgchf,Nitpick: you wrote ASCI C instead of ANSI C,0.0,C
13lta2u,jkrowdd,> A lot of programming/developer jobs also refer to C/C++ when they need a programmer who knows either C or C++.,0.0,C
13lta2u,jkrowdd,> A lot of programming/developer jobs also refer to C/C++ when they need a programmer who knows either C or C++.,0.0,C++
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,C
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,Haskell
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,Prolog
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C++
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,Go
13lta2u,jkrowdd,"So should I refer to Zig, Go, and Nim as C/Zig, C/Go, and C/Nim?",0.0,Go
13lta2u,jkrl9s7,"That, and most jobs I’ve had that advertised needing C/C++ was because it was an old and/or mixed bag of both legacy C code, and C++ so why not?",0.19999999999999998,C
13lta2u,jkrl9s7,"That, and most jobs I’ve had that advertised needing C/C++ was because it was an old and/or mixed bag of both legacy C code, and C++ so why not?",0.19999999999999998,C++
13lta2u,jkrl9s7,“If you’re a C programmer say you’re a C programmer” is lame as it seems to suggest that it’s like an identity rather than a skill you have.,-0.5,C
13lta2u,jkrl9s7,"For instance, I professionally work with C/C++/Python and Rust.",0.1,Rust
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C++
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,Go
13lta2u,jkt0d5o,"So should I refer to Zig, Go, and Nim as C/Zig, C/Go, and C/Nim?",0.0,Go
13lta2u,jkt0d5o,"It's a subset because you can literally copy-paste (most) C into C++, change imports a bit, and it will compile (and usually run) in exactly the same way.",0.125,C
13lta2u,jkt0d5o,"It's a subset because you can literally copy-paste (most) C into C++, change imports a bit, and it will compile (and usually run) in exactly the same way.",0.125,C++
13lta2u,jkt0d5o,"What's not a joke is you can take basically any reasonable C program, only change headers and imports, and get a working C++ program.",0.1,C
13lta2u,jkt0d5o,"What's not a joke is you can take basically any reasonable C program, only change headers and imports, and get a working C++ program.",0.1,C++
13lta2u,jkt0d5o,"The real reason C and C++ are lumped together as C/C++ is because they, although different languages, have more in common than any other (related) language.",0.04583333333333333,C
13lta2u,jkt0d5o,"The real reason C and C++ are lumped together as C/C++ is because they, although different languages, have more in common than any other (related) language.",0.04583333333333333,C++
13lta2u,jkrg784,"I definitely agree, but article talks about scaring off C programmers...",0.0,C
13lta2u,jkrg784,"I had an interview last week for a C programming job, doing a bunch of complicated vector math.",-0.25,C
13lta2u,jksfly4,"Obviously these are different languages now, but I will keep saying C/C++ for as long as C++ programmers expect that standard platform `.h` header files can be interpreted as C++ declarations.",-0.0125,C++
13lta2u,jksfly4,"It's not unusual for various languages to be able to ingest C declarations in order to facilitate FFI, but C++ is unique in not using a dedicated facility for this, but instead hoping that the header file will contain only constructs that are valid C++ - and very likely also additional `extern ""C""`annotations!",0.12916666666666668,C
13lta2u,jksfly4,"It's not unusual for various languages to be able to ingest C declarations in order to facilitate FFI, but C++ is unique in not using a dedicated facility for this, but instead hoping that the header file will contain only constructs that are valid C++ - and very likely also additional `extern ""C""`annotations!",0.12916666666666668,C++
13lta2u,jksfhsd,"Everyone who vehemently shouts about how C and C++ are very different are technically correct, but not correct enough for me to give a shit.",-0.05,C
13lta2u,jksfhsd,"Everyone who vehemently shouts about how C and C++ are very different are technically correct, but not correct enough for me to give a shit.",-0.05,C++
13lta2u,jksfhsd,"""C/C++"" is code for ""you know C++ but aren't gonna whine when you see a malloc.""",0.0,C++
13lta2u,jkrw0z4,In the end C++ still has the allmost-full C compatibility.,0.0,C++
13lta2u,jkrw0z4,In the end C++ still has the allmost-full C compatibility.,0.0,C
13lta2u,jkrw0z4,An other issue seems to be that C and C++ are the two ends of a dialect continuum and some people just choose to sit in the middle.,-0.0625,C
13lta2u,jkrw0z4,An other issue seems to be that C and C++ are the two ends of a dialect continuum and some people just choose to sit in the middle.,-0.0625,C++
13lta2u,jkrw0z4,I do agree that quite a few C/C++ arguments are not really about C/C++ but more about just C and one should cover C++ specifically sometimes.,0.06666666666666665,C
13lta2u,jkrw0z4,I do agree that quite a few C/C++ arguments are not really about C/C++ but more about just C and one should cover C++ specifically sometimes.,0.06666666666666665,C++
13lta2u,jkrw0z4,In C++ this is mostly automatic (but unsafe with respect to dangling pointers) while in C it is mostly manual.,0.5,C++
13lta2u,jkrw0z4,In C++ this is mostly automatic (but unsafe with respect to dangling pointers) while in C it is mostly manual.,0.5,C
13lta2u,jkrw0z4,Most memory bugs are due to particularities of using either C or C++ and don't show up so much in the other.,0.11249999999999999,C
13lta2u,jkrw0z4,Most memory bugs are due to particularities of using either C or C++ and don't show up so much in the other.,0.11249999999999999,C++
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,C
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,C++
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,R
13lta2u,jksdnbw,"By this logic, Python 3 is limited because it's not compatible with Python 2.",-0.07142857142857142,Python
13lta2u,jkuz44k,Isn’t C/C++ really just C++?,0.2,C++
13lta2u,jkw3j27,I'll stop saying C/C++ when C++ is weaned from C.  How do you communicate over the network with C++?,0.0,C++
13lta2u,jkw3j27,"Hence, communicating over the network -- which, frankly, most applications tend to do nowadays -- requires writing C code.",0.5,C
13lta2u,jkw3j27,"And as long as that's the case, it means programming in C++ requires a working knowledge of C programming, to work as C/C++ programmers on C/C++ codebases.",-0.05,C++
13lta2u,jkw3j27,"And as long as that's the case, it means programming in C++ requires a working knowledge of C programming, to work as C/C++ programmers on C/C++ codebases.",-0.05,C
13lta2u,jkw3j27,"_And yes, it saddens me, I was hoping that C++17 introducing `<filesystem>` meant the end of mandatory C in C++ was nigh, but here we are, 6 years later..._",0.0,C
13lta2u,jkw3j27,"_And yes, it saddens me, I was hoping that C++17 introducing `<filesystem>` meant the end of mandatory C in C++ was nigh, but here we are, 6 years later..._",0.0,C++
13lta2u,jksacsb,Well we mix C and C++ very freely based on what we need.,0.52,C
13lta2u,jksacsb,Well we mix C and C++ very freely based on what we need.,0.52,C++
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,Python
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,C
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,C++
13lta2u,jkrpgvy,"To be fair, he wrote the C in ASCII.",0.7,C
13lta2u,jkwyqno,"But I guess if you mean nemory unsafe languages with a C style syntax, I can only think of C and C++.",-0.15625,C
13lta2u,jkwyqno,"But I guess if you mean nemory unsafe languages with a C style syntax, I can only think of C and C++.",-0.15625,C++
13lta2u,jksgl6b,"It is not at all that strange, less strange than Java/C# imo considering that the two ecosystems there are completely different, whereas there's a huge amount of ecosystem overlap with C and C++.",0.026666666666666682,C
13lta2u,jksgl6b,"It is not at all that strange, less strange than Java/C# imo considering that the two ecosystems there are completely different, whereas there's a huge amount of ecosystem overlap with C and C++.",0.026666666666666682,C++
13lta2u,jksgl6b,"Same build tools, each consuming libraries written by the other with light opaque TU boundary interfaces or convenience layers, thanks to a certain degree of source compatibility (not like Zig, which supports converting C declarations into Zig declarations via a special directive @cImport, fundamentally different from the level of compatibility between C and C++).",0.14948979591836736,C
13lta2u,jksgl6b,"Same build tools, each consuming libraries written by the other with light opaque TU boundary interfaces or convenience layers, thanks to a certain degree of source compatibility (not like Zig, which supports converting C declarations into Zig declarations via a special directive @cImport, fundamentally different from the level of compatibility between C and C++).",0.14948979591836736,C++
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,C
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,C++
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,Rust
13lta2u,jkt4d7m,[C Is Not a Low-Level Language](https://queue.acm.org/detail.cfm?id=3212479),0.0,C
13lta2u,jkrjcwa,"while I understand why people enjoy programming in C, that sounds like a really bad decision if they actually want to get anything done",-0.09999999999999994,C
13lta2u,jksczy6,"Unfortunately, even using modern C++, it is still *really* easy to mess things up.",-0.010416666666666657,C++
13lta2u,jksczy6,"With C++, you get the illusion of safety with little actual added safety.",-0.09375,C++
13lta2u,jkw0o5n,"First of all, not all C code compiles in C++.",0.25,C
13lta2u,jkw0o5n,"First of all, not all C code compiles in C++.",0.25,C++
13lta2u,jkw0o5n,"2nd of all, if you write C++ code that would be fully valid C, you're not a good C++ programmer (with the obvious exceptions).",-0.11666666666666665,C++
13lta2u,jkw0o5n,"2nd of all, if you write C++ code that would be fully valid C, you're not a good C++ programmer (with the obvious exceptions).",-0.11666666666666665,C
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,C
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,C++
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,Java
13lta2u,jks2bwn,"True, their C skills are rusty",0.35,C
13lta2u,jksd4pw,> Rust programmers who have no interest making a 30 year step backwards.,0.0,Rust
13lta2u,jksftgb,I don't think C++ is save.,0.0,C++
13lta2u,jksftgb,"But its memory management works very different from C, with some pros and cons.",0.0,C
13lta2u,jkw0h5e,C++?,0.0,C++
13lta2u,jkrop3t,"Which is why I was interrogating their choice of C. They could get identical performance and much better ergonomics with C, but the founder was fresh out of school when he started the codebase, was only exposed to gamedev C++ (its own trash dialect), and has a bunch of wrong-headed misconceptions about C++.",0.35,C
13lta2u,jkrop3t,"Which is why I was interrogating their choice of C. They could get identical performance and much better ergonomics with C, but the founder was fresh out of school when he started the codebase, was only exposed to gamedev C++ (its own trash dialect), and has a bunch of wrong-headed misconceptions about C++.",0.35,C++
13lta2u,jkrvfde,"What's more, I _can_ use an existing template expression library in C++.",0.5,C++
13lta2u,jkrvfde,"In C, I have to further doom the ergonomics by switching to pointers and temporaries.",0.0,C
13lta2u,jks3mb7,It's not just a bad reason; it's an invalid reason because memory management in C++ can trivially be just as manual as it is in C. Even Rust gives you the same level of control if you want to opt out of all the higher-level primitives for managing memory.,-0.3499999999999999,C++
13lta2u,jks3mb7,It's not just a bad reason; it's an invalid reason because memory management in C++ can trivially be just as manual as it is in C. Even Rust gives you the same level of control if you want to opt out of all the higher-level primitives for managing memory.,-0.3499999999999999,Rust
13lta2u,jkrpu0e,You're making a stronger case for C over C++ than you might think.,0.0,C
13lta2u,jkrpu0e,You're making a stronger case for C over C++ than you might think.,0.0,C++
13lta2u,jkrpu0e,"The compiler might do that on -ffast-math, but it probably wont: the only way to really guarantee those kinds of performance characteristics is to use the compiler intrinsics directly, and then you are de facto programming in C.   Sure, there are C++ libraries for SIMD operations, but if you're doing this kind of very high-performance SIMD stuff, it's an entirely reasonable decision to say ""we need very low-level control of how to optimize this stuff, so we use the intrinsics directly"".",0.23333333333333328,C++
13lta2u,jkruiqm,My issue wasn't that they were using C. It isn't _wrong_ to use C for this shit.,-0.35,C
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,C
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,C++
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,Rust
13lta2u,jkruiqm,"But if you're giving up ergonomics, it's not an acceptable answer to say ""we chose C because we wanted to manually manage our memory"".",0.0,C
13l5mq9,jkpue4y,"As an example, he said C++ almost had `auto` in its first version.",0.25,C++
13l5mq9,jkpue4y,"Due to ruining compatibility with C, it didn't make the cut.",-0.125,C
13l5mq9,jkpue4y,"His talks usually deal with the design of C++ both past, present, and future)  I realize a language could be created as a specific tool for a specific job, doing it better than more generic languages.",0.05555555555555555,C++
13l5mq9,jkqfwhr,Some examples I can think of are:  -	Rust’s phenomenal of algebraic data types and pattern matching taken from the functional world.,0.5,Rust
13l5mq9,jkqfwhr,-	Go’s concurrency model that makes threading so much nicer to use.,0.2,Go
13l5mq9,jkqfwhr,-	Python has picked up types and pattern matching.,0.0,Python
13l5mq9,jkqfwhr,"-	Rust and Swift have Macro/DSL support built in, allowing different languages to be written inside of the host language, which has a lot of useful cases.",0.15,Rust
13l5mq9,jkqfwhr,"-	Rust and Swift have Macro/DSL support built in, allowing different languages to be written inside of the host language, which has a lot of useful cases.",0.15,Swift
13l5mq9,jkw2o0g,"Rust's borrow-checking may have been based on Cyclone's region management, but it's still quite a leap, and is continuously being refined.",0.0,Rust
13l5mq9,jkw2o0g,An excellent demonstration is actually C++: it's a blob of many organically tacked together features with many subtle and baffling interactions between them.,0.33333333333333337,C++
13l5mq9,jkqkk8y,"If you look at your pattern matching example, I found:  > Early programming languages with pattern matching constructs include COMIT (1957), SNOBOL (1962), Refal (1968) with tree-based pattern matching, Prolog (1972), SASL (1976), NPL (1977), and KRC (1981).",0.3,Prolog
13l5mq9,jkqkk8y,The concept of a macro surely isn't new as we have the example of C macros.,0.13636363636363635,C
13l5mq9,jkrwlo4,"For example, very few languages support higher-kinded types, type-level programming like in TypeScript is super rare, and many or most mainstream languages support either nominal or structural types, but not both.",0.27466666666666667,TypeScript
13l5mq9,jkrwlo4,(And here I’m considering Haskell “mainstream”.),0.0,Haskell
13l5mq9,jkrwlo4,"It’s my position that programming is still in its infancy, and that most of our current languages are as primitive compared to where we’ll be in 50 years as C and Fortran are when compared to now.",0.25,C
13l5mq9,jkrwlo4,"It’s my position that programming is still in its infancy, and that most of our current languages are as primitive compared to where we’ll be in 50 years as C and Fortran are when compared to now.",0.25,Fortran
13l5cun,,"The last year I was implementing the compiler for a very basilar programming language with the rust-style syntax but c-style semantic, basically a C with generics.",0.1,C
13l5cun,,"My goal was to get a modernized version of C, but with a blazing compiler and I achieved impressive performance (about 3mln loc/s turned into special bytecode i used).",0.6785714285714286,C
13l5cun,,"(Please note that the examples in the code snippets are useful to give the idea, they are not extracted from any existing code)  I think this behavior is due to the lack of forward declarations in C which makes inline not always possible when using functions defined in .o and declared in .h (I'm aware of linktime inline, but that's not the point).",0.10625,C
13l5cun,jkojrtn,"If you had used C++ instead of C you would likely have gotten such a ""return value optimization"" guaranteed for free, or could have used placement-new to construct the object in an existing location.",0.13333333333333333,C++
13l5cun,jkojrtn,"If you had used C++ instead of C you would likely have gotten such a ""return value optimization"" guaranteed for free, or could have used placement-new to construct the object in an existing location.",0.13333333333333333,C
13l5cun,jkojrtn,"Aside from that, there's no fundamental reason why      Type create();      ...     value = create();  should be slow, assuming that the Type is trivially copyable (in C++ parlance) and that a suitable calling convention is used.",0.125,C++
13l5cun,jkojrtn,self-referential structs (which is the actual reason why RVO matters in C++).,0.0,C++
13l5cun,jkudh7s,"IMHO, this is a place where many ABIs suck and many C and C++ compilers suck and they all leave a *lot* of performance on the table as a consequence.",0.5,C
13l5cun,jkudh7s,"IMHO, this is a place where many ABIs suck and many C and C++ compilers suck and they all leave a *lot* of performance on the table as a consequence.",0.5,C++
13l5cun,jkudh7s,those that cannot be called via a C ABI) to adhere to the C ABI.,0.0,C
13l5cun,jkp9btg,>I think this behavior is due to the lack of forward declarations in C which makes inline not always possible when using functions defined in .o and declared in .h  To be able to inline requires the source code of the function to be visible.,0.125,C
13l5cun,jkohjb8,"In C, the functions you've demonstrated should compile the same way, and it's not even an optimization, but part of the standard.",0.0,C
13l5cun,jkohjb8,So in C (and C++) it should have no performance difference whatsoever.,0.0,C
13l5cun,jkohjb8,So in C (and C++) it should have no performance difference whatsoever.,0.0,C++
13l5cun,jkon2po,"> The standard literally specifies  To be pedantic, the C standard does no such thing, but then again the C standard also pretends that things such as the ""stack"" don't exist.",0.0,C
13l5cun,jkv2plw,"Calling an object ""self"" within functions that are method-like on that object is a pretty common convention in C, enough so that I'd call it idiomatic.",-0.016666666666666663,C
13k8d8k,jkjyv3b,"You are the letlang guy, the one that also did an article on the Rust parsing ecosystem!",0.0,Rust
13k8d8k,jklr5a0,"> an article on the Rust parsing ecosystem  I'd be much interested in a link to the article, I couldn't find it.",0.25,Rust
13jvof8,jkihrpn,„Can you help me debug my shunting yard?“ - moved to Trains and Locomotives Stack Exchange :D,1.0,D
13j3u3m,jkig3oq,"I don't envision Futhark running a pacemaker or a nuclear power plant, but then again they put Ada on the Arianne V rocket, and we know how that went.",0.0,Ada
13j3u3m,jkih7ea,"If you want to take a Lisp perspective (always good for the soul), it's more that sizes are *quoted expressions*.",0.6,Lisp
13j3u3m,jkih7ea,in Lisp `(= '(+ 1 2) '(+ 2 1))` is false.,-0.4000000000000001,Lisp
13iqrlm,,"To recap, for anyone who's so far managed to avoid learning how Charm works --- it embodies the [Functional Core/Imperative Shell](https://github.com/tim-hardcastle/Charm/blob/main/docs/functional-core-imperative-shell.md) pattern, in that the language is divided into commands (which have effects but don't return values) and functions (which return values but don't have effects).",0.1,Shell
13iqrlm,,"Which leaves me with the idea of commands explicitly importing globals, as in `global x`, as in Python.",0.0,Python
13iqrlm,,"I realize this is a much-hated feature of Python, and I don't have to imitate its semantics exactly, I could make it so you have to import a global both to set and to get it, if y'all think that that would be better.",0.25,Python
13iqrlm,jkbio6c,"Python sort of half-way gets away with it create-by-assign by requiring `global` or `nonlocal` statements to mutate these, but in practice declaring variables is the only way to stop typo-assignment.",0.0,Python
13iqrlm,jkduqkb,"Scheme does this in hygienic macros, IIUC, and you can do it in Common Lisp with a macro like `with-gensym` or `with-unique-names`, using `[gensym](http://clhs.lisp.se/Body/f_gensym.htm)`.",-0.3,Scheme
13iqrlm,jkduqkb,"Scheme does this in hygienic macros, IIUC, and you can do it in Common Lisp with a macro like `with-gensym` or `with-unique-names`, using `[gensym](http://clhs.lisp.se/Body/f_gensym.htm)`.",-0.3,Lisp
13iqrlm,jkhqzyf,"I'd suggest using dynamic variables, as are found in Common Lisp; all are declared ahead of use and globally, but their values can be overridden within a scope.",-0.09999999999999999,Lisp
13i9k6f,,Just an example: In C you have unknown structs like this ``` #define T struct { int x; }  T a; a = (T) { .x = 1 }; ``` but this code does not compile.,-0.425,C
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,TypeScript
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,Go
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,Haskell
13i9k6f,jkb7cgw,"Small correction, TypeScript's `interface` is still structural, [TS Playground example](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHtRmQb2QDwC5kQBXAWwCNoAaZAT2LKumQF8BuAKC4BMIEAGzhQUCdCADO2GKRAJiACgAOmcMRxESFalDqNtLKOwCUyALwA+ZHIDWIdAHcQPcVOyqsxDFgu4uyATEAIw0AQzEAExhbDyy8ipqYCZcQA).",-0.25,TypeScript
13i9k6f,jk9yqp0,"TypeScript:      type A = { x: Number };     type B = { x: Number };      type Pointer<a> = { deref: a };      type Equals<a, b> =         a extends b ?",0.0,TypeScript
13i9k6f,jkaeub7,":D      type A = { x: B };     type B = { x: A };      type Equals<a, b> =         a extends b ?",1.0,D
13i9k6f,jkaeub7,"true : false) : false;      const x: Equals<A, B> = true;  > ""assume all types are identical""   > repeatedly break aliases until there are no more contradictions  I haven't yet thought how to implement that in my compiler (which should behave like TypeScript, but doesn't), but another approach is to concurrently analyse types and have each await on each other, then all deadlocks are due to cycles which you can iterate over to deduce equivalencies.",-0.08571428571428574,TypeScript
13i4nm0,jkqjm0w,"If you have something like the following (C#):      using (var x = new T())     {         for (int i=0;i<x.length;i++)          {             x[i] = f (i);         }     }  Then `x` cannot be `Unique` because it makes no guarantee about cleanup, which is required for `using () { }`.",0.17045454545454544,C
13i1mxv,jkr5ppi,"Surprisingly, it seems that this ""direct manipulation"" or WYSIWYG style is mostly used for pure graphic design and CAD or 3D, whereas creators of webpages, arguably one of the biggest uses of programming technology, still mostly edit text files containing text-based CSS and HTML to compose the visual appearance, using cartesian coordinates, numeric dimension in units of pixels or mm  or relative percentages, etc.",0.2517857142857143,HTML
13i1mxv,jkr5ppi,"Maybe its because I used stuff like Hyper/SuperCard, THINK Pascal, MPW, and CodeWarrior back then.",0.0,Pascal
13i1mxv,jkr5ppi,"At one point I tried using some Java IDEs, like Symantec VisualCafe, IntelliJ and Eclipse but IMO, these were bloated and slow compared to what I had used on much less powerful Mac computers a decade earlier.",-0.04166666666666667,Java
13i1mxv,jkr5ppi,"Having learnt to program with Pascal and the other languages I mentioned, I very much prefer a keyword based representation to a parenthesis (curly braces) based.",0.0675,Pascal
13i1mxv,jkr5ppi,"We see this in C, where ""typename"" requires special treatment, and where the existing codebase makes the policy of reserved words useless for language evolution, necessitating the return to stropping of keywords, like ""\_\_Generic"".",-0.07142857142857142,C
13i1mxv,jk7whsf,In Python those are 'grammaticalized' in the form of `with` blocks:  ```py with open( path ) as myfile:   myfile.write( text ) # file properly closed here even ICO error; variable myfile vanished ```,-0.05,Python
13i1mxv,jk983nj,"Another is the `with` block of Pascal, which basically brings the fields of a record into the local scope.",0.0,Pascal
13i1mxv,jk983nj,"Or the `with` block of Microsoft BASICs, which does something similar but requires a leading dot to disambiguate, which is probably an improvement over the Pascal approach.",0.0,Pascal
13i1mxv,jk9ewx0,It also seems to have a fairly direct analogy in Scala's implicit parameters.,0.1,Scala
13i1mxv,jlcbfbl,&#x200B;  For the synchronization I'm probably gonna do atomic things - both with Rust's primitives and some custom ones like AtomicString and AtomicHashMap (although I'm not sure how well it will end up).,-0.25,Rust
13i1mxv,jkoyx00,"I think 는 can be seen as a scoping operator, but it's more influential than `::` or `.` in C++ because it has larger scope itself.",0.25,C++
13hwld5,jk7kcm1,"But Haskell does support such types if you use explicit type annotations, although perhaps the result is not as polymorphic as in your type system:      example :: (forall b.",-0.375,Haskell
13hwld5,jk7u01y,"Once I give annotations teeth, if I needed to draw a line in the sand around `example` I might write this:      example(m:((number)->?a, list[number])->list[?a], ns:list[number]) : pair[list[number], list[string]] = ... ... ...;  Read the annotations a bit like a cross between Pascal and ML.",0.0,Pascal
13hwld5,jk81j7h,This is essentially how C++'s templates work.,0.0,C++
13hwld5,jk81j7h,Rust).,0.0,Rust
13hulvw,jk6yura,Rust uses a form of affine typing to handle variable lifetimes and borrowing.,0.0,Rust
13hulvw,jku7fra,"Clean, ATS and Rust, IIRC.",0.3666666666666667,Rust
13hulvw,jkmfis6,"And additionally, Rust also addresses this part of the OP  > In a dynamic language I could achieve this I guess by overwriting, x = f(x).",0.0,Rust
13hulvw,jkmfis6,"But that won't work if I'm using static types  Rust allows code like this:      let x = f(x)  So even if the first `x` was not moved into `f` (it was either borrowed or copied), the shadowing the first `x` takes it out of scope.",0.3333333333333333,Rust
13ht43r,jk8ohmo,"> At a global scale   This is Haskell we're talking about, right?",0.14285714285714285,Haskell
13hjah0,jk5pizl,"The simplest way to do this is to have a uniform representation for all your values, which is what many languages do, such as Java, ~C#,~ ¹ OCaml, and Haskell.",0.25,Java
13hjah0,jk5pizl,"The simplest way to do this is to have a uniform representation for all your values, which is what many languages do, such as Java, ~C#,~ ¹ OCaml, and Haskell.",0.25,Haskell
13hjah0,jk5pizl,"For languages like Java, ~C#,~ ¹ and Haskell, this is done by having all values be _boxed_ as pointers to their actual value; in Java, this is why you have to use `Integer` (a boxed pointer) instead of `int`.",0.0,Java
13hjah0,jk5pizl,"For languages like Java, ~C#,~ ¹ and Haskell, this is done by having all values be _boxed_ as pointers to their actual value; in Java, this is why you have to use `Integer` (a boxed pointer) instead of `int`.",0.0,Haskell
13hjah0,jk5pizl,"¹ Edit: Turns out C# doesn’t quite do that – it has value types as well as reference types, so it needs to do more",0.5,C
13hjah0,jk7b96f,"Compile a variant of the generic thing for every substitution (like in C++, or JIT in C#).",0.0,C++
13hjah0,jk7b96f,"Compile a variant of the generic thing for every substitution (like in C++, or JIT in C#).",0.0,C
13hjah0,jk7b96f,That's what Java does.,0.0,Java
13hjah0,jk716h1,"In any case, you won't go wrong to look at how C++ does it.",-0.5,C++
13hjah0,jk9btwj,"Here you can read *in-depth* how is done in Swift:   Compiling Swift Generics     https://forums.swift.org/t/compiling-swift-generics-part-i/60898     https://download.swift.org/docs/assets/generics.pdf",0.0,Swift
13hjah0,jk6r5ao,"Nim is a nice language to study for that as it has generics and compiles through C so you can easily inspect the ""intermediate language"".",0.5166666666666666,C
13hjah0,jk6zpqn,C++ is an example of a language that does this through the template feature.,0.0,C++
13hjah0,jk6zpqn,"Java, on the other hand, does not - instead it boxes all objects, and the same byte code is used for all instantiations of a generic function (and a generic class too).",-0.03125,Java
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,Java
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,C
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,Haskell
13hjah0,jkaeeow,In C# you can use both value types and reference types as generics type parameters.,0.0,C
13hjah0,jkaeeow,"Java only supports reference types as type parameters, because of *type erasure*.",0.0,Java
13hjah0,jkaeeow,The Java VM does not know about generics and musty treat all generic type parameters the same.,0.0,Java
13hjah0,jkaeeow,C# generates one shared realization of a generic for *reference types* (like Java) and in addition to that one realization per unique size of value types used to realize the generic (unlike Java).,0.125,C
13hjah0,jkaeeow,C# generates one shared realization of a generic for *reference types* (like Java) and in addition to that one realization per unique size of value types used to realize the generic (unlike Java).,0.125,Java
13hjah0,jk7n1j3,"I might compile all the way down (in my final compiler, rn I'm compiling to C) to machine code but include a bit more information so that a custom ""pre-linker"" could sort all that out.",0.11481481481481481,C
13hjah0,jk7lo00,"I'm currently compiling down to C, and it would be interesting to see how nim does things yeah.",0.11481481481481481,C
13hjah0,jk616jm,"Rust and C++ solve it, so you can too :-)",0.5,Rust
13hjah0,jk616jm,"Rust and C++ solve it, so you can too :-)",0.5,C++
13hjah0,jkaeor2,I didn’t realize C#’s value types were so well-integrated into the language,0.0,C
13hjah0,jk5l1k7,"I'm not sure how it works, but maybe   Look up how the ""inline"" specifier in C++ is implemented   (it has nothing to do with inlining function calls.",-0.25,C++
13hjah0,jk8pzi2,"For user defined struct, you could use something like Go interfaces :  https://research.swtch.com/interfaces",0.0,Go
13hjah0,jk7ph8q,"I'm currently compiling down to C, and it would be interesting to see how nim does things yeah.",0.11481481481481481,C
13hjah0,jkcnnc8,"I wouldn't call what C++ and Rust do ""solving"".",0.0,C++
13hjah0,jkcnnc8,"I wouldn't call what C++ and Rust do ""solving"".",0.0,Rust
13hjah0,jk7usui,"Well, you compile a Nim program with that setup and look at the C files, that's what is happening.",0.0,C
13gt1ib,,"I'm thinking something along the lines of Rust Game Dev, where you can share your progress and get feedback from a community beyond just Reddit and Discord.",-0.4,Rust
13g4r5d,jjyx0ui,"Most times after learning the language basics and probably working through a couple of books and some coding problems, so I feel like I'm starting to get a sense for idiomatic use of the language, I'll write a Lisp interpreter (writing the reader from scratch, no parsing libraries).",0.25,Lisp
13g06id,,"The language doesn't have to be JavaScript, I can read code in a lot of languages.",0.0,JavaScript
13fm2q5,jjxhvlq,Unification is currently entirely syntactic - just as if you encoded arithmetic at the type level in Standard ML or Haskell.,0.0,Haskell
13eztdp,,C was great for my toy JIT but I don't want to rewrite expression trees in it.,0.8,C
13eztdp,,I'd like my compiler's source code to be as small and simple as possible so Rust seems out because of the borrow checker and lack of pattern matching over RC'd trees and lack of tracing GC.,-0.08333333333333333,Rust
13eztdp,,Has anyone tried Swift for this?,0.0,Swift
13eztdp,jjsmdzy,"Common Lisp is my first choice, Racket the second one, and RAKU (perl6;)) the third one.",0.04,Lisp
13eztdp,jjsmdzy,You will find Common Lisp (and the other LISPs) extremely well suited for this job :),-0.012500000000000011,Lisp
13eztdp,jjswrj0,I personally like using D for this stuff.,0.0,D
13eztdp,jjswrj0,It's quite fast and has garbage collection and decent support for calling C code.,0.18333333333333335,C
13eztdp,jjsq48a,"Prolog is a good choice for writing compilers: It has a built-in grammar mechanism (definite clause grammars, DCGs), and great support for reasoning about ASTs symbolically via a generalization of pattern matching.",0.5,Prolog
13eztdp,jjsq48a,"A compiler can be expressed in Prolog as a *relation* between source code and target code, possibly involving intermediate steps.",0.0,Prolog
13eztdp,jjsq48a,"Prolog is ideally suited for reasoning about terms, and can therefore also be easily used to implement term rewriting languages, again as relations between source and target terms.",0.6666666666666667,Prolog
13eztdp,jjst8we,Haskell.,0.0,Haskell
13eztdp,jjwa9ap,"A Lisp or ML-family language might still be a good choice, for the reasons I listed above, but don't choose a Lisp or ML-family language because it's good at parsing if you're going to be struggling with all the actually hard parts of writing a compiler because of that choice.",0.2770833333333333,Lisp
13eztdp,jjt1e5i,Another vote for Rust but you'll have to be prepared to learn the language first before trying to dive into a compiler.,0.25,Rust
13eztdp,jjshes3,"Common Lisp and Coalton, if you like high-performance, bleeding edge tech.",-0.3,Lisp
13eztdp,jjv8s69,"Rust or Haskell, or any language that supports algebraic data type with pattern matching.",0.0,Rust
13eztdp,jjv8s69,"Rust or Haskell, or any language that supports algebraic data type with pattern matching.",0.0,Haskell
13eztdp,jju6i3c,"And full interop with C#, if that matters at all.",0.35,C
13eztdp,jjubtn4,"In my case I found C to have been completely perfect for my needs, but you have already tried that so I won’t recommend it.",1.0,C
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,C
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,C++
13eztdp,jjubtn4,"D, Swift, Nim seem to fit the bill, but ultimately you probably want a language you feel comfortable in.",0.26666666666666666,D
13eztdp,jjubtn4,"D, Swift, Nim seem to fit the bill, but ultimately you probably want a language you feel comfortable in.",0.26666666666666666,Swift
13eztdp,jjubtn4,"To me C is very nice with sufficient abstractions for my needs, and I’m comfortable with it.",0.5900000000000001,C
13eztdp,jjubtn4,For someone else C is unthinkable.,-0.05,C
13eztdp,jjubtn4,"That said, if you had problems using C, then it might be worth looking at codebases which implement in C or C-ish C++ to see how they get around those issues.",0.3,C
13eztdp,jjubtn4,"That said, if you had problems using C, then it might be worth looking at codebases which implement in C or C-ish C++ to see how they get around those issues.",0.3,C++
13eztdp,jjuwxkg,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important - except when implementing an interpreter that needs to implement specific integer sizes or make use of the C math library.",0.3464285714285714,Haskell
13eztdp,jjuwxkg,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important - except when implementing an interpreter that needs to implement specific integer sizes or make use of the C math library.",0.3464285714285714,C
13eztdp,jjtmbpo,My compiler is in C++ but the prototype that I made the most progress the quickest was in C# (before it became very slow).,0.054999999999999966,C++
13eztdp,jjtmbpo,My compiler is in C++ but the prototype that I made the most progress the quickest was in C# (before it became very slow).,0.054999999999999966,C
13eztdp,jjvdxqe,If you're already used to OCaml I would suggest Haskell as an alternative that solves your two pain points (full width ints and FFI).,0.35,Haskell
13eztdp,jjvykbg,Personally I prefer C++ in a moderate style which compiles on any C++98 or C++11 compiler over everything else I've tried.,0.0,C++
13eztdp,jjvykbg,"C works up to a certain complexity, and the fancy languages (including modern modern C++) cause too much dependability.",0.20357142857142857,C
13eztdp,jjvykbg,"C works up to a certain complexity, and the fancy languages (including modern modern C++) cause too much dependability.",0.20357142857142857,C++
13eztdp,jjvykbg,"In terms of C++ library support I solved the dependability, capability and complexity issues by providing LeanQt which is very powerful but still modest and easily integratable.",0.30777777777777776,C++
13eztdp,jjsqi0c,Rust is the closest to oCaml which is also low-level.,0.0,Rust
13eztdp,jjsqi0c,> I'd like my compiler's source code to be as small and simple as possible so Rust seems out because of the borrow checker and lack of pattern matching over RC'd trees and lack of tracing GC.,-0.08333333333333333,Rust
13eztdp,jjsqi0c,"It sounds puzzling, I start learning Rust with https://tablam.org and probably was making my life harder trying to do ""advanced"" stuff when not **have any idea of what I was doing**.",0.15000000000000002,Rust
13eztdp,jjsqi0c,---  Swift is fine.,0.4166666666666667,Swift
13eztdp,jjsqi0c,"My first prototype was on python, then I move to Swift.",0.25,Swift
13eztdp,jjsqi0c,"I then later move to Rust because swift support outside the Apple ecosystem is too poor, but is a good way to just test the water if wanna.",0.07499999999999998,Rust
13eztdp,jjtati5,Swift is fine.,0.4166666666666667,Swift
13eztdp,jjugujz,"Well, I have written [the first compiler for my programming language](https://flatassembler.github.io/compiler), targetting x86, in IE6-compatible JavaScript, and [the second compiler](https://github.com/FlatAssembler/AECforWebAssembly.git), targetting WebAssembly, has been written in C++11.",0.125,JavaScript
13eztdp,jjv9vg4,I've written a compiler in Rust without much issues with borrowchecker.,0.2,Rust
13eztdp,jjx6y45,Go.,0.0,Go
13eztdp,jjx6y45,"Wrote a compiler in C before, and while I enjoyed it at the time, I don't think I'll ever do that again.",0.5,C
13eztdp,jjykjur,I'd say take a stab at Julia; (I'm an idiot!,-1.0,Julia
13eztdp,jjv198j,Try Julia with LLVM.,0.0,Julia
13eztdp,jjwpr7a,Haven’t done it myself but I’ve heard a lot of good things about Haskell in this regard.,0.7,Haskell
13eztdp,jjwpr7a,Actually got a summer job where they’ve built a whole compiler in Haskell.,0.1,Haskell
13eztdp,jjwpr7a,I saw this one guy also made a compact lil parser in less than 80 lines in Haskell.,-0.16666666666666666,Haskell
13eztdp,jjxkyr0,JavaScript.,0.0,JavaScript
13eztdp,jjzoyno,"* **Haskell**: If you're up for a drastically different programming language experience that, if strangers' opinions on the internet (including mine) is anything to go on, will make you a better programmer even when using other languages, then give this beauty a go.",0.125,Haskell
13eztdp,jjzoyno,"Here's an example compiler written in Haskell for a statically-typed, non-GCed, performance-oriented Lisp+Rust-inspired Lisp:  [https://github.com/carp-lang/Carp](https://github.com/carp-lang/Carp)",-0.75,Haskell
13eztdp,jjzoyno,"Here's an example compiler written in Haskell for a statically-typed, non-GCed, performance-oriented Lisp+Rust-inspired Lisp:  [https://github.com/carp-lang/Carp](https://github.com/carp-lang/Carp)",-0.75,Lisp
13eztdp,jjuigvm,I can suggest Clojure.,0.0,Clojure
13eztdp,jjt9wpy,"If you like Prolog, you might want to try Mercury.",0.0,Prolog
13eztdp,jjt9wpy,"It's Prolog, but with strong types, strong modes and strong determinism.",0.4333333333333333,Prolog
13eztdp,jjtx8al,"Did you ever really try to do a decompiler that way, or you are just discussing a theoretical possibility of having a decompiler as a different way of running Prolog predicates?",0.06666666666666667,Prolog
13eztdp,jjt9m3d,I would suggest to give Haskell a try as it is really easy to make parser combinator in Haskell.,0.43333333333333335,Haskell
13eztdp,jjt9m3d,Haskell also have a LLVM binding if you are doing some kind of compiled languages.,0.6,Haskell
13eztdp,jjwz2s4,"You can write a C compiler in Python, https://web.archive.org/web/20150126174629/http://people.cs.uchicago.edu:80/~varmaa/mini_c/",0.0,C
13eztdp,jjwz2s4,"You can write a C compiler in Python, https://web.archive.org/web/20150126174629/http://people.cs.uchicago.edu:80/~varmaa/mini_c/",0.0,Python
13eztdp,jk8nuvi,I too use C++,0.0,C++
13eztdp,jjvkbsx,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important  I don't understand all these arguments against full-width integers, *especially* regarding compilers.",0.3464285714285714,Haskell
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,C
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,Rust
13eztdp,jjzrah3,"> Well, I have written the first compiler for my programming language, targetting x86, in IE6-compatible JavaScript, and the second compiler, targetting WebAssembly, has been written in C++11.",0.125,JavaScript
13eztdp,jjt1le8,"If they've already eliminated C and Rust for lack of abstraction, they're definitely not going to want to use Odin.",0.0,C
13eztdp,jjt1le8,"If they've already eliminated C and Rust for lack of abstraction, they're definitely not going to want to use Odin.",0.0,Rust
13eztdp,jjsoz3p,"I wrote my first compiler in C, and at my work we use C++ (although I’m not on the compiler team myself).",0.25,C
13eztdp,jjsoz3p,"I wrote my first compiler in C, and at my work we use C++ (although I’m not on the compiler team myself).",0.25,C++
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,C
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,C++
13eztdp,jjthcw3,My JIT in C is easy because I can just call anything but if I used OCaml it would be painful having to wrap everything in stubs.,-0.1333333333333333,C
13eztdp,jju9pd8,"In addition to this specific extreme (and maybe indeed unattainable) benefit, there are other, in a sense ""less general"", benefits we automatically get from describing a parser and compiler as relations in a logic programming language, including:  - being able to easily search whether the grammar is ambiguous by *asking* the Prolog system for strings that correspond to multiple tokenizations or ASTs - being able to easily express *test cases* as queries that relate (ground or partial) source programs to intended (ground or partial) target programs and must succeed or fail.",0.06153846153846154,Prolog
13eztdp,jju9pd8,"These advantages are much easier to achieve, and in fact typical properties of compilers that are written in Prolog.",0.016666666666666677,Prolog
13eztdp,jjujzn2,I recently got a glimpse into a commercial compiler written in Rust.,0.0,Rust
13eztdp,jjwa66w,I'd rather someone use something else they find easier than stick it out with Rust being miserable.,-1.0,Rust
13eztdp,jjvqu4h,"As for slow compile and startup times, that's not generally a complain I hear about C#/F#, but perhaps your case is unique.",0.016666666666666646,C
13eztdp,jjvsgak,I do use Haskell's appropriately sized integer types to express these in my AST.,0.5,Haskell
13eztdp,jjwg9tb,Floats have a -0.0 and this leads to (see also [isNegativeZero](https://seed7.sourceforge.net/libraries/float.htm#isNegativeZero(in_float))):      isNegativeZero(0.0 * -1.0)  --> TRUE     isNegativeZero(-0.0 * 1.0)  --> TRUE     isNegativeZero(0.0 * 1.0)   --> FALSE     isNegativeZero(-0.0 * -1.0) --> FALSE  Floats have also [Infinity](https://seed7.sourceforge.net/libraries/float.htm#Infinity) and this leads to (see also [isNaN](https://seed7.sourceforge.net/libraries/float.htm#isNaN(in_float))):      0.0 * Infinity --> NaN     Infinity * 0.0 --> NaN     0.0 * NaN      --> NaN     NaN * 0.0      --> NaN  The Seed7 compiler leaves such float optimizations to the C compiler.,-0.02000000000000004,C
13eztdp,jk03bo0,Many people say Haskell is an exceptionally good language to write a compiler in.,0.6,Haskell
13eztdp,jk03bo0,"If you are not intimately familiar with Haskell, you probably shouldn't try to build a compiler in it.",-0.1875,Haskell
13eztdp,jjxqdip,There are a lot of things about JavaScript that I actually really like.,0.2,JavaScript
13eztdp,jjxqdip,"I won't go as far as Douglas Crockford in some of the details, but I agree with him that there's a fantastic programming language lurking inside of JavaScript.",0.25,JavaScript
13eztdp,jjujs6q,"The suggestion was based on my practical experiences on in other LISP dialects, Clojure has a unique position, IMHO.",0.125,Clojure
13eztdp,jju1lfi,"It doesn't require knowing Prolog, but given that there are far more Prolog tutorials around, you'll probably have an easier time of it.",0.3,Prolog
13eztdp,jju1lfi,Erlang might be good enough too.,0.35,Erlang
13eztdp,jk4whxl,For a larger compiler in Python look at  https://github.com/windelbouwman/ppci,0.0,Python
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,Rust
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,Haskell
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,Scala
13eztdp,jjuy2dc,"Strictly speaking, it's not Rust's fault, but more like an inherent complexity that comes with the lack of powerful GC.",0.4,Rust
13eztdp,jjwfngy,Functional style is pathological for Rust.,0.0,Rust
13eztdp,jjwfngy,"Rust is really an imperative language, IMHO.",0.2,Rust
13eztdp,jjv6p4e,"For example, I want to do:      add(mul(a, b), c) -> madd(a, b, c)  but Rust cannot match the inner `mul` if you have to go through an `Rc`.",0.0,Rust
13eztdp,jjulxjj,"It's not to start a debate about which is better or worse, but could you explain what is unique about Clojure about writing compilers and/or interprerers compared to other dialects like CL or Racket?",0.0875,Clojure
13eztdp,jjv6u4g,Even if you wrap everything in `Rc` Rust is painful because tail calls leak not only stack but everything tied to the scope.,-0.35,Rust
13etpti,,"I tried to design a lifetimes system both convenient and efficient, inspired by C++, Nim and Vale.",0.0,C++
13etpti,,"# Constructors  An automatic constructor allows to define a default value and to put the variable in a valid state, but does not cover all the C++ constructors use cases.",0.0,C++
13etpti,,"I don’t like exceptions but it may be useful to have a different behavior when an exception is thrown (for example, to have a [D’s scope guards](https://tour.dlang.org/tour/en/gems/scope-guards) equivalent, to solve [the obvious final step](https://akrzemi1.wordpress.com/2023/04/23/the-obvious-final-step/) or to make them compatible with [Vale’s higher RAII](https://verdagon.dev/blog/higher-raii-7drl)).",0.11000000000000001,D
13etpti,jk2u36g,C++ kinda does too when your compiler elides calls to destructors on moved objects.,0.0,C++
13etpti,jjtmj17,I can't believe you mentioned lifetimes but not Rust!,0.0,Rust
13etpti,jjtmj17,"Ok, Rust-style lifetimes aren't relevant here, but Rust does track whether variables live or not with a two-state system: either they're fully initialized, in which case they can be used in expressions and they need their destructors called, or they're uninitialized and can't be used in expressions and won't have their destructors called.",0.34545454545454546,Rust
13etpti,jjtmj17,Assignment and moves are always just a bitwise copy in Rust so they don't create any new cases.,0.13636363636363635,Rust
13etpti,jk5pkdy,"Looks like ""C++ but different"".",0.0,C++
13etpti,jk5pkdy,I have never read about C++ destructor elision before.,0.0,C++
13etpti,jjv21o0,Very nice explanation about Rust.,0.78,Rust
13etpti,jjv21o0,"I am not Rust programmer but since,  I am doing ownership check in C I need at least compare against Rust.",-0.3,Rust
13etpti,jjv21o0,"I am not Rust programmer but since,  I am doing ownership check in C I need at least compare against Rust.",-0.3,C
13etpti,jjv21o0,The perfect solution for C should be able to track this without adding any extra runtime state.,0.5,C
13etpti,jjuvwz6,"Rust handles construction/copies/moves/destruction nicely, I particulary like that it has destructive moves (through it has *only* destructive moves), however it’s prohibition of shared mutability makes it cumbersome.",-0.15,Rust
13etpti,jk5rfa9,> I have never read about C++ destructor elision before.,0.0,C++
13etpti,jjwtluc,Rust avoids it except in really weird cases where a variable is initialized in one code path and left uninitialized in another.,-0.25,Rust
13etpti,jjwvc1c,Can you help me to translate this C sample to Rust?,0.0,C
13etpti,jjwvc1c,Can you help me to translate this C sample to Rust?,0.0,Rust
13etpti,jjx69cv,This cannot happen in safe Rust.,0.5,Rust
13etpti,jjyfo1p,"Yeah, there's no equivalent of malloc in idiomatic Rust code.",0.0,Rust
13eo3pa,jjrp61r,If you look at the Haskell type `(<*>) :: (Applicative f) => f (a -> b) -> (f a -> f b)` it can be seen as distributing the functor type `f` over the function type `(->)`.,-0.175,Haskell
13eo3pa,jjrp61r,Python’s `f(*xs)`) then you can construct `liftAn` for arbitrary/inferable `n`.,0.0,Python
13eo3pa,jjrp61r,"In general, they can be partially applied to arguments in any order, but in the slightly simpler case that you don’t allow that, they would let you treat an uncurried type `(a, b, c) -> d` as if it were curried `a --> b --> c --> d`; whereas they also ensure that the function will be fully applied at some point locally (which is _almost always_ the case with applicatives in typical Haskell code) or explicitly boxed into a closure.",-0.07666666666666666,Haskell
13eo3pa,jjrhcqb,"I don't know much about your language -- if it's dynamically typed, you could make some sort of `Decode.mapMany` that takes varargs, reduces with the (binary) `<*>` to get a list of arguments with the Applicative wrapper (read: `sequenceA`), then map spread-apply on your original function  if it's not dynamically typed, you might still be able to encode this, but it involves talking about mapping over the types in a heterogeneous (argument) list (or just casting to the top type = whatever the ""supertype of everything"" is, but that's no fun :p)  not sure I explained this very well, but I'm happy to rephrase if you could tell me which languages you're familiar with (I'd guess Elm?)",0.33636363636363636,Elm
13eo3pa,jjslho3,"I'm literally typing this while watching a talk about Applicative in C++, a language without automatic currying.",0.4,C++
13eo3pa,jjslho3,"Implement manual currying, which is possible in C++.",0.0,C++
13eo3pa,jjrjd77,"Elm indeed is where I got the idea ""I need this functionality"" from, but it automatically curries so it doesn't have the issue with peeling off one argument at a time.",0.0,Elm
13eo3pa,jjrjd77,I think I'll be fine with Haskell analogies as well if you want to explain using that.,0.4166666666666667,Haskell
13eo3pa,jjvbhrr,Or perhaps C++ has some unsafe cast capability that makes the nice unlimited API expressible as well :),0.55,C++
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,C
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,C++
13elyfa,,"Def !SomeClass(){     		Log(""Goodbye :("");     	}     }          /*          Here come modules,modules can either contain extensions,attributes or helpful functions          modules can be the only thing in the file,and must start with the keyword ""extend"" followed by either ""Attribute"",""Extension[]"" or ""Helper""          modules can either be internal or public,and the access modifier attribute must be put before the extend keyword          */     @Public     extends Extension[SomeClass]               //We can add additional Functions,but not additional Variables or Properities          //We can use the Params[] Container to pass an infinite amount of objects as parameters,although it must be the last argument     @Public      Fn ExtensionFunction(val uselessStuffForExample : Params[Dyn]) : bool{     	//The When keyword takes multiple bools and checks for any falses,if detected,it returns from the method with the default value     	When{     	!false,     	true     	}          	//For loops work the same as in kotlin and rust,except we use the Range or RangeInclusive Functions     	For (i in RangeInclusive(1,10)){     		Log(i);     	}     	//While loops work as expected     	While (True){     		Break;     		//There also exists the Break keyword,the Skip keyword(similar to continue),Redo keyword(redos the current loop) and the Reloop keyword(Reloops the entire loop)     	}     	//Switch is intended to be faster and much more cleaner for checking single values similar to the C# variant and requires a constant value     	Switch(1){     		(1,2) => Logl(1),     		3 => Logl(3),     		4 => Logl(4),     		_ => Logl(""Default"")     	};     	return true;     }          //There are other object types other than Classes,these are Structs(The same as in most languages),Enums(Same as in C# but can inherit a constant and if it inherits,it must have a value) and Cases(Sames as Enums in rust)  so how does it look?",0.019940476190476186,C
13elyfa,,"also, I need some help with this language, so far I have made a simple lexer with logos in Rust and was planning to make a parser with nom and a compiler with Inkwell, but I am thinking of switching to another language, should I?",0.05,Rust
13elyfa,jjqsztg,"also, I need some help with this language, so far I have made a simple lexer with logos in Rust and was planning to make a parser with nom and a compiler with Inkwell, but I am thinking of switching to another language, should I?",0.05,Rust
13elyfa,jjqsztg,"If you are comfortable with Rust, use it, otherwise pick something else.",0.4,Rust
13elyfa,jjqwzdh,I disagree on the int thing  Int should be the same as C's int_fast32_t imo  There's no reason to explicitly specify the bit size of an integer if it's not required by the code in question.,0.0,C
13ej6fr,jjq8sc3,"Among other things in here, one thing I found interesting is that there appears to be the Interlisp source code of v1.5 of Quintus Prolog.",0.1875,Prolog
13e5ilp,jjocbyw,"Dart has come a long way since version 1, I still vaguely remember how Dart 1.x had a pluggable type system and was supposed to be a better JS.",-0.01666666666666668,Dart
13e5ilp,jjocbyw,"Of course most people writing code in Dart are doing this for Flutter as it is now, but it will be really nice to see Dart being used in other areas as well.",0.325,Dart
13e5ilp,jjnyr12,Saw this comment elsewhere:  >\> it's not bringing anything useful to the table compared to other existing languages   Dart's tooling and compiler are actually state-of-the-art.,0.05833333333333333,Dart
13e5ilp,jjnyr12,"Not many languages can claim to target every major OS (Windows, Mac, Linux, Android, iOS) in three different modes (native, JIT, interpreted) and natively compile to both JavaScript and WebAssembly, while also supporting hot-swapping code at runtime.",0.015625,JavaScript
13e5ilp,jjnyr12,Plus Dart's Pub package manager is stupidly simple and 'just works' compared to pretty much any other language I've used.,0.08125,Dart
13e5ilp,jjqs1ed,"Dart is only ""exciting"" if you fell into a coma around Java 7.",0.06666666666666667,Dart
13e5ilp,jjqs1ed,"Dart is only ""exciting"" if you fell into a coma around Java 7.",0.06666666666666667,Java
13e5ilp,jjqs1ed,"I understand it's targeting a similar kind of people as Go and they don't want to overload the minds of those feeble non-Googlers, but that doesn't explain all the feature work that is happening.",0.033333333333333326,Go
13e5ilp,jjolqep,"As in Dart, the GObject and GLib framework that started in the Gimp Open Source Paint Tool and later in the Open Sourc Linux GNome Desktop eventually become the Vala P.L.",0.0,Dart
13e5ilp,jjphj73,"None of those great things are a property of Dart, the language.",0.8,Dart
13e5ilp,jjphj73,"Dart, the language, does not bring anything new to the table.",0.13636363636363635,Dart
13e5ilp,jjphj73,"Tools and compilers are still reasons why you would pick a language over another for a project, and why Dart as a language choice can still make sense for some situations.",0.0,Dart
13e5ilp,jjphj73,But it'd be much better for absolutely everyone if the efforts spent on the Dart compiler went into improving the compiler of an existing language with extensive ecosystem.,0.15,Dart
13e5ilp,jju6svb,"""Dart is the only language that initially had design flaw X and now no longer has design flaw X"".",0.0,Dart
13e5ilp,jjqnsgn,So Kotlin and Typescript don't count then?,0.0,Kotlin
13e5ilp,jju6mp0,Kotlin.,0.0,Kotlin
13e5ilp,jju6mp0,Dart has been playing catch up to Kotlin's features for over five years now.,0.0,Dart
13e5ilp,jju6mp0,Dart has been playing catch up to Kotlin's features for over five years now.,0.0,Kotlin
13e5ilp,jjra194,Scala 3 has had it under a compiler flag for a long time too.,-0.05,Scala
13e5ilp,jjrgw0l,Kotlin and TypeScript aren't sound.,0.4,Kotlin
13e5ilp,jjrgw0l,Kotlin and TypeScript aren't sound.,0.4,TypeScript
13e5ilp,jjrupi6,"Uhm, I really don't know haha, don't work on the Dart team, was just clarifying the claim",0.2,Dart
13e5ilp,jjrgtaq,"Some examples of how language design interacts with what you might think of as ""implementation features"":  * Dart has no top level static initialization.",0.125,Dart
13e5ilp,jjrgtaq,"This means that applications can start up faster than you typically see in, for example, Java.",-0.16666666666666666,Java
13e5ilp,jjrgtaq,* Dart doesn't have class loading or other dynamic loading features.,-0.0625,Dart
13e5ilp,jjrgtaq,This makes whole-program optimization and large scale dead code elimination work in ways that are very difficult for a language like Java or C#.,-0.21190476190476193,Java
13e5ilp,jjrgtaq,This makes whole-program optimization and large scale dead code elimination work in ways that are very difficult for a language like Java or C#.,-0.21190476190476193,C
13e5ilp,jjrgtaq,* Dart's concurrency model is designed to be straightforward to compile to JavaScript while other languages struggle to have the same concurrency semantics on the web without losing a lot of performance.,0.08333333333333333,Dart
13e5ilp,jjrgtaq,* Dart's concurrency model is designed to be straightforward to compile to JavaScript while other languages struggle to have the same concurrency semantics on the web without losing a lot of performance.,0.08333333333333333,JavaScript
13e5ilp,jjrgtaq,"There's a reason every JVM has a JIT, while C++ implementations generally don't.",0.05000000000000002,C++
13e5ilp,jjrgtaq,There's a reason Ruby and Python are still mostly using bytecode interpreters and why ahead of time compilation for them hasn't been successful.,0.625,Ruby
13e5ilp,jjrgtaq,There's a reason Ruby and Python are still mostly using bytecode interpreters and why ahead of time compilation for them hasn't been successful.,0.625,Python
13e5ilp,jjw1gu5,Awfully specific asterisks that need to be appended to all these claims about Dart ...,0.0,Dart
13e5ilp,jjrgnq5,"I am talking about Dart, the language.",0.0,Dart
13e5ilp,jjrgnq5,Dart's tooling is great.,0.8,Dart
13e5ilp,jjrgnq5,And when Flutter was started there were already plenty of better options than Dart.,0.5,Dart
13e5ilp,jjzxape,> bigger than the alternative languages that run on VMs and have sound null safety  > Dart's ecosystem is bigger than comparable languages today.,0.13333333333333333,Dart
13e5ilp,jjzxape,I'd wager that even Scala's ecosystem (a language that is pretty much dying) is substantially bigger than Dart's.,0.15,Scala
13e5ilp,jjzxape,I'd wager that even Scala's ecosystem (a language that is pretty much dying) is substantially bigger than Dart's.,0.15,Dart
13e5ilp,jjryca9,It doesn't matter since Dart 3.0 seems to finally be a decent language.,0.16666666666666666,Dart
13e5ilp,jjryca9,"Could've had an easier time for everyone but here we are, and that's what my comment was pointing out: Building an ecosystem for Dart, the language, was a waste of resources.",-0.2,Dart
13e36pv,jjnq142,The Julia language is specifically built with scientific computing and researchers in mind.,0.0,Julia
13e36pv,jjnq142,"Julia approaches reproducibility from the packaging perspective: local environments (collections of installed packages) are easy to set up, the exact state of each environment is saved locally, along the ""research code"".",0.17083333333333334,Julia
13e36pv,jjnq142,"There are also Pluto notebooks, which are the Julia version of reproducible Jupyter-like notebooks.",0.0,Julia
13e36pv,jjnq142,Another thing that's often mentioned when talking about Julia for researchers is Julia's Unicode support.,0.0,Julia
13e36pv,jjnq142,"Supposedly, researchers like to use Greek letters and various fancy symbols as part of variable names, and Julia lets you do just that.",0.0,Julia
13e36pv,jjnq142,"Of course, Julia also provides a lot of tooling for all sorts of computation, optimization, solving equations, fitting neural networks, plotting stuff and so on.",0.5,Julia
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,Python
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,Fortran
13e36pv,jjor8ip,My opinion is that replacing Fortran will be tough.,-0.3888888888888889,Fortran
13e36pv,jjor8ip,"I successfully converted a friend who is doing her Ph.D. to Julia, but I don't think most of her colleagues would be able to follow.",0.5833333333333334,Julia
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,Python
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,R
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,Julia
13e36pv,jjp2p5w,I would expect Rust to become popular here if the scientific computing infrastructure for that language improves.,0.6,Rust
13e36pv,jjqyqq2,I think Julia as a language has a few significant flaws like lack of static typing/analysis and the use of multiple dispatch in large projects (which can be a death trap disguised as a feature).,0.17785714285714288,Julia
13e36pv,jjqyqq2,"Aside from that, Julia has a marketability problem.",0.0,Julia
13e36pv,jjqyqq2,Same goes for R in its own niche.,0.3,R
13e36pv,jjqyqq2,"Julia devs have made some misleading claims about Julia's performance (often citing very selective and unrealistic benchmarks), but in reality, Julia's performance is at about Java level in most cases.",0.06666666666666667,Julia
13e36pv,jjqyqq2,"Julia devs have made some misleading claims about Julia's performance (often citing very selective and unrealistic benchmarks), but in reality, Julia's performance is at about Java level in most cases.",0.06666666666666667,Java
13e36pv,jjqyqq2,So I don't see it replacing Fortran on that end of the spectrum either.,0.0,Fortran
13e36pv,jjtj3qh,"Julia offers almost no way to verify that you have written correct code: there's a lack of good linting, has no compile-time errors, it allows type piracy, it has the wildest variable scoping rules I've ever seen, its default import system is basically C-style copy-paste #includes rather than any modern approach, it has no trait/etc system to enforce invariants, etc etc etc.",0.3333333333333333,Julia
13e36pv,jjtj3qh,"(I am aware of the irony here, given Julia's decision to focus on scientific applications.)",0.25,Julia
13e36pv,jjqdrwn,Hence why I am not holding my breath for Julia to replace matlab.,0.0,Julia
13e36pv,jjtne68,"These are codes developped over decades that practically no engineer ever looked at, and they are about 500k lines of Fortran too late for refactoring.",-0.3,Fortran
13e36pv,jjtne68,Fortran is great because it allows you to write fast code without effort nor much programming knowledge.,0.39999999999999997,Fortran
13e36pv,jjql6hg,"Biologists & data scientists say ""why should I learn C++ when I can have every library I need in Python?"".",0.0,C++
13e36pv,jjql6hg,"Biologists & data scientists say ""why should I learn C++ when I can have every library I need in Python?"".",0.0,Python
13e36pv,jjql6hg,"And then I show them the source of their library, which is more often than not in C++.",0.5,C++
13e36pv,jjtoxu2,"Some are, of course, but some of those big ol pieces of code everyone is using are Fortran (or otherwise) messes that have bits of code from 40 years ago, that have been written in by every PhD student that has come, with practically no control of the quality of the code (no-one in academia has time for code review, something I've incidentally only heard of through the internet despite a PhD and postdoc in a code-heavy field), no unit testing beyond ""here's a couple of test cases, have fun"" and a bunch of print\*, git being used once every couple of years to merge part of a thesis' work in (when it's not plain e-mailing tar.gzs), etc... etc...",0.10178571428571428,Fortran
13e36pv,jjtoxu2,It just so happens that Fortran is fast by default.,0.2,Fortran
13e36pv,jjwyc0h,"I don't think Julia's devs are even trying to work on this, unfortunately.",-0.5,Julia
13e36pv,jjwyc0h,"As an example, when I'm messing around with Julia code (some numerical optimization, neural networks, data visualization and so on), the language feels just fine: I don't need to specify types, I can write functions that dispatch on whatever I need (this needs types, but it's OK), and everything is pretty fast.",0.3416666666666667,Julia
13e36pv,jjwyc0h,"I've just finished working on some Python + Equinox code (loving Equinox, BTW) that involves time-series cross-validation (which needs nested loops), and boy is it slower than Julia!",0.75,Python
13e36pv,jjwyc0h,"I've just finished working on some Python + Equinox code (loving Equinox, BTW) that involves time-series cross-validation (which needs nested loops), and boy is it slower than Julia!",0.75,Julia
13e36pv,jjwyc0h,"In Julia and Flux.jl the exact same code is literally orders of magnitude faster, just out of the box, without any optimizations.",0.125,Julia
13e36pv,jjwyc0h,"In Julia, however, I don't need to worry about JIT (except when it takes forever to run code for the first time - ha, got 'em!).",0.3125,Julia
13e36pv,jjwyc0h,I don't like it when `MyPackage.jl` basically consists of `include`s that supposedly act more like C's `#include` directives.,0.5,C
13e36pv,jjwyc0h,Even Python has abstract base classes that force you to implement the entire interface.,-0.4,Python
13e36pv,jjr6bey,"as opposed to MATLAB, which ships without a package manager and makes life hell for anyone using it.",0.0,MATLAB
13e36pv,jjqul2q,That's the point of the Python ecosystem or of libraries in general: other people have written stuff do you don't have to.,-0.03749999999999999,Python
13e36pv,jjxlkh1,"Ah, I took your mention of Julia to be a recommendation.",0.0,Julia
13e36pv,jjxlkh1,"As anecdata, I have definitely seen first-time Julia users run afoul of each of the various things I've mentioned.",0.0,Julia
13e36pv,jjxlkh1,Price of bolting a DSL on to Python.,0.0,Python
13dya1e,,"Usually this is the default behaviour of these constructs, but i found Go to be an oddball (as it usually is), here's the specification of type identity between two `struct` types ([link to the spec](https://go.dev/ref/spec#Type_identity)):  >Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags.",-0.125,Go
13dya1e,jjn2f8q,My records look like this in my static language; they are always a named user-type:      record R =         real a         string b     end      record S = (real a; string b)      # alternate compact syntax  This also defines two incompatible types `R` and `S`.,0.029999999999999992,R
13dya1e,jjnt5iq,"**Summary**  Anyway, I use record / struct types, as a typical ""C"" or ""Pascal"" program declares them.",-0.16666666666666666,C
13dya1e,jjnt5iq,"**Summary**  Anyway, I use record / struct types, as a typical ""C"" or ""Pascal"" program declares them.",-0.16666666666666666,Pascal
13dya1e,jjnt5iq,"As an example:      struct RGBA     {        int var R;        int var G;        int var B;        int var A;     }  Is not the same as:      struct ARGB     {        int var A;        int var R;        int var G;        int var B;     }  Both are Product Types, right ?",0.14285714285714285,R
13dya1e,jjnt5iq,"And a common:      union Param     {       int var I;       doubl var F;       char var C;       char* var S;     }  That's a Sum Type, right ?",-0.007142857142857145,C
13dya1e,jjnt5iq,"You will not notest much of a difference, from C or C++, in these fragments of code, except that "";"" and variable declarations aren't not supported here.",0.2,C
13dya1e,jjnt5iq,"You will not notest much of a difference, from C or C++, in these fragments of code, except that "";"" and variable declarations aren't not supported here.",0.2,C++
13dya1e,jjnt5iq,"I considering use C++ alike generics or templates but for non O.O., I ignore if they are considered Sum Types, Product Types or other concept in Type Theory.",-0.125,C++
13dya1e,jjoalx0,"Both of these types would be declared by associating labels with types, as in C. Like C, the labels correspond to offsets from the begining of the structure, so order and label names definitely both matter.",0.0,C
13dya1e,jjo71qn,"The example from the [PureScript documentation](https://github.com/purescript/documentation/blob/master/language/Records.md) is:      type Lang l = { language :: String | l }          type Language = Lang ( country :: String )     -- equivalent to { language :: String, country :: String }  I'm curious how that differs / is related to the [equivalent in TypeScript](https://www.typescriptlang.org/play?#code/C4TwDgpgBAMghgOwOYB4YD4oF4oG8oA2iSArnEhAFxQDOwATgJbJQC+UAZLAFDeiSxiZCtkHIU+AMYB7EggYhqdJi1bpeMhHSgQAHnAC2YAlTGly0HLm5RbUGXIXUA5ACEASs4A0Nu0WTCps4ACgAq3tys3EA):      type Lang<L> = { language: string } & L          type Language = Lang<{ country: string }>          let example: Language = {       country: 'BR',       language: 'PT',     }  Besides the difference in syntax, are these example fundamentally different?",-0.03333333333333333,TypeScript
13dya1e,jjnpiko,"I believe this is the same reason for Go to require ordering, requiring equal names is probably to make it easier to implement.",0.0,Go
13dya1e,jjnpiko,"edit: Go probably requires equal names to make a more stable ABI too, you have guarantee of the offset for each field name.",0.25,Go
13dya1e,jjsuzz5,"Your language looks very interesting, the only other set-based language i know is SETL, but they treat sets the same way APL treats arrays: it's their default data type.",0.13125,APL
13dya1e,jjnstgp,"I've seen this syntax being used in Lua, Javascript and Setl, i tried to come up with a nice syntax like `hashmap.key` for those but found it too difficult to fit in a static language.",0.25,Lua
13dya1e,jjo3j42,">foo = StandardEuropeanItem with PortugeseModifications  That is very cool, i was thinking about implementing the same idea in my language, but similar to how C# does it: the `{label: value, ...}` is part of the `with` syntax, it doesn't accept arbitrary objects, your idea is a interesting generalization.",0.17099999999999999,C
13dya1e,jjo7sdq,"I do think C does that [to an extent](https://stackoverflow.com/questions/42411819/c-on-x86-64-when-are-structs-classes-passed-and-returned-in-registers), i'd have to look at compiler outputs to be sure, but i think LLVM has this type of optimization.",0.5,C
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,C
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,Go
13dya1e,jjoemnx,"So, TypeScript has intersection and union types, which is closely related to the subtyping approaches I had mentioned - I should have mentioned these types by name, and used TypeScript as an example!",0.0,TypeScript
13dya1e,jjo7r1f,It's a Ruby inspired smalltalk dialect.,0.0,Ruby
13dya1e,jjo7r1f,It is inspired directly by Ruby's own `Struct` and `OpenStruct`.,0.35,Ruby
13dya1e,jjoep28,"> I do think C does that to an extent, i'd have to look at compiler outputs to be sure, but i think LLVM has this type of optimization.",0.5,C
13dya1e,jjqtupl,"In TypeScript, when the right-hand side of an intersection contains the same key(s) as the left-hand side, there are some surprising results.",0.35,TypeScript
13dya1e,jjqtupl,"I don't know if this is a TypeScript bug or actually expected, but [this is an interesting example](https://www.typescriptlang.org/play?#code/PTAEEFQZwSwGzgT1AUwB4EMC2AHOKAaUAMwHsAnaAV3JQCgAXRHFUABVJgDsGBmUALygA3qDQAuUFypYARinJFEk6XIVEAXipnzKAX0bNWHbgwBMg9px78AZCNBapKAG4LQBuvgagc1vpImNpaiEqAAjEqSZpqS-HqgIKAA8gDSdHRJQeagGDgsGORQoAykoPKgMLikULCy+CVlAMakXFAM5FRNDJlgAJIA5AAmqGgs3SUAFqzEMEU+6Nh4rPJwpADuoOswDJOkVD4DGgON5axpXig+fqZmAPoYgf4WQqGSkaDKoBYJSS248FYCnIFEu12ed1kT1uITE7yi31ioHiiTA-xwgNQ5BB5AyQA)      // A silly example, for sure     type Point3 = { x: number, y: number, z: number }     type Point2 = Point3 & { z: never }          let point3: Point3 = { x: 1, y: 2, z: 3 } // OK          // Point2 appears to be impossible to construct     // I'd expect the first example below without 'z' to be OK     let point2_a: Point2 = { x: 1, y: 2 } // compile error     let point2_b: Point2 = { x: 1, y: 2, z: 3 } // compile error  I feel like the row polymorphism example may be easier to understand in general (after you get past the ""I've never seen this before"" stage), which is probably related to what you mentioned about it being easier to implement type inference for as well.",0.13717948717948716,TypeScript
13dya1e,jjo4q82,"One other approach is what is done in C#: `tuple.Item0, tuple.Item1, ..., tuple.ItemN`, which is much simpler than generating letter labels and also fixes the parsing problem.",0.037500000000000006,C
13dya1e,jjoai3d,"> One other approach is what is done in C#: `tuple.Item0, tuple.Item1, ..., tuple.ItemN`, which is much simpler than generating letter labels and also fixes the parsing problem.",0.037500000000000006,C
13dv591,jjmg245,"I believe Python has a single integer type from the users perspective, but automatically promotes numbers as needed in the backend.",-0.07142857142857142,Python
13dv591,jjmg245,"That said, one type change that isn't as clear, division in Python 3+ between two integers will always produce a float.",0.10000000000000002,Python
13dv591,jjoupvy,"Originally, C designers used to change all integers values into integer, for operations.",0.375,C
13dv591,jjoupvy,"In C, both values were converted into signed integer bigger size ""integer"".",0.0,C
13dv591,jjpkb9p,You could take the JavaScript approach and decide that all numbers are double-precision floating point.,0.0,JavaScript
13dv591,jjpkb9p,"If you choose the latter alternative, then you'll probably want an analogue to Python's `struct` module for dealing with explicitly-sized binary data.",0.0,Python
13dv591,jjqmtvf,With a language like Python the transition is seamless.,0.1,Python
13dv591,jjuccq2,"To be fair, I once tested some computationally-heavy algorithms (I can't recall the specific use case now) written in Java with a version using the int type, and a version using the long type.",0.21666666666666665,Java
13dv591,jjuu3hg,"C for example typically uses a default 32-bit `int` type, literals are 32 bits and expressions are widened to 32 bits for evaluation, even if the operands are 8 or 16 bits.",-0.16666666666666666,C
13ds7sy,jjm3dli,See C++.,0.0,C++
13ds7sy,jjm3dli,Look at Rust.,0.0,Rust
13ds7sy,jjm3dli,You set the edition for your project and the code will run forever because it can just disable the newer features and use an old version of Rust.,0.1,Rust
13ds7sy,jjm3dli,"In the future, I can use the upcoming 2024 edition of Rust with crates that were made with the 2018 version.",0.0,Rust
13ds7sy,jjm3dli,"Rust isn't technically backwards compatible, but because the tooling is good, it doesn't matter; in essence it *is* backwards compatible.",0.35,Rust
13ds7sy,jjm3dli,"And heck, even Python when used with pip, pyenv, and virtualenv, which still isn't as good as cargo, allows you to run old code without much hassle.",0.3333333333333333,Python
13ds7sy,jjm3dli,"So basically what I'm saying is backwards compatibility, if defined as being able to use old code in an unmodified state for many years, is very very important, but backwards compatibility, if defined in terms of implementation - the language itself a la C++, is going to hold you back, and you should put your dev time into a good package manager which, if done right, should give you that first kind of backwards compatibility for free a la Rust.",0.38557142857142856,C++
13ds7sy,jjm3dli,"So basically what I'm saying is backwards compatibility, if defined as being able to use old code in an unmodified state for many years, is very very important, but backwards compatibility, if defined in terms of implementation - the language itself a la C++, is going to hold you back, and you should put your dev time into a good package manager which, if done right, should give you that first kind of backwards compatibility for free a la Rust.",0.38557142857142856,Rust
13ds7sy,jjmzmn1,"For example, the C++ std::string transition in GCC 5 is somewhat handled by `abi_tag` but that requires a bunch of manual work which better tools would've done for us.",0.5,C++
13ds7sy,jl9f972,Programs in R are probably quite extreme in that they are often treated as a short-term sratchbook.,-0.125,R
13djghc,,"The idea is that the program acts as, essentially, a compilation script for itself, allowing for Python-like flexibility at compile time with the runtime performance of C++.",0.0,C++
13djghc,,"On the one hand, I do like Rust's style of passing by move-value by default.",0.0,Rust
13djghc,,"Ideally, I want the core part of the language to only contain the elegant bare minimum, and the rest of the language to be implemented as part of the standard library (the way Python does it).",0.29,Python
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,C++
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,Rust
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,Python
13djghc,jjlumgt,"Call me old school, but I've always appreciated Java's everything is a reference and references are passed by value.",0.15000000000000002,Java
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,C++
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,Rust
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,Python
13djghc,jjplij0,C++ templates are Turing complete.,0.1,C++
13djghc,jjplij0,I imagine Rust macros probably are too.,0.0,Rust
13djghc,jjplij0,And of course Python has `eval` and the various introspective bits.,0.0,Python
13djghc,jjno1oi,"Most mutable parameters should have Rust's ""borrow"" semantics, which are marked by an \`@\` at both declaration and use:      /fn inc @v[#Var #I32] => @v.update (x => x+1)          @my_var << /var 42[#I32]     /do inc @my_var     /do @os.stdout.write_line ""updated value is {my_var.get}""  Ownership transfer of resources is also available.",0.3333333333333333,Rust
13djghc,jjm4oot,"In general, I don't want to force a garbade collector, so object ownership and lifetimes are handled akin to C++ and Rust.",0.05000000000000002,C++
13djghc,jjm4oot,"In general, I don't want to force a garbade collector, so object ownership and lifetimes are handled akin to C++ and Rust.",0.05000000000000002,Rust
13djghc,jjlv9jy,"Python does the same thing, and I like it, but as you've said, it isn't appropriate without a garbage collector",0.25,Python
13djghc,jjpmeru,"To be honest, you can already do pretty much that in Python.",0.35000000000000003,Python
13djghc,jjpmeru,"My approach is just a bit more formal, with a stricter type system and some neat things that can't be conveniently implemented in Python (like traits and macros).",0.5,Python
13djghc,jjnzh50,Immutable reference is not the same as C's const-reference.,0.0,C
13djghc,jjplslr,The issue was that I basically want the same code to be viable as a constexpr (in C++ terms) function.,0.0,C++
13cyl98,jjiznr3,"Examples are ""C"" array, union, enum, or ""Pascal"" file of, set of.",0.0,C
13cyl98,jjiznr3,"Examples are ""C"" array, union, enum, or ""Pascal"" file of, set of.",0.0,Pascal
13cyl98,jjiznr3,"Of course, ""C"" types like ""int"", ""uint*"" or ""Pascal"" types like ""byte"" or ""integer"" are subitems of ""Integer"".",0.0,C
13cyl98,jjiznr3,"Of course, ""C"" types like ""int"", ""uint*"" or ""Pascal"" types like ""byte"" or ""integer"" are subitems of ""Integer"".",0.0,Pascal
13cyl98,jjiznr3,"The hierarchy starts with a conceptual abstract root type item, like C# or Java ""object"", but also applied to simple types, not just classes.",0.0,C
13cyl98,jjiznr3,"The hierarchy starts with a conceptual abstract root type item, like C# or Java ""object"", but also applied to simple types, not just classes.",0.0,Java
13caf1f,jjq3l8y,Pascal P-Code is surprisingly elusive to track down.,0.2722222222222222,Pascal
13caf1f,jjsm70h,"The story goes that the original Pascal compiler was written in Pascal to begin with, and then manually (painstakingly) compiled to P-code.",0.375,Pascal
13caf1f,jjsm70h,"Because Pascal is designed for one-pass compilation, it's also entirely possible that partial versions of the compiler might have generated code for other parts.",-0.075,Pascal
13caf1f,jjkwszk,"But I can generate renderings of sources in C, or my ASM (or now PCL), and work from those if need be.",0.0,C
13caf1f,jjtbzwj,I haven't actually used Pascal since I was at college in the late 70's.,-0.15,Pascal
13caf1f,jjtbzwj,"But then I tracked down what I believe are the actual [sources](http://pascal.hansotten.com/px-descendants/dec-pdp-10-pascal-compiler/) for Pascal on PDP10, and the main compiler is 12Kloc (plus a 4Kloc file for the library.",0.0037037037037036904,Pascal
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,JavaScript
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Kotlin
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Swift
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Rust
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Go
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Elixir
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Java
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Haskell
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Scala
13c53kf,jjecylm,"It's at the point where [some say a language isn't suitable for production if it doesn't have good multicore support](https://news.ycombinator.com/item?id=35852321#unv_35855074) (also see Rust speeding through getting async/await *even though they already had `Send + Sync`*, and looking to add async traits).",0.625,Rust
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,Python
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,C++
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,C
13c53kf,jjecylm,"This is what TypeScript is: you have some typed values and untyped values, and want to verify and possibly optimize the typed code while permitting the untyped code; thus, the user is able to take an existing untyped codebase and ""gradually"" add types.",0.25,TypeScript
13c53kf,jjecylm,"Besides JavaScript/TypeScript, you'll find gradual typing on pretty much any other popular untyped language including [Python](https://docs.python.org/3/library/typing.html), [Lua](https://github.com/andremm/typedlua), and [Racket](https://docs.racket-lang.org/ts-guide/).",0.23125,Python
13c53kf,jjecylm,"Besides JavaScript/TypeScript, you'll find gradual typing on pretty much any other popular untyped language including [Python](https://docs.python.org/3/library/typing.html), [Lua](https://github.com/andremm/typedlua), and [Racket](https://docs.racket-lang.org/ts-guide/).",0.23125,Lua
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,TypeScript
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,Kotlin
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,Swift
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,Rust
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,Haskell
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,TypeScript
13c53kf,jjecylm,"Rust has them and is doing great, Haskell has implemented them as a “new experimental”-kind of thing.",0.40909090909090906,Rust
13c53kf,jjecylm,"Rust has them and is doing great, Haskell has implemented them as a “new experimental”-kind of thing.",0.40909090909090906,Haskell
13c53kf,jjecylm,"Other languages are looking to incorporate some variant or alternative to Rust’s borrowing rules: [Mojo (the hyped-up “AI” language) includes them](https://docs.modular.com/mojo/programming-manual.html#argument-passing-control-and-memory-ownership), and [Val-lang](https://www.val-lang.dev/) has mutable value semantics which are similar.",-0.2916666666666667,Rust
13c53kf,jjecylm,[Swift has first-class “actors” and “distributed” methods](https://www.swift.org/blog/distributed-actors/).,0.0,Swift
13c53kf,jjecylm,"[Unison](https://www.unison-lang.org/), Erlang, and Elixir are built with distributed being one of the #1 concerns.",0.0,Erlang
13c53kf,jjecylm,"[Unison](https://www.unison-lang.org/), Erlang, and Elixir are built with distributed being one of the #1 concerns.",0.0,Elixir
13c53kf,jjecylm,"Scala has [Akka](https://akka.io/) and is used WIDELY for distributed); whereas something like linear types and typed effects, you can't emulate in a library.",-0.1,Scala
13c53kf,jjecylm,"People are also working on Effect systems for Haskell ([eff](https://github.com/hasura/eff), [fused-effects](https://hackage.haskell.org/package/fused-effects), [effet](https://hackage.haskell.org/package/effet)).",0.0,Haskell
13c53kf,jjecylm,This is *not* in most general-purpose programming languages and probably never will be (maybe we'll see formal methods to verify unsafe code in Rust...) because it's a ton of boilerplate (you have to help the compiler type-check your code) and also extremely complicated.,-0.033333333333333326,Rust
13c53kf,jjecylm,Google’s compiler works on C++.,0.0,C++
13c53kf,jjfpibn,We're seeing a lot of work in the formal methods area and it's what I'm most excited about for existing languages -- projects like RefinedC that add refinement types and ownership types to C (using [[attributes]]...) and using them to automatically generate a proof of program correctness by guided search using the language semantics to tip off the search.,0.4375,C
13c53kf,jjfpwd6,"Rust demonstrating that there can be memory safety without runtime garbage collection seems like a big deal, and I would expect more languages to use similar systems, but try to require less information from the programmer (lifetime specifiers etc).",0.08333333333333334,Rust
13c53kf,jji6y27,"Ada had full typing (you can do gradual too), tasking and distributed (in an annex) from the start.",0.35,Ada
13c53kf,jjlczgs,"For me, I am hoping for an APL revival; all of what Python/numpy/AI is doing are APL but very verbose.",0.2,APL
13buw08,jjdosl4,\- Reference capabilities similar Rust borrow checker but expanded.,0.0,Rust
13buw08,jjdosl4,"\- Data sharing with actors without (necessarily)  copying all the data (like Erlang, if I understand this correctly) .",0.0,Erlang
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,Python
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,C
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,C++
13bodyk,jjeo08u,"I actually mad a trick to extend sealed classes in C# and Java ( Decorator Software Pattern), like stringbuilder class  * It's very good your P.L.",0.14249999999999996,C
13bodyk,jjeo08u,"I actually mad a trick to extend sealed classes in C# and Java ( Decorator Software Pattern), like stringbuilder class  * It's very good your P.L.",0.14249999999999996,Java
13bodyk,jjg37oz,"Sorry,but I don't understand the first one,do you mean I should let people decided how the objects identifiers are named?,cuz i plan to let them to do that,it's just a something like snake_case for rust and PascalCase for C# By extending class,you can add methods that don't exist in that class,think of it like traits from rust or extensions from C# So I shouldn't add sealed classes?,I could do that,I thought it could be useful,so as stuff that shouldn't be inherited from should be sealed  Thanks for the compliments on props and access stuff,I also plan to add stuff like modules(similar to static classes from C#,but importing them automatically gives you the methods without the need to type of the static class name)",0.22749999999999998,C
13bodyk,jjdb0ur,"The tilde is a bitwise operator in C, it’s not some unused symbol like you’re saying.",0.0,C
13bfvx5,,"Users should be able to add their own IO by wrapping Charm around embedded Go, it shouldn't be something that can be done only by me by hard-wiring stuff.",0.3666666666666667,Go
13bfvx5,,Charm is a [Functional Core/Imperative Shell language](https://github.com/tim-hardcastle/Charm/blob/main/docs/functional-core-imperative-shell.md).,0.0,Shell
13bfvx5,,"If there's a Go library for talking to something, it's a work of minutes for anyone who pleases to write their own `get` and `put` and `post` and `delete` commands for accessing it.",0.6,Go
13bfvx5,jjb2ep3,Can you elaborate on how this differs from Haskell's use of the IO monad?,0.5,Haskell
13bfvx5,jjb2ep3,Your `get` is very similar to the `x <- readFile ...` notation of Haskell's `do`-notation (which is sugar for the `>>=`operator).,0.0,Haskell
13bfvx5,jjb2ep3,"Haskell has nothing corresponding to `put`, `post` or such things - that's usually just done by IO actions that return a unit value.",-0.125,Haskell
13bfvx5,jjb2ep3,"Haskell's IO model is not perfect, mostly in that it is not possible to limit exactly *which* kinds of IO are possible, but it is probably the most widely used system that delimits pure and impure code in a principled manner.",0.10803571428571429,Haskell
13bfvx5,jjbkire,"You don't even really need a wrapper language, you can kinda just choose to write a functional subset of Go.",0.2,Go
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,Python
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,Java
13bfvx5,jjbi0mq,>Can you elaborate on how this differs from Haskell's use of the IO monad?,0.5,Haskell
13bfvx5,jjbi0mq,I'm not a big expert on Haskell.,0.0,Haskell
13bfvx5,jjbi0mq,The way they are *similar* is that Charm and Haskell are both functional languages dealing with how you do IO.,0.0,Haskell
13bfvx5,jjbi0mq,Whereas I couldn't give you a detailed breakdown of how Haskell monads work but I'm sure it isn't like that.,0.45,Haskell
13bfvx5,jje7e1m,Am I wrong or does this look like Haskell IO monad in disguise?,-0.5,Haskell
13bfvx5,jjchhqy,"You can do the same in Haskell if you are in IO:      main :: IO ()     main = do         myVar <- newIORef ""foo""         modifyIORef myVar (<> ""bar"")         putStrLn =<< readIORef myVar // prints `foobar`  The IORef could be imported from somewhere else.",0.1111111111111111,Haskell
13bfvx5,jjbooxw,I'd rather write Charm than Go any day :-),0.5,Go
13aobtm,,"I am gravitating towards `!` because I am most familiar with C#, Java and other curly-brace languages.",0.25,C
13aobtm,,"I am gravitating towards `!` because I am most familiar with C#, Java and other curly-brace languages.",0.25,Java
13aobtm,,": {""Alice"", ""Bob""}  Eew!",-0.9375,Alice
13aobtm,,"This looks a lot better (IMO):      name ~: {""Alice"", ""Bob""}  So I am torn: Should I go for familiarity (least surprise) `!` or for aesthetics `~` or some other option?",-0.1875,Alice
13aobtm,,"(Length >= 1 && Length <= 30)          // The set of names already taken     TakenNames = allowableNames && { ""Alice"", ""Bob"" }          // The set of allowable names that are not taken     AvailableNames = AllowableNames & !TakenNames           // A ""variable"" of the type (member of the set)     myNewName : AvailableNames  The definition of `AvailableNames` uses the complement of `TakenNames`.",0.0,Alice
13aobtm,jj8wkn4,I’m seeing a lot of “Do what C does” in the comments.,0.0,C
13aobtm,jj7vjo2,My philosophy is to do what C does unless I have a good reason not to.,0.7,C
13aobtm,jj8gnji,And why use a symbol at all: even C allows you to use `not` and `compl` for `!` and `~` respectively.,0.0,C
13aobtm,jj8hy7s,"A story that might be illuminating: in Lua, the ""not equals"" operator is `~=` instead of the C-style `!=`.",0.0,Lua
13aobtm,jj8hy7s,"The reason for this is that Lua was created in Brazil, and [the portuguese keyboard](https://cdn.shopify.com/s/files/1/0810/3669/files/portuguese-brazilian-abnt2-mac-kblayout-unilingual-2021.png) has a tilde on the home row of the keyboard (where the apostrophe/quote key is on a QWERTY keyboard).",0.0,Lua
13aobtm,jj9b6od,Given that you have a focus on sets and describe your language as  >  a logic programming language based on set theory  I'd probably stray away from your typical C syntax and try to design it more intuitively for that domain.,0.16666666666666669,C
13aobtm,jj9gd6e,"C has `~` for bitwise NOT (`!` for logical NOT), so it’s still familiar to most people.",0.375,C
13aobtm,jm6akjc,i use “~” (because my language only has bitwise negation and that’s what C uses for that) but it’s kind of ugly for booleans,-0.033333333333333326,C
13aobtm,jj89827,"The only reason C has two operators, `!` and `~` is because it has no built-in boolean type.",0.0,C
13aobtm,jj87se6,"The symbol abuse in C and its subsequent proliferation in C-derived programming languages is a silly convention established because of the lack of a sufficient number of symbols in early character sets, and some misguided desire to avoid spelling things out with reserved words like ""not"", ""NOT"", or "".NOT."".",-0.13333333333333333,C
13aobtm,jj8goe0,"After seeing Rust’s janky syntax, just don’t.",0.0,Rust
13aobtm,jj844lv,> My philosophy is to do what C does unless I have a good reason not to.,0.7,C
13aobtm,jj8l2gl,Go figure.,0.0,Go
13aobtm,jj8k7ly,> And why use a symbol at all: even C allows you to use not and compl for !,0.0,C
13aobtm,jj8k7ly,I had no idea C had support for operators as words!,0.0,C
13aobtm,jj8j027,"For example, ALGOL was pretty agnostic about the exact syntax details, letting you use beautiful mathematical operators in print, but also letting you type those operators in a way that actually works on your keyboard.",0.27,ALGOL
13aobtm,jj8j027,"Similarly, C's digraphs.",0.0,C
13aobtm,jj8j027,"Similarly, there have been programming languages that invented entirely novel operators, requiring custom keyboards – notably APL.",0.16666666666666666,APL
13aobtm,jj8j027,"Such a language would not catch on nowadays, and APL's modern incarnation in the form of J has [thankfully ASCIIfied the syntax](https://code.jsoftware.com/wiki/APL2JPhraseBook).",0.1,APL
13aobtm,jj8hbnm,"The ONLY “symbol abuse” in C is that declaring and dereferencing pointers both use the asterisk, that was a bad move and I wish that was different.",-0.23333333333333328,C
13aobtm,jj8juj3,Rust introduced very little novel syntax.,-0.24375000000000002,Rust
13aobtm,jj8juj3,The rest is just a fairly bog-standard ML-family language dressed up to look like C++.,0.7,C++
13aobtm,jj87lca,"I also have good reasons, but it also means your language learning materials need to cover integer operators instead of saying “look at C”.",0.7,C
13aobtm,jj8ubo8,Rust has proven that it causes no end of confusion to do that.,0.0,Rust
13aobtm,jj8ubo8,Stick very close to C for symbolic operators.,0.2,C
13aobtm,jj8ubo8,"Don't be afraid to add new *keyword* operators, like Python has `is`, `in`, and `not in` (the last is actually two keywords!)",-0.1159090909090909,Python
13aobtm,jj858k3,JavaScript.,0.0,JavaScript
13aobtm,jj8a65i,You could look at how Julia does it.,0.0,Julia
13aobtm,jj9c1dr,APL family and Smalltalk does not have any precedence.,0.0,APL
13aobtm,jj9c1dr,"Again, APL family has strict right-associativity, which simplifies stuff a lot.",0.0,APL
13aobtm,jj8m6dk,When C and it's operators where designed there wasn't a boolean type.,0.0,C
13aobtm,jj8jz7a,"C may have a bool, but it is not disjoint from integers.",0.0,C
13aobtm,jj8kyth,APL uses keystrokes these days to make those characters.,0.0,APL
13aobtm,jja07bs,"Bro, fn instead of the return type, with the return type on the far right like C++ invented as alternative syntax in C++11  may not technically be inventing new syntax, but it’s still violates the principle of least surprise, which is my entire point.",0.037012987012987004,C++
13aobtm,jj9314v,Genuine comment : how does one type APL at a reasonable pace on a normal keyboard ?,0.25000000000000006,APL
13aobtm,jj93ijz,"Scriptsprog som HyperTalk og MPW Shell brugte mange af disse symboler, og jeg oplevede aldrig at det danske tastatur var et problem, ikke engang i C, selv om ""{}"" var Option-Shift-""("" og "")"", fordi ""\["" og ""\]"" var Option-""("" og "")"", hvilket for såvidt er en ganske fornuftig og logisk placering,som de temmelig sikkert stadig har.",0.0,Shell
13aobtm,jj93ijz,"Scriptsprog som HyperTalk og MPW Shell brugte mange af disse symboler, og jeg oplevede aldrig at det danske tastatur var et problem, ikke engang i C, selv om ""{}"" var Option-Shift-""("" og "")"", fordi ""\["" og ""\]"" var Option-""("" og "")"", hvilket for såvidt er en ganske fornuftig og logisk placering,som de temmelig sikkert stadig har.",0.0,C
13aobtm,jj9mes5,"Your language learning materials should never say ""look at C"".",0.0,C
13aobtm,jj8m0l2,Sometimes one would think that C had been deliberately designed to insultingly annoy countries that do not have English as the primary language.,-0.19999999999999998,C
13aobtm,jj8m0l2,"And no, as far as I can tell/recall (I began studying/using C in 1986-87), no European programmer ever asked for trigraphs, I think it was rather the opposite.",0.03333333333333333,C
13aobtm,jj9w14l,"Such a low precedence for the former I think is unsuitable for bitwise manipulations, and there is also no reason for the latter to have different precedences across `and or xor` (I know C thinks otherwise).",0.0,C
13aobtm,jj9w14l,"My symbols for these ops are:                 type      precedence          not        logical     and                  5, say (I'd have to go and check)     or                   6 (both and,or short-circuit)          inot       bitwise     iand                 3 (same as + -)     ior                  3     ixor                 3  (I can't remember exactly where `iand` etc came from; it might have been from Fortran.",0.041666666666666664,Fortran
13aobtm,jjb9a9e,C's syntactic innovation that declaration looks like use has been generally considered to be a mistake.,0.05000000000000002,C
13aobtm,jjb9a9e,"This is real C code, written by real C programmers:      int (*(*(foo)(int))(double))(float);  Many curly-brace languages have deviated to some degree from that madness, separating the type syntax more clearly from the expression syntax (and often, disallowing function pointers).",0.3,C
13aobtm,jjb9a9e,"In that regard, Rust's syntax for types and functions is entirely mainstream with contemporary languages, *in particular if you note that it's mostly an ML-family language dressed up with curly braces*.",0.20833333333333331,Rust
13aobtm,jjb9a9e,"Since we're in r/ProgrammingLanguages, I'd also like to point out that C style circumfix declarations have a lot of local ambiguity, so you need to parse the entire declaration in order to know what it is (compare also the [""most vexing parse"" in C++](https://en.wikipedia.org/wiki/Most_vexing_parse)).",0.16666666666666666,C
13aobtm,jjb9a9e,"Since we're in r/ProgrammingLanguages, I'd also like to point out that C style circumfix declarations have a lot of local ambiguity, so you need to parse the entire declaration in order to know what it is (compare also the [""most vexing parse"" in C++](https://en.wikipedia.org/wiki/Most_vexing_parse)).",0.16666666666666666,C++
13aobtm,jjb9a9e,"In C, this strongly pushes you towards LR style parsers.",0.4333333333333333,C
13aobtm,jjb9a9e,"In C++, the parser also needs to track a symbol table, potentially requiring the evaluation of templates during the parse.",0.0,C++
13aobtm,jjb9a9e,"In contrast, Rust's syntax makes it possible to clearly separate syntax and semantics in the compiler (at the cost of needing the turbofish `::<T>()` pseudo-operator).",0.05000000000000001,Rust
13aobtm,jj9lkqg,Special APL keyboards have the symbols written on the keys (in addition to regular letters) and an APL mode switch.,0.17857142857142858,APL
13aobtm,jj8kxv9,"Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",-0.08571428571428572,R
13aobtm,jj8kxv9,"Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",-0.08571428571428572,APL
13aobtm,jjgeymw,Raku (and Perl) is really something different.,0.1,Perl
13aobtm,jjbxx6a,"I imagine people just don't like the C++ syntax, but it's a very valid point that applies to real generics as well.",0.2,C++
13aobtm,jj8rzss,"Having coded a lot of Prolog, one of the issues I found was that it was pretty hard to use another search strategy than the default depth-first search.",-0.020833333333333343,Prolog
13aobtm,jj8rzss,":-)      \> Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",0.10952380952380954,R
13aobtm,jj8rzss,":-)      \> Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",0.10952380952380954,APL
13aobtm,jjbhqtm,"Yes you can have finer graduations, but then you end up with a scheme like C's with far too many levels, many arbitrary and unintuitive, which nobody can remember and you end up just using parentheses anyway, so that there was no point.",0.25,C
13a4id1,jj5kfw3,"Rust's `fn index_mut<T>(vec: &mut Vec<T>, index: usize) -> &mut T`; if you want to be able to write      list[index] = 5;     return list;  (or, with less syntax sugar)      *list.mut_at(index) = 5;     return list;  then you need to go from having a `&mut Vec<i32>` to a `&mut i32` with `list[index]` and then go back to having the original `Vec<i32>` so that you can return it.",0.17708333333333334,Rust
13a4id1,jj5kfw3,"Rust manages this with lifetime annotations (where in safe Rust, the borrow checker ensures that mutable references cannot alias anything else).",0.5,Rust
13a4id1,jj5kfw3,"Val fixes this essentially by using continuation passing for indexing; the Rust equivalent would be essentially      list.with_mut_at(index, |item: &mut i32| {       *item = 5;     });  and now *this* works, and is just as flexible, since e.g.",0.0,Rust
13a4id1,jj5kfw3,"A more practical example would be (just like Rust's `Mutex`) you could define a `Mutex<T>` where you write `mutex.unlock[]` to get a (mutable reference to) the item inside, which will automatically wait to lock it and unlock the mutex when you no longer use the result.",0.5,Rust
13a4id1,jj7o69w,"If you go the Rust route and have &unique references, you can internally modify them all you want without aliasing anything externally  Rust has aliasing, but if you just disable it people would just do      string1 = strip(arg);     string2 = escapeHTML(string1);  it wouldn't actually be so bad in Rust's case, a minor inconvenience",-0.07499999999999997,Rust
13a4id1,jj8z4ep,"Hence, Rust uses borrow checking by annotating all (mutable) references with lifetimes.",0.0,Rust
139jnyx,,"You either have to set a mask then OR with the mask then XOR, something like this in C:      int bitwise_not(int num) {         // Create a mask with all bits set to 1         int mask = (1 << (sizeof(int) * CHAR_BIT - 1));         mask |= mask - 1;         // XOR the input number with the mask to get its bitwise NOT         return num ^ mask;     }  --- Why do I have to avoid unary operator?",-0.75,C
139jnyx,jj50f27,"Haskell also uses concatenation for function application, but it is higher precedence than arithmetic operators:  * your first example is written `fn1 a 123 65.7` as above * but your second case needs parens:  `fn1 a (123 + 456) (65.7 * 345)` * and unary operators use the same: `fn1 a (123 + 456) (- x)`",0.1,Haskell
139jnyx,jj6c4tu,"In Haskell, all operators are unary.",0.0,Haskell
139jnyx,jj6c4tu,"In Forth, words can operate on some fixed number of arguments.",0.1,Forth
139jnyx,jj6bay4,Doesn't Julia do this?,0.0,Julia
13993w0,,"I started learning Python, which is probably a good skill to have, but its feature set where manipulating raw bits is concerned seems to be ... lacking.",0.2346153846153846,Python
13993w0,jj2isii,"It seems like you are looking for an array programming language like APL, J, BQN, or, since you mentioned Python, Numpy.",0.0,APL
13993w0,jj2isii,"It seems like you are looking for an array programming language like APL, J, BQN, or, since you mentioned Python, Numpy.",0.0,Python
138yw57,jj0h18t,Write a Forth.,0.0,Forth
138yw57,jj356qn,Maybe take a look at Scheme in 48 hours and expand upon that.,0.0,Scheme
138yw57,jj0e2m6,You can investigate Racket — which was once called PLT Scheme (PLT stands for programming language theory).,0.0,Scheme
138yw57,jj0e2m6,It’s a variant of Lisp that is tailor-made for such a project.,0.0,Lisp
138yw57,jj0e2m6,Common Lisp might be another good choice.,0.19999999999999998,Lisp
138yw57,jj0i4m7,"Python: print(""hello, world!"")",0.0,Python
138yw57,jj0i4m7,"C:   #include <studio.h>  float GPA= 4.0;  int main(){     printf(""hello, world!",0.20833333333333331,C
138yw57,jj0i4m7,"Take structs in C, and make everything a struct.",0.0,C
138yw57,jj1n7c6,"And also i learned C (primary lang ) language, Assembly (NASM for linux) deeply.",0.2,C
138yw57,jj1n7c6,"And also i learned C (primary lang ) language, Assembly (NASM for linux) deeply.",0.2,Assembly
138yw57,jj2u03a,"It's so well written, you can follow the explanation and decide whether you want to do it in Java as the book (at least for the tree-walking interpreter) or in another programming language.",-0.3,Java
138yw57,jj0pjce,"Yes, so far it looks like I will read the Crafting Interpreters to get the basics in hand and make some POC, look at Forth, Racket and LLVM, then consider the scope of application and get to it.",0.1,Forth
138yw57,jj0pjce,"So far Im very excited about it, will be tough for sure, but wouldnt be fun if it wasnt :D",0.33310185185185187,D
138yw57,jj0p2n8,"> > Python: print(""hello, world!"")",0.0,Python
138yw57,jj0n2qb,Forth is a stack-based programming language family/environment.,0.0,Forth
138yw57,jj0n2qb,I wrote a Forth as part of my degree's first year end project.,0.25,Forth
138yw57,jj0o686,"But fair enough, not everyone likes Lisp.",0.35,Lisp
138yw57,jj1w2id,If you are serious about PL design you absolutely need to look into a Scheme and Racket is amazing for writing languages.,0.15555555555555559,Scheme
138yw57,jj0sopn,That's Lisp.,0.0,Lisp
138yw57,jj0sopn,"Obviously as a class project you're not looking to invent the next C, but why not illustrate the potential?",0.0,C
138yw57,jjldxzm,"You can go down the rabbithole as far as you want with a Forth; making it on LLVM, making your own VM etc.",0.18148148148148147,Forth
138yw57,jj14jyg,> That's Lisp.,0.0,Lisp
138yw57,jj11oui,"Anyway, I actually had the idea originally as an esolang, where everything is a C struct.",0.1875,C
138swus,jj1g3jp,"I use [Asciidoctor](https://asciidoctor.org/), [highlightjs](https://highlightjs.org/), a custom highlight.js language definition and that bash script:      #!/bin/bash     asciidoctor spec.adoc     ex spec.html <<eof     11 insert     <link rel=""stylesheet"" href=""https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/routeros.min.css"">     <!-- other hljs definitions I need (C, x86asm, etc..) -->     .",-0.125,C
138swus,jj1g3jp,"(The seemingly useless removing-then-rewriting conums at the end is necessary because Asciidoctor writes annotations as HTML in the code to display, prompting highlight.js to fill your console with ""unescaped HTML"" security warnings).",-0.25,HTML
138swus,jj90o98,"The easiest might just be to give your lexer the ability to turn a token stream into HTML, which you can then style with CSS.",0.0,HTML
138swus,jj90o98,"Even better, add multiple output format support: HTML, LaTeX, Markdown, etc.",0.25,HTML
138swus,jjdem9s,"](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site)  Alternatively, you can make the lexer output HTML, render the HTML into an image (pretty much just open it in a browser and take a screenshot), then paste the image in your README.",0.15,HTML
13872od,jj0xhrh,"Not an objective metric, but a while back I had to implement parsers for a number of languages, and for testing I created a ""stress test"" file for each language ([Lua example](https://github.com/boppreh/structured-editor/blob/master/test_files/full.lua)).",0.0,Lua
13872od,jj0xhrh,"- Whether it's a keyword or symbol heavy language, and family type (C, Lisp, something exoteric).",-0.2,C
13872od,jj0xhrh,"- Whether it's a keyword or symbol heavy language, and family type (C, Lisp, something exoteric).",-0.2,Lisp
13872od,jj0xhrh,- Surprising rules (I learned some hideous tricks in Python that come in handy when golfing).,0.6499999999999999,Python
13872od,jizsh74,"There are languages that just embed SQL, Prolog or Assembly, which, as features, are not really ""big.""",0.0,Prolog
13872od,jizsh74,"There are languages that just embed SQL, Prolog or Assembly, which, as features, are not really ""big.""",0.0,Assembly
13872od,jizsh74,"To work with my language I have a 1478 lines long highlighting grammar file, of which 985 lines are dedicated to x86-64 Assembly alone; that's 66% of `cmova`, `cmovae`, `cmovb`, `cmovbe` and their friends.",-0.05,Assembly
13872od,jizsh74,C# in other words.,-0.125,C
13872od,jj08b1h,"|Language | [Ecstasy](https://github.com/xtclang/) language| |:--|:--| |Target | Interpreter, JVM bytecode (wip), LLVM IR and WASM (planned)| |EBNF | yeah| |AST node types | 95| |Compiler & runtime | 272 kloc (mostly Java, some C, some Ecstasy)| |Class libraries | 119 kloc (pure Ecstasy)| |Tests | 11 kloc|",0.35714285714285715,Java
13872od,jj08b1h,"|Language | [Ecstasy](https://github.com/xtclang/) language| |:--|:--| |Target | Interpreter, JVM bytecode (wip), LLVM IR and WASM (planned)| |EBNF | yeah| |AST node types | 95| |Compiler & runtime | 272 kloc (mostly Java, some C, some Ecstasy)| |Class libraries | 119 kloc (pure Ecstasy)| |Tests | 11 kloc|",0.35714285714285715,C
13872od,jj17y5p,"| Language | [Sourcerer](https://gitlab.com/cal-coop/utena/haaden-two/-/tree/master/Code/Sourcerer) | |--|--| | Target architecture | The [Utena VM](https://gitlab.com/cal-coop/utena/utena-specification/-/tree/new-spec) | | EBNF productions | 15 | | AST node types | 10 | | Compiler language | Common Lisp | | Compiler lines of code | 314 | | Tests | 203 lines, 13 unit tests |",-0.3,Lisp
13872od,jj1tgm0,"Much better than EBNF.| |AST Node Types|35| |Host Language|Python| |Implementation Code Size|About 2,500 lines of Python.",0.5,Python
13872od,jj0bztq,C is a P.L.,0.0,C
13872od,jj0bztq,"<edited>  Two keywords that I would like in C would be ""function"" or ""variable"", for function or variable declarations.",0.0,C
13872od,jj0bztq,Several C based P.L.,0.0,C
13872od,jj0bztq,"C designers did mentioned once, that they did considered add them, but rejected them, due it was required C programs to be as short as possible.",-0.041666666666666664,C
1378d15,jisdcgg,> We have a short bus that fetches old ladies from the home to teach our young whipper-snappers to maintain the COBOL systems those same ladies wrote before the Hula Hoop was cool.,0.11000000000000001,COBOL
1378d15,jivvvee,Async/await (at least in Rust) can be used to make a single-threaded solution but it is ugly because async/await is more complex than necessary yet lacks some of the desired functionality.,-0.16,Rust
1378d15,jisjvrr,"With checked-exceptions *as in Java*, the inject-ee appears to need static annotations about things which are not its proper concern.",0.25,Java
1378d15,jiy3cg9,"From this page:  > Haxl is a Haskell library that simplifies access to remote data, such as databases or web-based services.",0.13333333333333333,Haskell
1378d15,jisptp1,I just believe Java gets it wrong by enforcing the checking in the wrong place.,-0.5,Java
1378d15,jitztib,I have found Clojure’s dynamically scoped Vars to be very useful for dependency injection and for mocking effectful functions during testing.,0.39,Clojure
1378d15,jitrppl,"Additionally, if you do it the Rust way you force checking all exceptions.",0.0,Rust
168jxwq,,"But the thing is, we have a PHP setup where data is grabbed from the client passed to the server.",0.0,PHP
168jxwq,,The PHP runs some SQL and passes a result back to the client.,0.0,PHP
168jxwq,jyw8bax,I suggest taking this to a PHP forum.,0.0,PHP
168jxwq,jyw8bax,There's probably an idiomatic way to do this in PHP that would be quite easy to use.,0.43333333333333335,PHP
1686ysr,jyvzcvf,"This is exactly equivalent to python's generators, using `def __call__(self, x=None): return self.send(x)` (Python doesn't need both `.send` and `.__next__` calls).",0.25,Python
1686ysr,jyv6bdb,Python's first official async implementation was all generators before it was given official syntax.,0.25,Python
167oefv,jyu88je,I think Forth.,0.0,Forth
167oefv,jyva39m,Assembly.,0.0,Assembly
167oefv,jyva39m,> java  Java does not let you do any of that.,0.0,Java
167oefv,jyva39m,Especially since everything in Lisp is an AST.,0.0,Lisp
167oefv,jyva39m,"(defn foo []         (println ""h""))     (defn main []         (do             (set-instr ""Ü"" (get-child 1 (get-child 1 foo)))             (foo))) ;prints funny German face     ;some Lisp I wrote one day  Also there are people who just invoke (if not embed) GCC in their programme and use it in JIT mode to modify things.",0.13888888888888887,Lisp
167oefv,jywr5qj,Lisp and assembly.,0.0,Lisp
167oefv,jywr5qj,Assembly lets you do anything the CPU allows.,0.0,Assembly
167oefv,jywr5qj,"On Lisp, you have hygienic macros.",0.0,Lisp
167oefv,jywr5qj,And domain-specific languages are normal in the Lisp world.,0.15,Lisp
167oefv,jyx8zi1,Lisp is one of the more moddable.,0.5,Lisp
167oefv,jyx8zi1,This carries over to Common Lisp.,-0.3,Lisp
167oefv,jyx8zi1,"This goes back to the mid 60s  * by default Common Lisp has a source interpreter and/or incremental compiler via the functions EVAL and COMPILE  * by default Common Lisp can load code at runtime via the function LOAD  * CLOS (the Common Lisp Object System) comes with open classes, before/after/around extensions, changeable class hierarchies, and on optional meta-object protocol to change the OOP implementation itself  It's not uncommon that a Common Lisp program might be compiled once for end users, delivered to the end user and then get tiny little loadable patches, which change/add/replace functionality of a running program.",-0.17875,Lisp
167oefv,jyx8zi1,"Let's check an example in CLOS, the Common Lisp Object System.",-0.3,Lisp
167oefv,jyxwznn,C# has very good modding tools and a lot of communities for modding games,0.9099999999999999,C
167oefv,jyu6zdj,"Lisp and various derivatives, definitely.",0.0,Lisp
167oefv,jyu6zdj,"Perl, because running and doing flips with your eyes closed while juggling multiple pairs of scissors is fun for the whole family.",0.1,Perl
167oefv,jyu6zdj,Ruby is another one to put on the list.,0.0,Ruby
167oefv,jyu6zdj,A lot of Ruby libs (like Rails) are based on the concept.,0.0,Ruby
167oefv,jyu6zdj,"Python, to some extent.",0.0,Python
167oefv,jyxz0g0,"Forth is definitely a language creation toolkit and has a very raw and punk/DIY flavor, but it's usually not very ""moddable"" in the sense the OP is talking about.",-0.13333333333333333,Forth
167oefv,jyxxhbx,So Lisp and the other Lisp?,-0.125,Lisp
167zsiv,,"def call_function(args:, globals:)       new_context = Dictionary.new(globals[:context].raw.dup)  where I used to do      def call_function(args:, globals:)       new_context = globals[:context].dup  And even before that I used to do      def call_function(args:, globals:)       new_context = globals[:context].deep_dup  My language is implemented in Ruby and the context is a Code::Object::Dictionary  Any help?",0.5,Ruby
167vd73,,Does such tool exist for C?,0.0,C
167vd73,jyszytw,"My favorite is [Lemon](https://compiler-dept.github.io/lemon/), which is very user friendly, generates good clean C code, and acknowledges modern concerns like threading (versus `yacc`).",0.3902777777777778,C
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,Go
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,Rust
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,Kotlin
166rij5,jynj02a,I'm implementing this in Rust.,0.0,Rust
166rij5,jymmzcj,"My toy* language:  * compiles to C  * based off C with modern features and tooling  * methods, generics, algebraic types, first class functions,    iterators, traits, built in strings  * null safety and intuitive error handling based off rust (Option, Result, ?",0.225,C
166rij5,jymmzcj,"operator, etc)  * tunable GC system, might also implement smart pointers, raw pointers available  * cut out as much UB as possible  * easy c library imports and bindings  thats my main goal, I have other ideas I would like to implement like pattern matching, lambdas, and closures but I can do without plus the implementation to C might not be straight forward.",0.13231456043956044,C
166rij5,jymmzcj,"From my research, it seems C is a bad backend unless there is a very close relationship to C. Methods are fine, iterators I think I have figured out, generics would be the most difficult but doable.",-0.01666666666666663,C
166rij5,jymmzcj,If anyone has any experience with C as a backend or any input on some possible pitfalls Id really like to hear.,0.1,C
166rij5,jymmzcj,One reason I want to compile to C is for easy bindings and to easily get the language from working to usable.,0.43333333333333335,C
166rij5,jyn42bu,"The C way is to just leave it to the user: a memory allocation IS a value in the form of a pointer, and you're responsible for fulfilling the promise of freeing it at some point.",0.2,C
166rij5,jyn42bu,"Python has the ""with"" clause which is nice but doesn't allow for interleaving things (A was created before B but we'd like to free it first) or returning the resource from a function or something.",0.4166666666666667,Python
166rij5,jylrwqk,A C compiler.,0.0,C
166rij5,jylrwqk,"I know, boring, but implementing it really made me appreciate compiler developers and I am learning a lot more about C, Rust (the language I am building it in) and low level programming.",-0.07500000000000001,C
166rij5,jylrwqk,"I know, boring, but implementing it really made me appreciate compiler developers and I am learning a lot more about C, Rust (the language I am building it in) and low level programming.",-0.07500000000000001,Rust
166f9gj,jyjdm4r,"* It had lvalue vs rvalue distinction * Conditional expressions `true -> E2, E3` means E2, `false -> E2, E3` means E3 * `E0 rep n` means E0 repeated n times `E0, E0, ... E0` * If Commands (but without else branch): `if E do C`, `unless E do C` * Test Commands: (just like if-then-else) `test E then C or C`, `test E ifso C ifnot C` * It already had a number of undefined behaviours * Let declarations: `let may be used to declare a set of mutually recursive functions and routines` * `There is no need for type declarations in the language, since the type of every variable is already known`",-0.26666666666666666,C
166er7n,,"So there's precondition/postcondition system like in Ada to help, and I guess you can also use proofs to ensure some specific operations can preserve good shape.",0.35,Ada
166er7n,jyjhs0g,"Side note: Common Lisp has these, and they are used in practice by some programmers.",-0.3,Lisp
166er7n,jyjxu27,My first introduction to such a system was [Clojure spec](https://clojure.org/guides/spec).,0.125,Clojure
166er7n,jyjxu27,"While it is very powerful, it: 1. checks entirely at runtime 2. is not Clojure's primary type system  IMO the best way to use it is to enable checking at dev / testing time, and then only enable checking the inputs / outputs of the system (eg HTTP request / response JSON) at runtime (which you are probably already doing).",0.358,Clojure
166er7n,jyjxu27,"IMO if a serious language was to be made employing predicates as the primary typing mechanism, it should: 1. check as much statically as possible, and assert the rest at runtime (java does this for array bounds checking for example, unlike dependently typed languages that can check bounds at compile time) 2. have a good polymorphism story (Clojure has Java classes + interfaces and its own types, records, protocols, multimethods, etc.)",0.2611111111111111,Clojure
166er7n,jyjxu27,"IMO if a serious language was to be made employing predicates as the primary typing mechanism, it should: 1. check as much statically as possible, and assert the rest at runtime (java does this for array bounds checking for example, unlike dependently typed languages that can check bounds at compile time) 2. have a good polymorphism story (Clojure has Java classes + interfaces and its own types, records, protocols, multimethods, etc.)",0.2611111111111111,Java
166er7n,jyp3hgd,"So... hum... a decade or so ago, [Rust had Typestate](https://stackoverflow.com/a/10319250/147192) which was specifically about ""tagging"" types with predicates.",0.0,Rust
166er7n,jyq1qvq,Interesting that you mention Ada.,0.5,Ada
166er7n,jyq1qvq,I think the Spark Ada version can do what you want since the proofs are part of the source code.,0.0,Ada
166er7n,jys75o8,"See: https://simon.peytonjones.org/verse-calculus/  SPJ is a major creator of GHC (Haskell), seems he hit major limitations with ""functional"" paradigm by Haskell, and going ""functional-logic"" by Verse.",0.0625,Haskell
166er7n,jyjmwiz,and Flux which adds liquid types to Rust \[[video](https://www.youtube.com/watch?v=k-izcFCHN2o)\],0.0,Rust
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,C++
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,C
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Java
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Rust
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Scala
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,Swift
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,TypeScript
166er7n,jyku6r2,Rust is a great example.,0.8,Rust
166er7n,jykuruc,"look at C++ polymorphism, you CAN do anything with it, but mostly people do pretty standard things that work well and quickly.",0.2708333333333333,C++
1660uus,jyjatia,I'm not asking about the union type (I'm aware of that from Haskell).,0.25,Haskell
1660uus,jyj60fk,"I made a mistake, because I have been writing C all day.",0.0,C
1660uus,jyj60fk,"Contrast this with ignoring that you don't understand how even C can infer the type of a division result, and lashing out at people.",0.0,C
165w7sp,,"While there may be a unique smallest set of values that describes the type of a term, TypeScript lets you do things like union arbitrary types, define types containing literal values, and use [conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) (which essentially lets you check if a type is a subset of another type), which makes them feel much more like sets than type theory's types.",0.19375,TypeScript
165w7sp,jygn361,"But, TypeScript is not type theory either way and you shouldn’t expect it to have much to do with type theory.",0.2,TypeScript
165w7sp,jygn361,"It’s pretty easy to make TypeScript accept an ill-typed program, even without using “obviously” unsound features like casts or `any`.",0.22777777777777777,TypeScript
165w7sp,jygi530,"TypeScript's types are not sets of values, because the type of an expression depends more on its provenance than its actual shape (especially because TypeScript is highly unsound).",0.165,TypeScript
165w7sp,jygi530,"TypeScript's type language does have set-like operators like union and intersection, but that doesn't make them sets.",0.0,TypeScript
165w7sp,jygi530,"TypeScript has subtyping and uses it generously, which is part of the reason why a single value can be given so many different types.",0.14285714285714288,TypeScript
165w7sp,jygi530,"----   Defining the language of ""types"" in TypeScript is actually pretty complicated, but for individual features, it's relatively straightforward:  TypeScript's rules type judgement rules include things that look like  * If you know that `e: A` and `e: B`, then you can conclude `e: A & B`  * If you know that `e: A & B`, then you can conclude `e: A` and `e: B`.",0.03125,TypeScript
165w7sp,jygsqyx,"Agree with u/benjaminhodgson: TypeScript is a tool, not a theory.",0.0,TypeScript
165w7sp,jygsqyx,"And yes, JavaScript has a strong type system, in the sense that you won't crash the browser.",0.4333333333333333,JavaScript
165w7sp,jyoe7ct,"Still, TypeScript treats types as a judgement, so it indeed works as a type theory.",0.0,TypeScript
165w7sp,jyjd5mu,"We're already working on various ways of incorporating more of the popular TS ""typeticool"" techniques, such as adding overloading (with some limitations), first-class polymorphism, and doing type inference for conditional types (which were already [described on a sound declarative system] (https://popl22.sigplan.org/details/POPL-2022-popl-research-papers/37/Type-Level-Programming-with-Match-Types) in Scala's match types ) into a sound type system with great type inference (MLscript, which is in very early development stages).",0.35375,Scala
165rh24,jyoxk6t,That's the behavior you would get from C:      #if FOO     int *a = bar();     #else     double a = bar();     #endif     if (false && a < 1.0) { ... },-0.20000000000000004,C
165ku1s,,"For example, in C++ you can say `const thread_local auto& x = ...`.",0.0,C++
165ku1s,jyfkfc3,"They are declared similar to C# (and other languages), with a type, then the name ``` MyClass a = MyClass.new() ``` But there are also modifiers that can be placed after the type and prefixing the name as so ``` str* fruits = [] int _privateItem ``` The asterisk after a type means it's a collection (list) and the underscore at the start of the name means that it is private.",-0.041666666666666664,C
165ku1s,jyhcwt4,"```let [variable] [type] = [value]```  In my language, types are prefixed with `:`, similar to symbols in Ruby:  E.g.",0.0,Ruby
165ku1s,jyidbba,"In Fortran: PROGRAM TEST IMPLICIT NONE INTEGER :: TESTINT INTEGER, PARAMETER :: CONSTINT And so on :)",0.5,Fortran
165ku1s,jymtzq2,"'=' Expr ```  ``` static: compile time evaluation, like zig comptime or nim static (usable as expression block as well as variable modifier) static var: C style static variable let: immutable var: mutable ```  Just using static is a shorthand for ``` pub?",0.5,C
165ku1s,jyp4gfn,"In my experience with dynamic languages like Python, I have found that it is _extremely_ rare to have bugs caused by assignment to variables that were intended to be immutable (apart from confusion caused by Python not having a separate syntax for declaring new variables).",0.14545454545454545,Python
165ku1s,jyfgew6,I prefer a minimal approach like in Go (the concise variable declaration i.e).,0.0,Go
165ku1s,jyfqz57,"Mine is somewhat influenced by Rust but does not use a `let` keyword          x = 42; // ""Simple variable""             // Single assignment with type inference.",-0.03571428571428571,Rust
165ku1s,jyeq6mr,C++ is a disaster.,0.0,C++
165ku1s,jyoa4ql,"In Scala, block is an expression - it can both declare local variables (or just have any declaration/statement in it), and yield a value:      val foo = {         val x = 42         val y = 1337         x * y     }  Similar is the `let ... in ...` expression in the ML family of languages.",0.0,Scala
165ku1s,jyoa4ql,"Also, IIRC, there is GCC-specific extension for C language.",0.0,C
165ku1s,jyh18w5,"It is not inferable, since without the keyword it would be inferred as static if in global/namespace scope or local (""automatic"" duration in C++ standardese) if in a function.",0.25,C++
165ku1s,jyh18w5,> does C++ not know how to infer addresses?,0.0,C++
165ku1s,jyiho9t,C++ was designed by a committee a long time ago and we have learned a great deal about OOLs since then.,0.375,C++
165ku1s,jyiho9t,"Of course, much of that learning was because of C++.",0.2,C++
165ku1s,jyguqfl,It’s kinda like how Rust works - it’s just that there’s no `let` keyword and type inference is represented using the Almighty Walrus `:=`.,0.0,Rust
165ku1s,jyk5jev,It's kinda like Haskell's `>>=` operator.,0.0,Haskell
165ku1s,jyiktf2,"The original commenter mentioned Rust as an inspiration, as an example they call it [""const eval""](https://doc.rust-lang.org/reference/const_eval.html) for anything that's calculated at compile time, not just individual variables (function calls, match expressions, etc.).",0.1875,Rust
165ku1s,jyiktf2,"Note that Rust's comptime evaluation is less powerful than Zig's but in the context of this conversation it's the same - an indication by the programmer that something **must** be done at compile time otherwise error, rather than leaving it up to the compiler to decide.",0.044444444444444446,Rust
165ku1s,jyo639w,It may be used similarly as `<-` notation from Haskell and Scala.,0.0,Haskell
165ku1s,jyo639w,It may be used similarly as `<-` notation from Haskell and Scala.,0.0,Scala
165ku1s,jyo639w,"Except this one is not tied to single interface/function: in Scala it's fixed to desugaring to`flatMap`,  and in Haskell to `bind`/`>>=`.",0.01428571428571429,Scala
165ku1s,jyo639w,"Except this one is not tied to single interface/function: in Scala it's fixed to desugaring to`flatMap`,  and in Haskell to `bind`/`>>=`.",0.01428571428571429,Haskell
165co33,jydbex4,"Fish is still updating itself to stay relevant in the modern age as well, with the current rewrite from C++ to Rust and the planned future upgrades for migrating from `wchar_t` to UTF-8 and incorporating more concurrency.",0.22000000000000003,C++
165co33,jydbex4,"Fish is still updating itself to stay relevant in the modern age as well, with the current rewrite from C++ to Rust and the planned future upgrades for migrating from `wchar_t` to UTF-8 and incorporating more concurrency.",0.22000000000000003,Rust
165co33,jydhtnk,"The main reason I didn't like nu, and some other utilities shell utilities written in Rust is the ""fancy"" graphics.",0.02083333333333333,Rust
165co33,jygwzb0,"It also helps that learning Bash makes it easy to pick up Zsh, Tsh, Csh, Ash, etc.",0.43333333333333335,Bash
165co33,jyf8is4,"Perl has a lot of these little offbeat things, and it very much appealed to my eclectic sensibilities as a kid.",-0.1425,Perl
165co33,jyf8is4,"For example, consider another Bash-ism: in `case`, patterns can be set off from blocks by a right parenthesis—this means you can’t naïvely scan Bash source under the assumption of balanced brackets.",0.2857142857142857,Bash
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Python
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,C++
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Rust
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Lisp
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,Forth
165co33,jyme2ye,Ruby too I guess.,0.0,Ruby
1654vrs,,"My schools' class forces the use of Java programming language, and I absolutely hated it.",-0.9,Java
1654vrs,,"So, over the course of a little less than a month, I wrote my own programming language, in Rust (objectively best programming language), using [pest](https://pest.rs), to be as similar to Rust as possible, but compiling to Java.",0.2076388888888889,Rust
1654vrs,,"So, over the course of a little less than a month, I wrote my own programming language, in Rust (objectively best programming language), using [pest](https://pest.rs), to be as similar to Rust as possible, but compiling to Java.",0.2076388888888889,Java
1654vrs,,"- Enums use classes instead of the builtin `enum` thing in Java, I just didn't feel like using them - Some generated builtins, (i.e.",0.0,Java
1654vrs,jygzfgl,"It's a sledgehammer to crack a nut, you could just ... write Java?",0.0,Java
1654vrs,jyfseyo,Had to make a 2nd comment because I missed this in my first read-through.`Rust (objectively best programming language)`  That's a big statement.,0.3125,Rust
1654vrs,jygm4ki,He’s likely unaware of languages that are better in each of the domains Rust is strong in.,0.23333333333333334,Rust
1654vrs,jygkvj1,"Rust is the best programming language because of its focus on 100% memory safety, 0-cost abstractions, ownership and borrowing...",1.0,Rust
1654vrs,jypmhb9,Borrowing and ownership in Rust are actually just compiler-level constructs; they don't exist after the code is compiled.,0.0,Rust
1654vrs,jypmhb9,"Something similar to async/await is in the works for a future version of Java, but at the moment it's not easy to translate directly to Java without a lot of legwork.",-0.029166666666666667,Java
1654vrs,jypmhb9,You could look at how Kotlin does it.,0.0,Kotlin
1654vrs,jygpqel,"C++ has some memory safety, but it's super complicated.",-0.08333333333333334,C++
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,C++
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,Python
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,Java
1654vrs,jyh716h,and I still think that Rust is by far the best language for the majority of use cases.,0.55,Rust
1654vrs,jygz2vs,"\> Rust is the best programming language because of its focus on 100% memory safety, 0-cost abstractions, ownership and borrowing...",1.0,Rust
1654vrs,jyd9vbl,What parts of Rust does Jasmine handle?,0.0,Rust
1654vrs,jyn4vwv,"Thank you, this helps me understand how people use Rust for implementing programming languages.",0.0,Rust
1654vrs,jyqsuwo,Go is better for a few things even if Rust might be slightly faster runtime.,0.044444444444444446,Go
1654vrs,jyqsuwo,Go is better for a few things even if Rust might be slightly faster runtime.,0.044444444444444446,Rust
1654vrs,jyqsuwo,"For learning/onboarding, Go is by far.. exponentially better than anything out there.",0.3,Go
1654vrs,jyqsuwo,"I'd use Rust or my new fav, Zig, for anything else.",0.13636363636363635,Rust
1654vrs,jyqxfn5,"If you like Go, you're going to love [IntercalScript](https://github.com/Storyyeller/IntercalScript).",0.5,Go
1654vrs,jyqxfn5,"The problem with Go is that it achieves ""simplicity"" by deferring all the work from the compiler to the human and forcing them to write low level repetitive code by hand.",-0.08333333333333333,Go
1654vrs,jyqxfn5,"Also, while Go may be ""simple"", it still has a lot of unforced design errors and dumb gotchas and the like.",-0.1875,Go
1654vrs,jygl63m,"If, in writing code, I made a borrow, there would be no way for me to translate that into Java code.",0.0,Java
1654vrs,jyglr7n,I think you’re missing the point…  It will run in Java with GC.,-0.2,Java
164ox4k,jyc9m4z,Python has [xeger](https://pypi.org/project/rstr/) but being able to reverse a whole grammar would be very convenient too.,0.3,Python
164k73n,jy96lkk,"When Spring (Java) was XML based, all your config was in one spot, now with annotations/decorators, it's all over the codebase.",0.0,Java
164k73n,jyckftc,"Python needs decorator syntax, because `def` is a statement instead of an expression there, so higher-order functions those wrapping other function definitions somehow, have to be called with special syntax.",0.11607142857142858,Python
164k73n,jyckftc,"In my PL `$` is a low-precedence, right-associative, infix operator, works like that in Haskell, i.e.",0.0,Haskell
164k73n,jyckftc,"`(***apk)` there is roughly `(*args, **kwargs)` as in Python.",-0.1,Python
164k73n,jycedsv,"In Java, they're called annotations.",0.0,Java
164k73n,jycvw4u,But if it is actually a tag that you can check if it is in certain object and with that generate code from a function that you wrote (not the compiler for you) then is ok. Basically Java tags,0.2380952380952381,Java
163g4nf,,"Hi everyone,  So I am writing a nil-checker (my keyword is called nil, but its the same as C++'s null).",0.0,C++
163g4nf,jy44k68,"Xcode's is SLOOWWW.... taking minutes on only 500k of C++... mine will run in 0.01 second, and also make the language neater to write.",0.0,C++
162drv9,,I believe Rust has something similar with `std::option` and match statements.,0.0,Rust
162drv9,jxytgkf,[Scala Option](https://www.scala-lang.org/api/2.13.3/scala/Option.html),0.0,Scala
162drv9,jxzbsem,"I see two things here:  - First-class support for `null` is common in a few languages, including Ceylon with its [`if(exists)`](http://web.archive.org/web/20211129235401/https://ceylon-lang.org/documentation/1.3/tour/basics/#dealing_with_objects_that_aren_t_there), Zig with its [`orelse`](https://ziglang.org/documentation/master/#Optionals), or [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator) and [PHP](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce) with the `?",-0.25,C
162drv9,jxzbsem,"I see two things here:  - First-class support for `null` is common in a few languages, including Ceylon with its [`if(exists)`](http://web.archive.org/web/20211129235401/https://ceylon-lang.org/documentation/1.3/tour/basics/#dealing_with_objects_that_aren_t_there), Zig with its [`orelse`](https://ziglang.org/documentation/master/#Optionals), or [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator) and [PHP](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce) with the `?",-0.25,PHP
162drv9,jxzbsem,It is popular in several OOP languages like Kotlin or Ceylon as it allows to downcast class references.,0.3,Kotlin
162drv9,jxzbsem,"TypeScript is similarly notable for encoding ECMAScript's many dynamic type checks in a static, AOT-checked, type system using [a range of narrowing checks](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) including `x instanceof y`, `""x"" in y` and `x.hasOwnProperty(y)` among others.",0.375,TypeScript
162drv9,jxzrdf1,"If used where a block is expected, Raku groups and binds arguments on the left of the `->` to parameters on the right, and calls the lambda/block as many times as appropriate:      for 4, 3, 2, 1 -> a, b { print a } # 42  ⁴ You have to write more verbose syntax if you want to deal with ""some"" or ""none"" tags of optionals:      Int:D  # `:D` is a ""type smiley"".",0.38367346938775515,D
162drv9,jxzrdf1,`Int:D` means some `Int`.,0.0,D
162drv9,jxzhanh,"So some of what you're thinking about overlaps with [Void Safety](https://www.eiffel.org/doc/eiffel/Void-safety-_Background%2C_definition%2C_and_tools)  Eiffel has the following, which might be of interest:  ```eiffel if attached x as l_x then   l_x.f (a) end ``` Kind regards, M ✌",0.3,Eiffel
162clva,jxxa19u,"(3) ""C"" switch-case or similar Pascal case-of instructions can sometimes be replaced into a small array of instructions.",-0.125,C
162clva,jxxa19u,"(3) ""C"" switch-case or similar Pascal case-of instructions can sometimes be replaced into a small array of instructions.",-0.125,Pascal
162clva,jxxt1gb,"Maybe you will find [A deep dive into dispatching techniques - Jonathan Müller - Meeting C++ 2022](https://youtu.be/P4BUvMmdTMU?si=VXcgAIPgsrs646lT) interesting, and/ or [Building the fastest Lua interpreter..",0.25,C++
162clva,jxxt1gb,"Maybe you will find [A deep dive into dispatching techniques - Jonathan Müller - Meeting C++ 2022](https://youtu.be/P4BUvMmdTMU?si=VXcgAIPgsrs646lT) interesting, and/ or [Building the fastest Lua interpreter..",0.25,Lua
162clva,jxxt1gb,Lua is considered to be fast and somewhere on Reddit Lua's author discussed tricks he used unfortunately I can't find it right now.,-0.004761904761904763,Lua
162clva,jxxt1gb,Edit: found the [Lua stuff](https://www.reddit.com/r/programming/comments/badl2/luajit_2_beta_3_is_out_support_both_x32_x64/c0lrus0/),0.0,Lua
162clva,jxxel81,This lets me push common routines into the C++ code instead of having it in the scripting language.,-0.3,C++
162clva,jxxel81,I’m writing in C++ and not making any use of inline assembly at the moment.,0.0,C++
162clva,jxxbuvs,Our other languages would be C++ or Python.,-0.125,C++
162clva,jxxbuvs,Our other languages would be C++ or Python.,-0.125,Python
162clva,jxxbuvs,"C++ destroys my language for performance, up to 100x faster.",0.0,C++
162clva,jxxbuvs,Python is 5-10x slower.,0.0,Python
162clva,jxxbuvs,The C++ code is very difficult to write in comparison to my DSL or else it would be the obvious answer.,-0.325,C++
162clva,jxxbuvs,Comparable C++ is hundreds of lines long and considerably harder to debug.,-0.07500000000000001,C++
162clva,jxxbuvs,The Python code solves some of that.,0.0,Python
162clva,jxxbuvs,"It is easier to write than the C++, but still more difficult than the DSL.",0.0,C++
162clva,jxy53us,"I've recently picked up the Lua code and started reading over it to find things they have done, but it's a bit of searching for a needle in a haystack.",0.0,Lua
162clva,jxxvulf,"(For example, it could be using more memory compared with the C++ solution.)",0.5,C++
162clva,jxynzhz,"All of the loading of the data is handled in C++, completely outside of the script itself (IOW, the script doesn’t contain any code to open a file or read from it).",0.0,C++
162clva,jxynzhz,We have some very robust C++ libraries to handle this.,0.2,C++
162clva,jxynzhz,"C++ destroys all of the above, including my scripts.",0.0,C++
162clva,jxynzhz,"A script is almost surely using more memory compared to a comparable program in C++, although there are some tricks I use in the VM that shrink usage compared to naïve C++.",0.5,C++
162clva,jxwvs2o,"Now because of my host language being Python the only *practical* gains right now come from when native code drops the GIL, but *in theory* this lets me work out the details of message-passing concurrency in a safe and productive environment.",0.2619047619047619,Python
162clva,jxzej11,You said elsewhere Python (I assume CPython) was 5-10 times slower; that was running the data application?,0.0,Python
162clva,jxzej11,">C++ destroys all of the above, including my scripts.",0.0,C++
162clva,jxzej11,C++ will destroy most of those others too.,0.15,C++
162clva,jxzej11,"You should expect interpreted code, that does not have a sophisticated JIT, to be at least a magnitude slower than C++ on pure computation.",0.13809523809523808,C++
162clva,jxzej11,"Python and Lua have dynamic typing, yours has too, but it's not clear how much type checking is left out.",0.0375,Python
162clva,jxzej11,"Python and Lua have dynamic typing, yours has too, but it's not clear how much type checking is left out.",0.0375,Lua
162clva,jxzej11,"If C++ is currently 100x faster, then it will still be at least 10x faster even if you did manage it.",-0.15,C++
162clva,jxzej11,"Maybe consider a hybrid approach: use the scripting language to orchestrate the task, but use special C++ functions to do the bulk of the real work.",0.2785714285714286,C++
162clva,jxzej11,"With more realistic programs than simple benchmarks, my dynamic language works briskly compared to CPython and Lua, not using the ASM accelerator.",0.16666666666666666,Lua
162clva,jxzej11,"The figure used to compare is throughput in lines per second; bigger is better:                      M lps     Lua 5.4         0.06 to 1.0   (2 Lua versions)     CPython 3.11    0.1  to 0.2   (Several versions)     Q               0.5           (My dynamic language)     Q/ASM           1.2          PyPy            0.7  to 1.4   (Several versions)     LuaJIT          1.1  to 1.7   (2 version)     M              10.9           (My static language)     C (gcc-O3)     14.0           (Transpiled from M)  From PyPy downwards is either the result of tracing JIT, or is native code.",0.14285714285714285,Lua
162clva,jxzej11,"The figure used to compare is throughput in lines per second; bigger is better:                      M lps     Lua 5.4         0.06 to 1.0   (2 Lua versions)     CPython 3.11    0.1  to 0.2   (Several versions)     Q               0.5           (My dynamic language)     Q/ASM           1.2          PyPy            0.7  to 1.4   (Several versions)     LuaJIT          1.1  to 1.7   (2 version)     M              10.9           (My static language)     C (gcc-O3)     14.0           (Transpiled from M)  From PyPy downwards is either the result of tracing JIT, or is native code.",0.14285714285714285,C
162clva,jxwzrrv,My host language is C++.,0.0,C++
162clva,jy00va2,> You said elsewhere Python (I assume CPython) was 5-10 times slower; that was running the data application?,0.0,Python
162clva,jy00va2,"I have a C++ library that loads the data for Python, but it is still substantially slower due to the way it has to work with Python.",-0.125,C++
162clva,jy00va2,"I have a C++ library that loads the data for Python, but it is still substantially slower due to the way it has to work with Python.",-0.125,Python
162clva,jy00va2,"Obviously I'll never get ""C++ fast"".",0.1,C++
162clva,jxy410w,"For the shorter job, you would have your answer before someone was able to finish a C++ version of the program.",0.5,C++
162c9z2,,Languages like C++ has implicit conversions.,0.0,C++
162c9z2,,"This is very close to (but not the same as, at least in C++) ""whenever type B can be used, type A can **also** be used"".",-0.033333333333333326,C++
162c9z2,,Languages like C++ does not **chain** implicit conversions.,0.0,C++
162c9z2,,This means A -> B and B -> C does not mean A -> C. 2.,0.15625,C
162c9z2,jxwsuva,"For any types `A`, `B`, `C`, if `A <: B` and `B <: C`, then `A <: C` and `i{A,C} = i{B,C} .",0.0,C
162c9z2,jxxdiu9,**  A common compiler like C will perform several implicit conversions.,-0.15,C
162c9z2,jxxdiu9,"Usually in C integers alike variables are converted into the specific integer byte, even if they where another 8, 16, 32 bits types and integer is 64 bits.",-0.125,C
162c9z2,jy89ain,"In my language Y, the only implicit conversions I'm allowing are the conversion between literals of basic type limited to not allow conversions that would lose information, which makes it so I don't have to write stuff like `1.0f` from C (I can just put a `1`), and a few conversions between sizes of basic types mainly for stuff like multiplying two 4-byte naturals and storing the result in another 4-byte natural, instead of an 8-byte one, which I think should be fine since it's less drastic than implicitly converting floats to integers or something like that.",0.027248677248677248,C
162c9z2,jyh1mwr,"For example, in Java, `int` is a subtype of `long` (per [JLS sec.",-0.07500000000000001,Java
162c9z2,jysoban,"Continuing with Java, `short` is a subtype of `int` and coercion takes place on the language-level (e.g., [JLS sec.",-0.05,Java
16225sf,jxz8chb,"That, or it's C, and it will overwrite memory or, worse, read out the user's password.",-0.4,C
16225sf,jxv7jei,"In the Erlang community, they have a motto, ""let it crash"".",0.0,Erlang
16225sf,jxwi2nv,"That's yet another thing one can accommodate in the type system - by using lifetimes, as featured by Rust, the bounds of a permission can be represented in the type system.",0.0,Rust
16225sf,jxznqne,"> That, or it's C, and it will overwrite memory or, worse, read out the user's password.",-0.4,C
16225sf,jxwhrsh,"- An effects system, such as Koka's algebraic effects or Haskell's monads, prevents access to systems without a direct chain of approval to the entry point; functions can no longer independently execute IO, including network access.",0.03333333333333333,Haskell
16225sf,jxzr1i1,"When writing this kind of code in C++, D or a similar language, I'd `debug assert(mid < len);`.",0.3,C++
16225sf,jxzr1i1,"When writing this kind of code in C++, D or a similar language, I'd `debug assert(mid < len);`.",0.3,D
16225sf,jxz22lf,Otherwise Python wouldn’t be as popular as it is.,0.6,Python
16225sf,jy0aus0,"No, Python has staying power but isn't really ""trending"" in the same way.",0.1,Python
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,Rust
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,Scala
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,Java
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,Python
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,JavaScript
1621mpb,,TLDR: Here's the repo - [https://github.com/liam-ilan/crumb](https://github.com/liam-ilan/crumb) :D  Hi all!,1.0,D
1621mpb,,"I started learning C this summer, and figured that the best way to learn would be to implement my own garbage-collected, dynamically typed, functional programming language in C ;D  The language utilizes a super terse syntax definition...",0.5458333333333334,C
1621mpb,,"I started learning C this summer, and figured that the best way to learn would be to implement my own garbage-collected, dynamically typed, functional programming language in C ;D  The language utilizes a super terse syntax definition...",0.5458333333333334,D
1621mpb,,"If you build anything cool with it, send it to the comments, it would be awesome to see what can be done with Crumb :D",0.7833333333333333,D
1621mpb,jxwv2l5,Have you considered something like Rust where the last statement in a block is the return value?,0.0,Rust
1621mpb,jxuwy6w,So you already knew some other language than C ?,-0.125,C
1621mpb,jxvzvia,"The source code for the Game of Life demo can be found here: [https://github.com/liam-ilan/crumb/blob/main/examples/game-of-life.crumb](https://github.com/liam-ilan/crumb/blob/main/examples/game-of-life.crumb) :D  Graphics are done just through print and escape codes... Every time I need to re-render, I just use the `\e[H` escape code to return to the top left of the terminal, and then print a string containing the rendered screen again...",0.07000000000000002,D
1621mpb,jxvzvia,"When it comes to matrices, it's just lists inside lists :D I have a render function that gets in a matrix, and returns the corresponding string to print :D  One of the nice things about Crumb is that lists are always pass-by-value, so it's harder to accidently mutate the matrix while you traverse it...  Crumb doesn't have any special graphics functions...",0.5714285714285714,D
1621mpb,jyn9uuw,it's very cool and reading through the source code as a C beginner myself it's really concise and well written in my opinion,0.27749999999999997,C
161zt0r,jxwc148,"I would also recommend checking out Lambda Prolog (There's a book Programming with Higher-Order logic), and some languages like Mercury and Curry.",0.0,Prolog
161xxel,jxuid3e,Pretty much the only reason C++ has `auto` is that it was an already reserved keyword from C that wasn't used very much.,0.1775,C++
161xxel,jxuid3e,Pretty much the only reason C++ has `auto` is that it was an already reserved keyword from C that wasn't used very much.,0.1775,C
161xxel,jxuubjk,"C++ also inherited it from D, which used it for two decades and was proposed for inclusion.",0.0,C++
161xxel,jxuubjk,"C++ also inherited it from D, which used it for two decades and was proposed for inclusion.",0.0,D
161xxel,jxuubjk,"`if constexpr` is another feature they took from D, but decided to invent a new keyword for and to make it worse.",-0.13181818181818183,D
161xxel,jxxzqlz,`var` in C#,0.0,C
161xxel,jxvlftx,How can D have used `auto` for two decades before C++ adopted the keyword for type inference if D has been around since 2001 and `auto` for that purpose came out with C++11?,0.0,D
161xxel,jxvlftx,How can D have used `auto` for two decades before C++ adopted the keyword for type inference if D has been around since 2001 and `auto` for that purpose came out with C++11?,0.0,C++
161xxel,jxy439q,"It isn't, and that's why I also dislike `var` in C#.",0.0,C
161xxel,jxy439q,"But I do like Rust's `let`, because it actually carries semantic meaning.",0.0,Rust
161xxel,jxvmnmm,It used it for one decade before C++.,0.0,C++
161xxel,jxy49md,It's not like C++ or C# can just flip their syntax on a whim,0.0,C++
161xxel,jxy49md,It's not like C++ or C# can just flip their syntax on a whim,0.0,C
161wg53,,Go back to 1 (repeat).,0.0,Go
161wg53,,"I know that Prolog is more like SLD Resolution and Horn clauses—I understand the difference, just trying to compare it to something.",0.5,Prolog
161ke75,,Here is a 469 line Forth compiler implemented in Forth:  https://github.com/kragen/stoneknifeforth/blob/master/tinyboot1.tbf1  Here is a 301 line BF interpreter implemented in BF:  https://github.com/canoon/bfbf/blob/master/bf.bf  (I actually don't know which  Scheme-in-Scheme is canonical.,0.0,Forth
161ke75,,"I guess you can argue a bit about this, because almost all of them will all have a garbage collector in C.   Here's a tiny one, but it's not implemented in itself: https://www.piumarta.com/software/lysp/  )  ---  I thought the answer might be C4: C in 4 Functions  https://github.com/rswier/c4  BUT there is no type checker.",0.0,C
161ke75,,"It is a bytecode interpreter for C, not a compiler.",0.0,C
161ke75,,Some variant of Pascal maybe?,0.0,Pascal
161ke75,jxsi44y,"Most likely Pascal, and in particular I'd look closely at the UCSD variant.",0.2222222222222222,Pascal
161ke75,jxsi44y,The compiler is itself written in UCSD Pascal.,0.0,Pascal
161ke75,jxsi5hz,I wouldn't be surprised if APL beats either of those.,0.1,APL
161ke75,jxum4v8,"On top of that there also are inline function definitions (more like Forth words than procedures really), with nesting and recursion.",0.39999999999999997,Forth
161ke75,jxud4wi,I'm working on something similar in TypeScript and I would like to compare (although it's a bunch of work TBH)  The type checker is 118 lines:  https://github.com/andrejbauer/plzoo/blob/master/src/minihaskell/type_check.ml  However I do think the parsing is the more annoying part.,-0.10000000000000002,TypeScript
161ke75,jxud4wi,I am not sure how close the mini Haskell syntax is to Haskell.,-0.25,Haskell
161ke75,jxss3k3,What's an example of an APL implemented in itself?,0.0,APL
161ke75,jxss3k3,I thought most of them were implemented in C or another low level language.,0.25,C
161ke75,jxswcj4,Co-dfns is a dialect of APL written in itself.,0.0,APL
161ke75,jxt4p0i,"A traditional Forth reader is pretty much trivial—grab a string of nonspace characters, check if they parse as a number, or refer to a defined name (“word”), and either compile or interpret the result according to the current mode.",0.1125,Forth
161ke75,jxt4p0i,"APL can express parsers very compactly for grammars that vectorise well, but ironically, APL itself is kind of hard to do that with.",0.16944444444444443,APL
161ke75,jxt9lwv,"As far as APL goes, Aaron Hsu wrote a parallel APL compiler ~~in 17 lines of APL~~ (*edit:* incorrect, see reply below), [which this sub discussed a few years ago](https://old.reddit.com/r/ProgrammingLanguages/comments/k258ez/a_gpucpu_hosted_compiler_written_in_17_lines_of/).",-0.03333333333333333,APL
161ke75,jxt9lwv,"But that does not include the APL run-time, which is still written in C/C++, so it feels like a bit of a cheat to call it a *complete* compiler (it's still really impressive)  EDIT: I just noticed you were also commenting in that discussion so let's just say I'm posting this for people reading along ;)",0.45,APL
16198e7,jxqlwi7,You may want to check out the stack-based Forth programming language.,0.0,Forth
16198e7,jxqlwi7,"Like your opcodes, Forth primitives get their arguments from the stack and return values to the stack.",0.0,Forth
16198e7,jxqlwi7,"For that reason, Forth provides several stack manipulation “words” like DUP, ROT, OVER, and PICK.",0.0,Forth
16198e7,jxrxax9,For example:      add      a b+c        # one value has been popped     neg      a b -c     push x   a b c x     pop x    a b  ETA: the idea for `(a - b)` came from Forth I think.,0.0,Forth
16198e7,jxs1vp0,"Forth or Factor will help you get real comfy with stack based programming, although it might be a hefty investment",0.2,Forth
16198e7,jxzc1vw,"Go ahead and add that link to your original post, if you can edit it.",0.375,Go
160m27p,jxnlwc5,* C was designed to write Unix in.,0.0,C
160m27p,jxnlwc5,* Lua was designed to meet the business needs of the Brazilian national electricity company.,0.0,Lua
160m27p,jxnlwc5,"* PHP, despite its flaws, succeeded because the author had something so definite in mind that he called his language **P**ersonal **H**ome **P**age.",0.0,PHP
160m27p,jxnlwc5,"* Go has been called ""a domain-specific language for writing servers"".",0.0,Go
160m27p,jxnlwc5,* Rust is a systems language.,0.0,Rust
160m27p,jxor3ml,And we'd still be using either Fortran or whatever came before it.,0.0,Fortran
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,C
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,C++
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,Java
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,Python
160m27p,jxp7vta,"It is far easier to make a new language to learn about this stuff than trying to target common languages like C and C++, C# etc...",-0.02121212121212121,C
160m27p,jxp7vta,"It is far easier to make a new language to learn about this stuff than trying to target common languages like C and C++, C# etc...",-0.02121212121212121,C++
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,C++
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,C
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,Python
160m27p,jxnil6p,"Not to mention some people just like to think different ways, and it's really hard to program with mutation if you're in Haskell or something.",-0.14583333333333334,Haskell
160m27p,jxnil6p,In the same vein it's hard to program functionally in C.,-0.14583333333333334,C
160m27p,jxpdgfl,Then you can switch to Rust like mode if you want that level of performance (technically better than Rust performance).,0.5,Rust
160hdhl,,"It's kind of like `lex` and `yacc`, but I think it's cleaner -- the library is written in C (ie.",0.6,C
160a70g,jxmqf23,"It was missing a lot of stuff, but it was actually usable, mostly because I could just throw actual C code in the middle of the program when there was something I couldn't do, with the help of some scripts I was also able to reference variables from zimbu itself.",0.13333333333333333,C
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,C
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,C++
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,Java
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,JavaScript
15zxwjj,jxkxgdr,"> Your store example uses two operands both using ptr %x, so the same rank for both, used to implement C code where LHS and RHS have different ranks.",-0.26666666666666666,C
15zxwjj,jxlg3uk,"The only language I can think of that combines this with parsing is Lua, pretty much every other language out there separates this into distinct phases.",0.125,Lua
15zobnr,,"Since I am using the Haskell recursion-schemes anyway, I am able to use either Cofree or a Functor product with Fix to inject extra information for every node.",0.25,Haskell
15zobnr,jxshcrd,"I can only speak about my C++ implementation, which basically had a struct called Node, and within it had a bunch of different structs like FunctionNode, ObjectNode, ListNode, ForLoopNode etc.",0.0,C++
15z5kwb,jxs5h7m,"For example, a type like Rust's Option<T> can itself be generalized as Result<T, ()>, meaning bool could be generalized as Result<(), ()>.",0.0,Rust
15z5kwb,jxgwpr1,"But if we compare this, for example, Rust code:  ``` fn main() {    let i: Option<()> = Some(());    i .map(|x| print!",0.20833333333333331,Rust
15z5kwb,jxgwpr1,"(""Nope"")); } ```  with this C++ code:  ``` auto i = true; i ?",0.35,C++
15z5kwb,jxgwpr1,"Rust chosen first approach, Argentum chosen second.",0.125,Rust
15z5kwb,jxtj23n,"No one prevents you from creating user-defined classes and go down the path of `result` analysis:  ``` class Result(R, E) {    ok = ?R;    err = ?E; } ```  Argentum on the other hand will go another way: passing error handlers as lambdas:  ``` fn parseInt(from String, onBadFormat(), onOverflow()) int {    ... ?",0.07314814814814814,R
15z5kwb,jxfoq1i,"In short, a lot of languages have the same capabilities (Rust and Haskell could trivially reproduce this) and decided not to do it.",0.0,Rust
15z5kwb,jxfoq1i,"In short, a lot of languages have the same capabilities (Rust and Haskell could trivially reproduce this) and decided not to do it.",0.0,Haskell
15z5kwb,jxfvg57,Also the `:` operator is called `fromMaybe` in Haskell.,0.0,Haskell
15z5kwb,jxfvg57,"In Rust, the `?` operator is `Option::map`, the `:` operator is `Option::or_else`, and the combination of the two is `Option::map_or_else`.",0.0,Rust
15z5kwb,jxg4lvw,"}  can be implemented in, say, Rust as:      fn to_message(number: Option<i32>) -> String {         number                 .map(|n| format!",0.0,Rust
15z5kwb,jxg4lvw,I should borrow Rust approach?,0.0,Rust
15y4cfv,jxbz3gu,Ruby also does this.,0.0,Ruby
15y4cfv,jxc09du,"I do quite close to this for `{ }`, with the exception of the semicolon (It's basically `begin` from Scheme with an alternative syntax).",0.0,Scheme
15y4cfv,jxdfsk5,"The C [comma operator](https://en.wikipedia.org/wiki/Comma_operator) is similar to this: evaluate from left to right, discard each result except the last.",0.07142857142857142,C
15y4cfv,jxew9t3,See Python.,0.0,Python
15xqv3w,jxcx0sb,"So, I think adding optional freedom would nice (like Rust's unsafe keyword but using types).",0.6,Rust
15xqv3w,jxdo2um,"So far, nothing out of the ordinary - Scheme behaves this way.",-0.075,Scheme
15xmg2b,jx79jpn,"Throw some Guile and Python in, source in both Java and C. Would be fun.",0.3,Python
15xmg2b,jx79jpn,"Throw some Guile and Python in, source in both Java and C. Would be fun.",0.3,Java
15xgt8b,,• adores its shared mutable state • embraces radical complexity • has a brick wall for interop with C.,0.0,C
15xgt8b,jx74ln8,This is pretty close to just C++ isn't it?,0.25,C++
15xgt8b,jx79qy5,But without C interop.,0.0,C
15xgt8b,jx6y28u,Not as good as C tbh (a truly perfect programming language),0.85,C
15x8bal,jx52y0o,"A lot of languages just use the logical operators for this, for example in Julia [https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation](https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation)  Additionally, you seem to have a concept of falsy and truthy, which has its dangers.",0.25,Julia
15x8bal,jx8yvyk,"_ = None      (:) :: Option a -> Lazy a -> a     (Some x) : _ = x     None : x = (force x)  With language support you could auto-lazy the RHS of both operators, or you wouldn't even need to do that in a lazy by default language like Haskell, though we can already express the same things in a slightly different way with `maybe`.",-0.125,Haskell
15x8bal,jx5myqp,"Most languages actually have more terse way to express the logic I'm trying to capture, for example in Rust the same can simply be done with:      v = match c {         b'0'..=b'9' => c - b'0',         b'A'..=b'F' => c - b'A' + 10,         _ => 255,     } as i8;  You can ignore the `b'...'` prefix, the sentinel `255` instead of `-1`, and the `as i8`; these just have to do with Rust's `char` type being different from the signed bytes I used in my example above.",0.14285714285714285,Rust
15x8bal,jx5myqp,"A more idiomatic Rust example would be:      let v = match c {         '0'..='9' => Some(c as u32 - '0' as u32),         'A'..='F' => Some(c as u32 - 'A' as u32 + 10),         _ => None,     };  But this isn't quite the same as my original example semantically since it does things like encoding errors in the type system, uses 32-bit unsigned ints instead of 8-bit signed ints, and only work on previously validated Unicode scalar values.",0.14166666666666666,Rust
15x8bal,jx5myqp,"Edit: This isn't relevant to anything, but in trying to figure out a nicer way to do this in C++ rather than with `if` statements, I accidentally did this:      v = 0;     switch (c) {         case 'F': ++v;         case 'E': ++v;         case 'D': ++v;         case 'C': ++v;         case 'B': ++v;         case 'A': ++v;         case '9': ++v;         case '8': ++v;         case '7': ++v;         case '6': ++v;         case '5': ++v;         case '4': ++v;         case '3': ++v;         case '2': ++v;         case '1': ++v;         case '0': break;         default: v = -1;     }  ***ಠ╭╮ಠ***",0.4,C++
15x8bal,jx5myqp,"Edit: This isn't relevant to anything, but in trying to figure out a nicer way to do this in C++ rather than with `if` statements, I accidentally did this:      v = 0;     switch (c) {         case 'F': ++v;         case 'E': ++v;         case 'D': ++v;         case 'C': ++v;         case 'B': ++v;         case 'A': ++v;         case '9': ++v;         case '8': ++v;         case '7': ++v;         case '6': ++v;         case '5': ++v;         case '4': ++v;         case '3': ++v;         case '2': ++v;         case '1': ++v;         case '0': break;         default: v = -1;     }  ***ಠ╭╮ಠ***",0.4,C
15ww9sh,jx4rz7r,"In Rust, you have to use convoluted workarounds like `mem::swap(&mut a, &mut b)` instead.",0.0,Rust
15ww9sh,jxcguy4,"> I think destructuring assignments should be able to affect control flow...  Not sure if this is what you mean, but in Rust control flow constructs come in two flavors: one that accepts booleans (ex.",-0.020833333333333332,Rust
15wdiqh,jx0akqq,"**  Some tips:  You could dive in, into several projects, code and documentation, like Modula and Ada.",0.0,Ada
15wdiqh,jx0akqq,"Java, C# and similar V.M.",0.0,Java
15wdiqh,jx0akqq,"Java, C# and similar V.M.",0.0,C
15wdiqh,jx0akqq,Pascal branch of P.L.,0.0,Pascal
15wdiqh,jx0akqq,Java and C++ uses classes definitions as modules.,0.0,Java
15wdiqh,jx0akqq,Java and C++ uses classes definitions as modules.,0.0,C++
15wdiqh,jx0akqq,**  C++ and Java mix both.,0.0,C++
15wdiqh,jx0akqq,**  C++ and Java mix both.,0.0,Java
15wdiqh,jx0akqq,Delphi doesn't.,0.0,Delphi
15wdiqh,jx0akqq,"**  Pascal call them ""unit (s)"".",0.0,Pascal
15wdiqh,jx0akqq,"**  Java ""package (s)"" sometimes does this.",0.0,Java
15wdiqh,jx0akqq,"There's an special single main folder module as the ""global"" namespace in C++.",0.11309523809523808,C++
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,Delphi
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,C++
15wdiqh,jx0akqq,"C++ ""namespace"" does not have this directly.",0.1,C++
15wdiqh,jx0akqq,Delphi does.,0.0,Delphi
15wdiqh,jx0akqq,Java and C++ emulate this using a class and a static constructor and a static destructor.,0.5,Java
15wdiqh,jx0akqq,Java and C++ emulate this using a class and a static constructor and a static destructor.,0.5,C++
15wdiqh,jx0akqq,"A lot of programers, in C and C++, emulate this by explicitly declaring and calling some functions.",0.0,C
15wdiqh,jx0akqq,"A lot of programers, in C and C++, emulate this by explicitly declaring and calling some functions.",0.0,C++
15wdiqh,jx0akqq,This is emulated in Java and C# with static fields and static methods.,0.5,Java
15wdiqh,jx0akqq,This is emulated in Java and C# with static fields and static methods.,0.5,C
15wdiqh,jx0akqq,"A ""only one mandatory file per (file) module"" approach is better, like Delphi / Turbo Pascal.",0.25,Delphi
15wdiqh,jx0akqq,"A ""only one mandatory file per (file) module"" approach is better, like Delphi / Turbo Pascal.",0.25,Pascal
15wdiqh,jx0akqq,"C++ allows not using a namespace at all, or using anonymous namespaces, or using several same level namespaces in one single file.",-0.023809523809523808,C++
15wdiqh,jx0akqq,"C++ uses anonymous namespaces, it works, but not recommended.",0.0,C++
15wdiqh,jx0akqq,"Modula, Ada also splits ""interface"" and ""implementation"" sections.",0.0,Ada
15wdiqh,jx0akqq,Delphi and FreePascal approach works better.,0.5,Delphi
15wdiqh,jx0akqq,"**  This works similar to *.obj or *.o files and *.h, *.hpp files generated by C or C++ compilers.",0.0,C
15wdiqh,jx0akqq,"**  This works similar to *.obj or *.o files and *.h, *.hpp files generated by C or C++ compilers.",0.0,C++
15wdiqh,jx0akqq,Delphi and FreePascal and TurboPascal had this for years.,0.0,Delphi
15wdiqh,jx1p0d5,"In a sense, classes serve as poor mans modules in Java and C#.",-0.4,Java
15wdiqh,jx1p0d5,"In a sense, classes serve as poor mans modules in Java and C#.",-0.4,C
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Pascal
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Java
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Perl
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,Python
15wdiqh,jx5fasi,"Then, a very basic implementation is illuminated in [https://xavierleroy.org/publi/modular-modules-appendix/](https://xavierleroy.org/publi/modular-modules-appendix/) \- it covers both a system for ""mini ML"" and ""mini C"" (by use of modules to abstract over details, hence ""modular modules"").",0.0,C
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,Go
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,Rust
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,C
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,Swift
15wdiqh,jx15ogi,"Oh hey, we meet again :D  Good point about Modula...I guess I could peer into freepascal too.",0.85,D
15wdiqh,jxbyyzb,"I have been meaning to check out D more closely, extra motivation now :)",0.3333333333333333,D
15wdiqh,jx3ds7u,Delphi / FreePascal and C# were highly productive and organized.,0.16,Delphi
15wdiqh,jx3ds7u,Delphi / FreePascal and C# were highly productive and organized.,0.16,C
15wdiqh,jx3ds7u,BTW The same guy that lead the C# project was one of the Delphi developers.,0.0,C
15wdiqh,jx3ds7u,BTW The same guy that lead the C# project was one of the Delphi developers.,0.0,Delphi
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,Java
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,C++
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,PHP
15wdiqh,jx3ds7u,Java didn't allow this.,0.0,Java
15wdiqh,jx3ds7u,"But, in C# or FreePascal, I can have a ""Toolbars"" module with those classes.",0.0,C
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,PHP
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,C
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,Java
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,C++
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,Delphi
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,Pascal
15wdiqh,jx31loy,"There is a special main or root folder like the ""global"" namespace of C++.",0.17460317460317462,C++
15wdiqh,jx31loy,"That single module per file would be similar to a Java class declaration, but can contain types, variables, classes or types declarations, functions.",-0.03571428571428571,Java
15wdiqh,jx2url0,"https://faultlore.com/blah/swift-abi/ - Swift is a language for an OS, so they prioritized a dynamic ABI component, similar to what Windows COM solved -- dynamic  modules at bigger a scale larger than static modules   ABIs are basically the dynamic part (not compiled together) part of a static module system (compiled together)  ----  Matklad has been thinking about modules a lot too, some good observations:  https://lobste.rs/s/vx8hbs/rust_module_system_encourages_poor  https://lobste.rs/s/47amaq/rust_i_wanted_had_no_future#c_vj5c1c  https://matklad.github.io/2023/03/28/rust-is-a-scalable-language.html  ---  If you're interested in dynamic composition of components written in static languages, I'd also look at plugin systems for big apps ... almost all apps grow them -- the browser, Word, Excel, Photoshop, Maya, etc.",0.18846153846153849,Swift
15wdiqh,jy2fhvu,"For instance, functions in C are not first-class, but they are first-class in JavaScript.",0.0,C
15wdiqh,jy2fhvu,"For instance, functions in C are not first-class, but they are first-class in JavaScript.",0.0,JavaScript
15wdiqh,jy2fhvu,"There are no C expressions that denote functions, even if they might denote the memory address of a function.",0.0,C
15wdiqh,jy2fhvu,"Similarly, memory locations are first-class in C, but not in JavaScript.",0.0,C
15wdiqh,jy2fhvu,"Similarly, memory locations are first-class in C, but not in JavaScript.",0.0,JavaScript
15wdiqh,jy2fhvu,"Scala's path-dependent types, type members, and traits are also a way of doing these things, and Scala's object system is an ML-style module system if you know which angle to look at it from.",0.0,Scala
15w9zef,,"I have a kind of outdated website here [http://jeebox.org](http://jeebox.org) and you can compile it in C++ via my github at [http://gamblevore.org](http://gamblevore.org) and see some docs here [http://docs.gamblevore.org/Message.md](http://docs.gamblevore.org/Message.md)  My github has many projects within it, one is to create the libJeebox.dll (or .so or .dylib).",0.2333333333333333,C++
15w9zef,,"It will create a lib and some C++ header code, and C header code too.",0.0,C++
15w9zef,,"It will create a lib and some C++ header code, and C header code too.",0.0,C
15w9zef,,* libJeebox works but what if you are writing a compiler in another language that doesn't work with C APIs?,0.0,C
15w0gic,jwzwws7,"Using Rust as an example, you'd end up with something like this:      struct GetField { receiver: Expression, name: String }     enum Expression { GetField(Box<GetField>), ... }  If you want a chain of fields to result in a single AST node, you'd need something like this instead:      struct FieldChain { receiver: Expression, names: Vec<String> }  That way you'd end up with something like this:      (field ""attr1"" ""attr2"" (identifier ""value""))",-0.4107142857142857,Rust
15vmmet,,"The quote :  ""I’ve programmed systems in many different languages; from assembler to Java.",0.25,Java
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Fortran
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,COBOL
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,C
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Pascal
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,C++
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Java
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,Lua
15vmmet,,"I’ve used stack based languages like Forth, and logic based languages like Prolog.""",0.0,Forth
15vmmet,,"I’ve used stack based languages like Forth, and logic based languages like Prolog.""",0.0,Prolog
15vmmet,jww6tts,"They aren't the only typeless languages, BCPL, BLISS, Forth, TCL and Bourne shell are typeless languages.",0.0,Forth
15vmmet,jww6tts,"""System languages"" need some typeless aspects to do what they are designed to do, hopefully those features are well controlled (that's not always the case, for instance C++ having evolved from C which itself can be considered as adding static types to BCPL have aspects which are justifiable only by its root in an untyped language).",0.25,C++
15vmmet,jww6tts,"""System languages"" need some typeless aspects to do what they are designed to do, hopefully those features are well controlled (that's not always the case, for instance C++ having evolved from C which itself can be considered as adding static types to BCPL have aspects which are justifiable only by its root in an untyped language).",0.25,C
15vmmet,jww6tts,"Static languages tend to acquire dynamic aspect (see the addition of object systems to C, Pascal, ML).",0.25,C
15vmmet,jww6tts,"Static languages tend to acquire dynamic aspect (see the addition of object systems to C, Pascal, ML).",0.25,Pascal
15vmmet,jww6tts,"Dynamic languages also can acquire static aspects (see Typescript for Javascript, the type annotation of Python).",0.25,Python
15vmmet,jww6tts,"Word for older assembly language, BLISS, BCPL, Forth.",0.16666666666666666,Forth
15vmmet,jwwyvaz,"You should try Forth  Also I think you're mistaking ""memory layout"" for ""type"" and these are different aspects of computing systems",0.0,Forth
15vmmet,jwwcmuu,Assembly (on most platforms) is a typeless language.,0.5,Assembly
15vmmet,jwwcmuu,Forth is an interesting programming language because it has this very same property.,0.25,Forth
15vmmet,jwwcmuu,Forth is a very simple virtual machine you can build for yourself in just a few hundred lines of assembly code.,-0.1,Forth
15vmmet,jwwcmuu,"It is significantly nicer than Assembly, without being meaningfully limited in scope and power, compared.",0.1517857142857143,Assembly
15vmmet,jwxmzll,"According to wikipedia, the following are typeless languages:  * AutoHotkey * B * BCPL * Bliss * Forth * MUMPS (M) * Rexx",0.0,Forth
15vmmet,jwvysqe,Clojure is probably a combination of the first 2.,0.25,Clojure
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,Java
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,C
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,Rust
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,Assembly
15vmmet,jxd4gnp,"Looking at Ada, it doesn’t have an Integer type.",0.0,Ada
15vmmet,jwwr8bh,"And of course, JavaScript comes to mind, unbidden, like a mosquito on the patio.",0.0,JavaScript
15vmmet,jwz6wzl,"Then I think you can *make* any language produce at least *runtime* type errors, for example you can create a JavaScript function that throws an error when it gets passed a non-integer-number, and you can make any typed language ignore some sort of type errors – in the sense that you can pass a non-e-mail-address to a function that expects an e-mail-address or a value in inches to a function that expects centimeters.",-0.3,JavaScript
15vmmet,jwz6wzl,Python can't prevent you from only using strings to represent numbers.,0.0,Python
15vmmet,jwz6wzl,"Different thought:  In C, an `unsigned char` is used to represent a number between 0 and 255.",0.0,C
15vmmet,jwwzt43,"(in Forth there is no syntax distinction between ASCII 'A', an integer 97, a pointer to the 97th word of memory, etc.",0.0,Forth
15vmmet,jx06f4d,I’ve been a Clojure programmer for a decade and his Clojure articles are rubbish.,0.0,Clojure
15vmmet,jx06f4d,His published Clojure code is horrible.,-1.0,Clojure
15vmmet,jx18sxt,You may have heard of it -- they called it `C`.),0.0,C
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,C
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,C++
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,Haskell
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,Lisp
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,Eiffel
15vmmet,jwz8n75,"For example, an i8 in Rust contains all integers from -127 to +128.",0.0,Rust
15vbuyi,jwuwgs2,"So yeah, here are some facts about established programming languages:   Java does what you do.",0.0,Java
15vbuyi,jwuwgs2,Scala works around the JVM limitation by introducing a compiler feature similar to C++ templates but much more limited.,0.14285714285714288,Scala
15vbuyi,jwuwgs2,Scala works around the JVM limitation by introducing a compiler feature similar to C++ templates but much more limited.,0.14285714285714288,C++
15vbuyi,jwuwgs2,"In C#, generic type information is tracked at runtime.",0.0,C
15vbuyi,jwuwgs2,"Put in any other type and it's a T** if you're thinking in C (where the last layer is the pointer to the list which holds the array, since a list is a reference type).",-0.0625,C
15vbuyi,jwuwgs2,C++ obviously has templates.,0.0,C++
15vbuyi,jwuwgs2,"Similar to C#, but much more powerful.",0.26666666666666666,C
15vbuyi,jwuwgs2,"C has macros for this, which leads to all sorts of awful hacks to have generic collections.",-0.5,C
15vbuyi,jwupjpn,"A normal vector implementation looks like this (I'm using C++ because it gives low-level control):      template <class T> class vector {       T* data;       std::size_t len;       std::size_t cap; // you could have the invariant that len == cap, but then you can't over-allocate     public:       vector(): data(nullptr), len(0), cap(0) {} // don't allocate for an empty vector       vector(vector<T> const& other): data(std::malloc(other.len)), len(other.len), cap(other.len) {         std::memcpy(data, other.data, len);       }       ~vector() {         for (std::size_t i = 0; i < len; ++i) {           (data + i)->~T(); // call destructors on the data         }         std::free(data);       }       void reserve(std::size_t new_cap) {         if (cap < new_cap) {           data = std::realloc(data, new_cap);           cap = new_cap;         }       }       // these are the mutable accessors, constant ones are basically the same       T& operator[](std::size_t idx) {         // maybe add a bounds check         return data[idx];       }       T& first() {         return *data;       }       T& last() {         return data[len - 1];       }       void push_back(T val) {         if (len + 1 >= cap) {           switch (cap) {             case 0: reserve(1); break;             case 1: reserve(4); break; // skip from 1 to 4 because that's better in most cases             default: reserve(cap * 2); break; // double capacity to over-allocate           }         }         ++len;         last() = std::move(val);       }       // depending on your language, you might want to implement emplace_back, it's not too complicated       void pop_back() {         if (len) {           --len;           (data + len)->~T(); // call the destructor of the last element         }       }     };  This is a simplified implementation of C++'s `std::vector`.",0.048214285714285716,C++
15vbuyi,jwxplc8,"The capacity can be part of the static type, as in C++ `array<t, 255>`.",0.5,C++
15vbuyi,jwxplc8,However this will require your language to support something similar to C++ template specialization.,0.0,C++
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,Go
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,Rust
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,C
15uwmsd,,"Swift uses `:` for passing arguments to named parameters (`foo(a: 10)`), why not `=`?",0.0,Swift
15uwmsd,jwsq4yg,Ruby also uses `:` for passing named parameters.,0.0,Ruby
15uwmsd,jwsq4yg,"And in Ruby's particular case, it makes a lot of sense.",0.16666666666666666,Ruby
15uwmsd,jwsq4yg,"Now Ruby has real named arguments, so the ""turn it into a hash argument"" rule only kicks in on old-style functions that don't take any named parameters.",0.1,Ruby
15uwmsd,jwskpy9,"In the C family of languages, assignment is an expression, so `a = b = c` is legal, and as a result, the `=` operator is a poor choice for named arguments.",-0.1,C
15uwmsd,jwskpy9,"The `=` assignments as expressions also leads to a few classes of common bugs in C family languages, so it's hard to defend in a new language, although it's easy to understand in an old languages with an enormous legacy codebase.",-0.017424242424242432,C
15uwmsd,jwu12xp,"IIrc, C# also use ':' for passing named arguments.",0.0,C
15uwmsd,jwtku1p,"Anyway, C making a ""virtue"" out of it (I believe Ritchie or someone else used the argument that assignment was more frequent than comparison for equality) and picking ""=="" for equality, at a time when ASCII was used, well *that* should not have happened.",0.3,C
15uwmsd,jwtnqv4,Python semi-recently added `:=` for assignment expression.,0.0,Python
15uwmsd,jx0g70f,Like in Prolog or Ting.,0.0,Prolog
15uwmsd,jwx7u86,"In languages like LISP, PROLOG or APL which build off math directly you don't have this issue (APL uniquely because assignment is considered).",0.2375,APL
15uwmsd,jx8xl8u,"Languages from the 70ies managed to get this right, Rust somehow regressed on that.",0.2857142857142857,Rust
15uwmsd,jwvn0ee,"The is a possibly well-known blog from a few years ago, that describes a ""mystery language"", comparing it with Go, and concluding they are nearly feature-equal, and then revealing the language to be Algol 68, which was defined in 1968 (and revised, mostly to give it a more format semantic definition, in 1974.)",0.18,Go
15uwmsd,jwvqfuw,"But there's also a universal ""C"" locale that you can place universal symbols for things in, like `==()`.",-0.25,C
15uwmsd,jxe2c58,"This often happens to comments mentioning Rust, but that's not my loss; I remember the things I write pretty well.",0.25,Rust
15uwmsd,jx1j6st,"You may recall that HTML used SGML entities for character names; again, iirc, some Danish standards people were very annoyed that the name for our letter Æ/æ was demoted to be a ""ligature"": Aelig/aelig.",-0.52,HTML
15uwmsd,jx1j6st,"I understand that part of Unicode's early ""mission statement"" was also to reconcile many kinds of code pages that had been in use, so fx ""℃"" exists as a codepoint (U+2103), even if the degree symbol ""°"" existed in Latin1, and we will typically write ""degrees Celsius"" as ""°C"" (two codepoints: °: U+00B0 and C: U+0043.)",0.14444444444444446,C
15uwmsd,jx1j6st,"This is why we got the infamous lexer problem in C, when typedefs were added to the language!",-0.625,C
15uwmsd,jx1j6st,"Using different styles as distinct symbols, in addition to solving the C lexer problem with types, also could solve the problem the C standards committee is having when needing to introduce new keywords at this point in C's lifecycle.",0.14545454545454545,C
15uq630,jwr13cg,"Haskell supports this (as well as embedded DSLs) through ""quasi quotes"" – blocks which are parsed with some custom parser, rather than by the main compiler.",0.16666666666666666,Haskell
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,C
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,C++
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,R
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,JavaScript
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,Java
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,Haskell
15uq630,jwr13cg,"When done well, the downsides are few (some extra complexity in the build process), and I find it a very convenient way of testing and running C and C++ code.",0.0,C
15uq630,jwr13cg,"When done well, the downsides are few (some extra complexity in the build process), and I find it a very convenient way of testing and running C and C++ code.",0.0,C++
15uq630,jwqz0ba,Rust does this via proc macros.,0.0,Rust
15uq630,jwqz0ba,"Right now I am aware of C, lisp, html, sql, latex and (for some cursed reason) gnu cobol.",0.26785714285714285,C
15uq630,jwr5ajj,"In Perl, this isn't a *language* feature, strictly speaking, but there's [a collection of modules](https://metacpan.org/pod/Inline) called `Inline` that let you embed code in other languages, well, inline.",-0.125,Perl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,C
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Perl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,C++
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Python
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Tcl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,Java
15uq630,jwsee3q,"The usual suspects get mentioned (Haskell's quasiquoting, Racket) but also some others.",-0.25,Haskell
15uq630,jwsee3q,** Since around 2000 Perl devs have been able to import foreign PL modules and/or embed foreign PL code via [`Inline`s](https://metacpan.org/search?size=500&q=inline) that embed *existing* implementations of foreign PLs into Perl programs.,0.03125,Perl
15uq630,jwsee3q,"Stefan Seifert, the author of several Perl `Inline`s brought the same tech to Raku, and has since taken it to new levels.",0.04545454545454545,Perl
15uq630,jwtn6ib,Common Lisp is one.,-0.3,Lisp
15uq630,jwrq5h8,"Although it mostly is in the form of strings, there are many DB systems that provide a processor to allow embedding SQL into C programs (and other languages), including PostgreSQL ECPG.",0.2916666666666667,C
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,HTML
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,JavaScript
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,PHP
15uq630,jwrq5h8,"Embedding for example a C snippet in a Pascal program is probably not very useful, for that the languages are not sufficiently dissimilar.",-0.11538461538461536,C
15uq630,jwrq5h8,"Embedding for example a C snippet in a Pascal program is probably not very useful, for that the languages are not sufficiently dissimilar.",-0.11538461538461536,Pascal
15uq630,jwrq5h8,Then of course there is C embedding in C++ to some degree.,0.0,C
15uq630,jwrq5h8,Then of course there is C embedding in C++ to some degree.,0.0,C++
15uq630,jwrq5h8,And asm sections in both C and C++ programs.,0.0,C
15uq630,jwrq5h8,And asm sections in both C and C++ programs.,0.0,C++
15uq630,jwrq5h8,"Finally, applications that use extension languages like ECMAScript or Lua will probably also include some code, but again this is most likely in the form of strings.",0.16666666666666666,Lua
15uq630,jwrq5h8,"Finally Perl has had support for various language extensions and embedding for decades, ranging from C (using XS) to ""Latin"".",0.0,Perl
15uq630,jwrq5h8,"Finally Perl has had support for various language extensions and embedding for decades, ranging from C (using XS) to ""Latin"".",0.0,C
15uq630,jwrq5h8,"How many and to what extent they are actually used (except that C for obvious reasons is used for integrating Perl with C-based libraries), I don't know.",0.16666666666666666,C
15uq630,jwrq5h8,"How many and to what extent they are actually used (except that C for obvious reasons is used for integrating Perl with C-based libraries), I don't know.",0.16666666666666666,Perl
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,C
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,Perl
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,C++
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,Lua
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,Pascal
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,C
15uq630,jwrq5h8,"Lexer (.lex) definition files for (f)lex, and grammar (.y) files for yacc/Bison could also be considered DSLs with embedded C code.",0.0,C
15uq630,jwto0dk,"Perl is a multi-syntax language: It has regular code, POD, regex, strings, and here-documents.",0.0,Perl
15uq630,jwsfkbi,Other examples React and C# linq,-0.125,C
15uq630,jxfktx1,"Other people already mentioned web front-end languages like HTML/JS/CSS, plus backend languages like PHP, ASP, etc.",-0.125,PHP
15uq630,jxfktx1,"For example, if you open a large HTML file and jump to the middle of the file, the syntax highlighting needs to know whether it's inside a `<script>` tag or not, which requires scanning the entire file from the start to properly answer.",0.04285714285714286,HTML
15uq630,jxfktx1,"HTML/PHP solve this problem by using delimiters that aren't valid code in the embedded language (`</script>` is not valid JS, and `?>` is not valid PHP).",0.0,PHP
15uq630,jxfktx1,Perl regex solves the problem by providing a wide range of ways to quote regexes so you can always find a delimiter that isn't used in your pattern.,-0.1,Perl
15uq630,jwsjscy,Examples: C# / .NET -- _most_ of the other languages on the CLR are basically just C# with a little syntactic sugar.,0.0625,C
15uq630,jwtbvvh,Ruby on Rails does that - to the point that it becomes a nightmare to work with it - every single DSl has its own complexities and peculiarities to the point that it feels like working in different languages.,0.1761904761904762,Ruby
15uq630,jwtuqu8,To some degree Rust's proc macros fit the definition.,0.4,Rust
15uq630,jwvm6hv,"For example, in Rust, expressions that appear inside the vec!",0.0,Rust
15uq630,jx0gj93,"At the time, I was also programming C and Fortran on the other Crays (running Unix).",-0.125,C
15uq630,jx0gj93,"At the time, I was also programming C and Fortran on the other Crays (running Unix).",-0.125,Fortran
15uq630,jwtv0ex,maybe script/style tags in HTML?,0.0,HTML
15uq630,jwrr2lj,And other Scheme and LISP variants are also often used as embedded extension languages - emacs probably being the best known example.,0.4375,Scheme
15uq630,jwrr2lj,"To what degree that actually includes code embedded directly in the C code, I do not know.",0.05,C
15uq630,jwt7dwl,;D !<,0.3125,D
15uq630,jwuylx7,"Rust's proc macro system is pretty amazing, it allows for the embedding of other DSLs with proper syntax checking, strong typing guarantees, and escape hatches to compute runtime values through rust.",0.2316666666666667,Rust
15uejj0,,"Hi, I just made this language in C++, with an interpreter and C++ transpiler, and also a web app to use it.",0.0,C++
15uejj0,jwqrszy,You should look at COBOL.,0.0,COBOL
15uejj0,jwtdls5,If your goal is to be more accessible than python you probably shouldn't need to download a C++ and ES compiler before you can use the language.,0.4375,C++
15uejj0,jwr5o34,The organization of your code (all in header files) makes it look like you don't know how to write idiomatic C++.,0.0,C++
15uejj0,jwr5o34,I see that your C++ transpiler dumps `using namespace std` into the generated code.,0.0,C++
15uae4o,jwpl5if,Have a look for Modern Compiler Implementation in Java by Andrew Appel.,0.2,Java
15uae4o,jwpl5if,"E: there's a version of the book using C++ too, take your pick.",0.0,C++
15uae4o,jwos6zr,"And Microsoft's Dotnet engineers seem to agree, with the new open source Roslyn C# compiler being fully functional and immutable.",0.06818181818181818,C
15uae4o,jwpx2yk,I can think of some references you might appreciate:  * [Object Oriented Programming in Common Lisp](https://en.wikipedia.org/wiki/Object-Oriented_Programming_in_Common_Lisp) - I enjoyed this book; especially the example at the end about implementing a range of different kinds of IO streams.,0.05,Lisp
15uae4o,jwpx2yk,I remember it being a more compelling illustration of OO than the C++ examples I was used to reading at the time.,0.4,C++
15uae4o,jwpx2yk,* [Lisp in Small Pieces](https://pages.lip6.fr/Christian.Queinnec/WWW/LiSP.html) - It has a chapter towards the end about organizing a compiler in an object oriented style.,-0.25,Lisp
15uae4o,jwq2zfd,First question: How well do you know C++ or Java?,0.25,C++
15uae4o,jwq2zfd,First question: How well do you know C++ or Java?,0.25,Java
15uae4o,jwolatx,"Compiler *C = new JavaCompilerClass();     ...     C->assignSource(""c:\test\helloworld.java"");     C->Compile();     ...     free C();      class JavaCompilerClass : CompilerClass     {        ...        ...     } ;          class CompilerClass     {        ...        ASTClass* AST;        SymbolTableClass* SymbolTable;        ...        LexerClass* Lexer;        ParserClass* Parser;        ...     } ;         Just my two cryptocurrency coins contribution...",0.2681818181818182,C
15uae4o,jwpoyrq,"came to suggest Appel's book, he also made variants in C and ML for comparison",0.0,C
15uae4o,jx6zrki,"Quite a long time ago - the only language the students had in common was Java, which was the reason for choosing it.",-0.11666666666666665,Java
15uae4o,jwoxxd1,"You'd have a very large function that takes a user input and the current total UI state, and returns a new UI state (see the Elm language).",0.10373376623376623,Elm
15uae4o,jwoxxd1,Just compare ready-to-go React widgets to what Elm offers.,0.1,Elm
15uae4o,jx779z0,">Crafting Interpreters by Nystrom is a very well written book  Ah yes, I loved going through creating Lox with C#, it was quite fun.",0.39999999999999997,C
15uae4o,jx779z0,"Though, C# is very slow to start up.",-0.39000000000000007,C
15tzhae,jwpo3kc,For reference: the D reference compiler lowers foreach and while to for loops.,0.0,D
15ty5ei,jwuv24z,"Most notably, the basic usecase of iterating over an array -- which in C is done by just incrementing a pointer -- seems like it could suffer quite a bit of overhead if the iterator was implemented as a wholly separate stack.",0.3333333333333333,C
15tw2nd,jwnmiqz,"Better still, write the compiler in Python, and take over a supercomputer, there's work to be done!",0.625,Python
15tp88l,jwlnqwg,"Ones like gcc on my machine, for an easy-to-compile language like C, might manage 10-20K lines per second, slower if optimising.",0.0,C
15tp88l,jwlnqwg,Tiny C might do 500-1000K lines per second.,0.0,C
15tp88l,jwkyum2,"Take C, C++, C#: you can compile a unit of code to a dynamically linked library (.dll, .so).",0.0,C
15tp88l,jwkyum2,"Take C, C++, C#: you can compile a unit of code to a dynamically linked library (.dll, .so).",0.0,C++
15tp88l,jwkyum2,Or you could look into how Rust works.,0.0,Rust
15tp88l,jwojs8n,In C / C++ this is sort of simulated with *.obj and *.h files.,0.0,C
15tp88l,jwojs8n,In C / C++ this is sort of simulated with *.obj and *.h files.,0.0,C++
15tp88l,jwojs8n,In Java this is done with *.class files.,0.0,Java
15tp88l,jwojs8n,"Delphi has been doing this for decades, with it's own intermediate code files.",0.6,Delphi
15tp88l,jx8sgzf,"In another comment, it appears you are using C++'s `std::map` which is notoriously slow.",-0.30000000000000004,C++
15tp88l,jwn88sf,"I would take a look at speeding the compiler up rather than doing any incremental compilation, which can be a nightmare & very error prone  For reference, [TCC](https://www.bellard.org/tcc/) was compiling 1 mil lines per sec of C on a 2.4ghz pentium 4, which is a single core 32-bit cpu that *doesn't* have any of the nice simd instructions  Given that any cpu you have today is *at least* 10x faster than this, you'd better be doing *at least* 350x more semantic analysis than C to make it worth it!",0.15595238095238095,C
15tkpyo,,I wrote a primitive Lisp parser in OCaml [https://github.com/BranislavLazic/yaran](https://github.com/BranislavLazic/yaran).,0.0,Lisp
15t0pad,jwhbpgk,"As part of the 'interface' (called instance arguments in Agda; similar to typeclasses in Haskell) you can declare a proposition that must hold for any instances, and instances must define a machine-checkable proof of this proposition for the given type.",0.0,Haskell
15t0pad,jwie757,C# has (or had) this functionality with Code Contracts.,0.0,C
15t0pad,jwos6vx,"C++ can do it: [https://godbolt.org/z/4P98obn55](https://godbolt.org/z/4P98obn55)      #include <concepts>          template<typename T>     concept IAdder = requires {         { T::add(int{}, int{}) }->std::integral;         requires (T::add(5, 9) == 14);     };          struct SimpleAdder {         static constexpr auto add(auto x, auto y) { return x + y; }     };          struct FakeAdder {         static constexpr auto add(auto x, auto y) { return 9; }     };          auto main()->int {         static_assert(IAdder<SimpleAdder>);         static_assert(!IAdder<FakeAdder>);     }",0.08333333333333333,C++
15t0pad,jwhp9zt,At least when I first learned it (Idris 1) it felt like a very natural extension of Haskell.,0.026666666666666672,Haskell
15t0pad,jwhsow4,"C# or Java) so it's whatever the target language compilation is, with a small overhead.",-0.25,C
15t0pad,jwhsow4,"C# or Java) so it's whatever the target language compilation is, with a small overhead.",-0.25,Java
15s4uea,jwdnwoi,"It may be as simple as emmitting a SVG or a PNG, or drawing in a HTML Canvas.",0.0,HTML
15s4uea,jwdnwoi,"Start scribling things around, maybe you want to draw a triangle, you may write something like: `define A, B, C to be points; Draw a line from A to B, B to C and A to C`, well, english has no good structure to parse and this is very verbose, so you may try and insert some keywords, and a few rules like ""uppercase letters are always points"" to make it more concise: `def A, B, C; Line A B; Line B C; Line A C`, and from there you continue this process of trying things, defining grammar, changing grammar, until you arrive at something you're happy with.",0.15,C
15s4uea,jwfqtz0,"&#x200B;  I first went with LLVM, but i had to learn the tool, which is very time consuming, and I also had to learn C++, which again, is very time consuming.",0.21666666666666667,C++
15s4uea,jwcdl3g,"I think future languages will support things that are currently done in libraries or functions today, like we are already seeing for example with goroutines in Go.",0.0,Go
15s4uea,jwcdl3g,"in C#, we can’t set any priority to control which tasks should be performed first.",0.25,C
15s4uea,jwp99c0,"Go ahead, make something weird, nobody will probably ever use it.",-0.5,Go
15s4uea,jwmoslg,"Though there is a discontinuity between the Lisp level and the lower-level implementation language, their implementations can share most of the code.",0.5,Lisp
15s4uea,jwpkfsb,"However postfix concatenative languages, like Forth, are another competing influence in my thinking.",0.0,Forth
15s4uea,jwpkfsb,I need to look at how stdio is actually implemented in various C libraries.,0.0,C
15s4uea,jwpkfsb,"Riding on top of C, is not necessarily the direction I want to take.",0.25,C
15s4uea,jwrkluf,[https://piumarta.com/software/maru/](https://piumarta.com/software/maru/)   [https://github.com/attila-lendvai/maru](https://github.com/attila-lendvai/maru)  You probably would want to bootstrap a compiled Lisp.,0.0,Lisp
15s4uea,jwrkluf,No C required.,0.0,C
15s4uea,jwrkluf,"It's a much more complex system, but the Yale T system (a Scheme dialect) was implemented entirely in its own language, save for a tiny assembler stub to initialize.",0.16,Scheme
15s4uea,jwrkluf,"Scheme-48 runs on a VM that is implemented in PreScheme, an embedded language that is compiled into C, but you could go direct to machine code.",0.1,C
15s4uea,jwrkluf,"[https://mumble.net/\~jar/tproject/](https://mumble.net/~jar/tproject/)  [https://www.s48.org/](https://www.s48.org/)  From your remarks about Forth and concatenative languages, however, it may be that you are going for something substantially simpler, and a self-compiling compiled Lisp exceeds your complexity budget.",0.0,Forth
15s4uea,jwrkluf,"[https://mumble.net/\~jar/tproject/](https://mumble.net/~jar/tproject/)  [https://www.s48.org/](https://www.s48.org/)  From your remarks about Forth and concatenative languages, however, it may be that you are going for something substantially simpler, and a self-compiling compiled Lisp exceeds your complexity budget.",0.0,Lisp
15s4mez,jwpcuih,":-)  In the somewhat weird language I am designing right now, I currently use a 𝐩𝐫𝐨𝐜 keyword next to the parameter list; but that is because I expect to use the C preprocessor (with 𝐩𝐫𝐨𝐜 being a macro) to ""compile"" the language to C, and I need to pass the parameters to a macro for manipulation.",0.05714285714285714,C
15s0ox6,,"For example, in the following Haskell code the well-formedness of expressions is ensured at compile time:      data Term a =         IntLit :: Int -> Term Int         BoolLit :: Bool -> Term Bool         Add :: Term Int -> Term Int -> Term Int         Equal :: Term x -> Term x -> Term Bool      -- Bool to bool comparison is fine.",0.1388888888888889,Haskell
15s0ox6,jwewou4,"Sidenote: the very first code sample (in TypeScript) seems messed up: SerializerOf vs. TypeName, StringSerializer vs. ""string"".",0.325,TypeScript
15s0ox6,jwf82kw,String -> Term a  or written in a way that is valid Haskell today      data SomeTerm where         MkSomeTerm :: Term a -> SomeTerm          parse :: String -> SomeTerm,0.0,Haskell
15s0ox6,jwmqqo5,"Haskell might not have this problem, as it has GADTs and type-directed compilation.",0.0,Haskell
15s0ox6,jwc8xyf,There is no such facilities in vanilla Haskell.,0.0,Haskell
15s0ox6,jwn1cby,"As far as I understand, Haskell's GADTs are just like OCaml's in this regard.",0.1,Haskell
15s0ox6,jwn1cby,What's close to mapping types is type families in Haskell.,0.0,Haskell
15ryfsq,jwcohca,"The main motive would be a language that was ""kinder"" than C...  That being said if I had to make some guesses:  - labelled jumps / gotos, if statements for control flow.",0.16666666666666666,C
15rxlp0,jwbximp,"Of course, the point is moot when you're transpiling to C (or Rust?",0.0,C
15rxlp0,jwbximp,"Of course, the point is moot when you're transpiling to C (or Rust?",0.0,Rust
15rxlp0,jwbbt11,"Transpiler is a useless word invented\* by people who felt it dishonest to call their creation a compiler, because our collective misunderstanding of the word ""compiler"" is informally centered around the traditional notion of a batch Fortran or C compiler.",-0.26666666666666666,Fortran
15rxlp0,jwbbt11,"Transpiler is a useless word invented\* by people who felt it dishonest to call their creation a compiler, because our collective misunderstanding of the word ""compiler"" is informally centered around the traditional notion of a batch Fortran or C compiler.",-0.26666666666666666,C
15rxlp0,jwbdvv7,This is especially true if both the source and the target for a transpiler are C style languages.,0.7,C
15rxlp0,jwdzulb,"I make transpilers for languages that are similar to C, so I can take advantage of the mature optimizations of C compilers that I couldn't hope to match.",0.05,C
15rxlp0,jwdlj8v,"Your average programmer (who had one compiler class, if that, years ago and then forgot everything in it as soon as it was over) says ""compiler"" to mean ""I run this program, it takes in source code and spits out something I can execute"", while they say ""transpiler"" to mean ""I run this program, it takes in source code and spits out some other source code I could inspect and mix in with other source code before having to compile again""  Which is a valuable distinction when you're trying to, say, justify using $HotNewLanguage to your team, or seeing if you can still use a certain library you need to use without having to worry about mangling and linking (or worse, figuring out some way to have 2 processes talk to each other), or seeing if you can use that language in $CertainHardware which uses a funky architecture and only has a proprietary C compiler.",-0.1484126984126984,C
15rxlp0,jwdlj8v,The JS dev who's been told to use Babel or the fresh graduate who has to use some JVM language that transpiles to Java are just working a different level and care more about the differences as they see it.,0.26666666666666666,Java
15rxlp0,jwcoppz,"So if I built something and I say “I transpile to C”, then I am highlight that there is a trade off I’ve made, that might be interesting.",0.5,C
15rxlp0,jwbussy,Assembly is definitely a programming language and we would still say you are compiling C even if you emit assembly instead of an executable.,0.0,Assembly
15rxlp0,jwbussy,Assembly is definitely a programming language and we would still say you are compiling C even if you emit assembly instead of an executable.,0.0,C
15rxlp0,jwch2qt,"When C was first introduced, it was considered high level.",0.20500000000000002,C
15rxlp0,jwg5uh4,"Hell, sometimes the categories change based on context — Nim is a transpiler in the sense that it targets a (relatively) high-level programming language, but it's also not a transpiler in the sense that C is just an IR that will immediately be compiled to machine code.",0.0,C
15rxlp0,jwfbemg,"btw: transpilers to C are usually called compiler, as this C is portable assembler enough.",-0.125,C
15rxlp0,jwcleep,Do you consider a distinction between Java bytecode and Java source code to be valuable?,0.0,Java
15rxlp0,jwbwqwr,That's a world of a difference  (And yes there are things like Forth or the Symbolics Lisp Machines that blur this line too)  I really don't care what businesses or marketing care about.,0.2,Forth
15rxlp0,jwbwqwr,That's a world of a difference  (And yes there are things like Forth or the Symbolics Lisp Machines that blur this line too)  I really don't care what businesses or marketing care about.,0.2,Lisp
15rxlp0,jwcrj2d,"for Android, Java to JVM bytecode to DEX to machine code) and also some interpreting going on for JS in the browser, but the vast majority of activity on your device was machine instructions from actually-compiled code.",0.0,Java
15rxlp0,jwbvc8i,_(Compare any ISA to Java bytecode from the JVM spec if you don't have experience in this area.,0.0,Java
15rxlp0,jwbrvi5,"Like if the target is C, then you get the full optimization facilities of an industrial strength C compiler, whereas if the target is asm you get (basically) nothing.",0.35,C
15rxlp0,jwd7f0r,I think a compiler that compiles to C would be considered a transpiler by most people.,0.5,C
15rxlp0,jwcmmqk,"Yes, of course, but that doesn't make Java bytecode machine code.",0.0,Java
15rxlp0,jwceq7f,"So `cc1`, the program `gcc` uses to compile C is not a compiler?",0.0,C
15rxlp0,jweufm5,> Symbolics Lisp Machines that blur this line too  They still have assembly.,0.0,Lisp
15rxlp0,jwcswrf,"Like x86-64 can be one final target, but C broadens that to dozens of architectures (ignoring portability concerns).",0.0,C
15rxlp0,jwehn98,Languages like C and Rust are both high and low level languages depending on context.,0.08,C
15rxlp0,jwehn98,Languages like C and Rust are both high and low level languages depending on context.,0.08,Rust
15rxlp0,jwehn98,It also presents the question of what happens if I generate C then run gcc under the hood.,0.0,C
15rxlp0,jwehn98,Is C just another IR at that point?,0.0,C
15rxlp0,jwgarff,"/u/reini_urban was [just arguing](https://www.reddit.com/r/ProgrammingLanguages/comments/15rxlp0/comment/jwfbemg/?utm_source=share&utm_medium=web2x&context=3):  > btw: transpilers to C are usually called compiler, as this C is portable assembler enough.",0.08333333333333333,C
15rxlp0,jweitbq,"People still write loads of assembly too, especially for small 8-bit MCUs where a compiler simply is too much overhead ;)  But I see your point, in the compiling to C case, I'd argue the whole thing boxed together thing with gcc is a compiler.",0.06666666666666667,C
15rxlp0,jwoelia,> C and Rust are both high and low level languages depending on context  Your classification mentality makes this sound so complicated but it's really just relative.,0.04333333333333334,C
15rxlp0,jwoelia,> C and Rust are both high and low level languages depending on context  Your classification mentality makes this sound so complicated but it's really just relative.,0.04333333333333334,Rust
15rxlp0,jwoelia,In the early home computing world C was considered a middle-ground of abstraction between writing in an assembly language and writing in something like BASIC.,0.05,C
15rxlp0,jwfqyg4,"Again, pointing to CoffeeScript as an example (or TypeScript, for that matter).",0.0,TypeScript
15rxlp0,jwfqyg4,Examples of the first definition would be CoffeeScript and TypeScript.,0.25,TypeScript
15rxlp0,jwfq0oy,"The kids these days, so soft and sheltered, I cannot possibly imagine why would someone not be able to understand the machine generated assembly for a 100k line C program.",0.19999999999999998,C
15rsd77,,"(Elixir, F# will treat middle part as  `(upper() + """"B)(""a"")`).",0.0,Elixir
15rsd77,jwagx4q,"Shell scripting seems to be the obvious example, though I'm not quite getting how your example works.",0.0,Shell
15rsd77,jwb6kob,This C++ proposals explores a bunch of possibilities: https://wg21.link/p2672r0,0.0,C++
15rsd77,jwbxxp7,"> `|` op has a lower precedence   > Elixir, F# will treat middle part as `(upper() + """"B)(""a"")`  That it has lower precedence than `+` is why it's parsed this way.",0.0,Elixir
15rsd77,jwc3sae,"`(+ ""B"")` like Haskell or `(_ + ""B"")`, `(\x -> x + ""B"")`, `&(&1 + ""B"")` in some other languages.",-0.125,Haskell
15r4qj3,jw9wgj5,"One of the first RPython languages, a Prolog, was already implemented as an AST interpreter.",0.25,Prolog
15r1cgs,,"""`  *Looping, if-else and python inspired first class list*  `var names = [""Alice"", ""Bob"", ""Callum""]`  `loop name in $names {`  `if $name == ""Callum"" {`  `echo ""Hello, enemy""`  `} else {`  `echo ""Hello, friend""`  `}`  `}`  &#x200B;  &#x200B;  &#x200B;",0.25,Alice
15r1cgs,jw6pzzg,"I have *thoroughly* learned all the junk in Bash, but it’s always a wearying distraction from whatever my main task is.",0.16666666666666666,Bash
15r1cgs,jwareyj,"Bash and zsh and sh are sort of like giraffes: they're evolutionarily optimized for this one weird set of tasks, which makes them look very different from every other language and makes them kinda bad at things outside their target domain.",-0.26499999999999996,Bash
15r1cgs,jwareyj,It would be handy if there were string literals that could use arbitrary delimiters like `/../` or `|..|` or `[==[..]==]` to make it easy to do stuff like pass shell commands as arguments without getting [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome)  - Shell functions should _really_ have locally scoped variables.,0.2722222222222222,Shell
15r1cgs,jwbhpx5,"Bash needs a return statement to be easy to return with values from functions, also json as a built in type with support.",0.43333333333333335,Bash
15r1cgs,jwakbvm,Shell scripts are not the same domain as Rust.,0.0,Shell
15r1cgs,jwakbvm,Shell scripts are not the same domain as Rust.,0.0,Rust
15qxqf9,jw7ue4v,So folk who like Python's lax attitude toward identifiers can just write stuff like `foo = 42`.,0.0,Python
15qxqf9,jw716v0,[APL](https://en.wikipedia.org/wiki/APL_(programming_language)) enters the chat,0.0,APL
15qxqf9,jw68iei,"It's required for interoperability with weird C libraries, but also great for implementing languages since you are not restricted to only Zig allowed values.",0.10000000000000002,C
15qxqf9,jw62wgv,Identifiers in Julia can end with '!'.,0.0,Julia
15qxqf9,jw8d1x0,End a case-construction with `esac` because ALGOL.,0.0,ALGOL
15qxqf9,jwe91tn,&#x200B;  This maybe look rather conventional at first glance ... but then consider that this is plain C code compiled with the ordinary gcc compiler!,-0.10491071428571427,C
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,Pascal
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,C
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,C++
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,C
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,C++
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,JavaScript
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,Pascal
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,Delphi
15qxqf9,jw70ex9,"Scanner in Kotlin:      const val ctquote: String   = ""'""     const val ctquote2: String  = """" + 34.toChar()     const val ctivar: String    = ""#""     const val ctdef: String     = ""==""     const val ctddot: String    = ""..""     const val ctcomment: String = ""//""     const val ctcomp: String    = ""°""     const val ctcombine: String = ""Combine""     const val cterror: String   = ""Error""     const val ctact: String     = ""Act""     const val cttrue: String    = ""true"" // ?",0.35,Kotlin
15qxqf9,jw60eso,"This is also allowed in a lot of the ML family, including Haskell and OCaml",0.0,Haskell
15qxqf9,jw8por4,So ... really doubling down on Perl then?,0.022222222222222213,Perl
15qxqf9,jwfbbf8,"Hm, this is in many ways as beautiful as I would expect from something descended from Perl, and also as godawful ugly as something descended from Perl.",0.2166666666666667,Perl
15qxqf9,jw90l6p,"APL, as I recall, has lots of strange characters, but tokenizing them is easy - just treat each oddball character as a token.",0.19166666666666668,APL
15qxqf9,jw9sxfe,Similar to C#,0.0,C
15qxqf9,jw8calp,Ruby too.,0.0,Ruby
15qxqf9,jw73zvf,"Some C examples:  * `for` is a reserved word, but if the next character is `m`, now you've go the identifier `form`.",0.0,C
15qxqf9,jw73zvf,I suspect the *actual* answer is that early Fortran's had this restriction to work around [Fortran's other absolutely crazy rules around whitespace and keyword lexing](https://stackoverflow.com/a/5793730/9457).,-0.15625,Fortran
15qxqf9,jw67439,Ruby too,0.0,Ruby
15qxqf9,jw5xz3h,Elixir  I also like the !,0.0,Elixir
15qxqf9,jw8m019,Julia can use `!` so I think maybe `?` too.,0.0,Julia
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,Ruby
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,Scheme
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,Clojure
15qxqf9,jw99whs,"The problem is it clashes with the nullability/safe navigation/null coalescing syntax in C# and TypeScript, which is also neat.",0.0,C
15qxqf9,jw99whs,"The problem is it clashes with the nullability/safe navigation/null coalescing syntax in C# and TypeScript, which is also neat.",0.0,TypeScript
15qxqf9,jw946ad,"To bring this into sharp focus, compare and contrast Raku with both Perl and another old PL that *did* double down on what it thought was a good design that turns out not to be:  * **Unicode** Basic string functions in Python 3 *corrupt* Unicode strings.",0.002777777777777768,Perl
15qxqf9,jw946ad,"To bring this into sharp focus, compare and contrast Raku with both Perl and another old PL that *did* double down on what it thought was a good design that turns out not to be:  * **Unicode** Basic string functions in Python 3 *corrupt* Unicode strings.",0.002777777777777768,Python
15qxqf9,jw946ad,"India is one of the largest nations on earth yet the Python code `'झंडा 🇮🇳'[::-1]`, which reverses a string containing the Hindi word for ""flag"" alongside India's flag, turns their flag into Nicaragua's, and the Indian characters into gibberish!",0.0,Python
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,Perl
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,Python
15qxqf9,jw946ad,* **Backward compatibility** Python 3 can't use Python 2 modules.,0.0,Python
15qxqf9,jw946ad,And Python 3 modules.,0.0,Python
15qxqf9,jw946ad,"Plus Perl modules, including XS ones.",0.0,Perl
15qxqf9,jw946ad,"* **Concurrency** Python 3 has finally gotten an accepted PEP to remove its GIL, with a hoped for time frame of about 5 years if it isn't backed out, a first tentative step in the long road to sensible concurrency solutions.",0.06666666666666667,Python
15qxqf9,jw946ad,"Perl's status is similarly behind the times, but also with plans to catch up.",-0.4,Perl
15qxqf9,jw946ad,"You *may* have been talking about Raku's parsing approach, syntax, and extensibility ""doubling down"" on Perl.",-0.15555555555555559,Perl
15qxqf9,jw946ad,Perl's parsing approach was LALR.,0.0,Perl
15qxqf9,jw946ad,Perl's syntax was a mishmash.,0.0,Perl
15qxqf9,jw946ad,Perl's extensibility was ad hoc.,0.0,Perl
15qxqf9,jw9fxz0,"Scheme, Racket and Common Lisp here treat `x'` as that the quote begins shorthand for `quote` of another form.",-0.3,Scheme
15qxqf9,jw9fxz0,"Scheme, Racket and Common Lisp here treat `x'` as that the quote begins shorthand for `quote` of another form.",-0.3,Lisp
15qxqf9,jw99xy2,Perl is doubling down on being terse and powerful and completely unreadable.,0.08148148148148147,Perl
15qxqf9,jw99xy2,"My own language reads a lot like pseudocode, or Python, and my variable and function names are verbose, because that's what suits me.",0.6,Python
15qxqf9,jw99xy2,"For me, that example of Raku is like an example of APL or indeed any time I have to do a regex.",0.0,APL
15qxqf9,jwhtvgv,It works fine in Clojure.,0.4166666666666667,Clojure
15qxqf9,jwcpesw,"> What I mean is for example         déjà-vu»⚛++    > Perl is doubling down on being terse and powerful and completely unreadable  Perl might, but Raku isn't.",-0.01701388888888889,Perl
15qcea4,jw4vwsc,as done in TypeScript).,0.0,TypeScript
15qblhm,jw367vc,"Zig is the most promising alternative-to-C I've ever seen, as they stick to C's philosophy, fix a lot of traps and solve one of it's biggest issue: tooling.",0.35,C
15q5877,jw23e09,Ruby can be used to do all of that too.,0.0,Ruby
15q2ljm,jw0mdp0,While it is about Lisp I think the thoughts expressed concern any language.,0.0,Lisp
15q2ljm,jw0mdp0,"I found it quite inspiring in general, not just particularly about Lisp.",0.2388888888888889,Lisp
15pfiig,jvz1x38,Do C people even know anything about successful language design?,0.75,C
15pfiig,jvz1x38,"C was successful, but that's mostly because of Unix, not on its own merits.",0.6166666666666667,C
15pfiig,jwqqiic,"Even so, he is not flawless, and as I mentioned in a recent comment somewhere, I believe his paper/article *Why Pascal is not my favorit programming language* unfairly hurt Pascal and also Pascal-derived languages quite a lot, this being one of several factors that helped C in out-competing Pascal and conquering the world around the end of the 1980es.",-0.25,Pascal
15pfiig,jwqqiic,"Even so, he is not flawless, and as I mentioned in a recent comment somewhere, I believe his paper/article *Why Pascal is not my favorit programming language* unfairly hurt Pascal and also Pascal-derived languages quite a lot, this being one of several factors that helped C in out-competing Pascal and conquering the world around the end of the 1980es.",-0.25,C
15pfiig,jwqqiic,"(Other things being for example Ron Cain's Small-C, GNU and GCC, and the close bonds between C and Unix, including the BSD distributions.",-0.125,C
15pfiig,jwqqiic,"Ratfor was used in BWK's book *Software Tools*, and the Pascal article was written after rewriting the book for Pascal: *Software Tools In Pascal*.)",0.0,Pascal
15pfiig,jvz5uht,Isn’t the success of Unix partly because of C as well?,0.3,C
15pfiig,jw0tzwj,I think you have to judge the design of C within the context in which it came into being and was originally used.,0.375,C
15pfiig,jw0tzwj,"Many languages designed to solve many of the same problems were invented before and after C, and yet C won the day.",0.3333333333333333,C
15pfiig,jw0tzwj,"It's true that the history of C and Unix are intimately intertwined, but I don't think the success of C is explained completely by the fact that it was used in Unix (and vice versa).",0.23750000000000002,C
15pfiig,jw0y3qo,I'm sure C was successful for it's own merits.,0.6166666666666667,C
15pfiig,jw0y3qo,Back then everything was in assembly and it wasn't hard to mix assembly with C and you can easily imagine what assembly your compiler would produce with the C code,0.04722222222222222,C
15pfiig,jw1mwb3,"/s  ""C people"" most likely know more about computer science than most who would resort to calling them ""C people.""",0.375,C
15pfiig,jvzuk7t,"Sure, and although I like C, my opinion is that unix's success due to C was more because of timing.",0.29375,C
15pfiig,jw0eu97,"The shortcomings of C are obvious to most, you don't need to be an expert.",0.25,C
15pfiig,jw0eu97,"C emerged around 1972, I started developing my own systems language around 1982, and right now the latest version is still going strong.",0.45476190476190476,C
15pfiig,jw0eu97,"I can spend all day telling you all the things that C did badly, sometimes laughably so.",-0.5999999999999999,C
15pfiig,jw0eu97,"But of course, my own private language is not used by anybody, while C runs half the world.",0.14444444444444446,C
15pfiig,jw0eu97,So you can certainlly call C 'successful'.,0.75,C
15pfiig,jvzumz9,"Yes, but it was also way more portable to other hardware platforms because of C so had more opportunity to grow.",0.2916666666666667,C
15ouf0b,,Dart:  `if (string is!,0.0,Dart
15ouf0b,,"empty) return null`  Kotlin:  `if (string !is empty) return null`  Perhaps we can also support negation before the predicate function like so:  `if (string is !empty) return null`   And if the predicate takes additional arguments, the subject must be the first argument, and the syntax would work like so:  `function longerThan(string, length): boolean { ... }`  `if (string is longerThan(5)) return null`   I think it's not a complicated syntax sugar to implement in a language but it helpes readability.",-0.002777777777777768,Kotlin
15ouf0b,jvu038d,But fair warning: The logical conclusion of that pursuit is COBOL.,0.475,COBOL
15ouf0b,jvu038d,"And oh yes, the bank is still running COBOL on mainframes after oh these many moons.",0.5,COBOL
15ouf0b,jvveqay,"For example, the Java `instanceof` syntax (very similar to the above) is horrid, and requires all sorts of extra parenthesis for no good reason.",-0.0875,Java
15ouf0b,jvu96xn,I like the Scheme convention of using a ?,0.0,Scheme
15ouf0b,jvu9u1o,"If you look at Rust syntax where the outer parenthesis is optional, it will look more readable.",0.5,Rust
15ouf0b,jvtxb7f,I was just thinking about Dart and Kotlin cuz I am a mobile dev haha.,0.2,Dart
15ouf0b,jvtxb7f,I was just thinking about Dart and Kotlin cuz I am a mobile dev haha.,0.2,Kotlin
15ouf0b,jvuj5op,"Ruby too `""string"".empty?`.",0.0,Ruby
15ouf0b,jvv3x7q,"I'm aware of Perl and Ruby, and in both you can have an `else` block if you want, although it is discouraged by some as being difficult to read.",-0.125,Perl
15ouf0b,jvv3x7q,"I'm aware of Perl and Ruby, and in both you can have an `else` block if you want, although it is discouraged by some as being difficult to read.",-0.125,Ruby
15ouf0b,jvwbb5u,"Well, back when I began reading about programming, COBOL was still a very common thing - ""ordinary"" programmers would typically use it in banks, businesses big enough to have an EDP-department (no IT back then!",-0.11523809523809524,COBOL
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,COBOL
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,APL
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,Pascal
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,Ada
15ouf0b,jvwbb5u,"In a way it reminds me most of C enums used as bit masks combined with for example integers, to represent flags or states of an object.",0.5,C
15ouf0b,jvwbb5u,"What I like about the COBOL level 88 ""condition names"", is that even though you use something like an enum, you don't need to make an explicit comparison.",0.0,COBOL
15ouf0b,jvxm8nu,"And I think you've pretty much affirmed that ""special syntax for predicates"" is a COBOL idea.",0.26904761904761904,COBOL
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,COBOL
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,Python
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,PHP
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,Go
15ouf0b,jvxm8nu,At least with COBOL it's not unfamiliar web frameworks and magical metaprogramming.,0.1,COBOL
15oi4b4,jvsg5ik,"But apparently you want your language to look like APL since you don't like keywords, so ...",0.05,APL
15oi4b4,jvua1k5,"https://www.postgresql.org/docs/15/functions-geometry.html  Ruby just has methods [1,2,3].include?",0.0,Ruby
15oi4b4,jvyvdbn,Julia does this,0.0,Julia
15oi4b4,jvsiqta,APL.,0.0,APL
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Lisp
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Haskell
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Rust
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,Swift
15o64p8,jvr73jn,You might want to take a look at [Ruby's switch expression](https://www.rubyguides.com/2015/10/ruby-case/) (and the `===` method too).,0.0,Ruby
15o64p8,jvyvjr5,C# has a similar feature.,0.0,C
15o64p8,jvseryg,C# and Rust both have a take on this in each their own way.,0.6,C
15o64p8,jvseryg,C# and Rust both have a take on this in each their own way.,0.6,Rust
15o64p8,jvseryg,Rust is hard-line keyword-first but omits parentheses.,0.0,Rust
15o64p8,jvseryg,C# has the `<expression> switch { <cases> }` structure taken from Scala.,0.0,C
15o64p8,jvseryg,C# has the `<expression> switch { <cases> }` structure taken from Scala.,0.0,Scala
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,Rust
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,Ruby
15o4pr5,,"Here I rewrite a few constructs from a C like language using these 7 controls (exit is used to indicate exiting out of ladder (similar to break), fallthrough is used to indicate exiting out of current block and continuing (similar to continue)):      1.",-0.05,C
15o4pr5,jvpuj9u,"Otherwise you can't access variables in `if` block from `then if` block, which would have been possible in corresponding C style code shown above.",0.0,C
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,Lisp
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,JavaScript
15o4pr5,jvsa4o7,">     if cond1 { >         stmt1; >         if cond2 do >         stmt2; >         stmt3... >     } elif cond3 { >         stmt4... >     }  Another construct for reducing nesting subsumed by this idea is Rust's `let else` (just use a `do` in the last, happy branch of pattern matching).",0.4,Rust
15o4pr5,jvtz1w0,(viz: PHP and the ternary `?`/`:` operator.),0.0,PHP
15o4pr5,jvtz1w0,The *goto fail* bug was basically a clerical error in a hand-rolled version of `if-also` done in C with `goto` and labels.,-0.5,C
15o4pr5,jvreiap,Most families taking after C stop at about this point.,0.5,C
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,C
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,C++
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,Java
15o4pr5,jvreiap,"Contrast this to Rust (or most functional languages) -- the above does make sense, because `if` is an *expression*.",0.25,Rust
15o4pr5,jvreiap,"Additionally, this lets you do things like the following (Rust syntax): ``` let some_var = {     let temp = produce_temp_value();     let another = temp.do_thing();     another + 3 }; ``` Helpful for correct scoping of temporary values without having uninitialized variables.",0.0,Rust
15o4pr5,jvreiap,[The Rust Book](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html#statements-and-expressions) has some more explanation.,0.5,Rust
15o4pr5,jvs2m57,"Rewriting that example using `thif` would be ``` if primary:     prelude thif secondary:     main code elif nextprimary:     next main code ``` I mentioned fallthrough because, if you convert this into C style code, it would be something like ``` if primary:     prelude     if not secondary:         # <fall> or <continue> or <skip> or whatever that makes the control to go back searching for next match in ladder (which is not present in C or any major languages that I know of)     main code elif nextprimary:     next main code ```  Sorry if my explanation is unclear again :|",0.05861111111111113,C
15o4pr5,jvsp3xp,The above version using Python style is the same.,0.0,Python
15o42wx,,where at global scope use can precede declaration) that also uses the template syntax that C++ and many other languages use?,0.125,C++
15o42wx,,I know C++ compilers resolve this issue be maintaining a table of all template declarations and when a template name appears `<` is parsed as an opening bracket for template parameters.,0.0,C++
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,Rust
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,C++
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,C
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,Java
15o42wx,jvzqt1o,"So, in Rust:   - In a _type_ context, angled brackets are just used as is: `Generic<Parameter>`.",0.0,Rust
15o42wx,jvzqt1o,I would recommend -- if you want to stick to angled brackets -- to do it like Rust.,0.0,Rust
15o42wx,jvzqt1o,"Not only because you'll get your order free parsing, but also because Rust users will already be familiar with it.",0.25833333333333336,Rust
15o42wx,jvr7n0s,"In my language transpiled to C++ I handle it in a pre-parse step (I use a peg that doesn't require a separate lexer but I preprocess for indent checking and a few other things):  Roughly, upon encountering balanced `<` and `>,` check if either a `(` `{` or `[` follows the closing `>`.",-0.1416666666666667,C++
15o42wx,jvr7n0s,"Also, `1 < 2 > (0)` is an error unlike in C++ (`1 < 2 > 0` is fine).",0.4166666666666667,C++
15o42wx,jvr7n0s,"On the upside, this parses both     `value = 1 + number_of_bits<number >> 1>::value // fine in c++03, fails c++11`  and  `value = 1 + number_of_bits<(number >> 1)>::value // fine any std`     https://stackoverflow.com/questions/31447039/valid-c03-template-code-wont-compile-in-c11  (I want to de-emphasize the use of < and > in C++ anyway partly by going crazy with CTAD but I still want the < and > syntax mainly for interfacing with 3rd-party code)",-0.01999999999999999,C++
15o42wx,jw157dm,It's a bit frustrating though that this problem is apparently so hard that even the Rust people decided to introduce different syntax to simplify parsing.,-0.23055555555555554,Rust
15o1wxa,jvvjep6,"By the way, if you are interested in garbage collectors, as you seem to be, they are just implementing a new garbage collector for sbcl (a Common Lisp compiler).",0.02878787878787879,Lisp
15o1wxa,jvqg7j5,"As far as I know, there is no non-sweep-time overhead to the Boehm GC, other than the normal overhead of allocating memory (and I think Boehm's `GC_malloc` runs faster than the C stdlib `malloc`).",0.041666666666666664,C
15o1wxa,jvqg7j5,"In fact, you can take a large C program and replace `malloc` with `GC_malloc` (and delete calls to `free`) and it will compile and run with no differences to the generated machine code besides which function is being called (and the lack of `free`s).",0.30714285714285716,C
15o1wxa,jynxm3j,"Look at [SGCL](https://github.com/pebal/sgcl), it's real-time GC for C++ without pauses, locks and tags.",0.0,C++
15o1wxa,jvyd8lz,"Cliff (who wrote the Hotspot JIT compiler for Java) now runs the Coffee Compiler Club ([https://www.youtube.com/@compilers]), is working (with me :-) on building the [Ecstasy](https://github.com/xtclang/xvm) back-end, and in his spare time is designing/building a low level language with global type inference called [AA](https://github.com/cliffclick/aa).",0.16666666666666666,Java
15o1wxa,jvvr44u,"All spilling decisions are made by codegen, the same way as in a plain C backend, without any consideration for relocation.",-0.10714285714285714,C
15o1r70,jvr5o8o,"It's true, I'm not a fan of Perl ...",0.35,Perl
15o1r70,jvuezri,"Now the point of this is that someone can declare for example:      languages          Forth  Forth is just an example, there's no particular use-case.",-0.08333333333333333,Forth
15o1r70,jvuezri,"But anyone who wanted to could, and then the `---` constructor will do the same things but with type `Forth`.",0.0,Forth
15o1r70,jvuezri,"So then can then overload `get` to interact with something that actually knows Forth, and start writing stuff like      x = 2     y = 3     get result from Forth --- x y +     post result to Output() // prints 5  A more realistic use-case is that people may want to talk to non-SQL databases.",0.2222222222222222,Forth
15njznz,jvmeu53,"Liquid Haskell is an example of a tool for adding refinement-type annotations to Haskell code, which you might like to look at for ideas.",0.0,Haskell
15njznz,jvmeu53,Ada also has integer range types like this.,0.0,Ada
15njznz,jvnb8em,"In Ada, these constraints are called subtype predicates :  http://www.ada-auth.org/standards/12rat/html/Rat12-2-5.html",0.0,Ada
15njznz,jvmxlxr,"The below is a syntax I'm working on:  ``` val :: String where str -> str.length in (5 to 10) myString = ""abcdefg""  # constraints are prohibited in type annotations val myOtherString :: String = ""xyzabc"" ```  The first line is a type signature similar to the ones you'll find in Haskell and the like.",0.125,Haskell
15njznz,jvqbvo1,I use it in C# all the time for model validation.,0.0,C
15njznz,jvqsv8e,Side note 2: Saline's refinement type's syntax is inspired from Liquid Haskell (which has been mentioned in another comment) with little tweaks to make it (in my opinion) more logical.,0.1875,Haskell
15njznz,jwlcsfj,"I know people have explored similar ideas for stack languages (I think Christopher Diggins for Cat, Daniel Ehrenberg for Factor, and maybe Anton Ertl for Forth) but I don’t have good references offhand, and I don’t think anyone’s gotten very far with it, but I’d be interested to try using a system like that.",0.27,Forth
15nj1xx,,"As I mentioned in my comment, I sometimes would like to use a function defined by a table as a function argument, but I don't know of any languages that would actually allow this, certainly JavaScript doesn't.",0.10714285714285714,JavaScript
15nj1xx,jvm9cy7,"She had a background in mathematics and apparently no qualms to prefer 'call' over 'apply'  In JavaScript functions can be called directly (of course) and also by their `call()` and `apply()` methods, whose semantics differ slightly.",-0.030555555555555548,JavaScript
15nj1xx,jvmbki3,"[Calling a function seems to be an artefact from Fortran, but I'm not sure.",-0.25,Fortran
15nj1xx,jvok55j,"In languages where functions are or may be lazy, like Haskell or Mathematica, people do call it a “function call” less often, I would say.",-0.20833333333333331,Haskell
15nj1xx,jvpjpk0,"Fortran orignally distinglished between functions (which returned a value and could appear in expressions), which did mimic functions like ""sin(x)"" and could appear in expressions and subroutines (which returned nothing but could change their byref parameters).",0.0,Fortran
15nj1xx,jvop64b,"In functional languages, like Haskell, functions really are functions in the mathematical sense.",0.1,Haskell
15nj1xx,jvop64b,"In fact, in lazy functional languages like Haskell, there is no guarantee that the code will be executed even once; if the result isn’t needed it won’t be invoked and if only parts of the result are needed only those parts of function will be executed.",-0.08333333333333333,Haskell
15nj1xx,jvop64b,"Even traditional procedures (like print) are, thanks to the magic of monads, genuine functions in Haskell.",0.275,Haskell
15nj1xx,jvpog0q,"What I mean is that, in one sense it is probably true, but in that sense it would also be true of procedural languages, as it is definitely possible to implement mathematical functions in them: for example a variable **var** *f*: **array**\[1..*n*, 1..*m*\] of 1..*k* in Pascal can represent *any* mathematical function f(i,j) of two natural variables i <= n, j <= m, to the subset of the natural numbers less than k. (I don't think you were the person who recently insisted in a comments section, that integers in programming languages weren't integers, otherwise this conversation would be rather pointless and futile.)",0.015530303030303026,Pascal
15nj1xx,jvpog0q,"So in this sense, again, Pascal (or procedural languages in general) does not ""truly"" model mathematical functions, but then I have my doubts that Haskell and other functional languages can rightfully claim to do so.",-0.024999999999999994,Pascal
15nj1xx,jvpog0q,"So in this sense, again, Pascal (or procedural languages in general) does not ""truly"" model mathematical functions, but then I have my doubts that Haskell and other functional languages can rightfully claim to do so.",-0.024999999999999994,Haskell
15nj1xx,jvroeoj,"Algol 60 originally used the word **procedure** (Algol 68 cutting it down to **proc**), but when NIklaus Wirth designed Pascal based on his Algol W dialect, he chose to differentiate by using the keyword **function**.",-0.032638888888888884,Pascal
15nj1xx,jvroeoj,"Interestingly, Ada retains the **function** keyword from Pascal, without requiring absence of side effects.",0.24375,Ada
15nj1xx,jvroeoj,"Interestingly, Ada retains the **function** keyword from Pascal, without requiring absence of side effects.",0.24375,Pascal
15nj1xx,jvqagyk,If I write down a Haskell function defining the fibonacci or factorial function(!),-0.07777777777777779,Haskell
15nj1xx,jvzpgvu,Languages like Haskell have laws like  > map f .,0.0,Haskell
15nj1xx,jvrtvt6,"One way to boil down the issue is to ask the question: is it necessary to have a ""real functional programming language, like Haskell"", to do functional programming?",0.014814814814814808,Haskell
15nj1xx,jvv5yf6,Wanna interface with C or some kind of ASM?,0.6,C
15nj1xx,jvzek60,"Then C, being low level and simple, just disallowed nested ""functions"", reducing the problem to global variables and variables in nested blocks that always belong to the same activation.",0.0,C
15nj1xx,jvzek60,"And now we have architectures that can't support the GNU C ""nested functions"" extension, because it uses an implementation technique that creates problems with function pointers.",0.0,C
15nj1xx,jvzek60,"And the ""new old-school"" people, who just adopted the word ""function"" because the language they are using descends from C and has inherited C's term, for something that used to be called subroutine, routine, procedure, or (in Ada for example) sub-program.",0.13636363636363635,C
15nj1xx,jvzek60,"And the ""new old-school"" people, who just adopted the word ""function"" because the language they are using descends from C and has inherited C's term, for something that used to be called subroutine, routine, procedure, or (in Ada for example) sub-program.",0.13636363636363635,Ada
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,Rust
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,Go
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,Python
15n31u1,,I guess there's some backlash against things like Python's `async` / `await` stuff.,0.0,Python
15n31u1,,"](https://en.wikipedia.org/wiki/The_Sneetches_and_Other_Stories) And in fact the *What color...* author seems to agree, highlighting *Go* as a good example.",0.7,Go
15n31u1,jvjz80j,"You can pretty easily model Promises with channels [https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec](https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec)  As far as I know, Erlang has a similar model where everything is sent as messages to specific addresses instead.",0.15666666666666668,Erlang
15n31u1,jw1315g,"I am eliminating it in my language and adopting a structured concurrency approach (see [Notes on structured concurrency, or: Go statement considered harmful](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)).",0.0,Go
15n31u1,jw1315g,"Basically, doing something like Go's green threads, but instead of the `go` keyword as done in Go, I have async scopes.",-0.2,Go
15n31u1,jvkebho,"In many languages (including Go, as you mention), either by language definition or by convention, you never really have to choose between multiple threading runtimes, so there's not really a need for async.",0.07500000000000001,Go
15n31u1,jvm3o28,I'd recommend taking a look at [Lua's Coroutines](http://lua-users.org/wiki/CoroutinesTutorial).,0.0,Lua
15n31u1,jvm3o28,"Lua's solution to this problem is to allow creating a coroutine with `co = coroutine.create(fn)` and then hand off control to the coroutine by calling `coroutine.resume(co, args...)`.",0.0,Lua
15n31u1,jvm3o28,"All of this is accomplished using regular functions, there is no syntactic element for `async` or `go`, there are just ordinary functions (implemented in C), which stash local execution state and hand off control to a different execution state until control returns with a return value.",-0.009999999999999998,C
15n31u1,jvm3o28,"Lua's model uses single-threaded cooperative concurrency, but there are third-party libraries like [LuaThread](https://hserg.github.io/luathread-website/examples.html) that add support for pthreads with a similar level of simplicity in API design and without language extensions.",0.0,Lua
15n31u1,jvo0qpu,"When you invoke a method that exists within a different `service` (equivalent to an Erlang ""process""), the result is a future, and the invocation is asynchronous.",0.0,Erlang
15n31u1,jvm1mmx,"In the case of C# and Kotlin, it's because the built-in thread types are too heavyweight to scale, so async/await allows a large number of ""tasks"" to be multiplexed onto a smaller number of real threads.",0.13809523809523808,C
15n31u1,jvm1mmx,"In the case of C# and Kotlin, it's because the built-in thread types are too heavyweight to scale, so async/await allows a large number of ""tasks"" to be multiplexed onto a smaller number of real threads.",0.13809523809523808,Kotlin
15n31u1,jvm1mmx,"I can't say why Python adopted it, but presumably for similar reasons to JS.",0.0,Python
15n31u1,jvm1mmx,"Languages like Erlang and Go adopted a different model from the start, with comparatively lighter-weight threads (i.e.",0.0,Erlang
15n31u1,jvm1mmx,"Languages like Erlang and Go adopted a different model from the start, with comparatively lighter-weight threads (i.e.",0.0,Go
15n31u1,jvm1mmx,"Java's taking an interesting approach - they're switching the built-in thread concept from something always backed by an OS-level thread to something that *can* be backed by an OS-level thread, but can also be a lightweight thread.",0.5,Java
15n31u1,jvm1mmx,"In the rules of Go, `quux` can certainly call `foo` synchronously.",0.21428571428571427,Go
15n31u1,jvkeohg,"In Kotlin, all functions are synchronous.",0.0,Kotlin
15n31u1,jvl3sgh,"Erlang uses a particular interpretation of the Actor model, which is asynchronous with unbounded mailbox size.",0.16666666666666666,Erlang
15n31u1,jvl3sgh,"This is somewhat but not completely analogous to Go's take on CSP, which is synchronous with bounded channel size.",-0.05,Go
15n31u1,jvl3sgh,"Erlang provides something akin to that with `gen_server:call`, although it also enforces deadlines whereas Go's channels can easily deadlock.",0.43333333333333335,Erlang
15n31u1,jvl3sgh,"Erlang provides something akin to that with `gen_server:call`, although it also enforces deadlines whereas Go's channels can easily deadlock.",0.43333333333333335,Go
15n31u1,jvl3sgh,"However, Erlang can also express asynchronous patterns which aren't possible with Go channels.",0.0,Erlang
15n31u1,jvl3sgh,"However, Erlang can also express asynchronous patterns which aren't possible with Go channels.",0.0,Go
15n31u1,jvl3sgh,Personally I prefer the Erlang model although I do find the unbounded mailbox size something of a footgun.,0.0,Erlang
15n31u1,jvl3sgh,"(Distributed Erlang opts for the latter when network buffers are full, FWIW)",0.175,Erlang
15n31u1,jvlujez,"Think about how it works in JavaScript for example; instead of the old idiom of passing callbacks to perform at some point in the future, we pass the current continuation.",0.03333333333333333,JavaScript
15n31u1,jvlujez,"And because this is JavaScript we're not talking about multiple JavaScript threads, we're really talking about 0 or 1 JavaScript threads.",0.1,JavaScript
15n31u1,jvnwpac,And it seems Go provides a single standard scheduler implementation (despite not having those particular keywords).,0.031746031746031744,Go
15n31u1,jvnwpac,"I don't see the `go` keyword as being *semantically* tied to whichever scheduler Go currently sports; just as a way of saying ""go do this in a separate thread of control"" which up to Rob Pike to solve.",0.0,Go
15n31u1,jvo4cqq,The most annoying thing about Python generators is/was how difficult they are to compose.,-0.26666666666666666,Python
15n31u1,jvp6sor,"> I don't see the `go` keyword as being semantically tied to whichever scheduler Go currently sports; just as a way of saying ""go do this in a separate thread of control"" which up to Rob Pike to solve.",0.0,Go
15n31u1,jvp6sor,"I think your point is that Go's scheduler can be thought of as some global compile-time constant, which could be set to something else.",0.0,Go
15n31u1,jvv96eh,"Virtual threads in Java work like that, for instance.",0.0,Java
15n31u1,jvxbc2x,"> Virtual threads in Java work like that, for instance.",0.0,Java
15mqi66,,"If not, and I doubt it doesn't, is this appliable to C++?",0.0,C++
15mqi66,,"PS: The parser I wrote (for C only) correctly parsed raylib.h and cimgui.h (so the failing case may be rare, but not sure about this)",0.016666666666666663,C
15mqi66,jvl2nwz,"Because it might just look like this:      A B;  I also support out-of-order declarations (not for C), and what I have to do is tentatively assume that with two successive identifiers like `A B`, the first is a type `A` to be subsequently defined.",0.125,C
15mqi66,jvl2nwz,"(Better in my syntax is to write `var A B`, which is also possible, or even `var B:A`, but if parsing existing C, you don't have that option.)",0.25,C
15mqi66,jw7g2na,C grammar is ambiguous without the lexer hack.,0.0,C
15mqi66,jw7g2na,"IOW, order-free parsing of C is not feasible in the general case.",0.05000000000000002,C
15mqi66,jvhyh2c,"It means type specifier, if you search for the C syntax nbf and look at `specifier :=` you understand better.",0.5,C
15mqi66,jvl8hyh,"In C, new type identifiers that can start a declaration by themselves (so don't need `struct` or `enum`) I think are only introduced by `typedef`.",0.06818181818181818,C
15mqi66,jvl8hyh,"But there is an ambiguity: if this new C syntax now allows out-of-order declarations, is the first `A` that visible from the outer scope, or is it intended to be the one defined later?",0.12878787878787878,C
15mqi66,jvlb2mb,"about the `const A typedef B` is parsed correctly as well just because typedef is a type qualifier (or something) and is exactly like writing `const` (look at the c bnfs, which I followed at the 100%, except for the typedef-name, which I recognize using this trick and not the classical lexer hack used by major compilers, which doesn't allow out of order decls)  thanks for the reply, my question also was, if this works correctly with C will it work for C++ as well?",0.128125,C
15mqi66,jvlb2mb,"about the `const A typedef B` is parsed correctly as well just because typedef is a type qualifier (or something) and is exactly like writing `const` (look at the c bnfs, which I followed at the 100%, except for the typedef-name, which I recognize using this trick and not the classical lexer hack used by major compilers, which doesn't allow out of order decls)  thanks for the reply, my question also was, if this works correctly with C will it work for C++ as well?",0.128125,C++
15mqi66,jvlb2mb,"since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C++
15mqi66,jvlb2mb,"since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C
15mqi66,jvlb2mb,however the huge set of syntax feature C++ has more than C scares me,0.45000000000000007,C++
15mqi66,jvlb2mb,however the huge set of syntax feature C++ has more than C scares me,0.45000000000000007,C
15mqi66,jvm0tag,">since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C++
15mqi66,jvm0tag,">since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,C
15mqi66,jvm0tag,"The first large C project I wrote, I used a thin syntax wrapper.",0.021428571428571425,C
15mqi66,jvm0tag,"It wrote out the proper C file `prog.c`, `prog.cl` containing declararations for local functions, and `prog.cx` for exported ones.",0.0,C
15mqi66,jvm0tag,"(As for C++, I doubt you will get far with that.",0.1,C++
15mqi66,jvmcil3,"Sorry, I don't know any C++ at all.",-0.5,C++
15mqi66,jvmcil3,Tweaked versions of both C and C++?,0.0,C
15mqi66,jvmcil3,Tweaked versions of both C and C++?,0.0,C++
15mqi66,jvmcil3,Or a new language that looks like C and/or C++?,0.13636363636363635,C
15mqi66,jvmcil3,Or a new language that looks like C and/or C++?,0.13636363636363635,C++
15mqarm,jvi62k3,You'd be surprised how easy it is to get used to typing these when programming in languages descended from C.,0.26666666666666666,C
15mqarm,jvi4h9f,[REBOL](https://rebol.com/) is derived from Lisp and Logo and uses square brackets for blocks  [Red](https://red-lang.org/) is derived from REBOL and uses square brackets for blocks.,0.0,Lisp
15mqarm,jvi4h9f,"[Tcl](https://en.wikipedia.org/wiki/Tcl) uses square brackets for command substitution, executing commands inside.",0.0,Tcl
15mqarm,jvke74y,"I do very little with curly brackets, currently only for dict lookups: `D{k}`, other uses are up for grabs.",-0.12291666666666667,D
15mqarm,jvke74y,At one point they were used for block comments (following Pascal).,0.0,Pascal
15mqarm,jvhy0o9,"Following this line of thought, isn't indentation-based syntax (like in Python) just as good, as it requires no brackets at all?",0.35,Python
15mqarm,jvkhx64,"Objective-C used square brackets for method invocation and ""people"" hated it.",-0.9,Objective-C
15mqarm,jvkhx64,"Its almost the solely reason why Swift was invented, so no they can write `hello.to(world);` sigh.",0.0,Swift
15mqarm,jvkue4i,Scala 3 got rid of curly braces by introducing alternative syntax based on indentation.,0.0,Scala
15mqarm,jvi41go,"Yep  Tcl also uses square brackets and might be the most popular language with the convention  Also my language dt went for square brackets, but in my case the design decision was more about avoiding collision with what shells will ""preprocess"" with (...) and {...} globbing and expansion semantics -- square brackets also have semantics there too, but are less likely to collide",0.2866666666666667,Tcl
15mqarm,jvjwhci,"On the contrary, Python in particular uses brackets every now and then for grouping multi-line code.",0.16666666666666666,Python
15mqarm,jvmivix,"Haskell also allows both styles, but Haskell has had that from the start, and most people use the off-side rule unless they're doing something like writing a short do-block on one line.",0.25,Haskell
15mqarm,jvmivix,"I feel like ""allowing both styles"" is harmful if people don't just standardize on one style (as has happened in Haskell.)",0.0,Haskell
15mqarm,jvmivix,"Scala simply can't do that because of its history - it started with curly brackets only, and as of Scala 3, the language designer is recommending that everyone should use the off-side rule instead.",0.0,Scala
15mqarm,jvmivix,"The result is that both styles will be common, and Scala basically looks like 2 different languages now.",-0.15,Scala
15mqarm,jvmivix,That's why he thought it was important enough to add it to Scala 3.,0.2,Scala
15mqarm,jvoazlx,Haskell uses parentheses for these.,0.0,Haskell
15mqarm,jvoazlx,"Importantly, `[-1]` is a valid lambda, while Haskell's `(-1)` is just a negative number.",0.05000000000000002,Haskell
15mqarm,jvrc7jr,Wait what Haskell styles are you talking about?,0.0,Haskell
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Swift
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Kotlin
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Scala
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Crystal
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Python
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,Julia
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,C
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Julia
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Swift
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Python
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Scala
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Kotlin
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,Crystal
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,C
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Swift
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Julia
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Crystal
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Python
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Kotlin
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,Scala
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,C
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Swift
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Julia
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Kotlin
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Scala
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,C
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Crystal
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,Python
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Swift
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Julia
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Kotlin
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Scala
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,C
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Crystal
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,Python
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Swift
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Scala
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Kotlin
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Julia
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Crystal
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,Python
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,C
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Scala
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,C
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Kotlin
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Python
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Swift
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,Crystal
15mnp7h,,"Calling it with the parent's param name invokes the parent's implementation, essentially bypassing the ""override"" altogether   - n/a     - Julia, OCaml  ### Optional/default parameters  #### When declaring an optional param, are there restrictions on where it can be in the overall parameter list?",0.0,Julia
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Kotlin
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Scala
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Swift
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Python
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Crystal
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,C
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,Julia
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Kotlin
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Crystal
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Julia
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Scala
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Python
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,Swift
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,C
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Scala
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Crystal
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Swift
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Kotlin
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,C
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Python
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,Julia
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Swift
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Julia
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Python
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Kotlin
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Scala
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,C
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,Crystal
15mnp7h,jvisokl,"Swift and Crystal also have this, but I don't know of any others.",0.0,Swift
15mnp7h,jvisokl,"Swift and Crystal also have this, but I don't know of any others.",0.0,Crystal
15mnp7h,jvlj3c4,"For example, in R, argument resolution is even more complex than this (they even allow partial name matching and ... arguments) and it's really complex and can lead to some unexpected footguns",-0.019999999999999997,R
15m88y4,jvfzrg1,"Generally, the algorithm looks like this:  * Go through every function with a matching name * Check if the provided arguments are legal for that function * If there are zero matches, it's a compiler error (no such function) * If there is exactly one match, then you use that function * If there is more than one match, then you pick ""the most specific"" of that set of matches  For example, [here's how to implement the rules specified by Java](https://github.com/oracle/coherence/blob/212681af0cf9b637e0630250f39e829d5b27e0b6/prj/coherence-core/src/main/java/com/tangosol/dev/compiler/java/InvocationExpression.java#L292).",0.21428571428571427,Go
15m88y4,jvfzrg1,"Generally, the algorithm looks like this:  * Go through every function with a matching name * Check if the provided arguments are legal for that function * If there are zero matches, it's a compiler error (no such function) * If there is exactly one match, then you use that function * If there is more than one match, then you pick ""the most specific"" of that set of matches  For example, [here's how to implement the rules specified by Java](https://github.com/oracle/coherence/blob/212681af0cf9b637e0630250f39e829d5b27e0b6/prj/coherence-core/src/main/java/com/tangosol/dev/compiler/java/InvocationExpression.java#L292).",0.21428571428571427,Java
15m77p7,,For example python has a type Path in pathlib to represent path that takes a string in constructor and implement different operations on Path whereas Go has a lib that is directly manipulating strings.,0.05,Go
15m77p7,jvewpyv,"Python's `Path` overloads the `/` operator so you can write `path1 / path2 / 'foo.jpg'` instead of `pjoin(path1, path2, 'foo.jpg')`, and it'll do the right thing -- unlike `path1 + '/' + path2 + '/foo.jpg'`.",0.2857142857142857,Python
15m77p7,jvesgpt,"Python had a library manipulating string paths forever, the `Path` class is a fairly recent introduction.",0.0,Python
15m77p7,jvfssus,"Even in dynamic languages like Python, you will either have your IDE point out obvious errors, or you'll at least get better runtime errors when you have a type mismatch instead of a wrongly formatted string.",-0.06,Python
15m77p7,jvewieq,"(Go, Zig, Pharo, many Lisps, AWK, C, etc) Then no, do not introduce abstractions for something that can already be expressed.",0.5,Go
15m77p7,jvewieq,"(Go, Zig, Pharo, many Lisps, AWK, C, etc) Then no, do not introduce abstractions for something that can already be expressed.",0.5,C
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,Python
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,Rust
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,Java
15m77p7,jvetq22,"The first case is a ""plain alias"" ( Pascal example ):      type         path = string;  But, this allows to use the new type to be used as a the original.",0.1367694805194805,Pascal
15m77p7,jvetq22,"C and Pascal allows to hide the new type:      type        path = forward class;  Another way is to use it indirectly thru a generic pointer:      type        path = pointer;  And, there are several type constructors ( don't confuse with O.O.",0.04545454545454545,C
15m77p7,jvetq22,"C and Pascal allows to hide the new type:      type        path = forward class;  Another way is to use it indirectly thru a generic pointer:      type        path = pointer;  And, there are several type constructors ( don't confuse with O.O.",0.04545454545454545,Pascal
15m77p7,jvesz99,That’s not how Python works.,0.0,Python
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,Rust
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,Haskell
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,Python
15m77p7,jvf3fsh,"A little twist concerning type definitions: some languages, including C and even some Pascal-derivatives, differentiate between type *aliases* and type *names*.",-0.1875,C
15m77p7,jvgpk89,"**  Free Pascal does this, but it's a little ambiguous.",0.10625000000000001,Pascal
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,Pascal
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,Python
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,C
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,Haskell
15m77p7,jvicg3r,"For the boxing part: Scala and Roc have opaque types, and C# has value types that incur no additional allocation.",0.0,Scala
15m77p7,jvicg3r,"For the boxing part: Scala and Roc have opaque types, and C# has value types that incur no additional allocation.",0.0,C
15m77p7,jvicg3r,"It's like in C++: if you want to reference a value via an interface or base type, you gotta use pointers.",-0.8,C++
15m77p7,jvmc24h,"That's usually the best you can do unless you're using a language that allows arbitrary code execution at compile time, such as by using macros in Common Lisp or proc macros in Rust.",0.07,Lisp
15m77p7,jvmc24h,"That's usually the best you can do unless you're using a language that allows arbitrary code execution at compile time, such as by using macros in Common Lisp or proc macros in Rust.",0.07,Rust
15m77p7,jvkpaes,"JS for very small projects because it's absurdly hackable, and Scala for larger projects as a personal preference.",-0.20625,Scala
15lilq6,,"I actually thank the Bejesus to everyone who [uploaded](https://freecomputerbooks.com/langAssemblyBooks.html) this seminal work because the scheme I was coming up with was basically some Rabin-Karp-like heuristic where I would hash all the 900+ odd mnemonics of x86-64 and then what I would have done is some sort of LL(k) parsing wherein every ident ending at "":"" would define a label, and every three-address-style code would be first lexed using C's regex.h library, and if, for example, ""\\w+\\s+\\%\\w+\\s\\%\\w+"" passed the lexical test, I would hash the leading \\w+ and then use a conditional branch for the opcode (ModR/M and the such and so).",0.020833333333333336,C
15l4y21,,So I have three proposals and I'd like your help picking one:**1) mut params**  Like C#'s ref or Swift's inout.,0.0,C
15l4y21,,So I have three proposals and I'd like your help picking one:**1) mut params**  Like C#'s ref or Swift's inout.,0.0,Swift
15l4y21,jvdyg5x,"I get it; every functional programming guru loves Agda, Haskell, and Emacs, but to have it so reliant on Emacs is absolutely absurd.",-0.5,Haskell
15ktb2o,jvgs6ol,"In general, I do agree that supporting multiple versions of a single dependency is necessary; and I love that Rust supports it.",0.12142857142857144,Rust
15ktb2o,jv7ucp4,"Perl also supports backwards and forwards compatibility through language versions, though in a much more dynamic language.",0.25,Perl
15ktb2o,jv9sgqa,I believe Go modules provide support for multiple major versions of a package to co-exist in an application.,0.03125,Go
15ktb2o,jv8918q,"Raku, Perl 7, and JVM bytecode have ideas like this.",0.0,Perl
15ktb2o,jv8918q,"There are some very adjacent ideas like Python and importing from `__future__`  But I haven't read the paper yet, I'm very interested in it!",0.2020833333333333,Python
15ktb2o,jvaxt57,Perl has long had a version literal form that uses that format.,-0.05,Perl
15ktb2o,jvaxt57,"Did you mean more flexible and less sophisticated than the approach/system in Go, Raku or VL?",0.13020833333333334,Go
15ktb2o,jvbqehi,> There are some very adjacent ideas like Python and importing `from __future__`.,0.1,Python
15ktb2o,jvbqehi,Python's `from __future__` is about *language* versions.,0.0,Python
15ktb2o,jvbqehi,"It's a relatively simple thing, enabling one or more features planned for inclusion in a later (probably next) version of Python.",0.125,Python
15ktb2o,jvbqehi,This is like `from __future__` in Python.,0.0,Python
15ktb2o,jvemszq,I wasn't actually aware Go supported using different minor versions at the same time!,0.05,Go
15ktb2o,jvemszq,">Did you mean more flexible and less sophisticated than the approach/system in Go, Raku or VL?",0.13020833333333334,Go
15ktb2o,jvemszq,In comparison to the approach Go takes.,0.0,Go
15kmsjl,jv935uv,"// Nice     struct Person {         string  Name         string  Email         int     Age     }      // Yuck     type person struct {         name std::string;         email std::string;         age int;     };  Also, the example with C's `int* x, y;` is misleading because the problem with C's syntax is the *grouping* of `int (*x), (y);`, not the fact that `int` comes before `x`.",0.6,C
15kmsjl,jv935uv,"It would definitely have been better if C grouped variable declarations as `(int*) (x), (y);` instead.",0.25,C
15kmsjl,jv809sr,The language used has an example (Go language) is inconsistent or verbose.,0.0,Go
15kmsjl,jv809sr,"If the name is more important and has to come first, the rule should be followed for classes and functions as well, but Go uses the syntax `func bar()` and `type Foo struct{}`.",0.3833333333333333,Go
15kmsjl,jvemuzw,"C doesn't do type grouping though, it does type _qualifiers_",0.0,C
15kmsjl,jvakueo,"You can think of pointer declaration in C as a destructuring declaration `int *t` means `*t` is an `int`, therefore `t` is a pointer.",0.0,C
15kmsjl,jv837sz,"Or you can be Haskell, where exponentiation is `^`, `**`, or `^^`, depending on precisely what types you want!",0.5,Haskell
15kmsjl,jv6m2n7,[Rust RFC with examples](https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html),0.0,Rust
15kmsjl,jv9y0i1,"syntax is very IDE friendly because when you write `name.`,  the IDE can immediately help you to suggest all public members of that object, whereas in C for  example, the IDE cannot easily give you a list of functions that work on a particular data object.",0.23500000000000001,C
15kmsjl,jv9nwm4,"Like in Rust:      Struct { x: a, y: b } = bar(); Struct { x, y } = Struct { x: 5, y: 6 };  Or consider a language where Point has been defined as a 2-tuple:      Point (x,y) = triangle.A    // defining x and y",0.75,Rust
15kmsjl,jv72f1g,"There are languages (like Go) that put the name first and don't use any punctuation to separate the type, but I find declarations easier to read with some kind of separator.",0.425,Go
15kmsjl,jva40hx,"Well, that is a wart of Haskell that can’t express one concept via single operator, right?",0.10714285714285714,Haskell
15kmsjl,jvhduhy,"Meanwhile PHP:      function repeat(string $str, int $n): string  which I guess can be read as in English.",0.0,PHP
15kmsjl,jvc5izy,"There's not a good way to resolve this kind of trade-off within the programming language itself, so Haskell asks the user to make the choice instead.",0.125,Haskell
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Pascal
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Ada
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Haskell
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,Scala
15k8zhf,,So one of the weird yet useful(kind of) features of Clojure is that it allows you to call a map even if it's not a function.,-0.5,Clojure
15k8zhf,,We have this feature in Python as well.,0.0,Python
15k8zhf,,I'm curious: how useful is this in a functional statically typed language like Haskell?,0.09999999999999999,Haskell
15k8zhf,jv4hv5x,"In C++ you can overload `operator()` on a class; objects of such classes are officially called ""callable objects"".",0.0,C++
15k8zhf,jv4ggjg,>We have this feature in Python as well.,0.0,Python
15k8zhf,jv4cs1z,I think you misunderstand Clojure.,0.0,Clojure
15k8zhf,jv89ld3,"Python ```python myDict = {0:""zero"", 1:""one"", 2:""two""} numberToName = myDict.get print(numberToName(1)) # prints 1 ```  but not e.g.",0.0,Python
15k8zhf,jv89ld3,"JavaScript: ```js const myMap = new Map(Object.entries({0:""zero"", 1:""one"", 2:""two""})) const numberToName = myMap.get console.log(numberToName(1)) # TypeError since `this` is not defined  const correctNumberToName = myMap.get.bind(myMap) console.log(correctNumberToName(1)) ```  I would also be very careful to specify the semantic choices here, including: 1.",0.0031818181818181746,JavaScript
15k8zhf,jv48qm1,In Haskell map/fmap is a function that takes a function and another argument as inputs and outputs data with a similar structure.,0.0,Haskell
15k8zhf,jv6z2jx,"Saying the name of a function is enough to call that function (without parameters), and that is also true in LISP, Haskell, and some other languages too.",0.075,Haskell
15k8zhf,jv6z2jx,"(In fact, in LISP, a function is exactly the same as just the first item in a list, so technically you do it all the time in Common LISP)  As stated, I suppose Haskell has the same thing.",0.03333333333333333,Haskell
15k8zhf,jv63nky,"In Clojure, maps are a first-class data type, alongside lists and vectors (another Clojure-specific data type).",0.0,Clojure
15k8zhf,jv4db6n,"In Clojure, the application `(m k)` where `m` is a Map is effectively `lookup k m` in Haskell.",0.6,Clojure
15k8zhf,jv4db6n,"In Clojure, the application `(m k)` where `m` is a Map is effectively `lookup k m` in Haskell.",0.6,Haskell
15k8zhf,jv4db6n,"Interestingly, this coercion does not make sense in Haskell because `(->)` is a concrete type constructor provably not equal to anything starting with `Map`.",0.1625,Haskell
15k8zhf,jv7pafd,I disagree with your description of how things work in Lisp.,0.0,Lisp
15k8zhf,jv7pafd,"It's easy to illustrate the difference in a Lisp-1 language like Scheme (or Clojure):      (define (hello-world)       (display ""hello world"")       (newline))          (define (call-twice f)       (f) (f))          (call-twice hello-world)  This last line mentions a 0-argument function without calling it.",-0.10555555555555556,Scheme
15k8zhf,jv7pafd,"It's easy to illustrate the difference in a Lisp-1 language like Scheme (or Clojure):      (define (hello-world)       (display ""hello world"")       (newline))          (define (call-twice f)       (f) (f))          (call-twice hello-world)  This last line mentions a 0-argument function without calling it.",-0.10555555555555556,Clojure
15k8zhf,jv7pafd,"Inside call-twice, that function is called twice, so the output is:      hello world     hello world  I also wouldn't describe Haskell as calling a function by mentioning it, because nothing is executed; a zero-argument function is the same thing as a constant.",0.0,Haskell
15k8zhf,jv4vyf8,Even if Clojure’s implementation has map as a keyword instead of a function (which I’m not sure is true) then it makes sense to make it mirror the syntax of every other lisp data structure.,-0.00833333333333334,Clojure
15k8zhf,jv5s9zn,The real question would be why is Clojure handling map functions differently?,0.1,Clojure
15k8zhf,jvbiu8h,">I also wouldn't describe Haskell as calling a function by mentioning it, because nothing is executed; a zero-argument function is the same thing as a constant.",0.0,Haskell
15k8zhf,jvbiu8h,"But if we go that route, all Haskell really does is manipulate lists by continually expanding them.",0.2,Haskell
15k8zhf,jvbiu8h,"(Technically a Cons cell)  But in terms of the initial question, ""calling a function"" means something different in Haskell.",0.0,Haskell
15k8zhf,jvbiu8h,"Using the definition of sequence manipulations (which is an oversimplification, in truth), _everything_ in Haskell is a function.",0.0,Haskell
15k79uw,jv4hj8o,"This includes Haskell, and there have been [multiple attempts](https://hackage.haskell.org/packages/#cat:Prelude) to provide an alternative prelude based on knowledge learned since Haskell's standard prelude shipped.",0.0,Haskell
15k79uw,jv4hj8o,"Another example is D, which originally shipped with quite a poor standard library and an alternative, Tango gained popularity.",-0.00833333333333334,D
15k79uw,jv4hj8o,"You should be able to leverage these directly from your language without having to use an FFI to a C intrinsics library, and without expecting the compiler to do auto-vectorization magic.",0.3666666666666667,C
15k79uw,jv4hj8o,"For numerics, I would recommend looking at the numerical tower of Scheme.",0.0,Scheme
15k79uw,jv4hj8o,[Kawa](https://www.gnu.org/software/kawa/Numerical-types.html) Scheme has a good implementation.,0.7,Scheme
15k79uw,jv5x5fj,I wrote about some [specific typeclasses and their issues](https://soc.me/languages/equality-and-identity-part1) in popular languages a while ago (a later chapter talks about Haskell).,0.19999999999999998,Haskell
15k79uw,jv5fs0m,>Kawa Scheme has a good implementation.,0.7,Scheme
15jpmxe,jv1q19f,"The Rust version of CPS conversion is misusing `RefCell`; the equivalent of `'t ref` is `&RefCell<T>`, not `RefCell<T>`.",0.0,Rust
15jpmxe,jv1q19f,"The latter is just a `T`, by value, which means the Rust implementation is passing a `u32` around by value and never actually incrementing it.",0.0,Rust
15jpmxe,jv1q19f,"---  All-in-all, Rust is definitely more verbose - but I think it's a shame to not use the one big correctness-checker that Rust has which is missing from OCaml, which is the borrow checker.",0.09999999999999999,Rust
15jpmxe,jv1gael,"For me personally the biggest issue in Rust has been performance, which might be surprising, because the usual meme is to rewrite things in Rust for speed.",0.15,Rust
15jpmxe,jv1gael,What I've seen in Rust is lacking a lot both in convenience and performance.,0.0,Rust
15jpmxe,jv1mahu,"As it is, it reads like it's going to be a critique of this subreddit, but the actual content is about comparing Rust and OCaml as language implementation platforms",0.0,Rust
15jpmxe,jv1int0,"Most of the times, you do not need to implement the whole thing; e.g., if you generate C code, you just need to represent only the constructions you use, not the whole C language.",0.22499999999999998,C
15jpmxe,jv1spim,"For every additional safety guarantee it may confer you in corner cases (mostly low level imperative code), just using immutable data structures, mostly functional code, and advanced types (like GADTs, which BTW are a correctness checking system that's totally missing in Rust) instead is likely to take you much further towards formal correctness, with much less effort.",0.07619047619047618,Rust
15jpmxe,jvgr89t,Seeing all those allocations in the Rust code made me cringe :x,0.0,Rust
15jpmxe,jv1lnyg,"If you want to write the next C++ that would be a massive undertaking, especially without institutional support.",0.0,C++
15jpmxe,jv1w7bk,"---  I'm not saying those other features aren't great; I really wish Rust had something like GADTs, but we should all try to learn from what each language does best.",0.46875,Rust
15jpmxe,jv2mm34,"In Rust, options are:  - Use Rc.",0.0,Rust
15jpmxe,jv2mm34,"Koka has one of the most heavily optimized pure reference counting implementations, and I would be surprised if Rust Rc was faster than Koka.",0.15357142857142855,Rust
15jpmxe,jv2mm34,"Moreover, Rust arenas are not as fast as heap allocation in OCaml/GHC, or other mature bump-pointer'd languages, because those compilers specifically optimize allocations on the machine code level and Rust doesn't.",0.05833333333333334,Rust
15jpmxe,jv2mm34,- Use a garbage collector in Rust.,0.0,Rust
15jpmxe,jv4rf1z,"> Moreover, Rust arenas are not as fast as heap allocation in OCaml/GHC, or other mature bump-pointer'd languages, because those compilers specifically optimize allocations on the machine code level and Rust doesn't.",0.05833333333333334,Rust
15jpmxe,jv4rf1z,You can implement a bump allocating arena in Rust just fine.,0.4166666666666667,Rust
15jpmxe,jv4rf1z,"The only difference between GHC's bump allocator will be that GHC stores the allocation and limit pointers in registers, in Rust you'll have to load them from a heap address.",0.0,Rust
15jpmxe,jv4rf1z,"I have a compiler project in Rust (in progress, not yet released) where I used to use bump allocating arenas/pools for different kinds of objects.",0.0,Rust
15jnq1p,,"Risor is a new language that compiles to bytecode and runs in a lightweight virtual machine, all written in Go.",0.13636363636363635,Go
15jnq1p,,The syntax feels like a blend of Go and Python.,0.0,Go
15jnq1p,,The syntax feels like a blend of Go and Python.,0.0,Python
15jnq1p,,It interoperates with Go types and leverages the Go standard library functions so Go programmers will feel right at home.,0.14285714285714285,Go
15jnq1p,,"Looking ahead, the more interesting aspects of the project are that Go libraries like the [AWS SDK and others are compiled-in](https://risor.io/examples/aws) to the Risor CLI.",0.5,Go
15jn1gv,,I work in a large Python codebase.,0.21428571428571427,Python
15jn1gv,jv0vprs,"Well, Python does haven an `Optional[T]` type annotation, which is an alias for the union `T | None`.",0.0,Python
15jn1gv,jv0vzn0,"Python has type annotations, and its type system includes 'Any' and 'Optional[T]' (which is 'T | None').",0.0,Python
15jn1gv,jv0y1bi,"custom Singletons to represent the absent of a value) is actually quite common in Python if a parameter should accept `None`, but it's absent should be treated differently again (the stdlib does that in quite a few places).",-0.125,Python
15jn1gv,jv0y1bi,The better solution is to use Python with type hints and static type checkers.,0.5,Python
15jn1gv,jv40kk2,"For example, consider this Python code:      if randomChance():        flag = True          print(flag)  The print() may raise an error because \`flag\` is not guaranteed to be assigned.",0.35,Python
15jn1gv,jv40kk2,"Now unlike Python, statically typed languages usually have block scope, but let's assume we keep Python style scope.",-0.25,Python
15jn1gv,jv40kk2,"We may implement a type system where uncertain variable assignments are automatically of a nullable type:      if randomChance():        flag = True          # at this point, flag is of type `Bool?`, because the assignment is uncertain     # so we are *forced* by the compiler to do this:          if flag is not None:        print(flag)  In a language like C# with block scope, we would be forced to do it like this:      bool flag; // or `var flag = false;`          if (randomChance()) {        flag = true;     }          ...",-0.06000000000000003,C
15jn1gv,jv40kk2,So this is an example how you could keep writing Python style code while still having the safety of forced null checks.,-0.30000000000000004,Python
15jn1gv,jv9e8sw,And Python can only tell you the latter.,0.0,Python
15jn1gv,jv9e8sw,"I also work in a large Python code-base for the day-job, and I can tell you that I've gotten a reputation for sprinkling assertions in lots of places.",0.21428571428571427,Python
15jn1gv,jv9e8sw,I will say that frustration with Python is part of the motivation behind my language.,-0.4,Python
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,Java
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,C
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,Python
15jn1gv,jv4o692,This is how you end up with type systems like C or pre-generics Go.,0.0,C
15jn1gv,jv4o692,This is how you end up with type systems like C or pre-generics Go.,0.0,Go
15jn1gv,jv4o692,"I think it's useful to look at TypeScript in this context, since it tries to provide static types that can actually express typical JavaScript patterns.",0.10666666666666666,TypeScript
15jn1gv,jv4o692,"I think it's useful to look at TypeScript in this context, since it tries to provide static types that can actually express typical JavaScript patterns.",0.10666666666666666,JavaScript
15jn1gv,jv4o692,"This might even be enough for a scripting language (think Perl 4, Bash, …).",0.0,Perl
15jn1gv,jv4o692,"This might even be enough for a scripting language (think Perl 4, Bash, …).",0.0,Bash
15jn1gv,jv4mn8w,"This is similar to how TypeScript works, especially when JSDoc type annotations are used so that no compilation step is necessary before execution.",0.0,TypeScript
15jn1gv,jv3m6a1,"My point is that it's completely trivial in the world of dynamic languages and expected within the realm of normal Python programs, to the point of making the limited system you suggested kind of useless.",0.025510204081632657,Python
15jn1gv,jv3uu88,C# is gradually typed FYI.,0.0,C
15jn1gv,jv4m7il,One of the very nice features of C# `dynamic` is that crossing the dynamic–static boundary is safe.,0.4266666666666667,C
15jn1gv,jv4m7il,"In Python or Typescript the type annotations are just annotations, and have little or no interaction with runtime behaviour.",-0.1875,Python
15jn1gv,jv4m7il,"In contrast, C# would do a checked cast at the point of the assignment, possibly raising an exception.",0.0,C
15jn1gv,jv801vd,> One of the very nice features of C# dynamic is that crossing the dynamic–static boundary is safe.,0.4266666666666667,C
15jn1gv,jv801vd,"> In Python or Typescript ... You can assign an int to a str variable by going through an Any type, and the language allows that.",0.0,Python
15jn1gv,jv801vd,"In contrast, C# would do a checked cast at the point of the assignment, possibly raising an exception.",0.0,C
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,Python
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,TypeScript
15jn1gv,jv801vd,Aiui early C# assumed fairly tight explicit static typing would be the norm for devs who used it.,0.14047619047619048,C
15jn1gv,jv9p69k,"Very good point about Raku – whereas most popular gradually typed PLs had a static type system grafted onto an existing dynamic language, a couple of PLs like Julia and Raku were *designed* with gradual typing in mind, which helps with actually achieving safety.",0.4183333333333333,Julia
15jn1gv,jv9p69k,"I perceive it as a design failure that the TypeScript compiler can transpile without typechecking, but it's understandable due to performance constraints.",-0.22083333333333335,TypeScript
15jn1gv,jv9p69k,Even the Deno runtime with its built-in TS support doesn't typecheck by default…  I think C#'s `dynamic` must also be seen in the context of the .NET Common Language Runtime.,-0.15,C
15jn1gv,jv9p69k,"And once that functionality is implemented in the CLR, it makes sense to expose it in the C# language for interoperability purposes, even though it would be rare to use this feature.",0.3,C
15jjcyv,jv23d02,"There're lot of use cases of indirection, just mention one: *vtable* (see C++ virtual methods).",0.0,C++
15j19pa,juzewfr,Feels like Bram is reinventing some parts of Lisp.,0.0,Lisp
15j19pa,juxufxd,"It encourages ad-hoc build systems and customization and built time injections are recipes for technical debt (see Java’s build system problem, there’s a billion ways to run it with gradlew, maven, etccc)",0.0,Java
15i92a9,juu9eff,(Nim is explicitly inspired by Pascal afaik) It also raises a runtime exception when using incorrect fields.,0.0,Pascal
15i92a9,jutgnlz,"You could still have `obj.field` with sum types   This is how Oils does it with [Zephyr ASDL](https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL) --  sum  types, but no pattern matching (because neither Python or C++ support it, at least the versions we use).",-0.3,Python
15i92a9,jutgnlz,"You could still have `obj.field` with sum types   This is how Oils does it with [Zephyr ASDL](https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL) --  sum  types, but no pattern matching (because neither Python or C++ support it, at least the versions we use).",-0.3,C++
15i92a9,jutgnlz,"The pattern is  1. a switch statement on the runtime tag 1. a static cast to the subtype 1. obj.field access, which you say you wanted   There are some syntactic hacks in Python (because it doesn't have switch, but C++ does!",0.625,Python
15i92a9,jutgnlz,"The pattern is  1. a switch statement on the runtime tag 1. a static cast to the subtype 1. obj.field access, which you say you wanted   There are some syntactic hacks in Python (because it doesn't have switch, but C++ does!",0.625,C++
15i92a9,juv0ers,I think Clojure also embraces that point of view.,0.0,Clojure
15i92a9,juw5nwn,"So:      rec Weapon       var name String       var bonus Int     case MeleeWeapon       var damage Int     case RangedWeapon       var minRange Int       var maxRange Int     end  is, AIUI, roughly equivalent to the following using ordinary structs and unions, using C syntax as most are familiar with that:      typedef long long Int;  // 64-bit int          typedef struct {         Int tag;            // discriminating tag         char* name;         Int bonus;         union {             Int damage;             struct {                 Int minRange;                 Int maxRange;             };         };     } Weapon;  I chose a 64-bit `Int` to avoid alignment and padding issues.",0.06071428571428572,C
15i92a9,juw5nwn,"Then that line might be equivalent to this C:      enum {MeleePeapon, RangedWeapon};   // assumed global; see below          if (weapon.tag == RangeWeapon &&  With accesses to the variant parts such as `x = weapon.damage` further guarded like this:      x = (weapon.tag == MeleeWeapon ?",-0.06999999999999999,C
15i92a9,jv77pzb,"I often get issues with the analogous ""when"" statements in Kotlin, because to check for a type I need to add the ""is"" modifier"".",0.0,Kotlin
15i92a9,juyu9sv,"Some Pascals and Ada have the sort of variant record feature I describe here, but as far as I know, languages that have a thing they call ""sum type"" don't have case-independent fields on it.",0.1,Ada
15i92a9,juzzh44,"In Haskell and ML you can duplicate a member over every case to make it *total*, whilst also having *partial* members.",-0.05,Haskell
15i92a9,juvh0b3,This is the same behavior as Haskell.,0.0,Haskell
15i92a9,juvh0b3,"Record fields in Haskell behave like plain functions, so you can call a partial field on a value which is of a case which does not contain this field - the compiler will not complain because they're the correct *type*.",-0.15714285714285714,Haskell
15i92a9,juwwj3n,And Ada [also has them](https://learn.adacore.com/courses/intro-to-ada/chapters/more_about_records.html#variant-records).,0.0,Ada
15i92a9,juwwj3n,"It is not a ""dead end"" feature, the C descendents are just very good at ignoring useful features for decades.",0.4366666666666667,C
15i92a9,juwwj3n,"But just look outside of the C world, and there are treasures everywhere (yes, ML is not the only source of good things).",0.2333333333333333,C
15i92a9,jutqo5e,"The type relationship is the same  (Multiple inheritance also turns into something Rust doesn't have --  variants as first class types, without wrapping)  Why do you say subtyping adds a lot of complexity?",0.08333333333333333,Rust
15i92a9,juvpkog,A potential fix for this in Haskell is to replace the sum type with a GADT and separate the record fields into their own types.,0.3,Haskell
15hwgbo,,Currently there are working iterators for:   * Array * Tuple * String * Number Range (like in Python)  # Problem  I'm not sure how to handle situations in which new keys are added or removed from the map.,-0.03787878787878788,Python
15hwgbo,,"For now the Litan map uses std::map from the C++ standard library as an underlying container, which has some problems with iterator invalidation.",0.0,C++
15hwgbo,,"(1, A)     [VM-Error] Unhandled exception: Invalidated map iterator  # Options  There are a few other options I thought about:  * Just accept UB from C++ (Not an option) * No map iterators (Not an option) * Just stop iteration and exit loop (Very soft error handling and hard to find error.",-0.12166666666666667,C++
15hwgbo,jurjpb8,"C++ solves this problem via the `erase` function on the map; it doesn't work with range-based for loops like the ones you are implementing here, because it requires updating the iterator directly.",0.1,C++
15hwgbo,jur6vfq,I quite like the way Java's concurrent collections (e.g.,0.0,Java
15hwgbo,jur6vfq,"Another trick from Java's iterators is that you can remove the last returned element through the Iterator interface instead of on the Collection, and this allows you to continue iterating safely.",0.25,Java
15hwgbo,jusjj3h,"If your backing language is C++, then consider `std::unordered_map` (hash map), and think about the behavior:   - Should insertion or removal cause an exception?",0.0,C++
15hwgbo,jusjj3h,"---  On another note, C++ doesn't make the distinction, but it's actually pretty important: there's a difference between an _iterator_ and a _cursor_.",0.325,C++
15hwgbo,jusjj3h,"The Rust library offers _some_ cursors for a few collections [see, for example, `LinkedList`](https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html).",-0.05,Rust
15hwgbo,jushte0,"You're in good hands: Java behaves similarly, and throws a `ConcurrentModificationException` in such a case.",0.2333333333333333,Java
15hwgbo,juymb3h,This is what C++ does with \`erase\` as someone else was pointing out.,0.0,C++
15hwgbo,juqtyhy,C++'s std::map has no way to get n-th pair without starting from the begin again and again which would result in O(n\^2) time complexity for the for loop in case of a map.,0.0,C++
15hwgbo,jutefzx,---  Regarding the Rust cursors.,0.0,Rust
15hwgbo,jutefzx,I'm not really familiar with Rust and will need do some reading about that topic.,-0.1875,Rust
15hwgbo,juqz268,"Of course, this is all under the assumption of single threading…  Btw Java also throws an exception if the collection was modified.",-0.07142857142857142,Java
15hwgbo,juvrrg9,"You can think of a Rust Cursor as a wrapper around a pointer to an element -- quite like C++ forward/bidirectional/random iterators -- really, where each cursor is specialized for the container type it can ""browse"".",0.2,Rust
15hwgbo,juvrrg9,"You can think of a Rust Cursor as a wrapper around a pointer to an element -- quite like C++ forward/bidirectional/random iterators -- really, where each cursor is specialized for the container type it can ""browse"".",0.2,C++
15hi5ro,,"(It simply makes sense to have those in a logic language and-honestly, Prolog sucks.",-0.15,Prolog
15hi5ro,,"For comparison, look at how many fine prints you got to read to even use the Prolog _forall_.",0.45833333333333337,Prolog
15hi5ro,jup7xdz,"You can do this more generally in Python with the `all` and `any` built-in functions in conjunction with generator expressions (to ensure that we don't compute more `odd`s than necessary):      >>> def odd(x): return x % 2 == 1     ...      >>> all(odd(x) for x in range(1, 6))     False     >>> any(odd(x) for x in range(1, 6))     True  There's also an interesting idea in probabilistic programming, where `some` corresponds to rejection sampling.",0.21428571428571427,Python
15hi5ro,juqqd8x,"Prolog:      for(_, []) :- true.",0.35,Prolog
15hi5ro,juuksao,"Like Java's `findAny`, then?",0.0,Java
15hi5ro,juqln1n,"Maybe `for` plays a special role in ***logical languages***, like Prolog.",0.3035714285714286,Prolog
15hi5ro,juqln1n,"Would you ever want to print *""some""* element of a collection and how would you do that in C#?",0.0,C
15hi5ro,juqln1n,In Haskell it's called `find`.,0.0,Haskell
15hi5ro,jut7wjw,"Python) that seemingly has _all_, _filter_ and _for_ in multiple forms (and syntaxes); there is perhaps some design points gained.",0.0,Python
15hi5ro,jutihui,Disclaimer: my language doesn't claim to _supersede_ Prolog.,0.0,Prolog
15hi5ro,jutihui,"However, this is not meant to imply it's _impossible_ to make something similar in Prolog.",-0.3333333333333333,Prolog
15hi5ro,jutihui,Edit: this may be a good opportunity to mention [NU-Prolog](https://prnt.sc/xwdAyuqcYfGj) (from NU-Prolog manual) as an attempt to add _some/all_ as a construct in LP languages in a different way than how Prolog does it.,0.35,Prolog
15hi5ro,juveswd,"In Ruby, for example, all iteration is done via methods taking blocks, and syntactic looping constructs while exist, are almost never used.",0.0,Ruby
15hi5ro,juveswd,"And in Rust, `for x in i {...}` is 90% pure sugar for `i.for_each(|x| {...})`.",0.21428571428571427,Rust
15gz8rb,,I'm considering creating a compiler for a high-level programming language and wonder if Go would be a good fit for writing it.,0.55,Go
15gz8rb,,"I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Haskell
15gz8rb,,"I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Rust
15gz8rb,,"Go wasn't that frequently mentioned, although, from what I know, if the language is compiled rather than interpreted, the choice of a programming language shouldn't matter as long as the compiler's target is native code.",0.025,Go
15gz8rb,,"I know Go is self-hosted and, therefore, written in itself.",0.0,Go
15gz8rb,,My language would have a GC: Would Go already having a GC complicate development?,0.0,Go
15gz8rb,,"If so, would Rust be a good option?",0.7,Rust
15gz8rb,,"In addition, I know Rust, for example, has tools for building languages, such as `inkwell` (LLVM bindings) and `cranelift`.",0.0,Rust
15gz8rb,,"To my knowledge, Go has no such tools.",0.0,Go
15gz8rb,junesc0,"Ive built interpreters in Go before, i didnt realize how unergonomic it was until I built the same interpreter in OCaml which has algebraic data types and pattern matching.",0.0,Go
15gz8rb,jum3hqn,"There's a book _just_ about writing a compiler in Go (also, AFAIK, Go is self-hosted)  https://compilerbook.com/  So, take your conclusions",0.0,Go
15gz8rb,jumd0pb,"I write compilers in Go, it's a decent language for that, but you will miss a stronger type system and sum types.",0.16666666666666666,Go
15gz8rb,jumd0pb,"I program most things from scratch, so i don't miss the lack of interop between say, Go and LLVM.",0.5,Go
15gz8rb,jumd0pb,"Go's GC is rarely a problem for a short lived program like a compiler, unless you plan to compile millions of lines of code, i think GCed languages work wonderfully.",0.43333333333333335,Go
15gz8rb,jumd0pb,"Besides, Go's profiling tool offsets most downsides of using GC, after a while, you program knowing exactly what you shouldn't do and performance stops being a problem.",0.375,Go
15gz8rb,jum4ax2,>I'm considering creating a compiler for a high-level programming language and wonder if Go would be a good fit for writing it.,0.55,Go
15gz8rb,jum4ax2,"If you know Go, then Go will be a good fit for writing a compiler and/or interpreter in.",0.55,Go
15gz8rb,jum4ax2,>My language would have a GC: Would Go already having a GC complicate development?,0.0,Go
15gz8rb,jum4ax2,>would Rust be a good option?,0.7,Rust
15gz8rb,jum4ax2,"If you know Rust, then Rust will be a good fit for writing a compiler and/or interpreter in.",0.55,Rust
15gz8rb,jum4ax2,">I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Haskell
15gz8rb,jum4ax2,">I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,Rust
15gz8rb,jum4ax2,Go wasn't that frequently mentioned  This is true.,0.22499999999999998,Go
15gz8rb,jum4ax2,"But languages are fads, and Rust is the current fad.",0.0,Rust
15gz8rb,jumd0n3,"As someone who’s writing a compiler in Go, I don’t recommend it if you can avoid it.",0.0,Go
15gz8rb,jumtnoa,You might also be interested in [this post from last week](https://www.reddit.com/r/ProgrammingLanguages/comments/15a4z4c/is_go_a_good_target_language/) about using Go as a compilation *target*.,0.125,Go
15gz8rb,juoozn3,I found C# quite pleasant to use.,0.7333333333333333,C
15gz8rb,jume12c,"Go doesn't have them,  so I wouldn't write any compiler in Go.",0.0,Go
15gz8rb,jume12c,Rust on the other hand is extremely well suited to compiler development.,-0.125,Rust
15gz8rb,jume12c,"Since you can also do concurrency in Rust, and it will also be safer, I don't think Go has any advantage over it in a compiler context.",0.0,Rust
15gz8rb,jume12c,"Since you can also do concurrency in Rust, and it will also be safer, I don't think Go has any advantage over it in a compiler context.",0.0,Go
15gz8rb,jumln2j,"I'm curious why you ask about Go specifically, is it because it's a language you like and/or already know?",-0.1,Go
15gz8rb,jumln2j,"> In addition, I know Rust, for example, has tools for building languages, such as inkwell (LLVM bindings) and cranelift.",0.0,Rust
15gz8rb,jumln2j,"To my knowledge, Go has no such tools.",0.0,Go
15gz8rb,jumln2j,"Another possibility, if the main thing is that you **want** to use Go, is that your compiler translates your new language into Go code, and then invokes the Go compiler.",0.1515151515151515,Go
15gz8rb,jumuscu,Learning rust or ml or Haskell would be a project of its own.,0.6,Haskell
15gz8rb,juomyh9,C interop might be difficult if you write it in go.,-0.5,C
15gz8rb,jupnnvt,"Very good, although I would prefer Rust, if I don't want to struggle with C/C++.",0.9099999999999999,Rust
15gz8rb,jupnnvt,"Although there are more good options, but Rust is a delight for everything, when I use it.",0.6,Rust
15gz8rb,jus65e8,"I did write a lisp compiler in C.  So if you are already good at Go, just use it.",0.7,Go
15gz8rb,jv0fhjo,I wrote a C-like language in Go a couple years ago [https://github.com/0x2ac/myc](https://github.com/0x2ac/myc).,0.0,Go
15gz8rb,jv0fhjo,It uses llir to generate the text format and needs a system C compiler.,0.0,C
15gz8rb,jv0fhjo,It wasn't too bad of an experience but there are some Go-like quirks to do that you have to deal with and the compilers/interpreters I've written later in Rust have been a much nicer experience.,-0.1666666666666666,Rust
15gz8rb,juqnoj9,Using `iota` as a replacement for enums didn't help with Go's lack of ADTs?,0.0,Go
15gz8rb,jvclgl6,"Rust has the Plex library too, which can let you define grammar in a macro and basically skip you to code gen",0.0,Rust
15gz8rb,jumjzex,I just think it's relevant to OP's question in the sense that there may not be as many resources for Go in respect to what they're trying to accomplish.,0.45,Go
15gz8rb,jumjzex,"However as you noted, Go itself is self-hosted so the codebase is a resource, but not quite the same as a book.",0.0,Go
15gz8rb,juvsm1t,> Go is self-hosted  For any* language the drive to self-host is high because presumably the author loves the language and wants to only write in it / check how a large project in it feels like.,0.14357142857142857,Go
15gz8rb,jumpcbq,"Fads are a factor but there are strong arguments for OCaml - it has a powerful type system and pattern matching, and Haskell is even better since it has continuations so you don't have to convert the source to CPS to implement certain structures (although you could use coroutines for most cases and Go does offer those).",0.3895238095238095,Haskell
15gz8rb,jumpcbq,"Fads are a factor but there are strong arguments for OCaml - it has a powerful type system and pattern matching, and Haskell is even better since it has continuations so you don't have to convert the source to CPS to implement certain structures (although you could use coroutines for most cases and Go does offer those).",0.3895238095238095,Go
15gz8rb,jumep90,"CPython uses GC, and many other high level features, but the implementation language is C, which has pretty much nothing.",0.197,C
15gz8rb,jummrjx,"Yeah, I saw some people have mentioned that those two things are quite useful for making compilers, and Go doesn't have them.",0.3,Go
15gz8rb,juoogh0,How do you handle algebraic data types for ASTs in Rust?,0.0,Rust
15gz8rb,juoogh0,"I haven't used Rust much, but when I wrote an interpreter in it, I made an enum for the AST nodes, but found it quite annoying to add new fields.",-0.15454545454545457,Rust
15gz8rb,jumnn0k,The main reason I'd like to use Go if it's a good option is that I already mostly know it.,0.45555555555555555,Go
15gz8rb,jumnn0k,"However, some commenters have already pointed out that Go may not be the best language because it doesn't have pattern matching and algebraic data types.",1.0,Go
15gz8rb,jumnn0k,Rust has both.,0.0,Rust
15gz8rb,jumnn0k,"I also like Rust, but I only know the basics, so I'd have to learn it, which isn't much of a problem since I'd like to learn it at some point.",0.1,Rust
15gz8rb,juqq0uv,"Go has `cgo` package, which allows C interop.",0.0,Go
15gz8rb,juqq0uv,"Go has `cgo` package, which allows C interop.",0.0,C
15gz8rb,juqo0pb,"I may be misunderstanding your comment, but I wasn't planning on compiling to Go.",0.0,Go
15gz8rb,jv0tw2a,Did you already know Rust when you first wrote a compiler in it?,0.25,Rust
15gz8rb,jv0tw2a,"If not, did learning Rust get in the way of writing the compiler?",0.0,Rust
15gz8rb,juon1mv,I believe OCaml should be a much more pleasant and flexible host language than Haskell for this use case.,0.6166666666666667,Haskell
15gz8rb,jumkvwe,"> CPython uses GC, and many other high level features  Yeah, features that the devs had to write from scratch, because as you point out, C does not offer much.",0.18375000000000002,C
15gz8rb,jumkvwe,"I think the point being made here was that it would be *easier* to write an interpreter in a language like Go, because you wouldn't have to worry about things like GC -- it just works.",0.0,Go
15gz8rb,juowj0g,"That’s the most natural representation of an AST, and that’s how all Rust based compilers that I know of do it too.",0.3,Rust
15gz8rb,juozck2,">However, some commenters have already pointed out that Go may not be the best language because it doesn't have pattern matching and algebraic data types  Those will be the people who like to use pattern matching and algebraic data types in their compilers.",1.0,Go
15gz8rb,juozck2,"Creating a tree might have been tricky in 1970s Fortran or BASIC, but pretty much any language now can manage it easily.",0.22083333333333333,Fortran
15gz8rb,juon1k1,Try Crystal.,0.0,Crystal
15gz8rb,juqepzm,"Yeah, I agree that Haskell can be tough.",-0.3888888888888889,Haskell
15gz8rb,juo2yb9,Imagine for example writing a Python interpreter in Go.,0.0,Python
15gz8rb,juo2yb9,Imagine for example writing a Python interpreter in Go.,0.0,Go
15gz8rb,juo2yb9,"This Python may have a specially designed set of data structures to represent Python objects, which might accommodate memory management by reference counting, say.",0.35714285714285715,Python
15gz8rb,juo2yb9,"Now Go apparently has its own GC, but how is that going to fit into what's going on in the Python bytecode execution?",0.35000000000000003,Go
15gz8rb,juo2yb9,"Now Go apparently has its own GC, but how is that going to fit into what's going on in the Python bytecode execution?",0.35000000000000003,Python
15gz8rb,juo2yb9,"Maybe Python relies on immutability to simplify data sharing, while Go data structures are immutable (I've no idea if they are).",0.0,Python
15gz8rb,juo2yb9,"Maybe Python relies on immutability to simplify data sharing, while Go data structures are immutable (I've no idea if they are).",0.0,Go
15gz8rb,juqkrck,"Haven't done Rust must lately so I might be confused, but I think it was the fact that I had to modify the patterns to accommodate the new fields in the first place.",-0.0784090909090909,Rust
15gz8rb,juqkrck,In C# I could just do the pattern matching (eg.,0.0,C
15gz8rb,juqkrck,"In Rust I would need to change all the Expr::Binary(_, _ ,_ ,_) and such.",0.0,Rust
15gz8rb,juqkrck,Seems like the Rust compiler has a struct (Expr) that has some common fields and then a field with an instance of an enum.,-0.3,Rust
15gz8rb,junpnl2,"I'm curious: I've seen mostly-functional languages, specifically Haskell and OCaml, recommended for PL implementation.",-0.1,Haskell
15gz8rb,juqmjrd,It was finally added in Go 1.18.,0.0,Go
15gz8rb,juqn2ol,"I want to write a whole new language, including the GC and other such features, but Go already has many of those.",0.14227272727272727,Go
15gz8rb,juqn2ol,"I was concerned Go already having those features would mess with my implementation of them for my language, although from what I understand, since I'm writing a compiler that targets machine code (or LLVM IR, which then compiles to machine code), that shouldn't be a problem.",-0.175,Go
15gz8rb,juqn2ol,"However, I probably won't use Go and will turn to something like Rust based on what the commenters have said.",0.0,Go
15gz8rb,juqn2ol,"However, I probably won't use Go and will turn to something like Rust based on what the commenters have said.",0.0,Rust
15gz8rb,jusm0t6,I like Go generics.,0.0,Go
15gz8rb,juto5r1,I'm not very experienced with Go.,-0.3076923076923077,Go
15gz8rb,juto5r1,"I've really only built one larger web app with it and am working on another, also in Go.",0.0,Go
15gz8rb,juujd74,Going crazy with them a la Java or C# just isn’t done.,-0.6,Java
15gz8rb,juujd74,Going crazy with them a la Java or C# just isn’t done.,-0.6,C
15gh2sl,juk00n2,"For instance Python doc comments are legitimate statements in the language, and you can read them programmatically by accessing `my_function.__doc__` for example.",0.0,Python
15g0v0c,juh8vy3,"Checkout how functions are defined in OCaml or Haskell, there is one way that is  ``` f arg1 arg2 = <exp> ```  which looks just like function application you would write later and it is sugar for  ``` f = \arg1 arg2 -> <exp> ```  I'm showing haskell here, OCaml has some similar stuff",0.0,Haskell
15g0v0c,juhxx9r,"let x = x  In Lua `local function f` desugars to `local f; f=function` instead of `local f = function`, precisely for this reason.",0.1,Lua
15g0v0c,juhe26k,F# uses  ``` let name x y = x + y ```  it is the same as  ``` let name = fun x -> fun y -> x + y ```  you have the same in JavaScript.,0.15,JavaScript
15g0v0c,jujsfjh,For example one could say in Scala :  val inc = (number: Int) => number + 1   But for a total beginner programmer would that above line really be easy to know what's going on?,-0.07916666666666666,Scala
15g0v0c,jujsfjh,"Now how about this one from Elm:   fn add x y = x+y   It's true there's more likely an easier way to do this in Scala but I hope you can see that Scala puts more of an emphasis on conciseness and being approachable to experts, while something like elm's syntax was meant to lower the barrier for entry for beginner/expert programmers alike",0.3375,Elm
15g0v0c,jujsfjh,"Now how about this one from Elm:   fn add x y = x+y   It's true there's more likely an easier way to do this in Scala but I hope you can see that Scala puts more of an emphasis on conciseness and being approachable to experts, while something like elm's syntax was meant to lower the barrier for entry for beginner/expert programmers alike",0.3375,Scala
15g0v0c,jugcsvq,Lisp isn't consistent though.,0.25,Lisp
15g0v0c,jug9te1,But Lisp ugly :(,-0.725,Lisp
15g0v0c,jujzwrv,"That's why I like PHP over C/C++ due ""function"" keyword makes it readable...",-0.125,PHP
15g0v0c,jugvtrj,"Indeed, this is perfectly normal in JavaScript, btw in your example your subnet even need the brackets `const add = (a, b) => a + b`",-0.3,JavaScript
15g0v0c,juggdx8,"Seeing as all that sugar could be (and often is) delivered by in language macro facilities, Lisp kinda has it both ways by design.",0.0,Lisp
15g0v0c,juga6rm,"Beginners will have no trouble classifying Haskell, Rust, OCaml as ugly, just because the syntax is not close to everyday math.",-0.26666666666666666,Haskell
15g0v0c,juga6rm,"Beginners will have no trouble classifying Haskell, Rust, OCaml as ugly, just because the syntax is not close to everyday math.",-0.26666666666666666,Rust
15g0v0c,jugaswn,The only language I know myself which makes closures explicit was C++.,0.0,C++
15g0v0c,jukch3u,"Haskell gets away without using `let` declarations, and having `let` expressions instead.",0.0,Haskell
15g0v0c,juglr7r,"No reference language, I just didn't particularly like how move closures work in Rust.",0.16666666666666666,Rust
15fs9pu,,"(By that I mean I don't have to learn the language itself before learning anything else, like in Haskell).",-0.3125,Haskell
15fs9pu,,EDIT: here's an non-exhaustive list of candidates  - Haskell - OCaml - Agda - [Hackket](https://github.com/lexi-lambda/hackett) - [Klister](https://github.com/gelisam/klister) - [Typer](https://gitlab.com/monnier/typer),0.0,Haskell
15fs9pu,jv74rt4,"See https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html and this phd thesis: [Scalable Metaprogramming in Scala 3](https://infoscience.epfl.ch/record/299370)  This is more or less the state of the art, it improves over MetaOCaml in several ways.",-0.10416666666666666,Scala
15fp4hw,juga1ix,For example: With [Zigler](https://github.com/E-xyza/zigler) you mix high level Elixir code and low-level Zig code seamlessly:,0.13,Elixir
15fp4hw,jvfvxnl,"I know Haskell already does that but if I do not want a purely functional lazily evaluated language, I don't see many alternatives.",0.15476190476190477,Haskell
15fo0dk,juel0xh,"Newlines aren’t special in that regard - you can imagine rewinding to some other herald symbol (eg go to the nearest `(` if you’re a Lisp, and design your string literals around that).",0.11607142857142858,Lisp
15fluxd,,"* Totally protected from memory leaks (unlike Java, Rust etc.)",0.0,Java
15fluxd,,"* Totally protected from memory leaks (unlike Java, Rust etc.)",0.0,Rust
15fluxd,jug27yw,"You have some very bold statements (""no memory leaks unlike Java, Rust"") in your description that make me suspicious.",0.43333333333333335,Java
15fluxd,jug27yw,"You have some very bold statements (""no memory leaks unlike Java, Rust"") in your description that make me suspicious.",0.43333333333333335,Rust
15fluxd,juvf2sm,"Rust actually used to have sigils for smart pointer types, but decided to ditch them for readability and consistency reasons.",0.10714285714285714,Rust
15fluxd,jugrpqo,I started with making a C++ smart pointer library ([https://github.com/karol11/ltm](https://github.com/karol11/ltm)) that introduces the same semantics.,0.10714285714285714,C++
15fluxd,juh2h8i,"Rust, on the other hand, is a systems-level language.",-0.125,Rust
15fluxd,juwnpfn,"In Rust - smart pointers are not built-in, they a the part of runtime library, and they are numerous.",0.10714285714285714,Rust
15fluxd,juwnpfn,"In contrast Argentum smart pointers are limited by UML, built-in, and deeply integrated in the compiler, same as  Rust &-reference or !-macro sigils.",0.03571428571428571,Rust
15fluxd,jv1ftl8,"BTW there are other demos - that show handling of the graph data structures with loops, file IO, text parsing/formatting and FFI-interop with C.",-0.125,C
15fluxd,jumu09v,Maybe it would help me to better understand Argentum's model if you could provide common code in other languages (I'm Java dev) and how they would be written in Argentum.,0.025000000000000005,Java
15fluxd,jund84j,"```Rust // Define classes class Document {    accounts = Array(Account);    transactions = Array(Transaction); } class Account {    id = 0;    name = """";    init(i int, n String) this { id:=i; name:=n }    toString() { ""{}/       {id}-{name}    ""} } class Transaction {    from = &Account;    to = &Account;    // or accounts = WeakArray(Account);    amount=int;    description = """";    ... }  // Create object doc = Document; doc.accounts.add(Account.init(1, ""Cookies"")); doc.accounts.add(Account.init(2, ""Gold"")); doc.transactions.add(Transaction.init(     &doc.accounts[0],     &doc.accounts[1],     200,     ""Sold""));  // Prints: // Transaction // from 1-Cookies // to 2-Gold // amount: 200 // reason: Sold doc.transactions.each((t){    log(""{}/        Transaction        from: {t.from ?",-0.75,Rust
15fluxd,jur4r0t,"In Java application you can delete account, and this account will be still visible to transactions but not presented in the document `accounts` registry.",0.0,Java
15fluxd,jur4r0t,"While in Java this checking is a multiline statement just to evade null pointers,  but if you want to protect your code from accessing the accounts that was removed from registry,  you need additional flags and checks.",0.0,Java
15fluxd,jurljcs,The problem I see is that Argentum's code needs to cover the edge case in each piece of code while in Java I just can remove the transaction and that's it.,0.0,Java
15fgh6b,judv71d,"In fact, in Haskell, every module does directly correspond to a compilation unit.",0.1,Haskell
15fgh6b,juef2z1,"> JavaScript notably lacked modules, and that was so painful they now have [multiple](https://requirejs.org/) [competing](https://github.com/amdjs/amdjs-api/blob/master/AMD.md) [modules](https://en.wikipedia.org/wiki/CommonJS).",-0.09999999999999998,JavaScript
15fgh6b,juef2z1,"It's funny, there's a 4th that you didn't link that's the actual, official module system :) The 2015 edition added the [standard module system](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) (called ""JavaScript modules"" or ""ES Modules"").",0.1875,JavaScript
15fgh6b,juhuaw8,It feels like JavaScript and Python are out of place in the table.,0.0,JavaScript
15fgh6b,juhuaw8,It feels like JavaScript and Python are out of place in the table.,0.0,Python
15fgh6b,judpts0,"BTW Good Article, but forgot to mention ""Modula"", from the Pascal branch of P.L.",0.7,Pascal
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,Pascal
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,Ada
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,Delphi
15fgh6b,juggfji,That is the approach that languages like Zig or Lua take and I absolutely love it (i.e.,0.5,Lua
15fgh6b,juif795,exactly what happened with C++ templates.,0.25,C++
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,C++
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,Haskell
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,Rust
15fgh6b,jud9x3m,"Since modules are objects in Python, is it enough to consider than they can be nested?",0.0,Python
15fgh6b,juowe0b,"I'm surprised to see Haskell listed under nesting, because module system in Haskell is extremely flat.",0.037500000000000006,Haskell
15fgh6b,juhop5h,"In Java, for example, you might need to have a (pre-compiled) dependency available during compilation for interface checking, but that doesn't stop you from arbitrarily composing a classpath from which implementations are loaded at runtime, replacing anything you like down to individual classes.",0.036111111111111115,Java
15fgh6b,juhop5h,Interfaces in Go work like this.,0.0,Go
15fgh6b,juk62fw,It feels like JavaScript and Python are out of place in the table.,0.0,JavaScript
15fgh6b,juk62fw,It feels like JavaScript and Python are out of place in the table.,0.0,Python
15fgh6b,judf088,Python doesn't have the same language level features for working with nested modules.,0.0,Python
15fgh6b,jueaegm,"Last time I tried, it was honestly quite clunky - much more so than doing this in Scala, which naturally unifies OOP and module systems, making the latter just as easy to use as the former.",0.23333333333333336,Scala
15fgh6b,jumdhw1,"- static methods and properties, - static arrays, - static array sizes (as in C), - static types, - static self types, - static dispatch and linking, - static virtual methods and properties, - static variables, - static visibility and storage class, - static classes, - static classes (the other static ones), static local functions and static lambdas, - static statements (the D ones), - static effects (I made that one up), - static initialisation blocks, - static constructors and shared static constructors, - `using static`, - `static import`, - static columns,  and probably more.",0.455,C
15fgh6b,jumdhw1,"- static methods and properties, - static arrays, - static array sizes (as in C), - static types, - static self types, - static dispatch and linking, - static virtual methods and properties, - static variables, - static visibility and storage class, - static classes, - static classes (the other static ones), static local functions and static lambdas, - static statements (the D ones), - static effects (I made that one up), - static initialisation blocks, - static constructors and shared static constructors, - `using static`, - `static import`, - static columns,  and probably more.",0.455,D
15ewmuk,,"Despite Python's GIL, a bit of threading does *subjectively* seem to [speed up turtle-graphics significantly](https://github.com/kjosib/sophie/blob/main/sophie/adapters/turtle_adapter.py).",0.0,Python
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,Ada
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,C
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,C++
15ewevk,juahxai,"A couple years ago I wrote an [Ada binding](https://github.com/csb6/libtcod-ada) to libtcod, a library used for making rougelike games, and it took a lot of manual effort to get the bindings working so I decided to work on a tool to make it easier.",0.0,Ada
15ewevk,jub9ky6,I got a tip about namespaced properties in Datomic and that seems to fit well with how I use modules (with a restriction like Go where the module/file name must be used as a prefix on imported symbols).,0.4,Go
15ewevk,jud44b3,"I am currently working on a gcc backend and binutil target for a custom ISA, which means learning a lot about these highly generic tools and the mess that is programming in C.",-0.05833333333333333,C
15ewevk,jv479rt,"I  * I started over with my previous Python implementation (which had just a lexer) * I wrote a new on-demand lexer, replacing the old one which used lots of horrible regular expressions.",-0.18606060606060607,Python
15ewevk,jv479rt,"* I wrote a parser, which currently creates a custom Python object, but the structure isn't set in stone, yet.",0.0,Python
15ewevk,jvg2b7l,"I'm thinking of starting a project which translates programs written in C, into my own systems language.",0.3,C
15ewevk,jvg2b7l,"But it will be difficult: C is lower level, quirky, and chaotic in what it allows in many places.",0.0,C
15ewevk,jvg2b7l,"I already have a product that can take C source code and turn it into my syntax, but that is purely for visualisation; I can't compile and run it, as too many details have to be changed or need attention.",0.35714285714285715,C
15ewevk,jvg2b7l,"having to cast every intermediate result down from `i64` to `i32`), that it would better to leave the code as C.",0.17222222222222222,C
15ewevk,juapglh,"The metaphor is message-passing similar to Erlang or Pony, but it turns out that pervasive codata poses some extra challenges.",0.0,Erlang
15ewevk,juapglh,"Also, maybe it's time to learn C#, even if only as a compilation target.",0.0,C
15ewevk,juw212y,Currently dissecting Kotlin type system then perhaps C#’s,0.0,Kotlin
15ewevk,juw212y,Currently dissecting Kotlin type system then perhaps C#’s,0.0,C
15ewevk,juvc7xi,I'm working on transpiling my programming language into JavaScript so that it can run in the browser.,0.0,JavaScript
15ewevk,juvc7xi,The problem is that the nature of Nutt is much more dynamic than that of JavaScript.,0.25,JavaScript
15ewevk,jv59jz4,## Typed functional TS/JS  Last month I started working on a new functional programming language for the TypeScript world.,0.06818181818181818,TypeScript
15ewevk,jv59jz4,"Basically, what could TypeScript be if it wasn't strictly a superset of JavaScript, and instead was more like statically typed functional JS?",0.5,TypeScript
15ewevk,jv59jz4,"Basically, what could TypeScript be if it wasn't strictly a superset of JavaScript, and instead was more like statically typed functional JS?",0.5,JavaScript
15ewevk,jv59jz4,"Now I'm on the long and hairy journey of figuring out how the type system will work, particularly with regards to enabling full/native interop with existing TypeScript code.",0.05833333333333333,TypeScript
15ewevk,jv59jz4,"* Type system and syntax is basically the same as TS where possible  Now I'm getting into the weeds, I'm starting to realise I have to go through a huge amount of work to re-implement most of TypeScript's type system for a language that's almost just syntax sugar on top of TS.",0.23333333333333336,TypeScript
15ewevk,jv59jz4,"I remember when I first learning Elm, and you could do something basic like `type UserStatus = Regular | Visitor` ... it took me way too long to understand that `Regular` and `Visitor` _are not references_ - you're making them up!",0.04,Elm
15ewevk,jwhntg9,"Actually I had three projects associated with C that I'm dropping:  * A C subset compiler (that one was also used to convert C APIs into my syntax) * The C visualiser which I'd started to hone into a more workable conversion tool * A backend for my systems language which targetted C source code  Dealing with C, a language I detest, *and* dealing with its diehards, was becoming too much.",0.2875,C
15ewevk,jv8aunn,I think where I'm at right now is \_not\_ trying to reimplement all of TypeScript's advanced type features but instead just maintain interop with all TS by integrating tsc into my compiler.,0.34285714285714286,TypeScript
15enrue,juasupq,"https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E#:\~:text=1980%E5%B9%B4%E4%BB%A3%E3%81%AB%E9%96%8B%E7%99%BA%E3%81%8C%E5%A7%8B%E3%82%81%E3%82%89%E3%82%8C%E3%81%9F%E3%80%8EMind%E3%80%8F%E3%81%AF%E3%80%81%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E8%AA%9E%E9%A0%86%E3%81%A8%E3%81%AE%E9%A1%9E%E4%BC%BC%E3%81%8C%E6%8C%87%E6%91%98%5B5%5D%E3%81%95%E3%82%8C%E3%82%8B%E9%80%86%E3%83%9D%E3%83%BC%E3%83%A9%E3%83%B3%E3%83%89%E8%A8%98%E6%B3%95%E3%81%AEForth%E3%82%92%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%81%97%E3%81%A6%E3%80%81%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AB%E8%BF%91%E3%81%84%E8%A8%98%E8%BF%B0%E3%82%92%E5%8F%AF%E8%83%BD%E3%81%A8%E3%81%97%E3%81%9F%E3%80%82  >1980年代に開発が始められた『Mind』は、日本語の語順との類似が指摘される逆ポーランド記法のForthをベースとして、日本語に近い記述を可能とした。    Translated: >""Mind,"" whose development began in the 1980s, is based on Forth, a reverse Polish notation system that has been noted for its similarity to Japanese word order.",0.25,Forth
15enrue,ju97sli,"Interesting, seems like a German language COBOL kind of thing to me",0.3666666666666667,COBOL
15enrue,ju98d93,"I do not know COBOL, so I cannot answer your question.",0.0,COBOL
15enrue,jugmpwn,"The similarity to COBOL is so great, you really need to research into it.",0.5,COBOL
15enrue,jugmpwn,"And perhaps also understand why, just as COBOL is in reality nothing whatsoever ""like"" English, so your language is not like German, although superficially, it might seem so.",0.0,COBOL
15enrue,jugs0vq,That was more or less the idea of COBOL: that its similarity to English would make it easier to read (and write).,0.11111111111111112,COBOL
15enrue,jugsgse,"Like you said, COBOL tries to be easier to read by being similar to english.",-0.03333333333333333,COBOL
15enrue,junkozj,"Also, COBOL was more successful for its time than is often credited",0.625,COBOL
15enrue,juj5i2a,"Even if you know neither Latin nor Perl, I think you might get something out of reading about Lingua::Romana::Perligata, Damian Conway's Perl module to allow programming in a Latin ""dialect"" of Perl.",0.0,Perl
15ebelq,,"I am working on my own lexer/parser generator (2-in-one, like C's PEG) and I was wondering if I should do PEG and Packrat or EBNF or even ABNF.",0.6,C
15ebelq,junia71,But you see I am making my blog except I am making my own roff-based macro suite to generate the HTML.,0.6,HTML
15dx5jq,ju4klfv,Drawing 10k triangles one at a time in C is also not going to be fast.,0.2,C
15dx5jq,ju5vo3s,"I had a case like this where I couldn't figure out why my code was running several times slower than equivalent C code, and when I profiled it, it turned out to be an issue caused by calling a function to create array slices in an inner loop (something like `for i, x in xs do for y in xs[(i+1)..] do...`).",0.0,C
15dx5jq,ju5c7m1,Python is too slow for rendering real-time 3d graphics as well - would you consider it a failed language?,-0.4,Python
15dx5jq,ju5c7m1,"In fact, speed beyond a certain is almost needless if your language has some way of doing FFI, because then you can just write performance-critical libraries in C or Rust or whatever while keeping the API in your language, like what NumPy does.",-0.14285714285714285,C
15dx5jq,ju5c7m1,"In fact, speed beyond a certain is almost needless if your language has some way of doing FFI, because then you can just write performance-critical libraries in C or Rust or whatever while keeping the API in your language, like what NumPy does.",-0.14285714285714285,Rust
15dx5jq,jv395pw,One important issue might be the C FFI.,0.4,C
15dx5jq,jv395pw,"It seems that calling a C function, which calls into the module's `call_function` will run a lot of string comparisons.",0.0,C
15dx5jq,ju8k3n7,"The issue isn't in the implementation language (C++), it's my language.",0.0,C++
15dx5jq,ju9b6km,Software renderers are slow in C as well when comparing to a GPU,-0.30000000000000004,C
15dx5jq,jufc6th,"In a language like C++, instrumentation also has the downside that you need to mark up your code to collect the profiling information, but if you're building your own language, that isn't a concern as you can simply add it automatically (or build it into your VM if you're using an interpreted/JITed language).",0.3,C++
15dx5jq,jufc6th,"I've been looking at [Tracy](https://github.com/wolfpld/tracy) for my C++ game engine (and potentially my hobby language), but I've also used [microprofile](https://github.com/jonasmr/microprofile) in the past and had a great experience with it.",0.037500000000000006,C++
15dq3dp,ju5mgb2,"Is it like python?, does it have types like C?.",0.0,C
15dp204,ju3gcpi,"It looks a bit ugly but I think the C++ way of saying ""operator+"" (for example) has it's merits, for this reason",-0.7,C++
15dmp16,," Rust, C++?",0.0,Rust
15dmp16,," Rust, C++?",0.0,C++
15dmp16,,Anything but C  Which has the the best library or framework for making languages like llvm,1.0,C
15dmp16,ju3ll4q,Multiple comments have mentioned Rust.,0.0,Rust
15dmp16,ju3ll4q,Rust is a fantastic programming language.,0.4,Rust
15dmp16,ju3ll4q,"Rust sells itself as a language for lower-level/backend/memory-conscious/high-performance problem spaces, none of which are directly relevant to PL implementation.",0.4,Rust
15dmp16,ju3ll4q,"In principle, Rust isn't the right choice, because it doesn't even sell itself as a good choice for this space.",0.4928571428571428,Rust
15dmp16,ju3ll4q,"My experience has been that for all the advantages Rust has in this space, its parent OCaml is the better choice without paying the costs of Rust that aren't relevant to programming language implementation.",0.45,Rust
15dmp16,ju3ll4q,"OCaml has many/all of the capabilities that make Rust pleasant for writing a compiler, and few/none of the irrelevant challenges that make Rust unpleasant for the same.",-0.10416666666666666,Rust
15dmp16,ju3ll4q,"With Rust, at first I fought the borrow checker, but then learned in an almost Stockholm Syndrome-y sort of way to describe my datastructures/algorithms in unnatural ways to avoid these problems.",0.25,Rust
15dmp16,ju3ll4q,With C++ I miss pattern-matching and spend a lot of time typing boilerplate.,-0.1,C++
15dmp16,ju3ll4q,"C# was fairly pleasant to work with, but still lacks certain capabilities and in general is more boilerplate to describe certain algorithms than in a more appropriate language.",0.3264880952380952,C
15dmp16,ju3ll4q,"C, or any particularly-low-level language is a wildly inappropriate choice in general, if your goal is the actual implementation of the target language.",0.05000000000000001,C
15dmp16,ju3ll4q,"Choosing C gives yourself a personal challenge, can be fun, and done well can end up with a notably high-performance compiler, but at the cost of easily 10x implementation effort on a project that often spans years to begin with.",0.30833333333333335,C
15dmp16,ju3ll4q,"D is very pleasant to work with as a ""C-family"" language and for me was by far the best among C/C++/C#, with the advantages that make those languages nice, and few of the disadvantages.",0.49066666666666664,D
15dmp16,ju3ll4q,"It's still missing the single most important feature, sumtypes and pattern matching, but like C++ et al that can (must be) worked around.",0.15714285714285714,C++
15dmp16,ju3ll4q,"If you were to insist on using a C-family language (C/C++/C#/Java/etc), I was strongly recommend reaching for D first.",0.3416666666666667,D
15dmp16,ju3ll4q,"More notes on OCaml:  * OCaml is a production-ready language that produces (relatively) high-performance executables, is battle-tested, and has a reasonably pleasant ecosystem (Rust's is better, C++ barely has one).",0.3566666666666667,Rust
15dmp16,ju3ll4q,"More notes on OCaml:  * OCaml is a production-ready language that produces (relatively) high-performance executables, is battle-tested, and has a reasonably pleasant ecosystem (Rust's is better, C++ barely has one).",0.3566666666666667,C++
15dmp16,ju3ll4q,"* Haskell, Standard ML, and other functional languages share much of the advantages of OCaml, but suffer from a ""purity problem"" that OCaml lacks.",0.025000000000000005,Haskell
15dmp16,ju3ll4q,"C to your will is satisfying in its own right, i.e., PL implementation in this case being an ""excuse"" for exercises/algo implementation in general.",0.27714285714285714,C
15dmp16,ju2ugtm,"If you're making a compiled language then it doesn't matter as much as your choice of target language that you're going to compile to (C, assembly, LVM), it especially doesn't matter if you're planning to make a self-compiling compiler (like golang)",0.1,C
15dmp16,ju2vj0s,"So yeah, C++ or Rust I guess.",0.0,C++
15dmp16,ju2vj0s,"So yeah, C++ or Rust I guess.",0.0,Rust
15dmp16,ju2vj0s,"In terms of portability, JavaScript and C# are good transpiler targets.",0.7,JavaScript
15dmp16,ju2vj0s,"In terms of portability, JavaScript and C# are good transpiler targets.",0.7,C
15dmp16,ju2tker,Haskell or Ocaml.,0.0,Haskell
15dmp16,ju2v27y,"Rust is great, like C but with modern tooling, pattern matching and a much more elegant type system.",0.5,Rust
15dmp16,ju2v27y,"Rust is great, like C but with modern tooling, pattern matching and a much more elegant type system.",0.5,C
15dmp16,ju2sybw,C++ or C for this.,0.0,C++
15dmp16,ju2sybw,C++ or C for this.,0.0,C
15dmp16,ju2sybw,"Seamless C interop  With these goals, I only really have one option: C.   So personally I think it depends on your goals with the language!",0.07500000000000001,C
15dmp16,ju3t3bb,Rust,0.0,Rust
15dmp16,ju3s0c0,">Rust, C++ ?",0.0,Rust
15dmp16,ju3s0c0,">Rust, C++ ?",0.0,C++
15dmp16,ju3s0c0,"But it depends on the proposed language too: if you use ones like OCaml or Haskell, they have facilities to quickly create mini-me versions of themselves.",0.3333333333333333,Haskell
15dmp16,ju3s0c0,"Think however about how any of those tools would handle a language like a custom assembler, or even your hated C language (its preprocessing language is a peach to implement).",-0.9,C
15dmp16,ju302re,"Chez scheme, racket, Common Lisp (back).",-0.15,Lisp
15dmp16,ju302re,Ocaml and Haskell are great too.,0.8,Haskell
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,Rust
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,Haskell
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,Go
15dmp16,ju2q324,C,0.0,C
15dmp16,ju3rgta,that is Functional like Lisp or supports regular expressions or has Regular Expressions libraries like JavaScript.,0.0,Lisp
15dmp16,ju3rgta,that is Functional like Lisp or supports regular expressions or has Regular Expressions libraries like JavaScript.,0.0,JavaScript
15dmp16,ju3rgta,"The second, is to implement a lexer and a parser like C, C++ compilers does.",0.0,C
15dmp16,ju3rgta,"The second, is to implement a lexer and a parser like C, C++ compilers does.",0.0,C++
15dmp16,ju6cgd9,"Then compile a parser to the source language of choice, write some glue code then: (0) interpret the parsed ast, (1) generate code in some high-level lang w/ garbage collection (OCaml, Python, etc.",-0.75,Python
15dmp16,ju31tvy,Rust enums are great to represent an AST.,0.8,Rust
15dmp16,ju31tvy,"I usually do something like this:  ```Rust enum Toplevel {     Struct {         name: String,         fields: Vec<Parameter>,     }     Function {         name: String,         parameters: Vec<Parameter>         body: Vec<Expression>,     } }  struct Parameter {     name: String,     ty: Type, }  enum Expression {     Block(Vec<Expression>),     FunctionCall {         name: String,         parameters: Vec<Expression>,     }     Assignment(String, Box<Expression>), } ```  Rust has frameworks for LLVM, native and some more unique ones, I didn't get anything useful working with any of them.",0.23125,Rust
15dmp16,ju34r5x,"Of those listed, I think Rust is the best.",1.0,Rust
15dmp16,ju34r5x,"It is seemingly more difficult, but really it’s just that memory management is hard and Rust doesn’t let you manage it poorly (by poor I mean with potential access violations).",-0.11488095238095239,Rust
15dmp16,ju34tyk,"If you’re making an interpreter and you care at all about performance, you’ll want to use a performance-oriented language like Rust.",0.0,Rust
15dmp16,ju34tyk,Haskell and OCaml are good choices.,0.7,Haskell
15dmp16,ju34tyk,"Rust can work here, but the overhead of learning Rust’s idiosyncrasies is probably not worth it.",-0.15,Rust
15dmp16,ju9fzbr,C has been a great non-nonsense language for me to write my compiler in.,0.8,C
15dmp16,ju9fzbr,I personally don’t think the added abstractions of even C++ was helpful (which I previous experience writing compiler code in).,-0.08333333333333333,C++
15dmp16,juj9c07,"Common Lisp, using Metaobject Protocol.",-0.3,Lisp
15dmp16,juptgea,"I think having match expressions and algebraic types helps A LOT in creating compilers, so I'd choose Rust if I were implementing a VM or transpiler.",0.0,Rust
15dmp16,juptgea,"However, libraries for using LLVM are a bit limited compared to C and C++.",-0.07142857142857142,C
15dmp16,juptgea,"However, libraries for using LLVM are a bit limited compared to C and C++.",-0.07142857142857142,C++
15dmp16,ju4k11g,"Since you mention C#, I wonder if you've tried F#.",0.0,C
15dmp16,ju6obaj,">Haskell, Standard ML, and other functional languages share much of the advantages of OCaml, but suffer from a ""purity problem"" that OCaml lacks.",0.025000000000000005,Haskell
15dmp16,ju6obaj,"I would like to add that the absence of mathematical jargon definitely makes OCaml more approachable, which alone may be a compelling enough reason to use OCaml over Haskell.",0.13125,Haskell
15dmp16,ju3afsx,>Compile time function execution  Could you explain how C helps compile-time execution?,0.0,C
15dmp16,ju3afsx,(Because this is not a feature of C itself.),0.0,C
15dmp16,ju5nut3,I cant think of anything about ocaml or Haskell that would make mini me languages particularly easy for a compiler - can you please elaborate?,0.4666666666666667,Haskell
15dmp16,ju3j5q4,"Racket, Ocaml or Haskell.",0.0,Haskell
15dmp16,ju3mn6u,"For comparing, I can only comment on languages I've used:  * Go doesn't provide enough PL-implementation-relevant power to make it a serious contender.",-0.1111111111111111,Go
15dmp16,ju3mn6u,"* Rust is a good choice in the context of worse choices (C, etc), but is not a good choice in the context of better choices (most functional languages, etc).",0.19,Rust
15dmp16,ju3mn6u,"* Rust is a good choice in the context of worse choices (C, etc), but is not a good choice in the context of better choices (most functional languages, etc).",0.19,C
15dmp16,ju3mn6u,"* Haskell is a great choice in the context of worse choices (Rust, etc), but is not a good choice in the context of better choices (OCaml).",0.1375,Haskell
15dmp16,ju3mn6u,"* Haskell is a great choice in the context of worse choices (Rust, etc), but is not a good choice in the context of better choices (OCaml).",0.1375,Rust
15dmp16,ju3mn6u,"OCaml is a productivity-first functional language with all of the expressive power you need for PL implementation, none of the irrelevant challenges you'd be faced with RE Rust et al, and overall gets recommended frequently by the people who use it for PL implementation for a reason.",0.1,Rust
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,COBOL
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,C
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,C++
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,Java
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,Pascal
15dmp16,ju5g06y,"Frankly, Ruby and Perl are huge in this field (not that I would choose either), proving that flexibility sometimes trumps good design.",0.55,Ruby
15dmp16,ju5g06y,"Frankly, Ruby and Perl are huge in this field (not that I would choose either), proving that flexibility sometimes trumps good design.",0.55,Perl
15dmp16,ju6nw0w,"Parsing is certainly easiest in Haskell, and if you're making a simple interpreter then that might be a worthwhile factor",0.2380952380952381,Haskell
15dmp16,ju3ejji,"> If you’re making an interpreter and you care at all about performance, you’ll want to use a performance-oriented language like Rust.",0.0,Rust
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Go
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Haskell
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Lisp
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,Java
15dmp16,ju3ejji,or has easy integration with a production-quality GC like the [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) (which has C and C++ bindings).,0.43333333333333335,C
15dmp16,ju3ejji,or has easy integration with a production-quality GC like the [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) (which has C and C++ bindings).,0.43333333333333335,C++
15dmp16,ju3ejji,I don't think Rust's memory management model is very conducive to running as an interpreter for languages with dynamic memory allocation.,0.1,Rust
15dmp16,ju4ow7t,:D,1.0,D
15dmp16,ju3f2yv,It's actually more due to the fact that I want seamless C imports with no FFI.,0.15833333333333333,C
15dmp16,ju3f2yv,I could do this if I transpile down to C with any language.,-0.15555555555555559,C
15dmp16,ju3f2yv,"However since I allow CTFE on native C functions too, it's much easier for my VM to dynamically call dynamic library code with C than a language with an FFI to C.  So I wouldn't say it helps with CTFE but if I want seamless C and CTFE at the same time, my options seem limited to C or C++.",0.04571428571428572,C
15dmp16,ju3f2yv,"However since I allow CTFE on native C functions too, it's much easier for my VM to dynamically call dynamic library code with C than a language with an FFI to C.  So I wouldn't say it helps with CTFE but if I want seamless C and CTFE at the same time, my options seem limited to C or C++.",0.04571428571428572,C++
15dmp16,ju4y86w,What do you think makes OCaml a better choice than Haskell?,0.5,Haskell
15dmp16,ju7w0nx,"If you're already proficient with Haskell, OCaml doesn't have any additional advantage.",0.0,Haskell
15dmp16,ju7w0nx,"Haskell introduces concepts that aren't immediately useful for being time-zero productive, that are also varying degrees of famously difficult to grok.",-0.1,Haskell
15dmp16,ju7w0nx,"I'd rephrase my thought as:  * For someone who is already proficient in Haskell and/or OCaml, they can both be equally good choices.",0.7,Haskell
15dmp16,ju9fge9,"I'm intimately familiar with Haskell but I can certainly imagine Haskell's enforced purity, category theoretic jargon and laziness by default being additional hurdles to those new to the language.",0.2418831168831169,Haskell
15cxb1a,jtzatjr,"Of course, non-deterministic methods might be necessary for some languages such as C++, but I hope to avoid them and only use them as a last resort for disambiguating actual ambiguities and not just inadequate states that can be fixed with deterministic techniques.",0.016666666666666666,C++
15cnhsc,jtx9z61,"With the 3 topics you suggested I would consider looking into things like behavioral types in Rust, such as typestates and session types.",0.0,Rust
15caifs,,"here's the introduction in that repo:  # Introduction Tungstyn is an interpreted scripting language, primarily inspired by LISP, ECMAScript, and Lua.",0.4,Lua
15caifs,ju6knwo,"Reminds me of [Tcl](https://wiki.tcl-lang.org/page/Dodekalogue), what with prefx notation, square brackets and explicit $variables.",0.0,Tcl
15caifs,jtvkhxj,such is C ¯\\\_(ツ)_/¯,0.0,C
15c4q04,jtwi0w9,"At this point, Rust is quite widely deployed and it's unlikely there will be any backward-incompatible changes to the language like there has been in the past.",-0.2833333333333333,Rust
15c4q04,jtwi0w9,So it will not be necessary to update this project with trivial changes to the Rust compiler.,0.0,Rust
15c4q04,jtwi0w9,It can freeze the version of Rust it forked from.,0.0,Rust
15c4q04,jtwi0w9,"But if there's future Rust versions, say Rust V4 or Rust V5, then it will probably still be simpler to track the main Rust compiler to update this project to support future Rust versions, rather than maintaining a completely separate compiler.",0.06666666666666667,Rust
15by6a3,ju41h4j,And why not write it in Pascal?,0.0,Pascal
15by6a3,jucld4i,"Pascal is a bit closer to my Oberon+ language than Go and I consider it much leaner than the huge implementations with complex multi-layer build processes we usually see from Google, and the Go code, in contrast to FP, depends on a garbage collector.",0.012500000000000025,Pascal
15by6a3,jucld4i,"Pascal is a bit closer to my Oberon+ language than Go and I consider it much leaner than the huge implementations with complex multi-layer build processes we usually see from Google, and the Go code, in contrast to FP, depends on a garbage collector.",0.012500000000000025,Go
15by6a3,jucld4i,"I actually had a look at the internals of V8, Dart and Go over the years; re-using a simplified version of V8 would be interesting, but - in contrast to JVM or e.g.",0.25,Dart
15by6a3,jucld4i,"I actually had a look at the internals of V8, Dart and Go over the years; re-using a simplified version of V8 would be interesting, but - in contrast to JVM or e.g.",0.25,Go
15bufdn,jtsrujy,"The SIMULA language was offically published to the IFIP in 1962 (""An Extension of ALGOL to the Description of Discrete Event Networks"") - but Ive not been able to find any copy of this paper (If anyone has a copy, please let me know!)",0.625,ALGOL
15bufdn,ju6x8pe,"UNIVAC 1107 computer's ALGOL compiler (developed at CASE University in Cleveland), and was finished in December 1964.",0.1,ALGOL
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,C++
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,ALGOL
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,Fortran
15b5tr7,jtots69,[COBOL on Wheelchair](https://web.archive.org/web/20160415075723/azac.pl/cobol-on-wheelchair/) is a thing.,0.0,COBOL
15b5tr7,jtots69,So are the [Bash](https://github.com/dzove855/Bash-web-server) [web](https://yoctu.github.io/yosh/) [frameworks](https://github.com/nerdgeneration/www.sh/blob/master/code/www.sh).,0.0,Bash
15b5tr7,jtots69,"And so, C code too?",0.0,C
15b5tr7,jtots69,"Also, PHP.",0.0,PHP
15b1rxq,jtnyt3v,Rust compiles closures by converting them to `struct` with fields of the variables that were captured.,0.0,Rust
15b1rxq,jto8duv,"Rust, C++?",0.0,Rust
15b1rxq,jto8duv,"Rust, C++?",0.0,C++
15b1rxq,jtogiet,Common Lisp?,-0.3,Lisp
15b1rxq,jtoj7qp,A lambda is isomorphic to a virtual method (AKA C++ and even C with certain patterns).,0.21428571428571427,C++
15b1rxq,jtoj7qp,A lambda is isomorphic to a virtual method (AKA C++ and even C with certain patterns).,0.21428571428571427,C
15b1rxq,jtoj7qp,"A lambda type in C could be defined something like this:  ``` struct BasicLambda { int (*func)(int arg1, void* context); void* context; }; ```",0.0,C
15b1rxq,jtogcni,"I think Crystal programming based on LLVM has lambda, they're termed as Proc.",0.0,Crystal
15b1rxq,jtogcni,Edit: [Link to Crystal Proc documentation](https://crystal-lang.org/reference/latest/syntax_and_semantics/literals/proc.html),-0.75,Crystal
15b1rxq,jtqgtir,"GHC Haskell can compile to both llvm and its native codegen, and it has much more lambdas (and closures) than most other languages.",0.2916666666666667,Haskell
15b1rxq,jtqgtir,"Seriously, Haskell is very serious about optimizing lambdas, because they are used a lot in typical programs.",-0.31111111111111106,Haskell
15b1rxq,jtow2pn,"If you’re compiling AOT you could raise the lambda to top level and just have it as a function, I’ve not worked with llvm much but this is how I’ve done it previously and afaik schemes that compile to C also do it this way",0.17777777777777778,C
15b1rxq,jtoxczl,"Llvm is not like Java or .Net CLR, is a low level VM.",0.0,Java
15b1rxq,jtoxczl,Check how C++ and C# implemented lambdas ...,0.0,C++
15b1rxq,jtoxczl,Check how C++ and C# implemented lambdas ...,0.0,C
15b1rxq,jtpubuy,"clang itself supports C lambdas ([""blocks""](https://en.wikipedia.org/wiki/Blocks_(C_language_extension\))) as an extension: https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/CGBlocks.cpp",0.0,C
15b1rxq,jtroems,How does Rust compile functions that can take either a function or a closure as an argument?,0.0,Rust
15b1rxq,jtoizov,"For example, JavaScript named functions (not lambda) are closures.",0.0,JavaScript
15b1rxq,jtt2cof,This `impl Trait` example is roughly syntax sugar for:       fn foo<F: Fn()>(f: F) { ... }  and Rust compiles generic functions via monomorphization.,-0.05,Rust
15b1rxq,jtou4ee,"I don't think Rust closures contain a function pointer; rather, they implement the `Fn`/`FnMut`/`FnOnce` traits which have the associated function `call`.",0.0,Rust
15b1rxq,jtq8las,"JavaScript functions are always closures, irrespective of being named or anonymous.",0.0,JavaScript
15b1rxq,jtq8las,"For example:      function outer(param) {         function inner() {             // closes over ""param""             console.log(param)         }         return inner     }  See also: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures  > In JavaScript, closures are created every time a function is created, at function creation time.",0.0,JavaScript
15b1rxq,jtomu1h,"If you need to expand to plain-old-functions, a common way is to have the object reference become the first argument of the function, so it would become (in C):      void __lambda_f(__closure_f * __c, int x);  The return type would be a function pointer of the type:      void (*__f)(__closure_f *, int);",-0.024999999999999994,C
15b1rxq,jtp4hlh,"If you’re specifically interested in return types - the Rust approach is to use traits (interfaces) for the closure types, which describe what the thing does rather than what the thing is (closures do not have a concrete identifiable type for a few reasons).",0.075,Rust
15b1rxq,jtp4hlh,"When not using `dyn` (so, the normal case) Rust’s compiler does something called “monomorphization” where it replaces trait-based generics with the real function, meaning there’s no runtime vtable or overhead - yay, equivalent performance to writing the thing by hand!",0.2,Rust
15b1rxq,jtp4hlh,"The monomorph topic goes beyond closures, and is discussed here https://rustc-dev-guide.rust-lang.org/backend/monomorph.html  Summary: Rust never lets you give a concrete type to a closure, instead you use a generic that describes what it _does_ rather than what it _is_, and the compiler expands it for you.",0.07500000000000001,Rust
15b1rxq,jtp4hlh,"I’d recommend reading up on how Rust does it even if you aren’t familiar with the language, because it has some of the best documentation out there for this very very complex process.",0.3283333333333333,Rust
15b1rxq,jtoyejk,Closures/anonymous functions in C++ and Rust are implemented by generating a unique type for every closure.,0.375,C++
15b1rxq,jtoyejk,Closures/anonymous functions in C++ and Rust are implemented by generating a unique type for every closure.,0.375,Rust
15b1rxq,jtoyejk,"As you mention, the Fn traits in Rust are used to constrain what the arguments and return types of these unique closure types are.",0.375,Rust
15b1rxq,jtoyejk,In C++ there is no way to write the actual type of a closure in the language.,0.0,C++
15b1rxq,jtoyejk,This is why you see the use of auto frequently when using closures in C++.,0.1,C++
15b1rxq,jtoyejk,The C++ std::function wrapper works a bit differently: it uses heap allocation and type erasure to store the closure.,0.0,C++
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,C++
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,C
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,Rust
15b1rxq,jtomblq,"I think Rust, Zig and Nim are three examples of this being done right.",0.2857142857142857,Rust
15b1rxq,jtooi1g,Is your VM like a VirtualBox VM or a Java RE VM?,0.0,Java
15b1rxq,jtrhdf6,"There are some minor differences between “ordinary” JavaScript functions and arrow functions, the biggest being how `this` is bound.",-0.15,JavaScript
15b1rxq,jtsw26d,"> JavaScript functions are always closures  Unless they do not capture anything from the outer scope, right?",0.2857142857142857,JavaScript
15b1rxq,jtt8n5f,"For JavaScript specifically, it's a dynamically typed language so there's no ahead-of-time process to determine which variables are local vs. free (captured from enclosing scope) so functions are always going to have an associated environment.",0.2,JavaScript
15b1rxq,jtou80x,"I implement them using the C preprocessor, with one or more macros per instruction which emit the assembled bytes into an array.",0.5,C
15b0517,,One of the reason people like Ruby is that it's fairly readable.,0.7,Ruby
15b0517,jtnpl9q,Racket carried forward the Lisp tradition and allows almost any symbol (except braces) to appear almost anywhere within an identifier.,0.0,Lisp
15b0517,jtnpl9q,The other comment mentions using `?` and `!` for optional handling (as is done in Swift).,-0.15625,Swift
15b0517,jtnun9l,The Racket and Clojure tradition of using ?,0.0,Clojure
15b0517,jtnun9l,"Elixir's use of % and of => for example, to do key/values is annoying.",-0.8,Elixir
15b0517,jto7bqb,People coming from Ruby will probably like it.,0.0,Ruby
15b0517,jtolq9b,"Elixir uses this convention, and it makes code delightfully readable.",1.0,Elixir
15b0517,jtorfdo,That way it'd keep the Lisp/Ruby tradition and not clash with C#/JavaScript conventions entirely.,0.0,C
15b0517,jtosohn,Ruby is a lisp derivative.,0.0,Ruby
15b0517,jtosohn,"[Here's a quote from the creator, Matz:](https://web.archive.org/web/20181027195101/blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642)  > Ruby is a language designed in the following steps: > >  * take a simple lisp language (like one prior to CL).",0.125,Ruby
15b0517,jtosohn,>  * add functionality found in Perl (in OO way).,0.0,Perl
15b0517,jtosohn,"> >So, Ruby was a Lisp originally, in theory.",0.375,Ruby
15b0517,jtosohn,"> >So, Ruby was a Lisp originally, in theory.",0.375,Lisp
15b0517,jtosohn,;-)  So it's not hard to see how a lot of lisp ideas (like Symbols as a language construct) and idioms got brought over into Ruby.,0.19791666666666669,Ruby
15b0517,jtq9uoi,"Although I like Scheme, I dislike the use of dedicated predicates for types as opposed to a generic operator for testing types.",0.0,Scheme
15b0517,jtopr3k,Ruby uses & for safe navigation.,0.5,Ruby
15b0517,jtv6okw,Ruby was designed in Japan so the question mark was more natural for them.,0.3,Ruby
15b0517,jtorydh,Ruby does suport ternaries with that syntax and it's not too bad.,-0.6999999999999998,Ruby
15b0517,jtshdbp,"But Scheme also marks mutating functions with a suffix `!`, which suggests an interrobang for predicates which also mutate.",0.0,Scheme
15b0517,jtwfshj,"I looked at it from the perspective of Scheme, which uses the `predicate?` convention and comes with dozens of built-in predicates, but most of them are simple type tests, and IMO, the absence of `is` in Scheme is a drawback.",0.1625,Scheme
15at643,,Prolog in [Charm](https://github.com/tim-hardcastle/Charm) they could do it without any help from me.,0.0,Prolog
15at643,,"Note also that I already have embedded Go, so by using that people can perfectly well define their own extensions to the IO system — e.g.",0.8,Go
15at643,,"if Go has a library for talking to knitting machines, then a power user can whip up a library using embedded Go that implements a command with signature `post (pattern KnittingPattern) to (machine KnittingMachine)`.",0.0,Go
15at643,,But it is essential to the person who wants to embed Prolog in the same sort of way.,0.06666666666666667,Prolog
15at643,,"And as with the IO commands, since you can already embed Go, you can do what you like with this.",0.0,Go
15at643,,"If you *want* to embed Python into Charm, then you are a very sick person, but since Go can call Python you can do that.",-0.9285714285714286,Python
15at643,,"If you *want* to embed Python into Charm, then you are a very sick person, but since Go can call Python you can do that.",-0.9285714285714286,Go
15at643,jtp223m,"There's also [Quasiquotation in Haskell](https://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf), where you might be able to write a quasiquoter to look like:      [sql|         SELECT ID, NAME, SALARY          FROM CUSTOMERS         WHERE SALARY > $threshold$     |]  I believe Raku also supports embedding languages, and parts of the language itself is implemented using its facilities for embedding.",-0.125,Haskell
15at643,jtp223m,"Of these approaches I think the Wyvern's best solves the embedding problem, as whitespace sensitivity resolves ambiguity issues without the need for syntax directed editing (eg, [Language Boxes](https://soft-dev.org/pubs/pdf/diekmann_tratt__parsing_composed_grammars_with_language_boxes.pdf)), or special, per-language delimiters, whereas Nemerle and Haskell can still have ambiguity issues in the embeddings, and I'm not familiar enough with Raku to determine whether or not it can resolve all ambiguity issues.",0.2924107142857143,Haskell
15at643,jtpda2i,"You need to define a new DSL for every language pair, and it does not address the potential for nested embeddings (Eg, Prolog in SQL in Charm).",0.06818181818181818,Prolog
15at643,jttmuzh,"Most of the time it's the C ABI, so there *is*, kind of, a standard way to interact between languages - via C.  But aside from that, if you have a base language, you can implement any embedded language in its types, or interpret it in the base language.",-0.1,C
15aie5u,jtmavec,It looks like this       # Source location for errors     loc =        Missing  # equivalent of runtime.NO_SPID     | Token %Token       # Very common case: argv arrays need original location     | ArgWord %CompoundWord     | WordPart(word_part p)   https://www.oilshell.org/release/0.17.0/source-code.wwz/frontend/syntax.asdl   And then it translates to both typed Python and typed C++.,-0.0716666666666667,Python
15aie5u,jtmavec,It looks like this       # Source location for errors     loc =        Missing  # equivalent of runtime.NO_SPID     | Token %Token       # Very common case: argv arrays need original location     | ArgWord %CompoundWord     | WordPart(word_part p)   https://www.oilshell.org/release/0.17.0/source-code.wwz/frontend/syntax.asdl   And then it translates to both typed Python and typed C++.,-0.0716666666666667,C++
15aie5u,jtmavec,"So the nice thing is that the C++ lets you see the memory layout directly, and it has evolved over the years.",0.35,C++
15aie5u,jtmavec,I believe people hit this problem over and over again and Rust -- variants aren't types by themselves.,0.0,Rust
15af770,,What are your thoughts on using Zig's C compiler as a backend?,0.0,C
15af770,,Let the codegen just spit plain C and let zig c take cover.,-0.21428571428571427,C
15af770,jtllxnb,And there are some platforms that only have ANSI C compilers.,0.0,C
15af770,jtllxnb,You could target those if you make your C output conservative enough!,0.0,C
15af770,jtki01y,C is a great target used by lots of languages!,1.0,C
15af770,jtki01y,And rather than limiting yourself to Zig you can use whichever C compiler is most suitable for the task as hand.,0.525,C
15af770,jtkjk9k,Is there some reason to use Zig's C compiler specifically?,0.0,C
15af770,jtkjk9k,"You're targeting C, you can use any C compiler",0.0,C
15af770,jtl0aho,"If you plan to use zig compiler as backend, I would advise to target pure Zig instead of C compiled by zig.",0.21428571428571427,C
15af770,jts973w,"I switched to using Zig CC for all my new and main C projects, including libsodium.",0.1515151515151515,C
15af770,jts973w,The fact that the C library gets optimized with the same options as the rest of the app is also a good way to get either smaller or faster code than with a generic package of the C library.,0.175,C
15af770,jts973w,I also use `cargo-zigbuild` to build packages for Rust projects.,0.0,Rust
15af770,ju6c07m,:( I had planned adding support for gcc/clang/msvc etc as well (did not get to do it yet)      (generated code should still compile with other C compilers),-0.4375,C
15af770,jtnbo64,"If you're going to target C, then what you do have is a big choice of compilers.",0.0,C
15af770,jtkozgt,"Another major plus is that you can use zig itself, which is for many cases better than straight C (C for FFI only IMHO).",0.2525,C
15af770,jtmgxmo,"Also, dropping LLVM doesn't mean Zig can't compile C. C can be easily transpiled to Zig so I don't see the issue here.",0.060416666666666674,C
15af770,jtkxsx9,There are lots of languages that can compile to C or C++!,0.0,C
15af770,jtkxsx9,There are lots of languages that can compile to C or C++!,0.0,C++
15af770,jtkxsx9,Haskell and Erlang used to be able to too.,0.5,Haskell
15af770,jtkxsx9,Haskell and Erlang used to be able to too.,0.5,Erlang
15af770,jtn4gi6,I was pointing out that you can take advantages of the strengths of other C compilers too.,-0.125,C
15af770,jtlr715,Allso a subset of F* compiles to C.,0.0,C
15af770,jtn5jqa,The C compilers all implement the same API so languages that compile to C can make use of the $CC environment variable to permit the programmer to select the compiler of their choice.,0.0,C
15af770,jtnj95f,"I assure you, I fully understand the advantages of Zig's C compiler.",0.0,C
15af770,jtnj95f,It is [one of its advertised strengths](https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html) that it implements the standard C compiler API and so can be swapped in-and-out with other C compilers without any additional work.,-0.0625,C
15af770,jtnj95f,"This means that you can, for free, take advantage of the best of all the C compilers and use whichever is best for the problem at hand.",0.7999999999999999,C
15af770,jtnj95f,Zig is not a universally superior C compiler.,-0.35,C
15af770,jtnj95f,There are many C compilers and they can excel in many different ways.,0.3333333333333333,C
15af770,jtnj95f,Targeting standard C rather than a non-standard Zig subset has many advantages and no disadvantage.,0.25,C
15a9pzh,jtjflkm,"In Lua this would look like this:  ```lua local function loop()     if condition then         return -- ""break""     end     return loop() -- fallthrough tail call end ```  The obvious alternative to a `break` is a `goto` (which can also be achieved using an early `return` inside a function), but that isn't any cleaner.",0.03333333333333333,Lua
15a9pzh,jtmwaaf,"The example by /u/till-one in [Effekt](https://effekt-lang.org/):      effect Break[A](): A      def forRange(lower: Int, upper: Int) { body: Int => Unit / Break } = {       def loop(i: Int): Unit / Break = {         if(i <= upper) {           body(i);           loop(i + 1)         }       };       try {         loop(lower)       } with Break[A] { () }     }      def f(a: Boolean, b: Boolean) = {       forRange(1, 5) { i =>         if(a) { do Break() };         println(""A"")         forRange(1, 6) { j =>           if(b) { do Break() };           println(""B"")         }       };       forRange(1, 7) { i =>         if(i == 5 && a) { do Break() };         println(""C"")       }     }      def main() = {       f(true, true)     }  Breaking out of a loop, just like early return, is non-local control flow and therefore effectful.",0.12333333333333332,C
15a9pzh,jtl1k6r,"Ada has `exit when`, which combines the typical if-break into a single statement.",-0.11904761904761904,Ada
15a9pzh,jtk3osn,Here is a mainstream language: JavaScript.,0.0,JavaScript
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,Haskell
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,Python
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,C
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,Kotlin
15a9pzh,ju7f1mq,Continuations in Scheme can be used to create all sorts of control-flow operators including `break`.,0.0,Scheme
15a9pzh,ju7f1mq,"I recently wrote Racket versions of Common Lisp `block`, `return` and `return-from` using them, for example, to make imperative style loops easier to work with.",-0.15,Lisp
15a9pzh,jua250z,"The canonical primary source on this line of thinking is [Structured Programming with Go To statements, by Donald Knuth](https://pic.plover.com/knuth-GOTO.pdf).",0.4,Go
15a9pzh,jtqa8za,"In C implementation of breaks you could do setjmp/longjmp, regardless of what the statement is.",0.0,C
15a9pzh,jtllkju,"In this case, the use of `goto` (which Lua has recently acquired - a good move as most languages are doing away with it), can trivially take the place of `break`, without turning all of my code upside down.",0.26111111111111107,Lua
15a9pzh,jtnow7j,Same with Scala.,0.0,Scala
15a9pzh,jtk256z,"In nested loops I even want a more powerful break/continue (in PHP you can do `break 2` to break out of 2 loops for example, other languages provide labels).",0.225,PHP
15a9pzh,jtkrmq7,"In Lua, this would look like this:  ```lua (function()     while loopcond do         if breakcond then return end         ...     end end)() ```  which of course in general isn't particularly beautiful (though something similar is sometimes used to emulate `continue` in Lua 5.1 which doesn't have `goto`, but that's more of a hack).",0.35,Lua
15a9pzh,jtm2odi,"Eh, it's rather clunky in Lua, but in more FP-centric languages (Ocaml, Haskell etc) 3 local tail-recursive functions is probably how you'd do it.",0.25,Lua
15a9pzh,jtm2odi,"Eh, it's rather clunky in Lua, but in more FP-centric languages (Ocaml, Haskell etc) 3 local tail-recursive functions is probably how you'd do it.",0.25,Haskell
15a9pzh,jtn3dyo,"That said, when you're writing idiomatic, imperative Lua, of course use `break`.",0.0,Lua
15a9pzh,jtvusfw,I took the fannkuch example and wrote it in very basic Scheme: [here](https://www.jdoodle.com/ia/Ku8).,-0.375,Scheme
15a9pzh,jtvusfw,I translated from a [C version](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-3.html) I found because I find C more familiar than Lua and it was already organized in a way that didn't require `break`.,0.4375,C
15a9pzh,jtvusfw,I translated from a [C version](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-3.html) I found because I find C more familiar than Lua and it was already organized in a way that didn't require `break`.,0.4375,Lua
15a9pzh,jtn6tuy,"Here's a [real example](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-lua-1.html) in Lua, which has `break` in two separate loops, both of them nested inside an enclosing loop.",0.2,Lua
15a9pzh,jtxu3zh,That Scheme looks surprisingly good when laid out like that.,0.7,Scheme
15a9pzh,jtxu3zh,"But then, so does the original C!",0.46875,C
15a9pzh,jtxu3zh,"While C does have `for`\-loops, sort of, they're still a lot of work, and the first two examples in your link are also non-idiomatic: I had trouble recognising what they did.",0.024999999999999994,C
15a9pzh,jtxu3zh,(BTW the non-`break` C version ran 10-50% slower than the `break` version - just saying.),0.0,C
15a9pzh,jty3tkn,Scheme - especially when you use such a minimal canonical subset like I did - is a language that doesn't place concision at an especially high priority.,0.055,Scheme
15a9pzh,jty3tkn,Scheme code written by Scheme experts to get work done - rather than Scheme code written by a C programmer for demonstration - tends to be more concise because people build tools within the language to help keep the code shorter.,0.3,Scheme
15a9pzh,jty3tkn,Scheme code written by Scheme experts to get work done - rather than Scheme code written by a C programmer for demonstration - tends to be more concise because people build tools within the language to help keep the code shorter.,0.3,C
15a9pzh,jty3tkn,I wouldn't have written the C code that way and I refactored it a bit in C before I tried translating to Scheme.,0.0,C
15a9pzh,jty3tkn,I wouldn't have written the C code that way and I refactored it a bit in C before I tried translating to Scheme.,0.0,Scheme
15a9pzh,jty3tkn,Are you saying that Scheme doesn't have loops as a feature?,0.0,Scheme
15a9pzh,jty3tkn,"In a language like Scheme - setting aside continuations, which I intentionally left out of my language - you can get a better idea about control flow just by looking at the shape of the code and the initial keywords.",0.16666666666666666,Scheme
15a9pzh,jty3tkn,"If I find some time, I might go through the exercise of starting from the Lua code to see how that goes.",0.0,Lua
15a9pzh,jtzitc0,I took some time to look at the Lua code a bit and I realized that eliminating the `break` statements in that code is really trivial to do.,0.2,Lua
15a9pzh,jtzitc0,"while (A) {         if (B) {             C;             break;         }         D;     }      ; Added X and Y for the loop state variables and updates, which are implicit above.",0.0,C
15a9pzh,jtzitc0,"while (A) {         if (B) {             C;             break;         }         D;     }      ; Added X and Y for the loop state variables and updates, which are implicit above.",0.0,D
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,C
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,D
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,Scheme
15a4z4c,,"Go has GC, so prototyping language can do whatever they want without caring about memleak 2.",0.0,Go
15a4z4c,jtj7w87,"Funny you mention that, I started targeting Go last week, and was surprised I couldn't find anyone else doing it.",0.11666666666666665,Go
15a4z4c,jtj7w87,Rust is definitely more meticulous about these things.,0.5,Rust
15a4z4c,jtizkys,"It's probably a decent idea, I mean the points that you listed in favour of Go make sense and seem valid.",-0.07291666666666667,Go
15a4z4c,jtizkys,"If so you probably have to mess with CGo, and as the gophers say: [""CGo is not Go""](https://dave.cheney.net/2016/01/18/cgo-is-not-go) 2.",-0.4625,Go
15a4z4c,jtizkys,Does the Go runtime support everything you need and/or are you willing to build that (ex.,0.25,Go
15a4z4c,jtizkys,"Obviously if you are building a new language rather than just using Go, there must be something it doesn't have that you want.",0.06818181818181818,Go
15a4z4c,jtizkys,The Go compiler is oddly strict about some things but not others.,-0.16666666666666666,Go
15a4z4c,jtimu6p,"> Go has GC, so prototyping language can do whatever they want without caring about memleak  That isn't exactly true.",0.35,Go
15a4z4c,jtimopj,"However, if you have a specific goal in mind for your language(like adding a type system to an already existing dynamic language(TypeScript-style), or to be used instead of another language in a certain niche (like JavaScript in webdev, Elm-style), then you need to make choices based on that goal/niche.",0.07142857142857142,JavaScript
15a4z4c,jtinneo,Go is also a pretty simple language so you’re not going to get bogged down in trying to do fancy syntax tricks or messing around with language features.,-0.0263888888888889,Go
15a4z4c,jtixdrn,If you want what Go provides then sure.,0.5,Go
15a4z4c,jtixdrn,"I think the biggest issue is that GC and the various runtime magic Go uses makes it hard to support in webassembly, which makes it hard to provide online demos.",-0.020833333333333343,Go
15a4z4c,jtixdrn,You might want to consider targeting JS instead of or in addition to Go in order to make it easy to provide in-browser demos.,0.43333333333333335,Go
15a4z4c,jtm5jgi,"I need to write a new backend in Go to replace my treewalker, so it's this route or a VM.",0.13636363636363635,Go
15a4z4c,jtjb88l,"If you want a target language that is not C, Rust is probably the best replacement.",1.0,C
15a4z4c,jtjb88l,"If you want a target language that is not C, Rust is probably the best replacement.",1.0,Rust
15a4z4c,jtjb88l,"That gets you easy ffi to the C abi, more supported architectures, and, potentially, support for embedded devices.",0.3111111111111111,C
15a4z4c,jtjb88l,"Go has some fun footguns you will inherit, like their slice invalidation and “default values” which cause a lot of issues.",0.3,Go
15a4z4c,jtizalo,">runtime magic Go uses makes it hard to support in webassembly  Go is one of the easier languages to compile to WASM, second only to Rust.",0.05208333333333333,Go
15a4z4c,jtizalo,">runtime magic Go uses makes it hard to support in webassembly  Go is one of the easier languages to compile to WASM, second only to Rust.",0.05208333333333333,Rust
15a4z4c,jtkqen4,"I really want to see a successful case of someone compiling a non-Rust-like language to Rust, because it sounds like a nightmare to me.",0.475,Rust
15a4z4c,jtkqen4,"And since OP is interested in simply borrowing Go's GC, they're probably interested in supporting programs that are worst-case for Rust codegen.",0.1875,Go
15a4z4c,jtkqen4,"And since OP is interested in simply borrowing Go's GC, they're probably interested in supporting programs that are worst-case for Rust codegen.",0.1875,Rust
15a4z4c,jtkqen4,"And to be clear, I'm a Rust enthusiast so I'd love to be proven wrong, but it really doesn't seem like the right use case.",0.11714285714285713,Rust
15a4z4c,jtm9nd2,"If I want C ABI, why not just use C?",0.0,C
15a4z4c,jtjw9ut,"Imo, a proper ownership model with RAII is really all you need for memory management - especially if your language is more strict about object lifetimes then eg C++.",0.175,C++
15a4z4c,jtjp9ck,"WASM applications for the web benefit from having super tiny sizes, and having to generate code for the Go runtime is not great in that regard.",-0.022222222222222237,Go
15a4z4c,jtm6xbn,"> I really want to see a successful case of someone compiling a non-Rust-like language to Rust  That's pretty much what procedural macros are for, and there are lots of examples of proc-macro based custom DSLs.",0.35,Rust
15a4z4c,jtm6xbn,"I've also personally worked with Rust code-generation based on a custom SQL DSL (and yes it deals with lifetimes), and I'm sure there are plenty other examples.",0.125,Rust
15a4z4c,jtm6xbn,"Not saying that Rust is a good call, but I also don't think it's as bad as you say.",5.551115123125783e-17,Rust
15a4z4c,jtm0bdy,AFAIK TinyGo doesn't support all of Go's features and is thus not really a fair comparison.,-0.35,Go
15a4z4c,jtm0bdy,It seems like Go might not currently be a good fit for that.,0.025000000000000022,Go
15a4z4c,jtm0ozf,Does it really need to support all of Go’s features as a compilation target?,0.2,Go
15a4z4c,jtm276x,"There’s also Go Assembly, but it might be too low level, and it might not solve the size problem, as the size is almost certainly caused by the linked in stdlib.",0.10714285714285714,Go
15a4z4c,jtm276x,"There’s also Go Assembly, but it might be too low level, and it might not solve the size problem, as the size is almost certainly caused by the linked in stdlib.",0.10714285714285714,Assembly
15a4z4c,jtm33x2,"I have expressed no opinion on Go as a compiler target per se, I just gave my opinion about Go and WASM in general.",0.05000000000000002,Go
15a4z4c,jtm33x2,I don't really see what targeting Go gives you in that situation.,0.2,Go
15a4z4c,jtm4iws,"Go assembly, WebAssembly and ""real"" assembly are different things and don't operate on the same level at all.",0.06666666666666667,Go
15a4z4c,jtm4iws,"In any case it certainly wouldn't solve any bundle size problems as that has to do with Go as a language and its features, not with how it's assembled.",0.21428571428571427,Go
159b6sn,jtg8w5g,"Java’s `int`/`char` types and C/++’s unsigned integral types) is of far more practical use than any infinity would be, and this behavior can be used for tricks like single-comparison bounds checks (𝑥−𝑎 ≤ᵤ 𝑏−𝑎 ↔ 𝑥∈{[𝑎, 𝑏]}).",0.3,Java
159b6sn,jthnvsg,"There is interval arithmetic, and some languages and compilers support it (at least one Fortran compiler had vendor-specific interval arithmetic language extension).",-0.3,Fortran
159b6sn,jteu5yn,"In Lua, they go as far as using the name `math.huge` for the floating point infinity value to emphasize that it just represents a quantity that is too big to fit in a float and not necessarily a singular value representing all infinities.",0.125,Lua
159b6sn,jtht25o,In COBOL you got to choose rounding strategy.,0.0,COBOL
159b6sn,jti7c5a,"In Elm, 1 / 0 = 0.",0.0,Elm
159b6sn,juc1201,"The numbers my Pascal compiler could represent in an integer type variable was the integer range -32767..32767, not a lot.",0.0,Pascal
1597agi,,The best resource that I found so far is Lua source code (and different Lua implementations) or write ups about it.,0.3666666666666667,Lua
1597agi,,"Lua with high interoperability with C in mind, looks rather clunky and I believe dedicated implementation may be much better in terms of performance and cleanness.",0.33,Lua
1597agi,,"Lua with high interoperability with C in mind, looks rather clunky and I believe dedicated implementation may be much better in terms of performance and cleanness.",0.33,C
1597agi,jtenpy3,"I've been researching this recently, so I've got a few good resources:  - [Green Threads Explained](https://c9x.me/articles/gthreads/intro.html) - [Coroutines in Less than 20 Lines of Standard C](https://dotat.at/@/2010-01-22-coroutines-in-less-than-20-lines-of-standard-c.html) - [libaco, a fast coroutine library](https://github.com/hnes/libaco) - [ Implementing Co, a Small Language With Coroutines](https://abhinavsarkar.net/posts/implementing-co-1/)  Lua's coroutine implementation is really great and it inspired both of the C implementations I linked, but it's pretty tightly coupled to the language/VM so it's not easy to understand how it works from reading the source code.",-0.0009157509157509189,C
1597agi,jtenpy3,"I've been researching this recently, so I've got a few good resources:  - [Green Threads Explained](https://c9x.me/articles/gthreads/intro.html) - [Coroutines in Less than 20 Lines of Standard C](https://dotat.at/@/2010-01-22-coroutines-in-less-than-20-lines-of-standard-c.html) - [libaco, a fast coroutine library](https://github.com/hnes/libaco) - [ Implementing Co, a Small Language With Coroutines](https://abhinavsarkar.net/posts/implementing-co-1/)  Lua's coroutine implementation is really great and it inspired both of the C implementations I linked, but it's pretty tightly coupled to the language/VM so it's not easy to understand how it works from reading the source code.",-0.0009157509157509189,Lua
1597agi,jtenpy3,"If you spend some time working with Lua coroutines, I think you'll find it's a really elegant solution to the [What Color Is Your Function?",0.5,Lua
1597agi,jtg9mrp,"You might want to look at implementation strategies for (single shot) delimited continuations or, more recently, effect handlers, for example in Chez Scheme or OCaml 5.These are effectively a different perspective on the same feature.",0.08571428571428572,Scheme
1597agi,jte3p89,"This was written long before Python implemented `async`, and has efficient low level coroutine switching (in assembler) for x86, x86_64, arm, arm64, ppc_osx (that dates it!)",-0.025,Python
1597agi,jtfb8nr,"C# has generators which are compiled to state machines, and can be used as coroutines (e.g.",0.0,C
1597agi,jtfb8nr,You can use sharplab.io to see how they are lowered to simple C# code before compilation.,0.0,C
1597agi,jtfb8nr,"Not sure whether that satisfies your definition of coroutines, but it's been battle-tested in huge systems for many years at this point, and the C# compiler is open source.",0.16250000000000003,C
1597agi,jtoxdw3,"The code is well commented, written in C and has proper coroutine implementation (stackful).",0.0,C
1597agi,jtt7af9,"I'm not expert but I played with Protothreads in C, but that's not really proper coroutines.",0.0,C
1597agi,jtfkwp8,"Reddit must be reading my mind somehow because I was literally pacing around my room thinking about how to implement coroutines in my language written in C just before logging into Reddit to take a break, seeing this post and then this comment lol.",0.8,C
1597agi,jtgalr6,"Lua's coroutines are only ""colorless"" in the sense that there is no compiler yelling at you for using a function in the wrong context, but that just moves the error to runtime, which is arguably *worse*.",-0.3,Lua
1597agi,jtgbn9l,"That is a very different system from Lua's, which are stackful.",0.0,Lua
1597agi,jtgbn9l,"But yeah, C#/Roslyn would be a good place to look for an implementation of stackless coroutines",0.7,C
1597agi,jthfpg6,I think you're perhaps not understanding how Lua's coroutines work ([explainer](https://www.lua.org/pil/9.1.html)).,0.0,Lua
1597agi,jthfpg6,"Here's an example with Lua:      function map(fn, values)         local result = {}         for i,x in ipairs(values) do             result[i] = fn(x)         end         return result     end      -- Same whether `foo` yields or not:     result = map(foo, blah)  Versus Python:      def map(fn, values):         return [fn(x) for x in values]      # If `foo` isn't async, we can do this:     result = map(foo, blah)      # But if it is async, we gotta define an async version:     async def map_async(async_fn, values):         return [await async_fn(x) for x in values]      # And be sure to await the call:     result = await map_async(foo, blah)  I think if you spend an appreciable amount of time working with Lua's coroutines, you'll find it's a breath of fresh air and much more pleasant to work with.",0.33888888888888885,Lua
1597agi,jthfpg6,"Here's an example with Lua:      function map(fn, values)         local result = {}         for i,x in ipairs(values) do             result[i] = fn(x)         end         return result     end      -- Same whether `foo` yields or not:     result = map(foo, blah)  Versus Python:      def map(fn, values):         return [fn(x) for x in values]      # If `foo` isn't async, we can do this:     result = map(foo, blah)      # But if it is async, we gotta define an async version:     async def map_async(async_fn, values):         return [await async_fn(x) for x in values]      # And be sure to await the call:     result = await map_async(foo, blah)  I think if you spend an appreciable amount of time working with Lua's coroutines, you'll find it's a breath of fresh air and much more pleasant to work with.",0.33888888888888885,Python
1597agi,jtgvtwk,"I've been reading through chapter 9 of the book on lua.org and from what I understand, the main difference is that Lua coroutines allow yielding from deeper within the callstack.",0.16666666666666666,Lua
1597agi,jtgvtwk,Whereas in C# (or python) all yields need to be in the generator function itself.,0.0,C
15950o0,jte21wd,Is the lecture you're referring to the one on Go's metaprogramming?,0.0,Go
15950o0,jthc5ev,"Using setjmp/longjmp you can make the common path through the loop as tight as possible (at least, as tight as is possible in C without guaranteed Tailcalls).",-0.1595238095238095,C
15950o0,jtma6ty,"https://research.swtch.com/coro  > For example, Rob Pike's 2011 talk “Lexical Scanning in Go” presents the original lexer and parser for the text/template package.",0.375,Go
15950o0,jtma6ty,"I guess you had to use a state machine since it's in C, not Go.",0.0,C
15950o0,jtma6ty,"I guess you had to use a state machine since it's in C, not Go.",0.0,Go
15950o0,jtma6ty,But to be honest I don't see the similarity between this C code and what's in the video (as I remember watching it many years ago).,0.55,C
15950o0,jtjr4yh,"> Using setjmp/longjmp you can make the common path through the loop as tight as possible (at least, as tight as is possible in C without guaranteed Tailcalls).",-0.1595238095238095,C
15950o0,jtnm4ud,"You can have Goroutines in C too, I guess a light-weight call to clone3 would do it.",0.0,C
15950o0,jths30d,"This is in general quite dangerous as raw C doesn't have stack unwinding, so you need to be quite careful that you don't skip any de-initialization that was supposed to happen (e.g.",-0.22019230769230766,C
15950o0,jths30d,But for specific low-level problems it does something you can't do in C otherwise: 'goto' a location outside of the current function.,0.0,C
15950o0,jtjtvu9,I think both C and C++ would benefit from a `[[tailcall]]` attribute you could apply to a return statement that explicitly enables tail calling -- losing the debugging property of the stack trace in exchange for the guaranteed reclamation of the stack space used by the current function.,0.0,C
15950o0,jtjtvu9,I think both C and C++ would benefit from a `[[tailcall]]` attribute you could apply to a return statement that explicitly enables tail calling -- losing the debugging property of the stack trace in exchange for the guaranteed reclamation of the stack space used by the current function.,0.0,C++
15950o0,jtk7w6u,"You _can_ do stack unwinding in safe C, by manually maintaining a singly-linked list of destructors stored on stack frames, and iterating over it before `longjmp`ing.",0.5,C
1592mvm,jtdbv12,"If you’re interested in a typed Prolog and term rewriting, you should definitely check out [λ-Prolog](https://www.lix.polytechnique.fr/~dale/lProlog/).",0.125,Prolog
1592mvm,jtdyvnc,IMO it's sort of a shame that most Prolog alternatives aren't too popular.,0.55,Prolog
1592mvm,jte5308,"that you want to use as a template, and later try to emulate Prolog declarations, maybe using some collection.",0.0,Prolog
1592mvm,jtfbqxx,Prolog is so cool.,0.35,Prolog
1592mvm,jtu9gdb,It's like Prolog on steroids built into a statically typed functional language.,0.0,Prolog
1592mvm,jtp7hah,"I must shamefully admit that I have never used Prolog, but I know there is a Danish company - Prolog Development Center - that has been developing and selling a Prolog system since back in the 80es.",-0.05,Prolog
1592mvm,jtp7hah,"It of course commercial, and has even been marketed by Borland as Turbo Prolog, also as PDC Prolog and now apparently Visual Prolog.",0.0,Prolog
1592mvm,jtp7hah,"If I remember correctly what I read about it many years ago, it is indeed a Prolog version with a type system, and I would think it is a static type system.",0.5,Prolog
1592cw0,,"Basically CppFront is what I mean, its transpiler doesn't perform any semantic analysis (AFAIK) over code but just translate a new syntax in the corresponding C++, this allows the transpiler to insert useful stuff in the transpiled version, like const-by-default or order independent for function declarations.",0.030965909090909086,C++
1592cw0,jteq75t,"I've spent a lot of time programming in [Moonscript](https://moonscript.org/), which cross-compiles into Lua.",-0.1,Lua
1592cw0,jteq75t,I really like using Moonscript because it smooths over some of the clunky parts of Lua (e.g.,0.2,Lua
1592cw0,jtd30b9,"It kinda limits what you can do in your syntax sugar, but if your target language is C++ *and* your source language is supposed to be roughly the same size/power/complexity, there is only so much you can do.",0.025,C++
1592cw0,jte7327,"**  The original ""C with Objects"" transpiler that turned ""Plain C"" into ""C++"" compiler, is an example of that.",0.08035714285714286,C
1592cw0,jte7327,"**  The original ""C with Objects"" transpiler that turned ""Plain C"" into ""C++"" compiler, is an example of that.",0.08035714285714286,C++
1592cw0,jte7327,"interface where they can be executed as a Library function, instead of a command line or shell program, but I ignore if GNU C or LLVM does.",0.0,C
1592cw0,jtgs7wq,"But if along with the syntax sugar it compiles for example to a safer, easier to debug and use subset of a language ( man I wish there was a C language version of Cppfront) then yes I would definitely appreciate something like that.",0.0,C
1592cw0,jthh2b8,"Lua (and Javascript) are both very simple languages, so they work well as a set of primitives that you can build other language constructs out of (e.g.",-0.0625,Lua
1592cw0,jthh2b8,It's not hard to build a language that is a superset of Lua or Javascript.,0.14583333333333334,Lua
1592cw0,jthh2b8,"When it comes to C++, it's such an enormously complex language that I think it would be difficult to write a sugar language isn't just transpiling to a very narrow subset of C++.",-0.265,C++
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,TypeScript
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Rust
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Haskell
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Python
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,C
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,Lisp
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,Scheme
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,Clojure
158iyza,jtb7bpb,"I put Lisp in the same category as Pink Floyd and ""Zen and the Art of Motorcyle Maintenance"".",-0.05,Lisp
158iyza,jtb7bpb,"If you stumble onto Lisp in your 30s after a decade of interest in programming languages where you've absorbed most of its ideas piecemeal, it will not blow your socks off.",0.25,Lisp
158iyza,jtb7bpb,"But if you're 18 and thought you were hot shit because you wrote a 1,000 line Pascal program, your first shot of Lisp could be very mind-expanding.",0.125,Pascal
158iyza,jtb7bpb,"But if you're 18 and thought you were hot shit because you wrote a 1,000 line Pascal program, your first shot of Lisp could be very mind-expanding.",0.125,Lisp
158iyza,jtatbfg,"The [Coalton programming language](https://github.com/coalton-lang/coalton) is a strongly, statically, strictly typed programming language with eager evaluation (a la ML) and type classes (a la Haskell).",0.4333333333333333,Haskell
158iyza,jtatbfg,"Its implementation—an optimizing compiler—is ""just"" a Lisp macro, which makes it a DSL that one can use within or adjacent to Common Lisp.",-0.3,Lisp
158iyza,jtatbfg,Has Lisp historically (and sometimes anachronistically) been hyped up beyond rationality?,0.0,Lisp
158iyza,jtb7mjl,"I think, and others who I know and talk to and work with, unfortunately only for fun at the moment, in the lisp/scheme world agree with me (and you read the sentiment online often), is that when you are lucky enough to have a career where you can do fulltime Common Lisp or, even better, where you go in and out of lisp to other languages and then back, that you keep wondering, with greater and greater confusion, why everyone is making their life so hard and often quite painful.",0.05972222222222221,Lisp
158iyza,jtb7mjl,"I have been programming for over 30 years, starting with basic and I like programming languages for being programming languages (I don’t care what is the best tool for the job ; i like a language or I don’t or I have to use it because of the job) and I keep coming back to Common Lisp as the winner.",0.13999999999999999,Lisp
158iyza,jtb0zdt,"If you can stick through the few boring bits (the course was aimed at engineers at MIT so most examples have to do with engineer-y things like modeling electrical circuits etc), then I think it'll leave you with a sense of awe and an understanding of why people make the claims they make about Lisp.",-0.2333333333333333,Lisp
158iyza,jtb0zdt,"EDIT: It's not a course on Lisp, it's a course on the essence of what we call ""Computer Science"" (the very beginning of the very first lecture talks about how CS is not really a good term for this).",0.05833333333333335,Lisp
158iyza,jti9ptd,"If OOP is pragmatic like Windows, and FP is elegant like Mac, then Lisp is more like Linux where _everything_ is hackable and you're free to do anything.",0.4666666666666666,Lisp
158iyza,jti9ptd,"I seriously believe we have still only just dipped our toes into what Lisp can actually do, and there are more techniques left to discover",0.03333333333333334,Lisp
158iyza,jtarnpd,"Common Lisp is similar to Chinual Lisp, is vast, and not really a strictly functional language.",-0.1,Lisp
158iyza,jtarnpd,"Scheme is minimalistic and strongly functional, and very pure and beautiful, but not terribly useful for complex applications (Racket is a expanded version that's better suited for that).",0.26865079365079364,Scheme
158iyza,jtarnpd,"Clojure is also strongly functional, but introduces other data types such as vectors, has interop with Java and includes constructs specially designed for concurrency.",0.1663690476190476,Clojure
158iyza,jtarnpd,"Clojure is also strongly functional, but introduces other data types such as vectors, has interop with Java and includes constructs specially designed for concurrency.",0.1663690476190476,Java
158iyza,jtc1o5a,"Programming in Lisp is like programming directly in an abstract syntax tree that can modify itself, with all the wonder and horror this entails.",0.1,Lisp
158iyza,jtav0ds,"From what I can gather, Lisp is truly magical:  * It can be both compiled and interpreted (or both at the same time) * It can be both statically and dynamically typed * It can be both imperative and functional * Code can be data, and data can be code * It can be implemented entirely in itself starting from a minimal version that can be described in one page, right up to Clisp that needs 1000 pages  It can do everything, and there is nothing it can't do.",0.11428571428571428,Lisp
158iyza,jtcqjd8,"advantages that are no longer unique to Lisp), and it also depends on your use case.",0.375,Lisp
158iyza,jtcqjd8,"Personally, I find statically typed functional languages (ML, Haskell, etc.)",0.0,Haskell
158iyza,jtcf3l7,"I've done a few hobby projects in Common Lisp, and to me, the magic of Lisp is not entirely the macros.",0.0,Lisp
158iyza,jtcf3l7,"Macros are a part of that, and a part of the reason it's easier to build those tools in Lisp than in other languages, but it's not the whole thing.",0.037500000000000006,Lisp
158iyza,jtcf3l7,"It's fairly trivial in Common Lisp to write games while they are running, deploy a stubbed out webserver and remotely live-code it into existence, debug and modify a Kafka processor while it is mid-stream and running in the test Kubernetes cluster, and so on.",0.09999999999999998,Lisp
158iyza,jtcf3l7,All with the safety harness of the condition-capturing REPL and pervasive data inspector in Common Lisp REPLs.,-0.3,Lisp
158iyza,jtcf3l7,"Macros help by reducing boilerplate and helping humans to reason about the program, but it's not entirely the reason people are devoted to Lisp.",-0.05,Lisp
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,COBOL
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,ALGOL
158iyza,jtrab9n,"Of those, the language with the greatest staying power has been COBOL, and by a country mile.",1.0,COBOL
158iyza,jtrab9n,COBOL systems have been running continuously under maintenance for approximately since computers had transistors.,-0.4,COBOL
158iyza,jtrab9n,Lisp absolutely has syntax.,0.2,Lisp
158iyza,jtrab9n,What makes Lisp interesting is the semantics.,0.5,Lisp
158iyza,jtrab9n,"For a long time PL researchers tried experimenting with extensible syntax as we know the term ""syntax"" from languages like BASIC and Perl.",-0.025,Perl
158iyza,jtrab9n,"Therefore, to your question about why macros are such a big deal, I think it is because the *elemental core* of LISP (eval/apply) has a paucity of semantics *and so did every other language* for the first 50 years of Lisp's existence.",0.03125,Lisp
158iyza,jtrab9n,That is why I think it's disingenuous to call Lisp a superpower.,0.0,Lisp
158iyza,jtbgz75,I like the Lisp family a lot.,0.0,Lisp
158iyza,jtbgz75,But the real answer imo is that it was 30 years ago when Lisp was super awesome compared to mainstream alternatives.,0.5111111111111111,Lisp
158iyza,jtbgz75,"(Yes, there were other forward-looking alternatives like SML and Prolog, and I liked them too.",0.2375,Prolog
158iyza,jtbgz75,But Lisp was more generally practical.),0.275,Lisp
158iyza,jtbugo6,"I suspect that Lisp would do well here in terms of text size, but not so much less in terms of constructs e.g.",-0.16666666666666666,Lisp
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Rust
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Haskell
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,C++
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Python
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,Scala
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Rust
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Haskell
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,C++
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Python
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Scala
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,Java
158iyza,jtbugo6,"(compared to Rust baseline somewhat more expressive with more syntactic sugar and no borrow-checker to make happy)  OCaml 1.15x -- LR parser generator and tree rewriting for parsing, as well as a regex->NFA->DFA conversions for lexing.",0.65,Rust
158iyza,jtbugo6,(Rust and OCaml seem similarly expressive except that OCaml needs interface files and Rust doesn’t.),0.8,Rust
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,TypeScript
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Rust
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Haskell
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,Python
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,C
158iyza,jtcpyue,"Sure, if you have Haskell experience, these things do not seam like a big deal in comparison BUT, coming from an imperative world... the transition is quite different.",0.16666666666666666,Haskell
158iyza,jtcpyue,Lisp is an insanely small target.,-0.25,Lisp
158iyza,jtcuzrq,"The things i miss most from Clojure when working in other languages: 1. live REPL 2. data-orientation (flexible data structures with good equality semantics) 3. sane but flexible scoping rules (both lexical and dynamic binding)  But the primary problem with Clojure (and other Lisps) is its small, fragmented community and the lack of backing by a top company like MS/Meta/Google/etc.",0.19292929292929292,Clojure
158iyza,jtchfyt,Ruby is basically a modern lisp.,0.2,Ruby
158iyza,jtd9q02,"This semantic flexibility is doubly present in a lisp like Clojure, whose implementation is partially realized as a _host language library_ (which people don’t often realize).",-0.05,Clojure
158iyza,jtd9q02,"Thus you get to _apply_ the tool of homoiconic s-expressions to the JVM, Node/browser, Dart, native, etc.",0.0,Dart
158iyza,jtchxup,I  think Lisp should *always* blow your socks off.,0.0,Lisp
158iyza,jtchxup,"The [metacircular evaluator](https://www.youtube.com/watch?v=OyfBQmvr2Hc) in and of itself is mind blowing, then the next step is [Destroy some New Buildings](https://lobste.rs/s/yj31ty/collapsing_towers_interpreters)  Yet Rich Hickey is probably [late fifties, early 60s](https://www.reddit.com/r/Clojure/comments/833xur/just_curious_how_old_is_rich_hickey/)  and didn't start playing with Common Lisp until his mid 40s?",-0.023579545454545454,Lisp
158iyza,jtchxup,He then made Common Lisp 2.0 for the JVM creating Clojure.,-0.3,Lisp
158iyza,jtchxup,He then made Common Lisp 2.0 for the JVM creating Clojure.,-0.3,Clojure
158iyza,jtchxup,Lisp is fractally profound and can rediscovered at any age.,0.08333333333333333,Lisp
158iyza,jtb3xyp,> Continuations are typically available  Not outside Scheme.,0.2,Scheme
158iyza,jtauhf2,"Of course, this syntax itself must be documented (something many macro writers do a bad job of), and its meaning (i.e., semantics) must also be explained, but beyond that, its implementation should be as concerning as how a Fortran compiler might optimize away a sequence of additions and multiplications as SIMD instructions.",-0.09999999999999992,Fortran
158iyza,jten12s,"In case anyone else was wondering ... ""Chinual Lisp"" is not a typo, and apparently refers to Lisp Machine Lisp: [https://en.wikipedia.org/wiki/Lisp\_Machine\_Lisp](https://en.wikipedia.org/wiki/Lisp_Machine_Lisp)",-0.35,Lisp
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,Lisp
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,Forth
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,Prolog
158iyza,jtb4zls,"(The language is named Common Lisp or CL, I believe we've had this exact discussion before anyway.)",-0.024999999999999994,Lisp
158iyza,jtxbd9n,"The main drawback of Lisp is the repulsive syntax, which is only really good if people seriously want some kind of metaprogramming, reflection, logical artificial intelligence.",0.11190476190476191,Lisp
158iyza,jtxbd9n,"Maybe there was potential (eg Planner, 3-Lisp) but Lisp stopped developing in that direction very early on (even regressed a bit since McCarthy's days) and what it offers is not useful enough for most people to accept a syntax they don't like.",0.09666666666666668,Lisp
158iyza,jtckffl,"You can of course programmatically manipulate program structure of programs in non-homoiconic languages, like Python or Java or even C/C++ too.",0.0,Python
158iyza,jtckffl,"You can of course programmatically manipulate program structure of programs in non-homoiconic languages, like Python or Java or even C/C++ too.",0.0,Java
158iyza,jtckffl,But it is easier in a homoiconic language like Lisp since you can treat program tokens as first class citizens and don't need to manipulate them via string processing routines and regexes or some specialized API.,0.25,Lisp
158iyza,jtctcol,"SML, Haskell, OCaml, ...  Prolog would also be a popular choice for such tasks.",0.3,Haskell
158iyza,jtctcol,"SML, Haskell, OCaml, ...  Prolog would also be a popular choice for such tasks.",0.3,Prolog
158iyza,jtctcol,"Elixir is also a very capable language, so it should not be a surprise that it handles such a simple task very well.",0.115,Elixir
158iyza,jtctcol,Elixir has macros.,0.0,Elixir
158iyza,jtctcol,The difference to Lisp is that Lisp code is written in its data syntax and that macros in Lisp are relatively unrestricted.,0.0,Lisp
158iyza,jtctcol,"See https://elixir-lang.org/getting-started/meta/macros.html   In the Elixir example we have the macro named macro_unless in a module:       defmodule Unless do        defmacro macro_unless(clause, do: expression) do         quote do           if(!unquote(clause), do: unquote(expression))         end       end      end  In Lisp I would define it interactively in an editor+repl or the repl directly:      CL-USER 1 > (defmacro unless1 (clause &body body)                   `(if (not ,clause)                        (progn                          ,@body)))     UNLESS1       $ iex macros.exs      iex> require Unless     iex> Unless.macro_unless true, do: IO.puts ""this should never be printed""     nil   What does the Elixir macro transform the expression to?",0.22499999999999998,Elixir
158iyza,jtctcol,"See https://elixir-lang.org/getting-started/meta/macros.html   In the Elixir example we have the macro named macro_unless in a module:       defmodule Unless do        defmacro macro_unless(clause, do: expression) do         quote do           if(!unquote(clause), do: unquote(expression))         end       end      end  In Lisp I would define it interactively in an editor+repl or the repl directly:      CL-USER 1 > (defmacro unless1 (clause &body body)                   `(if (not ,clause)                        (progn                          ,@body)))     UNLESS1       $ iex macros.exs      iex> require Unless     iex> Unless.macro_unless true, do: IO.puts ""this should never be printed""     nil   What does the Elixir macro transform the expression to?",0.22499999999999998,Lisp
158iyza,jtctcol,"In Lisp we can macroexpand the expression, too:      CL-USER 2 > (macroexpand-1                  '(unless1 true                     (print ""this should never be printed"")))      (IF (NOT TRUE)         (PROGN (PRINT ""this should never be printed"")))  The result looks like normal Lisp source code and like Lisp data, at the same time.",0.08124999999999999,Lisp
158iyza,jtctcol,"CL-USER 3 > (eval *)     NIL  We could also create the source code with the usual Lisp operators for list manipulation:      CL-USER 8 > (defmacro unless1 (clause &body body)                   (list 'if (list 'not clause)                         (cons 'progn body)))     UNLESS1      CL-USER 9 > (macroexpand-1                  '(unless1 true                     (print ""this should never be printed"")))      (IF (NOT TRUE) (PROGN (PRINT ""this should never be printed"")))  There is a certain look and feel to this way of programming programs.",0.07785714285714285,Lisp
158iyza,jtctcol,"Treating code as data, without changing the representation, is a part of what makes Lisp special.",0.35714285714285715,Lisp
158iyza,jtctcol,"Lisp does not have the nice surface syntax of Elixir, but then it also does not have the complex code representation.",0.15,Lisp
158iyza,jtctcol,"Lisp does not have the nice surface syntax of Elixir, but then it also does not have the complex code representation.",0.15,Elixir
158iyza,jtctcol,"Depends, but it is something which makes Lisp different.",0.0,Lisp
158iyza,jtdc2uo,"Haskell was actually pretty easy to pick up, learn you a Haskell is super approachable.",0.33888888888888885,Haskell
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,Haskell
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,Clojure
158iyza,jv9rvlo,"In Python, the way modules work makes it impossible to reliably patch a module once it's been loaded.",-0.6666666666666666,Python
158iyza,jv9rvlo,"In JavaScript, modules are hermetically sealed, so you have zero visibility into them from the REPL, so you can't change them.",0.0,JavaScript
158iyza,jv9rvlo,"And all of these languages have stack-unwinding exceptions, meaning that even if you can patch definitions at runtime (like you can in Ruby), you can't do Lisp-style interactive programming because the debugger can't be launched until after the stack unwinds.",0.0,Ruby
158iyza,jv9rvlo,"Decades have passed in which all new programming languages just copy C++'s exception mechanism, or reject it and implement C-style error handling instead.",0.13636363636363635,C++
158iyza,jtcuj21,"Document processing software, big data analytics, urban transportation planning systems, cloud backup service providers, AI, Google…  (cool read, 2014: pgloader switching from Python to CL https://tapoueh.org/blog/2014/05/why-is-pgloader-so-much-faster/)  ping /u/smthamazing for the ""mostly historical?""",0.0875,Python
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,Lisp
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,Rust
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,Java
158iyza,jtcscy1,"So, the CL version was beating (in speed) the Rust version.",0.0,Rust
158iyza,jtcscy1,"Of course, he wasn't writing the most efficient Rust code.",0.5,Rust
158iyza,jtcscy1,"The Rust community came to give a hand, sent PRs on his repository, they had lengthy discussions, they tried different approaches, and ultimately they got a very fast Rust program (that's in the follow-up article).",0.08666666666666667,Rust
158iyza,jtcscy1,"So even if the final Rust version beats it, 1) they run in the same ballpark (SBCL produces very fast code and is often at the top of the benchmarks, a little slower than C or sometimes beating it), 2) this says a lot about a developer's efficiency IMO (and we didn't even talk about workflows and the CL productivity: very short write-compile-test cycles, interactive debugging etc).",0.09541666666666666,Rust
158iyza,jtcscy1,"So even if the final Rust version beats it, 1) they run in the same ballpark (SBCL produces very fast code and is often at the top of the benchmarks, a little slower than C or sometimes beating it), 2) this says a lot about a developer's efficiency IMO (and we didn't even talk about workflows and the CL productivity: very short write-compile-test cycles, interactive debugging etc).",0.09541666666666666,C
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,Lisp
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,C
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,Perl
158iyza,jv9xtgd,"The best way to explain the power of macros is by comparing them with React, which, due to JavaScript's lack of macros, requires its own compiler.",0.4916666666666667,JavaScript
158iyza,jv9xtgd,"If browsers ran Common Lisp instead of JavaScript, React would've used read macros instead of needing a separate compiler.",-0.3,Lisp
158iyza,jv9xtgd,"If browsers ran Common Lisp instead of JavaScript, React would've used read macros instead of needing a separate compiler.",-0.3,JavaScript
158iyza,jte091q,"Lisp also pioneered OO, including Flavors (which originated ""mixins"") and CLOS.",0.0,Lisp
158iyza,jtcx993,In Lisp it is relatively simple to extend the language incrementally.,0.0,Lisp
158iyza,jtcx993,In this case this is Lisp with added macros and the target language is also Lisp.,0.0,Lisp
158iyza,jtcx993,"See for example the SBCL (an implementation of Common Lisp, mostly in Common Lisp) compiler itself.",-0.3,Lisp
158iyza,jtcx4lo,Many of the stated advantages of Lisp have nothing to do with macros.,0.5,Lisp
158iyza,ju8i0wq,"I don't know if you can be effective with Lisp without using macros, but in other languages the meta programming stuff like reflection and eval can often be avoided or relegated to libraries that do stuff like (de)serialization for you  Also lol I totally get that.",0.31875,Lisp
158iyza,ju8i0wq,"I can stand it for like maybe a month or two and then I've gotta take a break for my own well-being, otherwise I get grouchy  (Edit: also yes, Forth is different)",0.3,Forth
158iyza,jtdctf5,"Common Lisp supports and extensively uses dynamic scoping, it just has to be explicitly requested for a given variable.",-0.09999999999999999,Lisp
158iyza,juhiupj,"so  ""chinual lisp"" stands for ""Lisp machine manual lisp"".",0.0,Lisp
158iyza,juhiupj,"I never heard such abbreviation for ""Lisp machine lisp"".",0.0,Lisp
158iyza,jtxsdjb,"I remember using a thin syntax wrapper around C, for the first substantial program I wrote in it, to take care of some of the rough edges.",-0.08333333333333333,C
158iyza,jtxsdjb,"For Lisp, a project I played with once let me write code in a universal syntax of my choice, which was then translated to a range of languages.",0.0,Lisp
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,Python
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,Lua
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,C
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,Lisp
158iyza,jtxsdjb,"So for a `Fibonacci` benchmark in that syntax, it produced this Lisp source which runs under CLisp:      ; Lisp source output          (defun start ()       (format t ""~a"" (fib 36))       (format t ""~%"")     )          (defun fib (n)       (if (< n 2)           (return-from fib n)           (return-from fib (+ (fib (- n 1)) (fib (- n 2))))       )     )          (start)  But there was a problem: my universal syntax didn't have its own semantics and capabilities, those still belonged to the target language.",0.3,Lisp
158iyza,jtxsdjb,"Most languages, their syntax is also their identity: you can tell if you're coding in Python or in Lisp.",0.5,Python
158iyza,jtxsdjb,"Most languages, their syntax is also their identity: you can tell if you're coding in Python or in Lisp.",0.5,Lisp
158iyza,jtxsdjb,"Still, if I'd somehow got a job where I had to produce Lisp code, I would probably use such a conversion tool.",0.0,Lisp
158iyza,jtdb0dg,"I get that some stuff demands quite a lot (like Haskell, which is brilliant but also, y'know, Haskell) but some of them are pretty easy to pick up.",0.5277777777777778,Haskell
158iyza,jtciqbr,Like Sun pouring $500m into PR and marketing for Java.,0.0,Java
158iyza,jup79g5,Forth is like HaikuOS.,0.0,Forth
158iyza,jtk9oq4,"If you quote it, it is just code (data):      '(defun yey ()        (if (< 2 3) (message ""yey"")))  For example you can ask for the first element of the list:      (first '(defun yey ()               (if (< 2 3) (message ""yey""))))  => defun  Of you can ask for nth element of the list:       (nth 3 '(defun yey ()               (if (< 2 3) (message ""yey""))))  => (if (< 2 3) (message ""yey""))  You can also eval that 3 element as any code:      (eval (nth 3 '(defun yey ()                (if (< 2 3) (message ""yey"")))))  => ""yey""  Now imagine setting up a code and evaluating it in some other language like C++ or Python.",-0.4107142857142857,C++
158iyza,jtk9oq4,"If you quote it, it is just code (data):      '(defun yey ()        (if (< 2 3) (message ""yey"")))  For example you can ask for the first element of the list:      (first '(defun yey ()               (if (< 2 3) (message ""yey""))))  => defun  Of you can ask for nth element of the list:       (nth 3 '(defun yey ()               (if (< 2 3) (message ""yey""))))  => (if (< 2 3) (message ""yey""))  You can also eval that 3 element as any code:      (eval (nth 3 '(defun yey ()                (if (< 2 3) (message ""yey"")))))  => ""yey""  Now imagine setting up a code and evaluating it in some other language like C++ or Python.",-0.4107142857142857,Python
158iyza,jtk9oq4,"Indexing in Emacs Lisp is as in C, from 0, 1, ... N-length, and (cadr list) is same as (nth 1 list), I have jused that one just because it would look more ugly with (nth 1 (nth 2 ...)).",-0.06666666666666665,Lisp
158iyza,jtk9oq4,"Indexing in Emacs Lisp is as in C, from 0, 1, ... N-length, and (cadr list) is same as (nth 1 list), I have jused that one just because it would look more ugly with (nth 1 (nth 2 ...)).",-0.06666666666666665,C
158iyza,jtk9oq4,"Anyway, it is a very contrived and toy example, but try to rewrite it in Python or C++, and you will see a difference in code you use for the manipulation (program you write) and code you manipulate since there will be lots of string manipulations.",-0.65,Python
158iyza,jtk9oq4,"Anyway, it is a very contrived and toy example, but try to rewrite it in Python or C++, and you will see a difference in code you use for the manipulation (program you write) and code you manipulate since there will be lots of string manipulations.",-0.65,C++
158iyza,jtk9oq4,In Lisp the system does it for you (more or less) so you can write your programs as the code you manipulate is actually live program code.,0.15656565656565657,Lisp
158iyza,jtk9oq4,But look at JS or Python and how they write code they send back into the interpreter.,0.0,Python
158iyza,jtk9oq4,Compare to Lisp and property lists.,0.0,Lisp
158iyza,jtk9oq4,"Due to implementation of JS they of course can't do that, but if JS was a Lisp ...  > Any reasonable language infrastructure would manipulate program representations through ASTs  Would it?",0.037500000000000006,Lisp
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,Python
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,C
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,C++
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,Java
158iyza,jtk9oq4,Do you have access to the AST of your program when you type your programs in C++ or Java normally?,0.15,C++
158iyza,jtk9oq4,Do you have access to the AST of your program when you type your programs in C++ or Java normally?,0.15,Java
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,Java
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,Lisp
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,C
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,C++
158iyza,jtmkm1x,"In my view, Lisp only slightly increases the effective range of action from non-Lisp languages, but those differences put together bring you from something like 90% coverage on the best non-Lisp languages (e.g.",0.30666666666666664,Lisp
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,Haskell
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,Ruby
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,Elixir
158iyza,jtmkm1x,"Lisp languages may be less popular due to the initial work to familiarize yourself with the syntax (and many historical factors as well), but they have technical advantages that to my knowledge have only been matched by languages others consider to be Lisps or Lisp-equivalents (including the same gripes about too little syntax and universal open/close markers (usually parentheses))  &#x200B;  *The original draft of this post was a bit of a ramble elaborating on the above, kept here because I don't want to waste all that writing:*  &#x200B;  Most languages (and in truth most computing frameworks, period) try to make the \[default\] user interface (or developer interface, if you prefer; developers are the users of languages, after all!)",0.0982843137254902,Lisp
158iyza,jtmkm1x,"I'm unfamiliar with Elixir, but from your and lispm's examples here it seems to fit the same mold.",0.2,Elixir
158iyza,jtmkm1x,"Facilities like C's macro system (horrible though it is), or Elixir's apparently-better macro system extend this space to contain all possible language features; but the areas that aren't covered by the core language tend to have different usability characteristics, making them much slower to develop.",-0.2,C
158iyza,jtmkm1x,"Facilities like C's macro system (horrible though it is), or Elixir's apparently-better macro system extend this space to contain all possible language features; but the areas that aren't covered by the core language tend to have different usability characteristics, making them much slower to develop.",-0.2,Elixir
158iyza,jtmkm1x,"&#x200B;  Lisp languages don't exactly fit the above pattern, because their first priority is to make the conceptual core of the language as simple as possible.",0.13,Lisp
158iyza,jtmkm1x,Common Lisp also adds *some* focus on the user (i.e.,-0.3,Lisp
158iyza,jtmkm1x,"developer) interface, Scheme barely focused on anything but simplicity in its formative years and is now trying to make up for that mistake, and Racket is bound by some limits of Scheme but is otherwise excellent.",0.525,Scheme
158iyza,jtmkm1x,"But one important implication of Lisp's generality is the language-oriented programming paradigm, the ability to design toolkits that make arbitrary areas of possibility-space easier to navigate.",0.15000000000000002,Lisp
158iyza,jtmkm1x,*And* you still maintain the significant difficulty-reduction Lisp provides for tasks which *nobody* has written a framework for.,0.375,Lisp
158iyza,jtmkm1x,"(Note: In practice, only toy libraries like with-c-syntax bother to paper over S-expressions, since making use of Lisp's unique benefits requires the relationship between homoiconicity and macros, a relationship which would be covered up by complex syntax.",0.025000000000000005,Lisp
158iyza,jtmkm1x,"It's reasonably easy to do (especially compared to most other languages), and has to some extent already been done, but if you're familiar with Lisp you likely won't want to do it)  There's also no artificial, language-induced constraints on where your packages can be used.",0.2119047619047619,Lisp
158iyza,jtmkm1x,"You don't have to arbitrarily divide your users into ""Users"" and ""Developers""; any development work you do advances the entire system of ""people using Lisp software"".",-0.05,Lisp
158iyza,jtmkm1x,"&#x200B;  All the above points are, as far as I know, unique to Lisp languages.",0.15833333333333333,Lisp
158iyza,jtmkm1x,"Even lispm's Elixir example, though far more attractive than the other mainstream languages I've had the misfortune to become skilled at, sets a distinct format which macros have to follow, and which seems both less readable and more inconvenient to write than your example of ordinary Elixir code.",0.15583333333333332,Elixir
158iyza,jtmkm1x,I agree that it takes some time to familiarize yourself with Lisp syntax.,0.0,Lisp
158iyza,jtmkm1x,"And I can appreciate the benefits of creating libraries that make writing *most* code easier, rather than *all* code (I've actually been designing such an abstraction layer for Common Lisp, though work is too busy to have gotten it to the implementation stage yet).",0.06000000000000001,Lisp
158iyza,jtmkm1x,"To me, that's far more unpalatable than any of Lisp's weaknesses.",0.3,Lisp
158iyza,jthujoj,">I love parentheses (but highly prefer Scheme and Racket over Common Lisp), but the ""power"" of Common Lisp is overstated.",0.015000000000000013,Scheme
158iyza,jthujoj,">I love parentheses (but highly prefer Scheme and Racket over Common Lisp), but the ""power"" of Common Lisp is overstated.",0.015000000000000013,Lisp
158iyza,jthujoj,I vastly prefer Common Lisp over Scheme&Racket.,-0.15,Lisp
158iyza,jthujoj,I vastly prefer Common Lisp over Scheme&Racket.,-0.15,Scheme
158iyza,jthujoj,Not really in Lisp.,-0.1,Lisp
158iyza,jthujoj,"In Lisp the rules are more like: if one needs a linguistic abstraction, write a macro.",0.3,Lisp
158iyza,jthujoj,"Btw., the numbers of top-level macros in my Lisp Machine (an emulator running on my MacBook Pro)  world (the running Lisp image, which is an operating system) is 6955.",0.0,Lisp
158iyza,jtdk0bh,">I get that some stuff demands quite a lot (like Haskell, which is brilliant but also, y'know, Haskell)  I don't think that they demand a lot (at least not to be productive), but they usually *do* demand that you learn *some* new way of thinking about things.",0.12159090909090911,Haskell
158iyza,jtdk0bh,"That's why Haskell seems so alien to people - ""How am I supposed to do anything if I can't mutate a variable?"".",-0.25,Haskell
158iyza,jv9xg7p,"Copy the executable to another machine that doesn't have Artichoke, Rust, or anything else installed.",0.0,Rust
158iyza,jv9xg7p,"Run the executable file and get into a new REPL (when you save a Lisp image, it comes with the REPL and the compiler).",0.13636363636363635,Lisp
158iyza,jv9xg7p,"Since this is Ruby we're talking about, this was probably a Web server, so you have to re-run the HTTP request that originally caused the error, probably twice (once to reproduce the error and get into the debugger, and again once you've reloaded the corrected server).",0.375,Ruby
158iyza,jv9xg7p,"If the server was written in Lisp, the debugger would come up automatically when the error is signalled.",0.0,Lisp
158iyza,jv9xg7p,"The program stops on the expression that is equivalent to Ruby's `raise` statement, before the error is actually thrown.",0.0,Ruby
158iyza,jv9xg7p,Can Ruby do *that?,0.0,Ruby
158iyza,jv9xg7p,"While it has *some* of the required functionality (unlike Python, it *can* patch definitions in memory), it's missing the ability to handle exceptions *before* unwinding the stack (the Lisp debugger is just an exception handler), and its debugger lacks the ability to re-run stack frames, so it does you no good to be able to dynamically patch a definition.",-0.01666666666666668,Python
158iyza,jv9xg7p,"While it has *some* of the required functionality (unlike Python, it *can* patch definitions in memory), it's missing the ability to handle exceptions *before* unwinding the stack (the Lisp debugger is just an exception handler), and its debugger lacks the ability to re-run stack frames, so it does you no good to be able to dynamically patch a definition.",-0.01666666666666668,Lisp
158iyza,jv1fe8e,But you can also load Forth as an OS and bypass all ideas of kernels and syscalls and file systems and desktop environments and everything,0.0,Forth
158iyza,jtdxq8p,"Well, that and the fact that 40% or tutorials start with category theory, 30% say ""you don't need maths for Haskell!""",0.0,Haskell
158iyza,jtdxq8p,"I agree that the actual concepts behind programming in Haskell are not just easy to understand, but they're also much more simple than the alternatives.",0.10666666666666666,Haskell
158iyza,jtdxq8p,"I like Haskell and the ideas which created it, but the documentation is often super confusing and relies heavily on the consumer of the API knowing all the buzzwords (Monad, monad transformer, monoid, etc.).",-0.05555555555555556,Haskell
158iyza,jte27gz,">I like Haskell and the ideas which created it, but the documentation is often super confusing and relies heavily on the consumer of the API knowing all the buzzwords (Monad, monad transformer, monoid, etc.).",-0.05555555555555556,Haskell
158iyza,jte27gz,"It's not much harder to understand what a monoid is than to understand inheritance for example, and I was taught that in my second-ever lecture on C++.",0.05,C++
158iyza,jte27gz,"And I'm fully supportive of that reluctance when all you care about is to write a couple Python scripts to scrape a website or whatever, but when this is your profession and you care about writing good quality software then that's a very different story and it practically becomes your duty to spend some time working these concepts.",0.39999999999999997,Python
158iyza,jte3oah,"We're fully on the same page, but people aren't starting on Haskell, and even if they were it's still not very accessible compared to say, Elm.",-0.04807692307692307,Haskell
158iyza,jte3oah,"We're fully on the same page, but people aren't starting on Haskell, and even if they were it's still not very accessible compared to say, Elm.",-0.04807692307692307,Elm
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,Haskell
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,Lisp
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,Java
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,JavaScript
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,C++
158iyza,jteca32,"Then, in C++, you have the infamous:      #include <iostream>     int main() {        std::cout << ""Hello world!\n"";       return 0;     }  If you've never seen code in this format before, you have to mentally parse the following syntax/semantic objects (accompanied with their fancy terminologi):  1. the `#include` (compiler directives) 2. the `<iostream>` (header files) 3. the `int main()` (type declaration, function arguments) 4. the `{...}` (scope) 5. the `std::cout` (namespaced qualifiers) 6. the `<<` (stream operator) 7. the `\n` (line break character sequence) 8. the `;` (expression terminator) 9. the `return 0` (return statement, which at first made me think ""what does it mean to return in my code, why am I returning a seemingly random number, and to whom?"")",-0.10364583333333334,C++
158iyza,jteca32,"I won't even bother breaking down Java's:      public class HelloWorld     {       public static void main(String[] args)         {           System.out.println(""Hello world!",0.11736111111111111,Java
158iyza,jteca32,""");         }     }  Here's hello world in Haskell and Lisp, for comparison:      // Haskell     main = putStrLn ""Hello world!""",0.20833333333333331,Haskell
158iyza,jteca32,""");         }     }  Here's hello world in Haskell and Lisp, for comparison:      // Haskell     main = putStrLn ""Hello world!""",0.20833333333333331,Lisp
158iyza,jteca32,"// Lisp     (print ""Hello world!"")",0.0,Lisp
158iyza,jteca32,And yet these languages build up on theory that's widely considered much more esoteric than that of C++ or Java.,0.2,C++
158iyza,jteca32,And yet these languages build up on theory that's widely considered much more esoteric than that of C++ or Java.,0.2,Java
158iyza,jteca32,"I'm not saying that this makes them beginner-friendly languages (your first \~100 Haskell compiler errors can be cryptic gibberish, and Lisp's `car` and `cdr` historic baggage is confusing and unattractive, to put it mildly), but out of the three I think it's clear which one makes it easier to get your feet wet as a complete beginner.",0.054761904761904755,Haskell
158iyza,jteca32,"I'm not saying that this makes them beginner-friendly languages (your first \~100 Haskell compiler errors can be cryptic gibberish, and Lisp's `car` and `cdr` historic baggage is confusing and unattractive, to put it mildly), but out of the three I think it's clear which one makes it easier to get your feet wet as a complete beginner.",0.054761904761904755,Lisp
158iyza,jteemhx,But a course that's brain dead enough to get you started with programming on C++ or Java isn't going to be better at teaching you any amount of input beyond hello world.,0.09999999999999999,C++
158iyza,jteemhx,But a course that's brain dead enough to get you started with programming on C++ or Java isn't going to be better at teaching you any amount of input beyond hello world.,0.09999999999999999,Java
158iyza,jteemhx,"``` print(""Hello World"") ``` Seems more straight forward than Haskell to me.",0.35,Haskell
158iyza,jteemhx,"Mainly though, I agree with you- what I was trying to say is that Haskell is easy and much simpler (well, GHC is a massive complex project with language extensions yadda yadda but you get my point) but very *very* few people are learning Haskell as their first language.",0.06999999999999999,Haskell
158exhb,,"Alas, Vale's compiler is still written in Scala which doesn't have linear types, so I had a bug.",-0.4,Scala
158exhb,jt9yg02,"""I did X but forgot to do Y"" - I'm also getting warned by this by elm-review - a linter for the Elm language - and specifically its set of NoUnused rules.",0.0,Elm
158exhb,jtlkp67,For example in C++ the compiler guarantees your destructors get called and therein you release everything you acquired.,0.0,C++
158exhb,jtbrw4p,"There's a talk on it that compares Idris and Scala: https://www.youtube.com/watch?v=fV2no1Rkzdw  I take example from them to here:  ``` testFile : FileIO () testFile = catch (   do open ""testFile"" Read     str <- readFile    putStrLn (show str)    ls <- Count :- get    close    putStrLn (show ls))  (\err => putStrLn (""Handled: "" ++ show err)) ```  In this example, if you remove the ""close"" line, the program simplely won't compile.",0.0,Scala
158exhb,jtesizv,"There are implementation of session types in Rust, which only has support for affine types (not fully linear).",0.0,Rust
158exhb,jtakh26,It's Haskell :)  Isn't your example about forgetting to do Y?,0.5,Haskell
158exhb,jtaq6ii,"That explains it, I never learned Haskell ;) Definitely my achilles heel.",0.125,Haskell
158exhb,jtaq6ii,"If the user only exposes one way to consume X's result (specifically, the operation Y) then the compiler makes sure we can never forget to do Y.  I heard that LiquidHaskell has linear types, so the difference between Haskell and LiquidHaskell might have a better answer for you than I can give.",0.3333333333333333,Haskell
157dlmc,,"I don't see this to be a thing in major languages, but in my language, this is possible: (note that `=` is pattern matching, will succeed only if LHS = RHS) ``` a = [5, 6] [1, 2, 3, 4, 5, 6, 7, 8] = [1, 2 .. [3, 4] .. a, 7, 8] [1, 2, 3, 4, 5, 6, 7, 8] = [.. [1, 2, 3, 4], 5, 6, 7, 8] ``` The idea behind this is just Lisp's `splice-unquote`.",-0.21749999999999997,Lisp
157dlmc,jt58f8n,"Or you could copy Python's prefix-star and get `[1,2,3,4,*a,7,8]` which I think Guido got right.",0.2857142857142857,Python
157dlmc,jt458vw,"Answer on my own:  Elixir's `|` seems fine, I expect binary operation to be rarely used in my language to might as well use `bor` or something else.",0.4388888888888889,Elixir
157dlmc,jt8viqx,"For this I'd use a flatten function, like in good ol' PHP.",0.7,PHP
157dlmc,jt835jd,"I use `...` for varargs in my language just as in Lua, so I can't do it.",0.0,Lua
157dlmc,jtofuci,Weird Haskell.,-0.5,Haskell
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,Perl
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,Ruby
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,Crystal
157dlmc,jtfjebf,Rust serves as a good reminder of that failure.,0.19166666666666662,Rust
157dlmc,jtpbg3p,"And you use the same union type syntax as languages like TypeScript and Scala 3, where it is _not_ discriminated.",0.0,TypeScript
157dlmc,jtpbg3p,"And you use the same union type syntax as languages like TypeScript and Scala 3, where it is _not_ discriminated.",0.0,Scala
157dlmc,jtpfzgy,TypeScript's unions are not tagged.,0.0,TypeScript
157dlmc,jtpfzgy,"> TypeScript and Scala 3, where it is not discriminated.",0.0,TypeScript
157dlmc,jtpfzgy,"> TypeScript and Scala 3, where it is not discriminated.",0.0,Scala
157dlmc,jtpfzgy,"It means if `a | b` is not a tagged union, then you must discriminate yourself either by using intersected properties of the subtypes, as in TypeScript, or a by making it a dependent type on some external state, as do C-style anonymous unions.",0.0,TypeScript
157dlmc,jtpfzgy,The type variables being scoped address this issue by not requiring type specialisation rules as are present in C++ templates.,0.0,C++
157dlmc,jtpfzgy,"That said, this is a purely syntactic issue, which C++ solves exactly in the same way the code I posted does.",0.15476190476190477,C++
157dlmc,jtpfzgy,"I have a compiler that translates this code      f: (Int | String) -> Int     f (x: Int) = x     f (s: String) = s.length  into Assembly code roughly equivalent to this:      Int f₀(Int x) { return x; }     Int f₁(String s) { return length(s); }     Int f(Union<Int, String> x)     {         if(x.is<Int>()) {             return f₀(x.as<Int>());         }         else {             return f₁(x.as<String>());         }     }  This follows the System V ABI for AMD64, and all three routines are callable from C/C++ compilers adhering to it.",-0.425,Assembly
157dlmc,jtpfzgy,GCC outputs the same code when I write the code in C++.,0.0,C++
157dlmc,jtprgj3,"But then you're not really designing a ""weird Haskell"" as you stated above, since many important Haskell things will no longer be possible, such as polymorphic recursion (used to traverse nested data types) and GADTs, to name just a couple.",0.042857142857142864,Haskell
157dlmc,jtprgj3,"(I would assume so, since you keep referring to Java and C++ overloading, which both include subtyping-based overloading.)",0.0,Java
157dlmc,jtprgj3,"(I would assume so, since you keep referring to Java and C++ overloading, which both include subtyping-based overloading.)",0.0,C++
157dlmc,jtqzw76,"> you're not really designing a ""weird Haskell""     Oh I was describing the syntax/pseudocode I use, rather than what I'm actually doing in my free time.",-0.04999999999999999,Haskell
1576cdw,jt3v8aj,"This is the Mutability XOR Aliasing issue raised by Rust, which it addresses via its Borrowing restrictions (preventing mutation), and that Val addresses via its ""subscripts"" (preventing aliasing).",0.0,Rust
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,Haskell
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,Python
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,JavaScript
1576cdw,jt4w3oe,"I think it would probably be possible to combine something like Rust's alias analysis for mutable pointers with `fip` functions, so you'd have an opt-in borrow checker that you need to enable whenever you wanted mutable pointers into your data structures (where you'd initially need to acquire a uniqueness guarantee, probably by inspecting the reference counts).",0.0,Rust
1576cdw,jt4a20l,Because looking it up it seems that union field access in Rust is indeed unsafe.,0.0,Rust
1576cdw,jt4ssug,"""Unions or equivalent"" includes tagged unions (like Rust's enums).",0.0,Rust
1576cdw,jt4ssug,"Rust stops us from doing this because of ""aliasable XOR mutable"":      error[E0506]: cannot assign to `changeable` because it is borrowed       --> src/lib.rs:17:5        |     9  |     let ptr: &&str = match &changeable {        |                            ----------- `changeable` is borrowed here     ...     17 |     changeable = PointerOrInt::SomeInt(12345);        |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `changeable` is assigned to here but it was already borrowed     18 |          19 |     println!",0.0,Rust
1576cdw,jt9rjij,"That is, not just a machine type^1 , but a more complex contraption with object header, etc...  ^1 _Not a Lisp machine type, an x86 or ARM machine type._",0.1,Lisp
1576cdw,jt59cso,"FWIW Rust absolutely does have untagged unions, for C interoperability.",0.2,Rust
1576cdw,jt59cso,"FWIW Rust absolutely does have untagged unions, for C interoperability.",0.2,C
1576cdw,jtefdau,"This is what borrow-checking (Rust) or subscripts (Val) ""solve"", and I don't see how partial read barriers can solve that.",-0.1,Rust
1576cdw,jtjhvio,"- Or the escape of the interior pointer, which is what Rust's borrow checking does.",0.0,Rust
156wrxx,,"E.g., languages like Swift, Haskell, Agda, etc.",0.0,Swift
156wrxx,,"E.g., languages like Swift, Haskell, Agda, etc.",0.0,Haskell
156wrxx,jt1z53v,At least in Haskell you don't define an operator compared to another one.,-0.3,Haskell
156wrxx,jt1z53v,"In something like C# and C++ you can only override existing operators, so that follows their existing precedences.",0.0,C
156wrxx,jt1z53v,"In something like C# and C++ you can only override existing operators, so that follows their existing precedences.",0.0,C++
156wrxx,jt34k06,"Haskell will require that you disambiguate the operator by giving its fully qualified name - for example, `A.??`.",0.0,Haskell
156wrxx,jt259zp,As compared to languages like Python or Scala where operators are methods (magic or otherwise) that get called on their left-hand side.,0.5,Python
156wrxx,jt259zp,As compared to languages like Python or Scala where operators are methods (magic or otherwise) that get called on their left-hand side.,0.5,Scala
156wrxx,jt2gtdj,"Scala actually does have varying precedence for custom operators, but that precedence is determined by the first character of the operator.",0.125,Scala
156wrxx,jt95o3k,"Java pretty much killed it off, and quickly too.",0.12777777777777777,Java
156v4mf,,"Consider variable declaration in C vs Python:  C: int age = 21;  Python: age = 21  I don't understand why static types can't be an option for otherwise dynamically typed languages, especially given the capability of type inference, it seems like a small difficulty to allow the programmer to specify a type for their variables in a language that uses dynamic typing.",0.0625,C
156v4mf,,"Consider variable declaration in C vs Python:  C: int age = 21;  Python: age = 21  I don't understand why static types can't be an option for otherwise dynamically typed languages, especially given the capability of type inference, it seems like a small difficulty to allow the programmer to specify a type for their variables in a language that uses dynamic typing.",0.0625,Python
156v4mf,jt1ltke,"I’ll let others address the nuances around static/dynamic typing as a philosophy and simply point out that Common Lisp supports type specifications, but doesn’t require them.",-0.15,Lisp
156v4mf,jt1oq23,"The part about static vs dynamic typing has already been addressed, but I'll point out that in terms of providing or omitting the type, Python has optional type annotations (`a: int = 2`), while C++ allows types to be inferred (`auto a = 2`), and so is the case for most other languages I know",0.21875,Python
156v4mf,jt1oq23,"The part about static vs dynamic typing has already been addressed, but I'll point out that in terms of providing or omitting the type, Python has optional type annotations (`a: int = 2`), while C++ allows types to be inferred (`auto a = 2`), and so is the case for most other languages I know",0.21875,C++
156v4mf,jt6h98l,"Just a bit of reference, dlang, also known as D, allows you to not worry types by having an auto keyword.",0.0,D
156v4mf,jt1og7k,"See Hindley/Milner for the most common base  Hybrid strategies exist, like in JVM bytecode all ""objects"" are dynamic at runtime, but the Java compiler enforces type safety at compile time.",-0.15000000000000002,Java
156v4mf,jt1og7k,"JRuby)  (Edit: for the purposes of the OP, which I think is more about type _inference_ than static/dynamic typing, and to not put Java into the very-verbose bucket it was born in... Java also keeps getting more and more inference powers.",0.5,Java
156v4mf,jt1og7k,"Who knows how far they'll go, but Java's proven strategy is to leverage the ""last mover"" advantage and make decisions with a lot of experts and prior existing work)",0.03333333333333333,Java
156v4mf,jt1povu,"Python type hints look weird to me, compared to C/C++, and typescript is fully statically typed, so the type can't be omitted, correct?",-0.5,Python
156v4mf,jt1q52y,">Common Lisp supports type specifications, but doesn’t require them.",0.0,Lisp
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,Python
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,C
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,C++
156v4mf,jt1uktq,"This is because Python is dynamically typed by default, and type hinting is a feature that was introduced to help make Python code more understandable and easier to debug.",0.5,Python
156v4mf,jt1uktq,"In Python, type hints are optional, which means they don't change how the code runs, but they do provide a way for tools and IDEs to give better support for Python development.",0.5,Python
156v4mf,jt1uktq,"As for TypeScript, it is indeed a statically typed superset of JavaScript.",0.0,TypeScript
156v4mf,jt1uktq,"As for TypeScript, it is indeed a statically typed superset of JavaScript.",0.0,JavaScript
156v4mf,jt1uktq,"So in TypeScript, types can't be omitted in the sense that any variable or function you declare will have a type, whether explicitly declared by you or inferred by TypeScript.",0.0,TypeScript
156v4mf,jt1uktq,"However, TypeScript does allow a degree of flexibility with types using the ""any"" type when you need it.",0.0,TypeScript
156v4mf,jt1uktq,"Although it's generally recommended to avoid using ""any"" as much as possible to benefit from TypeScript's type checking features.",0.02500000000000001,TypeScript
156v4mf,jt2174l,"For Python, Mypy, PyRight, PyType, and Pyre all do this exact thing",0.25,Python
156v4mf,jt36eae,"There are other fun ones out there too -- I think Groovy counts, but Clojure does not.",0.0875,Groovy
156v4mf,jt36eae,"There are other fun ones out there too -- I think Groovy counts, but Clojure does not.",0.0875,Clojure
156v4mf,jt36eae,"I'll assert that getting a `ClassCastException` _at runtime_ is just as dynamic as getting a fatal `TypeError` _at runtime_ in Python or Ruby for `1 + ""hello""`.",0.0,Python
156v4mf,jt36eae,"I'll assert that getting a `ClassCastException` _at runtime_ is just as dynamic as getting a fatal `TypeError` _at runtime_ in Python or Ruby for `1 + ""hello""`.",0.0,Ruby
156v4mf,jt36eae,"Beyond that, I don't know how you'd get _more_ dynamic than `invokedynamic` without just being as untyped as Forth.",0.25,Forth
156v4mf,jt3ie8f,"It sounds like saying C is as dynamic as python because CPython is written in C.  I mean you can make it as ""dynamic"" as those languages but pay the price of complexity.",-0.10416666666666667,C
156szm0,,I've been looking at different langs such as C that use variadic arguments but I find it extremely unsafe and not really that practical.,-0.05625,C
156szm0,jt1fzf5,"Java, Golang, and Python all treat varargs as syntatic sugar for an array/slice/tuple.",0.0,Java
156szm0,jt1fzf5,"Java, Golang, and Python all treat varargs as syntatic sugar for an array/slice/tuple.",0.0,Python
156szm0,jt1csaa,Languages like C# and JS just turn the variadic part into an array.,0.0,C
156szm0,jt1csaa,"In case of C# that happens at compile time, decompiled code will show the construction of an array.",0.0,C
156szm0,jt19jhm,"Object Pascal / Delphi sort of handles this, similar to a list of single dimension array, where you can get the type or number of items.",-0.03571428571428571,Pascal
156szm0,jt19jhm,"Object Pascal / Delphi sort of handles this, similar to a list of single dimension array, where you can get the type or number of items.",-0.03571428571428571,Delphi
156szm0,jt19jhm,"In a C alike syntax it would be:       void printf        ( items[ ] )      {        int Count = count(items);        typeinfo T = typeof(items[0]);        if ( T = string )           ...;      }      ...     printf(""Hello World"", 5, FALSE, NULL );  This approach may require some Run Time Type Information...",-0.4000000000000001,C
156szm0,jt4a4gl,"In C, because the language is severely feature-poor, we have printf (and not a lot else) that uses it for convenient string formatting (and is full of security holes to boot!)",0.4375,C
156szm0,jt4a4gl,"Here's a list of things that people use variadics for:  - Nicer syntax for passing a list as an argument - Implicit builder patterns - Compensating for the lack of first-class tuple types - Compensating for the lack of generics over function types  Rust has something that strongly resembles printf, but in fact it is a macro that abstracts a builder pattern.",0.4333333333333333,Rust
156szm0,jt4a4gl,"I code a lot of Rust, and I have never missed not having variadic functions.",0.0,Rust
156szm0,jt2566x,"The version is C can have arguments of any mixed types, but the types are not specified and the compiler cannot check them when calling such functions.",0.0,C
156szm0,jt2566x,"I've not implemented them myself (other than when implementing C), but I did have a design for variadic parameters that looked like this:      proc F(int a, b, c ...) =  Parameters `a b c` would all have type `int`, but the ellipsis denotes that `c` represents a set of 0 or more variadic parameters, each of type `int`.",0.1875,C
156szm0,jt26s39,"Basically, imagine how Python does it, then apply it to a static subroutine in Assembly.",0.5,Python
156szm0,jt26s39,"Basically, imagine how Python does it, then apply it to a static subroutine in Assembly.",0.5,Assembly
156szm0,jt26s39,"For example, in Python, we demure the beginning of out varargs with `*arg`.",0.0,Python
156szm0,jt26s39,Make sure to add something like `argc` in your Assembly code too.,0.5,Assembly
156szm0,jt1ccd9,"C# requires you to type the array, or use the base `object` type.",-0.8,C
156szm0,jtdhpzn,Rust is a prime example of no-varargs going horribly wrong.,-0.5,Rust
156szm0,jt3ef3q,That's because varargs introduce ambiguity when there's partial application involved as in Haskell.,-0.1,Haskell
156szm0,jt275uu,They only serve as a footgun on C style string formatting.,0.0,C
156szm0,jt3nc5l,As seen in Rust.,0.0,Rust
156szm0,jtdtd1q,Varargs would remove ~80% of macro uses in Rust code in the wild.,0.1,Rust
156szm0,jt2mvwc,"Your options are an untyped language (fair enough), or a typed language with untyped variadics (what C does), or a dependently-typed language (where the type of your variadics would be something like `[(t:Type), t]`).",0.35,C
156szm0,jt5ugih,in C# `new [] { ... }` can become pretty bulky.,0.19318181818181818,C
156szm0,jtdybgc,"80% of Rust macro uses are derive macros, so no, that is simply untrue.",0.0,Rust
156szm0,jtfj6yq,60% of Rust macro uses is `vec!`.,0.0,Rust
156szm0,jtg65l9,"Every single time a Rust type has a `#[derive(...)]` annotation, that's a macro invocation for each type derived.",-0.07142857142857142,Rust
156szm0,jtg65l9,That makes up the vast majority of Rust macro usage.,0.0,Rust
156szm0,jtg65l9,"As for `vec!`, it will intrigue you to know that this macro is in fact merely a first-class citizen among a group of very similar forms of syntactic sugar:  C# 10 has some interesting syntactic sugar that rewrites initializer lists into repeated applications of `ICollection<T>.Add`, and C++ has it's own entire thing of dark magic.",0.1357142857142857,C
156szm0,jtg65l9,"As for `vec!`, it will intrigue you to know that this macro is in fact merely a first-class citizen among a group of very similar forms of syntactic sugar:  C# 10 has some interesting syntactic sugar that rewrites initializer lists into repeated applications of `ICollection<T>.Add`, and C++ has it's own entire thing of dark magic.",0.1357142857142857,C++
156szm0,jtg65l9,"Go has direct syntax, as does D. As far as I can tell, Java does use its vararg feature, sure, but that is far from the norm.",0.19999999999999998,Go
156szm0,jtg65l9,"Go has direct syntax, as does D. As far as I can tell, Java does use its vararg feature, sure, but that is far from the norm.",0.19999999999999998,Java
156szm0,jtg65l9,"So, apart from `println!` and friends which ""use macros to emulate varargs"", and that fact that varargs are really just a poor man's macros, what _other_ Rust macros do you know of that emulate varargs?",-0.10833333333333334,Rust
156szm0,jt3r6xc,It's an experiment in how much static checking one can do in a language that has no explicit types (think classless Python).,0.5,Python
156szm0,jt9l373,"C has had dynamic typing since its inception, and C++ has had statically typed heterogeneous lists since 3.0 in 1991.",0.0,C
156szm0,jt9l373,"C has had dynamic typing since its inception, and C++ has had statically typed heterogeneous lists since 3.0 in 1991.",0.0,C++
156ng13,jt225wp,"The meaning most of us give it today rather corresponds to the concepts introduced with Simula 67 and continued with Smalltalk-76/80, C++ and Java, to name a few.",0.15,C++
156ng13,jt225wp,"The meaning most of us give it today rather corresponds to the concepts introduced with Simula 67 and continued with Smalltalk-76/80, C++ and Java, to name a few.",0.15,Java
156ng13,jtl3xra,This is the paper that eventually led to try/catch and checked exceptions in Java.,0.0,Java
156ng13,jt1hzel,InProceedings of the international conference on APL: part 1 1979 May 30 (p. 340).,0.0,APL
156ng13,jt1hzel,"we have   ""Three different paths in the development of generic-concept languages have been followed by APL, Algol 68, and **object-oriented** languages such as SIMULA 67 and Smalltalk.""",0.0,APL
156ng13,juj4nce,Java.,0.0,Java
156ng13,jujg5ju,Java.,0.0,Java
156ng13,jt6b7zu,"Whitewater were acquired by Borland for their resource editor, which ended up packaged with Borland C++, and Actor was left to wither.",0.0,C++
156ng13,jto1lx2,Iirc I ended up using VB for the first (and last) time for a few days some time around 2000 because Delphi was playing up.,0.016666666666666663,Delphi
156ng13,jto1lx2,I went back to Delphi.,0.0,Delphi
156ng13,jto1lx2,"> were acquired by Borland for their resource editor, which ended up packaged with Borland C++  (and Delphi, I presume, not to rub it in about VB... 😁)  > Actor was left to wither.",0.0,C++
156ng13,jto1lx2,"> were acquired by Borland for their resource editor, which ended up packaged with Borland C++  (and Delphi, I presume, not to rub it in about VB... 😁)  > Actor was left to wither.",0.0,Delphi
156ng13,jto1lx2,Was it similar to how Erlang doesn't really follow the model or was it worse than that?,-0.06666666666666667,Erlang
156ng13,jtpa8x5,"Interestingly, Self pioneered the kind of JIT techniques now used by Java and JavaScript VMs, so we're all benefitting from the pioneers of early OOP still.",0.4000000000000001,Java
156ng13,jtpa8x5,"Interestingly, Self pioneered the kind of JIT techniques now used by Java and JavaScript VMs, so we're all benefitting from the pioneers of early OOP still.",0.4000000000000001,JavaScript
156ng13,jtpa8x5,"Just as Smalltalk bears little relation to later OO languages, Self bears little relation of prototype-based programming as it manifests in JavaScript.",-0.125,JavaScript
156joln,jszx631,"Dennis M. Ritchie rewrote McIlroy's roff in PDP-11 assembly for Version 1 AT&T UNIX, Joseph F. Ossanna improved roff and renamed it nroff for Version 2 AT&T UNIX, then ported nroff to C as troff, which Brian W. Kernighan released with Version 7 AT&T UNIX.",0.0,C
156joln,jszx631,"In 1989, James Clark re-implemented troff in C++, naming it groff.",0.0,C++
156ggyr,,"If lifetime is not ended manually, lifetime is automatically ended at the end of function as in all C style languages.",0.0,C
156ggyr,jt0uck1,"Clojure has a similar feature called *transducers*, though they're just a slight simplification on *foldl*.",-0.08333333333333333,Clojure
156ggyr,jt361xo,"In Julia, even easier, just prefix function with a '.",0.0,Julia
156ggyr,jt070od,Python comprehension lists follow a specific syntax.,0.0,Python
156bfwc,jsze94h,Look at the crap of C++ we are in we all understand that.,-0.8,C++
15661oq,jsysf6g,Try looking into a language called APL.,0.0,APL
15661oq,jsyu1or,"APL works on matrices, my language is programmed WITH matrices.",0.0,APL
155t03q,jsw56s2,"Python only got pattern matching in [3.10](https://peps.python.org/pep-0636/), which eases writing, but it would appear that due to the lack of static typing, there's no compile-time exhaustiveness checking.",0.125,Python
155t03q,jszslgj,"I am developing [Cwerg](http://cwerg.org), a new C-like language, primarily in Python.",0.2681818181818182,Python
155t03q,jszslgj,"The idea is to proto-type it in Python and once the design is stable to re-implement it in another more performant language, e.g.",0.5,Python
155t03q,jszslgj,C++.,0.0,C++
155t03q,jszslgj,I am actively working on the frontend in Python.,-0.13333333333333333,Python
155t03q,jszslgj,"It is disappointing, though, that there is still no good performance story for Python even if you have no deps to speak of and do not use a lot of the dynamic features of the language * using type annotations is key both for correctness and the IDE support it enables * having two implementations is super valuable, it make them both more deterministic * I cannot imagine developing Cwerg in any other way.",-0.034523809523809526,Python
155t03q,jszslgj,The iteration time with Python is just unparalleled.,0.0,Python
155t03q,jszslgj,C++ by comparison is painfully slow.,-0.30000000000000004,C++
155t03q,jszslgj,"* I firmly believe, that it would have been slower to develop the compiler in C++ only.",-0.1,C++
155t03q,jsybj7w,"Because you're better off with Haskell, a ML, or a Lisp.",0.5,Haskell
155t03q,jsybj7w,"Because you're better off with Haskell, a ML, or a Lisp.",0.5,Lisp
155t03q,jsz9v4b,Even C's type system is better than nothing.,0.5,C
155t03q,jsxg4am,Because Haskell and similar are pretty much strictly and fairly objectively better for compiler dev.,0.2375,Haskell
155t03q,jsxhitb,"I'm writing my bootstrap compiler in C++, but all of my code generation tools so far are written in python.",0.1,C++
155t03q,jsx3wm4,I did generate Assembly with Python.,0.0,Assembly
155t03q,jsx3wm4,I did generate Assembly with Python.,0.0,Python
155t03q,jsym6x3,Ruby is better for this kind of stuff anyway.,0.55,Ruby
155t03q,jsz18om,"It's funny, y'know, because I could write a compiler much quicker in Python, and it would certainly be less error-prone, than if I wrote it in say, C++.",0.09444444444444444,Python
155t03q,jsz18om,"It's funny, y'know, because I could write a compiler much quicker in Python, and it would certainly be less error-prone, than if I wrote it in say, C++.",0.09444444444444444,C++
155t03q,jsz18om,"Maybe I should prototype mine in Python and reïmplement it in C++ when mature...  Also, all the people lamenting Python's pattern-matching, I think this is only half the puzzle.",-0.022222222222222216,Python
155t03q,jsz18om,"Maybe I should prototype mine in Python and reïmplement it in C++ when mature...  Also, all the people lamenting Python's pattern-matching, I think this is only half the puzzle.",-0.022222222222222216,C++
155t03q,jsz18om,"A large part of compiler development is text processing, which Python is quite intuitive for...",0.21428571428571427,Python
155t03q,jsvwaoc,"I'll go ahead and answer my own question and say that it's probably because a lot of people prefer static typing, but then nobody makes compilers in Java either.",0.55,Java
155t03q,jsxtdw8,"It doesn't use a compiler    is an interpreted language, which means the source code of a Python program is converted into bytecode that is then executed by the Python virtual machine",0.0,Python
155t03q,jsyx63z,"Speaking as someone whose last few compiler projects were written in Python :P  For a one person project on a toy language it's fine, but I think for more complex compilers with multiple contributors Python doesn't scale as well as other languages do.",0.13020833333333334,Python
155t03q,jsyx63z,"Python is easy to write but also easy to make mistakes/introduce bugs that can be tricky to debug in a complex piece of software like a compiler, mitigating those risks requires extra work that you wouldn't need to do in other languages, so unless you have a specific reason to make your compiler in Python usually other languages are better.",0.10208333333333333,Python
155t03q,jsz2g9o,"Mainly, because it seems 95% of programming-language hobbyists are also inveterate Haskell or ML fans.",0.16666666666666666,Haskell
155t03q,jsz2g9o,"Sure you can do compilers with pattern-matching, but then you can also write a C compiler in C, or a Pascal compiler in Pascal.",0.5,C
155t03q,jsz2g9o,"Sure you can do compilers with pattern-matching, but then you can also write a C compiler in C, or a Pascal compiler in Pascal.",0.5,Pascal
155t03q,jsz2g9o,If that's Python (as it is for me) then go right ahead and build your bootstrap therein.,0.2857142857142857,Python
155t03q,jsz2g9o,Here's why: Nothing stops big companies from doing big software engineering on Python.,0.0,Python
155t03q,jt9dizp,"I started writing mine in Python, in the end I'll probably switch to like Rust but I find it easier to prototype in Python ([link to my compiler so far](https://github.com/SamG101-Developer/SPP-Compiler-2/tree/master/src)).",0.0,Python
155t03q,jt9dizp,"I started writing mine in Python, in the end I'll probably switch to like Rust but I find it easier to prototype in Python ([link to my compiler so far](https://github.com/SamG101-Developer/SPP-Compiler-2/tree/master/src)).",0.0,Rust
155t03q,jsz10v8,Python is _not_ a crappy language,0.0,Python
155t03q,jsxscnu,Including Python.,0.0,Python
155t03q,jsyiqqe,Haskell?,0.0,Haskell
155t03q,jt5n38k,Oils is using both ASDL and pgen2 with C++ back ends as well.,0.0,C++
155t03q,jt5n38k,"It's been all over the blog, not particularly organized, but I may write up an architecture description later:  https://www.oilshell.org/blog/2022/03/middle-out.html  https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL  I've indeed found it  useful to borrow metalanguages from Python itself.",0.07222222222222223,Python
155t03q,jt5n38k,"Oils is made faster via a translator from statically typed Python to C++ called ""mycpp"".",0.0,Python
155t03q,jt5n38k,"Oils is made faster via a translator from statically typed Python to C++ called ""mycpp"".",0.0,C++
155t03q,jt5n38k,It would basically be like if:  - shell was a good language - the C preprocessor and shell were the SAME language (they are kinda  similar if you squint?),0.2333333333333333,C
155t03q,jswbcd3,Java is too verbose.,0.0,Java
155t03q,jswbcd3,People typically choose Java only if they want to write a language that targets JVM.,-0.08333333333333333,Java
155t03q,jswbfjf,"People absolutely do use Java, many resources like Crafting Interpreters and Modern Compiler Implementation use Java, it was the choice in the course I took and doesn't seem to be uncommon in general.",0.35,Java
155t03q,jswbfjf,"Also [Vinegar](https://github.com/catseye/Vinegar) is an example of a proof-of-concept implementation in Python, and [Thun](https://joypy.osdn.io/) is a Joy interpreter written in Python.",0.8,Python
155t03q,jsz9nfx,"Python's niche is, apparently, gluing together useful code that is *not* written in Python.",0.175,Python
155t03q,jsyvgp3,"OCaml is another good option, it has nice FP features but is a bit more flexible than Haskell.",0.6,Haskell
155t03q,jsyvgp3,"The initial compiler for Rust was written in OCaml, before it was self-hosted.",0.0,Rust
155t03q,jsyydwr,Scala is very cool too.,0.45499999999999996,Scala
155t03q,jsxi4iv,"> Python has a de-facto standard testing framework, pytest that makes it very simple, and it has a first party stdlib solution unittests, although that is considered too verbose today.",0.08333333333333333,Python
155t03q,jswl9uv,You can write Java without it being verbose so long as you throw out getters/setters and just use public fields.,-0.025,Java
155t03q,jswjask,Wondering whether it \*is\* possible to target JVM \*without\* wring a compiler in Java?,0.0,Java
155t03q,jsx8qxf,One step closer to Kotlin.,0.0,Kotlin
155t03q,jsyvlpx,"Relevant to both this thread and your comment, [compiler written in Python targeting JVM](https://yangdanny97.github.io/blog/2021/08/26/chocopy-jvm-backend)",0.4,Python
155t03q,jsx1hxb,"Yeah, the Scala compiler is written in Scala and the Kotlin compiler is mostly Kotlin",0.5,Scala
155t03q,jsx1hxb,"Yeah, the Scala compiler is written in Scala and the Kotlin compiler is mostly Kotlin",0.5,Kotlin
155t03q,jt83vp9,"So instead I chose to do what Python does, requring everything to be defined by the time of first usage.",0.25,Python
155t03q,jt83vp9,"Probably, rtime code will also be able to interact with ctime constructs through a specific interface, similar to how Python allows C extension libraries.",0.16666666666666666,Python
155t03q,jt83vp9,"Probably, rtime code will also be able to interact with ctime constructs through a specific interface, similar to how Python allows C extension libraries.",0.16666666666666666,C
155t03q,jt83vp9,"I've actually considered just making a Python library to simplify writing programs as compilation scripts, but have decided against it.",0.0,Python
155t03q,jt83vp9,"While both Lua and Python are self-implemented (if observed from within the language), the runtime language on top of them would have to be integrated into the same mechanism in order to be sufficiently uniform, and that would make it poorly suited for performance-sensitive runtime evaluation",0.033333333333333326,Lua
155t03q,jt83vp9,"While both Lua and Python are self-implemented (if observed from within the language), the runtime language on top of them would have to be integrated into the same mechanism in order to be sufficiently uniform, and that would make it poorly suited for performance-sensitive runtime evaluation",0.033333333333333326,Python
155t03q,jt9m28p,Though I'd also say Julia's metaprogramming and compilation model could be related.,0.0,Julia
155rqm1,jsy9497,"Minor tip i got from the (very readable but informal) Go specification is, if your language is syntactically heterogeneous, to pick apart grammar productions in bundles that make semantic sense, and for each syntactical term, give a semantical meaning.",0.07500000000000001,Go
155rqm1,jswcy3a,You iterated all the way from C to S and transpilong to C++?,0.0,C
155rqm1,jswcy3a,You iterated all the way from C to S and transpilong to C++?,0.0,C++
155rqm1,jswcy3a,"I am not sure why do you have so much similarity to C++ in your STL, are you transpiling to C++?",-0.024999999999999994,C++
155rqm1,jszukxw,"honestly reddit is great for specific articles on bits of language design, also finding blogs of other language designers like Graydon's who's put a couple stuff out there about Rust etc.",0.31875,Rust
155rqm1,jsvukq4,"It allows splitting inheritance per base class, like Rust's splitting impls on a struct per trait.",-0.8,Rust
155rqm1,jsxkbws,I'd probably go with always mandating `{}` like Rust does.,0.0,Rust
155cisi,jsty31j,After way to many `NullPointerException`s in Java in the past.,0.125,Java
155cisi,jsty31j,[enum `Option`](https://doc.rust-lang.org/std/option/) in Rust.,0.0,Rust
155cisi,jsty31j,"For instance in [Kotlin](https://kotlinlang.org/docs/null-safety.html#nullable-types-and-non-null-types), if we have a `val s: String`, then `s` is guaranteed to be a `String`.",0.0,Kotlin
155cisi,jsty31j,"TypeScript has [union types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types), which allow a type to be specified like, e.g.",0.0,TypeScript
155cisi,jsty31j,"function f(x: number | string | null) {         if (typeof x === ""number"") {             console.log(""x is a number"");         } else if (typeof x === ""string"") {             console.log(""x is a string"");         } else {             console.log(""x is null"");         }     }          f(123);     f(""Hello World"");     f(null);  Something similar is possible in Kotlin using [sealed classes](https://kotlinlang.org/docs/sealed-classes.html) and the [`is` operator](https://kotlinlang.org/docs/typecasts.html#is-and-is-operators).",0.0,Kotlin
155cisi,jsty31j,"Here's a tiny AST example:      sealed class Expr      class Const(val num: Int) : Expr()     class Add(val lhs: Expr, val rhs: Expr) : Expr()     class Sub(val lhs: Expr, val rhs: Expr) : Expr()      fun eval(expr: Expr): Int =         when (expr) {             is Const -> expr.num             is Add -> eval(expr.lhs) + eval(expr.rhs)             is Sub -> eval(expr.lhs) - eval(expr.rhs)         }       fun main() {         println(eval(Const(1)))         println(eval(Add(Const(1), Sub(Const(4), Const(2)))))     }  Given that `expr` is a `sealed class`, then Kotlin enforces that all classes derived from `Expr` is matched in the [`when` expression](https://kotlinlang.org/docs/control-flow.html#when-expression).",0.19166666666666665,Kotlin
155cisi,jstwdge,"In Kotlin, nullable references form a separate type hierarchy (X?).",0.0,Kotlin
155cisi,jstwdge,There were also C dialects with non-nullable pointer types.,0.0,C
155cisi,jsu04qy,You can study how Dart or Swift implemented their null-safe types.,0.0,Dart
155cisi,jsu04qy,You can study how Dart or Swift implemented their null-safe types.,0.0,Swift
155cisi,jsunmvn,"This largely corresponds with how it is done in C, although C doesn't have a dedicated `NULL` literal, it uses `0` (sometimes, `NULL` is defined as `(void*)0`).",0.21428571428571427,C
155cisi,jsunmvn,"I can use `nil` in dynamic code like this:      f := fopen(""file"",""r"")     # call C function via FFI     if f = nil then            # could not open file  If a language does not support the concept of `nil` or `NULL`, and you want to call functions via FFIs like my example, then you will a workaround.",0.0,C
155cisi,jsu5nnv,"For example, a byte with null example would support the values of:       0 ... 255 , NULL  The concept of ""null"" did exist before on Lisp, but used ""nil"" instead.",0.0,Lisp
155cisi,jsu5nnv,"Before Java retake Lisp usage of null, null was used as the empty value of pointers.",-0.1,Java
155cisi,jsu5nnv,"Before Java retake Lisp usage of null, null was used as the empty value of pointers.",-0.1,Lisp
155cisi,jsv1mzp,"After all, there's literal-list syntax for both terms and types in Haskell.",0.0,Haskell
155cisi,jsy60o6,For languages in the C lineage (e.g.,0.0,C
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,C
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,C++
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,Java
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,C
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,C++
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,Java
155cisi,jsy60o6,"For languages in the Lisp lineage (dynamically typed, e.g.",0.0,Lisp
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,Lisp
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,Python
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,Ruby
155cisi,jsy60o6,"SML, Rust, Haskell), there typically isn't really a notion of NULL, there are only [sum types](https://en.wikipedia.org/wiki/Tagged_union), which represent things that can be one of several possible values.",0.05,Rust
155cisi,jsy60o6,"SML, Rust, Haskell), there typically isn't really a notion of NULL, there are only [sum types](https://en.wikipedia.org/wiki/Tagged_union), which represent things that can be one of several possible values.",0.05,Haskell
155cisi,jsur9sh,"In Kotlin, is flow typing used to narrow a `String?` to a `String` after a null check?",-0.2,Kotlin
155cisi,jsu2kta,Kotlin uses null to represent optionals.,0.0,Kotlin
155cisi,jstydrx,"At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W).",0.25,ALGOL
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,C
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,Java
155cisi,jsutsgq,"> C doesn't have a dedicated NULL literal, it uses 0 (sometimes, NULL is defined as (void*)0).",0.0,C
155cisi,jsusbzs,"In Rust for example, it's defined in the standard library (not in the compiler itself), any user could've defined it.",0.0,Rust
155cisi,jsuf6xv,"Which is something that can come up, when iterating, mapping, filtering, and flattening [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html)s and [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html)s in Rust at least.",-0.3,Rust
155cisi,jsuuh3m,"Yes, Kotlin features a limited form of flow-sensitive typing and calls it [smart casts](https://kotlinlang.org/spec/type-inference.html#smart-casts).",0.07142857142857142,Kotlin
155cisi,jsvz3lq,"In case of Kotlin, decision to have special case type hierarchy for nullable types (and not having union types in the language, although this question was raised regularly in scope of Kotlin/JS and interoperability with TypeScript) was primarily a type inference performance concern.",0.2523809523809524,Kotlin
155cisi,jsvz3lq,"In case of Kotlin, decision to have special case type hierarchy for nullable types (and not having union types in the language, although this question was raised regularly in scope of Kotlin/JS and interoperability with TypeScript) was primarily a type inference performance concern.",0.2523809523809524,TypeScript
155cisi,jsv6plv,Kotlin uses [nullable types](https://en.wikipedia.org/wiki/Nullable_type) which are more like [union types](https://en.wikipedia.org/wiki/Union_type) than [option types](https://en.wikipedia.org/wiki/Option_type).,0.5,Kotlin
155cisi,jsv6plv,Nullable types are more convenient to work with in many cases and are more familiar to imperative programmers coming from languages like Java with `null`.,0.46875,Java
155cisi,jsuahmn,syntax in Kotlin.,0.0,Kotlin
155cisi,jsuyxll,The mistake was to make nulls implicit like in C or Java.,0.0,C
155cisi,jsuyxll,The mistake was to make nulls implicit like in C or Java.,0.0,Java
155cisi,jsuxxdd,"(The code also looked suspiciously like C++, unless C23 also has `auto`, and the name of the file it tries to compile is `main.cpp`.)",-0.1,C++
155cisi,jsuv9df,Kotlin: https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiJmdW4gbGVuKHM6IFN0cmluZz8pOiBJbnQge1xuICAgIHJldHVybiBzLmxlbmd0aFxufSJ9  TypeScript: [https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA](https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA),-0.75,Kotlin
155cisi,jsuv9df,Kotlin: https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiJmdW4gbGVuKHM6IFN0cmluZz8pOiBJbnQge1xuICAgIHJldHVybiBzLmxlbmd0aFxufSJ9  TypeScript: [https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA](https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA),-0.75,TypeScript
155cisi,jsvcb6k,> Kotlin uses nullable types which are more like union types than option types.,0.5,Kotlin
155cisi,jsudtqj,syntax in Kotlin.,0.0,Kotlin
155cisi,jsudtqj,Similar sugar exists in Rust and possibly other languages as well.,-0.0625,Rust
155cisi,jsudtqj,In Kotlin you can define methods on null types.,0.0,Kotlin
155cisi,jsu91sy,"Regarding your first point: I'm not sure how this is done in Rust but in other languages I know, None is a valid assignment for Option<T> for all T. In Kotlin, an optional type would be T?",-0.041666666666666664,Rust
155cisi,jsu91sy,"Regarding your first point: I'm not sure how this is done in Rust but in other languages I know, None is a valid assignment for Option<T> for all T. In Kotlin, an optional type would be T?",-0.041666666666666664,Kotlin
155cisi,jsu91sy,and similarly null is valid for any T. In Scala None is Option[Nothing] with Nothing being the subtype of every type.,0.0,Scala
155cisi,jsu91sy,"Regarding the second point, the same can also be done with null, again, like in Kotlin.",0.0,Kotlin
155cisi,jsuwgps,"At least in the context of Kotlin (believe me, I have no particular feelings for the language other than that I find it interesting) this is not correct.",-0.002083333333333326,Kotlin
155cisi,jsuwgps,In Kotlin you cannot use a value of type T?,0.0,Kotlin
155cisi,jsuwgps,You can (again Kotlin) assign null to a variable of an optional type the same as you can assign None to any variable of type Option<T>.,0.0,Kotlin
155cisi,jsuwgps,"And well in, say Java, you would have to consider every non-primitive type optional.",0.0,Java
155cisi,jsuwgps,But Java just does not have any advanced features when it comes to null.,0.4,Java
155cisi,jsuwgps,Basically      // Kotlin     let a: A?,0.0,Kotlin
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,Rust
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,Java
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,Kotlin
155cisi,jsuwgps,= ...     a = b     // Rust     let a: Option<A> = ...     let b: Option<B> = ...     a = b     // Java     A a = ...     B b = ...     a = b  But this is hardly interesting.,0.5,Rust
155cisi,jsuwgps,= ...     a = b     // Rust     let a: Option<A> = ...     let b: Option<B> = ...     a = b     // Java     A a = ...     B b = ...     a = b  But this is hardly interesting.,0.5,Java
155cisi,jsuskdq,I dislike Rust's use of 'try_thing' being the call that returns the Result.,0.0,Rust
155cisi,jsycs7a,JavaScript has this and I gotta say my personal opinion is that having two different nulls is even worse than having null,-0.13333333333333333,JavaScript
155cisi,jsue3dl,How do you do this in Kotlin?,0.0,Kotlin
155cisi,jsue3dl,Rust doesn't any additional syntax for Option.,0.0,Rust
155cisi,jsue3dl,As seen in Kotlin's special syntax for nullable types.,0.35714285714285715,Kotlin
155cisi,jsuvn1j,"Somewhat related, in Rust I've long wanted a crate-level attribute to disallow potential panics, i.e.",-0.016666666666666666,Rust
155cisi,jsv0nxd,"The same programmers wouldve been getting nulls and other UB in C++ though, so in a way, things are a bit better.",0.125,C++
154sacf,jsqofsf,The C++ generic algorithms library has both std::for_each (which just visits each element) and std::accumulate (which acts similarly to a fold).,0.0,C++
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,JavaScript
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,C++
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,Rust
154sacf,jsrshrg,"Also if you're looking for a very general functional looping construct, you may want to implement something like Scheme's [named let](https://weinman.cs.grinnell.edu/courses/CSC151/2014F/readings/named-let-reading.html).",0.06500000000000003,Scheme
154sacf,jss14mo,"This is typically called `map` (in Haskell, this is specifically called `fmap`).",-0.16666666666666666,Haskell
154sacf,jss14mo,"This is typically called `reduce`, `fold` (in Haskell, this is specifically called `foldl` which has a closely related sister function called `foldr`), `accumulate`, etc.",-0.08333333333333333,Haskell
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,JavaScript
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,Rust
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,Python
154sacf,jstrbxr,`reduce` comes from APL and it is so named because it uses a function to *reduce* the dimension of the data being processed.,0.0,APL
154sacf,jssghrg,This is why I’m in favor of how Ruby supports multiple names for the same method.,0.0,Ruby
154sacf,jsql3dp,To me it sounds like a `mapM_` (in Haskell terminology).,0.0,Haskell
154qygu,jsqtuup,"Many prebuilt types like ""i32"" or prebuilt functions like the ""main"" function in C, or the ""and"", ""or"" operators in SQL are examples of ""predefined idents"".",0.3333333333333333,C
154apa1,jsp4r7q,"However while the two following sentences are true, they do not give a clear view of the domain:   - Go is meant to write servers (any program can be transformed in a server)  - C is meant to write programs (literally what a _programming_ language is meant to do)",0.15,Go
154apa1,jsp4r7q,"However while the two following sentences are true, they do not give a clear view of the domain:   - Go is meant to write servers (any program can be transformed in a server)  - C is meant to write programs (literally what a _programming_ language is meant to do)",0.15,C
154apa1,jsnyz2b,"Sometimes they are created using intricate Assembly libraries, as some pthreads implementations which have no access to clone\* system calls do.",0.0,Assembly
154apa1,jsnyz2b,"Even if that host is the microprogram of the CPU, for example, when you compile C code with -ffreestanding, the host still exists, it's the microprogram.",0.0,C
154apa1,jsntsyp,"Bash can't generate random numbers natively, but some program with that ability is expected.",-0.3,Bash
154apa1,jsntixq,Sy many languages have semantic constraints on what structures you can create (see doubly linked lists in safe Rust).,0.3333333333333333,Rust
1548d01,jspltil,"It would take me a bit of time to dust off my C skills and take a closer look at your code, but I might get to it at some point.",0.0,C
1548d01,jspy5vl,Always glad to see something written in C in these days.,0.5,C
153zpve,jspkhkp,Just look at lambdas in C++: they compile to an instance of an anonymous struct with fields for all captured values and an overloaded call operator.,0.0,C++
153h7x0,jsjg0u9,"Python PL makes it sweet to write in, but hellish to even write a generator for.",0.35,Python
153h7x0,jsodlh5,I'm using Python for my host and some day I would like to generate native code after I get all the semantic kinks ironed out.,0.0,Python
153h7x0,jslmlys,"Ah, the reason I chose to implement this in Python was because the Chocopy is a subset of Python.",0.0,Python
153h7x0,jslmlys,"Therefore I didn't need to write a parser at all, I just parsed it into the Python AST using the built-in `ast` module and converted that into my own AST.",0.6,Python
153h7x0,jslmlys,When people take the class at Berkeley they use Jflex for the parser since the skeleton code for their assignments is in Java.,0.0,Java
153h7x0,jskozjj,Do you mean you think Python is a bad language to use for implementing another language?,-0.5062499999999999,Python
153h7x0,jskufyt,"I'm not sure how much of a CFG Python grammar is, but it seems very hard to parse by hand at least.",-0.18229166666666669,Python
153h7x0,jskufyt,It was in Go but I implemented it in C and it worked just fine.,0.4166666666666667,Go
153h7x0,jskufyt,It was in Go but I implemented it in C and it worked just fine.,0.4166666666666667,C
153h7x0,jsm1xca,I think writing a subset of Python is not going to be that hard.,-0.2916666666666667,Python
153bfuu,jsj33j7,Similar to Eiffel?,0.0,Eiffel
153bfuu,jsj5266,"However, Eiffel checks preconditions/postconditions at runtime, raising an exception if they’re not met.",0.0,Eiffel
153bfuu,jsky0fk,"(As an outsider my impression is that this happens in all these systems, for example Dafny, Why3 and Liquid Haskell, because automated solvers do not scale in many cases, and they become increasingly slow and brittle before they stop working completely.",0.09999999999999998,Haskell
15369z8,jsjdnt9,"I would look into [SPARK](https://docs.adacore.com/spark2014-docs/html/lrm/), which is a subset of the Ada language that supports formal verification of programs using an automated theorem prover.",0.0,Ada
15369z8,jsjdnt9,"Both Ada and SPARK have facilities for safety critical programs, especially real-time embedded systems.",0.0,Ada
15369z8,jsia2v4,"Check out Dafny, F*, TLA+, and check out how the seL4 OS was verified, even though it’s written in C: https://www.cs.columbia.edu/~junfeng/09fa-e6998/papers/sel4.pdf.",0.0,C
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,C
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,Go
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,Rust
15369z8,jsj0bou,"As a practical example, where most C code will accept an index in an array as `size_t` which may fail at runtime (or worse: trigger a buffer overrun), the most correct type, whose use can never fail, is `Index (xs: List a) = { i ∈ ℕ₀ | i < |xs| }` (where `ℕ₀` includes 0).",0.06999999999999999,C
15369z8,jsi1owa,"Have you checked ADA, Rust & Zig?",0.0,Rust
15369z8,jslgj51,You'd probably want to allow programmers to manually assert the complexity of a function where the compiler is unable to deduce it (similar to Rust's `unsafe`).,-0.25,Rust
15369z8,jsils9p,"You can check for example:  https://www.scattered-thoughts.net/writing/how-safe-is-zig/ https://andrewkelley.me/post/unsafe-zig-safer-than-unsafe-rust.html  I think Rust is the best of the 3, but each one teaches good lessons.",0.85,Rust
15369z8,jsils9p,"I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  ```pascal var    Day : Set of 1..31;    Month : Set of 1..12;  ```  and that certainly is very useful to make safe APIs!",0.3608928571428571,Delphi
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,Ada
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,Rust
15369z8,jslyqx8,"> I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  It's fairly incomplete, unfortunately:   1.",0.15714285714285714,Delphi
15369z8,jslyqx8,"In my Rust code, instead, I have library code to create a generic strong type facility with arbitrary invariant validation:      struct Tagged<T, D>(T, PhantomData<fn(D)->D>);      impl<T, D> Tagged<T, D> {         pub fn new(value: T) -> Result<T, D::Error>         where             D: ValidateInvariant<T>,         {             D::validate(&value)?",0.11111111111111109,Rust
15369z8,jslyqx8,"In my Rust code, instead, I have library code to create a generic strong type facility with arbitrary invariant validation:      struct Tagged<T, D>(T, PhantomData<fn(D)->D>);      impl<T, D> Tagged<T, D> {         pub fn new(value: T) -> Result<T, D::Error>         where             D: ValidateInvariant<T>,         {             D::validate(&value)?",0.11111111111111109,D
15369z8,jsirk34,I believe this is already present in Rust with `Range` and `RangeInclusive`.,0.0,Rust
15369z8,jsirk34,You can write something like: ```rust let range = 1..31; // range.start() = 1 // range.end() = 31 ``` I'm not sure how different are the ranges you mentioned from Rust's.,-0.125,Rust
152hv8q,jsg4mxc,"Well, there are dynamically typed functional languages, like Lisp.",0.0,Lisp
152hv8q,jsgciv9,Like APL.,0.0,APL
152hv8q,jsgk55e,"Wow, APL is a great beast, I tried few times to learn it.",0.2333333333333333,APL
152hv8q,jsgpg2o,"APL programmers used to send each other one-liners and ask, ""OK, what does this do?""",0.1875,APL
152hv8q,jsgpg2o,APL is probably one of the most difficult languages to learn.,0.0,APL
152hv8q,jstxycf,"But I had an inherent interest in APL's design, so...",0.0,APL
1529hgn,jscsecw,"> if a developer has any idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects  Java’s `URL.equals()` would like a word.",0.16,Java
1529hgn,jsczxqu,"It would be so nice to enforce that some C++ callback can’t allocate memory on the heap, take a lock, yield, etc.",0.6,C++
1529hgn,jsczxqu,"I’m not sure if it’s enough to persuade people to use some language over C++, but that doesn’t mean the feature lacks value.",-0.1875,C++
1529hgn,jsd204y,Maybe it's also similar to type checking in the sense that people didn't like static types because most people were familiar with Java or C++ style types which were really limited back then.,0.21726190476190477,Java
1529hgn,jsd204y,Maybe it's also similar to type checking in the sense that people didn't like static types because most people were familiar with Java or C++ style types which were really limited back then.,0.21726190476190477,C++
1529hgn,jsd0kx7,"But it's ok, security vulnerabilities are not on every programmers' minds (let's ignore those flashbacks featuring my PHP teacher), so surely there are no other cases of such hippy concepts getting in the way of profit, such as _security_, _correctness_, _data races_, _the VM crashing at runtime because user code tried to log by writing onto nothing_, or the entire idea of ""accessing an object"" through a reference which may be NULL - which Hoare himself calls his Billion Dollar Mistake - which can neither be modelled as an effect nor have any economical cost.",0.19464285714285715,PHP
1529hgn,jsd4d0y,"Think Scala, think Common Lisp quotes.",-0.3,Scala
1529hgn,jsd4d0y,"Think Scala, think Common Lisp quotes.",-0.3,Lisp
1529hgn,jsd015f,"Moreover, the value that it returns is totally immutable, like all values in Haskell.",0.0,Haskell
1529hgn,jsd98n6,"OO languages already have something for this: It's called dependency injection, and the truck-sized hole in DI for Java is the global package scope.",0.0,Java
1529hgn,jsdmf1a,I'm kinda persuaded by the bold argument that if a language feature has any merit at all Java would have stolen it by now.,0.3333333333333333,Java
1529hgn,jsdfdz1,"I notice that Java in characteristic fashion solved the problem by adding a second sort of `switch` statement which also isn't very good, but at least it doesn't have fallthrough.",0.1358333333333333,Java
1529hgn,jsd443x,"In Haskell, the IO monad isn't actually an 'effect' it is just a description of an effectful computation in a state-monadic/continuation-passing form.",0.0,Haskell
1529hgn,jsd3b5b,Optimizing C compilers have been moving code around for years which can make code harder to debug.,-0.1,C
1529hgn,jsgznmn,"I think the JavaScript implementation of async/await is a bit confusing for asynchronous error handling, like how `.catch` is used on Promise directly but `try/catch` otherwise.",-0.09999999999999999,JavaScript
1529hgn,jsgznmn,I think it has value in JavaScript.,0.0,JavaScript
1529hgn,jsf6vh9,Python's @contextmanager decorator needs a generator function that suspends once,0.0,Python
1529hgn,jsg7tx1,"The language I'm slowly working on in my free time is porting an Effect System to Assembly and binary code, where `mov [rax], rdi` has type `{ in rdi: a, rax: mem a; writes rax }`.",0.04999999999999999,Assembly
1529hgn,jsdes2m,I mainly want to forbid cases like this (using Rust in this example):      println!,0.20833333333333331,Rust
1529hgn,jsdes2m,"For panics, I meant something like panics in Rust that are basically implemented as a `throw` with `catch_unwind` being a `try/catch`.",0.0,Rust
1529hgn,jsktpww,I think that's how C# does it but not completely sure.,-0.25,C
1529hgn,jswrpx1,"Checked exceptions (as implemented in Java) can't be used alongside polymorphism; either a polymorphic function throws no exceptions, rendering it incorrect, or it throws any exception, despite the fact that when used it will only throw a subset.",0.0,Java
1529hgn,jswrpx1,"This can be solved via effect polymorphism, but Java lacks that feature.",0.0,Java
1524b7f,jscffe1,Some of the recent work I'm aware of (but this is outside my core area) is Max Bolingbroke's [Cambridge Haskell Supercompiler](https://github.com/batterseapower/chsc).,0.08333333333333333,Haskell
1520pt9,jsem8fm,I think that was clearest when they presented this Python program:      def g(x):         return         x - 10  And then cited students struggling to predict the exact error as an example of their evidence that they struggled with a transition from functional to imperative programming.,0.25,Python
1520pt9,jsem8fm,"Or even more surprisingly, a lot of concern with whether students understand that a function that doesn't explicitly return a value in Python will actually return a `None` that can be assigned to a variable.",0.39999999999999997,Python
1520pt9,jsnhneb,The style of Lisp is much better at teaching imo.,0.5,Lisp
151nyde,,I call it 'Creole C'.,0.0,C
151nyde,,Or maybe 'Pidgin C'.,0.0,C
151nyde,jscwwpj,"Well with this in mind, I assumed creole C to be just some sort of C with fancy extentions.",0.0,C
151j3gf,jsa7gy9,"The Future of C ...""  C != C++",0.0,C
151j3gf,jsa7gy9,"The Future of C ...""  C != C++",0.0,C++
1516vdp,js8h8rc,This is sort of what C does.,0.0,C
1514w59,js6vhrt,"- context free grammars: good - compiler switches: bad - compiler warnings: bad - follow C ABI: good - built-in doc generator: good - built-in test framework: good - manual memory management: will require more programmer time - multiple pointer types: bad - portability should be easy - builtin UTF-8: good - too many choices: bad - special debug and assert functionality: good - pointless flexibility like both `l` and `L` for large integer literals: bad - user extensibility (operator overloading, custom literals, implicit conversions) relieves pressure on the language - greppable syntax (e. g. for finding casts) - redundancy in syntax: semicolons good - underscores in number literals: good - composability: good - macros: bad, don't work",0.18498964803312637,C
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,C
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,C++
1514w59,jsahs8w,"Well, I ended up going back to C, because of several otherwise reasonable limitations of Zig.",0.06666666666666667,C
1514w59,js7ho5j,"C macros, certainly horrible (if you don't use them correctly + easy make parenthesis mistakes especially when you are starting out (nowadays I only do that when I am running on caffeine at 3AM) or redefine syntax).",-0.11333333333333333,C
1514w59,js710du,abused  Example of a good macro in C:      #define CAST     CAST(float)(a)/b;  `CAST` is defined an empty string.,0.3,C
1514w59,js7s7yl,"I often use C macros for stuff like `#define FOO(str) assert(foo_api(context, state, str, strlen(str)) != -1)` (passing lots of common arguments, doing validation of the return, etc.",-0.3,C
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,Java
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,Python
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,Ruby
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,C
1514w59,jsc9a36,"On the other hand, Rust's doc generator is great.",0.3375,Rust
1514w59,jsa7yqs,I did watch it and I think he straw-manned Lisp a little bit.,-0.1875,Lisp
1514w59,jsa7yqs,"I'm a hobbyist Common Lisper and, in my experience, macros are not a barrier to any major CL project or the reason Lisp hasn't become ""popular"".",0.12083333333333333,Lisp
1514w59,jsa7yqs,"Certainly, if the industry finds things like Java's Lombok acceptable (which is horrifying under the hood), most uses of macros in Common Lisp shouldn't offend anyone.",-0.12142857142857143,Java
1514w59,jsa7yqs,"Certainly, if the industry finds things like Java's Lombok acceptable (which is horrifying under the hood), most uses of macros in Common Lisp shouldn't offend anyone.",-0.12142857142857143,Lisp
1514w59,jsk1xgv,"If I mouseover a C++ macro in VS Code, it will at least show me what it expands to and ctrl+click mostly works.",0.1,C++
1514ibb,js75h2w,"Some time ago I wrote a *generalized uncurry* in Haskell which could eliminate the need for multiple distinct operators like above, at the expense of having to define instances for each product type (though I'm sure this could be automated with TH).",0.2,Haskell
1514ibb,js75h2w,"data Point = Point Double Double     instance Uncurry (Double -> Double -> r) Point r where       uncurry f (Point x y) = f x y      data Size = Size Double Double     instance Uncurry (Double -> Double -> r) Size r where       uncurry f (Size w h) = f w h  And its uses can be chained, as in:      drawRectangle >$ point >$ size  Where      drawRectangle :: Double -> Double -> Double -> Double -> Render ()  This is the how arguments are passed in Haskell's Cairo bindings.",0.0,Haskell
1514ibb,js8iuou,"But despite what the Haskell hive-mind thinks, in my day job multi-argument functions are the norm, so that cutesy composition operators would not earn their keep.",0.0,Haskell
1514ibb,js7gkkc,"If you really want to replace this operator, most random symbols are OK. For example `|` like in Unix or `&` like in Haskell.",0.175,Haskell
1514ibb,js7glyj,I used: `value` ``` `` ``` `function1` ``` `` ``` `function2`  Because my PL grammar has infix function call notation like in Haskell: `1` ``` ` ``` plus ``` ` ``` `2`,0.0,Haskell
1514ibb,js7joy7,"Haskell uses `.`, but for function composition from left to right.",0.14285714285714285,Haskell
1514ibb,js7joy7,"Haskell also has `>>>`, which works like the pipe operator we know.",0.0,Haskell
1514ibb,js7joy7,"Clojure has an interesting approach to this using a macro, where you only need to write the arrow once.",0.25,Clojure
1514ibb,jsa7urp,"There are parallels to Unix pipes, and also to concatenative programming in general  I have a project called Z where I was trying to explore something like this space in Java",0.05000000000000002,Java
1514ibb,js8ey5c,Then you can reverse (<- or <<) for binding assignment a la Haskell or [LiveScript](http://livescript.net/).,0.0,Haskell
1514ibb,jsc97q9,"> But despite what the Haskell hive-mind thinks, in my day job multi-argument functions are the norm, so that cutesy composition operators would not earn their keep.",0.0,Haskell
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,Clojure
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,Lisp
1512nfo,,"Today I tried to search a little for other ""prior art"", and stumbled upon this [page](https://forums.swift.org/t/multiplication-by-juxtaposition/64128), about adding this to Swift.",-0.10416666666666667,Swift
1512nfo,,The proposal includes the code needed to implement the feature in Swift.,0.0,Swift
1512nfo,,"I don't know Swift, but it seem the author of the proposal saw in necessary to restrict implicit multiplication to having the right operand being parenthesised.",0.14285714285714285,Swift
1512nfo,,"The implementation was rather surprising, but - given I don't know Swift - looks both elegant and efficient.",0.6,Swift
1512nfo,,"There are languages (in particular functional programming languages, I think) that allow function calls without parenthesised arguments, and these typically use the first as a fixed syntax for function application (in combination with currying), and at least one (Perl) that uses a - shall we call it ""heuristic"" - mix: if the function name is followed by an opening parenthesis, only the parenthesised expression is taken to be its argument, otherwise as many arguments as needed are taken, possibly the rest of the expression.",0.06875,Perl
1512nfo,,Or something like that - with Perl you can't always be sure.,0.5,Perl
1512nfo,,"If A = B = C, for example ℝ, then it's just a ""plain old"" multiplication, but if A is ℝ and B and C are vector or matrix types, then it is scalar multiplication, and if A is a function type, then it is application of a function B→C, unless B is a function type also, in which case it is function composition.",-0.057142857142857134,C
1512nfo,js6n3dd,"You just take any function `foo: (A, B) -> C` and overload the function application operator for `A` with parameter type `B` as `foo(a, b)`.",-0.75,C
1512nfo,js6n3dd,"If you don't care about being too general, and just want to compose functions of type `A -> B` and `B -> C` for `A`, `B`, and `C` being fixed types, you can create dummy types for `A -> B` and `B -> C` and overload their function application operators as above.",0.05000000000000001,C
1512nfo,js6n3dd,"For the more general case of `A`, `B`, and `C` being arbitrary, I believe the language needs a higher level of polymorphism than the simple scheme above.",0.11666666666666668,C
1512nfo,js6zwws,"And if you disambiguate with parenthesises (because TIL people write `sin` without parenthesises), you get `(sin a) (cos b) + (cos a) (sin b)` where all you need is to implement function semantics for those such that `((n : ℝ) : ℝ -> ℝ) = n × _` (there's some typeclass magic you can use to achieve that in Haskell).",0.25,Haskell
1512nfo,js779up,"> and at least one (Perl) that uses a - shall we call it ""heuristic"" - mix: if the function name is followed by an opening parenthesis, only the parenthesised expression is taken to be its argument, otherwise as many arguments as needed are taken, possibly the rest of the expression.",0.05,Perl
1512nfo,js779up,Or something like that - with Perl you can't always be sure.,0.5,Perl
1512nfo,js7btbm,"The CST will then contain ""juxt"" nodes like:      ""sin a cos b"" →     {kind: ""juxt"", children: [         { kind: ""name"", symbol: ""sin"", type: ""R→R"" },         { kind: ""name"", symbol: ""a"", type: ""R"" },         { kind: ""name"", symbol: ""cos"", type: ""R→R"" },         { kind: ""name"", symbol: ""b"", type: ""R"" } ] }          and ""sin k t"" →     { kind: ""juxt"", children: [         { kind: ""name"", symbol: ""sin"", type: ""R→R"" },         { kind: ""name"", symbol: ""k"", type: ""R"" },         { kind: ""name"", symbol: ""t"", type: ""R"" } ] }  Now suppose we want the rule that ""plain implicit multiplication"" of two values of the same type A, giving a value also of type A, must result in calling the function `mulAAA:A×A→A`.",0.2835164835164835,R
1512nfo,js7hpdi,The fact that juxtaposition was an operator suggested you code have Ruby like power to make DSL’s too.,0.0,Ruby
1512nfo,js7r3sf,"Given your choice of syntax for your example, I guess you are a Haskell programmer.",0.0,Haskell
1512nfo,js7r3sf,"I apologise for never having been able to figure out Haskell (and admittedly, I haven't tried *too* hard), but I am sure that Haskell programmers may have some interesting insights to share on this.",0.3020833333333333,Haskell
1512nfo,js7tots,":-) I have used Perl5 quite a lot in the past (ca 1994-20-something - had it not been for Perl5 and MacPerl, I'd probably have chosen Python back then).",0.08333333333333333,Python
1512nfo,js9rmlp,"C cheats by having its grammar depend on semantic analysis, because of the `(a)*b` ambiguity.",0.0,C
1512nfo,js9rmlp,"'""'{n} codepoint* '""'{n}` (C#'s and friends shouldn't be too dissimilar I would think, unless they define this rule in plain English), which I guess you can (ab)use to introduce complex states in a parser rule.",-0.1714285714285714,C
1512nfo,jsawn5d,"Absolutely, even a ""puritan"" language like Pascal has to ""cheat"" to distinguish between assignment and procedure call, IIRC.",0.2,Pascal
1512nfo,js9ey1u,"Let D = A×B, then its f:D→C.",0.0,D
1512nfo,js9ey1u,":-)  Forgive me for saying this, and it is not personal, but I think that if there is one thing I find annoying with Haskell, it is the way some Haskell users casually present concepts from Haskell as if they are the only ""true"" way to view things, which to me is jarring and reductionistic.",0.008333333333333323,Haskell
1512nfo,jsjweab,"I mean I can see at least three different meanings to `x + y / z * w` (PEMDAS with multiplication first, C with division first, and what my mate Benji would expect me to understand and vice-versa with _fraction last_).",-0.018750000000000006,C
1512nfo,js9givt,"Fair point, but Haskell can express both.",0.7,Haskell
1512nfo,jsb04qa,"I suppose this is also a ""problem"" for Haskell, although being side-effect free, maybe not.",0.4,Haskell
15128pq,,This syntax is inspired by and similar to that in Haskell.,0.0,Haskell
15128pq,,So Haskell function call as such becomes a sequence in my language.,0.0,Haskell
15128pq,,Hence ```foo x y``` in Haskell is written as ```foo@ x y``` in my lang.,0.0,Haskell
15128pq,,Hence ```foo x (bar y) (baz z)``` in Haskell is written as ```foo@ x bar@ y; bas@ z``` in my lang.,0.0,Haskell
15128pq,js6jsav,>Hence foo x (bar y) (baz z) in Haskell is written as foo@ x bar@ y; bas@ z in my lang.,0.0,Haskell
15128pq,js7o7da,I was just following Haskell style.,0.0,Haskell
15128pq,jsaz762,"In fact languages like C++, which provide short-circuiting for default logical operators, when they are overloaded, there is no short-circuiting because they lack lazy evaluation.",0.0,C++
150xbp3,jshcb0f,"For example, in Python, lists, sets, and dicts can't be used as keys in a dict and functions that take lists/sets/dicts as arguments can't use the built-in function memoization mechanisms.",0.0,Python
150xbp3,jshcb0f,"One reason I think the Go community demanded generics so vociferously is that the built-in `slice` and `map` types lacked a lot of common functionality, like `sort()`, `reverse()`, `min()`, etc.",-0.3,Go
150xbp3,jskjaow,Elixir has both of these and I love it.,0.5,Elixir
150xbp3,jscj3nk,"The Swift way of `.Variant` is much better, I fully agree.",0.5,Swift
150xbp3,jscj3nk,Rust's requirement for giving the explicit path (or using a local import) just causes line noise for no tangible benefit (at least in my experience).,-0.15,Rust
150xbp3,jsfzvay,[Higher Kinded Types in Haskell](https://serokell.io/blog/kinds-and-hkts-in-haskell)  [Higher Kinded Types in Scala](https://www.baeldung.com/scala/higher-kinded-types),0.25,Haskell
150xbp3,jsfzvay,[Higher Kinded Types in Haskell](https://serokell.io/blog/kinds-and-hkts-in-haskell)  [Higher Kinded Types in Scala](https://www.baeldung.com/scala/higher-kinded-types),0.25,Scala
150xbp3,jsfxvq5,"In Haskell, this exact functionality is given by the `Functor` type class:  ```haskell class Functor f where   fmap :: (a -> b) -> (f a -> f b) ```  Which is then used as:  ```haskell showInts :: (Functor f) => f Int -> f String showInts = fmap show ```  Here we say `f` is ""something that looks like a generic collection"".",-0.3125,Haskell
150xbp3,jsfxvq5,"It would be like if in C# you could have an interface be specified something like:  ```csharp interface ICollection1 where this<TElem> {   this<TRes> FMap<TRes>(Func<TElem, TRes> f); } ```  whereby the interface `ICollection1` can only be implemented for types that take a generic argument to begin with.",0.0,C
150xbp3,jsfxvq5,"The only two languages I know of that elegantly support higher order generics, is Haskell and Scala.",0.25,Haskell
150xbp3,jsfxvq5,"The only two languages I know of that elegantly support higher order generics, is Haskell and Scala.",0.25,Scala
150xbp3,jshe5zb,I think C++ has that.,0.0,C++
150xbp3,jshgms3,C++ has enough jank that everything is possible but nothing is easy.,0.14444444444444446,C++
150xbp3,jshgms3,Haskell has higher order generics with enough discipline and ergonomics that large parts of the standard library are built around it.,0.11607142857142858,Haskell
150uorm,,"I was just playing around with CPP, making a general macro file called `makaronidefs.h` as I had done prior with [MangoMacs](https://gist.github.com/Chubek/bc96fc7cff2d90cb255ccd973c5ca9e8) but MangoMacs was for Assembly and I wanted something for cross-compiler C. That is besides the point.",0.02500000000000001,Assembly
150uorm,,"So I thought to myself, what if I use CPP on Python, I wrote this [shell](https://pastebin.com/6uYJNbe7), I call her Shelly Duval because she's terrified and does not poll for some reason.",0.0,Python
150uorm,,I will be writing it in C because I also wanna learn cross-platform systems programming and I have been looking for a hook.,0.0,C
150uorm,js5c29k,Do you mean text preprocessor like the one in C / C++ ?,-0.3125,C
150uorm,js5c29k,Do you mean text preprocessor like the one in C / C++ ?,-0.3125,C++
150uorm,js5c29k,"In the GNU C preprocessor , you need to check the source code directly.",0.1,C
150uorm,js5c29k,"I started a C / C++ preprocessor alike tool, some time ago, used two small grammars, one for the tokens and lexer, another for the syntax rules and parsers.",-0.25,C
150uorm,js5c29k,"I started a C / C++ preprocessor alike tool, some time ago, used two small grammars, one for the tokens and lexer, another for the syntax rules and parsers.",-0.25,C++
150ovi7,,"For example, if we say JavaScript is a TC language, that will make the lexer for JS an oracle for `TMjs` right?",0.2857142857142857,JavaScript
150ovi7,js5b5re,"Since checking whether a string is a member of the language called JavaScript takes more than one step, it's not done by an oracle.",0.5,JavaScript
150fsjk,js40vnh,Lua developers have invented a technique for version 5.x to capture variables implicitly even with a single-pass compiler.,0.0,Lua
150fsjk,js40vnh,"Umka's main design principle is *Explicit is better than implicit*, taken from the Python Zen.",0.3333333333333333,Python
150fsjk,js40vnh,"I cannot say I understand how it applies to Python (which is too *implicit* for me), but to Umka it applies quite literally.",0.0,Python
150fsjk,jschgnb,"So the main design goal was to have a statically typed language with an interpreter as small as Lua, Squirrel or Wren.",-0.04166666666666667,Lua
150er0h,,"An easy way to speed it up is to use an optimising compiler (which for me means transpiling to C and using `gcc-O3`), which might improve things by up to 40%.",0.43333333333333335,C
150er0h,,"For a production compiler, fine, but I also no longer have the C transpiler anyway; I prefer to go it alone.",0.4166666666666667,C
150er0h,,(Note that 50% of Tiny C's speed is thanks to being compiled with something better than Tiny C!),0.175,C
150er0h,js4lhi0,Many languages especially C still seem fixated on 32-bit integers.,0.25,C
150er0h,jsax8kz,"When this compiler *was* optimised, via transpilation to C, performance when building large inputs improved up to 40%.",0.21428571428571427,C
1507h3a,js3hk3w,Do you have any notes on how it compares to similar languages like Lua or Lily?,0.0,Lua
1507h3a,js7k5qg,"I really like [Ruby Koans](https://www.rubykoans.com/) as a way to get introduced to a language, so I wrote a similar interactive tutorial for two of my past language projects.",-0.016666666666666663,Ruby
1507h3a,js3kcmz,"I haven't used lua in something like 10 years, but my C API for Toy's interpreter resembles it somewhat, or at least has analogues.",-0.3,C
1504ozy,js3oazn,"Languages like Lisp typically use a reader, and languages like  Forth have a compilation mode that doesn't do anything like parse/lex  (dt, for example, also does not need or want a traditional lexer or parser)  Also this is usually about the early stages of a language, which makes a lot of sense for a new language guide.",-0.03606060606060606,Lisp
1504ozy,js3oazn,"Languages like Lisp typically use a reader, and languages like  Forth have a compilation mode that doesn't do anything like parse/lex  (dt, for example, also does not need or want a traditional lexer or parser)  Also this is usually about the early stages of a language, which makes a lot of sense for a new language guide.",-0.03606060606060606,Forth
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,Python
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,Go
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,C
14zwh6r,,"Kind of the area of systems administrators and linux distro maintainers and enthusiasts, where very obfuscated AWK, Perl, Python, and others live, but aiming for a more accessible syntax.",0.3622727272727273,Perl
14zwh6r,,"Kind of the area of systems administrators and linux distro maintainers and enthusiasts, where very obfuscated AWK, Perl, Python, and others live, but aiming for a more accessible syntax.",0.3622727272727273,Python
14zwh6r,,"Early versions waffled between languages, I settled on Rust for a while, then renamed it and re-implemented in Zig with some improvements to the approach.",0.1,Rust
14zoylt,jrz8f99,Haskell uses a newtype keyword.,0.0,Haskell
14zoylt,jrz8f99,"In Ada, they are called derived types and are written like: `type Derived is new BaseType;` while type aliases are called subtypes and omit the `new` keyword (e.g.",0.13636363636363635,Ada
14zoylt,jrzaohf,"For example, in Rust, structs can be written with named fields, but also as tuple structs, which work really well for types that just wrap a single other type:      // named fields     struct MyNewtype {         wrapped: PredefinedType     }      // tuple struct     struct MyNewType(PredefinedType)  The compiler knows that `MyNewType` is identical to `PredefinedType`, so they optimise the same, but they can't be used the same any more — you can't pass a `MyNewType` to a place that's expecting a `PredefinedType`, and vice versa.",0.08392857142857142,Rust
14zoylt,jrz852z,Haskell uses `newtype` which is a zero-cost abstraction.,0.0,Haskell
14zoylt,js2azgo,D uses [`Typedef`](https://dlang.org/library/std/typecons/typedef.html).,0.0,D
14zoylt,jsbj2uu,I have called this [strong typing](https://en.wikipedia.org/wiki/Strong_and_weak_typing) but this may just be influence from a old lint program which added strong typing to C++.,0.3222222222222222,C++
14zoylt,jrzma68,In a plain C alike:      struct PointA     {         int X;         int Y;     } ;           struct PointB     {         int X;         int Y;     } ;        Should be considered two different types.,-0.10714285714285714,C
14znygr,,"I know about Oberon and Turbo Pascal, which were famous for their fast compilation speed, but I was curious about more current research.",0.22000000000000003,Pascal
14znygr,js1rfbr,The DMD compiler for D is pretty fast.,0.225,D
14znygr,jrzcnmw,"Note that Tcc's speed depends in part in being built (as a C application) using `gcc -O3`, or via some optimising compiler.",0.0,C
14znygr,jrzcnmw,Transpiling to C and using `gcc-O3` would give a boost of 30-40%.,0.0,C
14znygr,jrzuys5,I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,C++
14znygr,jrzilr5,"This is Hapran Xu's proof of concept about creating a multi tier JIT compiler for Lua other than LuaJIT, which is already a work of art.",-0.125,Lua
14znygr,js07ob0,I'd call Go's speed 'healthy'.,0.5,Go
14znygr,js07ob0,The tests I did a few years ago (on a slower machine) put Go's lines-per-second rate in the high 5-figures; the faster ones were well into 6 figures.,-0.020000000000000004,Go
14znygr,js07ob0,"But sometimes all you want to do is turn a bunch of source code into executable code as quickly as possible, and so long as it does a reasonable job, I don't care,  C is commonly used as a target language, so the code has already been verified; in this case you don't need complex analysis.",-0.09,C
14znygr,jrzxese,> I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,C++
14znygr,jrzzymg,"Because, even on my machine, which is not that fast, a fast compiler like Tiny C can generate executable code at up to 10MB per second (so 7 minutes doing that would produce a 4GB executable, although it would probably run out of memory long before).",0.07,C
14znygr,jrzzymg,"Regarding C code, people don't mind faster compilers, but from innumerable threads about this in various forums, they are unwilling or unable to move away from mainstream but slow compilers like `gcc`, and switch to `tcc`, which can be 20 times faster than even `gcc-O0`.",-0.26666666666666666,C
14znygr,jrzzymg,"From your comments it sounds like you are using C++, which has various features not conducive to fast compilation.",0.1,C++
14znygr,js1umyf,"It's different from ones like C, in only supporting one target at a time.",0.08333333333333333,C
14znygr,js1umyf,"It can be made to work on ARM and Linux via intermediate C, but I'm pulling support on that.",0.0,C
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,Pascal
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,Fortran
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,Ada
14znygr,js4ok0x,"Wirth actually worked on Algol68, before he left to create Pascal (via Algol W maybe?)",0.0,Pascal
14znygr,js4ok0x,It filled that role far better than Algol68 *or* Pascal!,0.375,Pascal
14znygr,juc4cqg,"I mean, they are not terrible: here I compare Clang/LLVM, run via `Zig CC` as that is the only way I can get it to work on Windows, with my compilers, on a 40Kloc C input:      Compiler        Input   Opt  Build Time   Runtime          Zig cc -O0      qc.c    -O0   2 secs      5.8** secs     Zig cc -O3      qc.c    -O3  10           4.6     bcc             qc.c    --    0.18        5.8     mm              qc.m    --    0.1         5.5  `bcc` is my C compiler, which itself is not optimised, and is further handicapped by needing an ASM stage.",0.046875,C
14znygr,js3obdq,Also: C&P is seriously impressive.,1.0,C
14znygr,js3obdq,Using C++ templates and linker relocations to create and specialize these stencils is pretty mind-bending!,0.3125,C++
14znygr,juc5hw7,Llvm does actually do 260 passes by default in Rust.,0.0,Rust
14ytm57,,"And defining a fluid Rust or JS-like chainable API is easy to write and think about I think, but perhaps declarative state is ""better""?",0.3111111111111111,Rust
14ytm57,jrxspmx,many configuration APIs in TypeScript have fields that can only be specified in tandem or not at all.,0.25,TypeScript
14ytm57,jrxspmx,"Rust and other affine type systems can do this, but it's difficult and causes a combinatorial explosion of types.",-0.3125,Rust
14yacuw,jrschae,"I just think it is a pity that even when a language like C allows all letterlike Unicode codepoints in identifiers, the standards committee forgets to add ""×"" and ""·"" as multiplication symbols synonymous to ""\*"", or even better only for multiplication, not pointer dereferencing, which would still be absolutely trivial.",0.15000000000000002,C
14yacuw,jrschae,"The curly braces, for those of us who still remember mathematics before we learned C or Perl or one of the many other languages that overloads them with several meanings, are mainly used for set notation, as set descriptors or set builders.",0.13541666666666666,C
14yacuw,jrschae,"The curly braces, for those of us who still remember mathematics before we learned C or Perl or one of the many other languages that overloads them with several meanings, are mainly used for set notation, as set descriptors or set builders.",0.13541666666666666,Perl
14yacuw,jrwvvr6,"Then αβ may mean many different things, depending on A and B. even worse, let's introduce γ of type C and the expressions: (αβ)γ, α(βγ), and αβγ.",-0.1925,C
14yacuw,jrwvvr6,"There actually is precedent for that in programming languages: In Perl, a function can have an unparenthesised comma-separated argument list, but if the first expression after the function name is parentheses, then it is assumed to contain all arguments to the function.",0.125,Perl
14yacuw,jrwvvr6,"But this means that interpreting αβγ correctly as (αβ)γ or α(βγ) not only depends on the type of A, B and C, but also of whether the expressions are parentheses or not.",0.0,C
14yacuw,jrx6ck1,"Fortran and Ada use the same syntax for both, although both use round brackets for the purpose.",-0.1,Fortran
14yacuw,jrx6ck1,"Fortran and Ada use the same syntax for both, although both use round brackets for the purpose.",-0.1,Ada
14yacuw,jrx6ck1,Ada I think specifically wanted to blur the distinction between the two.,0.0,Ada
14yacuw,jt6o09q,"Yes, we also have those under the name ""generics"" or Haskell name them type variables.",0.0,Haskell
14yacuw,jsapg83,"Haskell treats type parameter application syntactically the same as function application (both with space as the operator char), though it doesn't have syntactic sugar form of array indexing, array element value get is a vanilla infix operator `!`, as in `a !",0.0,Haskell
14yacuw,jru65jt,"(And this would not be worse than many other languages' conventions/heuristics for ""semicolon insertion"": JavaScript, Go, ...)",-0.00833333333333334,JavaScript
14yacuw,jru65jt,"(And this would not be worse than many other languages' conventions/heuristics for ""semicolon insertion"": JavaScript, Go, ...)",-0.00833333333333334,Go
14yacuw,jrwy1vm,For example Haskell.,0.0,Haskell
14xy759,,"So far I think [Rust](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html) has the best error messages in the terminal, where it draws red lines using `^` or `~` with arrows and descriptions inline with the code.",0.3666666666666667,Rust
14xy759,,It appears Rust drew inspiration from [Elm](https://elm-lang.org/news/compiler-errors-for-humans) for error styles.,0.0,Rust
14xy759,,It appears Rust drew inspiration from [Elm](https://elm-lang.org/news/compiler-errors-for-humans) for error styles.,0.0,Elm
14xy759,jrq26ho,Maybe Rust has few implementations so it's easy to get those mixed up (unless such things are baked into the language specification; I don't know).,0.058333333333333334,Rust
14xy759,jrq26ho,"C on the other hand has loads, of which one of the most interesting is Clang's when running on Windows.",0.2916666666666667,C
14xy759,jrq2tu2,Iirc I heard praises for Elixir or was it Elm?,0.0,Elixir
14xy759,jrq2tu2,Iirc I heard praises for Elixir or was it Elm?,0.0,Elm
14xy759,jrqdfwq,Coalton drew inspiration from Rust & Elm.,0.0,Rust
14xy759,jrqdfwq,Coalton drew inspiration from Rust & Elm.,0.0,Elm
14xy759,jrpt5f8,There is also another notable Rust error rendering lib: [ariadne](https://github.com/zesterer/ariadne).,-0.125,Rust
14xy759,jrpt5f8,"So you can get the same beautiful error rendering in your own projects :D  Also, just to be clear, `rustc` uses it's own internal lib for error rendering.",0.45000000000000007,D
14xy759,jrssh0z,"Rust's tooling is heavily standardized by the language — compiler (`rustc`), package manager, auto doc generator, formatter, linter, etc, and they are all available with the tool `cargo` that one installs through the typical installation.",0.011111111111111118,Rust
14xy759,jrssh0z,"Having multiple implementations of the Rust compiler is generally not sought after as well, so it's accurate to think of `rustc`'s diagnostics as the language's own diagnostics.",0.24375000000000002,Rust
14xy759,jrssh0z,"It's also worth noting that since Rust's compilation model is relatively strict, much of the compiler diagnostics are essential feedback, especially while learning the language — hence the UX choices made.",0.1,Rust
14xy759,jrqyel7,Probably Elm - its error messages are quite good,0.7,Elm
14xuna4,jrph9w1,"I don't know about LLVM IR specifically, but I had difficulty converting C# IL to WASM because it used goto statements instead of loops.",0.0,C
14xuna4,jrqsduk,GHC (Haskell) does short cut fusion based on a set of rewrite rules like `map g .,0.0,Haskell
14xuna4,js4ktkm,"You may think of LLVM as being at a similar level to C, with perhaps some more detailed information.",0.3,C
14xuna4,jrptkfu,"I am currently experimenting with function inlining in JavaScript, and I'm unsure how to handle multiple returns in a function.",0.0,JavaScript
14xuna4,js7xcl7,"The Rust compiler has two AST-ish levels, I believe.",0.0,Rust
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,Lisp
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,C
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,Lua
14xms09,,"Thus this is not an issue:      let f1 = function f do         let x = 10         invoke f     end          let f2 = function do         let x = 20         let inner-fn = function do             print x # Will print '20', not '10'         end     end  ('invoke' is a function can be used to call functions taking no arguments)  The interpreter is written in C (C99), and the core interpreter (not counting any libraries) is just around 1k lines of code, and can be embedded by compiling it to a library and including the interpreter.h header.",0.0,C
14xms09,,It is possible both to call Beryl functions from C and C functions from Beryl.,0.0,C
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,TypeScript
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,Haskell
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,Rust
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,C++
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,C++
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,Java
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,C
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,Scala
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,Kotlin
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,TypeScript
14xmlma,jro34g9,This is part of why C++ is famously so slow to compile and leads to such large codesize.,-0.02857142857142859,C++
14xmlma,jro34g9,This is why it can be such a challenge to maintain and use third-party C++ libraries that use a lot of templates.,0.0,C++
14xmlma,jro34g9,This is even worse in C++ because of overloading and [SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error).,-0.4,C++
14xmlma,jro34g9,"In C++, if a call fails (i.e.",-0.5,C++
14xmlma,jro34g9,(I guess that makes C++ templates more like a logic language?),0.5,C++
14xmlma,jro34g9,This is why compile errors from templates in C++ are hell.,0.0,C++
14xmlma,jro34g9,"Java generics were very successful, so many languages since then went down a similar (but not identical) path.",0.3298611111111111,Java
14xmlma,jrojr67,Note that GADTs can't work in an approach like C++ templates.,0.0,C++
14xmlma,jrojr67,GADTs _could_ work in Rust if Rust allowed erasing some of the generic types; otherwise it also won't work.,0.0,Rust
14xmlma,jrojr67,C++ already supports template template parameters.,0.0,C++
14xmlma,jrotsua,"> I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages  Check out [D](https://dlang.org).",-0.022222222222222237,C++
14xmlma,jrotsua,"> I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages  Check out [D](https://dlang.org).",-0.022222222222222237,D
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,Ruby
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,Python
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,PHP
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,D
14xmlma,jrotsua,"In fact, [Design-By-Introspection](https://www.youtube.com/watch?v=HdzwvY8Mo-w) is a core tenet of D doctrine.",0.0,D
14xmlma,jrotsua,"If I knew more about Lisp, I'd have posted a Lisp metaprogramme that typechecks itself AOT.",0.5,Lisp
14xmlma,jrovxh2,"If List<T> is covariant (eg because it’s a read-only data type), and your language has subtyping and variance (like Java or TypeScript), saying a variable has type List<T> means it will hold a List or some subtype of List, each element of which is of type T or a subtype of T.  And the different elements can have different types (heterogeneity).",0.0,Java
14xmlma,jrovxh2,"If List<T> is covariant (eg because it’s a read-only data type), and your language has subtyping and variance (like Java or TypeScript), saying a variable has type List<T> means it will hold a List or some subtype of List, each element of which is of type T or a subtype of T.  And the different elements can have different types (heterogeneity).",0.0,TypeScript
14xmlma,jrpg2cf,There is also the in-development language [Hackett](https://github.com/lexi-lambda/hackett) which uses the approach described in the paper to unify Racket style macros with a Haskell style type system.,0.0,Haskell
14xmlma,jro6tff,I think Rust generics are much more like C++ templates than you realise.,0.5,Rust
14xmlma,jro6tff,I think Rust generics are much more like C++ templates than you realise.,0.5,C++
14xmlma,jro6tff,"The compiler will generate different instances of Container for each type parameter, just as C++ will.",0.0,C++
14xmlma,jro84cz,"For custom types Rust - like many others - uses a kind of ""sublanguage"" that is processed during compilation to elaborate the type system.",0.5333333333333333,Rust
14xmlma,jro84cz,"On the opposite side, Zig has a novel approach: instead of using a separate syntax to define types, the constructor is an actual Zig function (evaluated at comptime):  ``` fn Vec(comptime T: type) type {     return struct {         buf: []T,         len: usize,          // methods...     }; } ```  While it may seem that we are breaking some kind of academic barrier by executing code to create types, in the end the result is identical to the Rust example: a builtin type constructor (the `struct`) parametrized by a type value.",-0.030000000000000006,Rust
14xmlma,jro84cz,"Rust just uses a special syntax to describe it, but it's a comptime computation all the same.",0.17857142857142858,Rust
14xmlma,jro84cz,"There are practical differences: by having a more restricted syntax/semantics for the type system (like Rust does) you get the benefit of error messages that are naturally simpler to understand; plus, Rust generics cannot loop forever (afaik).",0.3,Rust
14xmlma,jrnteuv,It's more like an arrow (as understood in Haskell).,0.5,Haskell
14xmlma,jroimbo,"That Zig in particular does not do it (nor do dynamic C++ templates for that matter), is a detail of that particular implementation.",0.1111111111111111,C++
14xmlma,jroimbo,"Nowadays with its `concept`s, even C++ supports this.",0.0,C++
14xmlma,jrom2ol,This is not fully true anymore: C++'s `concept`s allow to constrain type arguments.,0.35,C++
14xmlma,jrom2ol,In fact D's entire metaprogramming doctrine relies on CTFE to typecheck type arguments (eg.,0.0,D
14xmlma,jrom2ol,"eg: `Additive = { a ∈ Type | ∀(x ∈ a, y ∈ a): x + y }`   or in C++:      template<typename a>     concept Additive = requires(a x, a y) { x + y; };",0.0,C++
14xmlma,jrocse6,"From a code generation perspective, they're the same, but from a type checking perspective, they're two different ends of a spectrum, with C++ on the now-disfavored ""compile time dynamic typing"" end.",0.0,C++
14xmlma,jro9pl3,"Using Rust and Zig as examples: the first models mathematical functions with programming functions and type arrows with generics; Zig, on the other hand, decides that its functions are a good enough model for both mathematical functions and type arrows.",0.13749999999999998,Rust
14xmlma,jrosuli,"This is a common issues with C++ templates, for example:      template <typename F, typename... Args>     auto invoke(F fun, Args&&... args) {         auto result = fun(std::forward<Args>(args)...);          return result;     }  This looks perfectly reasonable.",0.06666666666666667,C++
14xmlma,jroi5in,"You don't need Dependent Typing: type constraints, including C++'s concepts, can be modelled after Refinement Types alone, though they of course are less general.",-0.05833333333333332,C++
14xmlma,jropcwi,"You can achieve both in a single language with either a reflective interface and CTFE (as in D, `void f(T)(T x) if(typeid(T).whatever)`), or with types as first-class values, as in      double (x: 'a) if (isAdditive 'a) = x + x  Refinement (or Dependent) Types can achieve the same thing, and simplifies type signatures:      Additive = { a ∈ Type | ∀(x ∈ a, y ∈ a).",-0.023809523809523808,D
14xmlma,jro0mdn,"\*The name ""arrow"" comes from the Category Theory, but the way I use it is a bit more pragmatic, more related to Haskell's typeclass inspired by the mentioned theoretical concept",0.25,Haskell
14wxw2c,jrpvwo8,"I don't know about Rust, but GHC has numerous fancy features that require constraints.",0.0,Rust
14wxw2c,jrpvwo8,Already in the surface language in GHC Haskell we can write type [equality constraints](https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/equality_constraints.html).,0.0,Haskell
14wwl1h,jrldr9n,Nope - It's just a big image for now :D,0.5,D
14wu604,jrn30rp,What is the Scala influence on Vale?,0.0,Scala
14wu604,jrjy1bv,"I'm hoping that by combining them with generational references we can finally make our programs as fast as Rust or as flexible as Java or wherever we want in-between (we need a term for this, perhaps gradual optimization?)",0.1,Rust
14wu604,jrjy1bv,"I'm hoping that by combining them with generational references we can finally make our programs as fast as Rust or as flexible as Java or wherever we want in-between (we need a term for this, perhaps gradual optimization?)",0.1,Java
14wu604,jrp2exs,Vale has a general rule that a function or struct needs to be marked `exported` to be visible to C or the OS.,0.07500000000000001,C
14vvgnw,jrf6ewn,"I would argue this makes your automata objects, and thus your language OOP, though in a different sense from Java.",0.0,Java
14vvgnw,jrhc2oi,Cell program gets compiled literally into Java or C# code.,0.0,Java
14vvgnw,jrhc2oi,Cell program gets compiled literally into Java or C# code.,0.0,C
14vvgnw,jrhc2oi,Are they saying the Java code compiled from Cell is 2-3 times faster and less memory intensive than an “equivalent Java program”?,-0.16666666666666666,Java
14vvgnw,jrhc2oi,That simply sound like they are comparing to a terribly written Java program.,-0.3,Java
14vvgnw,jrhc2oi,Or are they using the Cell to C++ the compiler?,0.0,C++
14vvgnw,jrhc2oi,Anything is 2-3 times faster and use less memory in C++ compared to Java.,-0.16666666666666666,C++
14vvgnw,jrhc2oi,Anything is 2-3 times faster and use less memory in C++ compared to Java.,-0.16666666666666666,Java
14vvgnw,jrf2lg0,Java is faster than c#?,0.0,Java
14vvgnw,jrivdfp,"In this regards, they're more like messages in the actor paradigm (Erlang), but automata are not actors either, because actors have their own thread of execution while automata are ""passive"" entities, just jike objects in OOP.",0.55,Erlang
14vvgnw,jrhkjyy,"You could call that a terrible Java implementation, but it might be the Java implementation many developers would write.",-0.25,Java
14vvgnw,jrhkjyy,Most Java developers are not thinking about data oriented design and cace locality.,0.5,Java
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,C++
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,Java
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,C
14vvgnw,jrimmwg,"The performance results shown on the website are for the C++ code generator, which is obviously the fastest of the three.",0.0,C++
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,Java
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,C++
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,Python
14vvgnw,jrimmwg,"The thing is, the kind of code that even a very good compiler/transpiler would generate when compiling any higher-level language to C++ is not the same as manually written C++ code.",0.5033333333333333,C++
14vvgnw,jrimmwg,"The Java and C# code it's compared to are written in an OOP style, and I think this is stated clearly in the article and the benchmark page.",0.10000000000000002,Java
14vvgnw,jrimmwg,"The Java and C# code it's compared to are written in an OOP style, and I think this is stated clearly in the article and the benchmark page.",0.10000000000000002,C
14vvgnw,jrimmwg,"You can certainly squeeze better performance from Java by ditching OOP altogether and using data oriented programming techniques, or the ECS architecture, but that's certainly not the kind of programming style Java was designed around, and it definitely takes an extra effort on the part of the programmer to do so.",0.20119047619047623,Java
14vvgnw,jrimmwg,"And note that the title of the post is ""Why functional relational programming is faster than **OOP**"", not ""Why functional relational programming is faster than Java when the latter is used with the lowest-level programming style possible"".",0.0,Java
14vvgnw,jrimmwg,"Although I'm not sure the latter is not true, I haven't tried but I don't think Java is the ideal implementation language for data oriented design and the ECS architecture.",0.11875000000000001,Java
14vvgnw,jrhcq6s,"C# has some specific advantages in the doesn’t-always-have-to-box area, which Java will match in a year or two with a similar capability.",0.0,C
14vvgnw,jrhcq6s,"C# has some specific advantages in the doesn’t-always-have-to-box area, which Java will match in a year or two with a similar capability.",0.0,Java
14vvgnw,jrhcq6s,Otherwise Java tends to be a bit faster with long running applications.,-0.05,Java
14vvgnw,jrinedu,"The hand-written Java code used in the comparison is indeed written in an OOP style, but why do you think that's a terrible implementation?",-1.0,Java
14vvgnw,jrinedu,Isn't that the natural  thing to do when programming in Java?,0.1,Java
14vvgnw,jrinedu,When Java was first released (in 1995) OOP was all the rage and nobody was even talking about data oriented design and the Entity/Component/System architecture.,0.25,Java
14vvgnw,jrhlk79,"This looks to have more details:  https://www.cell-lang.net/benchmarks-relational.html  Based on that page, they are comparing to the Cell via C++.",0.5,C++
14vvgnw,jrhlk79,"That said, towards the bottom they have a comparison of Vell embedded in Java to Cell via C++.",0.0,Java
14vvgnw,jrhlk79,"That said, towards the bottom they have a comparison of Vell embedded in Java to Cell via C++.",0.0,C++
14vvgnw,jrhlk79,Generally speaking the java version looks to be about 6% slower than the C++ version specifically for the CSV test (though it can be much slower than that for specific examples).,0.08333333333333333,C++
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,Java
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,C++
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,Java
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,C++
14vvgnw,jripx0m,The thing that stops you from doing it and the reason people use Java the first place is the platform agnostic property of JVM.,0.25,Java
14vvgnw,jripx0m,"Python or JS cannot be easily complied to C++ because they are interpretative; I don’t know any good way it can be done, and if someone manage to create a good compiler many will be using it.",0.5833333333333333,Python
14vvgnw,jripx0m,"Python or JS cannot be easily complied to C++ because they are interpretative; I don’t know any good way it can be done, and if someone manage to create a good compiler many will be using it.",0.5833333333333333,C++
14vvgnw,jrosmiv,It seems to matter how the programs are written ;-)  Do the fastest C# programs use hand-written vector instructions?,0.25,C
14vvgnw,jrh45ei,Edit: The Rust Book has a fairly decent quick discussion of the different stances: https://doc.rust-lang.org/book/ch17-01-what-is-oo.html,0.16666666666666666,Rust
14vvgnw,jrh4clv,"I recently learned that Erlang evidently doesn't formally comply to the original idea, and was like wait what?",0.20833333333333334,Erlang
14vvgnw,jrhnh9s,Being in a language like Java doesn't mean you need to use tons of OOP features.,-0.3125,Java
14vvgnw,jrip26t,"No, the difference in performance between the generated C++ and Java code is much larger than that.",0.0,C++
14vvgnw,jrip26t,"No, the difference in performance between the generated C++ and Java code is much larger than that.",0.0,Java
14vvgnw,jrip26t,Java makes a terrible compilation target for a language like Cell.,-1.0,Java
14vvgnw,jrip26t,"The generated Java code is still competitive with hand-written OO Java code, sometimes faster, sometimes slower, but trying to compile Cell into Java (or C#) code in like trying to fit a round peg in a square hole.",0.1,Java
14vvgnw,jrip26t,"The generated Java code is still competitive with hand-written OO Java code, sometimes faster, sometimes slower, but trying to compile Cell into Java (or C#) code in like trying to fit a round peg in a square hole.",0.1,C
14vvgnw,jrip26t,The C++ code generator is more recent and has been redesigned from the ground up to achieve better performance.,0.3333333333333333,C++
14vvgnw,jrip26t,At least some of that work could be backported to the Java version.,-0.3,Java
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,C++
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,Java
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,C
14vvgnw,jrndlwg,"As for Go being significantly faster than Java, I just looked at ***The Computer Language Benchmarks Game***, and that doesn't seem to be the case: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html).",-0.25833333333333336,Go
14vvgnw,jrndlwg,"As for Go being significantly faster than Java, I just looked at ***The Computer Language Benchmarks Game***, and that doesn't seem to be the case: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html).",-0.25833333333333336,Java
14vvgnw,jrndlwg,"Go seems to be slightly faster than Java in most (but not all tests), but the difference is really minimal.",0.07777777777777779,Go
14vvgnw,jrndlwg,"Go seems to be slightly faster than Java in most (but not all tests), but the difference is really minimal.",0.07777777777777779,Java
14vvgnw,jrndlwg,"Although Go seems to have improved lately, the last time I checked (a few years ago) Java was clearly faster, and I've to admit I wasn't aware of Go's improvements.",-0.029999999999999992,Go
14vvgnw,jrndlwg,"Although Go seems to have improved lately, the last time I checked (a few years ago) Java was clearly faster, and I've to admit I wasn't aware of Go's improvements.",-0.029999999999999992,Java
14vvgnw,jrndlwg,"But now I'm curious, I'm going to rewrite the benchmarks in Go and see what happens.",-0.1,Go
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,Go
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,C
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,Java
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,C++
14vvgnw,jrndlwg,"I'm not aware of a tool that can automatically convert, say, non-trivial Java code into equivalent C++ and produce a significant speedup.",0.125,Java
14vvgnw,jrndlwg,"I'm not aware of a tool that can automatically convert, say, non-trivial Java code into equivalent C++ and produce a significant speedup.",0.125,C++
14vvgnw,jrndlwg,"I even tried a couple of native compilers for Java, and they were actually slower than the JVM.",0.0,Java
14vvgnw,jrndlwg,"In the Java and C# version of the benchmark I didn't follow the principle of encapsulation religiously, but only because it was irrelevant to what I was interested in, which is performance.",-0.0625,Java
14vvgnw,jrndlwg,"In the Java and C# version of the benchmark I didn't follow the principle of encapsulation religiously, but only because it was irrelevant to what I was interested in, which is performance.",-0.0625,C
14vvgnw,jrmbpfx,"Erlang processes really are quite similar, from an intuitive perspective, to actors: They represent a distinct thread of control and communicate by asynchronous messages.",0.16666666666666666,Erlang
14vvgnw,jrmbpfx,"First, Erlang apparently has a process registry that lets you look up a PID.",0.15,Erlang
14vvgnw,jrmbpfx,"In principle you could simulate a registry with actor messages, but in Erlang it's part of the semantics.",0.0,Erlang
14vvgnw,jrmbpfx,"Second, Erlang has selective receive, which lets you process messages in the order you care about them and save the rest for later.",0.0,Erlang
14vvgnw,jrmbpfx,"The last difference is that crashing is not one of the three things actors are theoretically allowed to do, which means that Hewitt doesn't define any sort of supervisory tree the way Erlang does.",0.0,Erlang
14vvgnw,jrmbpfx,"On that front, Erlang seems superior for at least thinking about robustness in the face of failure.",0.027777777777777752,Erlang
14vvgnw,jrhq2gg,Most Java programs are not performance critical and most devs rightfully don’t care about speed when weighed against readability and potential for reuse.,0.25,Java
14vvgnw,jrhq2gg,When speed is required though there are many Java programs properly optimized to be fast and have better memory footprint.,0.3,Java
14vvgnw,jrhq2gg,Since the compiler here specially optimize for performance when it generates the code and care not about readability it is only fair to compare with another Java program that is also written to optimize for performance.,0.3523809523809524,Java
14vvgnw,jrnt3xh,You are for sure right that automatic Java to C++ converter has uneven performance.,0.1952380952380952,Java
14vvgnw,jrnt3xh,You are for sure right that automatic Java to C++ converter has uneven performance.,0.1952380952380952,C++
14vvgnw,jrnt3xh,Our own rewrite test on Go was actually even slightly faster than C++ but it could be many factors at play.,0.23333333333333334,Go
14vvgnw,jrnt3xh,Our own rewrite test on Go was actually even slightly faster than C++ but it could be many factors at play.,0.23333333333333334,C++
14vvgnw,jrnt3xh,"It was harder to get devs and libraries are insufficient, so we went for C++ anyways.",-0.1,C++
14vvgnw,jrnt3xh,"Maybe I am biased because I looked at Java and scala before and scala tends to be slightly slower, so I had preformed opinion that was hard to change.",-0.22916666666666669,Java
14vvgnw,jripulv,That sounds like the first definition the Rust Book discusses.,0.25,Rust
14vvgnw,jrjmua8,"So no, that's *not OOP*, not the way Simula, Java and C++ see it.",0.0,Java
14vvgnw,jrjmua8,"So no, that's *not OOP*, not the way Simula, Java and C++ see it.",0.0,C++
14vvgnw,jrjmua8,It just happened that the benefits of this approach are most obvious to people working in C++ - a language that suffered from the OOP craze badly.,-0.06666666666666661,C++
14vvgnw,jrjpx4s,"Sure if you're learning C, then it makes sense to learn about what's happening in memory, but if you're learning a higher level language of a different paradigm, talking about what happens in the machine may undermine their understanding.",0.25,C
14vvgnw,jrpvp8s,"message passing (hence ""what I called 'objects'""), versus the more common modern C++ take of ADTs.",0.13333333333333333,C++
14vm3kw,,"I have played with Rust, Nim, Zig, Go and saw that none of them use classes (they have their own way to define something similar to an interface though).",0.3,Rust
14vm3kw,,"I have played with Rust, Nim, Zig, Go and saw that none of them use classes (they have their own way to define something similar to an interface though).",0.3,Go
14vm3kw,jreyzx5,in TypeScript a class can `implements` another class.,0.0,TypeScript
14vm3kw,jreyzx5,"Rust where any type can implement a trait, in some OOP languages you can't implement interfaces for non-class types - A class is a container for data    - ex.",0.0,Rust
14vm3kw,jreyzx5,"""dataclass"" in Python - A class is a mechanism to protect data from other classes (note: **not** other objects.",-0.03125,Python
14vm3kw,jrevmsn,"Most of the good parts of object-oriented programming can be accomplished or done better with modules, functions as first-class values, and Rust traits (or, better yet, Haskell type classes).",0.48,Rust
14vm3kw,jrevmsn,"Most of the good parts of object-oriented programming can be accomplished or done better with modules, functions as first-class values, and Rust traits (or, better yet, Haskell type classes).",0.48,Haskell
14vm3kw,jrevmsn,"If you care about an interface, use an interface (a Rust trait).",0.0,Rust
14vm3kw,jrgn3dk,When Java added closures (it sort of had something like it already with anonymous inner classes) different ways of composing stuff together other than inheritance became much more palatable.,0.09375,Java
14vm3kw,jrgn3dk,"So my thesis is that closures, dependency injection, design for test, and possibly performance improvements in compilers/run-time for higher order programming may have played a big part on the Java side in the move away from inheritance based abstraction.",0.08333333333333333,Java
14vm3kw,jrgn3dk,I think a similar story may be true for C++.,0.175,C++
14vm3kw,jrgn3dk,"Java debuggers are much better now so maybe single stepping would work for less complex scenarios but if it isn't readable like a book, the code isn't as readable as it could be.",-0.009523809523809504,Java
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,Java
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,C
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,Python
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,JavaScript
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,Ruby
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,TypeScript
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,Kotlin
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,Scala
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,Crystal
14vm3kw,jrqn7d7,"Swift, too, it's only one year older than Rust.",0.08333333333333333,Swift
14vm3kw,jrqn7d7,"Swift, too, it's only one year older than Rust.",0.08333333333333333,Rust
14vm3kw,jrncoii,"That will have a headache, (even though my live is Elixir, and Erlang), if that will be pushed to be used everywhere, I would start to hate it as well.",-0.33181818181818185,Elixir
14vm3kw,jrncoii,"That will have a headache, (even though my live is Elixir, and Erlang), if that will be pushed to be used everywhere, I would start to hate it as well.",-0.33181818181818185,Erlang
14vm3kw,jrf2nx0,Rust has classes.,0.0,Rust
14vm3kw,jricwsa,"When I think about such topics, I always look at how it is with Rust, and I always say: okay, that's the way.",0.25,Rust
14vm3kw,jricwsa,"With Rust, you can define *methods* for your *struct*, so it's basic OOP, encapsulation is supported.",0.0,Rust
14vm3kw,jrnbhq6,"If you take away inheritance than a Java style class is really just a namespace with polymorphism, and parametric polymorphism (ie generics in arguments or functions) is possible without classes.",0.1,Java
14vm3kw,jrgkd6x,In Java Style OOP the only mechanism for reuse and encapsulation is inheritance.,0.0,Java
14vm3kw,jrgkd6x,is that Java’s OOP became popular to a large part due to the relatively easy implementation via virtual function tables.,0.2806547619047619,Java
14vm3kw,jrhionm,Go packages even look like classes.,0.0,Go
14vm3kw,jrhionm,Your knowledge would be a great help  Do what you want but you can't ignore the fact that the vast majority of code in production today is written either in java or C#.,0.4,C
14vm3kw,jrg6e5q,"A notable counter-example would be Kotlin, an OOP language presumably made by people who weren't satisfied with Java.",0.5,Kotlin
14vm3kw,jrg6e5q,"A notable counter-example would be Kotlin, an OOP language presumably made by people who weren't satisfied with Java.",0.5,Java
14vm3kw,jrg6e5q,Although the class-based design of Kotlin is still likely influenced by what is convenient to implement on the JVM.,0.0,Kotlin
14vm3kw,jrhwj1w,people who program in C++ are busy endlessly fighting with templates and implicit behavior.,-0.012499999999999997,C++
14vm3kw,jrhzbr2,A class is a Pascal record type with functions glued on … ?,0.0,Pascal
14vm3kw,jrfgeoy,It reminds me of JavaScript and similar languages where you are/were required to construct your own classes by hand (an extra boilerplate).,0.125,JavaScript
14vm3kw,jrf2kjh,I don't think structures as in Rust are the same as classes in Java except data inheritance.,0.0,Rust
14vm3kw,jrf2kjh,I don't think structures as in Rust are the same as classes in Java except data inheritance.,0.0,Java
14vm3kw,jrf2kjh,"The point of classes is that one is able to tie data and behaviour together, whereas this is the thing Rust is trying to avoid by having strictly separate `struct` and `impl` blocks, which can be located in different files and even crates (through traits).",0.25,Rust
14vm3kw,jrewepg,"From the beginning, I was assuming that Rust doesn't implement OOP because of the lack of classes/inheritance (one of the four pillars of OOP).",0.0,Rust
14vm3kw,jrewepg,For instance Rust have struct and Nim has object as product types (there are also tuples) that can implement stateful struct (Nim has also inheritance now that I remember),0.0,Rust
14vm3kw,jrf1qlb,"> Rust traits (or, better yet, Haskell type classes).",0.5,Rust
14vm3kw,jrf1qlb,"> Rust traits (or, better yet, Haskell type classes).",0.5,Haskell
14vm3kw,jrf1qlb,How would Haskell type classes even work in a non-Haskell language?,0.0,Haskell
14vm3kw,jrqzti4,"I was happy to know by discussing with other redditors there are still languages that implement classes in the classical way (Like Grace, Swift and Crystal you mentioned).",0.225,Swift
14vm3kw,jrqzti4,"I was happy to know by discussing with other redditors there are still languages that implement classes in the classical way (Like Grace, Swift and Crystal you mentioned).",0.225,Crystal
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,TypeScript
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,Scala
14vm3kw,jrh8sjc,> In Java Style OOP the only mechanism for reuse and encapsulation is inheritance.,0.0,Java
14vm3kw,jrglmfv,I also think that Java recieve a big boost throught promotions made to organizations (which facilitate it's adoption).,0.0,Java
14vm3kw,jrih3g3,I saw that CLOS (Common Lisp Object System) don't follow the classical definition of class/hineritance we see in other OO languages.,-0.14166666666666666,Lisp
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Go
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Java
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,C
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,Java
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,C
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,COBOL
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Kotlin
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Go
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Rust
14vm3kw,jrgdwf8,"Not just convenient to implement, but also compatible with the Java ecosystem.",0.0,Java
14vm3kw,jri19oj,"If it requires inheritance in the Java style, i.e.",0.0,Java
14vm3kw,jrfl7du,"In the TypeScript example below, `BThing` is a subtype of `AThing`.",0.0,TypeScript
14vm3kw,jrf9xra,"No matter where the methods are defined in Rust, the behavior is still tied to the underlying data.",0.0,Rust
14vm3kw,jrf9xra,When you write:  ``` dog.bark(); ```  there's no difference between Rust and Java.,0.0,Rust
14vm3kw,jrf9xra,When you write:  ``` dog.bark(); ```  there's no difference between Rust and Java.,0.0,Java
14vm3kw,jrh5zkf,"""Haskell type classes"" are just type classes as implemented in Haskell.",0.0,Haskell
14vm3kw,jrh5zkf,"Type classes can be implemented in other languages such as ML, Scala, or C++20.",-0.0625,Scala
14vm3kw,jrh5zkf,Rust traits specifically don't provide higher kinded types.,0.25,Rust
14vm3kw,jri21l6,"In Java in particular, pretty much anything you can do with inheritance, you can do with interfaces and delegation.",0.20555555555555557,Java
14vm3kw,jrik91b,"Ad-hoc polymorphism is achieved using methods on generic functions, with methods specialised on all arguments, rather than methods on objects; I can only think of Dylan and Julia being influenced by the generic function model.",0.0,Julia
14vm3kw,jrik91b,an abstract class in Java).,0.0,Java
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Go
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,Java
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,C
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Kotlin
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Go
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,Rust
14vm3kw,jrl2se8,Will be used for new projects  Kotlin has inheritance so does Go as I pointed out.,0.13636363636363635,Kotlin
14vm3kw,jrl2se8,Will be used for new projects  Kotlin has inheritance so does Go as I pointed out.,0.13636363636363635,Go
14vm3kw,jrgmssd,"> No matter where the methods are defined in Rust, the behavior is still tied to the underlying data.",0.0,Rust
14vm3kw,jrgmssd,"In Java, the visibility is tied to the type (class) whereas in Rust the visibility is tied to the module.",0.0,Java
14vm3kw,jrgmssd,"In Java, the visibility is tied to the type (class) whereas in Rust the visibility is tied to the module.",0.0,Rust
14vm3kw,jrfbjwd,"The dot syntax in Rust is a syntax sugar for the full syntax `T::f` or `<T as I>::f`, where `f` is a function taking `self` as the first argument.",0.3,Rust
14vm3kw,jrfbjwd,"In Java, methods are bound to data because you necessarily need an object to call methods upon, unless I'm missing some trick to bypass that.",-0.1,Java
14vm3kw,jrfcdll,"There are no ""higher-kinded type classes"" in Haskell; there are higher-kinded types.",0.0,Haskell
14vm3kw,jrnkluj,"For instance, in Rust, one trait B can extends an other trait A.",-0.125,Rust
14vm3kw,jrlcrg7,"As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,Kotlin
14vm3kw,jrgbss4,"[TypeScript playground link](https://www.typescriptlang.org/play?#code/FAb2wAgh6aIQQCoAsCWA7A5hVBnCAhhLgK4BGALgJ4AOAphAPYBmEAQihppDHAO7I6AJwYc0WHPgIBjaXRoU6AEwA0xRpIScsPavS3jsAXmIUhXXbVHbjp8xIA+EdCQC2ZYeCjMS6aRVRGdBwAOTplJEMAChoCIQJXAC4DLgBKCBAAXy8IABs6CggyG2SxLggTACJBXNzGSsJ8Mp0eWAQhTDc6dEKWCD0GAHJmzEHNdEZCglxcVEx0AjJ8-o1Y+NcC4SZWAYhByK5BgDoeVDCImyjiw1TwbNActpHNIlJKK22UnSg2gWEGA4SPCEWTyRSqdSaEaWfSA2y4MzlJwudyeKC7Z4mBH2bg8Hx+AJBULhJRwmJxBLJOHpLI5fKFa5cUo2CoQap0Wr1RrsGyPOAAeQA0qdzqTLoysLdgNkgA)      // BThing is a subtype of AThing     // where AThing is accepted, so is BThing     type AThing = string | number     type BThing = string  Yes, interfaces can also have a subtype relationship.",0.0,TypeScript
14vm3kw,jrgbss4,"For example in Java, an interface can `extends` another interface.",0.0,Java
14vm3kw,jrgbss4,Rust also has trait subtyping.,0.0,Rust
14vm3kw,jris11n,"If you implement something like this in, say, C, you may have come up with an OO design but that does not make C an OO language.",0.0,C
14vm3kw,jrfhu39,Python.,0.0,Python
14vm3kw,jrfe9yn,This is exactly how C++ implements class methods.,0.25,C++
14vm3kw,jrfe9yn,Rust isn't doing anything different here.,0.0,Rust
14vm3kw,jrfe9yn,What makes Rust different is the ergonomics of `impl` blocks and the flexibility of type classes.,0.0,Rust
14vm3kw,jrgcbem,Rust currently doesn’t have this; only a type can implement a trait.,0.0,Rust
14vm3kw,jrnoz46,The foundation of Rust is based off of OCaml and it takes all of its best traits.,1.0,Rust
14vm3kw,jrnoz46,"I don't love Rust because the slow compilation just makes it really hard to enjoy, if it was faster than I would.",0.07708333333333332,Rust
14vm3kw,jrn1jam,">As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,Kotlin
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Go
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Java
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,C
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Ruby
14vm3kw,jrn1jam,Rust doesn't.,0.0,Rust
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,C++
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,Java
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,Rust
14vm3kw,jrfx4wk,"Rust and C++ implement ""objects"" very differently.",0.0,Rust
14vm3kw,jrfx4wk,"Rust and C++ implement ""objects"" very differently.",0.0,C++
14vm3kw,jrfx4wk,"Rust determines what function to call at compile time, this is not (necessarily) true for C++.",-0.175,Rust
14vm3kw,jrfx4wk,"Rust determines what function to call at compile time, this is not (necessarily) true for C++.",-0.175,C++
14vm3kw,jrfx4wk,C++ has a very different implementation using [vtables](https://en.wikipedia.org/wiki/Virtual_method_table).,0.0,C++
14vm3kw,jrfx4wk,"In simple cases, C++ method call dispatch can be optimized at compiled time, thus resulting in a similar outcome to rust, but this is not the norm.",0.0,C++
14vm3kw,jrfzbpr,"It has associated functions (albeit namespaced a bit weirdly, but that's just a C quirk, right?",-0.10714285714285715,C
14vm3kw,jrfzbpr,"Yes, you technically call them as free functions, but that's how Rust and C++ work under the hood, so is there really any semantic difference?",0.20000000000000004,Rust
14vm3kw,jrfzbpr,"Yes, you technically call them as free functions, but that's how Rust and C++ work under the hood, so is there really any semantic difference?",0.20000000000000004,C++
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,C
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,Rust
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,Java
14vm3kw,jrgiozk,"At least in the C# implementation of a partial class (part of the issue of all this terminology is there is no mathematical or robust definition of a `class`, so we need to specify which language's interpretation of a `class` we mean).",-0.178125,C
14vm3kw,jrgiozk,A partial class can almost be thought of as a purely syntactic concatenation of two files (almost like a C #include directive).,0.057142857142857134,C
14vm3kw,jrgiozk,"In Rust, visibility/encapsulation is determined by the **module**, not the type.",0.0,Rust
14vm3kw,jrgiozk,The same rules of visibility apply to these functions just like any other kind of entity in Rust.,0.15833333333333333,Rust
14vm3kw,jrneuzy,Classes that come from Java and C# have their own way of working (This is how a learned OOP by the way).,0.6,Java
14vm3kw,jrneuzy,Classes that come from Java and C# have their own way of working (This is how a learned OOP by the way).,0.6,C
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,Java
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,C
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Go
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Java
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,C
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,Ruby
14vm3kw,jrneuzy,Rust doesn't.,0.0,Rust
14vm3kw,jrneuzy,Rust is rigid in this point (I don't know if it's because of safety or to create a sound type system).,0.4,Rust
14vm3kw,jrit5f3,OP asked why languages lie Rust don’t have classes.,0.0,Rust
14vm3kw,jrfhehb,"But I concede that Rust makes it *easier* to seperate data and impl, and Java makes *conflation* the happy path.",0.8,Rust
14vm3kw,jrfhehb,"But I concede that Rust makes it *easier* to seperate data and impl, and Java makes *conflation* the happy path.",0.8,Java
14vm3kw,jrilbyx,"Without inheritance, C++ does compile-time dispatch.",0.0,C++
14vm3kw,jrilbyx,"For trait objects (boxed), Rust does runtime dispatch, pretty sure with vtables.",0.375,Rust
14vm3kw,jrghbx7,"~~C is fundamentally different from Java & Rust, because it has no private members.",0.0,Java
14vm3kw,jrghbx7,"~~C is fundamentally different from Java & Rust, because it has no private members.",0.0,Rust
14vm3kw,jrghbx7,"Languages like Haskell not, because of immutability and lack of side effects.",0.0,Haskell
14vm3kw,jrghbx7,Rust & Java allow arbitrary side effects and mutation of their associated instance.,-0.1,Rust
14vm3kw,jrghbx7,Rust & Java allow arbitrary side effects and mutation of their associated instance.,-0.1,Java
14vm3kw,jrhp47u,"I'm not very familiar with Rust, I hoped that comparing to C# would help me understand.",-0.14423076923076922,Rust
14vm3kw,jrhp47u,"I'm not very familiar with Rust, I hoped that comparing to C# would help me understand.",-0.14423076923076922,C
14vm3kw,jrflnf1,"Yes, you can perhaps imitate the Rust's behaviour with static methods (modulo syntax), but that wouldn't be in the nature of Java for sure.",0.5,Rust
14vm3kw,jrflnf1,"Yes, you can perhaps imitate the Rust's behaviour with static methods (modulo syntax), but that wouldn't be in the nature of Java for sure.",0.5,Java
14vm3kw,jrnig92,"Like Rust or Go, methods are defined separately of data structures.",0.0,Rust
14vm3kw,jrnig92,"Like Rust or Go, methods are defined separately of data structures.",0.0,Go
14vm3kw,jrns1wd,I have visited the official [FAQ for Go](https://go.dev/doc/faq) and they stated that they don't implement type/data inheritance.,0.0,Go
14vm3kw,jrnjz4i,You can also look at D for another example.,0.0,D
14vm3kw,jrnw34p,I have visited the official FAQ for Go and they stated that they don't implement type/data inheritance.,0.0,Go
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,C++
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Rust
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Go
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Scala
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Kotlin
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Julia
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,Elixir
14vm3kw,jro13ss,But it shows that Go use the type embedding (among other methods like traits or mixins or protocols) to mitigate this drawback.,-0.125,Go
14vm3kw,jro13ss,TBH I am more in favor of the Go type embedding,0.5,Go
14vbyy3,,"Well and good: the model is turtles all the way down, just like Lisp's eval/apply.",0.2722222222222222,Lisp
14vbyy3,jrcq0mr,IIRC Cloud Haskell embeds actors in a lazy language.,-0.25,Haskell
14vbyy3,jrd0nrv,Cloud Haskell ...,0.0,Haskell
14vbyy3,jrd0nrv,"Cloud Haskell decrees that *because Haskell,* messages happen in a monad, which is no surprise.",0.0,Haskell
14vbyy3,jrd0nrv,Gymnastics in section 3 deal with Haskell not being anything like Erlang.,0.0,Haskell
14vbyy3,jrd0nrv,Gymnastics in section 3 deal with Haskell not being anything like Erlang.,0.0,Erlang
14vbyy3,jrmnwdd,"It might not be exactly how Haskell implementations work on the inside, but you can think of an entire Haskell program's evaluation as being driven by the *need* for that outside-world resulting from all the I/O actions they perform, in order as determined by their functional dependencies embedded in all that monadic fancy footwork that do-notation desugars into.",0.125,Haskell
14vbyy3,jrmnwdd,And Haskell's way of saying that is wrapped up in its relationship with the I/O monad.,0.0,Haskell
14va6m9,jrdskmq,And I decided long ago that the best use of my time is to just work on improving Haskell tooling.,0.475,Haskell
14va6m9,jre41jj,enums in C and many other languages only allow \`[atoms](https://langdev.stackexchange.com/questions/1970/what-is-the-type-and-correct-name-of-a-member-of-an-enumeration/1971#1971)\` to be values with the same underlying simple type.,0.075,C
14va6m9,jre41jj,Having the type representation do both jobs is good but for reasons unknown they chose to name their construct after the less general concept (a C stlye enum) rather than the more general one (a discriminated union).,0.17222222222222225,C
14va6m9,jre41jj,The type representation being (using Haskell like syntax)  data union = typeA | typeB | typeC,0.0,Haskell
14va6m9,jrfqag8,I wonder if Swift checks all the boxes...,0.0,Swift
14va6m9,jrdnkdj,"I’ve used macros in Lisp-like languages and the preprocesser in C extensively, but felt like it was a feature I could live without, so I left it off the list.",0.04545454545454545,C
14va6m9,jrdnkdj,"This is cool, and it’s fun to take advantage of Lisp’s syntax to do so, but I’ve always felt like code that relies too much on macros becomes difficult to reason about.",0.08749999999999997,Lisp
14va6m9,jrdnkdj,"In C, I see the preprocessor as mainly used for performance, debug flagging, higher order programming, and generics.",0.20833333333333331,C
14va6m9,jre5wni,"Enums in C carry tags, but no data.",0.0,C
14va6m9,jre5wni,"Unions in C carry data, but no tags.",0.0,C
14va6m9,jre5wni,"Rust ADTs carry both (or one, or neither).",0.0,Rust
14va6m9,jre5wni,"Swift did too, so the small amount of emerging consensus as to what to call ADTs in C-like languages is nice.",0.175,Swift
14va6m9,jrgjx3o,"It might, though I’ve never used Swift as I’m outside the Apple development world.",0.0,Swift
14v92v5,,And by dead I mean in *this* sense (from Monty Python's Parrot sketch):  >He's not pining!,-0.2953125,Python
14v92v5,,"IN MEMORIAM  *Conceived in the spring of 2001 as a fusion of Perl and Python, Parrot, the illegitimate love child of Guido van Rossum and Larry Wall, was born as version 1.0 on 17.",0.5,Perl
14v92v5,,"IN MEMORIAM  *Conceived in the spring of 2001 as a fusion of Perl and Python, Parrot, the illegitimate love child of Guido van Rossum and Larry Wall, was born as version 1.0 on 17.",0.5,Python
14v92v5,jrcph68,"Imagine a Smalltalk with a good static type system (Griesemer introduced a similar one to Go), a highly optimized VM (Bak and Holze were the wizards behind V8), and an integration with the Web that was never fully realized.",0.19199999999999998,Go
14v92v5,jrgdgdy,"You've heard of Ada, but nobody knows of Babbage.",0.0,Ada
14v92v5,jrgdgdy,(Named after collaborators Ada Lovelace and Charles Babbage.),0.0,Ada
14v92v5,jrbkpty,HyperCard  ActionScript,0.0,ActionScript
14v92v5,jrcqcuy,"Eiffel, Oberon.",0.0,Eiffel
14v92v5,jrccdbt,Pascal,0.0,Pascal
14v92v5,jrdxe02,Eiffel.,0.0,Eiffel
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,Pascal
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,Ada
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,C++
14v92v5,jrc8bn8,Not sure about ActionScript.,-0.25,ActionScript
14v92v5,jrdoys0,> ActionScript  Now you made me sad.,-0.5,ActionScript
14v92v5,jrdoys0,"ActionScript was Flash's version of Javascript, based on the same ECMAScript standard, but *better*.",0.16666666666666666,ActionScript
14v92v5,jrc5m1y,> ActionScript  RIP - We had some good times,0.7,ActionScript
14v92v5,jrdhmul,"Modula-3  I have a habit of picking the wrong horse, and was **so** chuffed to have picked a nice, clean GC'ed language with modules as my next language after C, instead of C++.",0.11666666666666667,C
14v92v5,jrdhmul,"Modula-3  I have a habit of picking the wrong horse, and was **so** chuffed to have picked a nice, clean GC'ed language with modules as my next language after C, instead of C++.",0.11666666666666667,C++
14v92v5,jrfmlnt,Eiffel's last update was a few months ago.,-0.1,Eiffel
14v92v5,jrcds5r,"But object pascal versions are still alive, Delphi and other OSS like Free pascal and Lazarus.",0.125,Delphi
14v92v5,jrcds5r,And I would not be surprised if Pascal is still used as first language on some places,0.175,Pascal
14v92v5,jrhmv4z,"I love OOSC as a book, and found Eiffel: The Language ""interesting"", but the new version was a more complex and less beautiful language.",0.2885281385281385,Eiffel
14v92v5,jrhmv4z,"One thing that made me question Meyer's sincerity as a language developer was how in OOSC, he argued passionately that Eiffel had no case statement, because with OOP, it wasn't needed.",-0.05,Eiffel
14v92v5,jrhmv4z,"Then in the next Eiffel version a case statement had been added, with no acknowledgement that the previous stance had been wrong.",-0.2222222222222222,Eiffel
14v92v5,jrhmv4z,"I just now had a look at the EiffelStudio site, and it would seem that Eiffel is still alive.",0.1,Eiffel
14v92v5,jrjebiz,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal,  There were a slew of PL/\* languages around the end of the 70s.",0.4333333333333333,Pascal
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,Pascal
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,Fortran
14v92v5,jrjebiz,"I did later buy a book about C, but I was unimpressed and sold it again (at quite a loss actually).",0.0,C
14v92v5,jrjebiz,"But then Fortran has changed a lot more, and it's still 'Fortran'.)",0.5,Fortran
14v92v5,jru11ss,"It was a hodge podge of languages: Python for the AI/gameplay scripting, C++ for the game engine, an XML-based in-house GUI editor for creating interactions, and a visual programming tool for animation state machines.",-0.2,Python
14v92v5,jru11ss,"It was a hodge podge of languages: Python for the AI/gameplay scripting, C++ for the game engine, an XML-based in-house GUI editor for creating interactions, and a visual programming tool for animation state machines.",-0.2,C++
14v92v5,jreeo2b,What semantics do JavaScript classes have or lack that you find makes them “improper”?,0.0,JavaScript
14v92v5,jreao66,*Added sigh*  What is it with people thinking that C syntax is clear or stylish?,0.3,C
14v92v5,jribhrl,Actually I meant gnu Eiffel/Smart Eiffel projects.,0.0,Eiffel
14v92v5,jrkkuyu,"PLZ/SYS was intended as a system programming language, and the idea was that mainstream languages like BASIC, FORTRAN and COBOL would also be developed for this Pcode system, which ran on Zilogs RIO system for Z80, and on ZEUS (Unix) for the Z8000.",0.05,COBOL
14v92v5,jregpyw,"JavaScript didn't have classes back then, only prototype-based inheritance.",0.0,JavaScript
14v92v5,jregpyw,"Which is powerful, but doesn't lead to a very smooth experience for beginners who were expecting ""Java in the browser"".",0.41000000000000003,Java
14v92v5,jrj08ah,"Why should they maintain for example CHILL or Eiffel, if there are no users of the languages?",0.0,Eiffel
14v92v5,jrd0n4w,"Ive been developing with Delphi since Delphi 3 and while the IDE and developer experience is (mostly) absolutely phenomenal, the language/compiler itself lacks a lot of features or are implemented in a very annoying way which are handled much more nicely in modern languages.",0.05,Delphi
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,Delphi
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,C
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,Rust
14v92v5,jrd0n4w,I use Delphi for new projects because Ive built a huge framework which provides most of the functionality I miss over the years.,0.34545454545454546,Delphi
14v92v5,jrd0n4w,"But I feel like I will switch to Rust as soon as a matured, native and multi os GUI platform is available... :/",0.07500000000000001,Rust
14v92v5,jrnuxjw,"Like I said, it's a lot simpler in some ways than Pascal (it doesn't even have a Boolean type, nor does it have floating point), but its syntax is interestingly strange in that "","", "";"" and "":"" are considered delimiters that are entirely ignored (except for separating tokens like space), which results in the weird reversed Algol-like declaration syntax: ""a b c integer"".",-0.18333333333333335,Pascal
14v8lsz,jrbwf6j,Its ideas are mixing TypeScript's type system and general syntax with fuctional features such as immutability and flow control without loops (like Ruby - you use functors i.e.,0.02500000000000001,TypeScript
14v8lsz,jrbwf6j,Its ideas are mixing TypeScript's type system and general syntax with fuctional features such as immutability and flow control without loops (like Ruby - you use functors i.e.,0.02500000000000001,Ruby
14v8lsz,jree2if,"I agree it's not the ergonomic or simple (kinda like Python having you join arrays for performance) but it's not bad, especially if they have a reason not to give a concatenation operator or method to strings.",0.11666666666666664,Python
14v8lsz,jre6gsz,": Pascal, Modula2, Oberon, Python 2, [Seed7](https://seed7.sourceforge.net), ...",0.0,Pascal
14v8lsz,jre6gsz,": Pascal, Modula2, Oberon, Python 2, [Seed7](https://seed7.sourceforge.net), ...",0.0,Python
14v8lsz,jre6gsz,": Oracle, SQLite, SQL Server, MySQL, PostgreSQL, ...  Java generics also use `<>` (this is neither concatenation nor not equal).",0.0,Java
14v8lsz,jre6gsz,"For that reason [Seed7](https://seed7.sourceforge.net) uses [&](https://seed7.sourceforge.net/libraries/string.htm#(in_string)&(in_string)) for string concatenation (Basic, Ada, and other languages also decided for `&`):      msg := ""hello world"" & "" @ "" & timestamp();  This string concatenation does no type conversions (unlike the `+` string concatenation of Java).",-0.0625,Ada
14v8lsz,jre6gsz,"For that reason [Seed7](https://seed7.sourceforge.net) uses [&](https://seed7.sourceforge.net/libraries/string.htm#(in_string)&(in_string)) for string concatenation (Basic, Ada, and other languages also decided for `&`):      msg := ""hello world"" & "" @ "" & timestamp();  This string concatenation does no type conversions (unlike the `+` string concatenation of Java).",-0.0625,Java
14v8lsz,jrei91v,"For example Lua uses `..`, which strikes me as unintuitive, while your `<>`, as  u/ThomasMertes mentioned, often means `not equal`, as it does in my syntax, so may be confusing to some.",-0.15,Lua
14v8lsz,jrei91v,"So that impenetrable C++ code I sometimes come across could really be quite simple after all, if I just ignore 90% of the syntax?",0.1,C++
14v8lsz,jrefwoh,Lua uses `..` but I don't like it that much.,0.2,Lua
14v8lsz,jrl5l2s,"In Python, for instance, there's both, and the file example would be `open(f""{path}{file}{ext}"")`.",0.0,Python
14v8lsz,jrla25r,"If the destination is represented as `D`, then my version results in these operations behind the scenes:      D := """"     D +:= path     D +:= file     D +:= ext  So the string adds are still there, but now they're the slightly more elaborate inplace versions!",0.43125,D
14v8lsz,jrlc657,"In Python specifically, more complex expressions are allowed, but that doesn't have to be so in your language.",0.1,Python
14v8lsz,jrlc657,"Not in Python (nor some other languages with unicode strings), because `str` is immutable for good reasons.",0.2875,Python
14v8lsz,jrlc657,"However, it has drawbacks, and could've been better off if implemented in a slightly different way (`Option<&T>` in Rust, for instance, is optimized to represent `None` with a null reference, but unlike a raw null pointer, this cones with convenient and simple compile-time guarantees).",0.0673076923076923,Rust
14uttxo,jr9ddjb,"This IMO qualifies, check the use of EBNF notation in the Go language specification: https://go.dev/ref/spec#Notation",0.0,Go
14uttxo,jrbqegb,Go to statements         4.4.,0.0,Go
14usw9q,,"For chaining calls I have pipelines, as in F#, Elixir or Elm: `1 |> isNegative ==> isNegative(1)`.",0.0,Elixir
14usw9q,,"For chaining calls I have pipelines, as in F#, Elixir or Elm: `1 |> isNegative ==> isNegative(1)`.",0.0,Elm
14usw9q,jre5xfc,"The Elm and Purescript documentation compliments this really well, since you get the type of your ""hole"" and just search for it across the available packages.",0.30000000000000004,Elm
14usw9q,jre5xfc,The only downside is that the Haskell syntax for declaring generic parameters for whatever reason puts the generic constraints before the argument/return types.,0.0,Haskell
14usw9q,jre5xfc,"This can make it quite opaque to scroll through purescript or Haskell docs, but with Elm docs it's quite nice.",0.6,Haskell
14usw9q,jre5xfc,"This can make it quite opaque to scroll through purescript or Haskell docs, but with Elm docs it's quite nice.",0.6,Elm
14usw9q,jre5xfc,"(Seriously, polymorphism is nice but does Haskell have to be *that* polymorphic?)",0.13333333333333333,Haskell
14upgz1,jr8ylk2,Many developers use C as their destination P.L.,0.5,C
14upgz1,jr966ni,I guess you should know some principles on how Assembly works.,0.0,Assembly
14upgz1,jr9dtpu,"I can say that if you target C or C++ as your final target, it would suffice.",0.0,C
14upgz1,jr9dtpu,"I can say that if you target C or C++ as your final target, it would suffice.",0.0,C++
14upgz1,jr9dtpu,"Especially if you want to define a language like JavaScript, there's no point to work with LLVM, SSA or assembly.",0.0,JavaScript
14upgz1,jratcwd,"LIBFFI is one heavyweight and complex solution, consisting of C code plus various platform-specific ASM files.",-0.15,C
14upgz1,jratcwd,"It requires a C compiler to process, and is generally horrible to build and an undesirable dependency.",-1.0,C
14upgz1,jrawjzz,"Unless you're writing another ""C replacement language"" as a design goal, the compilation step can happen later.",0.0,C
14upgz1,jr8zpyc,So ABI stability simply because C's ABI is stable for platforms.,0.0,C
14upgz1,jr9996h,"* It can also be run from the terminal in the way Python scripts are ""interpreted"" (fast-compiled to bytecode and then run on a VM, except mine will be fast-compiled to WASM and run via a WASI runtime).",0.0,Python
14upgz1,jr9996h,"* Most likely, like Python, a file will represent a single module, with directories being used to group them (though Rust's crate tree structure also looks appealing as the basic build unit).",0.18571428571428572,Python
14upgz1,jr9996h,"* Most likely, like Python, a file will represent a single module, with directories being used to group them (though Rust's crate tree structure also looks appealing as the basic build unit).",0.18571428571428572,Rust
14upgz1,jreospd,I'm familiar with C and know basic pointer arithmetic (and manipulating C arrays with it).,0.1875,C
14upgz1,jr9kkd1,"These are some characteristics of my own systems language:  * Primarily supports Windows on x64 via direct native code generation * Other 64-bit platforms can be supported via transpilation to C, although that doesn't cover all language features * The compiler is fast enough to run programs directly from source (up to a certain size anyway; 500K lines would take one second to compile) * There is no REPL; this would be impractical in this language as it is strictly AOT: all code must be compiled before calling the entry point * There was an experimental, discrete VM target with an interpreter.",0.15892857142857145,C
14upgz1,jr9lzet,"Also, preferably it should be a ""quick 0 to 60"" type language like C (and Go and Zig from what I hear).",0.3333333333333333,C
14upgz1,jr9lzet,"Also, preferably it should be a ""quick 0 to 60"" type language like C (and Go and Zig from what I hear).",0.3333333333333333,Go
14uc5t2,jrobor3,It has the same kind of esoteric vibes that APL and Nock give off!,0.375,APL
14ua5dx,jr70895,"I'm pretty sure Swift does it, so do HotSpot (VM) and Go.",0.375,Swift
14ua5dx,jr70895,"I'm pretty sure Swift does it, so do HotSpot (VM) and Go.",0.375,Go
14ua5dx,jreh2nv,The idea for Swift was initially to just move allocations to the heap for ref counting or on the stack depending on what the analysis showed.,0.0,Swift
14ua5dx,jr7c7hy,"I considered a lot of programming languages to write my compiler in (C, Zig, F#, OCaml, Standard ML, Crystal,...), and when I got bored of my indecisiveness about languages, I picked V without thinking about it much.",-0.09999999999999999,C
14ua5dx,jr7c7hy,"I considered a lot of programming languages to write my compiler in (C, Zig, F#, OCaml, Standard ML, Crystal,...), and when I got bored of my indecisiveness about languages, I picked V without thinking about it much.",-0.09999999999999999,Crystal
14ua5dx,jr7nhrt,"a borrow checker as in Rust), or a runtime cost (e.g.",0.0,Rust
14ua5dx,jr6gckn,If I'm not mistaken that's how Rust does it.,0.0,Rust
14ua5dx,jrdbwnz,I took following snippet from generated C code: ``` void _v_free(voidptr ptr) {     #if defined(_VPREALLOC)     {     }     #elif defined(_VGCBOEHM)     {     }     #else     {     }     #endif } ``` `_v_free` is the the function which is suppose to do the deallocation.,0.0,C
14ua5dx,jr6ytec,"It is possible, but as a note, Rust doesn't prevent all leaks.",0.0,Rust
14ua5dx,jr8z3jv,&#x200B;  >If I'm not mistaken that's how Rust does it.,0.0,Rust
14ua5dx,jr8z3jv,"Other programming languages have offered viable solutions, different strategies, and alternate directions, besides what Rust is doing.",-0.041666666666666664,Rust
14ua5dx,jr7utm5,"smart pointers in C++, but basically this is the idea behind destructors.",-0.09285714285714287,C++
14ua5dx,jr93g82,"C#, for example, uses the `stackalloc` keyword for this.",0.0,C
14ua5dx,jr9oy8u,"I'm not a Rust aficionado so maybe I'm not fully understanding the implications of ""borrow checker"", but for a language without mutable references, you just need a type system utilizing some kind of substructural logic that fits your use case, be it linear, affine etc.",0.6,Rust
14ua5dx,jr6nmku,"Not necessarily, COBOL for example divides variables into sections, where each section has a specific lifetime requirement.",0.0,COBOL
14ua5dx,jr6nmku,COBOL slightly abstracts this lifetime requirement in the syntax.,-0.16666666666666666,COBOL
14ua5dx,jr6nmku,"In COBOL you can't return a variable from a function's  local-storage or working-storage directly, you have to move it into the linkage section.",0.1,COBOL
14ua5dx,jr6nmku,"Also, you can't return or pass file descriptors around in COBOL, that would be unsafe since it has native resources associated with it, so file descriptors are only valid in the scope that they were declared.",0.0,COBOL
14ua5dx,jr6j14y,"Yes if you do it the Rust way, but I wonder if there's another set of constraints that would work.",0.0,Rust
14ua5dx,jr8091o,"As a note to the note, off the top of my head the only two cases of leaks that Rust doesn't catch is 1) explicitely leaking and 2) Reference-counted cycles.",0.25,Rust
14ua5dx,jr7udyp,in Python),0.0,Python
14ua5dx,jr995py,Depends on what kind of Rust.,0.6,Rust
14ua5dx,jr995py,"AFAIK a restrictive Rust without unsafe, forget, Rc and Arc (and maybe some other features) could probably do it.",-0.125,Rust
14ua5dx,jr7uzhx,"I've no idea if this is supposed to be a performant version of it, or if that relies on using Tiny C backend.",0.0,C
14ua5dx,jr7uzhx,"This is about the same time as Tiny C working on a version in pure C, but the executable was 23MB.",0.07142857142857142,C
14ua5dx,jrc6hen,How about you go back to shilling Rust then.,0.0,Rust
14ua5dx,jr6o5z9,I haven't studied COBOL and I couldn't grasp any of that.,0.0,COBOL
14ua5dx,jr7um54,People acting like Rust is the only way are fooling themselves.,0.0,Rust
14ua5dx,jryljtv,in Python  [Python's GC handles cyclic references without leaking memory.,0.0,Python
14ua5dx,jr79v4u,COBOL source code is syntactically separated into divisions and sections.,0.0,COBOL
14ua5dx,jr79v4u,"The key thing here, is that COBOL doesn't allow you to return variables directly from other sections.",-0.008333333333333331,COBOL
14ua5dx,jrc5rfm,"In one like C and like mine, applying gcc-class optimisation might only double performance, but at a cost of taking up to 100 times longer to build, so it's not worth doing for routine development.",-0.049999999999999996,C
14u1brp,jr5k9do,"This problem occurs in C too, where the types are `T*[]` for `array of pointer`, and `T(*)[]` for pointer to array, or somthing like that.",0.25,C
14u1brp,jr5k9do,"It was actually solved by Algol68 (four years before C first appeared), by using a left-to-right syntax.",0.125,C
14u1brp,jr5k9do,"C tried to make it correspond, and the result was disastrous.",-0.7,C
14u1brp,jr5q4zw,I've had a similar problem working with C where this can become ambiguous.,0.0,C
14u1brp,jr6h62s,"I never really liked how TypeScript has `Array<T>` (good - ""Array of T"") but then has a syntax sugar of `T[]`, which feels backwards.",0.19999999999999998,TypeScript
14u1brp,jra5psl,Just read through the linked page and wanted to say that Ruby handles array indexing the same way!,0.0,Ruby
14u1brp,jr65x1m,This issue was notorius in C++ until C++11 and required you to put an extra space.,0.0,C++
14u1brp,jr62sz8,"It's ugly, but you rarely see this in actual C code.",-0.13333333333333333,C
14u1brp,jr62sz8,"The reason: nobody uses pointers to arrays (`T(*)[]`) in C; the universal idiom is to use a `T*` type instead (pointer to the first element), even though this is unsafe: `A` might not be an array, but C allows indexing of pointers anyway.",0.16666666666666666,C
14u1brp,jr62sz8,"Yet another is pointer-to-function `F`, called as `(*F)(x)`, but this is rarely seen too, because one of C's quirks allows you to just use `F(x)`.",0.3,C
14u1brp,jr62sz8,"So, it's all very well saying that having extraneous parentheses is OK, but even C,  not averse to punctuation, avoids using them as much as possible!",0.2333333333333333,C
14u1brp,jr62sz8,"Personally I prefer a postfix dereference operator (mine was based on Pascal's `^`), but as I said it's your choice.",0.0,Pascal
14u1brp,jr62sz8,"Go with `@`, whether prefix or postfix, and see what sample programs look like.",0.0,Go
14tvuta,jr4kw0w,"As far as programming history goes, don't forget about the array languages, like APL.",0.1,APL
14tvuta,jr4kw0w,"In fact, Jeremy Gibbons has an article, [Origami Programming](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf), which explains (via Haskell) more than you ever wanted to know about reduce.",0.5,Haskell
14tvuta,jr4kaj7,Probably APL.,0.0,APL
14tvuta,jre45ig,"I believe it was John Backus doing research for good functional primitives, and he found out that 90% of for loops in the Fortran compiler were either filter, map, or reduce.",0.7,Fortran
14tvuta,jr51b2v,"That said, some commentators have mentioned APL, and quoting the Wikipedia page linked above:  > Plankalkül has drawn comparisons to the language APL",0.25,APL
14tvuta,jr509ln,"I’ve always assumed Lisp, but since it’s older than I am, and older than most living people for that matter, I guess it doesn’t matter too much at this point.",0.2583333333333333,Lisp
14tvuta,jr9g2dz,"When I said ""earlier Lisps"" I was thinking Scheme but of course Scheme is notoriously minimalistic.",0.0,Scheme
14tvuta,jr9g2dz,Tbh it doesn't make sense to have a Lisp without filter map reduce.,0.0,Lisp
14tvuta,jr9g2dz,"Edit: having read the document, Lisp 1 does indeed not have built in filter or reduce functions.",0.0,Lisp
14tvuta,jr9g2dz,"There's a select, which is like first() in C#, and a reduce, which is unrelated to functional array manipulation.",0.25,C
14tvuta,jr9g2dz,"Edit 2: I read through the Chinual and found that, in Lisp Machine Lisp, filter is called ""subset"" or ""rem-if-not"".",0.0,Lisp
14tvuta,jr4s8c5,"This is probably close to correct, but with the following caveats:  * Original APL did not have a real `map` construct where you could apply an arbitrary function to each element of an array.",0.11875,APL
14tvuta,jr4s8c5,"Instead, all APL operations were implicitly rank-polymorphic.",0.0,APL
14tvuta,jr4s8c5,"The actual APL version of `map` (called ""each"") is much younger.",0.0,APL
14tvuta,jr4s8c5,"* APL's `filter` operation was also somewhat different, as it took a boolean array instead of a function.",0.0,APL
14tvuta,jr4s8c5,"* APL's `reduce` was pretty much what you'd expect it to be however, although limited to a handful of built-in functions IIRC.",0.1261904761904762,APL
14tvuta,jr4s8c5,"The connecting thread here is that APL didn't have first class functions, so the modern filter/map/reduce operations would not be expressible.",0.225,APL
14tvuta,jr4s8c5,"I'm not sure when they first occurred in their modern form, but I think Lisp was the first reasonably widespread language with first class functions, so I'd point to somewhere in that vicinity.",0.15,Lisp
14tvuta,jr9gb05,"Yeah, the fact that it's the oldest functional language and that it's list-based and loops through recursion makes it a safe bet for being the first to implement filter map reduce, but surprisingly older versions of Scheme don't have built in implementations of filter and reduce, and somehow I was dumb enough not to consider there are other old Lisps besides Scheme.",0.0738095238095238,Scheme
14tk6p4,js2t9ev,"I did want to minimize people bringing old baggage, and I like that in C++ for many years the idea of a concept suggested signature-based polymorphism (aka duck typing).",0.3,C++
14tjakk,jr2ybnf,">Most programming languages I know use `}` for all of those things,  That's C having far more influence than it deserves.",0.3,C
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,Pascal
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,Lua
14tjakk,jr2ybnf,"Plus there are a couple  more categories: the ones using S-expressions so `)` is used for everything, and those using no terminator at all (like Python and Nim).",0.5,Python
14tjakk,jr2ybnf,"As for the reasons for those using only `End`, with Pascal and Algol60, `Begin ... End` are a form of parentheses just like `{ ... }` and `( ... )`.",0.0,Pascal
14tjakk,jr5747e,Erlang has many ways of ending block structures and it's a mess.,0.1625,Erlang
14tjakk,jr5lia7,> That's C having far more influence than it deserves.,0.3,C
14tjakk,jr4jc1w,"HTML template languages often have ways of separating delimiters like this, so that the meta-level template blocks don’t have to be strictly nested in the object-level HTML blocks.",0.0,HTML
14tjakk,jr663lx,"Take this example from C (which often allows braces to be optional: yet another possibility):      if (a) {b; c;} else {d; c;}  The two blocks are separated by `} else {`; think of how many ways there are of placing those, occupying anything from 1 to 3, lines, with  `}` possibly sharing with the previous line,  maybe `{` with the next.",0.08333333333333334,C
14tjakk,jr663lx,"C's approach is to use no braces for a block of one statement, and braces otherwise, but that can be odd too:      if (a) b; else {d; c;}  Also, a syntax that doesn't have parentheses around the condition, needs something that separates `a` from `b`; another brace?",-0.16666666666666666,C
14tjakk,jr4rvt5,"Past that, it seems like what you're getting at is meta-programming, especially with the HTML part.",-0.125,HTML
14tjakk,jr4rvt5,"As someone said, that's essentially just goto:      retryable: someAction();     if(allowRetry() && shouldRetry()) {         backoff();         goto retryable;     }  That's actually shorter, although that's partially due to C syntax, and IMO much easier to follow mentally.",-0.004999999999999999,C
14tjakk,jr4rvt5,"Second, the HTML example looks like it's more or less just permuting over the combinations of essentially singly nested arrays.",0.0654761904761905,HTML
14tjakk,jr4xrrc,"C also has something I'd perceived as an ambiguity:      do ; while (c) {}  Does that `while` end the `do` statement, or does it start a new `while` statement?",0.13636363636363635,C
14tjakk,jr3ndba,"BTW I sometimes use an alternate, more compact syntax with parentheses:      if a then b else c fi       # or:     ( a | b | c )          record R = ... end          # or:     record R = (...)  This form is more suitable for one-liners.",0.00833333333333334,R
14t96qf,,"Great examples are Crystal and Codon (a Python ""subset"", which treats the language like a statically typed one).",0.8,Crystal
14t96qf,,"Great examples are Crystal and Codon (a Python ""subset"", which treats the language like a statically typed one).",0.8,Python
14t96qf,,"I am barely convinced that such a language would enable the compiler to do even deeper and interesting optimizations than the classical ones (but still mind blowing) applied to languages such as C, C++ (an example is Zig, which is even more optimizable AFAIK because of its very clever approach to Meta Programming, isn't it?",0.18095238095238095,C
14t96qf,,"I am barely convinced that such a language would enable the compiler to do even deeper and interesting optimizations than the classical ones (but still mind blowing) applied to languages such as C, C++ (an example is Zig, which is even more optimizable AFAIK because of its very clever approach to Meta Programming, isn't it?",0.18095238095238095,C++
14t96qf,,"The compiler informs you that \`data\` must be something iterable, which means it must implement attributes      fn len()    // used in foreach and return     fn nth(idx) // used in foreach  and then each iterated element should implement specific attributes as well      static default // used as base for the sum     fn add()       // used to sum all the elements  &#x200B;  **Why I don't like the idea of making type annotations just optional**  What seems to happen in Crystal code is that users just end up using explicit typing over implicit one, because:  * The language allows you to do it, so for Crystal users it's easier to just reject a new way to code and continue using the classic approach with types * The compiler doesn't explain to you why a function raises compilation errors when you pass a wrong argument  &#x200B;  **Ways to make it easier for the user to spot wrong arguments**  Using this approach may be hard for the user to understand what to pass to a certain function of an X library, maybe not well documented.",-0.11937229437229441,Crystal
14t96qf,,"One solution would be just printing some sort of compile time stack trace of function instantiations, like Clang does when using \`auto\` on parameters in C++.",0.0,C++
14t96qf,jr1a3ha,"You can do that in any sort of MLy language to be honest, especially if you don't use advanced type-level magic like it's common in Haskell.",0.24,Haskell
14t96qf,jr1l2ty,You can see this in action when using complicated C++ templates or writing Haskell code without enough type annotations.,-0.13333333333333333,C++
14t96qf,jr1l2ty,You can see this in action when using complicated C++ templates or writing Haskell code without enough type annotations.,-0.13333333333333333,Haskell
14t96qf,jr1l2ty,"There's a good reason why the Haskell community has developed the convention that all top-level declarations should have type declarations, and why Rust promoted that contention to a rule.",0.39999999999999997,Haskell
14t96qf,jr1l2ty,"There's a good reason why the Haskell community has developed the convention that all top-level declarations should have type declarations, and why Rust promoted that contention to a rule.",0.39999999999999997,Rust
14t96qf,jr1jd1k,"Haskell in particular was designed such that in _any valid Haskell program_, with no type annotations at all, the types can be fully inferred.",0.08333333333333333,Haskell
14t96qf,jr30r3j,"ReScript is syntactic sugar on OCaml (same AST, different parser) designed to transpile to JavaScript, and the syntax is more comfortable if you’ve come from a C or JS background.",0.225,JavaScript
14t96qf,jr30r3j,"ReScript is syntactic sugar on OCaml (same AST, different parser) designed to transpile to JavaScript, and the syntax is more comfortable if you’ve come from a C or JS background.",0.225,C
14t96qf,jr2ma88,"I see the many comments that so and so functional language that does it, frankly no one cares, it's imperative and C level performance or go home.",0.5,C
14t96qf,jr1kwo9,Modern Java has this.,0.2,Java
14t96qf,jr6nl67,I guess there is a good reason Rust requires explicit types at the function boundary and why functional languages have this at least as the best practice.,0.4666666666666666,Rust
14t96qf,jr51m0f,"Using typeclasses ala Haskell, a and b would be inferred as: `(Read a, Num a) => a` That is, some type a, for which the appropriate methods (in this case read and (+)) are defined, but we don't yet know concretely what it is.",0.325,Haskell
14t96qf,jr3n3c9,It is common to write Rust code that requires explicit type annotations.,-0.3,Rust
14t96qf,jr274pq,I already don't write types in Rust until I have to (due to ambiguity and choices).,-0.125,Rust
14t96qf,jrh8kdo,"It's an interesting language, but it does not match C for performanc https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/ocaml-gpp.html, and thus is useless for a variety of cases, e.g.",0.0,C
14t96qf,jr3cpw4,The implementation of ML languages is not based around copying the body of a function like Crystal.,0.0,Crystal
14t7ig2,jr4znt0,"Val originates from taking Swift's double nature of both reference and value semantic, and pushing the value semantic part and only it to the maximum.",0.0,Swift
14t7ig2,jr4znt0,"Also, they think Val is easier to understand than Rust lifetimes and borrow checker, and therefore decided to try and develop Val as a mainstream programing language.",0.0,Rust
14ssjiv,jr13j4h,It's something of a paradox :)  What I think is:  - It's 10x-100x harder to write a production C compiler (Clang/LLVM) than a toy C compiler - It's 10x-100x harder to write a production shell (our goal) than a toy shell - C/C++ are ~10x bigger than shell?,0.07500000000000001,C
14ssjiv,jr13j4h,"Open source is really like those sci-fi books where the civilization is running, but nobody knows how the tech works anymore  Shell is sprayed all over the foundations of software, both at build time and runtime (and it's more popular now than EVER!",0.3625,Shell
14ssjiv,jr13j4h,"due to the cloud and embedded systems becoming Linux systems)  But there are lots of parts that only a few people know about  ---  To be honest we still need a lot of help, and I think the people on this sub have the right skills - e.g https://www.oilshell.org/blog/2023/03/roadmap.html  If anyone likes generating C++ code, there are some exciting projects there, like ""boxless optimization"" to remove a level of boxing from the interpreter  Generating C++ is the best of both worlds IMO -- you don't have all the pitfalls of writing it by hand (e.g.",0.28883928571428574,C++
14snerw,jqzzirf,:D,1.0,D
14sbn35,,"That makes such a loop a *list-comprehension*, a slightly different beast, which in Python has dedicated syntax:      x = [elem + 2 for elem in [1,2,3,4]]  In Pyret, the same example is:      x = for map(elem from [list: 1,2,3,4]):       elem + 2     end  Pyret is touted as being *designed to serve as an outstanding choice for programming education*, so I'm surprised it makes the basics so hard: the original BASIC gave you `for i = a to b`; I couldn't tell you how it would be in Pyret.",0.08541666666666667,Python
14sbn35,jqwyo6c,Pyret is pretty much a Scheme with a facelift to make it more accessible.,0.33125,Scheme
14sbn35,jqxf5hw,"I can't speak for the Pyret designers, but: when you have `for i = a to b`, you have `for i = a to b` and you need a whole lot more other things that will need to be taught as well, such as list comprehensions in Python.",0.14375,Python
14sbn35,jqxf5hw,"(I invented this kind of 'for' expression, in a post to comp.lang.lisp in the 90s where it was a Lisp macro called 'with'.",0.6,Lisp
14sbn35,jqxf5hw,Later it went into [my own Lisp](https://github.com/darius/cant) as 'for'.,0.3,Lisp
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,Ruby
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,Julia
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,Lisp
14sbn35,jqxi2l2,">It's used to demonstrate functions-as-values,  That was demonstrated by `d-dx` (another source of confusion: I haven't used minus signs inside identifiers since I wrote some COBOL.",-0.1,COBOL
14sbn35,jqxkwif,">(I invented this kind of 'for' expression, in a post to comp.lang.lisp in the 90s where it was a Lisp macro called 'with'  Yes I noticed that Lisp was also open-ended when it came to loops, with endless flexibility and possibilities (from looking at CLisp).",0.2375,Lisp
14sbn35,jr06ve7,"(My `head` and `tail` functions were named after the Haskell versions, but mine are not lazy.)",0.125,Haskell
14sbn35,jqzcs0w,"To give an example in a language I'm more familiar with, Haskell's `take`, which takes n amount of items from the start of a list and returns a new list of those items, is auto-curried.",0.3371212121212121,Haskell
14sbn35,jqzcs0w,"This is why most Haskell functions don't pass the ""object"" first (in this case the list) because it's the most likely to vary rather than being fixed.",0.27,Haskell
14sbn35,jqxwsy0,"The idea is only that if you wrote out the call by hand, it'd have a readability problem exactly like the readability problem of (Scheme)  ``` ((lambda (x y z) ...)    (compute-foo)    (compute-bar)    (compute-baz)) ```  which the `let` expression was invented to improve on.",0.125,Scheme
14sbn35,jqwxut3,"If I would pick a language to teach beginners for ease of teaching it would neither be Python, JS nor a functional language of any kind.",0.6,Python
14sbn35,jqyet2k,"Maybe that's how it works in languages like Lisp, but I'd implement loops using lower-level features, not higher-level ones.",0.0,Lisp
14sbn35,jqxqaql,"And from looking at open-source projects, it's not common elsewhere either (except programs written in Rust which seem to do little else except pattern-matching).",-0.018750000000000003,Rust
14sbn35,jr0janv,It means I can also do simple embellishments:      for i in range do         redo          # various multi-level loop controls         exit         next     else              # (from Python) execute on normal exit     end  It becomes harder to incorporate this stuff when the concept of iteration revolves around traversing some linear data structure instead of just existing independently.,0.008333333333333331,Python
14sbn35,jqz4fgo,"Going back to Pyret, from what I've read, the designers see equational reasoning about programs as a big deal and not just for the Haskell freaks who like big words like ""equational reasoning"".",0.0,Haskell
14sbn35,jqxudbq,Throwing someone head first in Scheme might be significantly harder than easing them into functional programming with Pyret.,0.075,Scheme
14sbn35,jqxudbq,However the question is whether it compares favourably with say Pascal or BASIC if the intention is *just to teach people the basics of programming*.,0.0,Pascal
14sbn35,jqxudbq,"If the intent is to later just use functional programming, then clearly using something like BASIC or Pascal would point people in the whole wrong direction – they'd have to do a 180 to get aligned with functional programming.",-0.039999999999999994,Pascal
14s9pnm,,"It seems to be common knowledge that the D compiler has very fast clean compile times, even though it's packed to the brim with language features.",0.10888888888888891,D
14s9pnm,,"**Question:** Are there any blog posts or articles digging into the design of the D compiler, or some of its implementation choices?",0.0,D
14s9pnm,,"There a handful of articles on the [official D blog](https://dlang.org/blog/), but they mostly don't cover compiler internals.",0.5,D
14s9pnm,,And the personal blogs of some of the D contributors seems rather sparse.,0.0,D
14s9pnm,jqxpuem,There's quite a lot of info on the compiler source on the D Wiki.,0.0,D
14rjg05,jqygp6g,"So like, TLDR, we can write C code to an API that generates code like the way LLVM does, but with more cowbell?",0.5,C
14rfz9f,jr9hcvp,"Rust also has exceptions, and they're very frequently used.",0.13,Rust
14rfz9f,jraenfd,"What would be ""Rust exceptions""?",0.0,Rust
14rfz9f,jrata2a,"Yes, Rust's panic is a form of unchecked exception, which can be caught with catch_unwind.",0.0,Rust
14rfz9f,jrata2a,It's essentially the same as in Java or C++.,0.0,Java
14rfz9f,jrata2a,It's essentially the same as in Java or C++.,0.0,C++
14re46t,,I’m considering utilizing C as a compilation target for an unannounced language;  1.,0.0,C
14re46t,,Any good libraries for building C Source?,0.7,C
14re46t,,Any good libraries aside from TinyC to compile the C into an Executable?,0.7,C
14re46t,jqrs2af,"This is my experience from a previous language that I've abandoned:  - C compilers don't like huge generated functions, had to use TinyCC to even able to compile (the self build of a compiler took about 2mins still, painfully slow for the development - don't try to selfhost too early) - the generated binaries were huge (I did inline some stuff but mostly things like refcounting and other small rudimentary stuff, still it added up a lot) - the performance boost (when I managed to compile it in GCC by splitting the huge functions) is not much unless your language is pretty much just C with a different syntax, you're still required to do your own optimizing compiler if you want performance gains - general linking with arbitrary function names (eg.",0.1387254901960784,C
14re46t,jqry4o4,My [language project](https://norstrulde.org/language84/) uses C as a target language.,0.0,C
14re46t,jqry4o4,"If you follow the “browse” links and look for files named “84_stable.c” and “c.84”, you can find the generated C code and the compiler component that writes it out for each release of the self-hosted compiler.",0.0,C
14re46t,jqry4o4,"At the start, I would put all of the generated C code into one giant C function with lots of labels and gotos.",0.0,C
14re46t,jqry4o4,"Later, I changed my approach to iteration and that made it easier to turn source functions into isolated C functions.",0.0,C
14re46t,jqry4o4,"One trick I found helpful was to use the C extensions provided by gcc and clang for things like arithmetic overflow checking, scoped labels, and statement expressions.",0.0,C
14re46t,jqrqv56,There are some very good Scheme implementations that compile to c like chicken.,0.15499999999999997,Scheme
14re46t,jqtqyi6,"I've used C as an optional backend (for when I want code to build on Linux instead of Windows, or make use of an optimising compiler).",0.0,C
14re46t,jqtqyi6,"When used as an IL for my own systems language, which although not much higher level than C, it still has enough mismatches:  * My `int` types, literals etc are `i64/u64`; C's literals are `i32/u32` * My string literals have a type roughly equal to `u8*`; C's strings are `char*`, but `char` is a type with unspecified signedness that is neither `i8` nor `u8` * If I want to use C's `puts()` say from my language, via its FFI, I will need to declare `puts` in my syntax using `u8*` equivalant.",0.11875,C
14re46t,jqtqyi6,"When transpiling those, the declarations have to be written as C syntax, but compilers will complain that my `puts(u8*)` doesn't match the standard library version.",0.125,C
14re46t,jqtqyi6,* My arrays have value semantics; C's arrays always decay to pointers * My syntax is expression-based (statements and expressions can be mixed).,0.0,C
14re46t,jqtqyi6,"C isn't, unless you target gnu C (as supported by gcc).",0.0,C
14re46t,jqtqyi6,"* C has lots of UB that can get in the way, for things that are well-defined in both my language and my intended targets (for example, signed integer overflow) * Many constructs in my language, like a 3-way comparison `if f()=g()=h()`, end up being evaluated twice or more in the C (`if (f()==g() && g()==h())`); these all need attention * I use new features like slices, multiple function returns, multiple assignment, which I simply haven't bothered with.",0.18939393939393936,C
14re46t,jqtqyi6,"(To transpile a program to C, I have avoid those features and many more) * All my records (structs) effectively use `pack(1)`, although the majority of fields are properly aligned.",0.4,C
14re46t,jqtqyi6,"* When generating C, the sizes of pointers are hard-coded as either 4 or 8 (or just 8 now as I only do 64 bits), so a particular C rendering can only be compiled as `-m32` or `-m64`, whereas proper C code will work as either * I sometimes use inline assembly.",0.041666666666666664,C
14re46t,jqtqyi6,"This is generally accepted, except for Tiny C where you have to use the ridiculous option `-fdollars-in-identifiers`.",-0.09444444444444444,C
14re46t,jqtqyi6,"* C has complex rules to do with mixed arithmetic, which in no way match mine.",-0.15,C
14re46t,jqtqyi6,My whole-program compiler will produce a one-file C rendering of the whole application.,0.2,C
14re46t,jqtqyi6,"There is already a problem where, after taking a few tens of milliseconds to produce the C, it will hit a brick wall as soon as gcc is invoked, but large inputs of tens of thousands of lines combined with `-O2` or `-O3` will make it even slower.",0.007142857142857131,C
14re46t,jqtqyi6,This is where Tiny C is a better match for the output of my compiler.,0.25,C
14re46t,jqtqyi6,"When someone else is responsible for compiling the resulting C, the results can vary.",0.2,C
14re46t,jqtqyi6,"My aims with generating C were mostly met (although it would cramp my coding style as I needed to use cruder features sometimes): I could run code on Linux, and optimisation usually gave a useful speedup.",0.18333333333333335,C
14re46t,jqtqyi6,"The generated C, while I made an attempt to keep it structured, mostly looked dreadful; the mangled names didn't help.",-0.25,C
14re46t,jqtqyi6,"I've also experimented with generating low-level, unstructured C code, with few of C's data types (eg.",-0.2,C
14re46t,jqtqyi6,"I even tried generating from a separate linear IL into C code, but that was awful - so many redundant temporaries and copies, that you *need* an optimising compiler to tidy it all up.",-0.024999999999999994,C
14re46t,jqtqyi6,"Here is my transpiler in action on a 40KLoc project `qq`; `tm` is a timing tool:      c:\qx>tm mm qq                       # Using direct native codegen     Compiling qq.m---------- to qq.exe     TM: 0.09          c:\qx>tm mc -tcc qq                  # Via C and Tiny C     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: tcc  -oqq.exe qq.c c:\windows\system32\user32.dll -luser32 c:\windows\system32\kernel32.dll -fdollars-in-identifiers     TM: 0.27          c:\qx>tm mc qq                       # Via C and gcc -O0     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: gcc -m64   -oqq.exe qq.c -s     TM: 6.36          c:\qx>tm mc -opt qq                  # Via C and gcc -O3     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: gcc -m64  -O3 -oqq.exe qq.c -s     TM: 49.51  If I need optimisation (the main reason I would do this on Windows), transpiling to C can take 500 times longer to build.",0.09166666666666667,C
14re46t,jqtqyi6,"But if this is your main way of getting a binary, then Tiny C is the best bet for routine builds unless your programs are small.",0.22916666666666669,C
14re46t,jqsh0ua,> Any good libraries for building C Source?,0.7,C
14re46t,jqsh0ua,"I used both llvm-ir (text) and C. I like the C code better but maybe it's because I wrote that second so it was less rough  I didn't use the tcc lib, I used the binary by spawning multiple processes",0.046666666666666676,C
14re46t,jqtybly,Somehow related: [a list of open source compilers that can generate C code](https://github.com/dbohdan/compilers-targeting-c).,-0.25,C
14re46t,js16hsm,"I have a [public domain 128 bit integer library](https://github.com/aeldidi/int128) which you can use if you want to do that, since C doesn't actually have 128 bit integers.",0.0,C
14re46t,jqs4g9l,"If your language matches C well, then it’s *fine*, as long as you really thoroughly understand the pitfalls of defined behaviour in C. It’s very helpful as a first step for getting something running and interoperating with other code.",0.1486111111111111,C
14re46t,jqs4g9l,"Still I do wish for a better “portable assembler”, because C isn’t quite it.",0.5,C
14re46t,jqs4g9l,"You can also use a C backend as a jumping-off point to start generating native code, or retargetable code (LLVM, JVM, CIL, whatever).",0.0,C
14re46t,jqtnsw8,">the generated binaries were huge (I did inline some stuff but mostly things like refcounting and other small rudimentary stuff, still it added up a lot)  That doesn't look like the fault of using C; presumably the generated C code was also huge?",0.18500000000000005,C
14re46t,jqv3tuf,"It also used generics implemented as specialized copies, that added a lot, but even without that the generated C code of the individual functions was big due to refcnts, handling of exceptions when calling functions and other small stuff that added up.",-0.1,C
14re46t,jqv3tuf,"But maybe the C compilers would handle calling a lot of inlined functions better than directly embedding it, I haven't tested that.",0.3,C
14re46t,jqv3tuf,The main problem is that the C optimizer can't optimize out redundant refcnt operations or other high-level things.,-0.052777777777777785,C
14re46t,jqv3tuf,And I think most people who want to output to C are in the mindset that they wouldn't need to care about optimizations by doing that.,0.5,C
14re46t,jqv3tuf,There was just generation of C code so I don't have a comparison unfortunatelly.,0.0,C
14rdg9d,jr1zb9g,"I'd be interested to see what his opinions are today on the extensibility of languages, and how both Scheme and Java have fared on growth here.",0.25,Scheme
14rdg9d,jr1zb9g,"I'd be interested to see what his opinions are today on the extensibility of languages, and how both Scheme and Java have fared on growth here.",0.25,Java
14rdg9d,jqtbjm7,Java is a brand name for a computer programming language.,0.0,Java
14rdg9d,jqtbjm7,I shall speak of The Java Programming Language™ a great deal more in this talk.,0.65,Java
14rdg9d,jqtbjm7,I have to say the full phrase The Java Programming Language™ for there is a guy who works where I do who deals with the laws of marks of trade and he told me I have to say it that way.,0.35,Java
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,Fortran
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,APL
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,Pascal
14rdg9d,jr2hzfz,"Obviously there is a peak, or an answer, to Gossling and Java community at the time, we should not forget that it was a time when Java was marketed heavily as a simpler (better) C++ by trashing some C++ features, in particular operator overloading and multiple inheritance.",0.09333333333333334,Java
14rdg9d,jr2hzfz,"Obviously there is a peak, or an answer, to Gossling and Java community at the time, we should not forget that it was a time when Java was marketed heavily as a simpler (better) C++ by trashing some C++ features, in particular operator overloading and multiple inheritance.",0.09333333333333334,C++
14rdg9d,jr2hzfz,"I don't know if Bjarne & Co have seen this talk and have taken a big note from it, but recent C++ development, C++ 11 and further seem to reflect what Steel is talking about big language, extending the language, so the new add-ons feel the same as the language itself, and so on.",0.022727272727272724,C++
14rc8yc,jqsousg,"Haskell for example, treats the variables as nullary functions, and therefore no distinction.",0.0,Haskell
14rc8yc,jqsb3bj,"Eiffel uses ""feature"" for pretty well exactly this purpose.",0.25,Eiffel
14rc8yc,jqumghg,"Symbol, taken from Lisp.",0.0,Lisp
14rc8yc,jr4gu4m,"In Scheme et al, an environment maps **symbols** to **values**.",0.0,Scheme
14ra832,jqr8iif,"Sure it has it's flaws, but I wanted to spend my time on language design not writing optimisers, and there is no other reusable backend with the same performance and transpiling to C is ugly and fragile.",-0.02749999999999999,C
14ra832,jqrc6vj,"I do sometimes use a C backend (although C makes a poor IL), but I know that in that case, the minimal dependency to turn that C into executable binary is under 0.25MB of the Tiny C compiler (a 1.6MB installation, but I only need 2-3 files of it).",-0.125,C
14ra832,jr21znr,"Big things like LLVM, Web Browser(HTML, CSS, js), OS-APIs, SQL (vs the actual relational model that is truly simple), C++, etc is that are BIG.",0.0,HTML
14ra832,jr21znr,"Big things like LLVM, Web Browser(HTML, CSS, js), OS-APIs, SQL (vs the actual relational model that is truly simple), C++, etc is that are BIG.",0.0,C++
14ra832,jr21znr,"And if you are making C++, LLVM, *THE* way.",0.0,C++
14ra832,jqryx4q,"Rust has some bindings for it, but then I couldn't fully work through documentation on how to use llvm either way.",0.0,Rust
14ra832,jqspcsh,"Rust does work on different backends, but these have rather low priority and are mostly not ment to replace the LLVM-backend.",-0.08333333333333333,Rust
14ra832,jqtzzay,"Well it seems to be the main bottleneck of several compilers including Zig, Crystal, Odin (and probably Rust)",0.08333333333333333,Crystal
14ra832,jqtzzay,"Well it seems to be the main bottleneck of several compilers including Zig, Crystal, Odin (and probably Rust)",0.08333333333333333,Rust
14ra832,jqrdxuc,Why transpiling to C is ugly and fragile?,-0.35,C
14ra832,jqr8l9x,They mostly compare it to other backends like C and gccjit,0.1875,C
14ra832,jqrsp2b,Nim transpiles to C quite successfully.,0.75,C
14ra832,jqtk2n7,The Rust compiler uses LLVM and it definitely isn't written in C++,0.0,Rust
14ra832,jqtk2n7,The Rust compiler uses LLVM and it definitely isn't written in C++,0.0,C++
14ra832,jqsaywh,"Can you expand a little more, is your compiler written in Rust and you also interface with cranelift using its Rust library API, i.e.",0.15625,Rust
14ra832,jqsrev7,"I feel like generating text as an internal representation is hard to do elegantly, and unless you want to hook into the AST of some C compiler you will be generating text.",0.06944444444444443,C
14ra832,jqsrev7,"And if you do, you essentially defeat the point as that C compiler will act like LLVM.",0.0,C
14ra832,jqsrev7,"Not only that, unless you are targeting one C compiler, on a single operating system, you will have to account for their differences, and write a lot of tedious logic that locates and calls the compiler.",-0.19047619047619047,C
14ra832,jqsrev7,"A final reason for my newest language is that I explicitly do not want some of C's UB, e.g.",0.0,C
14ra832,jqsrev7,Both of those things require more compiler specific hacks to implement on top of C.,0.3333333333333333,C
14ra832,jqs35iw,C is not the prettiest language to begin with first of all.,0.25,C
14ra832,jqs35iw,"A great example is the Koka language, if you look in the C headers and source files, almost everything is static and inline in order to not incur extra runtime overhead.",0.43333333333333335,C
14ra832,jqsryvf,"If you want to generate C, generate C, it's ugly, but it's an easy way to prototype when you are only targeting one platform and C compiler.",-0.08888888888888886,C
14ra832,jqvcb9i,their own C compiler backend,0.6,C
14ra832,jqu0259,A valid alternative is usually a C backend,-0.25,C
14ra832,jqtgmfu,[C--](https://en.wikipedia.org/wiki/C--) is another option it inspired Cmm in Haskell,0.0,C
14ra832,jqtgmfu,[C--](https://en.wikipedia.org/wiki/C--) is another option it inspired Cmm in Haskell,0.0,Haskell
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,Rust
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,Kotlin
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,Scala
14ra832,jqu8v55,"I think the characterization of C as ""ugly and fragile"" is _not_ a principled analysis - we should be talking more about some of the benefits you mentioned: expressiveness, performance, interop, distributability, binary size, debugability  and compile time of the target, and whether it was worth the pain.",0.02500000000000001,C
14ra832,jqs9q6l,Any inspiration from Holy C?,0.0,C
14ra832,jqtx0lg,"But... what will the Zig devs actually accomplish, with this R&D opportunity?",0.0,R
14ra832,jqtx0lg,"But... what will the Zig devs actually accomplish, with this R&D opportunity?",0.0,D
14ra832,jqtx0lg,"But then again, I'm not trying to write a C replacement.",0.0,C
14ra832,jqt4cit,"The other is that you end up with something you're happy with, but the community as a whole is less happy, a la like Graydon's talk about his vision for Rust.",0.30166666666666664,Rust
14ra832,jqsd6kf,Holy C of TempleOS?,0.0,C
14ra832,jqsd6kf,"No, my stuff was from much earlier than that (from '81), and actually I had nothing to do with C at all, until the 90s when it started turning up in APIs (specifically, Win16 API).",0.0,C
14ra832,jqrzpdo,> Debug build backend for the Rust compiler.,0.0,Rust
14r2pkq,jqv95hv,"HTML is in there as well, and I assume it's not a string?",0.0,HTML
14r2pkq,jqv95hv,It also outputs HTML and TS.,0.0,HTML
14r2pkq,jqvcx6n,Also the language implements an HTML-like variant it's not really HTML.,-0.1,HTML
14r2pkq,jqvcx6n,"The output is different languages because your app should eventually has a server (can be implemented using any language but I chose to compile to Node.js) and a client app (which should be HTML, CSS, and JS because that's what run on the browser).",0.0,HTML
14r2pkq,jqvezh5,"Check this todo app example built using the DSL: [https://github.com/algorizr/thoth/blob/main/examples/todo.thoth](https://github.com/algorizr/thoth/blob/main/examples/todo.thoth)  The code responsible for parsing HTML elements can be found here in the repo: [https://github.com/algorizr/thoth/blob/main/src/analyzer/parsing/helper.ml#L121](https://github.com/algorizr/thoth/blob/main/src/analyzer/parsing/helper.ml#L121)  Also, the code responsible for checking the UI code for any sementic errors can be found here: [https://github.com/algorizr/thoth/blob/main/src/analyzer/type\_checler/xra\_checker.ml](https://github.com/algorizr/thoth/blob/main/src/analyzer/type_checler/xra_checker.ml)  Sorry, the code is not documented and not very clean so it can be a little hard to read.",-0.3300213675213675,HTML
14qv5lp,,"- [How Rust solved dependency hell](https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell) - [Addressing the shortcomings of peer dependencies](https://hackmd.io/@dzearing/BJifNnpsq)  To be brief, have these issues been solved in dependency/package management, or is it still an open question?",0.0,Rust
14qv5lp,jqpj5gs,In C#/Nuget you get one version per library but with build time checks for possible compat issues.,0.0,C
14qv5lp,jqpjuz3,"Well, first off, my thesis of “it isn’t just Rust or JS that has this problem, you know”… I’m not going to call it conclusively demonstrated, but I’ve found some strong support and a couple decent counterpoints.",0.2833333333333333,Rust
14qv5lp,jqpjuz3,There are potentially a lot of unexpected dependencies hiding in even a quite small C program.,-0.049999999999999996,C
14qv5lp,jqpjuz3,"A medium-sized Rust project can easily tip the scales at 2-300 crates, which is still rather more dependencies than anything I’ve looked at here, but that’s explained by the simple fact that using libraries in C is such a monumental pain in the ass that it’s not worth trying for anything unless it’s bigger than… well, a base64 parser or a hash function.",0.13055555555555556,Rust
14qv5lp,jqpjuz3,"A medium-sized Rust project can easily tip the scales at 2-300 crates, which is still rather more dependencies than anything I’ve looked at here, but that’s explained by the simple fact that using libraries in C is such a monumental pain in the ass that it’s not worth trying for anything unless it’s bigger than… well, a base64 parser or a hash function.",0.13055555555555556,C
14qv5lp,jqqchsv,"Rust's Cargo is quite clearly well regarded, but it is complicated.",-0.19999999999999998,Rust
14qv5lp,jqqchsv,"For my language, I copied the principles of the Go package manager.",0.0,Go
14qv5lp,jqqgu26,Julia's dep management works great for me,0.8,Julia
14qv5lp,jqsrf2v,"For example if you have libA depending on libC v1.1 and libB depending on libC v1.2, in your approach the application that uses both A and B can not pass C typed objects between A and B, because the identifiers wouldn't match?",0.0,C
14qv5lp,jqy3chz,Fwiw here is the result in Rust.,0.0,Rust
14qv5lp,jqy3chz,"And once again, Rust error messages take the cake at letting you know what’s going on.",0.0,Rust
14qv5lp,jqt9zxt,"That is true, the application using both A and B would have to map the data between the two different versions of C. However, I would not recommend using something related to C when using A and B, A and B should stand on their own.",0.2375,C
14qv5lp,jreikpc,A language can also go further than Rust does to support this.,0.0,Rust
14qn9of,jqqlomc,\> No parser   \> Just start with the AST     So... Lisp.,0.0,Lisp
14qc538,jqn7w3d,Something like what you have here combined with TypeScript's type narrowing?,0.0,TypeScript
14q21pz,jqlaati,https://godbolt.org is my favorite for C,0.5,C
14pzzs6,jqnnl2d,I think Lua is a good example of doing documentation well.,0.7,Lua
14pzzs6,jqnnl2d,"[The API is documented in a single HTML file on the website](https://www.lua.org/manual/5.4/manual.html) that has both the high level descriptions of the language and architecture, as well as documentation for each public-facing function.",0.04428571428571429,HTML
14pzzs6,jqlswwc,I think your Rust example is a good example of documentation that \*doesn't\* clutter the code unduly.,0.7,Rust
14pzzs6,jqmwwjd,"Either way, one thing to learn from the Rust documentation project may be ways to automate testing of code samples in docs so they stay in sync as the code evolves.",0.0,Rust
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,Rust
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,Python
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,C
14pzzs6,jqouds0,"I do this a lot more for Python than other languages (since doc comments break up the function definition and implementation, annoying) but it can help make it less spaced out.",-0.14791666666666667,Python
14pzzs6,jqpb6oy,"Haskell can infer most of the types, people really do write them into the code mostly as a means of documentation because they're that useful, and can say a lot more than you can in English with significantly-fewer characters and significantly less room for (mis)interpretation.",0.2619047619047619,Haskell
14psfd7,,"(DRY = Don't Repeat Yourself)  This is a bit of C code I encountered today:      uint64_t maxOR(uint64_t a, uint64_t b, uint64_t c, uint64_t d) {         ....     }  The problem for me is that declaration: 4 parameters, all with the same type, but the type has to be written 4 times.",-0.033333333333333326,C
14psfd7,,"This style is common across lots of languages, but C has that extra-cluttery typename, so that I can barely make out the parameter names.",-0.125,C
14psfd7,,"C could at least have gone with `u64`:      u64 maxOR(u64 a, u64 b, u64 c, U6 d) {             # (typo left in)  Now it is much less objectionable, but I would have gone further to:      u64 maxOR(u64 a, b, c, d) {  While C is a lost cause, I wonder why other languages do this as well: create extra maintenance, extra things to check, extra things you can get wrong (one of those types could have been `int64_t` \- not easy to spot in that sea of `uint64_t`).",-0.13083333333333336,C
14psfd7,,"Funnily enough older C allowed you to do this, or along these lines:      u64 maxOR(a, b, c, d) u64 a, b, c, d; {  In my own syntaxes, it usually something like:      func maxor(u64 a, b, c, d)u64 =                # `=> u64` is optional  Types are only repeated when there are no parameter names (as in, FFI declarations, but I can choose to add names to enable keyword parameters).",0.10333333333333332,C
14psfd7,jqjtzp8,Eiffel manages this.,0.0,Eiffel
14psfd7,jqkp1uh,"Go has this:      func(a, b int, z float64) bool { return a*b < int(z) }  In this example, `a` is also type `int`.",0.0,Go
14psfd7,jqlmgw6,"if you're willing to use C++ you could avoid the repeated explicit types  auto maxOR(uint64\_t a, decltype(a) b, decltype(a) c, decltype(a) d) -> decltype(a) {  // return type same as param 'a' type  (even though it's more typing as in input device and just making them all template params of a single typename T would probably make more sense)",0.2357142857142857,C++
14psfd7,jqqp0gu,"And as usual, this has been true since Algol times, but C screwed it up, maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something.",-0.0638888888888889,C
14psfd7,jqqp0gu,"Much as I love C, it is cluttered and inconsistent as few other languages (most of C's own deplorable descendants aside, of course.)",0.11249999999999999,C
14psfd7,jqqp0gu,"And don't get me started on declarators, qualifiers, specifiers, storage classes, attributes, initializers and whatever - suffice it to say that C's declaration syntax is just abominable in general.",0.05000000000000002,C
14psfd7,jqsxijw,"Changing the language's notation may be an option in Perl, but it is not an option for me.",0.0,Perl
14psfd7,jqk2pvr,"In C, four struct members with identical types, followed by one of a different type to address your other point, could be written like this:      struct {         uint64_t a, b, c, d;         int64_t  e;     }  Unless you specifically wanted one member per line (for example if the members weren't related), you wouldn't use separate types like this:      struct {         uint64_t a; uint64_t b; uint64_t c; uin64_t d;         int64_t  e;     }  At least, the choice is there.",-0.10625,C
14psfd7,jqk2pvr,"With mixed types, I still use a comma separator between them (just as C does actually); I could have made it stronger with a semicolon, as used the top struct example.",0.16666666666666666,C
14psfd7,jqk2pvr,"I'd write that as this (here I've chosen to use capitalisation to mark the types better; it is case-insensitive):      proc pout(Int n, j, k, Real x1, x2, x3, x4) =  In C however it would be:      void pout(int n, int j, int k, double x1, double x2, double x3, double x4) {  Which is more readable?",0.17142857142857143,C
14psfd7,jqk3m84,I think Pascal and Ada would be similar to this.,0.0,Pascal
14psfd7,jqk3m84,I think Pascal and Ada would be similar to this.,0.0,Ada
14psfd7,jqmtw9v,"Here is C's famous `for`\-loop which for some inexplicable reason, every other language likes to copy:      for(index = 0; index < N; ++index) {...}  Notice THREE instances of the loop index variable, with two needless repetitions!",-0.2125,C
14psfd7,jqqxvnv,">maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something  It shouldn't be hard in C, or any harder than it normally is to parse types that wrap themselves around names, since it will know exactly what every identifier is when encountered.",-0.056666666666666664,C
14psfd7,jqqxvnv,"&#x200B;  >Much as I love C,  You do?",0.5,C
14psfd7,jqqxvnv,"We need such language, but C is a very poor example of it.",-0.26,C
14psfd7,jqqxvnv,This is legal C:      long unsigned const const int typedef long const const T;  It defines T as an alias for `const u64`.,0.03333333333333334,C
14psfd7,jqqxvnv,"Thinking of it, C legalises repetition in several places:      int a, a, a, a, a, a;         // at module scope          void F(int a, int b);     void F(int a, int b);         // parameter names can match ...     void F(int c, int d);         // ... or not     void F(int b, int a);         // ... or be switched     void F();                     // or just forget about them          const const const int;        // like my earlier example     L1:; int L1; goto L1;         // L1 is a variable AND a label!",0.0,C
14psfd7,jqqxvnv,But taking pot-shots at C is too easy (and too much fun).,0.3666666666666667,C
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,TypeScript
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,Rust
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,Elm
14piaj7,jqio7u8,"Maybe that `<=` is wrong; changing it to `>=` makes it work, but it goes wrong now with `A + B + C`.",-0.5,C
14o068e,jqc1q2j,in JavaScript they are kind of similar—because it's a dynamic language with first-class functions/closures—but not the same).,0.19999999999999998,JavaScript
14o068e,jqc1q2j,"In a language like JavaScript, you can nest function definitions, but you are allocating memory if you do so!",0.0,JavaScript
14o068e,jqa94gs,"Haskell pretty much does this (in a roundabout way): [edited this part out to to inaccuracy]  Using that philosophy, your `main` could look like this:      // The ""null"" program: exits immediately with code 0     // main has type: Int     main = 0  Using a more complex example:      // Says ""hello"" to the first provided argument, or exits with code 1     // main has type: [String] -> Int     main args: [String] = match (first_of args):         Some name:             println (concat ""Hello, "" name)             exit 0         None:             exit 1  Defining a type (here `Option t` is the ""type"" and `Some t`/`None` are the constructors and possible values):      type Optional t:         Some t | None          foo = Some 3 // Has type ""Option Int"" and value ""Some 3""     bar = None // Has type ""Option t"" for any type ""t"" and value ""None""  Defining a typical function:      // Square has type: Int -> Int     square n: Float = n*n  Defining a typical variable:      pi = 3.14159 //...",-0.053125000000000006,Haskell
14o068e,jqa94gs,"There are many ways to go about it, this syntax is just an example of Haskell's semantics that I've adapted into a Python-esque indent-based syntax style.",0.5,Haskell
14o068e,jqarqkc,Scala 3 also supports classic brackets as well as a custom indent-based syntax.,0.16666666666666666,Scala
14o068e,jqafpqw,"I don't think it's bad, it's not unlike JavaScript in a way, so it's not necessarily unfamiliar.",-0.3499999999999999,JavaScript
14o068e,jqana0u,It can easily be desugared from the C syntax into an assignment.,0.43333333333333335,C
14o068e,jqa7dtq,"In Scheme, `(define (f args) body)` is really just syntactic sugar for `(define f (lambda (args) body))`.",0.2,Scheme
14o068e,jqaonfj,"> Haskell pretty much does this (in a roundabout way): Everything is a function (even single values), and ""types"" are just special kinds of functions (functions that ""hold on"" to their arguments for later de-structuring).",0.14714285714285716,Haskell
14o068e,jqaonfj,"Normal ""variables"" are also just functions, so in a roundabout way everything is a variable in Haskell.",0.15,Haskell
14o068e,jqaonfj,"Not everything is a function in Haskell, certainly not single values (`""foo""` isn’t a function, it’s a string).",0.03571428571428571,Haskell
14o068e,jqaonfj,"It’s somewhat more accurate to say “everything is a _value_ in Haskell”, since functions are values, but even that isn’t very helpful really since there are plenty of non-value concepts in the language.",0.325,Haskell
14o068e,jqbtbbc,Haskell only allows this at the top level.,0.25,Haskell
14o068e,jqaggnr,"Another angle: would you consider Python to be a language where ""everything is a variable"" like this?",0.0,Python
14o068e,jqb9ex6,I consider Python a language where every top-level user identifer (ie.,0.0,Python
14o068e,jqb9ex6,This is what makes Python somewhat difficult to optimise.,-0.5,Python
14o068e,jqb9ex6,"The only names in Python you can't change are the keywords, and anything else that is a hard-coded built-in.",0.0,Python
14o068e,jqbsg16,"In Scheme, everything is a *value*, including the symbols themselves.",0.0,Scheme
14ngaly,jqca2ti,"I've been chipping away at the (bytecode) compiler, which is *significantly* faster than the (written in Python) interpreter -- and since I'm out of Python-land I can actually do deep recursion.",0.1875,Python
14ngaly,jqca2ti,"I wrote the compiler in D -- not because I know or have a great affinity for D, but because I wanted something familiarly C-ish but with niceties like less pointer chasing, dynamic arrays, and strings that make sense -- but I'm starting to feel the pain of writing something in a less-well-known host language, and so started something in C++ for static analysis to both practice and see if that's a better option.",0.2869047619047619,D
14ngaly,jqca2ti,"I wrote the compiler in D -- not because I know or have a great affinity for D, but because I wanted something familiarly C-ish but with niceties like less pointer chasing, dynamic arrays, and strings that make sense -- but I'm starting to feel the pain of writing something in a less-well-known host language, and so started something in C++ for static analysis to both practice and see if that's a better option.",0.2869047619047619,C++
14ngaly,jq7bdod,I'm rewriting everything in Haskell as I couldn't stop thinking that something can be incredible wrong with the python code I wouldn't know until it is a problem.,0.2,Haskell
14ngaly,jq7bdod,"Right now I have almost ported the parser, 150 grammar rules from python to Haskell!",0.3571428571428571,Haskell
14ngaly,jq8hffa,"For example, I have written a small tool which takes C Headers as input and produces glue code to call them from my lang.",-0.25,C
14ngaly,jq9wcbd,Realised I was just reinventing a worse version of Rust.,-0.4,Rust
14ngaly,jqikc4o,[https://github.com/Gwenio/abyss-lisp](https://github.com/Gwenio/abyss-lisp)  A Lisp based on Kernel.,0.0,Lisp
14ngaly,jqb41jz,"I'm working in Ruby so creating a whole DSL for my ideas is pretty simple, plus it makes everything go very smoothly from one part of the compiler to the other.",0.16899999999999998,Ruby
14ngaly,jqmrxur,"Timings include transpilation to C, but that is insignificant.",0.0,C
14ngaly,jqmrxur,"(I'm no longer able to transpile M6 to C, so the build-times above could have been even better, but since no app takes longer than 0.1 seconds to build, I wouldn't notice in practice.",0.3333333333333333,C
14ngaly,jqmrxur,**EDIT**: I've managed to transpile `mm6.exe` (M6 compiler) into C and therefore to optimise it via `gcc-O3`.,0.0,C
14ngaly,jqmrxur,Build-times for these apps are now up to 700 times faster than `gcc-O3` building C renderings of those same apps.,0.0,C
14ngaly,jqsr0lp,"Previously it was implemented in Rust, and a tenant of a different experimental language/VM called Rail with different semantics and goals.",-0.016666666666666663,Rust
14ngaly,jqsr0lp,Moving from Rust was motivated by the ease of cross-compiling and the relative tiny-ness of the produced executables.,0.0,Rust
14ngaly,jqxcrhf,"I already dabbled in a simple Lisp-y thing in Rust (an interpreter) and then got to somewhere halfway through Writing a Compiler in Go (in Golang, just keeping the syntax Lisp-y)  As I am going to have afternoons free for the next two weeks, I decided to pick this idea up.",0.13333333333333333,Rust
14ngaly,jqxcrhf,"I already dabbled in a simple Lisp-y thing in Rust (an interpreter) and then got to somewhere halfway through Writing a Compiler in Go (in Golang, just keeping the syntax Lisp-y)  As I am going to have afternoons free for the next two weeks, I decided to pick this idea up.",0.13333333333333333,Go
14ngaly,jqgxsod,"I've also done a bunch to clean up the internals, and Sophie is now available on the command-line without mentioning Python thanks to some packaging goop, which is nice for usability.",0.3916666666666667,Python
14ngaly,jqm37of,"So far my IR is pretty simple, but can be used to implement a subset of C, the next things i want to add are floating point numbers, malloc/free built-ins, global register allocator and eventually FFI.",0.06999999999999999,C
14ngaly,js2ri3a,If interested you can find the [constraint gathering code in C# here](https://github.com/cdiggins/plato/blob/main/PlatoAst/Constraints.cs).,0.25,C
14ngaly,jswo747,Wrote a summary here:  https://jevko.github.io/writing/2023-07-20-lambda.html  Also recently ported my little lambda-calculus-based language to from JS to C: https://codeberg.org/xtao-org/last.c  Been fun debugging the minimal refcounting garbage collector.,0.003124999999999996,C
14ngaly,jswo747,;D,0.25,D
14ngaly,jt322uh,"I'm thinking about implementing a language... (which, if successful, will serve as a second language to my Lua game framework Lyte2D.)",0.11666666666666665,Lua
14ngaly,jt322uh,I'm torn between Python and TS.,0.0,Python
14ngaly,jt322uh,Leaning towards Python syntax.,0.0,Python
14ngaly,jrl870h,I've just done something else that I should have done long ago: cut most ties with the C language.,0.225,C
14ngaly,jrl870h,That language can come up when dealing with APIs; when trying to build open source stuff; when used as a transpiler target; comparing benchmarks between my language and C; when optimising my apps via the transpiler (see the EDIT PS of my first post).,0.125,C
14ngaly,jrl870h,"So, I've deleted the various C compilers I had lying around: gcc, tcc and Clang, although that last barely worked.",0.016666666666666666,C
14ngaly,jrl870h,"I've archived my `mc` transpiler (M to C compiler), which already only existed in an older compiler version, and which didn't support the full M language.",0.1722222222222222,C
14ngaly,jrl870h,"I will still retain my own `bcc` C compiler, but that's of little help in either optimising, or working on Linux!",0.1828125,C
14ngaly,jrl870h,It includes an option to do the bulk of the work in translating some C APIs into my syntax.,0.0,C
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,C++
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,C
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,TypeScript
14ngaly,jt42vke,I'm torn between Python and TS.,0.0,Python
14ngaly,jt42vke,Leaning towards Python syntax.,0.0,Python
14ng0eq,jq8a2qd,Does anyone know of an implementation for Rust ?,0.0,Rust
14neutn,jqag99u,Scheme is lovely.,0.5,Scheme
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Go
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Objective-C
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Swift
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Rust
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,Java
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,C
14n9a4g,jq6ehdb,"Ruby, as a language, was *fine*, but Ruby on Rails made it *wildly popular*.",0.5083333333333333,Ruby
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,C
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,C++
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,Objective-C
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,PHP
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,R
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,Lua
14n9a4g,jq9579b,"Popularity isn't all of it: the difference between what you achieve privately and a monster language like C++, say, with its vast choice of implementations, tools and libraries, is like that between a home movie and a $100m Hollywood production that employs a crew of a thousand.",0.0,C++
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,C
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,Java
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,Go
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,Rust
14n9a4g,jqc515c,Though Lua is perhaps not the best example because it wasn't aimed at the niche they found.,1.0,Lua
14n9a4g,jqc515c,"It was designed as a general-purpose scripting language but someone at Lucasfilm Games read about it in Dr Dobbs' Journal and thought it was way better than their in-house scripting language, and so Lua got into gamedev and it sort of snowballed.",0.5,Lua
14n9a4g,jqgr4m9,I trust it's more interesting than Paul Graham's claim that Lisp was the magic sauce behind getting Yahoo to buy him out?,0.275,Lisp
14n9a4g,jq6itm8,"It's worth mentioning that various ""web"" languages, such as Python and Ruby, didn't have corporate sponsors initially.",0.06,Python
14n9a4g,jq6itm8,"It's worth mentioning that various ""web"" languages, such as Python and Ruby, didn't have corporate sponsors initially.",0.06,Ruby
14n9a4g,jq6itm8,"Guido didn't go to work for Google and get their support, until a fairly long time into Python's history.",-0.05,Python
14n9a4g,jqoxa9m,"Go read old BYTE magazines, there were ads for compilers back then!",0.05,Go
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,Swift
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,Go
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,Rust
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,C
14n9a4g,jqoxa9m,"- Java was started as an _inducement_ to a Sun employee to remain at the firm, basically a bribe -- ""do whatever you feel like so long as you stay here"".",-0.125,Java
14n9a4g,jqoxa9m,"I would generalize this to ""most R&D""; almost always it's started outside company planning -- government or academic labs, occasional personal projects -- and companies join in funding once it's already underway.",0.1,R
14n9a4g,jqoxa9m,"I would generalize this to ""most R&D""; almost always it's started outside company planning -- government or academic labs, occasional personal projects -- and companies join in funding once it's already underway.",0.1,D
14n9a4g,jq69rtt,"If you measure success by having as much adoption as newer languages like C# or Swift, your odds are going to be very low without a major backer.",0.140625,C
14n9a4g,jq69rtt,"If you measure success by having as much adoption as newer languages like C# or Swift, your odds are going to be very low without a major backer.",0.140625,Swift
14n9a4g,jqew37k,"[There's a nice writeup of the history on Lua's website if anyone wants more of the story, which is pretty interesting](https://www.lua.org/history.html).",0.3875,Lua
14n9a4g,jqjmknq,"Another part of the story that's important, is **LuaJIT** was primarily responsible for game industry popularity, and it is not part of the core Lua development.",0.0666666666666667,Lua
14n9a4g,jqjmknq,"Whereas, Lua devs' primary goal was to be easily embedded on all platforms.",0.4166666666666667,Lua
14n9a4g,jqjmknq,"Because they did not agree on goals, and architecture necessary to achieve the different goals, Lua did not incorporate LuaJIT performance increases.",0.0,Lua
14n9a4g,jqjmknq,They were compatible at Lua version 5.1 and then the 2 developments went their separate ways.,0.0,Lua
14n9a4g,jqjmknq,"Meanwhile Lua proper is on version 5.4.6, with 5.1 being quite awhile ago in the Lua rear view mirror.",0.0,Lua
14n9a4g,jqjmknq,Lua also doesn't attempt to retain backwards compatibility.,0.0,Lua
14n9a4g,jqjmknq,This prevents any long term ecosystem from stabilizing around Lua.,-0.05,Lua
14n9a4g,jqjmknq,"Like to the extent game devs care about Lua, they're likely to use 5.1 forever.",-0.2,Lua
14n9a4g,jqjmknq,"Personally as a lone wolf indie game developer, I pretty much gave up on the idea of Lua 1) because its ecology is rearguard and will never amount to anything, and 2) I personally can't think about 3D math in terms of Lua.",0.008333333333333331,Lua
14n9a4g,jq6g6gq,"*Or*, they might get some new corporate suit manager who cuts costs, hires new people, and orders everybody to rewrite everything in C++.",0.0909090909090909,C++
14mno1w,jq6m8ml,"As if that wasn't enough, most of the comments in the issue thread are clear that low-friction integration with C++ builds is a big part of why many people are using Zig.",0.22000000000000003,C++
14mno1w,jq3n5vl,"There's no way I am porting the entirety of LLVM, it's dependencies and a C++ compiler.",0.0,C++
14mno1w,jq6485u,"Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,Go
14mno1w,jq6485u,"Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,C
14mno1w,jq6485u,And it's usually compared to Java which had/ has decades of more speed optimizations behind it.,-0.05000000000000001,Java
14mno1w,jq6485u,Yet I have seen no complaints that Go is slower than Java.,0.0,Go
14mno1w,jq6485u,Yet I have seen no complaints that Go is slower than Java.,0.0,Java
14mno1w,jq6485u,LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C
14mno1w,jq6485u,LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C++
14mno1w,jq6485u,"Lastly, I'm really interested to see how the C interop will go.",0.25,C
14mno1w,jq6485u,Their easy inclusion of C files was a big selling point early on.,0.17777777777777778,C
14mno1w,jq7fwgb,"Haven't seen it mentioned anywhere, but one solution for not having to deal with C++ compilation is to simply compile LLVM to WebAssembly and convert it back to C.  Mozilla already uses that approach for sandboxing ([link](https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/)).",0.0,C++
14mno1w,jq5rtoo,"He wrote the Datalight C compiler from scratch, including the codegen back-end.",0.0,C
14mno1w,jq5rtoo,"That same back-end has been in a lot of different compilers, including the Symantec C++ compiler which also holds the distinction of being the first compiler to turn C++ directly into a binary format without first transpiling to C.  This codegen back-end has been actively maintained and updated since the 1980s and is now part of the Digital Mars C++ compiler, and the reference compiler for D (also created by Walter).",0.06666666666666667,C++
14mno1w,jq5rtoo,"That same back-end has been in a lot of different compilers, including the Symantec C++ compiler which also holds the distinction of being the first compiler to turn C++ directly into a binary format without first transpiling to C.  This codegen back-end has been actively maintained and updated since the 1980s and is now part of the Digital Mars C++ compiler, and the reference compiler for D (also created by Walter).",0.06666666666666667,D
14mno1w,jq5rtoo,"Impressive as all that is, it didn't take long for people to lift the front-end from the reference D compiler and slap it on top of both LLVM and GCC back-ends, and within the D community it's generally preferred to use either LDC (LLVM D Compiler) or GDC (GNU D Compiler) when deploying code to production because they both have better optimization, cross-compilation support, more arch targets, and are just generally more feature-rich.",0.42857142857142855,D
14mno1w,jq5yx74,The C backend is not the replacement backend.,0.0,C
14mno1w,jq5yx74,"LLVM does not have a C backend, that's an extra bonus that zig offers.",0.05,C
14mno1w,jq5hwlh,"To be fair, ""delegate everything to the C compiler"" is easier than integrating with LLVM in the first place.",0.475,C
14mno1w,jq5s4xf,C++ is still fumbling with const/constexpr/consteval.,0.0,C++
14mno1w,jq6qbia,Java isn't somehow the gold standard here.,0.0,Java
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,Go
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,C
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,C++
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,Rust
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,C
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,C++
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,Go
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,Java
14mno1w,jq6qbia,"Some of Go's slowness is due to language specification decisions which cannot be amended now \[1\], but a *lot* is due to reinventing optimizations that other compilers have had for years, and Zig is currently enjoying via LLVM even if LLVM integration itself takes some work.",0.03125,Go
14mno1w,jq6qbia,"That's *despite* Go having Google's weight behind it, and a huge Go footprint at Google making a ripe target for optimization with ROI.",2.7755575615628914e-17,Go
14mno1w,jq6qbia,"It's also part of why idiomatic Rust *can be* faster than idiomatic C, because it's like having the speed of `restrict` everywhere with none of the UB.",0.0,Rust
14mno1w,jq6qbia,"It's also part of why idiomatic Rust *can be* faster than idiomatic C, because it's like having the speed of `restrict` everywhere with none of the UB.",0.0,C
14mno1w,jq8u5gg,>  Their easy inclusion of C files was a big selling point early on.,0.17777777777777778,C
14mno1w,jq8u5gg,Zig being a drop-in replacement for your entire C++ toolchain is *still* one of the three major selling points advertised on the website.,0.03125,C++
14mno1w,jqkofc3,"> Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,Go
14mno1w,jqkofc3,"> Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,C
14mno1w,jqkofc3,And it's usually compared to Java which had/ has decades of more speed optimizations behind it.,-0.05000000000000001,Java
14mno1w,jqkofc3,Yet I have seen no complaints that Go is slower than Java.,0.0,Go
14mno1w,jqkofc3,Yet I have seen no complaints that Go is slower than Java.,0.0,Java
14mno1w,jqkofc3,Go prioritizes compiler speed over final executable speed.,0.0,Go
14mno1w,jqkofc3,Using LLVM would be a non-starter for them (see Rust).,0.0,Rust
14mno1w,jqkofc3,Zig on the other hand wants to be a sort of competitor to C. And being a competitor to C means that you need fast executables.,0.09166666666666667,C
14mno1w,jqkofc3,C is spoiled with a ton of work being put into optimizing compilers.,0.0,C
14mno1w,jqkofc3,> LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C
14mno1w,jqkofc3,> LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,C++
14mno1w,jqkofc3,It’s filled with people who are complaining that their multi-language projects (including C++) rely on Zig’s current compiler architecture.,0.2,C++
14mno1w,jq97mwp,I do something of the sort by having a path to generate C source code.,0.0,C
14mno1w,jq97mwp,"Then I can apply `gcc-O3`, or I can even get Clang, which just about works (it doesn't have working standard C headers, or a linker), to generate LLVM IR.",0.0,C
14mno1w,jq5rw4a,"Just targeting LLVM text IR (similar to what llvmlite does in Python) is just text generation, and can still be fed into LLVM tools or the API via IR parsers.",0.0,Python
14mno1w,jq5rw4a,"But, it decouples you from troubles of linking and versions of the LLVM C++ codebase.",0.0,C++
14mno1w,jqknlv8,There’s also the advantage that C++ has that you have more control over your API by having to explicitly declare it “const” (_edit_: or maybe I’m thinking of “constexpr”?).,0.5,C++
14mno1w,jqknlv8,(It goes without saying: doing something better than C++ is not an achievement in current year.),0.25,C++
14mno1w,jwcm3hn,Switching from debug to release builds in C++ can alone gain an order of magnitude in performance - and all you had to do was flip a switch in the compiler.,0.0,C++
14mno1w,jqr2ce0,So that maps semantically to unsafe C functions dealing with void\* parameters.,0.0,C
14mno1w,jqr2ce0,"The ""how"" is a separate concern - in other mainstream languages such as Rust there is a duplicated mechanism within the language: ""generics"".",-0.0625,Rust
14mno1w,jqr2ce0,"For example, instead of a separate \`where\` clause mechanism as in Rust, it could be  done much more ergonomically IMO if we simply had Zig's \`comptime\` combined with DBC (design-by-contracts).",0.25,Rust
14mno1w,jq64i5n,"You’re limited by what the hardware and OS let you do, and they’re heavily influenced by C, so the only way of going “faster than C” is to address a *limitation* imposed by C that makes it hard to write a fast program conveniently/correctly/reliably/&c.",-0.07261904761904761,C
14mno1w,jq96jj5,"I think partially Andrew Kelley could have worded the proposal better (putting proposal in the title, not using future tense such as ""this will remove C++ compilation""), and partially they are getting the feedback they asked for.",-0.00555555555555555,C++
14mno1w,jqdniwa,Yet I do still have a path (via a C backend) to optimise *some* programs (since the translation is not 100%).,0.0,C
14mno1w,jq8bc6v,It might take many years to gain parity with all possible use cases of a C replacement.,0.25,C
14mhu3o,,"These types function similarly to how they work in TypeScript, so if you've ever wanted to know more about how TypeScript's type system works this might be helpful.",0.25,TypeScript
14mhu3o,jq78ltw,"I was just talking about how they function in the type checker, TypeScript style unions.",0.0,TypeScript
14mhu3o,jq3g2bq,"Consider:      class A a     class B b     class (A c, B c) => C c      baz :: (A c, B c) => (c -> c) -> c -> c      quux :: C c => c -> c  Where we want to be able to use a value of the type `C c => c -> c` where type `(A c, B c) => c -> c` is expected - eg, call `baz quux`, but we don't want to allow a value of `(A c, B c) => c -> c` to be used where `C c => c -> c` is expected.",-0.11249999999999999,C
14m98qv,jq0s9gk,"`a := []int{}`  `b := [10]int{}`  `c := map[string]string{}`  I've given up trying to understand the decisions that drove Go's design, I just use the recommended practices at this point.",0.0,Go
14m98qv,jq1rvy5,"`v := make([]int, 10)` is shorthand for      var v []int     {         var tmp [10]int         v = tmp[:]     }  while `v := make([]int, 0, 10)` is short for      var v []int     {         var tmp [10]int         v = tmp[:0:len(tmp)]     }  Because slices are so common in Go, `make` is an extremely useful convenience.",0.125,Go
14lcvm1,jpy89b2,The C programming language has five decades of backwards-compatible cruft layered on.,0.0,C
14lcvm1,jpy89b2,"You can't make silk purse from a sow's ear, and you can't test quality into a system, and you can't call C a tool-chain that provides any assurance of reliable or safe software.",0.5,C
14lcvm1,jpy89b2,"I mean it may look like C, but any nontrivial property is undecidable.",-0.3125,C
14lcvm1,jpxdgsw,"There are high-quality C parsers (e.g., libclang), so it makes no sense not to just use those.",0.0,C
14lcvm1,jpxdgsw,"It’s a worthy discussion, since some languages (e.g., C++) are not context-free.",0.3333333333333333,C++
14lcvm1,jq0jzxi,Im going to deanonymize myself with that but here it is :D  [https://mlsec.org/docs/2023-eurosp.pdf](https://mlsec.org/docs/2023-eurosp.pdf),1.0,D
14k9c5x,jpr1ry2,are handled by the underlying Fortnite game engine (presumably written mostly in C++).,0.04999999999999999,C++
14k3frc,jpq54j8,:D so it's like a C on your A-F tier [ranking](https://www.youtube.com/watch?v=AzLqTgC0E0s)?,1.0,D
14k3frc,jpq54j8,:D so it's like a C on your A-F tier [ranking](https://www.youtube.com/watch?v=AzLqTgC0E0s)?,1.0,C
14k3frc,jprtgib,"Check out Mercury if you haven't already, it's a blend between Prolog and Haskell including support for linear types and typeclasses.",0.0,Prolog
14k3frc,jprtgib,"Check out Mercury if you haven't already, it's a blend between Prolog and Haskell including support for linear types and typeclasses.",0.0,Haskell
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Lisp
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,C
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Haskell
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,C++
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Rust
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Python
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Forth
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,D
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,Java
14j52c8,jplonyh,C++ uses `FT CT::*` for a reason.,0.0,C++
14iz6jf,,I'm working on a *“TypeScript but better”* type of language.,0.5,TypeScript
14iz6jf,,"The language would get statically typed errors for free, with better support for error subtyping than Rust's monad-based *Result* as a bonus.",0.45,Rust
14iz6jf,,"If I tell them to use monads or effects for state mutations, most of them will just return to JavaScript land instead.",0.5,JavaScript
14iz6jf,jpkchd1,">this isn't really OOP  There [doesn't seem to be consensus](https://doc.rust-lang.org/book/ch17-00-oop.html) whether Rust is OOP or not – it lacks inheritance, but has instantiation, delegation, limited encapsulation, etc.",0.0642857142857143,Rust
14iojtb,jpi7ceb,IMO it is executed much better than yours because Lisp is a much better suited language.,0.5,Lisp
14iojtb,jpics4d,"I never used Lisp, but I'll check it out for sure!",0.625,Lisp
14iojtb,jpidn1a,"However, the concept applies to UI quite gracefully, so consider using a Lisp next.",0.0,Lisp
14ic9c8,jpgcylu,"Information about which libraries are used (like, the standard C library containing the `printf()` function) is stored differently, and those libraries are stored in different locations in your file system.",0.0,C
14ic9c8,jpgcylu,"Alternately, you could do like Java does it: Compile to some bytecode, and then have a bytecode interpreter or JIT-compiler that translates the bytecode to each platform.",0.0,Java
14ic9c8,jpgca7n,"It's maybe not quite what you meant, one count argue Python and Lua scripts can also be run on any computer that has the interpreter installed, but JVM languages are still compiled and most machines have the interpreter installed, so it runs everywhere in practice.",0.5,Python
14ic9c8,jpgca7n,"It's maybe not quite what you meant, one count argue Python and Lua scripts can also be run on any computer that has the interpreter installed, but JVM languages are still compiled and most machines have the interpreter installed, so it runs everywhere in practice.",0.5,Lua
14ic9c8,jpk105w,"This class of languages includes everything from Python to Java, depending on what you need.",0.0,Python
14ic9c8,jpk105w,"This class of languages includes everything from Python to Java, depending on what you need.",0.0,Java
14ic9c8,jpga18d,"A Java program, once compiled, can be run everywhere for example.",0.0,Java
14i037i,jpdxm47,I am a bit confused by the mention of Haskell.,-0.4,Haskell
14i037i,jpdxm47,The integer type you are using for Haskell is not the correct one to look at this issue because it is not a 32-bit integer *or* a 64-bit integer.,0.0,Haskell
14i037i,jpdxm47,"Also, Haskell has no implicit type conversions at all.",0.0,Haskell
14i037i,jpdxm47,"If you give no type signature to `g`, it will default to `Integer` which is [Haskell's infinite precision integer type](https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Integer.html#t:Integer).",0.0,Haskell
14i037i,jpdxm47,"Also, Haskell's issue with negative literals is a bit different than what you're describing.",-0.15,Haskell
14i037i,jpdxm47,The reason this can be a problem in a different way than other languages is because the Haskell function call syntax is juxtaposition: `f x` is `f` applied to `x`.,-0.0625,Haskell
14i037i,jpdxm47,This is what `NegativeLiterals` does in the context of Haskell and GHC.,0.0,Haskell
14i037i,jpgd95p,Rust has no implicit conversion.,0.0,Rust
14i037i,jpe9rex,(I created a whole thread about this exact question [here](https://www.reddit.com/r/C_Programming/comments/14gyl0a/why_long_really_needs_to_be_deprecated/?utm_source=share&utm_medium=web2x&context=3) in the C subreddit; the replies were not sympathetic.),0.06666666666666667,C
14i037i,jpemm38,Why are you mentioning Python and JavaScript?,0.0,Python
14i037i,jpemm38,Why are you mentioning Python and JavaScript?,0.0,JavaScript
14i037i,jpemqjz,"I actually tested it like this:      #include <stdio.h>      long f(void){return -1;}     long g(void){return 0xFFFFFFFF;}      int main(void) {         printf(""%f\n"",(double)f());         // both -1.000000         printf(""%f\n"",(double)g());     }  with a conversion to double, since in C, because you have to tell `printf` whether an expression is signed or unsigned, that influences the result.",-0.025,C
14i037i,jpg74d6,"The main repository is:  https://gitlab.com/mail.umlcat  I'm working in both a FreePascal version and a Plain C version, but it could be migrated to other P.L.",-0.057539682539682536,C
14i037i,jpfju5d, >Why are you mentioning Python and JavaScript?,0.0,Python
14i037i,jpfju5d, >Why are you mentioning Python and JavaScript?,0.0,JavaScript
14i037i,jpfybhd,Rust doesn't have a prefix decrement operator: `--x` is also equal to `x`,0.0,Rust
14i037i,jpfzn23,This is special behavior Java has that you didn't clarify which is confusing because the code example you generalize to multiple other languages depends on this behavior.,-0.01696428571428571,Java
14hcw00,,"I'm designing a statically-typed compile-to-JavaScript language, like a better TypeScript, based on looking at the patterns in my code that are a pain to express in TypeScript or that require sacrificing performance for flexibility or readability.",0.5,TypeScript
14hcw00,,"The type system will be simple enough to have a spec, and nominal (like Java), but ""modern.""",0.06666666666666667,Java
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,Java
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,JavaScript
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,C
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,Rust
14hcw00,,"There are different ways to represent a set of integers in JavaScript, for example a built-in Set, or you could use a sorted array of integers, or a sorted typed array (e.g.",0.0,JavaScript
14hcw00,,"So if you have some noun and want to perform a verb on it—suppose it's some custom data structure called ""List"" and you want to get the ""length""—the best thing for the JavaScript engine is if you just call a function like ""listLength"".",1.0,JavaScript
14hcw00,,"It doesn't happen in TypeScript, for obvious reasons.",0.0,TypeScript
14hcw00,,"In Haskell or ML, it is also verboten for types to affect behavior, because you are not supposed to have to specify any type annotations; the type system is designed around the goal of whole-program type inference (which is a non-goal for me).",0.0,Haskell
14hcw00,,(I think Scala can do something like this.),0.0,Scala
14hcw00,,The duplicated code might be identical—in which case it still could benefit the JavaScript engine by being monomorphic—or it might have different inlined—or macro-expanded—code based on the differently instantiated type parameters.,0.0,JavaScript
14hcw00,,"(Scala can make sure instances that are associated with different ""parent"" instances aren't used interchangeably, but as much time as I've spent reading about Scala's type system and calculus, I don't think it's what I need.)",0.15,Scala
14hcw00,,"Modules, instead of being singletons like in TypeScript, would have parameters and type parameters that form the ""configuration"" or context of the module.",0.0,TypeScript
14hcw00,,Maybe this was the idea with C++.,0.0,C++
14hcw00,jpamyvk,"My day job is C# code and it always irks me that I have to do ""Go To Implementation"" to just look at the code that's being called.",0.0,C
14hcw00,jpamyvk,"My day job is C# code and it always irks me that I have to do ""Go To Implementation"" to just look at the code that's being called.",0.0,Go
14hcw00,jpamyvk,"I consider the entire notion of ""Go To Implementation"" to be a code smell because it implies that there's only a single implementation.",-0.023809523809523808,Go
14hcw00,jpamyvk,"In TypeScript, my preferred approach is actually a map (object literal) of strings to functions.",0.0,TypeScript
14hcw00,jpamyvk,There's a follow-up by someone else ['Modules Matter Most' for the Masses](https://www.pathsensitive.com/2023/03/modules-matter-most-for-masses.html) that explained it better IMO and has TypeScript code examples.,0.5,TypeScript
14hcw00,jpamyvk,"I also found [Encoding ML-style modules in Rust](https://blog.waleedkhan.name/encoding-ml-style-modules-in-rust/) helpful in the sense of explaining this ""functional"" language feature in terms of an imperative language but it does require familiarity with Rust.",0.0,Rust
14hcw00,jpblsad,> However—and this is the point—the purpose of having different implementations of an interface here is not so we can do some kind of late-bound dynamic dispatch...  What you're describing here reminds me of how templates are used in the C++ STL.,0.19999999999999998,C++
14hcw00,jpblsad,"For example, C++ has for a long time had names like [InputIterator](https://en.cppreference.com/w/cpp/named_req/InputIterator).",-0.05,C++
14hcw00,jpblsad,"Another, weirder example is C# extension methods.",0.0,C
14hcw00,jpblsad,(I think Scala can do something like this.),0.0,Scala
14hcw00,jpblsad,Kotlin too.,0.0,Kotlin
14hcw00,jpblsad,"However, it's not perfect, and there are cases where Kotlin needs to box the wrapped primitive into an object.",-0.5,Kotlin
14hcw00,jpblsad,"Technically, the Kotlin approach isn't restricted to primitives.",0.0,Kotlin
14hcw00,jpblsad,Haskell has the same general idea with [newtype](https://wiki.haskell.org/Newtype).,0.02500000000000001,Haskell
14hcw00,jpblsad,"---  FWIW, if you haven't, you might want to look at Go.",0.0,Go
14hcw00,jpblsad,"To be clear, I'm not recommending Go.",0.10000000000000002,Go
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,C++
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,C
14hcw00,jpb5qkw,"Structs are great for memory usage, and they are fast to get the size and the type itself isn't actually important, it's just a way to more easily see the data (C# Spans have a similar goal).",0.38888888888888884,C
14hcw00,jpb5qkw,"(Later versions try to add more C and C++ features like ""enum"", but its hardly required, and just an easier way to write constants.)",0.06944444444444443,C
14hcw00,jpb5qkw,"(Later versions try to add more C and C++ features like ""enum"", but its hardly required, and just an easier way to write constants.)",0.06944444444444443,C++
14hcw00,jpbfa3n,Insightful blog post but just wanted to mention that behavior can in fact depend on types in Haskell trough the use of type classes.,0.0,Haskell
14hcw00,jpitaev,"I guess I am talking about a specific set of circumstances where you have a high-level, statically-typed language, somewhere between Java and Haskell, and you can write modules that have types as parameters, and types can have ""methods,"" but in many cases the substitution is done at compile time (and this can be relied on, both for performance purposes and for the sake of language features that rely on it).",0.25,Java
14hcw00,jpitaev,"I guess I am talking about a specific set of circumstances where you have a high-level, statically-typed language, somewhere between Java and Haskell, and you can write modules that have types as parameters, and types can have ""methods,"" but in many cases the substitution is done at compile time (and this can be relied on, both for performance purposes and for the sake of language features that rely on it).",0.25,Haskell
14hcw00,jpdskxi,"I'm not a huge fan of Go for other reasons either, but I do actually really like shaped types as opposed to named types.",-0.041666666666666685,Go
14hcw00,jpdskxi,"The advantage, for me, that Go has over OCaml is its explicitness.",0.0,Go
14hcw00,jpdskxi,My major gripe with Go here is that there's no way to let the compiler verify conformance so you're stuck writing a test for every interface you want to make sure conforms and the test is likely only calling a dummy method that accepts the interface.,0.140625,Go
14hcw00,jpdskxi,"Go has some interesting ideas, but is a bit too DIY for my taste to use regularly.",0.25,Go
14hcw00,jpe493c,> My major gripe with Go here is that there's no way to let the compiler verify conformance so you're stuck writing a test for every interface you want to make sure conforms and the test is likely only calling a dummy method that accepts the interface.,0.140625,Go
14hcw00,jpe493c,"If Go added a succinct way to say ""this struct should implement that interface"", I think I would at least be neutral on the topic.",-0.3,Go
14hcw00,jpe493c,"> Go has some interesting ideas, but is a bit too DIY for my taste to use regularly.",0.25,Go
14hcw00,jpe493c,"I think it's trying to be a better C, and I think it largely succeeds at that.",0.6,C
14hcw00,jpe493c,And I think that attitude has ossified in the Go community.,0.0,Go
14hcw00,jpe493c,I remember when generics came to Java 5 (almost 20 years ago) and it was such a huge improvement in the language.,0.20000000000000004,Java
14hcw00,jpe97da,"If Go added a succinct way to say ""this struct should implement that interface"", I think I would at least be neutral on the topic.",-0.3,Go
14hcw00,jpe97da,"With Go syntax, it'd probably be an expansion of tags, like `type MyStruct struct 'implements:[InterfaceA, InterfaceB]' {}` (single quotes because Reddit apparently doesn't like letting us escape ticks).",-0.010714285714285711,Go
14hcw00,jpe97da,I think anyone who's worked in Java is familiar with the inconsistency of the `@Override` annotation.,0.375,Java
14hcw00,jpe97da,">I think it's trying to be a better C, and I think it largely succeeds at that.",0.6,C
14hcw00,jpe97da,"I will give Go that it's a very consciously designed language and a lot of it does contribute to their goals, i.e., there should generally be one way to do things, enforcing KISS, and making the code as easy or easier to read than it is to write.",0.20444444444444446,Go
14gwj0t,jp85094,"I cant use sqlite or postgress for 2 reason first i want to perform the queries on the fly without recreating db from git files and also i want to add a custom queries fit git like push, blame... etc  I started it to test the idea and learning rust and i want it to be wild usages in the near future,  BTW, In the demo i am running queries on the offical Rust analyzer repo.",0.2750000000000001,Rust
14gqgsj,,"I'm pretty sure I've seen this somewhere in the past for Haskell a couple of years back, and maybe some other langs.",0.075,Haskell
14gqgsj,,"Example of unformatted code (Haskell):      data Row = Row {colA :: String, colB :: String}      table :: [Row]     table =     [ Row ""xxxxxx"" ""xx"",       Row ""x"" ""xxxx"",       Row ""xxxxxxxx"" ""xxxx""     ]  Example of the auto-formatted code:      table :: [Row]     table =     [ Row ""xxxxxx""   ""xx"",       Row ""x""        ""xxxx"",       Row ""xxxxxxxx"" ""xxxx""     ]   Obviously the data could just put put in `.csv` / `.tsv` files.",-0.5,Haskell
14gqgsj,jp72n2t,I embed a small bit of Emacs Lisp code that I can manually run to realign things when I make changes.,-0.25,Lisp
14ghevk,jp661h3,So in Prolog Syntax I assume you want something like this.,0.0,Prolog
14ghevk,jp661h3,I hear also some  forms of Prolog support limited version of it.,-0.07142857142857142,Prolog
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,Haskell
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,Prolog
14gcuev,,"&#x200B;  I wanted to ask you how Swift accomplished to define primitive types like `Int`, `Bool` and `Character` in its standard library without having a compiler instrinsic type (I don't know if they exist but I haven't seen them).",0.1,Swift
14gcuev,jp4synt,"Sorry to not answer the question in the title (I don't know about Swift), but [here](https://github.com/nim-lang/Nim/blob/devel/lib/system/basic_types.nim) is how Nim does it (this module is implicitly imported).",-0.5,Swift
14gcuev,jp4z9fz,"Based on the docs, there is a very magic `Builtin` object available for the stdlib: https://www.swift.org/standard-library/  You can also try looking at the source code for the stdlib, but I don't know enough Swift to make sense of anything.",0.35000000000000003,Swift
14gcuev,jpc5r67,"I don't know how Swift does it, but I've done it by making primitive types into ""external"" classes.",0.0,Swift
14g8vwb,,"For processing operations, consider concatenative languages such as Forth, whose operands are on a stack.",0.0,Forth
14g8vwb,jp4d4ak,If you used queues as the underlying data structure in Forth rather than stacks you'd introduce a lot of problems with memory moving around.,0.0,Forth
14g8vwb,jp4itsc,"As Forth illustrates, groups of stack operations can be reasoned about in isolation as an unit that consumes the top N values and pushes M values, making stack-based models very composable.",0.35,Forth
14g8vwb,jp5w8pp,"When coupled with the natural levels of language/supervision (cf Erlang's 5 levels), the upshot is a complete solution for arbitrarily complex computational systems that is fully consistent with arbitrary machine code provided it follows the simple actor model rules.",0.008333333333333337,Erlang
14g8vwb,jp9o3dx,"See LabVIEW G, Simulink, Verilog, Cal for examples of languages.",0.0,Verilog
14g8vwb,jp6wux2,"For instance, Forth’s “retain” is an enqueue, and “restore” is just waiting for the value to come around again.",0.0,Forth
14g8vwb,jp6wux2,One is left-to-right composition of functions:      f : A → B     g : B → C     h : C → D      f g h : A → D     ≅     λs0:A.     let s1:B = f(s0) in     let s2:C = g(s1) in     let s3:D = h(s2) in     s3  The other is right-to-left composition of continuation transformers.,-0.125,C
14g8vwb,jp6wux2,One is left-to-right composition of functions:      f : A → B     g : B → C     h : C → D      f g h : A → D     ≅     λs0:A.     let s1:B = f(s0) in     let s2:C = g(s1) in     let s3:D = h(s2) in     s3  The other is right-to-left composition of continuation transformers.,-0.125,D
14g8vwb,jp6wux2,f : (B → Z) → (A → Z)     g : (C → Z) → (B → Z)     h : (D → Z) → (C → Z)      f g h : (D → Z) → (A → Z)     ≅     λk0:(D→Z).,-0.75,C
14g8vwb,jp6wux2,f : (B → Z) → (A → Z)     g : (C → Z) → (B → Z)     h : (D → Z) → (C → Z)      f g h : (D → Z) → (A → Z)     ≅     λk0:(D→Z).,-0.75,D
14g8vwb,jp4iab6,"Let's assume that it would be a concatenative language, not Forth, and that stacks are not a desired paradigm of computation.",0.0,Forth
14g8vwb,jp482n6,I mentioned concatenative languages and Forth.,0.0,Forth
14g8vwb,jp6u7s3,Assembly or machine code is generally what gives *the ability to* make function calls in higher level languages.,0.15000000000000002,Assembly
14g8vwb,jpa0i4b,Verilog's delayed actions and JavaScript's event-based concurrency are examples of ordering work via a priority queue.,0.0,Verilog
14g8vwb,jpa0i4b,Verilog's delayed actions and JavaScript's event-based concurrency are examples of ordering work via a priority queue.,0.0,JavaScript
14g8vwb,jp4r2ad,I'm not trying to prove a better Haskell or something.,0.5,Haskell
14g8vwb,jp4szga,"The main reason I thought in terms of *only* a queue, is because concatenative languages such as Forth create a great deal of brevity by assuming there's some implicit data you're working on.",0.24166666666666667,Forth
14g8vwb,jp4szga,"I like the brevity offered by Forth, and I like postfix notation just fine, because that's the actual natural order of ASM instructions.",0.17222222222222225,Forth
14g8vwb,jp59yme,Well I was thinking a Forth style global data structure that everything (not separately allocated) gets pushed or popped from.,0.0,Forth
14g8vwb,jp769hr,"Some key differences:  * You send a ""message"" (think procedure/function call that doesn't return -- there's no returned value, no error codes returned, no promise/future, etc, nothing whatsoever is returned) to an ""address"" (think email address, but obviously low level, almost at the level of a machine address but not quite that simple) of an actor (think ""process"" in the general sense and think extremely lightweight, so maybe 256 bytes per ""process"" max -- see Ponylang whose actors/processes are 256 bytes each; I think Scala's are around the same size, or maybe 512 bytes per).",-0.012499999999999997,Scala
14g8vwb,jp8cred,"Secondly, regardless, I'm pretty certain that hand-written assembly for the majority of applications is going to be organized as lists of calls or procedures much like C, simply because it's the intuitive way to organize things.",0.13285714285714287,C
14g8vwb,jp97ljd,That would be a higher level job for the C code of the 3D graphics device driver.,0.25,C
14g8uyu,jp44ey2,It's basically an attempt to find methods of memory safety that are simple enough to retrofit onto C++.,0.0,C++
14g8uyu,jp44ey2,"I'm also thinking about adding a section to the end, briefly going over all the other methods of memory safety that I know, in case someone else can think of a method for making them fit C++.",0.09166666666666667,C++
14g8uyu,jp6kbkg,"""Making C++"" ...  Why try to revive something that is dead by design?",-0.2,C++
14g8uyu,jp4iya6,"Also make sure to relate to prior work in this area (comparing pros/cons--in your talk, I mean, as that would be interesting to the broader C++ audience; no need to reply here):  - -fbounds-safety, https://discourse.llvm.org/t/rfc-enforcing-bounds-safety-in-c-fbounds-safety/70854 - -Wlifetime, e.g., https://godbolt.org/z/_midIP, https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/ - SAL annotations, https://learn.microsoft.com/en-us/cpp/code-quality/understanding-sal?view=msvc-170 - GCC 13 -Wdangling-reference, https://developers.redhat.com/articles/2023/06/21/new-c-features-gcc-13 - “safe libc++” mode, https://libcxx.llvm.org/UsingLibcxx.html#enabling-the-safe-libc-mode - RFC: C++ Buffer Hardening: https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734  - Safe Buffers Programming Model under which any pointer arithmetic is considered unsafe and clang warns about it  - -Wunsafe-buffer-usage initial commit https://reviews.llvm.org/D137346, docs https://reviews.llvm.org/D136811 - [RFC] Lifetime annotations for C++: https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377 	- See also: Comparison with other work in this area: https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377#heading--other-work 	- https://github.com/google/crubit/blob/main/docs/lifetimes_static_analysis.md 	- implementation: https://github.com/google/crubit/tree/main/lifetime_analysis",0.1953125,C++
14g8uyu,jp5zofh,"Well I'm sure you already know [my views](https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html), but the ""brutal"" truth is that anyone who cares about safety and isn't burdened by legacy codebases will use Rust, and so the people still stuck on C++ are the ones who can't just up and migrate their codebase to a new-fangled ad-hoc subset of C++.",-0.1875,Rust
14g8uyu,jp5zofh,"Well I'm sure you already know [my views](https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html), but the ""brutal"" truth is that anyone who cares about safety and isn't burdened by legacy codebases will use Rust, and so the people still stuck on C++ are the ones who can't just up and migrate their codebase to a new-fangled ad-hoc subset of C++.",-0.1875,C++
14g8uyu,jp5zofh,"Also, the design of C++ is fundamentally limited in ways that make it difficult to retrofit safety on top anyway.",-0.023809523809523798,C++
14g8uyu,jp4t8f9,* Something more like Rust's Arc<Mutex<T>> would work.,0.5,Rust
14g8uyu,jp4mzx5,"Edit: Added ""Our ultimate goal is to find simple ways to make C++ memory-safe, simple enough that they can be accomplished via static analysis or linters, without extending the language.""",0.11666666666666665,C++
14g8uyu,jp6v6t3,"So, for most of these places its not easy to simply pivot from C++ to Rust.",0.09444444444444444,C++
14g8uyu,jp6v6t3,"So, for most of these places its not easy to simply pivot from C++ to Rust.",0.09444444444444444,Rust
14g8uyu,jp6cn6i,"I think a lot of people think the same as you do, but there are a few reasons I don't share that worldview:   * If someone actually wanted absolute safety, they'd use a language safer than Rust, perhaps something like Typescript.",0.0,Rust
14g8uyu,jp6cn6i,"Most popular Rust crates have some usage of unverified `unsafe`, either directly or in non-stdlib dependencies.",0.4000000000000001,Rust
14g8uyu,jp6cn6i,"People who use Rust are pragmatic folks who are fine [sacrificing _some_ speed for safety](https://verdagon.dev/blog/myth-zero-overhead-memory-safety), and _some_ safety for their low-level goals.",0.4166666666666667,Rust
14g8uyu,jp6cn6i,"* I believe that with some improvements, C++ can also occupy a sweet spot in that vicinity.",0.35,C++
14g8uyu,jp6cn6i,"And if we can provide a smooth, gradual on-ramp to it (such as described in the draft) that's easier than Rust, then we might actually make it to a memory-safe world faster than we would with a slow global migration to Rust, which I think you would agree is a good thing.",0.13333333333333333,Rust
14g8uyu,jp6cn6i,"* `unsafe`, and the entire C++-to-Rust migration story, suggests that non-memory safe code can coexist with (and gradually transition to) safe code, which hints it's also possible to migrate to a safe subset of C++, or Vale, or CppFront or Carbon if they ever choose to add safety.",0.3,C++
14g8uyu,jp6cn6i,"* There are still some reasons to use C++, such as existing libraries whose paradigms Rust can't reason about (UI, OO, etc), existing frameworks that still use C++ (Unreal), and existing programs that still use C++ (Spanner).",0.0,C++
14g8uyu,jp6cn6i,"* There are still some reasons to use C++, such as existing libraries whose paradigms Rust can't reason about (UI, OO, etc), existing frameworks that still use C++ (Unreal), and existing programs that still use C++ (Spanner).",0.0,Rust
14g8uyu,jp6cn6i,I see a path forward for C++.,0.0,C++
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,Kotlin
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,Swift
14g8uyu,jp6cn6i,I'd hesitate to say that Rust's future supremacy is a brutal truth.,-0.4375,Rust
14g8uyu,jp4usus,"FWIW, `int main() {}` is legal and standard (including omitting the explicit `return 0;` statement)--and shorter than the `void` version (which is sufficiently out of place in either C or C++ code to be distracting here, I think), https://en.cppreference.com/w/cpp/language/main_function  > The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.",0.13999999999999999,C
14g8uyu,jp4usus,"FWIW, `int main() {}` is legal and standard (including omitting the explicit `return 0;` statement)--and shorter than the `void` version (which is sufficiently out of place in either C or C++ code to be distracting here, I think), https://en.cppreference.com/w/cpp/language/main_function  > The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.",0.13999999999999999,C++
14g8uyu,jp4usus,"More on the friendly nitpicking side ;-) Using `std::endl` (I cannot bring myself to omit `std::`) other than as an explicit buffer flushing operation for a non-error output stream is going to raise some eyebrows, too: C++ Weekly - Ep 7 Stop Using std::endl, https://www.youtube.com/watch?v=GMqQOEZYVJQ",0.25,C++
14g8uyu,jp55a2n,"No problem, glad the nitpicking can be useful :-)  As for the `std::endl`: Generally I'd go with the isocpp.org FAQ, https://isocpp.org/wiki/faq/input-output#endl-vs-slash-n or the C++ Core Guidelines, https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio50-avoid-endl  In my context `'\n'` is also shorter to type than `std::endl`--with the context being never `using namespace std;`, https://isocpp.org/wiki/faq/coding-standards#using-namespace-std (yes, even for short snippets of code that I need to fit on the slides in a presentation--it can be even more useful for talks as the audience can quickly tell at a glance whether I'm talking about, say, `std::sort`, `llvm::sort`, https://developers.redhat.com/blog/2019/10/18/extend-c-capabilities-with-llvm-stlextras-h, or more likely `std::ranges::sort` nowadays).",0.30757575757575756,C++
14g8uyu,jp54mps,"I updated the article to add this near the top (in response to another comment):  > Our ultimate goal is to find simple ways to make C++ memory-safe, simple enough that they can be checked via static analysis tooling or linters, without extending the language.",0.2,C++
14g8uyu,jp54mps,"Some things feel Rust-esque (borrowless affine style and simplified borrowing, definitely), but the other parts (gen refs, constraint refs, shared_ptr) are specifically to make things easier than Rust.",-0.0625,Rust
14g8uyu,jp5c8oz,"I'm saying that we don't need to change anything in the C++ compiler (clang, GCC, etc) or the C++ standards.",0.0,C++
14g8uyu,jp5c8oz,"I suspect you mean ""We need to change how we use C++, which in practice is just like changing the language"", which is a reasonable stance TBH, even though I don't necessarily share the definition.",-0.0375,C++
14g8uyu,jp6kr58,"If you squint, it's what Rust's borrow checker is doing too since you can choose to use `unsafe` anywhere you'd like (minus the opt-out/opt-in distinction).",-0.1,Rust
14f99ui,joz2wx9,"Languages like TS, Crystal are able to infer things to a limited extent, and certain advanced techniques like semantic subtyping and [algebraic subtyping](https://lptk.github.io/files/[v6.2]%20mlstruct.pdf) can provide complete or almost complete inference, though it may take some time to understand these approaches.",0.20714285714285718,Crystal
14f99ui,joyurgi,"Python tools like mypy or pyright have overloads, which let you specify the output given specific inputs (especially with the Literal type).",0.0,Python
14f99ui,jp06h0q,"If you're looking more generally for ""I have a type union A | B | C, but here there's only A | B"".",0.18333333333333335,C
14f99ui,jp06h0q,"It's a type system built after the fact on top of Erlang, and infers types (that are unions of values) from the code.",0.5,Erlang
14f99ui,jp06h0q,"The advantage of this approach to typing is that the type system can express the types A, A | B, and A | B | C with no trouble.",0.1,C
14f99ui,jp0fjw1,"In Haskell, you would write something like       {-# LANGUAGE FunctionalDependencies #-}  -- implies MultiParamTypeClasses      class Fooable a b | a -> b where         -- | a -> b is the functional dependency                                              -- implying that the type of b depends on the type of a.         foo : a -> b      instance Fooable Array Array where         foo = fooArray      instance Fooable Float Float where         foo = fooFloat  If you then call `foo` with an array argument, it will infer the result type to be array so you need not specify it.",0.0,Haskell
14f99ui,jp0fjw1,---  Another possibility to consider is C++ function template specialization:      template <typename T>     T foo(T x);      template<>     float foo<float>(float x) { ... }      template<>     array foo<array>(array x) { ... }  Function template parameters can be inferred from the argument type (but cannot be inferred from return type).,0.0,C++
14f5wp0,,The compiler is written in Kotlin without using any 3rd party dependencies and is around ~300 lines.,0.0,Kotlin
14f5wp0,,"If people are curious or find my work useful I'll upload the code and provide a Kotlin script that can be easily executed like ``` qc template.qc ""{ //JSON vars here }"" ```  What are your thoughts?",0.2111111111111111,Kotlin
14f5wp0,jplg2bf,"Another possible approach for this is doing something similar to what a Lisp does: build up a data structure representing the AST, and dump that out to a string.",0.0,Lisp
14f5wp0,jplg2bf,"Then you can write functions that generate a 'sub-AST', akin to Lisp macros.",0.0,Lisp
14f5wp0,jplg2bf,"Haskell tends to be quite nice for this (for example because it allows you to define custom infix operators, and is quite good at dealing with recursive data types).",0.6499999999999999,Haskell
14e8erj,jpse5ao,So if you have a program written in COBOL in 1965 then it will run fine in 2365 on the Star-Ship Enterprise if you only present it to a COBOL compiler designed to target the Majel Barrett Architecture.,0.1388888888888889,COBOL
14dlbc8,joztdsm,"This is basically equivalent to using a per-type arena allocator in C, which is not memory safe by any reasonable standard.",0.2333333333333333,C
14dlbc8,jozhkao,"Or perhaps also about unsafe languages guarded with sanitizing tools, e.g., like C with AddressSanitizer?",0.4,C
14dlbc8,jor31j7,However to me it felt like I had roughly as many `if` checks as I would need in C++,0.5,C++
14dlbc8,joyagx3,ATS gets to zero-cost memory safety much closer than most others including Rust.,0.35,Rust
14dkx6p,josoi9l,"For a couple examples of recent _adoption_ of PEG,   * Python is moving from a LL(1) parser to a PEG parser: https://peps.python.org/pep-0617/ * Zig's grammar is specified as a PEG: https://github.com/ziglang/zig-spec/blob/master/grammar/README.md",0.0,Python
14dkx6p,jotu9nl,Languages like C usually resolved the dangling else conflict by an ad hoc disambiguation criteria.,-0.25,C
14de1dr,joszfjl,This is exactly what should have been happening for Elm in the last 5 years.,0.125,Elm
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,C
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Java
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Ruby
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Prolog
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,Lisp
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,C++
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,PHP
14daokr,jrbb5ty,An example could be C++ references.,0.0,C++
14daokr,jrbb5ty,"C++ also has pointers which it ""inherited"" from C. So now it has to equivalent features that basically do the same, but in different ways, and they also interact in weird ways.",-0.16666666666666666,C++
14daokr,jrbb5ty,I guess Stroustrup's reason may have been that this meant that C++ could have backwards compatibility with C. In my opinion this came at a high price.,0.16,C++
14daokr,jrbb5ty,"C++ was attempting that, but failed: it added a new kind of pointers - yet at the same time it changed the meaning of struct types.",0.05909090909090908,C++
14daokr,jrbb5ty,Look at Object Pascal to see how OOP could be added without messing up with the base Pascal language.,-0.8,Pascal
14daokr,jrbb5ty,"By the looks of what went into C23, I expect the next version of C to include lambdas - but why does the latest version then not at least have nested functions, a simple and useful feature that already exists as incompatible proprietary extensions in the two probably most influential compiler systems GCC/GNUC and Clang, and was standard in Algol- and Pascal-derived languages going back to the late 60es and 70es?",0.07777777777777778,C
14daokr,jrbb5ty,"Why isn't there a language close to being as simple as original C or Pascal/Modula-2, with all the lessons added that we ought to have learnt in 75 years of computers and programming language design.",0.1875,C
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,C
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,C++
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Java
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Swift
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Go
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Rust
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Scheme
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Perl
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Python
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,PHP
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Ruby
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,Haskell
14daokr,jrbb5ty,"Other scripting languages fill this niche now, perhaps mainly Javascript and Python (until recently Php), and before them it was BASIC.",0.010416666666666664,Python
14daokr,jrbb5ty,"And of course there are the immortal dinosaurs, FORTRAN and COBOL, and maybe even their offspring PL/1.",0.0,COBOL
14daokr,jop8s0h,"They usually come back to the same archetypes:  Algol C likes, lisps, MLs  Edit : for non dead languages :)",0.009999999999999998,C
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Python
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Haskell
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Rust
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,Go
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,TypeScript
14daokr,jop3dvi,"Why would I use a language without even syntax highlighting where I'd need to run the compiler to see typos when I can just use typescript or Kotlin with a full IDE, autocomplete, linting etc.",0.35,Kotlin
14daokr,josx2j0,The only language that I'd call dead is Elm.,-0.1,Elm
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,Prolog
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,Forth
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,APL
14daokr,joqaqug,"To be fair, almost every new language did become popular because it was very similar to an existing popular language (almost always C, and C is quite similar to Algol).",0.33939393939393936,C
14czkbu,joppssr,I recommend  - https://davidchristiansen.dk/tutorials/nbe/ in Racket or https://davidchristiansen.dk/tutorials/implementing-types-hs.pdf in Haskell - https://github.com/AndrasKovacs/elaboration-zoo,0.0,Haskell
14czkbu,joqqa0o,It seems like something along the lines of Rust's shared vs unique references might be useful here.,0.3375,Rust
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,JavaScript
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,C++
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,Rust
14cxmbr,jona67v,"Better to:  \- support all reasonable operations on all containers (push-back, push-front, delete, insert, etc)    \- use the same interface for all containers so it's easy to move between them   \- make the tradeoffs clear in documentation     Otherwise people will invent their own containers that do what they want, then you'll get two standard libraries (look at boost vs C++ STL ugh), and then everyone will use both, and then everything will be a mess.",0.15648148148148147,C++
14cxmbr,jooloet,"See for example [""Q: Remove element by value in Go list""](https://stackoverflow.com/questions/31080285/remove-element-by-value-in-go-list).",0.0,Go
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,Lisp
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,C
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,Rust
14cxmbr,joonxut,"Clojure is good here, even if it means sometimes weird decisions at first glance.",0.15,Clojure
14cxmbr,jot5z43,Historically boost could be viewed as a feeder for getting libraries into the ISO C++ standard.,0.0,C++
14cxmbr,jot5z43,For a better example of the two conflicting standard libraries problem consider Tango and Phobos from the early days of [D](https://en.wikipedia.org/wiki/D_(programming_language)).,0.19999999999999998,D
14cv7tg,joqnjz7,"The last few months has been implementing threads, getting a second backend, implementing cross language inline (so C++ code inlines into bolin builds), improving codegen so the optimizer doesn't need to deal with sloopy codegen, now recently syntax changes, etc  There's going to be quiet a few months before we'll have a killer app with all the syntax it uses fully implemented.",-0.05714285714285715,C++
14cu0id,joof9xj,"On a Pentium4 machine, the register machine required 32.3% less time to execute standard benchmarks if dispatch is performed using a C switch statement.",-0.08333333333333333,C
14cu0id,joof9xj,Designing your runtime around the constraints of the hardware can be the difference between your language being ~10x slower than C versus ~100x slower than C.,0.0,C
14cu0id,jop6u3u,Here's a recent article about [arbitrary decisions in Rust](https://graydon2.dreamwidth.org/307291.html).,-0.05,Rust
14cu0id,jooo6tr,"The reasons Java went stack only were, one to avoid to look like another processor codes and avoid been sued.",0.0,Java
14cqhj1,,"I came across the paper and presentation [*Generalized Evidence Passing for Effect Handlers*](https://www.microsoft.com/en-us/research/uploads/prod/2021/03/multip-tr-v4.pdf), (and it's Haskell implementation [EvEff](https://hackage.haskell.org/package/eveff)) which describes the process Koka's compiler uses when compiling effect handlers to C, but it is a completely over my head and I am not very familiar with programming language papers.",-0.022115384615384606,Haskell
14cqhj1,,"I came across the paper and presentation [*Generalized Evidence Passing for Effect Handlers*](https://www.microsoft.com/en-us/research/uploads/prod/2021/03/multip-tr-v4.pdf), (and it's Haskell implementation [EvEff](https://hackage.haskell.org/package/eveff)) which describes the process Koka's compiler uses when compiling effect handlers to C, but it is a completely over my head and I am not very familiar with programming language papers.",-0.022115384615384606,C
14cqhj1,jon1fac,"I think what happens in C is that the handler is called immediatly and then if you need to suspend, a global variable is set and the function return (if you don't need to suspend, the handler just return the value), then every function above in the call stack will check if the global variable is set and if so will add the continuation to the list and the return.",0.0,C
14cqhj1,joon6w8,"I'd like to explain how the ""bubbling"" works in analogy to how the `Result` monad works in a strict language like OCaml or Rust.",0.0,Rust
14cqhj1,jom1aqd,"I did notice that the EvEff implementation uses a free monad, but I believe in the compilation to C the monad is compiled away rather than interpreted at runtime.",0.4,C
14chayf,,"I have absolutely no idea how to approach parsing, so much so that I got bored and am currently rewriting the lexer in like 3 other languages (the implementation on GitHub is in Go).",-0.10500000000000001,Go
14chayf,jolqbch,"There are many ways to go about implementing a parser, but if you are just getting started and the jargon about LR, LL(1), context-free grammars is going over your head, here's what I would recommend (I'm also gonna assume you're gonna use Go because you mentioned Go):  You probably want to have expressions in your language.",0.5,Go
14chayf,jolr2p4,I have write [a blog about writing a parser in Haskell](https://terenceng03.github.io/blogs/parser_combinator.html).,0.0,Haskell
14chayf,jom28iu,"I'm going to use C as the example language to parse, where every top level item is a declaration of some sort, could be variables, types, function prototypes/forwards, or function definitions.",0.5,C
14chayf,jom28iu,"When a C function is defined, language statements are allowed (a block is required to start).",0.0,C
14chayf,jom28iu,"For C, expressions may also appear in declarations, so the declaration parser needs a subset of an expression parser, where in some sense, basically only unary operators are allowed (with an exception for constant expressions such as for initializers and array bounds, which allow binary operators as well).",0.0,C
14chayf,jom28iu,"A language like C requires complete forward declarations, so can logically combine symbol table construction, scoping maintenance, as well as symbol resolution with parsing.",0.175,C
14chayf,joq1bvt,"Check out ""Writing an Interpreter in Go"" by Thorsten Ball.",0.0,Go
14camve,,"Is the idea that the linters take the AST (like a Rust linter, how does it work in Rust?",0.0,Rust
14camve,jok4xpl,"For example the transformation `x == False` -> `x is False` is suggested by some Python linters, but since operators can be overloaded this can cause the program to break.",-0.4000000000000001,Python
14c83jy,,"I don't like how TypeScript does it and makes it so the global is extended, because then you can't have different versions of the type at the same time.",0.0,TypeScript
14c83jy,jol0mo7,"Swift allows new members to be declared in extensions, but they have some limitations.",0.13636363636363635,Swift
14c83jy,joleoek,It might be worth looking into extension methods in [Kotlin](https://kotlinlang.org/docs/extensions.html) and [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/).,0.3,Kotlin
14c83jy,joleoek,It might be worth looking into extension methods in [Kotlin](https://kotlinlang.org/docs/extensions.html) and [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/).,0.3,Swift
14c83jy,joleoek,"Alternatively, you can do similar things in Rust with traits.",0.0,Rust
14c83jy,joleoek,"In Rust, however, that ""I follow this interface"" declaration is separate from the class declaration, which means you can declare methods on classes that you didn't write.",0.0,Rust
14c83jy,joleoek,"For example, in Rust, `Vec` is the built-in equivalent of Javascript's `Array`.",0.0,Rust
14c83jy,joleoek,"I could write a `CanSlice` trait in my own code, and implement it for the built-in `Vec` type, and then as long I've imported the trait and Rust knows about it, I can use the `slice` method from my trait on the built-in type.",0.27499999999999997,Rust
14c83jy,joleoek,"Rust normally exports an `Iterator` trait, which has a bunch of different ways of iterating over collections.",0.075,Rust
14c83jy,jokn1n1,"The inconsistencies push you to try to add methods, but this problem does not exist in the first place if you go with plain functions first (see Haskell and typeclass methods).",0.04642857142857143,Haskell
14c83jy,jok7aiy,Look at Ruby for prior art.,0.0,Ruby
14c83jy,jomlyug,"I like how Rust does this particular thing, though it could go further.",0.08333333333333333,Rust
14c3wkr,,So I've started to work on this new programming language that aims for building machine learning systems (like what Python has being doing so well in recent years).,0.06818181818181818,Python
14c3wkr,,"I have thought of some of these small features that might be interesting for AI/ML people:  * better performance over Python (which should be the same case for different sorts of hardware); * better compile time checking, which minimises run time error (such as strongly typed, but would not require a type keyword when initialising variables like Python, so a type inferencing system is required); * better native support for AI/ML code/utils, like built-in tensor types, functions, etc.",0.2425925925925926,Python
14c3wkr,jok7lut,"Additionally, almost all of the runtime on large models is spent doing matrix multiplications that are implemented in C, so the python overhead matters very little.",-0.04315476190476192,C
14c3wkr,jok7lut,Honestly I think there's not much that can easily be improved on vs Python.,0.3111111111111111,Python
14c3wkr,jolfwx6,Even Fortran was better at this than many modern languages.,0.39999999999999997,Fortran
14c3wkr,jokppjp,"So because this language is planing to support JIT compiling, a notebook style debugging / documenting system should be relatively easy to implement, so this means dynamic compiling, or more specifically, it will have a compiler and an interpreter, which will support features like interactive debugging and interactive command line tools like Python's idle.",0.3111111111111111,Python
14c3wkr,jokppjp,"In terms of the actual performance gain over Python, you are right, the critical part of ML computation is handled with C. However, seeing what Mojo's LLVM & MLIR system can do, I'm confident that with careful optimisation, there are still some potential for these languages to improve upon C's performance, especially in exotic hardware like GPUs, TPUs and NPUs.",0.24081632653061225,Python
14c3wkr,jokppjp,"In terms of the actual performance gain over Python, you are right, the critical part of ML computation is handled with C. However, seeing what Mojo's LLVM & MLIR system can do, I'm confident that with careful optimisation, there are still some potential for these languages to improve upon C's performance, especially in exotic hardware like GPUs, TPUs and NPUs.",0.24081632653061225,C
14c3wkr,jokppjp,"Even if there is little performance gain over C, MLIR will provide much better scalability to different hardware without the need for changing much code.",0.128125,C
14c3wkr,jokppjp,"Python is a great language, especially for AI/ML, to dramatically improve the performance of large models like large transformer models, the change has to be low level, so in the implementation of the language used to build the model, or hardware improvements.",0.2457142857142857,Python
14c3wkr,jokppjp,"It is hard to build on top of or even surpass Python in some areas, without sacrificing existing develop&debug experience, but like what I mentioned before, it is not impossible.",0.18055555555555555,Python
14c3wkr,jov7prv,"So, Haskell's port of torch does this, but it requires type-level integer addition.",0.0,Haskell
14c2017,,"Hi  A few years ago Ive written a virtual processor runtime and a simple compiler for a somewhat self designed/dialect of a low level assembler language, all written in C++ as a learning project.",-0.06666666666666667,C++
14c2017,,:)   I since would like to rewrite the runtime environment/virtual processor part in Rust.,0.5,Rust
14c2017,,"Feel free to check out the repositories: (Warning, not the best docs and certainly not the best c++ haha)   Virtual Processor/Rumtime Environment  - https://github.com/pointermess/FlexRTE-X  Assembler/Compiler/FlexASM to FlexRTE Executable  - https://github.com/pointermess/FlexASM-Compiler  Some docs if interested  FlexASM Quick Start - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexASM%20QuickStart%20Guide.md - https://github.com/pointermess/FlexRTE-X/blob/master/SystemCalls.md - https://github.com/pointermess/FlexASM-Compiler/tree/master/examples  Flex Executable Format (Basically the generated ""machine""/byte code from my asm dialect)  - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexApplication%20Excutable%20Format.md   Thanks for your time   For the lulz, my unfinished attempt at a tiny C compiler, comes with tokenizer, ast parser and representation.",0.25261904761904763,C
14c2017,jokcrsl,If you just use `malloc` (C) or `new` (C++) then it will typically attempt full allocation.,0.10656565656565657,C
14c2017,jokcrsl,If you just use `malloc` (C) or `new` (C++) then it will typically attempt full allocation.,0.10656565656565657,C++
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,R
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,D
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,C++
14bz7jf,joikybk,Look at Ada and it's subset Spark.,0.0,Ada
14bz7jf,jozyn5i,The first talks about how a JS and Go program that are textually almost identical have very different security properties.,0.125,Go
14bz7jf,jozyn5i,- I worked on Go's [html/template](https://pkg.go.dev/html/template) library which touches on design of DSLs for [securely composing network messages](https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition) from untrusted and trusted strings.,0.4,Go
14bz7jf,joj4bkb,Look at papers about Rust.,0.0,Rust
14bz7jf,joj4bkb,Rust took a lot of stuff from Cyclone and then put it in a security critical path.,0.0,Rust
14bz7jf,joklvnx,Haskell and Rust should provide plenty of opportunities to write real code with strong static guarantees.,0.37777777777777777,Haskell
14bz7jf,joklvnx,Haskell and Rust should provide plenty of opportunities to write real code with strong static guarantees.,0.37777777777777777,Rust
14bz7jf,joklvnx,"You could also look into properly dependently-typed languages, but they tend to lack a large ecosystem, so I'd say Haskell is currently the farthest you can go.",0.07142857142857142,Haskell
14bz7jf,jp0c941,"For example, Java's stronger typing makes it easy to preserve invariants around what messages an object can respond to.",0.43333333333333335,Java
14bz7jf,jokthru,"Ada forces you to make objects aliased if you need to access them through another object and it limits their scope and usage, you can extend it in unsafe ways in which  you have to specify, i.e.",0.0,Ada
14bz7jf,jokthru,Parallel blocks are in Ada 2022.,0.0,Ada
14blzws,jogwzfc,Obviously ignore the fact that Java messed up the default treatment of arrays.,0.0,Java
14blzws,jogqayy,"Got your point, thanks for your answer :D  Currently I'm unable to write your counter-example in TS because it seems that TS isn't smart enough, but if the type system allowed me to exploit the invariant of `f` and `s` having the same type I would have had some surprises at runtime if `Pair<U | V>` and `Pair<U> | Pair<V>` were considered equal.",0.13061224489795917,D
14blzws,jolb0lo,Thanks for the clarifications anyway :D,0.6,D
14b8c0r,,"Egel is implemented in C++ without an explicit garbage collector, parallel evaluation is simply spawning of another root node, and the graph -or parts of the graph- can be serialized, shipped, or saved to disc.",0.0,C++
14b8c0r,,"import ""egel_rpc.ego""          using System          def main =          let C = rpc_client ""localhost:50001"" in              rpc_call C [_ -> [X -> X] ] 42  In the above example, a lambda is sent to server, that returns the identity function to the client, and the client applies that to the constant 42.",0.05555555555555555,C
14b8c0r,,"import ""prelude.eg""      import ""egel_rpc.ego""          using System using List          def main =          let C = rpc_client ""localhost:50001"" in              rpc_call C [_ -> from_to 1 1000 ] |> sum   It works reasonably well but I am still wrinkling out the features.",0.18333333333333335,C
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,Java
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,Python
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,Rust
14acrae,,"Rust went the GAT way, and all pure functional languages that have HKTs that I know don't monomorphize.",0.21428571428571427,Rust
14acrae,,"C++ and D template metaprogramming come somewhat close, but are not exhaustively type-checked like proper implementations of HKTs.",0.0,C++
14acrae,,"C++ and D template metaprogramming come somewhat close, but are not exhaustively type-checked like proper implementations of HKTs.",0.0,D
14acrae,jobtxo7,But HKT is perfectly compatible with monomorphization and it would work fine in Rust.,0.7083333333333334,Rust
14acrae,jo9vza1,"Also, Haskell has its equivalent of GATs through functional dependencies.",0.0,Haskell
14acrae,jo9vza1,"Finally, functional languages face different tradeoffs than Rust does.",0.0,Rust
14acrae,jo9vza1,"By contrast, for a language like Rust, different types are represented differently on the stack, so even something as simple as hard-coding the size of stack allocations can be a big win.",0.16,Rust
14acrae,jobul1u,"I think they are as expressive as Haskell's HKTs (you can define abstractions for functors, monads, etc), but notationally much more cumbersome.",0.65,Haskell
14acrae,jobul1u,"`(Type -> Type) -> Type`) things get quite hairy, and while I think the module language is strong enough to express it, it becomes quite a Turing tarpit compared to Haskell.",0.21666666666666665,Haskell
14acrae,jocqg4b,"From what I've heard, Standard Chartered's Haskell variant Mu also uses monomorphization, I'm guessing it must support HKTs, otherwise, it wouldn't really be Haskell-like, but I don't have first-hand knowledge of it.",0.1,Haskell
14acrae,joc5z8s,">so far these languages only allow parameterisation over types, not type constructors  C++ has ""template template"" parameters though.",0.05,C++
14a79va,jo9731m,"*/     	free(p);  /* error: `p` has already `moved` */     }  Even wrote a POC C parser so I could extend the type system and enforce this, but never completed it because life caught up.",0.0,C
14a79va,jo91kix,"I liked lot of parts for instance:  ""As any C programmer knows, we carefully track who owns the data,"" "" We have a mental distinction between owning pointers and non-owning pointers.""",0.13333333333333333,C
14a79va,job9xz0,"For example:      users = [userAlice, adminBob, evilCharlie]     adminIDs = [1]     ...     users.remove(0) // Alice deleted her acouunt     ...     for index in adminIDs:         giveSecretsTo(users[index])         // whoops, just gave secrets to Evil Charlie!",-1.0,Alice
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,Rust
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,C
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,C++
14a79va,joizi09,"Here's another example:      users = [alice, bob, charlie]     gifts.append({recipient_id=1, item=""Apple""}) // Give Bob an apple     ...     users.remove(0) // Delete Alice     ...     for gift in gifts:         users[gift.recipient_id].send_message(""You got a ""+gift.item)         // Whoops, just told Charlie he got an apple instead of Bob  A more safe way to approach this would be with a map from globally unique IDs to users: `users = {alice.id: alice, ...}`.",0.4583333333333333,Alice
14a79va,jodn5rt,> a segfault isn't guaranteed in C or C++  Yep!,0.0,C
14a79va,jodn5rt,> a segfault isn't guaranteed in C or C++  Yep!,0.0,C++
149vqg4,,"I know that TypeScript allows you to specify array types like this: [Header, ...Body[], Tailer].",-0.75,TypeScript
149vqg4,jo7d336,"There are some nice languages for implementing state machines, like Ragel, which can emit code in C and C++.",0.6,C
149vqg4,jo7d336,"There are some nice languages for implementing state machines, like Ragel, which can emit code in C and C++.",0.6,C++
149vqg4,jo7guzo,"Clojure spec allows you to type collections using regular expressions, but they are only checked at testing/runtime, not statically.",0.0,Clojure
149vqg4,jo8j38j,Or like in Rust if something is marked [must_used](https://doc.rust-lang.org/std/hint/fn.must_use.html) it can be used to trigger the problem.,0.1,Rust
149vqg4,jo8hree,Erlang bit syntax is somewhat related to this.,0.0,Erlang
149vqg4,jodi9wk,"In Rust, it's usually done manually via session types:      pub fn stream() -> (Sender<Header>, Receiver<Header>);      pub struct Sender<T>(...);      impl Sender<Header> {         #[must_use]         pub fn send_header(self, header: Header) -> Sender<BodyPart>;     }      impl Sender<BodyPart> {         #[must_use]         pub fn send_body(self, body: BodyPart) -> Self;          pub fn send_tailer(self, tailer: Tailer) -> Sender<Header>;     }  So, that's cool, we have a state machine that enforces the sequence Header, followed by any number of BodyParts, followed by Tailer.",0.04999999999999999,Rust
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,Rust
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,C
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,Python
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,JavaScript
149vqg4,jo9bibi,"I'm don't know much Erlang, so I'm wondering is there a difference between giving the ascii code points as numbers      <<82,73,70,70>>:4/binary-little, %""RIFF""  compared to specifying it with the ascii string itself      <<""RIFF"">>:4/binary-little,  The latter would feel a bit more ergonomic to use.",0.2333333333333333,Erlang
149vqg4,jo8nwkr,"Unless you mean that thing which TypeScript calls tuples, because that is pretty much what I'm interested in.",0.096875,TypeScript
149vqg4,jo9evma,"IIRC, in Erlang a string is just syntactic sugar around a binary.",0.0,Erlang
149vqg4,jo9evma,The code I pasted was lifted directly from an actual program I wrote while learning Erlang.,0.05,Erlang
149fzge,jo6vuh7,This is basically the C++ approach.,0.0,C++
149fzge,jo6vuh7,"This is basically the Java approach, especially since generics are erased at runtime.",0.0,Java
149fzge,jo8ydgo,"In the case of C++, template instantiation is *roughly* similar to macro expansion.",0.0,C++
149fzge,jo8ydgo,I don't know how clever C++ compilers are at reusing work.,0.16666666666666666,C++
149fzge,joajp8g,"Again, I'm not quite sure how C++ compilers work under the covers.",0.5,C++
148szdv,,"As I'm sure many of you will be aware, when implementing a new language, the ability to call C code from it is very useful because of the ubiquity of existing software and libraries in said language, and because in most OSes it's the only way you can talk directly to the OS.",0.29704545454545456,C
148szdv,,"This had me thinking, gee it'd be great if I could automatically import the stdlib declarations from C headers into my language without having to write special ""glue"" code for each declaration I want to import...",0.5785714285714286,C
148szdv,,"I figured I could use a minimised C parser that is only designed to understand declarations (no definitions, function implementations or whatever), to parse any C header file that is requested, and then comb the declarations out of there.",0.0,C
148szdv,,"This should work fine for all C code which only consists of declarations, however there's a big issue here: what about macros?",0.1388888888888889,C
148szdv,,Edit: I'm wondering whether I should look into using SWIG for this and consume the XML parse tree it outputs for C headers on my end...,0.0,C
148szdv,jo1snic,">the ability to call C code from it is very useful because of the ubiquity of existing software and libraries in said language, and because in most OSes it's the only way you can talk directly to the OS.",0.2475,C
148szdv,jo1snic,"These just happen to be low level machine types, they are not specific to C.  But it is unfortunate that APIs for such libraries are very often expressed as C header files, using C syntax, which is really unsuitable for describing cross-language interfaces, for many reasons some of which you've discovered:  * It is necessary to parse C declaration syntax * Nested includes need algorithms (which are implementation-defined) to locate header files, together usually with a location for system headers, and a bunch of search locations for others * Headers may include conditional blocks using `#if`, `#ifdef` and so on.",0.01666666666666667,C
148szdv,jo1snic,"* Macro may expand to arbitrary C expression syntax * Instead of enumerations, headers may use tons of `#defines` to declare global constants.",-0.05,C
148szdv,jo1snic,There isn't really a simple solution that doesn't involve at least half of a C compiler.,-0.15555555555555556,C
148szdv,jo1snic,It does involve a home-made C compiler.,0.0,C
148szdv,jo1snic,"Some macro are simple, but others can contain arbitrary C code, expressions or statements.",-0.05,C
148szdv,jo1snic,Now you need a transpiler *from* C to your language (the other way is more common!).,0.0,C
148szdv,jo1snic,"Sorry I don't have a solution for you, and don't really like solutions that involve a C compiler (I think Zig bundles Clang for example).",-0.15,C
148szdv,jo1up8e,luajit ffi does a similar thing and it just ignores the macros....      it expects fully preprocessed C headers.,0.0,C
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,Pascal
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,C
148szdv,jo2yqa4,"A more modern approach is to write a tool to do a rough parse of the preprocessed C headers (I once wrote [a simple regex-based PHP script for that](https://github.com/uliwitness/Forge/blob/2c9e3245896342d10875629c1817bce909872a17/headerimport.php) for Apple platforms) and then add an ""overlay"" of hand-written code in your language that can replace parts of the automated import, or provide a more native interface.",0.22000000000000003,C
148szdv,jo2yqa4,"A more modern approach is to write a tool to do a rough parse of the preprocessed C headers (I once wrote [a simple regex-based PHP script for that](https://github.com/uliwitness/Forge/blob/2c9e3245896342d10875629c1817bce909872a17/headerimport.php) for Apple platforms) and then add an ""overlay"" of hand-written code in your language that can replace parts of the automated import, or provide a more native interface.",0.22000000000000003,PHP
148szdv,jo2yqa4,"Swift does that very well, but I think Perl does something similar.",0.1,Swift
148szdv,jo2yqa4,"Swift does that very well, but I think Perl does something similar.",0.1,Perl
148szdv,jo2yqa4,"Swift allows this by annotating API so it gets imported ""hidden"" and can only be used by the overlay.",-0.08333333333333333,Swift
148szdv,jo2yqa4,"In any way, as C API is often not complete anymore, you'll likely end up writing a different script for each platform, one to parse Apple's Swift interfaces, one for Microsoft's C# interfaces etc.",-0.016666666666666666,C
148szdv,jo2yqa4,"In any way, as C API is often not complete anymore, you'll likely end up writing a different script for each platform, one to parse Apple's Swift interfaces, one for Microsoft's C# interfaces etc.",-0.016666666666666666,Swift
148szdv,jo2yqa4,You might even write it so that it generates little C adapter functions based on attribute annotations and other things a particular platform's headers contain (e.g.,-0.04861111111111111,C
148szdv,jo2yqa4,Apple's headers use a proprietary 'nullable' attribute on all C headers to provide information C usually doesn't have).,-0.25,C
148szdv,jo3jzmq,In general as many others have mentioned C headers are a nasty pice of code and you'll effectivly need a full C compiler to parse them.,-0.024999999999999994,C
148szdv,jo3jzmq,Solutions to this problem include  a) Just have C or large parts of it as a subset in you language.,0.21428571428571427,C
148szdv,jo3jzmq,This is for the most part what C++ does.,0.5,C++
148szdv,jo3jzmq,"(More technically however most C headers still have to use ifdef CPP wrapped extern ""C"" blocks to get the name mangling right.)",0.3214285714285714,C
148szdv,jo3jzmq,"b) Just like a) but instead of really being a real subset, we parse C files with a different tokenizer, that remapps common tokens like ""if"", ""for"" and ""int"" onto specialized C version.",0.02500000000000001,C
148szdv,jo3jzmq,This would allow you to not being forced to have C constructs to take all the sweetspots.,-0.30000000000000004,C
148szdv,jo3jzmq,c) Have a bindgen tool like Rust's cbindgen.,0.0,Rust
148szdv,jo3jzmq,This uses libclang to parse you code and then create somehow meaningfull Rust code from it.,0.0,Rust
148szdv,jo4z5u8,It also supports some limited amount of C++ bindings which further complicates things.,-0.03571428571428571,C++
148szdv,jo3dix7,"In what I can only describe as _thoroughly annoying_, it turns out that stdlib implementations often don't just contain macros that we have to handle, but actual C code too (not just prototypes)!",-0.26666666666666666,C
148szdv,jo3jn0g,"It's almost like this problem is so annoying that I'm better off just building a library that documents the structure of the C stdlib in a machine-readable way using data structures, from which then any needed C glue code can be generated to lift out macro definitions and what-not...",-0.15000000000000002,C
148szdv,jo1t4cu,"I am really curious about your tool that parses C headers, would you mind linking to it, if it's openly available?",0.15000000000000002,C
148szdv,jo4wpme,C isn’t portable at all either without tons of macros.,0.0,C
148szdv,jo2zp1g,"I won't be wanting to parse function definitions like `int main(){}`, only declarations such as `int rand();`...  Re typedefs, yes I am already anticipating needing to do some kind of typedef-tree lookup in my parser for this (looking at preprocessed C source made it abundantly clear of the need to do so!).",0.17833333333333332,C
148szdv,jo2zzmf,"On adapting things, I've already contended with that at the bare minimum, I will need to write some additional C code of my own to be patched onto the end of any stdlib headers that define macros that I might want to use in my lang...",0.325,C
148szdv,jo2zwac,"I've thought about doing that, but I'd really like to avoid writing a whole C macro processor if I can possibly avoid it...",0.13333333333333333,C
148szdv,jo2zwac,I'd ideally like to take the cleanest fairly robust route towards turning a C header into a bunch of symbol definitions to import.,0.8,C
148szdv,jo37oxd,"Oh wait, I think I misunderstood —do you mean, process all C stdlib headers whilst my language compiler is being compiled?",-0.3125,C
148szdv,jo2zos6,The tool is based on a C compiler I created a few years ago.,-0.2,C
148szdv,jo2zos6,"I assume you're on Linux, but if you want to try it out, as an example of how it might work, try downloading this single-file C rendering of my compiler, which is for Linux:  [https://github.com/sal55/langs/blob/master/temp/cc.c](https://github.com/sal55/langs/blob/master/temp/cc.c)  This should be built using `gcc cc.c -occ -lm -ldl -fno-builtin`.",-0.75,C
148szdv,jo2zos6,"And C source may use names that are keywords in my syntax, although some are taken care of.",0.0,C
148szdv,jo2zos6,"In general however it will have trouble compiling arbitrary C code, even just the headers.",-0.08333333333333333,C
148szdv,jo2zos6,"Sometimes, a single DLL exists that corresponds to the C module name, in which case I can remove the `$`.",-0.07142857142857142,C
148szdv,jo2zos6,"In general, it will consist of C expression syntax, that needs to be translated by hand.",0.05000000000000002,C
148szdv,jo2zos6,ETA: [this](https://github.com/sal55/langs/blob/master/temp/cc_export.m) is the exports module of my C compiler that handles the `-mheaders` option.,-0.75,C
148szdv,jpfyoed,So why import the raw standard C library?,-0.11538461538461539,C
148szdv,jpfyoed,"C arrays and strings don't know their length, something most modern languages have built in.",0.35,C
148szdv,jpfyoed,"So it may be worth taking a step back, and instead of importing the C standard library, creating your own library that is implemented using standard C calls so it's portable.",0.18,C
148szdv,jpfyoed,Especially C's string manipulation is rudimentary.,0.0,C
148szdv,jpfyoed,So why even bother with C calls that don't support that?,0.0,C
148szdv,jo31t1x,"An initial workaround I can think of, at least for the stdlib, is to special-case them with some additional C code to extract them.",-0.15,C
148szdv,jo31t1x,"Apparently, you can ask GCC to dump macro names ~~(but not values)~~ with different options:    https://stackoverflow.com/questions/24388575/print-all-defined-macros   _Correction: I get both names **and** values when I use it!_   In any case, it seems to me the ideal would be to have a way to extract object-like macro definitions from C headers, but have the macro processing done separately...",0.3166666666666667,C
148szdv,jo33vha,"Those intrinsics, for example:      #define _mm256_mask_cvt_roundps_ph(A,B,C,D) _mm256_mask_cvtps_ph ((A), (B), (C), (D))  may be necessary for the *implementation* of SDL, where it will pull in the same system headers (or might not be needed at all, and they are just there), but they are certainly not needed to just use the SDL library via its API, so they don't need to be part of your bindings for the library.",-0.03571428571428571,C
148szdv,jo33vha,"Those intrinsics, for example:      #define _mm256_mask_cvt_roundps_ph(A,B,C,D) _mm256_mask_cvtps_ph ((A), (B), (C), (D))  may be necessary for the *implementation* of SDL, where it will pull in the same system headers (or might not be needed at all, and they are just there), but they are certainly not needed to just use the SDL library via its API, so they don't need to be part of your bindings for the library.",-0.03571428571428571,D
148szdv,jo3728d,"Also, unintuitive things like remembering that C's canonical `bool` is actually named `_Bool`..!",0.0,C
148szdv,jo3hcar,"In real code, there is the possibility of a clash between struct tag names and ordinary identifiers, since few languages have copied those peculiar namespaces from C.",-0.08333333333333333,C
148szdv,jo3m09o,"In original C code outside of macros, then `123ULL` would have `u64` type, however such constants I don't think occur in declarations, except perhaps as enum values, but C limits those to `int` values (maybe some apply extensions for wider types).",0.125,C
148szdv,jo3m09o,"When it comes to C runtime functions that users of my language want to call, then I write those bindings manually.",0.0,C
148szdv,jo3m09o,"While there can be over 1000 functions in the C runtime, I only define a few dozen.",-0.1,C
148pni0,jo1grje,"IMO, Kernel captures the essence of computation much more than Scheme, even though the languages look similar on the surface.",0.25,Scheme
148pni0,jo2l4ou,"The linker merges some variables together for languages following the C model but even then things get way more interesting with dynamic linking and multi-threading thrown in (especially with the ""C"" model).",0.2,C
148pni0,jo2l4ou,"Java doesn't have ""global variables"" though it has static class level variables which suffer some of the same downsides as truly ""global"" variables.",0.125,Java
148pni0,jo2l4ou,"Java also doesn't have dynamic scope (which at least one Scheme, MIT-Scheme supports via fluid-let and dynamic-wind (apparently conceptualized by RMS)).",-0.08333333333333333,Java
148pni0,jo2l4ou,"Java also doesn't have dynamic scope (which at least one Scheme, MIT-Scheme supports via fluid-let and dynamic-wind (apparently conceptualized by RMS)).",-0.08333333333333333,Scheme
148pni0,jo2l4ou,Steve Yegge claims dependency injection (aka Guice) is related to Java not having dynamic scope and I'm inclined to hear him out a bit.,0.0,Java
148pni0,jo2l4ou,"What SICP never showed was how this might end up optimized, by a smart enough compiler, to exactly create what say a Java compiler might produce (namely a shared method table plus an array of values (aka instance variables).",0.15476190476190477,Java
148pni0,jo2l4ou,"I believe MIT-Scheme got reasonably close with ""multi-closures"" which I think only need a level of indirection plus interning to behave more like Java style dispatch.",0.2333333333333333,Java
148pni0,jo2l4ou,People weren't writing Scheme code in an OOP style so at best chicken and the egg to incentivize certain work.,0.20476190476190478,Scheme
148pni0,jo2l4ou,"Of course to compare with C++ where much dynamic dispatch is actually statically done, that might be a heavier lift.",0.0,C++
148pni0,jo2dwbj,"From a certain perspective, therefore, there are no ill-typed Scheme, Python, BASIC, etc.",0.10714285714285714,Scheme
148pni0,jo2dwbj,"From a certain perspective, therefore, there are no ill-typed Scheme, Python, BASIC, etc.",0.10714285714285714,Python
148pni0,jo5sho8,"He carefully read the entire ""Lambda: The Ultimate..."" series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system.",-0.0875,Scheme
148pni0,jo369a6,"There are examples of tools which reject badly typed or insufficiently typed dynamic languages statically, such as Erlang's dialyzer.",-0.23333333333333328,Erlang
148pni0,jo369a6,I know because I spent a long time there myself before I learned Scheme and then later Kernel (which I discovered when searching for solutions to problems I had with macros and quotation).,-0.05000000000000001,Scheme
148pni0,jo369a6,"The presence of preprocessors, never-ending extensions to Haskell and tools like TemplateHaskell demonstrate that static typing is clearly less expressive than we want it to be.",0.37777777777777777,Haskell
148pni0,jo40cfm,"And I don't dispute that the profusion of extensions to Haskell shows *something*, but I'd argue it is more about the limitations of *Haskell* than the limitations of type-checking as a convention.",0.5,Haskell
148pni0,jo40cfm,"The choice to use, say, TemplateHaskell rather than C++ means someone sees a certain benefit to making that particular compromise.",0.19047619047619047,C++
148pni0,jo3pw4k,"For example, in Dart:      extension IntExt on int {       int get increment => this + 1;     }      main() {       var n = 1;       print(n.increment); // ""2"".     }",0.16666666666666666,Dart
148pni0,jo3pw4k,You can't make a functioning C++ implementation without a type checker.,0.0,C++
148pni0,jo3pw4k,"> In the case of something more interesting like indirect method calls, the static type annotations do not direct semantics;  Sure, dynamic dispatch doesn't require static types, as Smalltalk, JavaScript, Ruby, etc.",0.35000000000000003,JavaScript
148pni0,jo3pw4k,"> In the case of something more interesting like indirect method calls, the static type annotations do not direct semantics;  Sure, dynamic dispatch doesn't require static types, as Smalltalk, JavaScript, Ruby, etc.",0.35000000000000003,Ruby
148pni0,jo3i6kw,I would consider overloading in Haskell.,0.0,Haskell
148k8qy,,"If you'd ever wanted to just brain dump language ideas that should be in C, here's the time someone would actually appreciate it.",0.0,C
148k8qy,jo18f0p,"For start, few things that I miss in og C and just can't refuse this opportunity to rant about them, even though they are pretty specific and mostly don't make sense in your C3:  * typedefs nested inside structs etc.",0.1375,C
148k8qy,jo18f0p,"* Post-assignment operators (like post-increment/decrement, but generic assignment operation) - I don't have a good idea how the syntax should look like, but it's just really inconsistent, that C has post- variants specifically for `++`, `--`, but not for anything else.",0.3,C
148k8qy,jo1ej96,Go has this and it's a huge headache when it comes to dealing with databases.,0.4000000000000001,Go
148k8qy,jo0y60j,That's my number one feature for any low-level language trying to improve upon C.,0.0,C
148k8qy,jo1a6ql,">If you'd ever wanted to just brain dump language ideas that should be in C,  In C, or in C3?",0.0,C
148k8qy,jo1a6ql,The feature list you recently posted for the latter already covers most of the things people want to have in C. (Other than C++ features without being C++; that seems a very common desire.),-0.0030000000000000027,C++
148k8qy,jo1a6ql,The enhancements you've already made to C are plenty to be going on with.,0.0,C
148k8qy,jo3vbpb,"I'd like sum types (Rust `enum`s) and pattern matching, but that seems to conflict with 'zero is initialization'.",0.0,Rust
148k8qy,jo0g9vr,For a moment I though that the CONST passive-agressive was a C like feature,0.0,C
148k8qy,jo0n4is,Memory safety through the borrow checker is Rust's main feature.,0.16666666666666666,Rust
148k8qy,jo0n4is,"But it requires things like move semantics, which is very different from C semantics.",0.0,C
148k8qy,jo0n4is,"As C3 is an evolution on C, it doesn't fit well.",0.4,C
148k8qy,jo1v08a,Rust's memory safety is via the type system.,0.0,Rust
148k8qy,jo1v08a,The OP's response mentioning Rust's borrow checker suggests that you're talking past each other.,-0.1875,Rust
148k8qy,jo1f3df,"that don't pollute global namespace  Is that particularly useful in C because of headers and no namespacing, or is there something else you want it for?",0.15,C
148k8qy,jo1gvbd,"> Go has this and it's a huge headache when it comes to dealing with databases  Ok, so I'm not sure how the problem arises there, but I would assume that fields are passed by reference as pointers, in which case you have `null` as null and everything should be fine.",0.2666666666666667,Go
148k8qy,jo13y56,Meanwhile C is commonly used as a target or intermediate language by such higher level languages as Nim or Haskell.,-0.016666666666666663,C
148k8qy,jo13y56,Meanwhile C is commonly used as a target or intermediate language by such higher level languages as Nim or Haskell.,-0.016666666666666663,Haskell
148k8qy,jo13y56,"BTW the thread isn't about C or C++, but ideas suitable for that level of language.",0.55,C
148k8qy,jo13y56,"BTW the thread isn't about C or C++, but ideas suitable for that level of language.",0.55,C++
148k8qy,jo50bbv,"When you say sum types and mention Rust, I assume you basically mean tagged unions?",-0.3125,Rust
148k8qy,jo50bbv,"That is not necessarily difficult, but I've found it somewhat hard to find good syntax for it that meshes with C syntax.",0.21944444444444441,C
148k8qy,jo50bbv,"Plus in C at least I run into the case where a single ""tag"" field affects the interpretation of multiple separate union members in a struct.",-0.12380952380952381,C
148k8qy,jo50bbv,"I extended the switch in C to take arbitrary ""case"" expressions, making it a lot like pattern matching but without the binding.",-0.1,C
148k8qy,jo3eurl,"Best solution I found so far how to solve this runtime-overhead-free in og GCC C is by defining zero-length array of the handle type inside the node type ([like here](https://github.com/MarkusSecundus/Shell/blob/main/datastructs/ultimate_list.h)) and then using `__typeof__(node->_handle_typeinfo[0])` or something like that xDD, which is just so insanely ugly.",0.1333333333333334,C
148k8qy,jo1krmo,"(C3 also has some ability to annotate for null safety)  Let's say you have three fields in a postgres database a, b, and c. All are nullable but C has a default value.",0.0,C
148k8qy,jo1krmo,"If you only insert a, and b then C will get the default value specified in the database and not null as above.",0.0,C
148k8qy,jo1krmo,"It works great in Erlang, PgPsql, crystal etc.",0.8,Erlang
148k8qy,jo1arpb,"Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,C
148k8qy,jo1arpb,"Plenty of people would dearly love C++ to die, and that's not really commentary on C.",0.2,C++
148k8qy,jo1arpb,"Plenty of people would dearly love C++ to die, and that's not really commentary on C.",0.2,C
148k8qy,jo339yr,"So we could imagine something like this:  ```c typedef struct { int; char; } mytuple;  mytuple foo = { 42, 'c' }; int x = foo.0; char y = foo.1; ```  We take the `.X` syntax from Rust and simply re-use other C syntax.",-0.0625,Rust
148k8qy,jo339yr,"So we could imagine something like this:  ```c typedef struct { int; char; } mytuple;  mytuple foo = { 42, 'c' }; int x = foo.0; char y = foo.1; ```  We take the `.X` syntax from Rust and simply re-use other C syntax.",-0.0625,C
148k8qy,jo0oolk,"Compiling LLVM and LLD by hand will always work, but not everyone has the time to spend compiling those... :D",1.0,D
148k8qy,jo2w75f,So for example you can do dynamic calling in C3 by just doing a regular call on the `any` type (so like Go's `interface{}`):      Foo f;     Bar b;     any x = &f;     any y = &g;     x.test(); // Calls `test` on Foo     y.test(); // Calls `test` on Bar  But in order to make this happen and fit for C more ceremony in terms of *defining* `test()` is needed.,0.225,Go
148k8qy,jo2w75f,So for example you can do dynamic calling in C3 by just doing a regular call on the `any` type (so like Go's `interface{}`):      Foo f;     Bar b;     any x = &f;     any y = &g;     x.test(); // Calls `test` on Foo     y.test(); // Calls `test` on Bar  But in order to make this happen and fit for C more ceremony in terms of *defining* `test()` is needed.,0.225,C
148k8qy,jo2w75f,"It works great in Erlang, PgPsql, crystal etc.",0.8,Erlang
148k8qy,jo1v7l9,">Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,C
148k8qy,jo1v7l9,"(Now they target C, LLVM, WebAssembly, Javascript, JVM, and other such ubiquitous layers.)",-0.0625,C
148k8qy,jo1v7l9,>that's not really commentary on C  Which is why discussing it here is off-topic.,-0.1,C
148k8qy,jo2wcdm,"Don't forget p-code, which first showed up in the late 60s, then going mainstream with the Pascal compilers in the 70s.",-0.024999999999999994,Pascal
148k8qy,jo1x0m1,Why C ?,0.0,C
148k8qy,jo1x0m1,"Forth was easily ported, for instance...",0.43333333333333335,Forth
148k8qy,jo2xzr0,"Languages with C backends, like Nim and Zig, are portable because C is, again, *ubiquitous*.",0.0,C
148k8qy,jo2xzr0,There are portable Forth systems ... they are portable because *they are written in C*.,0.0,Forth
148k8qy,jo2xzr0,There are portable Forth systems ... they are portable because *they are written in C*.,0.0,C
148k8qy,jo2xzr0,"And Forth is an interpreted language ... there are no good reasons to write a Forth backend for a compiler and several good reasons to write a C backend, including efficient interop with the existing extensive C ecosphere.",0.0875,Forth
148k8qy,jo2xzr0,"And Forth is an interpreted language ... there are no good reasons to write a Forth backend for a compiler and several good reasons to write a C backend, including efficient interop with the existing extensive C ecosphere.",0.0875,C
148k8qy,jo2xzr0,"As u/till-one already pointed out, whining about C and C++ is off topic.",0.0,C
148k8qy,jo2xzr0,"As u/till-one already pointed out, whining about C and C++ is off topic.",0.0,C++
148k8qy,jo2xzr0,And Forth is even more off topic.,0.5,Forth
148k8qy,jo2xzr0,"I already answered your question of why C is a good backend target, and I'm not even sure you're not pulling my leg by bringing up Forth.",0.6,C
148k8qy,jo2xzr0,"I already answered your question of why C is a good backend target, and I'm not even sure you're not pulling my leg by bringing up Forth.",0.6,Forth
148k8qy,jo31fo6,It's clear that C is just riding a historical headwind.,0.05000000000000001,C
148k8qy,jo31fo6,"I'm saying, why C as opposed to other languages that did exist at that level?",-0.125,C
148k8qy,jo31fo6,The history of C and its near competitors is hardly off-topic.,-0.09583333333333334,C
148k8qy,jo31fo6,"Forth did not, historically, achieve portability by being written in C.  It achieved it by being mostly written in *Forth*, with not that much machine-specific code necessary.",0.175,Forth
148k8qy,jokla92,"As you say, C is omnipresent.",0.0,C
148k8qy,jokla92,And I actually like C quite a lot.,0.0,C
148k8qy,jokla92,"But C is already perfectly good at being C-like (being the most C-like language there is - the real thing, by definition.)",0.4666666666666666,C
148jook,,A good example is a Bash program that compiles a Bash string to an executable.,0.7,Bash
147rwl1,jocsebm,I chose Java because it is a awesome object oriented language and I wanted something different from C++.,0.5,Java
147rwl1,jocsebm,I chose Java because it is a awesome object oriented language and I wanted something different from C++.,0.5,C++
147k92s,,"Hello everyone, i started this project one week ago, it's a query language with a syntax very similar to SQL written in Rust Programming language to perform CURD operations on .git files, for now, it only supports selecting but will implement more operations.",0.16666666666666666,Rust
147k92s,jnxc7by,Given that your project is also written in Rust you could just include the prql-compiler crate and have that generate SQL/GQL which you then process as before.,0.0,Rust
147k92s,jnvxih4,"Currently, I am working on improving code structures then I will add the option to be used as a library because already i need to use it inside another project :D",0.5,D
147k92s,jnyzrx4,"As an objective benchmark (which I just thought of), the difference between Google search results for ""I hate Java"" and ""I hate SQL"" (as phrases in quotes) is two orders of magnitude in favor of SQL.",-0.5333333333333333,Java
147k92s,jnyzrx4,"The difference between ""I love Java"" and ""I love SQL"" is one order of magnitude in favor of SQL.",0.5,Java
147k92s,jnyxjax,"I am very interested in Compiler and Programming languages, so when trying to practice as much as I can for example I created a port for Turtle graphics [https://github.com/AmrDeveloper/Turtle](https://github.com/AmrDeveloper/Turtle), last two weeks I was reading a book called Building git, it is about building git from scratch and start learning rust then got the idea of merging the idea and create a language to run on .git files and on the started i think of implementing it as some language like Lua but i found that SQL like will be easier for this case",0.17500000000000002,Lua
147k92s,jnvy6no,"Great to hear :) I have use for something like this in a python project, do you think it would be possible to wrap the rust library in C to facilitate import to python?",0.43333333333333335,C
147k92s,jnvzmoj,"I don't know if it possible, this is my first Rust project :D, we can search about it",0.4166666666666667,Rust
147k92s,jnvzmoj,"I don't know if it possible, this is my first Rust project :D, we can search about it",0.4166666666666667,D
147k92s,jnw509e,"There is PyO3 project, created specifically to facilitate developing python modules in Rust.",0.0,Rust
14783jp,,For the problem I'm trying to solve the union and intersection types correspond roughly to TypeScript's.,-0.1,TypeScript
14783jp,jnvitvb,"It is being used to try to add static types to Elixir for example, see [this blog post](https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/).",0.5,Elixir
14783jp,jo2k866,Hot news: [Elixir's “Set Theoretical Type System” prototype/demo/showcase](https://news.ycombinator.com/item?id=36299214).,-0.16666666666666666,Elixir
147657x,jnusw0r,I'm using C for my language so I can't use any fancy OOP.,0.0,C
147657x,jnvufrv,"Given how messy type solvers can get with generics and type inference, it also helps that I don't have to be writing that logic in C (my interpreter is in C89)  I'm kind of curious what other people's approaches are as well  If I had all the time and money in the world though, I would be building an interpreter that can make optimizations based on static types.",0.13499999999999998,C
147657x,jnzqi1v,"I have runtime types, so instructions like 'add', 'sub' perform action on runtime types.I want move out types from VM, but the main problem is order-independent declaration.I don't want to implement forward declaration like in C or C++.",0.13333333333333333,C
147657x,jnzqi1v,"I have runtime types, so instructions like 'add', 'sub' perform action on runtime types.I want move out types from VM, but the main problem is order-independent declaration.I don't want to implement forward declaration like in C or C++.",0.13333333333333333,C++
1475h9o,jntz751,They might generate source code for another language (eg C); or generate some intermediate language like LLVM; or generate assembly *source code* like ASM.,0.0,C
1475h9o,jntyywr,Figure out its grammar (see the back of the classic ANSI C book for C's grammar) and the semantics for that grammar.,0.08333333333333333,C
1475h9o,jntvw7d,"Will you make it like an existing language, like Basic, C, or Lisp?",0.0,C
1475h9o,jntvw7d,"Will you make it like an existing language, like Basic, C, or Lisp?",0.0,Lisp
1475h9o,jntvw7d,Making a Basic interpreter in Python: https://youtube.com/playlist?list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD  Making a Lisp interpreter: https://youtube.com/playlist?list=PLWUx_XkUoGTrXOU0pFa_OVGA-6voiIEAt,0.0,Python
1475h9o,jntvw7d,Making a Basic interpreter in Python: https://youtube.com/playlist?list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD  Making a Lisp interpreter: https://youtube.com/playlist?list=PLWUx_XkUoGTrXOU0pFa_OVGA-6voiIEAt,0.0,Lisp
1475h9o,jnvhwu9,"* Compile your language to another one, preferably to C, and compile the generated C source for the final product.",0.0,C
1475h9o,jnvhwu9,"Writing a transpiler can be pretty easy, especially, if your language is similar to C (even Python is a C-like language, with a slightly different syntax).",0.13666666666666666,C
1475h9o,jnvhwu9,"Writing a transpiler can be pretty easy, especially, if your language is similar to C (even Python is a C-like language, with a slightly different syntax).",0.13666666666666666,Python
1475h9o,jnzq8we,Another common recommendation:  * Thorsten Ball's [Writing A Compiler In Go](https://compilerbook.com/),-0.3,Go
14759gv,,It sits on top of another language (Java) and is interpreted.,0.5,Java
146xui4,,"So I was learning a bit of Haskell recently, and thought wouldn't it be nice if we could write foldl and foldl' as one polymorphic function?",0.3,Haskell
146qyyc,,"Hello, I'm writing a C compiler for fun, and I would like my compiler to go from source code to SSA IR in one pass.",0.3,C
146qyyc,jnrtqtn,"In C, preprocessing is done first as a strictly textual replacement and then the lexer is run in the next step.",0.125,C
146qyyc,jnsdpgv,"A ""traditional"" C compiler operates on streams.",0.0,C
146qyyc,jnrvaxt,I've done a C preprocessor in a single pass.,-0.07142857142857142,C
146qyyc,jnrvaxt,"This way, you will be able to offload the work to a separate C compiler to get started (use it with `-E` to get preprocessed input for your compiler), and get back to your own CPP later.",0.275,C
146qyyc,jnrvaxt,You say you're doing this for fun; I can tell you from experience that writing a C preprocessor is not fun!,0.056249999999999994,C
146qyyc,jnsnqi4,"Macros in C never operate on ""old ones""; they only operate on subsequently processed text.",0.03333333333333333,C
146qyyc,jnsnqi4,"I'm not aware of any examples in C in which a single pass that includes macro expansion would not work, but if you are, then please share the problems that you're aware of, using examples.",0.01785714285714286,C
146qyyc,jnterwr,"C translation is specified to be an ... 8-phase process, at least in whatever old draft of C23 I have laying around.",-0.09999999999999999,C
146qyyc,jo0p5rf,"In the example you gave in this comment (which I know you said was invalid C but it needs to be lexed to figure that out in the first place, right?",0.26785714285714285,C
146qyyc,jnsrlhp,"Yup, preprocessor isn't valid C, instead it is a second language meant to define ways to rewrite and modify text files.",0.0,C
146qyyc,jnsa5w5,"Yeah, I imagine you could still just do any replacements between reading the text and outputting the AST, either before or after the lexer tokenises depending on whether you want to preprocess the raw text (as the C preprocessor does) or tokens (no idea if it would be useful to process tokens prior to generating the AST nodes vs processing the AST nodes like in a macro system)",0.023076923076923068,C
146qyyc,jnsdc0d,"The C pre-processor transforms an intermediate tokenized stream of so called ""pre-processor"" tokens into a different stream of the same.",0.0,C
146qyyc,jnsrbn1,I thought code like this could be a problem  &#x200B;  \#define PLUS +   int main() {     int i = 0;     return i+PLUS;        }  &#x200B;  But apparently that's not valid C code.,0.10833333333333334,C
146qyyc,jnt7nbc,"I don't think the second scenario is possible, the preprocessor wouldn't produce binary (in C or C++ at least, I don't know of any other langs that use preprocessing) it's just text replacement",-0.10625,C
146qyyc,jnt7nbc,"I don't think the second scenario is possible, the preprocessor wouldn't produce binary (in C or C++ at least, I don't know of any other langs that use preprocessing) it's just text replacement",-0.10625,C++
146noct,,"Oh, and it's a hacked Haskell, so the sequencing primitive turns into do-notation, and the *don't-memoize* operator turns into the IO monad.",0.0,Haskell
146noct,,"Arguably, do-notation is just the ALGOL semicolon in disguise.",0.0,ALGOL
146noct,,"The only resolution to this paradox -- at least in the Haskell worldview -- seems to be that `IO` is highly magical, so that functions in that monad must be recalculated rather than memoized.",0.06666666666666667,Haskell
146noct,jnrlgmc,Also note that the final IO monad in that post is not equivalent to the one in Haskell and will probably not hold up under aggressive GHC-style optimizations and inlining (more on this later).,0.16666666666666666,Haskell
146noct,jnrlgmc,>do-notation is just the ALGOL semicolon in disguise  It's not.,0.0,ALGOL
146noct,jnrlgmc,"`seq` is the ALGOL semicolon in diguise (well, up to weak head normal form anyway).",-0.1125,ALGOL
146noct,jnrlgmc,"`(>>=)` on its own does not perform any sequencing (that is what `seq`, a primitive that cannot be implemented in Haskell directly, is for).",0.4000000000000001,Haskell
146noct,jnrlgmc,"Haskell's semantics never ""rewrite under a lambda"" (unlike, e.g.",0.0,Haskell
146noct,jnrlgmc,But optimizations do exist and that is why Haskell's `IO` is defined more intelligently than `() -> a`.,0.65,Haskell
146noct,jnrlgmc,"The full definition looks like this (which would still be fine if Haskell could rewrite under lambdas)      newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)  Note that `RealWorld` is a phantom argument that is only necessary to distinguish between effectful `IO` and pure `ST`, `State#` is a zero-sized type, and `(# , #)` is an unboxed tuple.",0.1961904761904762,Haskell
146noct,jnrlgmc,This is used to implement Haskell's infamous lazy IO.,-0.375,Haskell
146noct,jnwkmfd,Haskell even has an extension for this (`-XStrictData`) that makes constructor fields strict by default.,0.0,Haskell
146noct,jnwb1q8,"What about Haskell’s approach, where it’s lazy by default but you simply put a `!` before a data type field that you want to be strict (and also you can use `seq` for strictness in expressions)?",-0.125,Haskell
146noct,jnz4nco,"This is Haskell's ""lol no generics"" and GHC fixed it recently with [unlifted datatypes](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/primitives.html#unlifted-datatypes) in a very late response to the [famous blog post by Bob Harper](https://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/).",0.202,Haskell
146noct,jo1q05p,"I had to read the comment a couple times, but I think it is an analogy to how people talk about the lack of generics in Go?",0.0,Go
146noct,jo367sv,"In analogy to Go's ""lol no generics"" (which has been a joke for years and finally fixed), there is the ""lol no values"" joke about Haskell (which has been finally fixed).",0.45000000000000007,Go
146noct,jo367sv,"In analogy to Go's ""lol no generics"" (which has been a joke for years and finally fixed), there is the ""lol no values"" joke about Haskell (which has been finally fixed).",0.45000000000000007,Haskell
146noct,jo2z5bs,So it’s not that Haskell would supposedly not have generics.,0.0,Haskell
146noct,jo2z5bs,It’s like the situation with Go.,0.0,Go
146au5t,jnpeau5,C .,0.0,C
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,PHP
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,Haskell
146au5t,jnvqb7t,I'm implementing a subset of C++ with WebAssembly and custom VM targets.,0.0,C++
1464vgx,jnvqz2m,"However, I've seen that one of the C++ classes used internally by JIT has a tempdir member and I'm sure `FILE*`s are stored somewhere too, so I think the way I really want to be approaching it is to acquire them.",0.175,C++
1460agz,jno3eyj,And with the compiler written in Haskell no less!,0.10416666666666666,Haskell
1460agz,jnolpqn,How was writing the compiler in Haskell though?,0.0,Haskell
1460agz,jnz3qm9,"Well, if you like Haskell you could look into the [CPU example in Clash](https://yager.io/CPU/CPU1.html)",0.0,Haskell
1460agz,jnouyjx,"I am in the UK, but not the North so that was someone else :D",1.0,D
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,C
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,TypeScript
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,Rust
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,Go
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,C++
145llww,jnncqhz,C# uses (as far as I'm aware anyway) a relatively standard bidirectional inference algorithm.,0.11666666666666665,C
145llww,jnncqhz,"But at this point, there is no way for C# to know which type would be appropriate!",0.625,C
145llww,jnncqhz,"`IEnumerable<out T>`, C# doesn't do this, even though it could).",0.0,C
145llww,jnncqhz,"Similarly, TypeScript infers `never []`, which is sound, because it means that the array is effectively immutable (there is no way to construct values of type never), so *all* elements of the list vacuously have any type you want (there are none).",0.3333333333333333,TypeScript
145llww,jnncqhz,"Rust on the other hand is (roughly) Hindley-Milner based, so it doesn't have to work out every type immediately.",-0.1125,Rust
145llww,jnncqhz,"In Rust, `Vec::new()` will return `Vec<_a>`, where `_a` is a *unification variable*.",0.0,Rust
145llww,jnncqhz,"In other words, instead of committing to a type immediately, Rust infers a placeholder for it.",-0.125,Rust
145llww,jnncqhz,"Later, instead of checking for type equality directly, Rust will perform unification and work out the values of these unification variables.",0.05,Rust
145llww,jnncqhz,"Rust's syntax for function types is not great, so I am going to use something a bit more Haskelly here.",0.04999999999999999,Rust
145llww,jnncqhz,"Now, Rust knows that `_a = &str` and so it knows that the *real* type of `list` should be `Vec<&str>`.",0.2,Rust
145llww,jnncqhz,"In Rust's type system (without unions), what you described is exactly what is going to happen.",0.25,Rust
145llww,jnncqhz,"It is a bit long, but very detailed and it features a full implementation in Haskell",0.2733333333333334,Haskell
145llww,jnol753,TypeScript is actually an... [interesting example](https://www.typescriptlang.org/play?#code/PQKhCgAIUgVBPADgU0gSwHYDNkCdkYDGqA7mgC4AWkARgK5oA25mkAFAIK64CG8AlFBhDIASWx4AzpAAGPDPADaAXRm065SJOTIAttPIB7Wqh5aUhND0aRCh3YiZ5bPbZCOQ6GNFnjpNjDzkeELA4OCMyAFokpoAvJAq4MDAkJAAegD8ETHkAHSIdJKUbABEwbGlgikZ2Yy5yalZ4QAmyISB+JAAbjy4WvbIAMKGGC0UaKMAXLSGhpHy4ZHRsQBMkAlJNWnN4D7skoMjYxOj-JAA3lBpkPVrBUUl5ciV1am14AC+kMiMblc3W65VYPYpsACMqwAzG8dtlPktgY0PskwCIECh0BJ8ERSBRqEU8ABaNpYTDIFqQFpBMzkJDIEToyioSQ8XSoADWmEphiwnm8ZMIQUmGCphheGAA5JpDIRCHRcAAaOD0gDKhFwaEQ5BEACsippMDhcAZme5DIh3PS8qFwnTMbB8MgADywAB8G2uaQAPpdIFyxjNJQssJLIAjAb6Lv7uUGMIY2pLldTyDwZrBlYRKEwWjj007XW6VOHwlgvIQWKNILoeBzkAAZZA8LCFtj8fM6QuXL2QfDkBWi6MBlozUoh0olhHgMtESuimt1gByCZd7rYKbTcEz2cYuYIHdXReUG0SynbcAL7u7gL7A79w7jK6TVJp25zOMnSyitybfISC4bX822RD5ll7OZ4mrWtkGXNoIWhZVFBDM8QKyIA) because it depends on compiler settings.,0.25,TypeScript
145llww,jnol753,The TypeScript [checker.ts code](https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts) is a single 50k LOC file so I'm probably not going to be able to understand the implementation.,0.2142857142857143,TypeScript
145llww,joy4x67,C# doesn't add covariance to `List` because it is backed by a mutable array.,0.0,C
145llww,joy4x67,The mistake was made with arrays and inherited from Java:      Tiger[] tigers = new Tiger[] { new().... };     Animal[] animals = tigers;     animals.Add(new Giraffe());  Crashes because `Giraffe` may use more memory than the `Tiger` array slot provides or someone might inspect the `Tiger` array after the giraffe was added.,0.25757575757575757,Java
145llww,jnlzppe,RE: #3 - One example is [TypeScript unifies](https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEA3W8DOB7AtiAwugdsAJYAuRBAXPAEbroQhT4BQzDJ8ERqHAvPAG0AuqyIAzeAAoM2PIVLl8ASngBvZvE2duJAHQAHAK6oAFpIBEJED3NLmAX3ggIqBOq3aeB42YCMAJgBmO3tWLh5mAHpI+AA9AH5WaPgAQQAfACF4bngoNENqEgBPfQR0CXSMtJxmYtL4ABVrPikeGCJ8AHN4NPh8Q0xqEBgVEAAPK0JUVpJ2rp6+gaGYBdp6RmV4ePhZwwQqMSgXECiYrQTmIA) that situation as `List<A|B>`.,0.0,TypeScript
145llww,jnortte,"My compiler is also written in Rust and has basically the same idea of a ""database"" (a struct of arenas) that gets updated as we churn through the HIR.",0.0,Rust
145llww,jno18ya,"For `Any`, are you referring to the [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any) kind of any which turns off the type checker completely, or are you referring to the [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) kind of any that is the top type?",0.44999999999999996,TypeScript
145llww,jno18ya,"For `Any`, are you referring to the [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any) kind of any which turns off the type checker completely, or are you referring to the [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) kind of any that is the top type?",0.44999999999999996,Kotlin
145llww,jnoh7f5,Go).,0.0,Go
145llww,jno2edb,"I refer to `Any` in the TypeScript sense, which seems common among numerous tools.",-0.15,TypeScript
145llww,jno2edb,Kotlin's choice of terminology there is confusing - is it what is often called `BaseObject` (since often there are primitive types that don't extend `Object`)?,-0.3,Kotlin
145llww,jnoj6on,Go).,0.0,Go
145llww,jnoj6on,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,Pascal
145llww,jnoj6on,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,ALGOL
145llww,jno5umm,"If I understand correctly, from a type system perspective Kotlin has no primitive types, so `Any` is the top type, the superclass of every class.",0.5,Kotlin
145llww,jno5umm,"So yeah, in other languages that might be called `Object`, and like Java `Object` it has methods `equals`, `hashCode`, `toString`.",-0.125,Java
145llww,jno5umm,Unlike Java `Object` it really is the top type because there are no primitives.,0.35,Java
145llww,jno5umm,"I believe Kotlin compiles the `Int` ""class"" into JVM primitive integers when possible, but that's an implementation detail of the JVM code generation not the type system (Kotlin has other compilation targets like JS or experimental WASM compilation).",-0.008333333333333331,Kotlin
145llww,jnollaj,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,Pascal
145llww,jnollaj,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,ALGOL
145kps7,jnlvtnf,[Here's an implementation in Common Lisp](https://github.com/stylewarning/computable-reals).,-0.3,Lisp
145hkld,,On Elm's homepage there's a reference to a John Carmack tweet praising the Elm compiler: [https://twitter.com/ID\_AA\_Carmack/status/735197548034412546?s=20](https://twitter.com/ID_AA_Carmack/status/735197548034412546?s=20)   I've been using Better Exceptions with the python interpreter and I hate developing without it.,-0.35000000000000003,Elm
145hkld,jnmszq0,Try Steel Bank Common Lisp.,-0.3,Lisp
145hkld,jnlg34z,"The Rust language compiler is known for generally having good error messages, and being much more clear in what the issue is compared to other languages.",0.24500000000000002,Rust
145hkld,jnmzh04,"C++ aside, what languages do you think have compilers with incomprehensible error messages?",0.0,C++
145hkld,jnqafzn,"Elm's error messages are famously detailed, but I sure did hit a lot of them while banging my head against its standard JSON library.",0.3,Elm
145hkld,jnqafzn,"In contrast, Python's a bit more terse, and I agree that static types are nice, but json.loads(...) is practically a godsend in comparison.",0.5333333333333333,Python
145hkld,jnnk0x7,"Gotchaaa, the short loop of development sounds like what I’ve heard from Clojure devs.",0.0,Clojure
145hkld,jnlgox8,A great compiler might be the push that gets me to finally try Rust.,0.4,Rust
145hkld,jnn37gu,"Not exactly compiled, but Groovy.",-0.125,Groovy
145hkld,jnnp8tc,"Sure, Clojure was created by a guy who was proficient in Common Lisp and tailored it specifically to his needs.",0.1,Clojure
145hkld,jnnp8tc,"Sure, Clojure was created by a guy who was proficient in Common Lisp and tailored it specifically to his needs.",0.1,Lisp
145hkld,jnnp8tc,"It's more opinionated a language as well and it's easier to write ""line-of-business"" applications in it which can leverage existing Java ecosystem (which is important for many enterprises).",0.4666666666666666,Java
145hkld,jnnp8tc,He also decided not to incorporate many Common Lisp features (some because they don't really play well with Java and some because he decided they were detrimental to the style of programming he promotes) and added some extra (which are either external libraries in CL or don't exist at all).,0.08,Lisp
145hkld,jnnp8tc,He also decided not to incorporate many Common Lisp features (some because they don't really play well with Java and some because he decided they were detrimental to the style of programming he promotes) and added some extra (which are either external libraries in CL or don't exist at all).,0.08,Java
145hkld,jnnp8tc,Problem with Clojure is that you often see Java stack traces and Java exceptions.,0.0,Clojure
145hkld,jnnp8tc,Problem with Clojure is that you often see Java stack traces and Java exceptions.,0.0,Java
145hkld,jnnp8tc,"Not a problem for me, I have written more Java than any other language (yes, I was paid to do so, that was the reason :-D ).",0.4583333333333333,Java
145hkld,jnnp8tc,"If you really decide to dig into Common Lisp (it's not everybody's cup of tea), check this linter as well: [https://github.com/g000001/lisp-critic](https://github.com/g000001/lisp-critic) , or this wrapper over Lisp Critic which can work very well in your CI/CD pipelines if you use them: [https://github.com/40ants/40ants-critic](https://github.com/40ants/40ants-critic) .",-0.27999999999999997,Lisp
145hkld,jnls7z8,"Wouldn’t say Rust is exclusively for “low-level programming”, depending on which definition you are using.",0.0,Rust
145hkld,jnls7z8,Rust has a lot of modern language features,0.2,Rust
145hkld,jnm5k5i,It's worth noting that the Rust compiler team [draws a lot of inspiration from Elm](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html)   > Those of you familiar with the Elm style may recognize that the updated --explain messages draw heavy inspiration from the Elm approach.,0.15833333333333335,Rust
145hkld,jnm5k5i,It's worth noting that the Rust compiler team [draws a lot of inspiration from Elm](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html)   > Those of you familiar with the Elm style may recognize that the updated --explain messages draw heavy inspiration from the Elm approach.,0.15833333333333335,Elm
145hkld,jnumeat,"Elm evidently treats `type` definitions as like a nominal reference-type, but `type alias`es as structural composite things without any implied referencing.",0.25,Elm
145hkld,jnnx60b,"Mmmmm okay, I found: ""He also decided not to incorporate many Common Lisp features \[...\] some because he decided they were detrimental to the style of programming he promotes"" especially interesting because programming style is so personal.",0.33999999999999997,Lisp
145hkld,jnllsu2,"(Right now, I think this about Ruby and TailwindCSS).",0.2857142857142857,Ruby
145hkld,jnqdfj2,"Ironically, Clojure has pretty bad error messages.",-0.22499999999999992,Clojure
145hkld,jnlw3tg,I just thought you should give Rust a try even if you’re not writing performance and memory safety sensitive programs.,0.1,Rust
145dugl,jnl2pjl,"Some ecosystems like Cloud Haskell did it for static closures (known ahead of time, like functions within the same code base which get explicitly marked as such), which is easier but it won't work for arbitrary database servers.",-0.05000000000000001,Haskell
145dugl,jnn7zhy,See [javactrl](https://github.com/javactrl/javactrl) for a Java implementation of continuations that is serializable,0.0,Java
145dugl,jnnhfy4,Adam Dunkels' [Protothreads](http://dunkels.com/adam/pt/) library is an implementation of stackless coroutines based on C macros that resolve to state machines.,0.0,C
145d24u,jnmj4pz,"It can generate C, Go and my language.",0.0,C
145d24u,jnmj4pz,"It can generate C, Go and my language.",0.0,Go
145d24u,jnmj4pz,"Go was about 85K (array writes) on my PC, clang was 95K (array writes, clang compiles 230K lines of sqlite in <2s) and mine... well... let's just say I doubt anyone is getting my speeds anytime soon.",0.0,Go
145d24u,jnnw186,"One of Go's selling point was that it was fast to compile, so I'd expect them to have benchmarks, but maybe they are internal to Google.",0.1,Go
145d24u,jnnwdfl,"About Go being advertised as fast to compile, then yes I fully agree with you, they should have provided benchmarks to back their claims.",0.1,Go
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,C
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,D
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Lua
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Python
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Ruby
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Perl
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Rust
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Pascal
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Go
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Lisp
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Julia
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Dart
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,Java
145c4ih,jnmrm95,"Alternatively, take a look at the Array languages like APL, J, or BQN.",0.0,APL
145c4ih,jnwumrk,"Code generation is the key, just use something like Rust or Go, create a rule engine with a tiny local DB and apply rules around annotations etc on compilation time.",0.0,Rust
145c4ih,jnwumrk,"Code generation is the key, just use something like Rust or Go, create a rule engine with a tiny local DB and apply rules around annotations etc on compilation time.",0.0,Go
145c4ih,jnkaf6n,I believe Eiffel works that way,0.0,Eiffel
145c4ih,jnmb8n9,Clojure can [add watchers](https://clojuredocs.org/clojure.core/add-watch) to its mutable containers.,0.0,Clojure
145c4ih,jnmb8n9,Tcl can [add traces](https://www.tcl.tk/man/tcl8.4/TclCmd/trace.html#M14) to variables in a similar way.,0.0,Tcl
145c4ih,jnmwfws,This is like a require statement in Eiffel.,0.0,Eiffel
145c4ih,jnmxvcq,"Only because I haven’t seen anyone mention it, the https://dynamicland.org project uses a Lua dialect extended with `When` statements that function similar to what you’re describing.",0.0,Lua
145c4ih,jnn3f9j,Prolog programs are essentially a series of rules.,0.0,Prolog
145c4ih,jnnsegx,"C# has attributes, which I only know the basics of - this gives a kind of metadata to a specific function or variable.",0.19999999999999998,C
145c4ih,jnncfzt,"For example if would be neat if `fun(A, B): C` could be made into a time-dependent value, by just adding an operator, like `fun!",0.375,C
145c4ih,jnncfzt,"(Signal<A>, Signal<B>): Signal<C>`.",0.0,C
145c4ih,jnncfzt,"I think Haskell does something with Monads and the ""do""-notation and Scala with ""for""-notation.",0.0,Haskell
145c4ih,jnncfzt,"I think Haskell does something with Monads and the ""do""-notation and Scala with ""for""-notation.",0.0,Scala
145c4ih,jnldgmb,Something like Common Lisp would make this approachable.,-0.3,Lisp
145c4ih,jnkfi3g,JavaScript example:  ``` function* rules() {   let a = 0;   if (a == 0) {     yield a++;   } }  function main() {   let rules = rules();   let a = rules.next().value;   console.log(rules.next().value); } ```,0.16666666666666666,JavaScript
145c4ih,jnojxnn,Look at Ada’s aspects which is nicked from Eiffel.,0.0,Ada
145c4ih,jnojxnn,Look at Ada’s aspects which is nicked from Eiffel.,0.0,Eiffel
145bk89,jnk448q,[Elm](https://elm-lang.org/) does this.,0.0,Elm
145b3eg,jnqby21,Perl has something like a pronoun in the form of `$_` and `@_` but they have precisely defined semantics.,0.4,Perl
145b3eg,jnkh6av,"I haven't come across this concept in particular before, but reading that page it is clearly about universal and existential quantifiers, and [Haskell totally lets you use them if you want](https://serokell.io/blog/universal-and-existential-quantification) - in fact, things are implicitly universally quantified by default.",0.05333333333333333,Haskell
145b3eg,jnkh6av,"We can translate of the donkey sentence to type-level Haskell, which reads something like:  ```haskell class Farmer f where class Donkey d where class Owns f d where class (Farmer f, Donkey d, Owns f d) => Beats f d where     beat :: f -> d -> () ```  The type of `beat` is actually `forall f d .",0.0,Haskell
145b3eg,jno5s4u,"(Farmer f, Donkey d, Owns f d) => BEATS(F,D)` *is the correctly encoded donkey sentence that fixes the out of scope variable*.",0.0,D
1457g52,jnk4ryj,I'm not very familiar with C# but your memory manipulation looks *very* expensive.,-0.39711538461538465,C
1457g52,jnk4ryj,I think shifts are safe in C#?,0.5,C
1457g52,jnk7a9r,>   >I'm not very familiar with C# but your memory manipulation looks very expensive.,-0.39711538461538465,C
1452482,,"From what I've heard, other languages, such as Zig and C++, include an additional interpreter for it's *comptime* evaluation.",-0.0625,C++
1452482,,"Please enlighten me :D  My language is meant to be transpiled down to C, as I didn't want to mess with LLVM docs.",0.22314814814814818,D
1452482,,"Please enlighten me :D  My language is meant to be transpiled down to C, as I didn't want to mess with LLVM docs.",0.22314814814814818,C
1452482,,"I was thinking the compiler could take that AST nodes that are necessary for comp-time evaluation and transpile only them to C.      int32_t add (int32_t a, int 32_t b) {         return a + b;     }     int main (void) {         return add(1, 2); // 3     }  Then this C code, as explained in the begging, would get compiled down to an executable and executed.",0.002777777777777768,C
1452482,,"fn sub (i32 a, i32 b) -> i32 {         return a - b;     }     fn main () -> void {         i32 x = 3;         i32 y = sub(10, 3);     }  This would then get transpiled down to C and from C down to the final executable.",-0.03611111111111113,C
1452482,jnipmud,"I do this by making every AST an expression and then make sure to rewrite the AST to statements where necessary for C code generation  The hard part is doing name resolution at right stage, I also allow compile time closures to close over bindings of runtime values and pass them around as first class objects so it gets a bit tricky.",0.1488095238095238,C
1452482,jnmd1h4,This is not dissimilar to how macros tend to work in Common Lisp implementations - the function for a macro is compiled just as any other function is.,-0.2125,Lisp
1452482,jnj0d59,"The only downside I can see in using libgccjit for this, is that currently they only support compiling to binary (file) or memory, but not both at once (you'd need to compile twice if your compile-time function is to be executed at both compile-time and run-time, as C++'s `constexpr` supports).",0.0,C++
1452482,jnke4ut,I think Rust and C++ are a bit more complicated because they have limitations on what can be done at compile time and at least for Rust there are a bunch of extra checks to confirm you aren’t doing anything that they consider undefined,-0.075,Rust
1452482,jnke4ut,I think Rust and C++ are a bit more complicated because they have limitations on what can be done at compile time and at least for Rust there are a bunch of extra checks to confirm you aren’t doing anything that they consider undefined,-0.075,C++
1452482,jnilz2v,This is pretty much what Scala 3 does I think.,0.225,Scala
1452482,jnnbp5h,Although instead of compiling an .exe i will try out C JIT compilers such as libgccjit or tccjit.,0.0,C
1452482,jnnehff,"Compiling to an executable will definitely hurt, but what about JITing C?",0.0,C
1452482,jniviyw,"And the typed ASTs are then passed to one of a few library functions that output any of C, Javascript, GLSL or webassembly  >inline AST to require a specific keyword  This is something like a lisp 'quote' function which I thought about but I think they would be unhygienic macros right?",0.028571428571428564,C
144owz5,jno0cif,You can use intersection types in [Scala 3](https://docs.scala-lang.org/scala3/book/types-intersection.html)!,0.0,Scala
144owz5,jno0cif,"I think TypeScript also has them, but I can't find the docs page.",0.0,TypeScript
144ekk3,jniisgd,"What is particularly interesting to me is that if we look at the usual syntax of GADTs (Generalized Algebraic Data Types), as found in OCaml or Haskell for example, it resembles TF a lot.",0.125,Haskell
143bzzd,,In this one we add call expressions to Wanda and make it so the reader produces linked lists like any worthy Lisp.,0.3333333333333333,Lisp
143fgv6,,"From what I understand, looking at Lisp/Scheme compilers, macros are expanded before compilation, and having them saved in variables would prevent the compiler to know what to expand to (unless the variable can be resolved at compile time, which might be why Scheme has let-syntax instead of just let for macros).",0.0,Scheme
143fgv6,,"Haskell is able to compile them, but I was reading Simon Peyton Jones books and it looks like that requires a very different compilation scheme.",0.25,Haskell
143a6qa,jnb2xoh,"Using the file system + a list of search directories (like `-I` for C and C++ includes, and `-L` for `.so`/`.dll` files) actually gives all the freedom necessary for implementing a package manager.",0.0,C
143a6qa,jnb2xoh,"Using the file system + a list of search directories (like `-I` for C and C++ includes, and `-L` for `.so`/`.dll` files) actually gives all the freedom necessary for implementing a package manager.",0.0,C++
143a6qa,jn9q6jf,"And even if I had rustc errors, I set its output format to JSON to catch them and then use source maps to track down the Letlang code that produced the faulty Rust code.",-0.15555555555555559,Rust
143a6qa,jn9r7pa,">And even if I had rustc errors, I set its output format to JSON to catch them and then use source maps to track down the Letlang code that produced the faulty Rust code.",-0.15555555555555559,Rust
143a6qa,jn9vvkk,"This happens to be true for `A = int`, but not for anything else, so if you interpret type parameters as parametric (which you should, because that is how they work in most statically typed languages except C++), it is still a contract violation.",0.425,C++
1437nai,,It gave some examples like Rust not including a Random package (since one for cryptography would be unsuitable for day to day [i.e.,-0.5,Rust
142qw6x,jn5xafa,Java did not choose type erasure because of backwards compatibility.,0.0,Java
142qw6x,jn5xafa,C# does not erase generic types.,0.0,C
142qw6x,jn5yddy,"> All realizations using reference types can share the same compiled code  That can be true for a lot of generics such as collections, though if we have a type bound on a generic parameter `T extends ISpaceship` and want to call `.launch()` on an instance of `T`, then a language like Vale or Rust would need different instantiations to call the correct function...",0.06999999999999999,Rust
142qw6x,jn5yddy,"I think Java doesn't need to, not sure about C#.",-0.25,Java
142qw6x,jn5yddy,"I think Java doesn't need to, not sure about C#.",-0.25,C
142qw6x,jn5w9cy,why Python does not need generics?,0.0,Python
142qw6x,jn6iij4,">  though if we have a type bound on a generic parameter `T extends ISpaceship` and want to call `.launch()` on an instance of `T`, then a language like Vale or Rust would need different instantiations to call the correct function...",0.0,Rust
142qw6x,jn6iij4,"I think Java doesn't need to, not sure about C#.",-0.25,Java
142qw6x,jn6iij4,"I think Java doesn't need to, not sure about C#.",-0.25,C
142qw6x,jn6iij4,Same with C#.,0.0,C
142qw6x,jn6iij4,The reason Rust (and I assume Vale) need monomorphization to call trait methods is because those trait methods are dispatched *statically*.,0.0,Rust
142qw6x,jn6iij4,Java and C# can compile a generic method once for all type arguments because any method called on an instance of the type argument is a virtual call going through the instance's v-table.,0.0,Java
142qw6x,jn6iij4,Java and C# can compile a generic method once for all type arguments because any method called on an instance of the type argument is a virtual call going through the instance's v-table.,0.0,C
142qw6x,jn6iij4,"In Rust, since trait calls are statically dispatched, the calls at runtime are faster.",0.0,Rust
142qw6x,jn66r9v,Java references are similar to dyn Trait in Rust.,0.0,Java
142qw6x,jn66r9v,Java references are similar to dyn Trait in Rust.,0.0,Rust
142pydn,,Relish  is a homegrown LISP I have written from scratch using only safe Rust  (with the exception of libc calls in POSIX job control libraries).,0.25,Rust
142pydn,,You (could possibly) wish your shell config looked this cool: [(My shell config)](https://pastebin.com/tRZPx9ff)  Relish called in CI: [(Tests for optional features written in Relish)](https://gitlab.com/whom/relish/-/blob/main/snippets/userlib-tests.rls)  Homoiconicity put to work for shell use: [(Shell command binding generator)](https://gitlab.com/whom/relish/-/blob/main/snippets/genbind.rls)  (Docs are linked to in the Readme),-0.38,Shell
142pydn,jn8e1al,Closer to Scheme or Cl ?,0.0,Scheme
142pydn,jnd8nuu,Emacs as any other Lisp has its own symbol tables too :).,0.325,Lisp
142pydn,jnd8nuu,"I am not sure what you mean that Relish keep it's symbol tables  synchronized to the environment, but as any process, Emacs as well reflects changes in its process environment, to the level that programmers who write lisp applications in Emacs Lisp care about the environment.",-0.28125,Lisp
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,Bash
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,Lisp
142pydn,jnd8nuu,The comment you have quoted is talking about combining shell commands with Lisp forms.,0.0,Lisp
142pydn,jnd8nuu,"But you can use Elisp in Eshell and as long as you are keeping yourself in the Lisp land you can combine lisp forms as normally in Lisp, which makes Eshell equal to Relish in that regard (just with a more powerful Lisp).",0.18,Lisp
142pydn,jn9xgj0,(Also not too familiar with Rust).,0.375,Rust
142pydn,jnef157,"> you can use Elisp in Eshell and as long as you are keeping yourself in the Lisp land you can combine lisp forms as normally in Lisp, which makes Eshell equal to Relish in that regard (just with a more powerful Lisp).",0.18,Lisp
142pydn,jng9v9e,"> (l ping -c COUNT (get-api-domain)) Here COUNT is either used verbatim or expanded to whatever value that variable references  Your example is trivial in Emacs Lisp and Eshell:      (defmacro l (&rest args)       (let ((cmd))         (dolist (arg (nreverse `(,@args)))           (push arg cmd))         (shell-command-to-string (format ""%S"" cmd))))  The mockup:      (defun get-api-domain ()       'api.trashcan.services)     (defvar COUNT 4)      Eshell just did it:      c:/emacs/help-remote $ (l ping -c COUNT (get-api-domain))  Perhaps better with something that does not require admin priviledge?",-0.3333333333333333,Lisp
142pydn,jng9v9e,"> (l ping www.google.com)  The answer:      c:/emacs/help-remote $ (l ping www.google.com)             Pinging www.google.com [142.250.74.36] with 32 bytes of data:         Reply from 142.250.74.36: bytes=32 time=143ms TTL=53         Reply from 142.250.74.36: bytes=32 time=20ms TTL=53         Reply from 142.250.74.36: bytes=32 time=24ms TTL=53         Reply from 142.250.74.36: bytes=32 time=14ms TTL=53          Ping statistics for 142.250.74.36:         Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),     Approximate round trip times in milli-seconds:         Minimum = 14ms, Maximum = 143ms, Average = 50ms  But that is totally missing the point, since Eshell does not have to do anything like creating that macro but can just execute shell syntax directly, and even combine it with Emacs Lisp functions:          Welcome to the Emacs shell          ~ $ ping -c COUNT (get-api-domain)     Access denied.",-0.00833333333333336,Lisp
142pydn,jng9v9e,"Or what about this:      ~ $ (message ""Hello"") > greeting.txt     ~ $ ls | grep greeting     (standard input):greeting.txt  There are limitations of course when it comes to shell syntax, but on Lisp side, Eshell can do anything Relish can and much more.",0.25,Lisp
142pydn,jng9v9e,"It is a bit similar idea to yours, but Emacs Lisp itself provides for what Relish does, in quite trivial manner, while Eshell adds shell syntax and let you mix the two seemlesly.",0.0,Lisp
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,C
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,D
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,Julia
142ixw5,jn4v85p,As is `Lua`.,0.0,Lua
142ixw5,jnbw66m,"Yeah, as much as I love D, characterizing it as faster than C seems wrong.",0.0,D
142ixw5,jnbw66m,"Yeah, as much as I love D, characterizing it as faster than C seems wrong.",0.0,C
142ixw5,jnbw66m,"D's performance is C-like for most things, but it is generally a little slower, and occasionally *much* slower.",0.1708333333333333,D
142ixw5,jnbw66m,According to https://programming-language-benchmarks.vercel.app/d-vs-c D only outperformed C on one microbenchmark (nsieve).,0.0,D
142ixw5,jnbw66m,According to https://programming-language-benchmarks.vercel.app/d-vs-c D only outperformed C on one microbenchmark (nsieve).,0.0,C
142ixw5,jnbw66m,"From my limited experience with Julia, it's the same kind of mixed bag.",0.13214285714285715,Julia
142ixw5,jnbw66m,"Julia outperforms C on matrix operations, but slightly underperforms C on pretty much everything else.",0.09444444444444444,Julia
142ixw5,jnbw66m,"Julia outperforms C on matrix operations, but slightly underperforms C on pretty much everything else.",0.09444444444444444,C
142ixw5,jnbw66m,"D has three compilers -- the reference implementation (DMD), the GCC implementation (GDC) and the LLVM implementation (LDC).",0.0,D
142ixw5,jnbw66m,"When gauging the performance of Lua, does one use luac as the standard, or luajit?",0.0,Lua
142iq4o,jne0dm6,"To paraphrase a famous quote, those who do not learn from Erlang are doomed to reimplement it.",0.5,Erlang
142cxoh,,"So I just write a simple script to test how fast you can sum all numbers up to a certain amount...      //the test case (toy)     fn test_sum(key: int, val: int) {     	fn sum(n: int) {     		if (n < 2) {     			return n;     		}          		return n + sum(n - 1);     	}          	var result: int const = sum(val);     	print string key + "": "" + string result;     }          for (var i: int = 0; i <= 10; i++) {     	test_sum(i, i * 1000);     }  And then I wrote the [exact same code in JavaScript and C](https://github.com/Ratstail91/Toy/tree/main/scripts/test_sum), and compared them.",0.11071428571428571,JavaScript
142cxoh,,"So I just write a simple script to test how fast you can sum all numbers up to a certain amount...      //the test case (toy)     fn test_sum(key: int, val: int) {     	fn sum(n: int) {     		if (n < 2) {     			return n;     		}          		return n + sum(n - 1);     	}          	var result: int const = sum(val);     	print string key + "": "" + string result;     }          for (var i: int = 0; i <= 10; i++) {     	test_sum(i, i * 1000);     }  And then I wrote the [exact same code in JavaScript and C](https://github.com/Ratstail91/Toy/tree/main/scripts/test_sum), and compared them.",0.11071428571428571,C
142cxoh,,"The result was quite good, IMO -  C : JavaScript : Toy = 1.00 : 16.25 : 109.50  For a language implementation built from the ground up in six months, I'm quite surprised that it's less than than one order slower than JS, and only roughly 2 orders slower than C.  I know this is a pretty simple way of testing speed, but I figured I'd put it up to see what others thought.",0.11190476190476191,C
142cxoh,,"The result was quite good, IMO -  C : JavaScript : Toy = 1.00 : 16.25 : 109.50  For a language implementation built from the ground up in six months, I'm quite surprised that it's less than than one order slower than JS, and only roughly 2 orders slower than C.  I know this is a pretty simple way of testing speed, but I figured I'd put it up to see what others thought.",0.11190476190476191,JavaScript
142cxoh,,&#x200B;  Edit: NEVERMIND I should learn to run tests multiple friggin' times  C	0.002s	1  JS	0.064s	32  Py3	0.070s	35  Toy	0.430s	215,0.0,C
142cxoh,jn42p4d,"With C, I got a timing of pretty much zero seconds, even unoptimised; at any rate hard to disinguish from the time taken to run an empty program.",0.01458333333333333,C
142cxoh,jn42p4d,"The benchmark also isn't the same: some use nested functions, the C at least doesn't do that.",-0.15,C
142cxoh,jn42p4d,"A better benchmark should run a bit longer (on Windows at least, measuring very fast runtimes is hard), and the C should not be affected by optimisation too much.",0.07366666666666667,C
142cxoh,jn42p4d,Measuring against upoptimised C might be fairer: you are still comparing interpreted code against native.,0.0,C
142cxoh,jn717ig,"Now I could put together a `Fibonacci` test like this:      fn fib(n:int) {         if (n<3) {             return 1;         } else {             return fib(n-1)+fib(n-2);         }     }          for (var i: int = 1; i <= 36; i++) {         var res:int =fib(i);         print string i + "" "" + string res;     }  I tested this with `toyrepl` and compared with other products I had lying around:       PicoC      81,000    seconds (extrapolated)      toyrepl       340      A68G           16    (Algol68 interpreter)      CPython 3.11    7      Q-fn            5.4      Lua 5.4         3.7      Q-asm           1.35 (Q is my dynamic language)      PyPy            0.7      LuaJIT          0.33      C               0.2  unoptimised      C               0.11 optimised  This shows a wider disparity than your test.",-0.0625,Lua
142cxoh,jn717ig,"Now I could put together a `Fibonacci` test like this:      fn fib(n:int) {         if (n<3) {             return 1;         } else {             return fib(n-1)+fib(n-2);         }     }          for (var i: int = 1; i <= 36; i++) {         var res:int =fib(i);         print string i + "" "" + string res;     }  I tested this with `toyrepl` and compared with other products I had lying around:       PicoC      81,000    seconds (extrapolated)      toyrepl       340      A68G           16    (Algol68 interpreter)      CPython 3.11    7      Q-fn            5.4      Lua 5.4         3.7      Q-asm           1.35 (Q is my dynamic language)      PyPy            0.7      LuaJIT          0.33      C               0.2  unoptimised      C               0.11 optimised  This shows a wider disparity than your test.",-0.0625,C
142cxoh,jn717ig,"Notes:  * Fibonacci can be a challenging benchmark, especially if your function calls are slow * I don't know if `toyrepl` is optimised or is the fastest way of running this program * PyPy and LuaJIT use JIT, so I wouldn't pay much attention to those timings; JIT always gives astonishing results on microbenchmarks * Pico C is a C interpreter, and not a fast one.",0.13333333333333333,C
142cxoh,jn4zsze,The C entry was just curiosity.,0.0,C
142cxoh,jn5h1j7,"You may be right in this case, but I've seen people's benchmarks ""my language is almost as fast as C!""",0.26785714285714285,C
141z4k2,jn3u2hs,FYI: Did you know LOGO is actually Lisp without all those parentheses?,0.0,Lisp
141z4k2,jn6skpf,Pascal was a teaching language.,0.0,Pascal
141z4k2,jn6skpf,Python started life as a teaching language.,0.0,Python
141sjvi,jn1lw2d,"----  Several companies in fact do profit(now or in the past) with programming languages: MS, Borland, Apple, Amazon, Ericcson, IBM, Informix, FoxPro, SAP (and a lot of ERP/app Bussines makers), kdb+, APL, RDBMS & NoSQL makers, Some game makers, etc  It would be best if you *opened your mind* about how *exactly* this fit in the idea (I think you will not see at first how Apple ""profit"" from programming languages!",0.1875,APL
141sjvi,jn200fy,"Not for Python, not for Zig, not for Apple, *NOBODY* makes money on that *particular* aspect of the game.",-0.11666666666666668,Python
141sjvi,jn200fy,There's no doubt that Apple released Swift so that developers would release iPhone-only applications.,0.0,Swift
141sjvi,jn200fy,"Python was a teaching language, but Guido can write a number on paper and someone will pay it.",0.0,Python
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Go
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Dart
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Swift
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,Rust
141sjvi,jp6z1lr,Look at Objective-C for instance.,0.0,Objective-C
141sjvi,jp6z1lr,"It achieved that by taking the language people had used so far, C, and adding a few small constructs on top that made it easy to do polymorphism, dynamism and message sending _only when you needed it_.",0.09722222222222222,C
141sjvi,jp6z1lr,So Objective-C runs any of your old C code.,0.1,Objective-C
141sjvi,jp6z1lr,So Objective-C runs any of your old C code.,0.1,C
141sjvi,jp6z1lr,"(compatibility) Also, if you need to optimize for speed, you are able to replace object-oriented code with plain C code for those important tight loops.",0.12678571428571428,C
141sjvi,jp6z1lr,"I wouldn't try being the next C# or C++ at this point, though.",0.0,C
141sjvi,jp6z1lr,"I wouldn't try being the next C# or C++ at this point, though.",0.0,C++
141qm6g,jn1vh0p,"I liked how the article talked about tail calls at the *end*  “I got argued into not having them because the project in general got argued into the position of ""compete to win with C++ on performance"" and so I wound up writing a sad post rejecting them which is one of the saddest things ever written on the subject”",0.1566666666666667,C++
141qm6g,jna20d9,I definitely think there's space in the ecosystem for a natively compiled language mid-way between Go and Rust:   - More heavily typed than Go.,0.09999999999999999,Go
141qm6g,jna20d9,I definitely think there's space in the ecosystem for a natively compiled language mid-way between Go and Rust:   - More heavily typed than Go.,0.09999999999999999,Rust
141qm6g,jna20d9,- Not quite as low-level as Rust: green threads + no-lifetimes.,-0.2,Rust
141qm6g,jna43dp,"Well, you weren't wrong, and you weren't right either :)  As Graydon mentions, his Rust wouldn't have been _better_, it would have been _different_.",0.15714285714285714,Rust
141qm6g,jna43dp,"I really like today's Rust, but part of it is because I _love_ performance/pedal-to-the-floor code, and today's Rust offers me that in a nice package.",0.35,Rust
141qm6g,jna43dp,"Don't like the syntax, can't program like it were Java or Python, etc...",0.0,Java
141qm6g,jna43dp,"Don't like the syntax, can't program like it were Java or Python, etc...",0.0,Python
141qm6g,jna43dp,"Rust clashes with that because the ownership/borrowing discipline is just plain new to many, and it takes time getting used to it.",0.14069264069264067,Rust
141qm6g,jna43dp,"Most people who stuck to hit -- who reach the ""hindsight"" part -- agree that Rust has changed the way they approach programming even in other languages, and that their programs are better for it.",0.2916666666666667,Rust
141qm6g,jn2ok7n,"Rust has TCO, not guaranteed tail callss which the article talks about  See https://github.com/phi-go/rfcs/blob/guaranteed-tco/text/0000-explicit-tail-calls.md",0.0,Rust
141qm6g,jna4yq0,"Rust is successful because of its ecosystem and tooling, not because of lifetime annotations and async/await.",0.75,Rust
141qm6g,jymlfl5,"But I think, in a lot of ways, Haskell is this language.",0.0,Haskell
141qm6g,jymlfl5,"I know, I know, it’s Haskell!",0.0,Haskell
141qm6g,jymlfl5,"But I happen to believe that much of what makes it truly so impressive is often unsung:  * Many of Rust’s features, such as traits and enums, come more or less directly from Haskell.",0.30476190476190484,Rust
141qm6g,jymlfl5,"But I happen to believe that much of what makes it truly so impressive is often unsung:  * Many of Rust’s features, such as traits and enums, come more or less directly from Haskell.",0.30476190476190484,Haskell
141qm6g,jymlfl5,"It includes Go-style channels and queues for cross-thread communication (and, incidentally, it did before Go so much as existed), plus an efficient implementation of software transactional memory largely based around optimistic, lock-free transactions.",0.20714285714285713,Go
141qm6g,jymlfl5,"* Despite its reputation, the Haskell type system is legitimately simpler than Rust’s.",0.0,Haskell
141qm6g,jymlfl5,"* Despite its reputation, the Haskell type system is legitimately simpler than Rust’s.",0.0,Rust
141qm6g,jymlfl5,The trait metaprogramming routinely used in Rust would make most Haskellers’ heads spin.,0.5,Rust
141qm6g,jymlfl5,"* `cabal`, Haskell’s equivalent to `cargo`, is not nearly as polished or friendly, and it is sadly somewhat old and crufty.",-0.018749999999999996,Haskell
141qm6g,jymlfl5,* The library ecosystem is pretty solid for most of the usual things people do with languages like Go.,0.125,Go
141qm6g,jymlfl5,Writing Haskell is not doing mathematics.,0.0,Haskell
141qm6g,jymlfl5,"Haskell is a programming language, and writing Haskell is programming.",0.0,Haskell
141qm6g,jymlfl5,"And if you’re coming from Rust, you’ll find it remarkably easy to pick up.",0.43333333333333335,Rust
141qm6g,jp6s22n,Maybe Crystal?,0.0,Crystal
141qm6g,jnmgti2,"> As Graydon mentions, his Rust wouldn't have been better, it would have been different.",0.25,Rust
141qm6g,jnmgti2,"> I really like today's Rust, but part of it is because I love performance/pedal-to-the-floor code, and today's Rust offers me that in a nice package.",0.35,Rust
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,C
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,C++
141qm6g,jneuhmo,Rust is tuned to be good at mutable aliasing.,0.7,Rust
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,C
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,C++
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Go
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Java
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,JavaScript
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Python
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,Ruby
141qm6g,jneuhmo,"Rust is somewhat unique in that it deals with the mutable aliasing problem head-on, and actually ""solves"" it... at an ergonomic cost.",0.1875,Rust
141qm6g,jp8wsog,"Not for me ;)  I favor type-classes over inheritance and Result over exceptions, so... no, not Crystal.",0.25,Crystal
141qm6g,jnn6m4u,"I remember playing with Forth and Haskell, and boy was my whole world turned upside down.",0.022222222222222213,Forth
141qm6g,jnn6m4u,"I remember playing with Forth and Haskell, and boy was my whole world turned upside down.",0.022222222222222213,Haskell
141qm6g,jnn6m4u,"I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,Rust
141qm6g,jnn6m4u,"I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,C++
141qm6g,jnn6m4u,"I still remember the joy when Mutable XOR Aliasing kicked in, and how it helped me better structure (and debug) my C++ code afterwards.",0.65,C++
141qm6g,jnn6m4u,"Before Rust, I would sometimes have a ""gut feeling"" that a piece of code may be trouble, and I would try to think of various execution paths to see if any would be problematic... and when I couldn't find any, I'd leave with a dread feeling in my guts, not quite convinced it was alright, and quite afraid it would still blow-up in my face one day.",-0.26666666666666666,Rust
141qm6g,jnn6m4u,"All of this doesn't mean you should absolutely learn Rust, that you're not a good programmer if you don't, or anything like that.",-0.15416666666666665,Rust
141qm6g,jnn6m4u,"It just means that learning Rust may require more effort than learning another language more similar to what you're used to, and that you won't get any benefit if you don't stick long enough for the concepts to click.",0.19,Rust
141qm6g,jn38ofk,"I think the point is that in C++ you can't just write a function that would blow the stack without TCO, as the compiler is free to just not do it (and probably won't in a debug build, even if it would in release).",0.4,C++
141qm6g,jn38ofk,"So it can only be treated as a possible optimization that might make some programs faster, but not as free rein to write C++ as if it was a functional language.",0.13333333333333333,C++
141qm6g,jno6e5v,"Go ahead, tell me what I did wrong.",-0.5,Go
141qm6g,jno6e5v,Go ahead and tell me why my code is wrong.,-0.5,Go
141qm6g,jno6e5v,"> I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,Rust
141qm6g,jno6e5v,"> I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,C++
141qm6g,jno6e5v,"Before thinking I might have no idea what I'm talking about feel free to try out my compiler and reproduce my build speed https://bolinlang.com/ There's likely no way a person can get that kind of performance without knowing what their doing  > All of this doesn't mean  So many words and it doesn't seem like you ever thought maybe a person has no issues with manual memory management, C++ code and has valid reasons not to like rust  In the article graydon says ""Performance: A lot of people in the Rust community think ""zero cost abstraction"" is a core promise of the language.""",0.2375,C++
141qm6g,jno6e5v,"Before thinking I might have no idea what I'm talking about feel free to try out my compiler and reproduce my build speed https://bolinlang.com/ There's likely no way a person can get that kind of performance without knowing what their doing  > All of this doesn't mean  So many words and it doesn't seem like you ever thought maybe a person has no issues with manual memory management, C++ code and has valid reasons not to like rust  In the article graydon says ""Performance: A lot of people in the Rust community think ""zero cost abstraction"" is a core promise of the language.""",0.2375,Rust
141qm6g,jno6e5v,But I think the C and C++ standard library has 'ok' performance in some areas and slow in others.,0.06666666666666665,C
141qm6g,jno6e5v,But I think the C and C++ standard library has 'ok' performance in some areas and slow in others.,0.06666666666666665,C++
141qm6g,jno6e5v,Here's my language beating C in one area and C++ was painfully slow here https://bolinlang.com/more_optimal_standard  Since you brought up understanding how to write code multiple times I'll bring up for the third time that you should tell me what's wrong with the code in my example.,-0.2,C
141qm6g,jno6e5v,Here's my language beating C in one area and C++ was painfully slow here https://bolinlang.com/more_optimal_standard  Since you brought up understanding how to write code multiple times I'll bring up for the third time that you should tell me what's wrong with the code in my example.,-0.2,C++
141qm6g,jnoeq4x,"> Go ahead, tell me what I did wrong.",-0.5,Go
141qm6g,jnz8qel,I know that languages like Python and Go don't do it because they are determined to have intact stack traces for debugging.,0.0,Python
141qm6g,jnz8qel,I know that languages like Python and Go don't do it because they are determined to have intact stack traces for debugging.,0.0,Go
141qm6g,jnz8qel,But for C++ that sort of thing wouldn't be a priority...,0.0,C++
141qm6g,jnohhc7,Go ahead.,0.0,Go
141qm6g,jyldotb,"So if you have a loop header A invoking an iterator B that yields values to a loop body C, you get A calls B with the pointer-to-C, and B calls C for each step, just as if you'd passed a lambda / closure as C.  But there are details that differ:    * C can't escape, so you get the lifetime nesting of everything that you expect.",0.0,C
141qm6g,jyldotb,"* The variable-environment of C is extends the frame of A, so a frame-pointer from A is passed to B, and then back to C to run in, so variables in the loop body live across multiple calls back from B to C. The calls from B to C extend the _stack_ pointer of B with register spills and reloads (extending B's frame) but use the _frame_ pointer from A-and-C to find the environment for C.   * There's a loop-control protocol (continue, break, early-return) encoded in a token passed back and forth.",0.02727272727272727,C
141qm6g,jyldotb,"I think a similar translation scheme exists in the C++ coroutine stuff that's in LLVM now, but I haven't looked at the exact details.",0.125,C++
141mbnr,jn0wyot,"""Array languages"" like APL and its descendants can also be understood that way.",0.0,APL
141mbnr,jn0zk0b,"That said, I feel like you would run into practical problems as far as implementation goes - recursion in a language like Haskell mainly ""works"" (is efficient and reasonable for large inputs) because Haskell is able to optimize tail recursion so as to avoid stack overflows or ballooning memory requirements.",0.2361904761904762,Haskell
141mbnr,jn0zk0b,I would recommend looking at a language like Python and trying to write a meaningful program only using those higher order functions (or perhaps a few more you implement yourself) and seeing how far you can get.,0.19166666666666668,Python
141mbnr,jn1fox9,APL?,0.0,APL
141mbnr,jn1fox9,-   wikipedia https://en.wikipedia.org/wiki/APL_(programming_language)   try APL https://tryapl.org/,0.0,APL
141mbnr,jnds98h,"In Python you can write:      def makeRecursive(f):         return lambda args: f(f, args)          @makeRecursive     def factorial(alsoFactorial, n):         return 1 if n == 1 else n * alsoFactorial(alsoFactorial, n-1)      assert factorial(6) == 720  There is also a paper on why fold is awesome, but I haven't read it: http://www.cs.nott.ac.uk/~pszgmh/fold.pdf",1.0,Python
141mbnr,jn1hila,"If you like JavaScript, I wrote about implementing the “Mockingbird” in JS—plus some related combinators—here:  http://raganwald.com/2018/08/30/to-grok-a-mockingbird.html",0.0,JavaScript
141m6a4,jn0w2oy,"I like the Python variant of this - when you have several strings after each other in the code, they get concatenated to a single string.",-0.06547619047619048,Python
141m6a4,jn0w2oy,"I'd also ask myself if generic interpolation makes sense - I've found the ""choose when to interpolate"" from Python (prefix to activate interpolation, allow strings to be either single or double quote delimited) to be slightly better than the ""Default to interpolation with need to escape, use single quotes to avoid it"" from Perl/Ruby/Shell.",0.07142857142857144,Python
141m6a4,jn1fa0u,What about just escaping the line break like you do in C?,0.0,C
141m6a4,jn1fa0u,And it will be familiar syntax to anyone who ever wrote a non-trivial macro in C xD,0.375,C
141m6a4,jn22xkd,"But if I learned anything at all from PHP, it's that you shouldn't mix large literal binary or text data into your programming language.",0.21428571428571427,PHP
141m6a4,jn22xkd,"Whatever fills in the template can be responsible for formatting stuff as HTML, or the correct number of digits after the region-specific decimal separator, etc.",0.2,HTML
141m6a4,jn1ys1m,"I like the way that Python does this: you can enclose multiple string literals (without commas in between them) in parentheses to create a single string literal, ex:      x = (         ""this is a long string""         ""literal broken across many lines""         ""goodbye""     )      y = ""this is a long stringliteral broken across many linesgoodbye""      assert x == y  In its absence, languages that support compile-time macros like Rust also have an easy way of doing this:      let x: &'static str = concat!",0.027033730158730156,Python
141m6a4,jn1ys1m,"I like the way that Python does this: you can enclose multiple string literals (without commas in between them) in parentheses to create a single string literal, ex:      x = (         ""this is a long string""         ""literal broken across many lines""         ""goodbye""     )      y = ""this is a long stringliteral broken across many linesgoodbye""      assert x == y  In its absence, languages that support compile-time macros like Rust also have an easy way of doing this:      let x: &'static str = concat!",0.027033730158730156,Rust
141m6a4,jn2wam8,"That said, regarding breaking up strings: you can make up a syntax for that, like adjacent C strings concatenating together or JS' backslash, or, even simpler, you can make a semantic guarantee that manual concatenation of literals is done at compile-time.",0.0,C
141m6a4,jn210pj,Just one voice of opposition: The implicit concatenation of Python has been a source of weird bugs for me.,-0.5,Python
141m6a4,jndv751,"80 chars come from punched cards used for Fortran programs etc, and at that time nobody thought of CRT terminals.",0.0,Fortran
141m6a4,jn2cegl,Something like Go's template library should solve this.,0.0,Go
141m6a4,jn4qb7q,"ahaha :D It was just an opinion of mine, no annoyance intended.",1.0,D
1414ryo,,"A big reason why newer programming languages aren’t used in industry is because of the sheer amount of existing libraries and resources that already exist for it; for example, ML models are currently mainly built in Python because of the existence of libraries like numpy and pytorch, even though Python may not be the most efficient language for the task.",0.16666666666666666,Python
1414ryo,jmykhzd,"Google's Carbon is compatible with C++, and allows C++ to be inlined with Carbon.",0.0,C++
1414ryo,jmykhzd,"D is (mostly) a superset of C.  C can frequently be compiled as D.  Also, D can call gluelessly into (most) C libraries.",0.3666666666666667,D
1414ryo,jmykhzd,"D is (mostly) a superset of C.  C can frequently be compiled as D.  Also, D can call gluelessly into (most) C libraries.",0.3666666666666667,C
1414ryo,jmykhzd,"Perl has a bunch of Inline:: modules, allowing other languages to be used within perl scripts.",-0.125,Perl
1414ryo,jmyo0xm,"There are attempts to have a ""common runtime"", like the Java and dotnet virtual machines, but these are very opinionated and are a poor fit for many languages.",0.08,Java
1414ryo,jmyrvkn,"Well, HTML5 allows you to mix CSS (called ""inline CSS""), HTML and JavaScript in a single file, although it is discouraged.",-0.07142857142857142,HTML
1414ryo,jmyrvkn,"Well, HTML5 allows you to mix CSS (called ""inline CSS""), HTML and JavaScript in a single file, although it is discouraged.",-0.07142857142857142,JavaScript
1414ryo,jmyukpd,"EDIT: Also, the old [Arity/Prolog32](http://petergabel.info/ArityProlog32/ArityProlog32/) Prolog compiler allowed users to combine C and Prolog code in the same file, albeit the C code was limited in nature.",0.009523809523809526,Prolog
1414ryo,jmyukpd,"EDIT: Also, the old [Arity/Prolog32](http://petergabel.info/ArityProlog32/ArityProlog32/) Prolog compiler allowed users to combine C and Prolog code in the same file, albeit the C code was limited in nature.",0.009523809523809526,C
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,Lisp
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,Scheme
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,Java
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,Python
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,JavaScript
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,Lua
1414ryo,jn04rjh,"I don't know about _research_, but we did have a component based development environment in the '97 timeframe, built in Java, that did enable different languages to be used to build software, specifiable down to the method level.",-0.07777777777777779,Java
1414ryo,jn04rjh,"In other words, the same class could have one method written in Java, another in BASIC, and another in JavaScript -- not that that was the goal.",-0.041666666666666664,Java
1414ryo,jn04rjh,"In other words, the same class could have one method written in Java, another in BASIC, and another in JavaScript -- not that that was the goal.",-0.041666666666666664,JavaScript
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,C
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,Fortran
1414ryo,jn010bw,"Some languages, like D, also allow you to literally [mark a class as COM](https://dlang.org/spec/interface.html#com-interfaces) and all instances will be callable from other binaries in different languages, without any kind of C FFI.",0.15833333333333333,D
1414ryo,jn010bw,"Some languages, like D, also allow you to literally [mark a class as COM](https://dlang.org/spec/interface.html#com-interfaces) and all instances will be callable from other binaries in different languages, without any kind of C FFI.",0.15833333333333333,C
1414ryo,jn0q9a4,by writing some extensions in C or by using [FixNative](https://www.fixscript.org/docs/native/) or other libraries).,-0.125,C
1414ryo,jn0q9a4,"While I'm not sure how much such language mixing is useful, there are enough of real world examples where it turned out just fine (PHP, SQL, HTML, regexps, etc.)",0.11111111111111112,PHP
1414ryo,jn0q9a4,"While I'm not sure how much such language mixing is useful, there are enough of real world examples where it turned out just fine (PHP, SQL, HTML, regexps, etc.)",0.11111111111111112,HTML
1414ryo,jn0v9mz,"> mainly built in Python because of the existence of libraries like numpy and pytorch, even though Python may not be the most efficient language for the task.",0.3333333333333333,Python
1414ryo,jn0v9mz,A PHP or ASP file is designed to contain HTML portions.,0.0,PHP
1414ryo,jn0v9mz,A PHP or ASP file is designed to contain HTML portions.,0.0,HTML
1414ryo,jn0v9mz,Those HTML portions are designed to contain JavaScript and CSS portions.,0.0,HTML
1414ryo,jn0v9mz,Those HTML portions are designed to contain JavaScript and CSS portions.,0.0,JavaScript
1414ryo,jn0v9mz,"For example, JavaScript has both ""null"" and ""undefined"", a distinction that may be lost when handing data back and forth with another language.",0.0,JavaScript
1414ryo,jmyumnb,Don't forget the [inline-java](https://github.com/tweag/inline-java) package for Haskell.,0.0,Haskell
1414ryo,jn6amot,Making the language X which can embed Y Z A B C D E is already quite a feat.,0.0,C
1414ryo,jn6amot,Making the language X which can embed Y Z A B C D E is already quite a feat.,0.0,D
1414ryo,jn6amot,"Like if you come up with Gunkface, a language capable of embedding Python, the Python Software Foundation is *not* going to adjust itself to make sure it can embed Gunkface.",0.35,Python
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,Haskell
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,C
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,C++
1414ryo,jn13hh1,"It might sound like I'm clutching at straws here, but there are certainly languages with `|]`, such as OCaml and F# which use them for array literals, but also, Haskell itself, which uses it for quasiquotes.",0.20476190476190478,Haskell
1414ryo,jmyx17g,"It has a very opinionated architecture, like Java, in that everything is an object.",0.2,Java
1414ryo,jmyx17g,There's no Haskell for .NET for example (it was attempted and abandoned).,0.0,Haskell
1414ryo,jmz7jj6,"I have never written any Kernel (I have heard of it though), and I have a few questions as someone who writes quite a bit of Scheme.",-0.2,Scheme
1414ryo,jmz7jj6,All of what you said about environments here seems to also be true in Scheme.,0.35,Scheme
1414ryo,jmz7jj6,Is the environment system very different from Scheme?,0.0,Scheme
1414ryo,jn0glw0,Not a problem in Scheme either.,0.0,Scheme
1414ryo,jn0glw0,"Now try to add `and` and `or` to it, and you see a problem: These are not first-class procedures in Scheme, they're second-class, because they do short-circuiting evaluation.",0.0,Scheme
1414ryo,jn0glw0,"(This exact problem is what led me to Kernel in the first place: I was writing an interpreter in Scheme and came across several awkward points like this, before I found Kernel and everything seemed much more intuitive to me).",0.08,Scheme
1414ryo,jn0glw0,I consider the Kernel approach to be the duel of the Scheme approach.,0.0,Scheme
1414ryo,jn0glw0,"In Scheme, everything is implicitly evaluated, unless explicitly quoted.",0.0,Scheme
1414ryo,jn0glw0,> All of what you said about environments here seems to also be true in Scheme.,0.35,Scheme
1414ryo,jn0glw0,Is the environment system very different from Scheme?,0.0,Scheme
1414ryo,jn0glw0,"There are limitations on how you can create your own environments in Scheme, but almost none in Kernel.",0.6,Scheme
1414ryo,jn0glw0,Scheme environments are middle-class.,0.0,Scheme
140s7im,,"``` fn main(arg: type): result_type @event {} ```  ## Function Calls & Statements They're a lot like what they are in Java, C, etc.",0.0,Java
140s7im,,"``` fn main(arg: type): result_type @event {} ```  ## Function Calls & Statements They're a lot like what they are in Java, C, etc.",0.0,C
140s7im,,"I don't think this can replace Java for Minecraft servers, but it should have it's own little niche where it can support both high-level and low-level control.",0.20625,Java
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,JavaScript
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,Rust
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,Python
140s7im,,"However, I don't want to go as far as a language like Haskell - it should be easily readable without problem to most C-style developers.",0.3444444444444444,Haskell
140s7im,,I also don't like Java's verbosity - it's nice while debugging but it's painful to write without IDE tooling (which I don't always have access to).,-0.04999999999999999,Java
140s7im,,"And currently, it's hard for new people to get into the Spigot realm - most people dive in without knowing any Java, so giving them some language that can fit inbetween the realms of Skript's englishness and Java's verbosity would be nice.",0.2689393939393939,Java
140s7im,,"## Example So, for example, here's a simple Hello World in Java.",0.0,Java
140s7im,,"This allows this language to (hopefully) be **extremely** fast (speed is one of my priorities for this) using a bytecode interpreter and it's in Rust instead of Java, which should be a nice little speedup.",0.2041666666666667,Rust
140s7im,,"This allows this language to (hopefully) be **extremely** fast (speed is one of my priorities for this) using a bytecode interpreter and it's in Rust instead of Java, which should be a nice little speedup.",0.2041666666666667,Java
140s7im,jn0anwd,"## Programming Style  Be consistent in your approach, and avoid mixing syntax patterns (i.e., variable definition: `Type identifier = expr` in C family languages).",0.25,C
140s7im,jn0anwd,"You could aim to make your language more like Python, JS.",0.5,Python
140s7im,jn0c2ce,"My personal preferences are Ballerina, Python, or Go.",0.0,Python
140s7im,jn0c2ce,"My personal preferences are Ballerina, Python, or Go.",0.0,Go
140s7im,jn16wv0,"I decided to change it around a bit and line it up a bit closer to JavaScript, which was my original goal, something like JS but with some nice changes and less verbose (although verbosity is opt-in-able if you like, stuff like types).",0.26944444444444443,JavaScript
140s7im,jn16wv0,I'm gonna implement it over Valence Framework in Rust ([https://github.com/valence-rs/valence](https://github.com/valence-rs/valence)) so it can go fast and have both low-level and high-level control.,0.2,Rust
140hy0r,jmw9656,"It teaches Scheme bit by bit, building up to implementing a metacircular evaluator for the same language.",0.0,Scheme
13zzzfc,,"If you were to build an opinionated formatter like `gofmt` or `prettier` for a non-braced language like Python, how would you format it?",0.0,Python
13zzzfc,jmttv9r,Python has `elif`.,0.0,Python
13zzzfc,jmtvkct,Actually this made me think of a \`branch\` structure like this:  ``` branch      <some_very_long_condition>     and <some_very_long_condition>     and <some_very_long_condition>     or <some_very_long_condition>     then          <statement>         <statement>         <statement>      <condition> and <condition>     then          <statement>         <statement>      (<condition> and <condition>)     and (         <some_very_long_condition>         or <some_very_long_condition>     )     then          <statement>         <statement> ```  Which is a glorified JavaScript's `switch (true)\,0.0,JavaScript
13zzzfc,jmvizir,Python also has a match/case system now: structural pattern matching.,0.0,Python
13ztlms,jmswmat,"I like the fact that it jokes about rust's name shadowing and also JavaScript's quirkiness, it's kinda funny, also this language would strangely be usable unlike other esoteric programming languages",0.025000000000000005,JavaScript
13ztlms,jmv709g,> ❌ Rust Foundation (owned by the DreamBerd Foundation - please consider renaming)  This might be the best thing I've read all day,1.0,Rust
13ztlms,jx0zexx,"toadpond, i once discovered your programming language DreamBerd (now renamed to C, probably to abide by the naming laws) on a youtube short, and then I red through the documentation laughing my ass off the hilarius and implausible ideas, and I am asking, will it be OK if I make a meme programming language inspired by DreamBerd?",0.16666666666666666,C
13ztlms,jmuiwe4,"In Java at least there's the excuse the specification ""simply"" required absolutely everything to be in a Class because it was the 90s and OO was cool.",0.04,Java
13ztlms,jmtcqjj,"You're drunk, but you're at the bar in good company with C++ `friend`s",0.09999999999999998,C++
13ztlms,jn2mis5,"I'm not sure exactly how useful this is, but I think you might be interested in Parsing Expression Grammars (PEGs) (such as [LPEG](http://www.inf.puc-rio.br/~roberto/docs/peg.pdf) in Lua) and perhaps [Abstract Syntax Definition Languages](https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers) (ASDLs) as potential source of inspiration for Language Language if you weren't already aware of them.",0.1142857142857143,Lua
13ztlms,jmvzqin,"This is valid Perl to print  foo   bar      $x = foo;     print $x, ""\n"";          sub foo() {         bar     }     $y = foo;     print $y",0.0,Perl
13ztlms,jp160mr,https://www.mcmillen.dev/sigbovik/  93% of Paint Splatters are Valid Perl Programs,0.0,Perl
13zjq3y,,Our approach was greatly influenced by Java because at that time Ballerina was initially a JVM-based interpreted language.,0.4,Java
13zh58i,jmrc873,Haskell lists are extremely efficient for that so there's no need for a special abstraction.,0.11607142857142858,Haskell
13zezki,jmzmdyh,:D Thanks for the link.,0.6,D
13zcm5i,,Needing some way to tie those `t`s to the element type of the array I thought about adding a language feature to annotate the type of a function either at the top-level (like Haskell) or inline (like OCaml).,0.0,Haskell
13zcm5i,,"So the `capacity_of` function takes the length of an array and rounds it up to the next power of two:        let capacity_of n =         if n=0 then 0 else Int.next_pow_two(n-1)  Now the `resize` function appends `dn` elements onto the end of `a` in-place using C's `realloc`:        let resize(a, dn) =         let n2 = length a + dn in         Array(n2, C.realloc(ptr a, capacity_of n2 * size_of t))  Even if I added a `realloc` instrinsic there's still no way to tie the type of the input array to the type of the output array in my language today.",0.0,C
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,C
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,C++
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,Java
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,JavaScript
13zcm5i,jmr3oqy,"An example is the Haskell [ListLike](https://hackage.haskell.org/package/ListLike-4.7.8/docs/Data-ListLike.html) class, which provides generic operations over types which behave like lists.",0.0,Haskell
13zcm5i,jmrc0ky,"(Like C#'s indexer properties for example)  Similarly, Lists in Haskell are given special treatment, but are not very special.",0.07326007326007326,C
13zcm5i,jmrc0ky,"(Like C#'s indexer properties for example)  Similarly, Lists in Haskell are given special treatment, but are not very special.",0.07326007326007326,Haskell
13zcm5i,jmvwb87,> Arrays are built in to C  I wouldn't say that C has proper array support.,0.0,C
13zcm5i,jmvwb87,This is actually one of the biggest complaints I hear from C programmers.,0.0,C
13zcm5i,jmsl8qe,"JavaScript's built in array type supports the stack protocol, so it's both.",0.0,JavaScript
13zcm5i,jmsl8qe,"Since arrays are growable in JavaScript (which you need for them to support being used as stacks), the internal representation of an array has an indirection.",0.0,JavaScript
13zcm5i,jmsl8qe,A reference to a JavaScript array is a reference to a reference to an allocated block of memory.,0.0,JavaScript
13zcm5i,jmsl8qe,"If you have fixed-sized arrays as your primitive (like C, Java, and C#), then you can avoid that double indirection in places where you know you don't need to be able to grow the array.",0.25,C
13zcm5i,jmsl8qe,"If you have fixed-sized arrays as your primitive (like C, Java, and C#), then you can avoid that double indirection in places where you know you don't need to be able to grow the array.",0.25,Java
13zcm5i,jmsl8qe,(Like C#'s indexer properties for example)  The syntax is an orthogonal question.,0.0,C
13zcm5i,jmw68fz,"Array decay is certainly annoying, but C absolutely has arrays built into the language as a fundamental construct.",-0.30000000000000004,C
13zcm5i,jmt74ci,"Even indexer properties in C# are not completely first-class, because you can't specify `x[N]` where `x` is a polymorphic variable over all types which support indexing.",-0.05,C
13zcm5i,jmt74ci,"If you throw away the indexer property and just have methods, then these can be treated exactly the same as any other method - they're first-class, and you can separate out the setter and getter, which you can't do in C# because of the limitation of properties (which are second-class).",0.041666666666666664,C
13zcm5i,jmt74ci,"let peek collection index = collection[index]      f peek c  A first-class solution is to have operators and methods be interchangeable with syntax, as Haskell does.",0.0,Haskell
13zcm5i,jmwq34x,"For instance, there's also no size or aliasing information, so C still pales in comparison to languages like FORTRAN, Futhark, Chapel, etc.. when it comes to array support.",0.0,C
13y6nol,,"The stage 1 uses C as backend, as input to gcc.",0.0,C
13y6nol,,Should my stage 2 mainly target LLVM or C?,0.16666666666666666,C
13y6nol,,"But it's also known to be slow at compiling, also with `-O0`, while C has tcc which would speed up my c-to-exe step.",-0.30000000000000004,C
13y6nol,,Also targetting C would keep the ability to get my executable as optimized as the LLVM one.,0.0,C
13y6nol,,Now a couple of questions: * if targetting C: are all those string manipulations going to slow down my compilation anyway?,-0.2277777777777778,C
13y6nol,jmlf2sx,"LLVM also does not help you implement the C ABI, nor a lot of other things you get for free lowering to C. It does give you control, but that control often means you have to do a bunch of research in order to implement it right.",0.1869047619047619,C
13y6nol,jmlf2sx,"Several projects using LLVM later ends up eyeing other options (Rust, Zig, Odin etc)  Personally my project is using LLVM, so I’ve had to tackle these issues and every time I’ve felt I’m “done” digging into details, I’ve later discovered I was completely wrong.",-0.10416666666666667,Rust
13y6nol,jmlf2sx,"On the other hand, it’s great being able to tailor the debug info and not have a dependency on an external C compiler.",0.29375,C
13y6nol,jmlj3wh,>if targetting C: are all those string manipulations going to slow down my compilation anyway  Let's try it with some of my tools.,-0.2277777777777778,C
13y6nol,jmlj3wh,"`mc` is a transpiler that, with `-c`, turns it into a single C source file; oh and `tm` is a timing tool:      c:\qx>tm mm qc     Compiling qc.m---------- to qc.exe     TM: 0.10          c:\qx>tm mc -c qc     M6 Compiling qc.m---------- to qc.c     TM: 0.09          c:\qx>tm mc -tcc qc     M6 Compiling qc.m---------- to qc.exe     W:Invoking C compiler: tcc  -oqc.exe qc.c c:\windows\system32\user32.dll -luser32 c:\windows\system32\kernel32.dll -fdollars-in-identifiers     TM: 0.33  Building directly takes 0.1 seconds; turning it into C source (and it is very busy source of 43,000 lines) is marginally faster.",0.05285714285714286,C
13y6nol,jmlj3wh,But then you need to invoke the C compiler.,0.0,C
13y6nol,jmlj3wh,"Overall the process is slower than a direct build, but 0.3 seconds to build an app like this is still reasonable, compared with:      c:\qx>tm mc -opt qc     M6 Compiling qc.m---------- to qc.exe     W:Invoking C compiler: gcc -m64  -O3 -oqc.exe qc.c -s     TM: 51.09  This invokes `gcc -O3`, and takes 50 seconds.",0.10000000000000002,C
13y6nol,jmlj3wh,"`gcc -O0` takes 6.5 seconds, 25 times as slow as tcc (factoring out the C generation), but the generated code is not much better.",-0.275,C
13y6nol,jmlafpy,It's a bit odd to be stating that LLVM is slower than C when clang is itself powered by LLVM.,-0.16666666666666666,C
13y6nol,jmn3zxe,"For my project's C code generator, there is some string manipulation (mostly concatenation, no searching or substring operations on already ""generated"" code - I also use a header and footer template though there is only a few dozen lines in each), BUT this could be (and perhaps should have been) hidden.",0.03333333333333333,C
13y6nol,jmn3zxe,"A way to do this would be to create an AST for the C code and then just ""pretty print"" it to obtain C source code to pass to the C compiler.",0.25,C
13y6nol,jmn3zxe,tcc has been helpful to reduce the time to run my conformance tests but this is mostly because I don't do any kind of separate compilation so I compile my standard library once for each test case and I don't do any parallel building of test cases yet (so I'm using a single core unless the C compiler itself is multi-threaded).,0.20571428571428574,C
13y6nol,jmlooty,"LLVM is notoriously slow, generating c & feeding that through tcc will be faster, & then fallback on llvm codegen for release builds  Alternatively you can roll your own simple x86 backend, which will be much faster than either gcc or llvm  > if targetting C: are all those string manipulations going to slow down my compilation anyway?",0.007407407407407386,C
13y6nol,jmm3ujr,"I’ve been thinking about targeting C for a long time, and I’ve been drawing up some ideas where based on string length and possibly other heuristics I either use ropey structures (which would be used anyways for incremental compilation via LSP) and use kernel file ops for file appending, and for smaller strings just roll a StringBuilder.",-0.05833333333333333,C
13y6nol,jmpuuly,My C generation looks like SSA so I have many variables which doesn't seem to slow down tcc,0.01481481481481479,C
13y6nol,jmlq7z9,[Heres a godbolt link](https://godbolt.org/z/Wvzn9GcKv) demonstrating this approach with some C code.,0.0,C
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,C
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,Rust
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,D
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,Pascal
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,Pascal
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,D
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,C
13y6nol,jmmamnq,"The *major* advantage is that you can compile Rust and others to small `.wasm` modules, simplifying the bootstrapping and FFI.",-0.09375,Rust
13y6nol,jmmp2pf,"> LLVM also does not help you implement the C ABI,  Can you elaborate?",0.5,C
13y6nol,jmmeaft,">On the other hand, it’s great being able to tailor the debug info and not have a dependency on an external C compiler.",0.29375,C
13y6nol,jmmeaft,"On the other hand, the minimal dependency for C is a 1.6MB (not GB) Tiny C installation.",-0.075,C
13y6nol,jmmeaft,"And for the C code I sometimes generate, I only need 2-3 files totalling under 0.25MB.",0.0,C
13y6nol,jmmeaft,"At the user-site, yes, a C installation will be needed.",0.0,C
13y6nol,jmmeaft,"Otherwise, Tiny C is small enough to bundle.",-0.08333333333333333,C
13y6nol,jmlax1r,"> It's a bit odd to be stating that LLVM is slower than C when clang is itself powered by LLVM  C has a lot of compilers (some of them are very fast, for example tcc which is not powered by llvm for sure, and one passes c code).",0.1977777777777778,C
13y6nol,jmnyvga,Lua is one of the fastest lightest high level scripting lang there is designed for embedded systems in the mid 90's when they had less juice then your average ant.,-0.03916666666666666,Lua
13y6nol,jmnyvga,I kinda want to now I may spend rest of my life writing my own modules and possibly trying to erase luarocks from my mind.Yes btw I KNOW the new luajit or luajr I think is still very much a work in progress as mentioned librarys and a bunch more stuff but I for one would love Lua to be at least on people's mind when there looking at embedded systems.,0.24233766233766232,Lua
13y6nol,jmm8cra,CIL is very flexible; you can even do pointer arithmetic; I would say whatever you can do with standard C you can also do with CIL.,0.1,C
13y6nol,jmmtc0w,"Yet, `bcc` is limited in throughput by needing to use intermediate ASM source code (`tcc` is straight to binary in one pass), so there are two lots of lowering to source code, first to C, then to ASM.",0.1261904761904762,C
13y6nol,jmlchby,"I didn't mention gcc in response to anything you've written, but because gcc and clang are the two major C compilers.",0.0625,C
13y6nol,jmmg0lp,"Which is why my `mc` transpiler product, if it also invokes the C compiler, defaults to gcc; Tcc requires the `-tcc` option.",0.0,C
13y6nol,jmmg0lp,"Because the problem with gcc (I think you found this with LLVM) is that the translation to C is so fast, invoking gcc is like driving into a brick wall.",0.2,C
13y6nol,jmlhhwv,Tiny C runs on ARM too.,0.0,C
13y6nol,jmnm664,"However, I'm using a weird and non-standard ABI that is just C compliant enough to let me use all the C runtime and POSIX functions I want to.",-0.25,C
13y6nol,jmw7hf9,Weighing in at just 12.5kLOC of C it is only 0.17% of the 7.3MLOC in LLVM.,0.0,C
13y35a5,jmlvjdj,"Zig is rooted in pragmatism & trying to be a better C, and its main focus is systems programming.",0.3333333333333333,C
13y35a5,jmmcagl,"Is like before Rust, a language that *not* fill (enough!)",0.0,Rust
13y35a5,jmmcagl,"So doing a lang you start with was is *very well know first* and then, maybe, you start adding complex things like:  - Type checking - Limited Type inference (hard) - Full Type inference (VERY hard) - Macros (hard) - Good macros (harder) - Generics (even harder) - RC (easy) - Gc (very hard to very very hard) - Novel GC replacements like Rust borrow checking (almost God tier hard until recently?)",-0.040662202380952396,Rust
13y35a5,jmnkxbn,"Let me give one reason that confuses me:  C++ template metaprogramming is compile-time code execution, and it is very different from the usual conceptions of dependent types.",-0.125,C++
13y35a5,jmnkxbn,"Macro systems like m4 or the macros of Scheme and Common Lisp can offer compile-time (or ""pre-compile-time"") code execution, but they are not type systems at all, let alone dependent ones!",-0.375,Scheme
13y35a5,jmnkxbn,"Macro systems like m4 or the macros of Scheme and Common Lisp can offer compile-time (or ""pre-compile-time"") code execution, but they are not type systems at all, let alone dependent ones!",-0.375,Lisp
13y35a5,jmo1tbx,At least compared to some C++ template error messages I have seen in the past.,-0.275,C++
13y35a5,jmsby4t,At least compared to some C++ template error messages I have seen in the past.,-0.275,C++
13xzgbs,,"Have a presentation on a selected programming language that I don't know yet, (so python, java, C++ and Scheme/Racket are out) and next week I need to send in 3 suggestions for my presentation.",0.0,C++
13xzgbs,jmk7oc5,"OCaml has objects lol  Or Common Lisp, CLs objects are pretty cool.",0.275,Lisp
13xzgbs,jmk4qtq,"My first and unusual suggestion is ( commercial) Delphi / ( Open Source) FreePascal which is considered for many obsolete, which is not, because it's very detailed in it's design, besides supporting procedural and object orientation also supports modules.",0.24571428571428572,Delphi
13xzgbs,jmk4qtq,"The third could be JavaScript due functional programming, object orientation and dynamic declaration of properties and methods.",-0.041666666666666664,JavaScript
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,Go
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,Kotlin
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,Swift
13xzgbs,jmkrbia,Scala should suit you because you can compare it with your Java language.,0.0,Scala
13xzgbs,jmkrbia,Scala should suit you because you can compare it with your Java language.,0.0,Java
13xzgbs,jmkrbia,And C# is “not too exotic”(tm) and I can help you answer the questions and give you pointers to documentation.,0.5,C
13xzgbs,jmkw15s,What about R?,0.0,R
13xzgbs,jmlut64,"Second for smalltalk, also [IOLang](https://iolanguage.org) is super great, and of course the mighty Lua",0.3833333333333333,Lua
13xzgbs,jmp57nv,Kotlin might be an interesting one since I'd love to dip my toes a bit in app making.,0.5,Kotlin
13xw8jg,,I've been a C++ developer for 20 years.,0.0,C++
13xw8jg,,I spent many years honing my craft under the scrutinizing look of C++ chat on StackOverflow.,0.2,C++
13xw8jg,,"I was obsessed with C++ templates for a long time, but now I've toned it down a lot (because they negatively affect compilation time, readability and cause disproportional complexity).",-0.2513888888888889,C++
13xw8jg,,"I've dabbled in Haskell 15 years ago, from the YAHT tutorial (anyone remember that?).",0.0,Haskell
13xw8jg,,"I've also played a bit with Clojure but didn't go deep into macros, which is probably where the exciting stuff begins?",0.15,Clojure
13xw8jg,jmjpkwa,"Personally, the last language that 'blew my mind' was Elixir.",0.0,Elixir
13xw8jg,jmjpkwa,"Coming from the world of mutexes and complicated sharing, Elixir makes everything so much easier.",-0.15,Elixir
13xw8jg,jmjyizy,Prolog / Datalog.,0.0,Prolog
13xw8jg,jmjyizy,I heard Prolog made writing interpreters so easy it was banned in competitions!,0.5416666666666667,Prolog
13xw8jg,jmju3ry,Scheme and/or Haskell.,0.0,Scheme
13xw8jg,jmju3ry,Scheme and/or Haskell.,0.0,Haskell
13xw8jg,jmju3ry,Haskell is also a beautiful language - thinking functionally will expand your mind since you’re very experienced with imperative programming,0.925,Haskell
13xw8jg,jmjqd93,"Avoiding the esoteric languages, my vote is APL.",0.0,APL
13xw8jg,jmjqd93,"I've been working with C++ for over a decade, and APL is one of the few languages that revert me to the layman's position of ""it's magic, got it.""",0.15,C++
13xw8jg,jmjqd93,"I've been working with C++ for over a decade, and APL is one of the few languages that revert me to the layman's position of ""it's magic, got it.""",0.15,APL
13xw8jg,jml3fa4,"A few ideas:  - [Uxntal](https://100r.co/site/uxn.html) - essentially a forth-like assembly language  for a small virtual computer - [Futhark](https://futhark-lang.org/) - use a functional language to program the gpu - [Haskell](https://haskell.org) - a general-purpose functional language with many unique properties (purely functional, lazy, expressive types, STM, etc).",0.04880952380952382,Haskell
13xw8jg,jml3fa4,"You mentioned you dabbled in Haskell, why not try it again?",0.0,Haskell
13xw8jg,jml3fa4,"(I've written about [7 things I learned from Haskell](https://gilmi.me/blog/post/2022/12/13/learned-from-haskell), and my book is linked at them bottom if you're interested :) ) - [Zig](https://ziglang.org) - might hit closer to home with your C++ background, but is doing a few new and interesting things in that space.",0.2372727272727273,Haskell
13xw8jg,jml3fa4,"(I've written about [7 things I learned from Haskell](https://gilmi.me/blog/post/2022/12/13/learned-from-haskell), and my book is linked at them bottom if you're interested :) ) - [Zig](https://ziglang.org) - might hit closer to home with your C++ background, but is doing a few new and interesting things in that space.",0.2372727272727273,C++
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,Haskell
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,Lisp
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,Rust
13xw8jg,jmktye5,"Personally I'm fond of Ruby (yes, under the hood, Ruby is a smalltalk dialect.)",0.0,Ruby
13xw8jg,jmjz8an,"Prolog, or another of the logic programming languages maybe?",0.0,Prolog
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,Fortran
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,Pascal
13xw8jg,jmju1e7,And one more was `K` (related to `J` and `APL`).,0.25,APL
13xw8jg,jmkrpnr,https://red-lang.org  A modern take on Lisp with a focus in DSLs.,0.2,Lisp
13xw8jg,jmk2hqk,"Rust was mine, and I know it’s a popular one for this sort of thing.",0.6,Rust
13xw8jg,jmjzcm6,Watch this video about writing meta interpreters in Prolog.,0.0,Prolog
13xw8jg,jmld3d9,"Coming from C++ you can expect a much shorter, more elegant and expressive and ergonomic version of what you already know, with added metaprogramming in the language itself.",0.5,C++
13xw8jg,jmld3d9,What you will especially like is that you can take any C++ project and integrate it with Nim with no overhead at all.,0.0,C++
13xw8jg,jmld3d9,"I used it to run write a quick, one-off genetic algorithm to guess future user behavior of a legacy C++ app by calling into the actual code with Nim- yet the programming still felt quick-n-easy.",0.1111111111111111,C++
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,JavaScript
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,C
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,C++
13xw8jg,jmld3d9,"Write a cross-platform GUI app using C++ libraries, get done faster and have it be more pleasant.",0.6166666666666667,C++
13xw8jg,jmld3d9,Leverage decades-old C libraries and give them your own usability spin.,0.6,C
13xw8jg,jmld3d9,"Then there's the community projects... probably the most amazing one is futhark, which leverages LLVM to auto-generate Nim-bindings for any C library.",0.55,C
13xw8jg,jmjw1z3,"Go deeper in Haskell, learn Racket and read Beautiful Racket to see what the fuss about language oriented programming is all about.",0.85,Go
13xw8jg,jmjw1z3,"Go deeper in Haskell, learn Racket and read Beautiful Racket to see what the fuss about language oriented programming is all about.",0.85,Haskell
13xw8jg,jmkda76,"Erlang blew my mind two decades ago, and it has remained blown.",0.0,Erlang
13xw8jg,jmkda76,"I would avoid, for now, Elixir.",0.0,Elixir
13xw8jg,jmkda76,"While it inherits much of what Erlang provides, there's a whole lot more piled on top that obscures the elegance and simplicity of the Erlang approach.",0.35,Erlang
13xw8jg,jmk6k4z,Raku  At first glance it seems like a more polished version of Perl with more features.,0.4166666666666667,Perl
13xw8jg,jmjppu7,Ada?,0.0,Ada
13xw8jg,jmlhru4,> I was obsessed with C++ templates  You might be into [Spiral's](https://github.com/mrakgr/The-Spiral-Language) staging capabilities.,-0.5,C++
13xw8jg,jmlkdgw,Rust for changing the natural patterns I've always used in imperial programming,0.1,Rust
13xw8jg,jmll3m2,"Actually, from what you describe as the ""major breakthroughs in programming"", you should definitely have a look at Common Lisp.",-0.059375,Lisp
13xw8jg,jmll3m2,"I'd recommend you start by installing SBCL + Quicklisp and a editor that supports Lisp (Emacs is not required, but it's a good choice if you already know how to use it).",0.7,Lisp
13xw8jg,jmll3m2,"A good book to get you started is ""Common Lisp: A Gentle Introduction To Symbolic Computation"".",0.19999999999999998,Lisp
13xw8jg,jmll3m2,"More advanced books are ""Let over Lambda"" and ""On Lisp"".",0.45,Lisp
13xw8jg,jmkkz8d,Top contender : [https://mercurylang.org/](https://mercurylang.org/)  It's like if Prolog and Haskell had a baby.,-0.125,Prolog
13xw8jg,jmkkz8d,Top contender : [https://mercurylang.org/](https://mercurylang.org/)  It's like if Prolog and Haskell had a baby.,-0.125,Haskell
13xw8jg,jmjllt1,Try Rust and play with it a little bit.,-0.1875,Rust
13xw8jg,jmli0od,"Datalog is a nice simple one that's very powerful and then there's something like Idris, it's Haskell but abstract.",0.33,Haskell
13xw8jg,jmlnbb2,The first is APL.,0.25,APL
13xw8jg,jmlnbb2,I was told it wasn't so much a language as a religion (by one of the developers of the Fortran language).,0.2,Fortran
13xw8jg,jmlnbb2,The other is Elixir!,-0.15625,Elixir
13xw8jg,jmma7a4,Julia.,0.0,Julia
13xw8jg,jmma7a4,And also the syntax is Pythonic but the performance is like C++.,0.0,C++
13xw8jg,jmkb0nj,Rust is the best answer I can give you.,1.0,Rust
13xw8jg,jmkb0nj,"It’s not a VASTLY different paradigm from languages like C++ in the way that things like Haskell are, but it’s way more pragmatic than either C++ or Haskell.",0.25,C++
13xw8jg,jmkb0nj,"It’s not a VASTLY different paradigm from languages like C++ in the way that things like Haskell are, but it’s way more pragmatic than either C++ or Haskell.",0.25,Haskell
13xw8jg,jmkb0nj,"Rust reaches for a higher-level of abstraction with the adoption of some functional-programming concepts, but maintains a level of tramsparency between the code you write and the low-level semantics.",0.0,Rust
13xw8jg,jmkb0nj,"Rust has got a bit of a bad reputation on here for its cult-like level of recommendation, but I don’t think that’s worth paying much attention to.",-0.06666666666666661,Rust
13xw8jg,jmkb0nj,It’s the only language I know of that has a chance of being “the thing to now use anywhere we used to choose C++”,0.0,C++
13xw8jg,jmkiyev,Prolog or Agda.,0.0,Prolog
13xw8jg,jmkiyev,The gap between Haskell’s type system and Agda’s type system about as large as the gap between C’s and Haskell’s.,0.21428571428571427,Haskell
13xw8jg,jmkiyev,The gap between Haskell’s type system and Agda’s type system about as large as the gap between C’s and Haskell’s.,0.21428571428571427,C
13xw8jg,jmkgua2,*Erlang or any BEAM language* - and the secret here is the BEAM VM.,-0.4,Erlang
13xw8jg,jmltlgh,Scheme was great for me.,0.8,Scheme
13xw8jg,jmltlgh,"For statically typed FP I prrfer OCaml over Haskell, I find it more pragmatic and very nice to use.",0.64,Haskell
13xw8jg,jmm1lze,"There are a lot of good languages out there with novel ideas, such as Nim, Zig, and of course Rust.",0.35,Rust
13xw8jg,jmm7tue,Forth  APL  Brainfuck  OOK!,0.0,Forth
13xw8jg,jmm7tue,Forth  APL  Brainfuck  OOK!,0.0,APL
13xw8jg,jmmlf7r,Rust will blow your mind.,0.0,Rust
13xw8jg,jmntfhc,"Try Ada, it has structured programming as a key design idea.",0.0,Ada
13xw8jg,jmkdh9z,I really enjoyed coding in Ruby (not Rails).,0.5,Ruby
13xw8jg,jmka845,"Rust, man  It seems like stuff you know on the surface, so I'm sure it doesn't sound exciting, but once you go all in on Rust, it'll change your entire life I promise",0.3,Rust
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,C
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,C++
13xw8jg,jmldl42,"JavaScript will most likely, as yout stated: blow your mind and make you question everything you've believed in - I'm not sure though if that's the way you wanted your mind to be blown.",0.08333333333333333,JavaScript
13xw8jg,jmmz9x1,I guess Lisp could do the same when you go deep enough.,0.0,Lisp
13xw8jg,jmn7onn,Odin might not blow your mind but it will definitely make you go “man I wish C was like this!”,0.0,C
13xw8jg,jmnaam1,Something similar can be done in *Ada* when you define a type for everything.,0.0,Ada
13xw8jg,jmnaam1,I've seen highly efficient implementations of cryptographic algorithms in Ada that read like a book.,0.16,Ada
13xw8jg,jmnaam1,"Other than that, I'd also recommend *Prolog* and *Mercury* like others have.",-0.125,Prolog
13xw8jg,jmo9zqs,"Basically the same data structures as Python, but a completely different evaluation model: “goal-directed” evaluation.",0.0,Python
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,Scala
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,Java
13xw8jg,jmr90vx,"Considering your rich background in C++ and Haskell, along with your interest in functional programming paradigms, I wouldn't necessarily predict that [Ballerina](https://ballerina.io) will ""blow your mind.""",0.1875,C++
13xw8jg,jmr90vx,"Considering your rich background in C++ and Haskell, along with your interest in functional programming paradigms, I wouldn't necessarily predict that [Ballerina](https://ballerina.io) will ""blow your mind.""",0.1875,Haskell
13xw8jg,jmrkk26,Have you tried Lisp (as in common Lisp)?,-0.3,Lisp
13xw8jg,jmrkk26,"I know Clojure is ""a lisp,"" but I've never tried it myself, and you saying that you never really dove into the macros makes me think you didn't really experience the parts of Lisp I'm thinking about.",0.05,Clojure
13xw8jg,jmrkk26,"I know Clojure is ""a lisp,"" but I've never tried it myself, and you saying that you never really dove into the macros makes me think you didn't really experience the parts of Lisp I'm thinking about.",0.05,Lisp
13xw8jg,jmrkk26,"Basically, Lisp starts out as a pretty simple programming language that can do ""a few things.""",0.016666666666666663,Lisp
13xw8jg,jmrkk26,The process of writing a complex program in Lisp is basically extending the Lisp language itself to become a domain-specific language.,-0.3,Lisp
13xw8jg,jmx55dc,CHICKEN Scheme uses continuation  passing style (CPS) so functions never return but rather continue executing the continuation (rest of progeam).,-0.6,Scheme
13xw8jg,jmmffep,Elixir was a huge game changer for me.,2.7755575615628914e-17,Elixir
13xw8jg,jmk1274,\+1 for Prolog.,0.0,Prolog
13xw8jg,jmk1274,"Mercury is also worth a try if you like strong types, but it helps if you've dabbled a little in Prolog first.",0.19895833333333332,Prolog
13xw8jg,jml8n2t,"Yep, Prolog for sure.",0.5,Prolog
13xw8jg,jml8n2t,Prolog does the “logic programming” thing so much better compared to logic libraries in other languages.,0.1875,Prolog
13xw8jg,jml8n2t,"Also, the fact that it’s homoiconic like Lisp allows so much cool metaprogramming stuff.",0.35,Lisp
13xw8jg,jml6as4,I will giving a talk later this year at Gophercon UK about how I implemented it in Go using concurrency.,0.0,Go
13xw8jg,jmjslli,Scheme was a stretch but not mind-bending in any way.,0.0,Scheme
13xw8jg,jmjslli,But array processing languages like APL and J are a total mind melt and a blast.,0.0,APL
13xw8jg,jmk821y,>APL  Just curious.,-0.1,APL
13xw8jg,jmk821y,Last time I used APL was on an IBM 5100 which had an APL keyboard.,0.0,APL
13xw8jg,jmkdrpv,"APL was my first programming language, back around 1972.",0.125,APL
13xw8jg,jmkdrpv,"Decades later when I discovered Functional Programming, it felt familiar to APL, in the sense of composing programs from expressions returning values.",0.1875,APL
13xw8jg,jml7xpd,"Modern, very good documentation, a bit less confusing than APL imo.",0.16083333333333333,APL
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,C++
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,Rust
13xw8jg,jmlorlg,"While Rust without a doubt puts a big emphasis on compile-time verification, things like integer overflows still happen, and are not caught by the compiler.",0.0,Rust
13xw8jg,jmkfjds,I found Erlang to be underwhelming as a programming language.,0.0,Erlang
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,Erlang
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,Elixir
13xw8jg,jmlx2yk,The thing that elixir has over Gleam and Erlang is it’s meta programming capabilities.,0.0,Erlang
13xw8jg,jmlx2yk,"Elixir is really good and doing scientific computing, data analytics, machine learning, etc.",0.7,Elixir
13xw8jg,jmlx2yk,where as Erlang isn’t great for it.,0.8,Erlang
13xw8jg,jmlx2yk,"Lib, does macro black magic to get Elixir to run on GPUs, etc)",0.16666666666666669,Elixir
13xw8jg,jmn7bnw,First time when I got introduced to Scala.,0.25,Scala
13xw8jg,jmlag0y,"For an experienced c++ dev, the Rust experience will probably be “oh this is nice, finally some built in tooling“ and then “why can’t I build my linked list example, get out of my way Rust I know what I’m doing”.",0.4666666666666666,Rust
13xw8jg,jmlag0y,"Rust is great if you come directly from the front end world and want to do some lower level development, or just prioritize safety over convenience, but Rust is just a more unpractical c++ imo.",0.4666666666666666,Rust
13xw8jg,jn628j7,"I never really liked Python and when Julia came out I liked it way more right away, and now it has more libraries and support than it used to",0.31714285714285717,Python
13xw8jg,jn628j7,"I never really liked Python and when Julia came out I liked it way more right away, and now it has more libraries and support than it used to",0.31714285714285717,Julia
13xw8jg,jn61zmx,"Lol one big issue with Ada is you need a bootstrapped GCC 10 to compile it, and then you need to compile gcc 11, and then gcc 12, and then gcc13, and 14 if you really want.",0.3333333333333333,Ada
13xw8jg,jmkbty4,"I mean, they've done some Haskell, so that's not mind blowing anymore and it would be the obvious go-to answer.",-0.15625,Haskell
13xw8jg,jmng36m,">I guess Lisp could do the same  Did you ever see DSSSL, which was the predecessor of XSLT?",0.0,Lisp
13xw8jg,jmjvqq0,"Erlang obviously, LFE is like Common Lisp but BEAM, Gleam is a new BEAM language.",-0.05454545454545454,Erlang
13xw8jg,jmjvqq0,"Erlang obviously, LFE is like Common Lisp but BEAM, Gleam is a new BEAM language.",-0.05454545454545454,Lisp
13xw8jg,jmnp19u,"Ecstasy supports a very similar model of concurrency:  * Ecstasy ""services"" are like Erlang processes: Objects that represent async execution and a domain of owned/managed state.",0.0,Erlang
13xw8jg,jmnp19u,"mutable data) only exists within the realm of a service; this is different from Erlang, which does not allow mutable data for the most part.",0.16666666666666666,Erlang
13xw8jg,jmkjcv6,"There are other BEAM languages, although probably not as developed/popular as Elixir.",-0.125,Elixir
13xw8jg,jml50dw,I think there's a BEAM-style concurrency library in Rust but it might not have taken off.,0.0,Rust
13xw8jg,jml50dw,There's also some mentions of BEAM-style concurrency using new lightweight Java threads?,0.13636363636363635,Java
13xw8jg,jml50dw,But probably someone is experimenting with it in Clojure by now.,0.0,Clojure
13xw8jg,jml633k,"Yeah Idris or LeanProver or Coq since you have worked with Haskell the syntax is kind of similar, but being able to then also prove programs are correct is mind blowing.",0.3666666666666667,Haskell
13xw8jg,jmkx0gj,Damn I’ll have to add Prolog to my list of languages to try.,0.0,Prolog
13xw8jg,jmkx0gj,So far APL is at the top,0.3,APL
13xw8jg,jmkba7m,"https://tryapl.org/  Also, I think Dyalog will install a custom keyboard map just for APL.",0.0,APL
13xw8jg,jmmaq0v,"I now dabble with both APL and BQN which have prefix key system, where you hit  a prefix, then a key after that to get the symbol you want.",0.0,APL
13xw8jg,jmll702,Curry (similar to Haskell but with logic features added),0.0,Haskell
13xw8jg,jmmcgjs,The thing I found interesting about Erlang is that it's basically microservices and Kubernetes two decades before everyone was raving about how this new concept was going to revolutionize the industry.,0.3181818181818182,Erlang
13xw8jg,jmn74ws,"I understand Elixir's appeal, it's just not for me.",0.0,Elixir
13xw8jg,jmn74ws,If I wanted Ruby I would learn Ruby.,0.0,Ruby
13xw8jg,jmkp77p,Do people really think Carp is harder than Rust?,0.05,Rust
13xw8jg,jmkp77p,"When I had used it, with no Rust experience, I figured Carp out in a few hours.",-0.2,Rust
13xw8jg,jmkp77p,"Rust, on the other hand, has such dense syntax and an endless list of features that it was not something I figured out in a few hours.",-0.1125,Rust
13xw8jg,jmkwz0i,"Also, you can make a lot of Erlang pids.",0.0,Erlang
13xw8jg,jmmy8iy,Go absolutely does not.,0.2,Go
13xw8jg,jmli2tg,Go concurrency is not identical but it is *really* similar...,0.0,Go
13xw8jg,jmngjuo,"All of those ways are reasonably efficient  Notably, “strip suffix” _should_ be `semidet`, but a typical Prolog implementation will actually be `nondet`, so it will do an extra iteration just to tell the caller “no more results”.",0.04722222222222222,Prolog
13xw8jg,jmp08zv,"Yes, Prolog has first-class support for nondeterminism.",0.0,Prolog
13xw8jg,jmp08zv,There is a joke that Prolog only has one algorithm: exponential backtracking search.,0.0,Prolog
13xw8jg,jmp08zv,"This is indeed a joke, but it's true that writing exponential backtracking search is much easier in Prolog than in most other languages.",0.23125,Prolog
13xw8jg,jn14owr,Elixir is superficially similar to ruby the syntax looks similar but the semantics are completely different,0.0,Elixir
13xw8jg,jmlou1s,"In my case I've used more Rust than C++, but now recently I've found myself going back to C++ due to convenience.",0.09375,Rust
13xw8jg,jmlou1s,"In my case I've used more Rust than C++, but now recently I've found myself going back to C++ due to convenience.",0.09375,C++
13xw8jg,jmlou1s,"Convenience of being a more mature language with generally larger, more popular and more feature rich libraries for a much broader usecases than Rust.",0.34687500000000004,Rust
13xw8jg,jmlou1s,"There are fun PoC projects like Bevy and (now archived) amethyst, but actual real world development is done in C++ and that's where the cutting edge is (e.g.",-0.024999999999999994,C++
13xw8jg,jmlou1s,"Also I have tried to use Rust for ""low level hackery"", like creating an injectable dynamic library that can hook functions of an application, and it's more of a hassle in Rust than with C++.",0.16666666666666666,Rust
13xw8jg,jmlou1s,"Also I have tried to use Rust for ""low level hackery"", like creating an injectable dynamic library that can hook functions of an application, and it's more of a hassle in Rust than with C++.",0.16666666666666666,C++
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,C++
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,C
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,Rust
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,Rust
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,C++
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,C
13xw8jg,jmlou1s,"However, if there is a project where security is the #1 concern of an application together with performanc, then Rust could be a good fit.",0.55,Rust
13xw8jg,jna3kda,"I didn’t know about that Ada overlay though, so thanks for the link.",0.2,Ada
13xw8jg,jmm335q,"While the actor model used by Erlang and communicating sequential processes which inspired Go are in some ways two sides of the same coin, Go is missing out on a lot of the things that make Erlang great:  - Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.30000000000000004,Erlang
13xw8jg,jmm335q,"While the actor model used by Erlang and communicating sequential processes which inspired Go are in some ways two sides of the same coin, Go is missing out on a lot of the things that make Erlang great:  - Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.30000000000000004,Go
13xw8jg,jmm335q,"In Go, all goroutines share one big global mutable heap.",0.0,Go
13xw8jg,jmm335q,"Go's memory model is built on racy concurrent mutation of global state, where Erlang doesn't have mutation of global state whatsoever, and very little global state to begin with beyond the code server.",-0.060937500000000006,Go
13xw8jg,jmm335q,"Go's memory model is built on racy concurrent mutation of global state, where Erlang doesn't have mutation of global state whatsoever, and very little global state to begin with beyond the code server.",-0.060937500000000006,Erlang
13xw8jg,jmm335q,"- Erlang is built on asynchronous messaging, which is much more flexible.",0.5,Erlang
13xw8jg,jmm335q,"Go channels use synchronous, bounded, blocking messaging - The Erlang/OTP framework provides extensive built-in support for building fault-tolerant concurrent applications, including declarative structuring of supervision hierarchies, and a ""let it crash"" philosophy intended to enable self-healing applications, with extensive exception reporting capabilities.",0.0,Go
13xw8jg,jmm335q,Go has none of that.,0.0,Go
13xw8jg,jmm2k2o,"The only difference is that concurrent processes communicate by sending messages over channels in Go, where concurrent processes communicate by sending messages directly each other in Elixer.",-0.008333333333333331,Go
13xw8jg,jmm2k2o,There are different consequences in how they are implemented in Go vs OTP.,0.0,Go
13xw8jg,jmm2k2o,"Yes, Go and Erlang have differences beyond their concurrency systems.",0.0,Go
13xw8jg,jmm2k2o,"Yes, Go and Erlang have differences beyond their concurrency systems.",0.0,Erlang
13xw8jg,jmm551p,"> Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.6,Erlang
13xw8jg,jmm551p,"In Go, all goroutines share one big global mutable heap.",0.0,Go
13xw8jg,jmm551p,Mutability can be a pain point in Go.,0.0,Go
13xw8jg,jmm551p,"> Erlang is built on asynchronous messaging, which is much more flexible.",0.5,Erlang
13xw8jg,jmm551p,"Go channels use synchronous, bounded, blocking messaging  I disagree that Erlang style asynchronous messaging is more flexible.",0.5,Go
13xw8jg,jmm551p,"Go channels use synchronous, bounded, blocking messaging  I disagree that Erlang style asynchronous messaging is more flexible.",0.5,Erlang
13xw8jg,jmm551p,You have to synchronize actors manually by essentially implementing TCP-lite if you want that kind of behavior using Erlang actors.,0.3,Erlang
13xw8jg,jmm551p,I don't think it's fair to say Erlang actors are more flexible.,0.6,Erlang
13xw8jg,jmm551p,Go has none of that.,0.0,Go
13xw8jg,jmm551p,CSP in Go can be implemented on a fault tolerant runtime - it just isn't.,0.0,Go
13xw8jg,jmmedgo,Go's concurrency model (CSP ) and Erlang/BEAM's (Actor) are different.,0.0,Go
13xw8jg,jmmedgo,")*  Go's model does allow shared state, but the idiomatic way to handle shared state is to ""share memory by communicating"", i.e., to use channels to pass the state around, these are not messages, and should not be confused with such.",-0.2,Go
13xw8jg,jmmedgo,"In Go's CSP model, goroutines (lightweight threads) communicate primarily through channels which can be thought of as typed pipes that allow you to send and receive values with the channel operator, <-.",0.4,Go
13xw8jg,jmmedgo,"There is no direct channel of communication as in Go; instead, each actor has a mailbox for incoming messages.",-0.05,Go
13xw8jg,jmmedgo,"In Go, goroutines and channels are the main concurrency primitives.",0.16666666666666666,Go
13xw8jg,jmmedgo,"In Go, error handling tends to be done through multiple return values and the error type.",0.0,Go
13xw8jg,jmmedgo,"Go’s channels provide a mechanism for guaranteed delivery – if a goroutine sends a message on a channel, another goroutine will receive it.",0.0,Go
13xw8jg,jmmedgo,"the Actor model and Go's CSP model both provide robust frameworks for handling concurrency, they embody different philosophies and offer different sets of trade-offs.",0.0,Go
13xw8jg,jmmybn0,Except Go isn't pure CSP as there's no restrictions on memory sharing at all.,0.21428571428571427,Go
13xw8jg,jmm89xe,> I disagree that Erlang style asynchronous messaging is more flexible.,0.5,Erlang
13xw8jg,jmm89xe,Erlang has blocking *receive*.,0.0,Erlang
13xw8jg,jmm89xe,Joe Armstrong did a great job of covering the tradeoffs here in his book Programming Erlang.,0.8,Erlang
13xw8jg,jmm89xe,> You have to synchronize actors manually by essentially implementing TCP-lite if you want that kind of behavior using Erlang actors.,0.3,Erlang
13xw8jg,jmm89xe,"It's one of the most common patterns in all of Erlang, and it's built into the framework that ships with the language.",0.1,Erlang
13xw8jg,jmm89xe,"Go, on the other hand, bakes this into the language at a very very deep level, rather than it being a framework implemented in lower-level, more flexible primitives.",0.125,Go
13xstwh,jmkukxt,"There's a bunch of Lox implementations in Rust:  https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust  If you understood the book, and as I see from other comments that you're more at home with Rust than C, then can you kind of imagine the book with these as the code examples?",0.325,Rust
13xstwh,jmkukxt,"There's a bunch of Lox implementations in Rust:  https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust  If you understood the book, and as I see from other comments that you're more at home with Rust than C, then can you kind of imagine the book with these as the code examples?",0.325,C
13xstwh,jmj5iff,If you know how to program then you can do the C part of that book.,0.0,C
13xstwh,jmj5iff,"Rust is different for sure, but you can probably extrapolate and figure it out.",0.25,Rust
13xstwh,jmj5iff,"C is a small language, it doesn't have any special features.",0.053571428571428575,C
13xstwh,jmjz7uc,You can checkout the [Rust implementations of clox](https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust) interpreter.,0.0,Rust
13xstwh,jmjz7uc,It might teach you how to express the ideas presented in the book in idiomatic Rust.,0.0,Rust
13xstwh,jmjcu4n,Can write but need deep compiler expert that first masters Rust.,0.125,Rust
13xstwh,jmj0sgp,Because im not as good with C as I am in Rust,0.7,C
13xstwh,jmj0sgp,Because im not as good with C as I am in Rust,0.7,Rust
13xstwh,jmj6b0j,"Rust has so many feautures to make things faster, i preferred learning from a ""rusty"" source then porting C to Rust, so I can learn the many features of the language, i will try to implement clox again tho",0.5,Rust
13xstwh,jmj6b0j,"Rust has so many feautures to make things faster, i preferred learning from a ""rusty"" source then porting C to Rust, so I can learn the many features of the language, i will try to implement clox again tho",0.5,C
13xpicd,,The nearest such feature is something that C calls 'X-macros\`.,0.0,C
13xpicd,jmitixg,"General solutions I am aware of:  * Code generation, of with X-macros is a clever hack to work within the limitations of the C preprocessor.",0.15555555555555556,C
13xpicd,jmitixg,"For example, Java enums have built-in methods to retrieve the name of an enum value.",0.0,Java
13xpicd,jmitixg,"I want to highlight Java enums here, which I think are a fairly elegant solution following the ""turn it into a language feature"" approach.",0.25,Java
13xpicd,jmk81cr,"Just for fun, I implemented the [same kind of thing in TypeScript here](https://www.typescriptlang.org/play?target=7#code/PTAEGcBcENISwMakgTwA4FNymgJw6AgPa74KQA2KocAdgGYakYAmoAFABZEBuTovfpE4EeeONABGFLAEoAUMVpRQAbRb4A5rWgBbLABpQW8HABeh4xk10WiLAF1QAXmREAKgFc0MgPL0AQVJoFHB2VXlQKLUAIhYABhijAA4jGNxEhwNI6NU4gEYk0FTQdMKsnKi8lkKUtNwAJhiK6NjoRKMAFnrM7Na86FrQbtLccuyHBXkQUABhCkQAa1KAJU9aGLcIDAJhAgoiTUUiZSIZADoDzXYNax19cAUlcDOMS8P2E3M5Y9OLq8+1ls9ke8jB4OmACpIZFIaAAOIYWhMRCgejrchwE6EE58XDwWiaHDBFAAWiI9FJkG8MmwkCIyBpGHJlLwuBC4CMumgdBgdDoR1AcKgsFRqEw4HOsOA0zAvloVAg3AA7rQ0SRQN4ttSfFgBPRQDJCcJQPFSSMENA1cQ0ChgGhoFBdgzlSRlvQNVbqEbNMJ5OjaJjsfSvLr-EF2aEbrBoAAuNSTeOqBz+jHwYMeJnhkngAA8AQAfNGYEmAg5k7JS8mUwGg2qQ1nAjn80YAEJFlgx0tt8uJtQBZNt6upwPp+uZsNNyN5gJtoyzDtd-tzua9yv9wegVub2bD2tjtyhvxTjktrfzowAEUXJeX57mV7XVayW53m8vw5mcF0uv0tBgY4jnWh6NhGHLFnGmq0IstBEKqyYVqAADelQ4sokCGkivqcC4oCdjAqjxA4AD8lxYSaxHEaaYKtPg1K4GqYEoOc9C4EQujsEhmHGjhAC+RjsAA+kYcCyC4BZ4TG5zcmg7BwJAGC6OJNAKboqhwJMCi8fIQA).",0.3,TypeScript
13xpicd,jmlgmai,">Just for fun, I implemented the same kind of thing in TypeScript here.",0.3,TypeScript
13xkz1o,jmssmg9,"Instead of passing by value with great difficulty, why not support Rust's `&mut`?",0.8,Rust
13xkz1o,jmhznwf,The great thing about Haskell etc.,0.8,Haskell
13xkz1o,jmmu0jf,"It depends on the language, but in C, you can get the address of a variable that lives on the stack, and if you're not careful, the pointer can outlive the stack frame it points to.",0.05,C
13xkz1o,jmj6my6,"Monads were adopted by Haskell as a way of achieving purity without needing uniqueness types that Clean had adopted - so I'd say there is, in some sense, a fundamental connection there.",0.3666666666666667,Haskell
13xkz1o,jmj6my6,[Phillip Wadler's Monads For Functional Programming paper](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf) gives a pretty good overview of why the Haskell developers went with monads.,0.475,Haskell
13xkz1o,jmiofcc,Just like in Haskell `IO ()` is the unit type in a context where input/output is possible.,0.0,Haskell
13xkz1o,jmiui3g,"For example, take the function `putChar :: Char -> IO ()` from [Haskell](https://hoogle.haskell.org/?hoogle=putChar).",0.0,Haskell
13xkz1o,jmiui3g,"This is especially important in strict functional languages like Haskell, where all functions are pure and side effects are prohibited.",0.5071428571428571,Haskell
13xkz1o,jmiui3g,Haskell gets around this restriction by making the side effect part of the type.,0.0,Haskell
13xkz1o,jmiyct4,"Yeah, I know Haskell and how IO works.",0.0,Haskell
13xkz1o,jmiyct4,"It could be defined as, in Haskell terms,  ```` newtype Random a = Random (Rng -> (a, Rng)) ````  where `Rng` is a known random number generator type (it could be a parameter to `Random` though).",-0.5,Haskell
13xkz1o,jmiyct4,"(GHC has a language option to enable linear types, but I haven't written any Haskell long before this was added, so I'm not sure how it works).",-0.15,Haskell
13xdkmr,jmhhy9q,"Just did some benches, the code is [here](https://gist.github.com/yndc/6691f1cc0dcc31de59fffa13d5afa0d3) (C++).",0.0,C++
13xdkmr,jmhhy9q,"To simulate padding, I used different data types in C++ (`short, int, long long` to store the same `char` type (1 byte).",-0.02,C++
13xdkmr,jmhjsis,"For example, C# has special annotations like `[FieldOffset(n)]` to let users customize exactly how data is aligned.",0.3035714285714286,C
13xdkmr,jmhjsis,Overlapping memory can even be used to model C unions.,0.0,C
13xdkmr,jmhjsis,"Still, this makes C# a lot better at native code interop than Java.",0.5,C
13xdkmr,jmhjsis,"Still, this makes C# a lot better at native code interop than Java.",0.5,Java
13xdkmr,jmi7spx,"Yeah C# keeps the default alignment as an implementation detail, unless you manually specify the alignment via annotations.",0.0,C
13xdkmr,jmhydpq,"Any C compiler will align 64-bit entities at 8-byte boundaries, I'd be surprised if other languages did anything different.",-0.008333333333333331,C
13xdkmr,jmi3b79,"Both Java and C# seem to default to system pointer size alignments, which is 8 byte for 64 bit machines.",0.0,Java
13xdkmr,jmi3b79,"Both Java and C# seem to default to system pointer size alignments, which is 8 byte for 64 bit machines.",0.0,C
13x7r6s,jmqq9gc,This may be partially why Go switches stacks when calling into C,-0.1,Go
13x7r6s,jmqq9gc,This may be partially why Go switches stacks when calling into C,-0.1,C
13x3q8g,jmhbbk7,"And that's beside the mention of ""great success""... Rust wasn't even around in 2002, and I don't think any language other than MLKit used regions at the time.",0.325,Rust
13x3q8g,jmhc2wm,"By C, I believe they're referring to Cyclone, which was being worked at around the same time.",0.0,C
13x2iv3,jmfvkzo,"When I first hacked my type system together, only structs were nullable, and they all were (like Java I guess).",0.125,Java
13x2iv3,jmfvkzo,I finally buckled down and figured out the syntax and semantics of the Imperative Shell part of my FC/IS language.,-0.07777777777777779,Shell
13x2iv3,jmfvkzo,"I need to look into a bug that may still be lurking in the multiple dispatch, add a little more built-in IO, add a `rune` type for compatibility with Go, and bring the docs up to date.",0.10416666666666667,Go
13x2iv3,jmmjcbm,"It was originally in D, but I was never able to setup a debugger on Windows, so I've swiched to C# (that I'm more used to) and quickly was able to fix some bugs that were haunting me for months and finally advanced again.",0.30972222222222223,D
13x2iv3,jmmjcbm,"It was originally in D, but I was never able to setup a debugger on Windows, so I've swiched to C# (that I'm more used to) and quickly was able to fix some bugs that were haunting me for months and finally advanced again.",0.30972222222222223,C
13x2iv3,jmj3b7c,The Cara language (https://cara-lang.com): right now I'm rewriting the interpreter in Elm (it was previously in TypeScript and before that in OCaml).,0.05952380952380952,Elm
13x2iv3,jmj3b7c,The Cara language (https://cara-lang.com): right now I'm rewriting the interpreter in Elm (it was previously in TypeScript and before that in OCaml).,0.05952380952380952,TypeScript
13x2iv3,jnt1ses,I was finally inspired to get started after reading Graydon Hoare’s post on how Rust would have looked different if he could make all the decisions.,0.0,Rust
13x2iv3,jnt1ses,"One of the things that struck me is that Hoare didn’t want capture groups in Rust, and I realized from my own immediate disagreement that I really like closures, so I decided to put together some ideas for a language that used scopes (closures) as it’s “atomic” unit.",0.4,Rust
13x2iv3,jnt1ses,"It would be a systems level language with managed memory like rust but draw several inspirations from Julia, another language I really enjoy.",0.2,Julia
13x2iv3,jo8qvxq,"There are still functions in some ways via a trait system kind of like Rust (also where and polymorphism appears), but it's not quite the same.",0.3,Rust
13x2iv3,jo8qvxq,These procedures can also have embedded C code which is how you interact with external stuff and how the core and standard libraries are implemented.,0.0,C
13x2iv3,jo1uusi,"A couple years into it, I discovered the D programming language and fell in love.",0.5,D
13x2iv3,jo1uusi,"D is already pretty close to what I wanted ZACL to be, and much more mature.",0.2833333333333333,D
13x2iv3,jo1uusi,It seemed to me that I should be able to implement ZACL's value-add features as a D framework.,0.5,D
13x2iv3,jo1uusi,"That proved a lot more difficult than I thought, and I've lowered my sights for that D framework.",0.0,D
13x2iv3,jo1uusi,"One of the ways I am toning down my ambitions is to make at least the first version a transpiler instead of a compiler, targeting C as its IR and using gcc as its back-end.",-0.06851851851851853,C
13x2iv3,jo1uusi,"* Extending the struct type to include class-like capabilities, pretty much identical to D's structs.",0.225,D
13x2iv3,joqkhwz,"I’m implementing my language, sammy-lang, in C++ using LLVM.",0.0,C++
13x2iv3,joqkhwz,My previous version is written in JavaScript and compiles to JavaScript.,-0.16666666666666666,JavaScript
13x2iv3,joslvvk,"I'm continuing to work on [pliron](https://github.com/vaivaswatha/pliron) (an MLIR like extensible compiler IR framework written in Rust), and recently added infrastructure for [automatic verification of interface (trait) implementations](https://github.com/vaivaswatha/pliron/wiki/Automatically-Verifying-Implementation-of-Interfaces).",0.0,Rust
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,Python
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,D
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,C
13x2iv3,jnrkjfg,"I needed to change my grammar from what I'd _like_ to write to something else just to appease the LR gods) - in TypeScript I used a simple recursive descent - sure, probably less performant, but I had the freedom to eg.",0.11111111111111112,TypeScript
13x2iv3,jnrkjfg,"I am for some reason way better at using ML languages than ALGOL ones, and was having trouble getting my head around some things, like the semantics of modules, private declarations etc.",0.09999999999999999,ALGOL
13x2iv3,jnrkjfg,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,TypeScript
13x2iv3,jnrkjfg,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,Elm
13x2iv3,jns74ix,"The code didn't change much, probably I was writing unidiomatic D to begin with haha (C# was already my daily language).",0.13333333333333333,D
13x2iv3,jns74ix,"The code didn't change much, probably I was writing unidiomatic D to begin with haha (C# was already my daily language).",0.13333333333333333,C
13x2iv3,jns74ix,"Now I have some extra seconds of start up time (D compiler was very fast), but my interpreter is still too simple for me to be able to tell if I got a speed improvement or regression.",0.19,D
13x2iv3,jnrovs1,"I needed to change my grammar from what I'd like to write to something else just to appease the LR gods) - in TypeScript I used a simple recursive descent - sure, probably less performant, but I had the freedom to eg.",0.11111111111111112,TypeScript
13x2iv3,jnrovs1,"I am for some reason way better at using ML languages than ALGOL ones, and was having trouble getting my head around some things, like the semantics of modules, private declarations etc.",0.09999999999999999,ALGOL
13x2iv3,jnrovs1,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,TypeScript
13x2iv3,jnrovs1,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,Elm
13wopmk,jmcva5l,"Some C and C++ programmers mistakenly believe that other programmers avoid these low level languages because they are bad programmers, but it's precisely the opposite: they understand the value of ruling out as many types of errors as possible.",0.01071428571428574,C
13wopmk,jmcva5l,"Some C and C++ programmers mistakenly believe that other programmers avoid these low level languages because they are bad programmers, but it's precisely the opposite: they understand the value of ruling out as many types of errors as possible.",0.01071428571428574,C++
13wopmk,jmcve6m,"I agree with his initial point that it’s good to pick whatever language you want to use/are good at, with some guidelines based on the situation, but I also feel like his dismissal of any criticisms of C as a language choice doesn’t make as much sense.",0.39999999999999997,C
13wopmk,jmcve6m,"Like, it’s inarguable that C has both safety and expressiveness flaws that other languages improve upon to various degrees, so while sure, use C if that’s what you feel like using, I don’t see why people suggesting you use another language that avoids some of its major flaws is a bad thing.",-0.05249999999999997,C
13wopmk,jmcve6m,You can simply just not take their advice if you really want or need to use C.,0.1,C
13wopmk,jmcolqt,"I get where the author is coming from, but I think the title should be changed to something like - why you shouldn't listen to anyone telling you not to write your compiler in C",0.0,C
13wopmk,jmdkgoj,"No, C is not hard because ""manual memory management is hard"".",-0.07291666666666667,C
13wopmk,jmdkgoj,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C
13wopmk,jmdkgoj,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C++
13wopmk,jmdkgoj,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C++
13wopmk,jmdkgoj,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C
13wopmk,jmdkgoj,Can you write stable and fast code using C?,0.2,C
13wopmk,jmdkgoj,"In the end, the important thing is that you actually write your compiler, your interpreter, your parser ...  (Disclaimer: I write C and C++ every day at work because we have no choice for our use case.",0.2,C
13wopmk,jmdkgoj,"In the end, the important thing is that you actually write your compiler, your interpreter, your parser ...  (Disclaimer: I write C and C++ every day at work because we have no choice for our use case.",0.2,C++
13wopmk,jmdkgoj,I like C++.,0.0,C++
13wopmk,jmcw959,C is **usually** a bad choice for writing a compiler.,-0.6999999999999998,C
13wopmk,jmcw959,"Of course, manual memory management, lack of features, etc are possible to make do with, and plenty of people do because they have other reasons to use C.  But it's still more difficult, more expensive, so if you're not a team of programmers working on a high speed compiler for all platforms, you absolutely should not use C. In my extremely limited experience it's quite cumbersome to write compilers and tests in C due to the lack of meaningful abstraction.",0.04896103896103896,C
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,Pascal
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,C
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,C++
13wopmk,jmcprpt,That was before Java & Python mainstream days.,0.0,Java
13wopmk,jmcprpt,That was before Java & Python mainstream days.,0.0,Python
13wopmk,jmcprpt,I could done it in Object and Class ( and Modular ) Oriented Pascal.,0.0,Pascal
13wopmk,jmcprpt,"(s) done in new P.L., several are using Functional Programming, which is not a new trend, because early Lisp developers where also using it.",0.042045454545454546,Lisp
13wopmk,jmcprpt,"I recently switched from Object Pascal to Plain C, for another hobbyist compiler project, for the simple reason that I need it to be portable/ crossplatform as possible, even if I preferred Object Oriented Pascal.",-0.05357142857142857,Pascal
13wopmk,jmcprpt,"I recently switched from Object Pascal to Plain C, for another hobbyist compiler project, for the simple reason that I need it to be portable/ crossplatform as possible, even if I preferred Object Oriented Pascal.",-0.05357142857142857,C
13wopmk,jmi8pdq,So I do think C is a fine choice for this.,0.4166666666666667,C
13wopmk,jmi8pdq,"That said, if someone is so defensive of C that they genuinely see no downside the lack of safety, I don't really understand why they'd be motivated to design a programming language in the first place and I don't think I'd be interested in anything they produced...",0.275,C
13whdk5,,"I wouldn’t use it personally because I like basic shit like python and JavaScript, but I’m interested in programming langauge design and want to hear the communities opinions (critical but be nice it’s obviously a long time passion project for the creator)",0.0857142857142857,JavaScript
13whdk5,jmbm7yr,"It is not however a new construct, it looks like the arithmetic `if` that used to be in Fortran (maybe it still is?",0.13636363636363635,Fortran
13whdk5,jmfxc4w,">it looks like the arithmetic `if` that used to be in Fortran  Yes, the `3-way if` example was inspired by the arithmetic `if` of Fortran.",0.0,Fortran
13whdk5,jmpqbyi,Seed7 was inspired by:  * The basic concepts of Pascal and Modula-2 and that they lead to a well structured compiler without complicated parsing tricks.,-0.25,Pascal
13whdk5,jmpqbyi,* How Ada tried to improve over Pascal with the negative consequence that parsing and compiling Ada is extremely complicated.,-0.4,Ada
13whdk5,jmpqbyi,* How Ada tried to improve over Pascal with the negative consequence that parsing and compiling Ada is extremely complicated.,-0.4,Pascal
13whdk5,jmpqbyi,I took the idea of exceptions from Ada and rejected its overloading concept that leads to ambiguous sub-expressions.,0.0,Ada
13whdk5,jmpqbyi,* The pragmatism of C where it is important to get things done.,0.4,C
13whdk5,jmpqbyi,You don't have C dialects like in Pascal and you have a capable standard library everywhere.,0.1,C
13whdk5,jmpqbyi,You don't have C dialects like in Pascal and you have a capable standard library everywhere.,0.1,Pascal
13whdk5,jmpqbyi,* The aim of Java to create libraries that are portable and independent from the world of C libraries.,0.0,Java
13whdk5,jmpqbyi,* The aim of Java to create libraries that are portable and independent from the world of C libraries.,0.0,C
13whdk5,jmpqbyi,: You would import a Pascal library and the rest of the program would be in Pascal.,0.0,Pascal
13whdk5,jmpqbyi,"Java did it, but these libraries require the use of the JVM.",0.0,Java
13whdk5,jmpqbyi,"There are of course many C libraries, but using them directly would expose Seed7 with all the low-level C concepts that I want to avoid.",0.3,C
13whdk5,jmpqbyi,So it was necessary to create driver libraries to interface C libraries (that might also differ between operating systems).,0.0,C
13whaja,jmbnga3,"If C3 is intended as a C replacement, then surely that would make a stronger case for it.",0.5,C
13whaja,jmbnga3,"If I didn't have my own better-than-C systems language, then yes I would use C too, for all of its problems and quirks.",0.6,C
13whaja,jmcd49j,"Later, if you wish to use C or C++, you can do use the same techniques by kind of mechanically translating the ideas in your head into idiomatic C or C++.",0.19999999999999998,C
13whaja,jmcd49j,"Later, if you wish to use C or C++, you can do use the same techniques by kind of mechanically translating the ideas in your head into idiomatic C or C++.",0.19999999999999998,C++
13whaja,jmcd49j,My issue with recommending C is how it relates to the poor way beginners go about learning compilers.,-0.4,C
13whaja,jmcd49j,"You get these people who kind of want to create a language for novelty purposes and then design a very complex system on paper and then want to implement it all in C. These people almost always end up paralysed by analysis paralysis, riddled by the pollution of the problem domain as it appears in C, and just end up yak shaving all these silly concerns - it is not unusual in amateur circles to find people yak shaving the same old lexer or parser for months!",-0.07357142857142858,C
13whaja,jmcd49j,are fond proponents of things like using garbage collection (even in C) and using languages from the ML family.,0.0,C
13whaja,jmcd49j,"It's not correct to be like ""well, Clang uses C++, therefore C++ must be ideal for hobbyist compiler implementation"".",0.9,C++
13whaja,jmdmgii,"No, C is not hard because ""manual memory management is hard"".",-0.07291666666666667,C
13whaja,jmdmgii,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C
13whaja,jmdmgii,"C and C++ (despite sometimes being the only choice, e.g.",0.0,C++
13whaja,jmdmgii,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C++
13whaja,jmdmgii,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,C
13whaja,jmdmgii,Can you write stable and fast code using C?,0.2,C
13whaja,jmdmgii,(Disclaimer: I write C and C++ every day at work because we have no choice for our use case.,0.0,C
13whaja,jmdmgii,(Disclaimer: I write C and C++ every day at work because we have no choice for our use case.,0.0,C++
13whaja,jmdmgii,I like C++.,0.0,C++
13whaja,jmbljy0,"> The C3 compiler is written in C, and there is frankly no other language I could have picked that would have been a substantially better choice.",0.28125,C
13whaja,jmbljy0,"The vast majority of the heavy lifting is done by LLVM and, yet, this project is still over 65kLOC of C code.",-0.1,C
13whaja,jmbljy0,A hand-rolled parser (no lex/yacc) including 222 lines of C code to parse an int.,0.0,C
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Haskell
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Swift
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Rust
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,Scala
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,C
13whaja,jmbljy0,"Even if I was forced to use C I'd at least use `flex`, `bison` and as many libraries as I can get for all the tedious string manipulation and conversion.",-0.15000000000000002,C
13whaja,jmcoxgl,"I get where the author is coming from, but I think the title should be changed to something like - why you shouldn't listen to anyone telling you not to write your compiler in C..",0.0,C
13whaja,jmbfxoj,"> And doing an OO-style C++, or worse, Java, would just have pushed the compiler to slower and more bloated, with no additional benefits ...",0.04999999999999999,C++
13whaja,jmbfxoj,"> And doing an OO-style C++, or worse, Java, would just have pushed the compiler to slower and more bloated, with no additional benefits ...",0.04999999999999999,Java
13whaja,jmbfxoj,"I agree with Java (because of all dynamic allocation overhead and JVM dependency), but C++ is very well suited for compiler implementation (neither slower nor bloated, but easier to maintain) when moderately and judiciously used.",0.06666666666666667,Java
13whaja,jmbfxoj,"I agree with Java (because of all dynamic allocation overhead and JVM dependency), but C++ is very well suited for compiler implementation (neither slower nor bloated, but easier to maintain) when moderately and judiciously used.",0.06666666666666667,C++
13whaja,jmbfxoj,"I used both - C and C++ - to write compilers; both work well for the purpuse, but the latter makes a lot of things easier.",0.0,C
13whaja,jmbfxoj,"I used both - C and C++ - to write compilers; both work well for the purpuse, but the latter makes a lot of things easier.",0.0,C++
13whaja,jmbfxoj,"EDIT: just had a look at the C3 language; looks interesting, a bit like Oberon+ with a C syntax ;-) Nice to see that generic modules are considered useful by more language designers.",0.3583333333333334,C
13whaja,jmbfxoj,The LLVM backend looks a bit like a kludge; why not just a C cross-compiler?,0.0,C
13whaja,jmbnorn,"If there is a case where “use C to implement your language” is good advice, it’s probably limited to people who are writing languages that are similar to C.  “You can do anything in C if you’re good enough” is not an argument I usually expect from people who are investing effort into creating new languages.",0.1735621521335807,C
13whaja,jmbq5kh,">  > If C3 is intended as a C replacement, then surely that would make a stronger case for it.",0.5,C
13whaja,jmcfd0q,"What I **don't** like is when someone comes in and says *""I want to write a compiler and I'm thinking of doing it in C""* and then someone just vomits their opinions all over the whole discussion claiming it's impossible to write compilers in C, and how if you don't have feature X (usually pattern matching and sum types are listed as the magical components needed) it's impossible to write a compiler.",-0.17666666666666664,C
13whaja,jmcfd0q,"That said, I know a lot of people trying out in particular *Rust* as a language to implement languages in because everyone is recommending it.",0.16666666666666666,Rust
13whaja,jmcfd0q,And then they try to learn Rust and implement a compiler at the same time.,0.0,Rust
13whaja,jmcfd0q,"In the case of C, there is a very gentle introduction to creating a compiler in C with Crafting Interpreters.",0.26,C
13whaja,jmcfd0q,Following that makes C a breeze to use.,0.0,C
13whaja,jmcfd0q,"Maybe if someone had written something similar in Rust then learning compilers and learning Rust at the same time would be more successful for people, but we're not there yet.",0.3125,Rust
13whaja,jmcfd0q,So for that you'd stay away from C and so on.,0.0,C
13whaja,jmmptt3,"I personally do think that C is better them what you might think, given that a compiler is actually not heavyly involved in string processing.",0.16666666666666666,C
13whaja,jmmptt3,"The biggest issue with C IMO is that you have no structural matching and ADTs and have to emulate these features on a near constant base, since transfering ADTs is indeed a core part of a compiler.",-0.23333333333333336,C
13whaja,jmc51bt,>A hand-rolled parser (no lex/yacc) including 222 lines of C code to parse an int.,0.0,C
13whaja,jmc51bt,"I can save 20 lines on mine by using C's `strtod` to turn text into a float, once it has been isolated and freed of separators etc.",0.0,C
13whaja,jmbrra5,SURELY that is just some bad requirement by C?,-0.09999999999999992,C
13whaja,jmbrra5,"C surely doesn't have a `DEFAULT` statement, right?",0.39285714285714285,C
13whaja,jmbsqrw,"I worked with lowering to C, and while it has advantages, it also gives you less control and more need for additional installs.",0.16666666666666669,C
13whaja,jmcch93,> C++ is very well suited for compiler implementation  Tree rewriting is tedious in C++ due to the lack of sum types and pattern matching.,-0.14166666666666666,C++
13whaja,jmbg2f8,"Yes, I agree and that's why I qualified it, writing ""OO-style C++"" and not ""C++""",0.0,C++
13whaja,jmbpmdz,"> If there is a case where “use C to implement your language” is good advice, it’s probably limited to people who are writing languages that are similar to C.  That doesn't follow.",0.20952380952380953,C
13whaja,jmbpmdz,Only really esoteric languages like BF offer comparably-complicated implementations in C and other languages.,0.025000000000000005,C
13whaja,jmcilgc,"It cannot be argued that it's the most productive to go about certain parts of compilers in C. If we look at a screenshot from Andrew Appel's book ""Modern Compiler Implementation in C"":  [https://i.imgur.com/zEFlfIy.png](https://i.imgur.com/zEFlfIy.png)  You can see that it's basically matching over the structure of a tagged union encoding of the IR trees (as part of how to do tree tiling instruction selection), right.",0.09000000000000001,C
13whaja,jmcilgc,"Although, it can just be written directly in OCaml, Standard ML, Haskell, Scala, etc.",0.05,Haskell
13whaja,jmcilgc,"Although, it can just be written directly in OCaml, Standard ML, Haskell, Scala, etc.",0.05,Scala
13whaja,jmcilgc,"So, as much as I agree that it's possible, it's by no means the most illuminating, productive, or maintainable approach to take (using C).",0.2333333333333333,C
13whaja,jmcilgc,"I usually don't actively dissuade people already using C, but it is painful to avoid the classic ""in OCaml, this is just..."" replies.",-0.2222222222222222,C
13whaja,jmumjz3,"_Note: the C and C++ compilation models are a bit ""odd"", since each file leads to a separate process invocation.",-0.16666666666666666,C
13whaja,jmumjz3,"_Note: the C and C++ compilation models are a bit ""odd"", since each file leads to a separate process invocation.",-0.16666666666666666,C++
13whaja,jmc7y14,"> I can save 20 lines on mine by using C's strtod to turn text into a float, once it has been isolated and freed of separators etc.",0.0,C
13whaja,jmc7y14,There must be C libraries that already do almost all of this for you.,0.0,C
13whaja,jmc7y14,Maybe if you want to support some exotic number representation you'll need to write an extra line of code but writing 222 lines of code and then concluding that C rules is lunacy.,0.25,C
13whaja,jmc9tl5,"As soon as you step outside the features of C, LLVM is flakey, e.g.",0.0,C
13whaja,jmcb66r,Even if I was writing that in C I'd use `flex` and a string conversion library.,0.0,C
13whaja,jmcb66r,SURELY that is just some bad requirement by C?,-0.09999999999999992,C
13whaja,jmcb66r,"C surely doesn't have a DEFAULT statement, right?",0.39285714285714285,C
13whaja,jmcb66r,Hence your argument that C is blub doesn't hold water.,0.0,C
13whaja,jmbv6wy,C has had a default statement since K&R.,0.0,C
13whaja,jmbv6wy,C has had a default statement since K&R.,0.0,R
13whaja,jmcya2a,"> Tree rewriting is tedious in C++  What language would you then recommend for this purpose, and can you reference an example which demonstrates the specific advantage compared to C++?",-0.25,C++
13whaja,jmbg99g,Even OO-style C++ is ok when judiciously used; e.g.,0.5,C++
13whaja,jmcnuvz,Someone who really wants a “better C” is unlikely to enjoy writing their compiler in Haskell and someone who wants dependent types is unlikely to enjoy writing it in C. This is a coarse generalization of course.,0.08750000000000001,C
13whaja,jmcnuvz,Someone who really wants a “better C” is unlikely to enjoy writing their compiler in Haskell and someone who wants dependent types is unlikely to enjoy writing it in C. This is a coarse generalization of course.,0.08750000000000001,Haskell
13whaja,jmcoekc,"I don't know if the code in ""Modern Compiler Implementation in C"" is a good argument against C, given that it supposedly had all C auto-translated from the original ML sources or some such.",0.31875,C
13whaja,jmdv5z9,"When I once attempted a C compiler from scratch, I spent around 90 days, for an indifferent result that could nevertheless turn some C source programs into runnable binaries for x64.",-0.1,C
13whaja,jmdv5z9,"(I was able to build and run Lua, Seed7 and SQLite3 - nearly half a million lines - with varying success.)",0.2111111111111111,Lua
13whaja,jmdv5z9,Including 1.5 to 3 days to write a full C preprocessor.,0.35,C
13whaja,jmdv5z9,"My actual C compiler is a 100% self-contained 1MB executable, and compiles C code at about half the speed of Tiny C.",-0.05555555555555555,C
13whaja,jmccp0x,"LLVM IR is more of an assembly language for a generic machine, while C is a portable language abstracting PDP-like machines.",0.25,C
13whaja,jmccp0x,"Rust targets LLVM IR as well, does it make LLVM IR a Rust-like language?",0.0,Rust
13whaja,jmccp0x,"You can do oneliners in Haskell that are unreadable but would take 10 lines of human readable C.  If I need Haskell's features, I'll choose Haskell.",0.0,Haskell
13whaja,jmccp0x,"If I need C's features, I'll choose C. LOC is not a feature.",0.0,C
13whaja,jmcd0mw,>Even if I was writing that in C I'd use flex and a string conversion library.,0.0,C
13whaja,jmbws6m,"With additional installs I mean that if one lowers to C, a C compiler needs to be installed for the platform, and on several platforms that means a lot of downloads.",-0.15625,C
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Haskell
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Rust
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Swift
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Scala
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,Kotlin
13whaja,jmd2lz0,Scheme and Lisp have good libraries to help with this.,0.7,Scheme
13whaja,jmd2lz0,Scheme and Lisp have good libraries to help with this.,0.7,Lisp
13whaja,jmd2lz0,> and can you reference an example which demonstrates the specific advantage compared to C++?,0.0,C++
13whaja,jmcql6k,"The C wasn't auto translated, not that part of the book anyway.",0.0,C
13whaja,jmcql6k,"Most people dissuading people from C aren't saying it's impossible, they just don't want them to spend so long doing it (I'm sure you have your own articles where you've pondered C3's design for over a decade).",0.17666666666666667,C
13whaja,jme6tp4,"However, few are written in C.  The nearest I can think of is something like a [C parser written in OCaml](https://github.com/jhjourdan/C11parser) or the static analyzer [Frama-C](https://frama-c.com/).",0.15,C
13whaja,jme6tp4,"Even if there were, who is to say that two C compilers are comparable?",0.0,C
13whaja,jme6tp4,OCaml vs C for a decent sized program should be comparable.,0.16666666666666666,C
13whaja,jme6tp4,C is likely to be much slower in a first cut but has the potential to be ~3x faster than OCaml if you devote enough time to optimising it.,0.09,C
13whaja,jme6tp4,"> When I once attempted a C compiler from scratch, I spent around 90 days, for an indifferent result that could nevertheless turn some C source programs into runnable binaries for x64.",-0.1,C
13whaja,jme6tp4,"(I was able to build and run Lua, Seed7 and SQLite3 - nearly half a million lines - with varying success.)",0.2111111111111111,Lua
13whaja,jme6tp4,That's incredible and a great target but I don't know of anyone writing C compilers in OCaml.,0.8500000000000001,C
13whaja,jme6tp4,"Rust was originally written in OCaml but I don't know of anyone rewriting it in C.  > Applying that factor, I would have been able to do that in 5-10 days?",0.4375,Rust
13whaja,jme6tp4,Including 1.5 to 3 days to write a full C preprocessor.,0.35,C
13whaja,jme6tp4,If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,C
13whaja,jme6tp4,Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,C
13whaja,jme6tp4,"> My actual C compiler is a 100% self-contained 1MB executable, and compiles C code at about half the speed of Tiny C.  That's awesome but surely when you look at your compiler you see lots of repeating patterns in the code?",0.2666666666666667,C
13whaja,jmcf8ra,"> LLVM IR is more of an assembly language for a generic machine,  Let's look at the features:  * Functions (C and LLVM IR but not asm).",0.25,C
13whaja,jmcf8ra,* Arguments (C and LLVM IR but not asm).,0.0,C
13whaja,jmcf8ra,* Return value (C and LLVM IR but not asm).,0.0,C
13whaja,jmcf8ra,* Structs (C and LLVM IR but not asm).,0.0,C
13whaja,jmcf8ra,* Only fixed-width registers (asm but neither C nor LLVM IR).,0.0,C
13whaja,jmcf8ra,* Arbitrary jumps (asm but neither C nor LLVM IR).,-0.1,C
13whaja,jmcf8ra,* Raw stack (asm but neither C nor LLVM IR).,-0.23076923076923078,C
13whaja,jmcf8ra,LLVM IR is just a parsed and sanitised C with some additions like extra calling conventions and optional TCO.,0.0,C
13whaja,jmcf8ra,"You can do oneliners in Haskell that are unreadable but would take 10 lines of human readable C. >  > If I need Haskell's features, I'll choose Haskell.",0.0,Haskell
13whaja,jmcf8ra,"If I need C's features, I'll choose C. LOC is not a feature.",0.0,C
13whaja,jmbxul2,> a C compiler needs to be installed for the platform  Not sure whether this is a valid point; never came across a platform where there wasn't a standard C compiler easily available; even C++98 is virtually available everywhere with little effort; after all that's the main reason why e.g.,0.08819444444444445,C
13whaja,jmbxul2,I am using C or C++ for my compilers.,0.0,C
13whaja,jmbxul2,I am using C or C++ for my compilers.,0.0,C++
13whaja,jmd2jk3,"Products and sum types are ADTs, and C++ have both.",0.0,C++
13whaja,jmd2jk3,"- `std::variant` is the equivalent to Rust enums  - `std::optional` is the Maybe monad  - `std::expected` is the Either monad  By your logic, Rust enums and the Maybe/Either monads are the poor man's sum types.",-0.4,Rust
13whaja,jmd2jk3,"In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Rust
13whaja,jmd2jk3,"In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Haskell
13whaja,jmd2jk3,"`std::holds_alternative` and `std::get` are the equivalent of Rust's `if let` expressions, which are a form of pattern matching.",0.0,Rust
13whaja,jmbueco,"Well, LLVM is not exactly an example of ""moderate"" C++, is it?",-0.0625,C++
13whaja,jme6p3q,"But I mind people saying ""It's impossible to write a compiler in C, there isn't a worse choice, you need to have sum types and pattern matching to write a compiler"".",-0.5333333333333333,C
13whaja,jmeeo3v,>If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,C
13whaja,jmeeo3v,"You could just use an existing C compiler, it would be even quicker!",0.0,C
13whaja,jmeeo3v,>Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,C
13whaja,jmeeo3v,I could write a long article on what makes C hard to compile.,-0.17083333333333334,C
13whaja,jmeeo3v,"Plus, and this is the bit that takes man-years, is ensuring it will work for the billions of lines of existing C code.",0.0,C
13whaja,jmeeo3v,(So much for C being portable!),0.25,C
13whaja,jmcgjxq,LLVM doesn't implement the C ABI aside from placing things in the right registers.,0.2857142857142857,C
13whaja,jmcgjxq,LLVM has no concept of unions (which makes implementing some parts of C very very gnarly) 3.,0.26,C
13whaja,jmcgjxq,"Saying ""LLVM IR is like C"" is frankly a clown.",0.0,C
13whaja,jmeearg,Like Rust and Swift that both clock in at about 50% of the time spent in the frontend.,-0.1,Rust
13whaja,jmeearg,Like Rust and Swift that both clock in at about 50% of the time spent in the frontend.,-0.1,Swift
13whaja,jmbz03i,\> Not sure whether this is a valid point; never came across a platform where there wasn't a standard C compiler easily available  Windows requires downloading MSVC or doing things through Mingw which is a problem in itself.,0.05000000000000001,C
13whaja,jmd5fwy,"Can you speak to the ergonomics of C++ features such as using `std::variant` for full encoding of ASTs, type representations, etc.",0.175,C++
13whaja,jmd5fwy,"Tells me a lot that your language is written in Rust and not C++, in spite of the fact you've noted C++ does have pretty poor versions of all of the things mentioned.",-0.07500000000000001,Rust
13whaja,jmd5fwy,"Tells me a lot that your language is written in Rust and not C++, in spite of the fact you've noted C++ does have pretty poor versions of all of the things mentioned.",-0.07500000000000001,C++
13whaja,jmd7b13,"> Products and sum types are ADTs, and C++ have both.",0.0,C++
13whaja,jmd7b13,> std::variant is the equivalent to Rust enums > std::optional is the Maybe monad > std::expected is the Either monad  In a loose sense.,-0.07692307692307693,Rust
13whaja,jmd7b13,"> By your logic, Rust enums and the Maybe/Either monads are the poor man's sum types.",-0.4,Rust
13whaja,jmd7b13,"This is getting off topic but, FWIW, the issue with Rust in this context is the inability to pattern match through an `Rc`.",0.0,Rust
13whaja,jmd7b13,"> In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Rust
13whaja,jmd7b13,"> In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,Haskell
13whaja,jmd7b13,Both Rust and Haskell have actual sum types and pattern matching with few limitations.,-0.1,Rust
13whaja,jmd7b13,Both Rust and Haskell have actual sum types and pattern matching with few limitations.,-0.1,Haskell
13whaja,jmd7b13,"> std::holds_alternative and std::get are the equivalent of Rust's if let expressions, which are a form of pattern matching.",0.0,Rust
13whaja,jmd7b13,"Here's a little OCaml function to locally rebalance a red-black tree:      let balance = function       | `Black, z, `Node(`Red, y, `Node(`Red, x, a, b), c), d       | `Black, z, `Node(`Red, x, a, `Node(`Red, y, b, c)), d       | `Black, x, a, `Node(`Red, z, `Node(`Red, y, b, c), d)       | `Black, x, a, `Node(`Red, y, b, `Node(`Red, z, c, d)) ->           `Node(`Red, y, `Node(`Black, x, a, b), `Node(`Black, z, c, d))       | a, b, c, d -> `Node(a, b, c, d)  Please can you translate those 7 lines of sum types and pattern matches into C++ using `std::variant` and `std::visit`?",-0.14236111111111108,C++
13whaja,jmd7b13,That would be great but I've been hearing that C++ is about to get these features for 20 years now...,0.8,C++
13whaja,jmbvwbz,"It's an example of ""by the book"" C++ OO.",0.0,C++
13whaja,jmew4hr,I've done a few in C (I think you saw my 99-line JIT).,-0.2,C
13whaja,jmew4hr,> > If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,C
13whaja,jmew4hr,"You could just use an existing C compiler, it would be even quicker!",0.0,C
13whaja,jmew4hr,>  > > Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,C
13whaja,jmew4hr,>  > I could write a long article on what makes C hard to compile.,-0.17083333333333334,C
13whaja,jmew4hr,"Plus, and this is the bit that takes man-years, is ensuring it will work for the billions of lines of existing C code.",0.0,C
13whaja,jmew4hr,(So much for C being portable!),0.25,C
13whaja,jmew4hr,I suppose C is a different kettle of fish.,0.0,C
13whaja,jmcyi2k,In C functions accept many values but can return only one value.,0.25,C
13whaja,jmcyi2k,"> Even so, many features you listed are available in many programming and assembly languages that are nothing like C.  You didn't say ""programming languages unlike C"".",0.4666666666666666,C
13whaja,jmcyi2k,Functions and structs alone put LLVM IR much closer to C than any asm.,0.2,C
13whaja,jmcx4xl,> LLVM doesn't implement the C ABI aside from placing things in the right registers.,0.2857142857142857,C
13whaja,jmcx4xl,"> LLVM has no concept of unions (which makes implementing some parts of C very very gnarly)  Well, ok. You bitcast between structs to emulate unions.",0.38,C
13whaja,jmcx4xl,My point is that they're C style not tagged or discriminated unions like sum types in most modern languages.,0.35,C
13whaja,jmcx4xl,> LLVM IR is in SSA form  True but neither C nor asm are SSA.,0.35,C
13whaja,jmcx4xl,> LLVM IR is built around basic blocks  Ok but how is that more like asm and less like C?,0.20833333333333334,C
13whaja,jmcx4xl,C has block statements.,0.0,C
13whaja,jmcx4xl,In C and LLVM they cannot.,0.0,C
13whaja,jmd7bh7,"My language (letlang) is written in Rust because of the ecosystem: logos, rust-peg, etc...  Not because of the language's syntax and features.",0.0,Rust
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,Haskell
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,C++
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,Erlang
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,Elixir
13whaja,jmd7bh7,"The first draft of my language was done in Python, prior to the \`match\` statement.",0.125,Python
13whaja,jmd7bh7,"My choice of Rust is not based on the syntax/features of the language, therefore it does not invalidate my argument.",0.0,Rust
13whaja,jmczytr,"Not by your ridiculous standards, still that's what they are, and that's what C functions are usually translated to (if not inlined).",-0.29166666666666663,C
13whaja,jmczytr,"> You didn't say ""programming languages unlike C""  ""programming and assembly"", at least quote me correctly.",-0.3,C
13whaja,jmczytr,> Functions and structs alone put LLVM IR much closer to C than any asm  [HighLevel ASM records](https://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLARef/HLARef_html/HLAReference.htm#pgfId-1003858) disagree with you.,0.2,C
13whaja,jmdv5ng,"CCC does not implement the C ABI, It just packs things in the right registers.",0.2857142857142857,C
13whaja,jmdv5ng,My point is that they're C style  Being able to bitcast between types is not doing C unions.,0.5,C
13whaja,jmdv5ng,"Oh, so you think this is equivalent to C scopes?",0.0,C
13whaja,jmdv5ng,"> Ok but how is that more like asm and less like C  You're the one suggesting that the transformation C -> LLVM IR was a trivial one, not me.",0.2777777777777778,C
13whaja,jmdv5ng,In C and LLVM they cannot.,0.0,C
13whaja,jmd9xsy,"Yet, in response, they get replies that sometimes imply it's not tedious (""but.. but.. C++ has a shit version of this"").",0.024999999999999994,C++
13whaja,jmca4n1,"Nor is it my favourite, but hopefully this explains why I was saying ""OO C++"" is a bad idea with this definition of ""OO C++""",-0.6999999999999998,C++
13whaja,jmdb8zw,"Not by your ridiculous standards, still that's what they are, and that's what C functions are usually translated to (if not inlined).",-0.29166666666666663,C
13whaja,jmdb8zw,"The fact that C functions are usually translated to labels, calls and returns does not mean labels, calls and returns are functions.",-0.046875,C
13whaja,jme1zwh,">  > CCC does not implement the C ABI, It just packs things in the right registers.",0.2857142857142857,C
13whaja,jme1zwh,">  > Oh, so you think this is equivalent to C scopes?",0.0,C
13whaja,jme1zwh,"> > > LLVM IR is built around basic blocks > > > > Ok but how is that more like asm and less like C >  > You're the one suggesting that the transformation C -> LLVM IR was a trivial one, not me.",0.20833333333333334,C
13whaja,jme1zwh,In C and LLVM they cannot.,0.0,C
13whaja,jme7wzp,"The problem is when someone asks ""how do I solve this problem in my compiler written in C?""",0.0,C
13whaja,jme7wzp,"and the answer is ""You can't write a compiler in C, you should use Rust or Ocaml!""",0.0,C
13whaja,jme7wzp,"and the answer is ""You can't write a compiler in C, you should use Rust or Ocaml!""",0.0,Rust
13whaja,jme3z49,When I said that LLVM doesn't have scopes I am referring to C nestable scopes.,0.0,C
13w4l1z,,My goal is to have enough knowledge to try building a compiler for a simple functional programming language (something similar to Haskell or Ocaml I gusss?),0.0,Haskell
13w4l1z,jm9we7j,"Boom, now you have most of Scheme.",0.5,Scheme
13w4l1z,jmf2kht,"Go back and read about System F, universal/existential types, and higher-order polymorphism.",0.0,Go
13w4l1z,jmf2kht,"Note that implementing something like Haskell or OCaml would require learning about modules/typeclasses, but at that point you'll have enough knowledge to find those resources yourself.",0.0,Haskell
13w4l1z,jmami22,"Elixir and Rust also have hygienic macros, if I’m not mistaken.",0.0,Elixir
13w4l1z,jmami22,"Elixir and Rust also have hygienic macros, if I’m not mistaken.",0.0,Rust
13w4l1z,jmf2d6q,"They're significantly better than C's preprocessor macros, but they are not quite as robust as Racket's.",0.5,C
13w4l1z,jmf2d6q,"(A few searches indicate that Rust's macros are not hygienic over things like type parameters or something, and Elixir's fall short because their hygiene is rooted in a late resolution system.",-0.16666666666666666,Rust
13w4l1z,jmf2d6q,"(A few searches indicate that Rust's macros are not hygienic over things like type parameters or something, and Elixir's fall short because their hygiene is rooted in a late resolution system.",-0.16666666666666666,Elixir
13w3cw3,jmd8op6,"I recommend being familiar with both and the relevant literature prior to these papers you've linked: see TIL and David Tarditi's PhD thesis, see Compiling with Continuations, look at MLton's IRs, look at Haskell's Core language, etc.",0.25833333333333336,Haskell
13w2oya,jmax0da,"C is faster in terms of execution time, not development time.",0.0,C
13w2oya,jmax0da,"No one has ever said ""I'll develop this in C because it will take me half the time"".",-0.16666666666666666,C
13w2oya,jmax0da,"If anything C should be a good example of this, where you choose a programming language that's less productive in order to benefit in terms of performance once the project is complete.",0.2111111111111111,C
13w2oya,jmb35jf,"From a language perspective Java is lacking, there is no doubt.",0.0,Java
13w2oya,jmb35jf,"When I see seasoned Java developers move to Kotlin which also makes it very easy, I still observe old patterns being followed: mutable state and huge objects.",0.32833333333333337,Java
13w2oya,jmb35jf,"When I see seasoned Java developers move to Kotlin which also makes it very easy, I still observe old patterns being followed: mutable state and huge objects.",0.32833333333333337,Kotlin
13w2oya,jmb35jf,Whereas the Scala code bases I have seen are much better.,0.5,Scala
13vxdez,jm8h03p,I have been working on something with similar goals (also in Haskell!,0.0,Haskell
13vsbrh,,"The APL language has multidimensional arrays as a first-class data type, but up to now only vectors (lists) can be written literally in code.",0.0,APL
13vsbrh,,Dyalog is considering adding a general notation for arrays to APL.,0.05000000000000002,APL
13vsbrh,jm9v35o,"I am not a habitual APL user, but I was under the impression you could lay out your code pretty much how you liked, and there was a reshape operator for vectors.",0.35000000000000003,APL
13vsbrh,jmbiiyz,APL distinguishes between lists of lists and N-dimensional arrays.,0.0,APL
13vsbrh,jmbiiyz,"You could always use reshape \`⍺⍴⍵\` to create N-dimensional arrays in APL, but now your source code can visually reflect the structure:      [ 'abc' 'def'       (1 2) (3 4) ]  The above example is APLAN syntax equivalent to the APL expression:  `2 2⍴'abc' 'def' (1 2) (3 4)`  Lastly, the diamond here is not an operator in that it doesn't accept arguments and return results - but rather it is *syntax* for constructing higher dimensional arrays and namespaces.",-0.1,APL
13vsbrh,jmbiiyz,"In the same way you're unlikely to call the parentheses and commas in an ALGOL-style function call `myFunction(param1,param2)` ""operators"", we wouldn't call APL Array Notation ""functions"" in APL.",-0.25,APL
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,PHP
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,C++
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,Rust
13vozxh,jm7888e,This is what Rust works hard to prevent.,-0.2916666666666667,Rust
13vozxh,jm8l40j,"Java is infamous for failing badly here, even within its chosen paradigm.",-0.5999999999999999,Java
13vozxh,jm9cj7q,In my current project we are working with Kotlin and make heavy use of [data classes](https://kotlinlang.org/docs/data-classes.html) which is essentially the same thing.,-0.05,Kotlin
13vozxh,jmcp0lm,"Pony, an actor language, uses what it calls [reference capabilities](https://tutorial.ponylang.io/reference-capabilities/index.html) to govern data sharing: Immutable data can be freely shared between actors, isolated data (like C++'s unique\_ptr) can be passed from one actor to another by giving up ownership, and regular data can do whatever except being passed to another actor.",0.2,C++
13vozxh,jm77cu5,"If I understand the PHP case correctly, there will be no mutable version of a class if you declare the class `readonly`.",0.0,PHP
13vozxh,jm77cu5,"The C++ analogy would be a class with every member (and member function) being `const`, I guess.",0.0,C++
13vozxh,jm7uvxy,"Rust's references are closest to Affine types, because there is a requirement to use them at most once (borrowing aside), but there is no hard requirement that they must be used, as with a linear type system.",0.3229166666666667,Rust
13vozxh,jm7uvxy,Rust does allow violating any uniqueness guarantees due to unsafe code.,-0.125,Rust
13vozxh,jm7uvxy,[Austral](https://borretti.me/article/introducing-austral#linear) attempts to have Rust style borrowing with the additional linearity constraint.,0.0,Rust
13vozxh,jo9f4l0,The person you're replying to is using `struct` and `class` in ways that are consistent with the Swift programming language.,0.25,Swift
13vozxh,jo9f4l0,"In Swift, classes are reference types that are similar to heap-allocated objects in other popular languages (except that Swift uses reference counting for garbage collecting rather than a tracing garbage collector), whereas structs are value types, such that even when you mutate a struct-holding variable, it behaves as though you're re-assigning that variable with a new copy of the value.",0.12227272727272727,Swift
13vozxh,jmiyr89,"In Java, arrays are mutable so you have to be careful about sharing them.",-0.1,Java
13vozxh,jmiyr89,``` byte[] bytes = new byte[10]; // fill bytes f(bytes); // f might hold onto a reference to bytes ```  But there's no way for a Java program to modify a zero length array so it can be safely shared.,0.3181818181818182,Java
13vozxh,jmiyr89,But Java's type system does not allow specifying the array length as part of the array type.,0.0,Java
13vozxh,jmiyr89,"So in Java, you can't distinguish, without first adding to the type system, between an array that is safe to share and one that is not.",0.375,Java
13vozxh,jma5ab9,"I've looked at Clean, Pony and Rust but only done much with Rust.",0.18888888888888888,Rust
13vozxh,jma5ab9,I don't fully understand what the type system of Clean or Pony offer that's practically different than that of Rust which seems more limited but enough.,0.15904761904761905,Rust
13vozxh,jma5ab9,One thing that I imagine Pony can handle better than Rust is for cyclic data.,0.5,Rust
13vozxh,jma5ab9,"I found [A Comparison of the Capability Systems of Encore, Pony and Rust (pdf)](https://uu.diva-portal.org/smash/get/diva2:1363822/FULLTEXT01.pdf) that summaries them in the introduction as:  > The conclusion is that Rust has an advantage in its capability system compared to the other two, but because the languages have very different strengths and weaknesses it depends on the programmer's personal preference of which is the best one for her or him.",0.275,Rust
13vozxh,jmizp83,Java is arguably an interpreted language until it's JITed so maybe my example is relevant.,0.4,Java
13vozxh,jmizp83,"Fyi, Java's specified semantics require that any use of the `new` operator that completes normally completes with a reference with an identity different from any previously available reference: `new byte[0] != new byte[0]`.",0.16553030303030303,Java
13vozxh,jmcw26w,"Haskell originally had a main function `IO a -> IO b`, where you would have to pass and return the IO reference around for anything that was effectful, until monads and typeclasses were added.",0.2708333333333333,Haskell
13vozxh,jmcw26w,"The Axum language was C#-like, and could interact with a variant of C# which had `static` (aka global) removed and replaced with an `isolated` keyword, which would be more like a static thread local.",0.3,C
13vozxh,jmcw26w,"I think the idea in both of these languages is to make actor based systems more accessible to non purely functional programmers, but get many of the benefits of languages like Erlang.",0.39732142857142855,Erlang
13vozxh,jmcw26w,Rust's design is clearly descended from C++'s move semantics and `unique_ptr`.,0.10000000000000002,Rust
13vozxh,jmcw26w,Rust's design is clearly descended from C++'s move semantics and `unique_ptr`.,0.10000000000000002,C++
13vozxh,jmcw26w,These were a bit of a trade-off because they were designed to keep backward-compatibility in mind with older versions of C++.,0.16666666666666666,C++
13vozxh,jmcw26w,"Rust fixed this by enforcing no use-after-move at compile time, and the rest of the language was then designed around that model.",0.1,Rust
13vozxh,jmjuag8,"Yeah, Java's abnormal in any number of ways.",0.0,Java
13vozxh,jmjuag8,But Java arrays are mutable and it is only the sheerest coincidence that they also have fixed size at allocation time.,0.05,Java
13vozxh,jmjuag8,"Given the business strategy around Java, it all makes sense.",0.0,Java
13vozxh,jmnod8e,The JVMs `native` mechanism to connect Java methods to (mostly) C code and the JVM embedding ABI both assume that Java arrays do not change size and may not be `realloc`ed or reduce in size when native code calls back into Java code.,0.25,Java
13vozxh,jmnod8e,The JVMs `native` mechanism to connect Java methods to (mostly) C code and the JVM embedding ABI both assume that Java arrays do not change size and may not be `realloc`ed or reduce in size when native code calls back into Java code.,0.25,C
13vozxh,jmnod8e,My understanding is that not having a type that maps straightforwardly to C arrays would complicate a lot of that supporting C code.,0.3125,C
13vozxh,jmq7xgo,I was infatuated with Haskell for a while but came to the realization that the world is inherently dynamic and trying to shoehorn everything into static types just means adding more and more layers of abstraction.,0.26,Haskell
13vozxh,jmq7xgo,"In this case though, I'm using it as a transpiler to C, because I want low level access to the processor and memory for performance reasons.",0.0,C
13vozxh,jmskyat,When I first looked at OCaml I think it didn't handle parallel threads and F#/.Net is more likely to be accepted into the mainstream even with its C#/CLR interop baggage.,0.1875,C
13vozxh,jmstxe2,"The JVM ecosystem and languages like Scala are obviously much simpler on android, but not much help on iOS.",0.05,Scala
13vozxh,jmstxe2,"For most things, the syntax is more terse than C#, and it has better defaults.",0.5,C
13v7xul,jm50ake,"Like C# Roslyn Analyzers, or the Roc IDE.",0.0,C
13v7xul,jmqqx5k,For example you typically write a comment `/** */` over a method name in C++ or Java.,-0.16666666666666666,C++
13v7xul,jmqqx5k,For example you typically write a comment `/** */` over a method name in C++ or Java.,-0.16666666666666666,Java
13v7xul,jmqqx5k,"(In Python it's `"""""" """"""`.)",0.0,Python
13v7xul,jmqqx5k,You can also declare a method in Java and have it throw an `UnsupportedOperationException`.,0.0,Java
13v7xul,jmqqx5k,"As opposed to that, in Scala, you can have it return `???`.",0.0,Scala
13usqwq,,"I first noticed it in Rust that the language designers are very comfortable with just declaring ""X is UB"" (undefined behaviour) instead of providing sensible behaviour for edge-cases.",0.385,Rust
13usqwq,,"Currently, I'm refreshing my knowledge of C and found that newer C standards introduced UB where previously it was up to the implementation to define behaviour.",0.16666666666666669,C
13usqwq,jm2a34t,"(I'm talking about C, I'm not really familiar with how Rust does or uses UB.)",-0.1875,C
13usqwq,jm2a34t,"(I'm talking about C, I'm not really familiar with how Rust does or uses UB.)",-0.1875,Rust
13usqwq,jm2cf6s,Iirc especially early C standards left lot of behavior implicitly undefined which I suspect was recognized as problematic.,0.1,C
13usqwq,jm2cf6s,Especially for C standard they also have to take into account existing implementations; while the standard is written in prescriptive tone in actuality it is more just descriptive.,0.125,C
13usqwq,jm27jei,"I may be wrong but I feel like it's more a matter of being the case that once you define a behaviour you can't undefine it, and I know Rust in particular is extremely careful (for backward compatability reasons) about what behaviour it declares as stable.",0.016666666666666663,Rust
13usqwq,jm29sjw,"In Rust, this is trivial.",0.0,Rust
13usqwq,jm29sjw,"I'd never heard of the ""zero sized allocations are UB"" thing before, because it's not something Rust programmers ever have to worry about, unlike in C.",0.0,Rust
13usqwq,jm29sjw,"I'd never heard of the ""zero sized allocations are UB"" thing before, because it's not something Rust programmers ever have to worry about, unlike in C.",0.0,C
13usqwq,jm343lg,"> I first noticed it in Rust that the language designers are very comfortable with just declaring ""X is UB"" (undefined behaviour) instead of providing sensible behaviour for edge-cases.",0.385,Rust
13usqwq,jm343lg,"Rust has two ""modes"": safe and unsafe.",0.5,Rust
13usqwq,jmab5lx,"In the current UB arms race between C and C++ compilers, what programmers *think* UB means is ""whatever the CPU does is what should happen"", but the way that the language-lawyering compiler developers interpret it is ""the compiler is allowed to assume that UB never happens"".",0.0,C
13usqwq,jmab5lx,"In the current UB arms race between C and C++ compilers, what programmers *think* UB means is ""whatever the CPU does is what should happen"", but the way that the language-lawyering compiler developers interpret it is ""the compiler is allowed to assume that UB never happens"".",0.0,C++
13usqwq,jmab5lx,This is part of the semantics of C++.,0.0,C++
13usqwq,jmab5lx,"C++ is meant to support object identity, which means that if you call \`operator new\` twice in a row, without deleting one of those objects, it must return different pointers.",0.0,C++
13usqwq,jm40t9d,I am not entirely sure why you think allocating zero memory in Rust is undefined behaviour.,-0.25,Rust
13usqwq,jm40t9d,"Perhaps if you’re implementing extremely low-level data structures, you may need to be concerned about some unsafe APIs, but most people writing Rust will never need to worry about this.",0.1875,Rust
13usqwq,jm40t9d,"Rust strives to make as much of the language as possible undefined-behaviour free (or “safe”, in Rust parlance).",0.275,Rust
13usqwq,jm4co16,"In practice, this is not a thing you often rub up against if you're not working in a language like C, because most languages don't let you wantonly break their constraints; they will have some combination of static and dynamic checks and restrictions on basic language functionality to ensure that you play within their rulesets.",0.25,C
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,C
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,Rust
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,Haskell
13usqwq,jm2b7ko,Sounds like Rust is a good language to avoid.,0.7,Rust
13usqwq,jm7p2zu,"In Rust, integer overflow is defined as a panic.",0.0,Rust
13usqwq,jm7p2zu,The C version will most likely loop forever (it is UB after all.,0.25,C
13usqwq,jm588a8,"My view about C's UB is that I don't care for it, especially for things that I don't consider UB, like signed integer overflow.",0.0,C
13usqwq,jm588a8,"Quite often I've had a language where such overflow is well-defined, and desired target machines where it is well defined, but if using intermediate C between the two, now you have to run the gauntlet of some bloody-minded C compiler messing up your code and doing whatever the hell it likes.",0.0,C
13usqwq,jm588a8,Why is it UB in C?,0.0,C
13usqwq,jm588a8,"Even if writing in C, you're going to end up with different behaviour across compilers and with with the same compiler, depending on options.",0.0,C
13usqwq,jm588a8,"C is supposed to be a lower level language where you call the shots, but apparently not; the compiler does.",-0.025,C
13usqwq,jm2hw2m,"This was the case with early C, but is nowadays not really a factor because everything is so standardized.",0.0,C
13usqwq,jm3cbmx,Annex J in the C standard is invaluable.,0.0,C
13usqwq,jm2bqg9,">it's not something Rust programmers ever have to worry about,  ""Ever"" is doing a lot of work here.",0.0,Rust
13usqwq,jm2bqg9,"People do write low level code in Rust (with custom allocators and whatnot, though that part is unstable), it's just that the most common cases for memory allocation are already covered by `std`.",0.06666666666666667,Rust
13usqwq,jm3xohk,"> I'd never heard of the ""zero-sized allocations are UB"" before, because it's not something Rust programmers ever have to worry about, unlike in C.  Somewhat amusingly, you have this backwards.",0.6,Rust
13usqwq,jm3xohk,"`malloc(0)`, `new T[0]`, and `Alloc().allocate(0)` (for any `Alloc` implementing the Allocator requirements) are not undefined in C and C++; they all return a value which is unspecified except that it may be subsequently deallocated with `free`, `delete`, or `deallocate`, respectively (this may be null or another singleton, or it may be the address of an actual allocation, but either way the user is not allowed to dereference it).",0.10727272727272727,C
13usqwq,jm3xohk,"`malloc(0)`, `new T[0]`, and `Alloc().allocate(0)` (for any `Alloc` implementing the Allocator requirements) are not undefined in C and C++; they all return a value which is unspecified except that it may be subsequently deallocated with `free`, `delete`, or `deallocate`, respectively (this may be null or another singleton, or it may be the address of an actual allocation, but either way the user is not allowed to dereference it).",0.10727272727272727,C++
13usqwq,jm3xohk,"In Rust, by contrast, a type implementing `std::alloc::GlobalAlloc` _may_ invoke undefined behavior when passed 0 (though the default `std::alloc::System` allocator does not, as it also implements `std::alloc::Alloc`, which has a stronger set of requirements).",0.0,Rust
13usqwq,jm36y53,"`unsafe` is *far* from the only kind of UB in Rust, and it's scary that people still believe that.",0.04999999999999999,Rust
13usqwq,jmgd6m4,"This is a bigger problem in Rust than in C or other similar unsafe languages because Rust requires a LOT of invariants from your code, and really will do crazy things if you mess up any of the subtle details of pointers and aliasing, etc..",-0.1476190476190476,Rust
13usqwq,jmgd6m4,"This is a bigger problem in Rust than in C or other similar unsafe languages because Rust requires a LOT of invariants from your code, and really will do crazy things if you mess up any of the subtle details of pointers and aliasing, etc..",-0.1476190476190476,C
13usqwq,jm3uea8,"Per DonaldPShimoda's exposition higher up: C has ""undefined"" and also has ""implementation defined"" and ""unspecified"".",0.25,C
13usqwq,jm4fn50,> I am not entirely sure why you think allocating zero memory in Rust is undefined behaviour.,-0.25,Rust
13usqwq,jpuitya,What UB does eg JavaScript have?,0.0,JavaScript
13usqwq,jm2idkd,"I assure you, the existence of UB in Rust is grossly mischaracterized by OP.",0.0,Rust
13usqwq,jm352kh,> Sounds like Rust is a good language to avoid.,0.7,Rust
13usqwq,jm3jiyy,The size of an `int` in C is an implementation-defined behavior.,0.0,C
13usqwq,jm3jiyy,The order of evaluation of arguments to a function in C is an unspecified behavior.,0.0,C
13usqwq,jmaqer2,"It should be noted that in C, infinite loops (with non-constant conditions) themselves are undefined behavior (unless you perform IO, access a volatile/atomic value, or a small number of other exceptions of ""observable behavior"" inside of the loop).",-0.1875,C
13usqwq,jmaqer2,"So unless there's a black-box function call inside, a C compiler is free to assume *all* loops terminate.",0.4,C
13usqwq,jm2hx3w,"In Rust, most of the way one can invoke UB is by deliberately circumventing the strong guarantees the language provides  (using `unsafe { ...",0.4666666666666667,Rust
13usqwq,jm2hx3w,The problem that C(++) has compared to Rust is that any piece of code can have UB and innocuous looking code can be UB.,0.0,C
13usqwq,jm2hx3w,The problem that C(++) has compared to Rust is that any piece of code can have UB and innocuous looking code can be UB.,0.0,Rust
13usqwq,jm2hx3w,"Rust is quite literally designed with the property that the safe subset of the language will never introduce UB, almost like a mamaged language such as Java.",0.25,Rust
13usqwq,jm2hx3w,"Rust is quite literally designed with the property that the safe subset of the language will never introduce UB, almost like a mamaged language such as Java.",0.25,Java
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,Rust
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,C
13usqwq,jm3g53x,Can you give an example of user-error UB in safe Rust?,0.5,Rust
13usqwq,jm2hf2o,> Are you  saying that it impossible for a Rust program to call the `malloc` function of the C library via whatever FFI it has?,-0.6666666666666666,Rust
13usqwq,jm2hf2o,> Are you  saying that it impossible for a Rust program to call the `malloc` function of the C library via whatever FFI it has?,-0.6666666666666666,C
13usqwq,jm2hf2o,"Calling functions through FFI in Rust requires `unsafe`, so if you restrict your code to safe Rust then it's not (directly) possible.",0.25,Rust
13usqwq,jm4sjwp,"I'm most familiar with what Rust does as that's the systems language I use the most, and for the most part I think that what they label as UB is rather sensible, [according to this partial list](https://doc.rust-lang.org/reference/behavior-considered-undefined.html), at least.",0.24583333333333332,Rust
13usqwq,jm4sjwp,"For what it's worth, I do agree that UB should probably be a last resort, or reflecting of some problems with the backend (if you transpile to C or are working on top of LLVM or something), instead of being the first thing you reach for.",0.2625,C
13usqwq,jp710jy,"I think the point @BobSanchez47 is making is that Rust has objects that you just create, so few devs ever really call `alloc()`.",0.0,Rust
13usqwq,jp710jy,Whereas C always requires you to call `malloc(sizeof(MyStruct))` to get something roughly equivalent.,-0.1,C
13usqwq,jp710jy,"For all I know, Rust might have more UB in total than C, but only in gnarly low-level API nobody ever uses, making it UB-free in practice.",0.16666666666666666,Rust
13usqwq,jp710jy,"For all I know, Rust might have more UB in total than C, but only in gnarly low-level API nobody ever uses, making it UB-free in practice.",0.16666666666666666,C
13usqwq,jm2s7l7,C++),0.0,C++
13usqwq,jm42l7l,"In particular, Rust still hasn’t pinned down exactly what constitutes undefined behaviour when it comes to pointer aliasing and provenance, so any proof that undefined behaviour is impossible relies on a non-settled definition of UB.",-0.10138888888888889,Rust
13usqwq,jm37gjm,You can brick a system with Python if you really want to.,0.2,Python
13usqwq,jm37gjm,"Rust, being a very low-level systems programming language needs to give you access to the tools you need to... program systems.",0.2,Rust
13usqwq,jm3t9vz,"I know that it's not how C works, but by golly, the way it currently works is just too bizarre and arguably far more dangerous than it should be.",0.08,C
13usqwq,jm2qwph,And Rust developers LOVE happy paths.,0.65,Rust
13usqwq,jm2qwph,"But alas, Rust is not the only language there is.",-0.2,Rust
13usqwq,jm2jsvz,"Well, if I'm going down anyway, let's make it official:  *I dislike Rust, but not nearly much as its trigger-happy mob of fans.",-0.1277777777777778,Rust
13usqwq,jm3812x,Then how would Rust allow FFI with C/C++/whatever else that handles raw pointers?,-0.23076923076923078,Rust
13usqwq,jm56iqd,"> Rust, being a very low-level systems programming language   If Rust is 'very low level', that would make mine the other side of assembly.",0.025000000000000005,Rust
13usqwq,jm45dge,Hmm but it is _useful_ (for C) to have these dark corners where the behavior is undefined.,0.075,C
13usqwq,jm2x3ix,"> But alas, Rust is not the only language there is.",-0.2,Rust
13usqwq,jm3ygax,Writing a memory safe language that is free from UB is barely any work (I could do it in a day); writing a memory safe language that is as performant as C is a substantial amount of work (it takes dozens of developers working together 5+ years); writing a memory safe language that is free from UB and as performant as C is literally impossible.,0.2404761904761905,C
13usqwq,jm4cfkr,"> there would have at least been runtime checks on whether specific pointers can be dereferenced  Rust has ""managed pointers"" that are guaranteed to always be safe to de-reference: borrows!",0.10833333333333334,Rust
13usqwq,jm3j46e,"For actually performance-critical systems programming, generally nothing above C or even ASM is tolerable, this does not mean there aren't any other languages that do more, and this does not mean a certainly constrained design isn't lazy.",0.07797619047619048,C
13usqwq,jm3j46e,"I'm good enough to program in C, CUDA or ASM for things that need to be programmed in those.",0.35,C
13usqwq,jm3btvp,"My criticism is not that this stuff isn't checked, but that `safe` Rust is lazily defined, not as things that can be done safely, but as things that the authors think should be deemed safe.",0.3125,Rust
13usqwq,jm3btvp,"If this means a systems language, for example, in Go you would receive an error.",0.0,Go
13usqwq,jm3btvp,"Well, there is a lot to learn from other language designers, the question is only if the Rust community wants to.",0.025000000000000005,Rust
13usqwq,jm3gnyd,"> My criticism is not that this stuff isn't checked, but that `safe` Rust is lazily defined, not as things that can be done safely, but as things that the authors think should be deemed safe.",0.3125,Rust
13usqwq,jm3gnyd,"> If this means a systems language, for example, in Go you would receive an error.",0.0,Go
13usqwq,jm3gnyd,"Go has a GC, I don't even consider it for this discussion.",0.0,Go
13usqwq,jm3gnyd,"--  So, do I have to take this as ""I don't want what Rust wants to be, a GC-less safe language with optional access to unsafe low level details""?",0.2333333333333333,Rust
13usqwq,jm3i2ym,"Go, for example, does this.",0.0,Go
13usqwq,jm3i2ym,"It's not like Rust doesn't compromise on performance for the sake of safety generally, this shouldn't come to a surprise.",0.05000000000000002,Rust
13usqwq,jm3i2ym,"> Go has a GC, I don't even consider it for this discussion.",0.0,Go
13usqwq,jm3i2ym,"> So, do I have to take this as ""I don't want what Rust wants to be, a GC-less safe language with optional access to unsafe low level details""?",0.2333333333333333,Rust
13usqwq,jm3i2ym,You don't have to take it as anything - it's not like any individual in particular has any power to change Rust.,0.08333333333333333,Rust
13usqwq,jm3i2ym,"And at this point to counter this laziness you would need a new language most likely, Rust is too far gone.",0.18409090909090908,Rust
13usqwq,jm3i2ym,"Those insights you can apply to all languages, not only Rust.",0.0,Rust
13usqwq,jm3p0c1,"Rust was born for writing an efficient, parallel, but memory safe browser, not just as a random language.",0.0,Rust
13usqwq,jm3p0c1,"If I say I want to know how Rust could have been better, I mean with this goal in mind.",0.09375,Rust
13usqwq,jm4x5zc,"here's the thing, Rust's type system ensures that a value's type never changes.",0.0,Rust
13usqwq,jm4x5zc,"Instead of complicating the type system to such an extent (as what you're suggesting isn't just about freshly allocated pointers, at the very least you have to also propagate that additional type info down the line), Rust simply says - if you want to ensure this is always in a valid state, use wrapper types (like Box, which is a wrapper around a pointer).",-0.04911111111111112,Rust
13usqwq,jm4x5zc,"This offloads the burden from the language developers to create safe wrappers for all potential use cases of unions, pointers, C FFI, to the developers, which makes much more sense as the language devs can't possibly cover all such cases (and if you're suggesting ""don't cover all cases, only some"", where do you draw the line?)",0.16666666666666666,C
13usqwq,jm3sw7p,"The goal of Rust is providing safety, which is what my proposal does.",0.0,Rust
13usqwq,jm3sw7p,"> Rust was born for writing an efficient, parallel, but memory safe browser, not just as a random language.",0.0,Rust
13usqwq,jm3sw7p,You reject this because the very notion of this solution insults your perception of Rust and perhaps even your notion of oneself.,0.2,Rust
13usqwq,jm3sw7p,"But realize that Rust is not the only language with lazy design, in fact, I'm sure there is laziness in every language to an extent, so there is no reason to outright defy this so much.",0.1125,Rust
13uh17j,,"I'm pretty firmly convinced that using a more dedicated teaching language is a better approach than having beginners just start with Python/JavaScript/other language goes here and I'm not really here to discuss that, so I'm not really interested in comments like ""Just use Python because x, y, and z.""",0.1375,Python
13uh17j,jm2gx57,"TypeScript) to introduce various type concepts gradually - **Mutability**: Immutable by default, but with the possibility for opt-in mutability.",0.0,TypeScript
13uh17j,jm2gx57,"I've seen people learn Python via Jupyter Notebooks and then be completely lost trying to make their own program - **Easy to run**: As a beginner, one of my frustrations was ""I just want to run the code"".",0.37777777777777777,Python
13uh17j,jm2drem,"Something like Scheme, with SICP as an example of how to teach.",0.0,Scheme
13uh17j,jm2drem,"If you grasp SICP, you not only learn Scheme, you learn how to implement it, or how features of programming languages in general are implemented.",0.02500000000000001,Scheme
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,C
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,Python
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,JavaScript
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,C++
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,Java
13uh17j,jm268jg,https://hedycode.com/ is a great example of teaching to program by gradually building up to Python.,0.8,Python
13uh17j,jm268jg,I'd also recommend Elm as a source of inspiration.,0.0,Elm
13uh17j,jm3k9jr,"For beginners I'd probably have a language that requires type signatures on everything (including locals) with the ability to relax the requirement later - I also agree that algebraic data types are great for learning - loops, probably a single keyword for all kinds akin to go - low boilerplate (as somebody mentioned Java is terrible with this - it also requires everything to be in a class which is just silly and pedantic) - comprehensive package management that makes it easy for students to build fun little projects without needing to add to a config file.",-0.0325595238095238,Java
13uh17j,jm3k9jr,"Students don't need to worry about perf, but could get discouraged with long compile times - I agree with another commenter's mentions of immutability by default - ""everything is a pointer"" (a la Java) is also probably quite beneficial to students - it's a difficult concept and one that can be tackled down the line.",-0.2351851851851852,Java
13uh17j,jm7osyn,I've thought about this a bit - I actually think introducing a non-programmer to a pure functional language (like Haskell) *could* be a good idea (though it certainly has its limitations and detractors).,0.28214285714285714,Haskell
13uh17j,jm7osyn,"So, to answer your question, I would take Haskell and simplify it to within an inch of its life, mostly in terms of the type system and syntax.",0.5,Haskell
13uh17j,jm2dwn6,Or is the thread really about how to teach people to code in Rust or other such modern language?,0.06875,Rust
13uh17j,jm2yava,"It's one of the reasons why Python is better than some languages for this purpose, but has its own issues.",0.55,Python
13uh17j,jm2yava,"Pascal has an ecosystem outside its use in academics, so not only can students learn CS with the language, the language and its ecosystem are large enough to accommodate higher levels of skill.",0.09285714285714286,Pascal
13uh17j,jp8y6ii,Having to declare variables in a VAR section that has to be below the CONST section both of which have to be at the top of my function like Pascal will put unnecessary obstacles between learners and the successes that keep them coding.,0.01666666666666666,Pascal
13uh17j,jp8y6ii,You can always move on to C later if you want to teach them how to associate errors where the compiler got confused with the actual error location.,-0.13333333333333333,C
13uh17j,jm3kqpu,And a type checker something like TypeScript's where 90% of the time all you need to annotate is your functions and it can infer the rest.,0.0,TypeScript
13uh17j,jm6oeqp,Somebody on the C subreddit specifically asked about a simple graphics library; one suggestion was GTK3!,0.0,C
13uh17j,jm2raw2,People say it a lot in regards to learning Haskell or something after C (or something).,0.0,Haskell
13uh17j,jm2raw2,People say it a lot in regards to learning Haskell or something after C (or something).,0.0,C
13uh17j,jm81jhp,When I moved on from C++ I had to unlearn loads of accepted wisdom because it turned out to be completely wrong:  * Simula-style OOP sucks.,-0.4,C++
13uh17j,jm81jhp,* C++ isn't conducive of good performance.,0.7,C++
13uh17j,jm81jhp,Basically everything C++ added to C had already been done better before C++ was invented.,0.5,C++
13uh17j,jm81jhp,Basically everything C++ added to C had already been done better before C++ was invented.,0.5,C
13uh17j,jm3lm20,"Where I would argue for recursion over loops stems from my experience in teaching programmers using JavaScript where, once they learn how to think I'm terms of recursion, it's often been easier to move to iteration without losing the intuition for recursion in the process.",0.0,JavaScript
13uai8f,, All I need is a sample how to call a language server written in C that can  be empty like //put your code here.,-0.1,C
13uai8f,jm065nf,I guess you need to choose the IDE client (vs code etc) I’m not sure how the commands are sent (maybe stdin in C and maybe sockets.. no idea where to configure this) There are sample projects but for some reason for me particularly they write a about everything but not about the bits I need so it is very frustrating reading.,-0.20111111111111113,C
13uai8f,jm0f0cm,lets say my server is in C where do I specify the port for instance..these are the parts that are driving me crazy :-/,-0.425,C
13u5ie6,jlzbsm0,"(Since you mention Clang so are using C, if the parameter type uses `const`, it may not be necessary to make a copy, as that stops the callee writing into the struct.)",0.0,C
13u5ie6,jm4d16y,If you want to pass data to or from C you need to get your hands dirty and implement the ABIs.,-0.6,C
13u5ie6,jm4d16y,LLVM by default will just do some simple best effort when you don’t lower according to the C ABI.,0.5,C
13u5ie6,jlzgraa,"Take this example code:      struct S {       int a;       float b;       long c;     };     float f(struct S arg) {       return arg.a + arg.b + arg.c;     }     void test() {       struct S arg;       arg.a = 1;       arg.b = 2.f;       arg.c = 3;       float val = f(arg);     }  My implementation would generate something like this (if, of course, it was made to parse C):      define float @f({ i32, float, i64 } arg) {       %0 = extractvalue { i32, float, i64 } arg, 0       %1 = extractvalue { i32, float, i64 } arg, 1       %2 = sitofp i32 %0 to float       %3 = fadd float %2,  %1       %4 = extractvalue { i32, float, i64 } arg, 2       %5 = sitofp i64 %4 to float       %6 = fadd float %3, %5       ret float %6     }          define void @test() {       %0 = insertvalue { i32, float, i64 } undef i32 1, 0; My initialization is a bit shorter here because of how I initialize structs       %1 = insertvalue { i32, float, i64 } %0, float 2.000000e+00, 1       %2 = insertvalue { i32, float, i64 } %1, i64 3, 2       %3 = call float @f({ i32, float, i64 } %2)     }  But Clang emitted this (data layout, attributes, and metadata are omitted):      %struct.S = type { i32, float, i64 }          ; Function Attrs: noinline nounwind optnone uwtable     define dso\_local float @f(i64 %0, i64 %1) #0 {       %3 = alloca %struct.S, align 8       %4 = getelementptr inbounds { i64, i64 }, ptr %3, i32 0, i32 0       store i64 %0, ptr %4, align 8       %5 = getelementptr inbounds { i64, i64 }, ptr %3, i32 0, i32 1       store i64 %1, ptr %5, align 8       %6 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 0       %7 = load i32, ptr %6, align 8       %8 = sitofp i32 %7 to float       %9 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 1       %10 = load float, ptr %9, align 4       %11 = fadd float %8, %10       %12 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 2       %13 = load i64, ptr %12, align 8       %14 = sitofp i64 %13 to float       %15 = fadd float %11, %14       ret float %15     }          ; Function Attrs: noinline nounwind optnone uwtable     define dso\_local void @test() #0 {       %1 = alloca %struct.S, align 8       %2 = alloca float, align 4       %3 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 0       store i32 1, ptr %3, align 8       %4 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 1       store float 2.000000e+00, ptr %4, align 4       %5 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 2       store i64 3, ptr %5, align 8       %6 = getelementptr inbounds { i64, i64 }, ptr %1, i32 0, i32 0       %7 = load i64, ptr %6, align 8       %8 = getelementptr inbounds { i64, i64 }, ptr %1, i32 0, i32 1       %9 = load i64, ptr %8, align 8       %10 = call float @f(i64 %7, i64 %9)       store float %10, ptr %2, align 4       ret void     }  IIRC, C requires all variables to have addresses, while my language doesn't, but what I don't get is why \`%6\`-\`%9\` in \`test\` are used to load everything out in the form of \`i64\`s, only to reinterpret that again inside \`f\`.",-0.025,C
13u5ie6,jm3dlum,"The C ABI is typically ""just"" the ABI the kernel designed for system calls from user-space: C adopts this ABI on a per platform/per OS basis simply so that those system calls can be modeled directly in C.  So, to some degree, you're asking why Linux system calls on x64 were chosen to pass your struct as two 64-bits registers :)",0.10833333333333334,C
13tjaz7,,"I've re-implemented the ALT interpreter almost 20+ times for the past 1.5 years (Scala mostly), but this time I've implemented it in typescript - so it runs in the browser!",0.1875,Scala
13ta9vj,jlu3la2,"Not exactly tagged pointers, but Swift keeps track of unused bits and bit patterns and tries to use them to store discriminator of the tagged union.",-0.1125,Swift
13ta9vj,jlu3la2,And I think lower bits of the pointer are assumed to be unused (probably only in cases when reference is known to point to pure Swift object).,0.10714285714285714,Swift
13ta9vj,jlvjioz,GHC (Haskell) uses pointer tagging to store constructor tags for algebraic data types as an optimization.,0.0,Haskell
13ta9vj,jlxbkrg,Objective-C runtime makes extensive use of tagged pointers and values.,0.0,Objective-C
13ta9vj,jlygs6z,"Java was a disaster in so many ways that I find it difficult to learn from beyond ""don't do anything remotely like this"".",-0.03333333333333333,Java
13ta9vj,jlz9ecz,This is one of the design goals for Swift for example.,0.0,Swift
13ta9vj,jlz9ecz,"Swift has ""real"" compiled polymorphic generics, where the same compiled code can be applied to different types (via indirection).",0.06666666666666667,Swift
13ta9vj,jlyp7dy,"Because this:      let max m n = if m>=n then m else n  is far less efficient than this:      let max (m:int) n = if m>=n then m else n  Even if you just do this:      let min(m, n) = if m<=n then m else n     let min_int(m, n) = min(m, n)  It compiles `min_int` into a tail call to `min` which is:      _camlTest__min_267:       sub     sp, sp, #32       str     x30, [sp, #24]     L101:       str     x0, [sp, #8]       str     x1, [sp, #0]       adrp    x8, _caml_lessequal@GOTPAGE       ldr     x8, [x8, _caml_lessequal@GOTPAGEOFF]       bl      _caml_c_call     L102:       cmp     x0, #1       b.eq    L100       ldr     x0, [sp, #8]       ldr     x30, [sp, #24]       add     sp, sp, #32       ret     L100:       ldr     x0, [sp, #0]       ldr     x30, [sp, #24]       add     sp, sp, #32       ret  That's virtual calls to generic functions via a C API.",-0.022222222222222216,C
13ta9vj,jlyhd3b,Having tried Lisps and Haskell I must say that the only place I have ever seen arbitrary precision by default work is computer algebra systems.,-0.05,Haskell
13ta9vj,jlzpspe,Ok but Lisp is also grindingly slow.,0.09999999999999998,Lisp
13ta9vj,jlzmlac,> This is one of the design goals for Swift for example.,0.0,Swift
13ta9vj,jlzmlac,"Swift has ""real"" compiled polymorphic generics, where the same compiled code can be applied to different types (via indirection).",0.06666666666666667,Swift
13ta9vj,jlzt6vx,> Ok but Lisp is also grindingly slow.,0.09999999999999998,Lisp
13ta9vj,jlztzjr,> Lisp is also grindingly slow  [That so?,-0.30000000000000004,Lisp
13ta9vj,jm26kv1,"Apple spent considerable amount of engineering resources on implementing this type of generics in Swift, I doubt they would just do it for the fun of it.",0.09999999999999999,Swift
13ta9vj,jm009qp,"> Tracing is a data miss factory;  In Lisp, sure.",0.5,Lisp
13ta9vj,jm2e2ke,"> Apple spent considerable amount of engineering resources on implementing this type of generics in Swift, I doubt they would just do it for the fun of it.",0.09999999999999999,Swift
13ta9vj,jm2e2ke,Swift also uses RC.,0.0,Swift
13ta1b6,jlu5z6o,I'm not aware of any but the languages I know that do this are MMA/WL and Erlang.,-0.125,Erlang
13ta1b6,jlw6qwi,"So if you wanted to expose a DEQUE written in C to a language akin to Python, then your PY\_INCREF and PY\_DECREF could manage things that way, and the interface to memory management would all work out.",0.0,C
13ta1b6,jlw6qwi,"So if you wanted to expose a DEQUE written in C to a language akin to Python, then your PY\_INCREF and PY\_DECREF could manage things that way, and the interface to memory management would all work out.",0.0,Python
13t91mw,,"I'm bored of headers system in C, I want to start an experimental project for compiling C source without the need of forward declarations, and maybe add then support for generics and some runtime safety check as well.",-0.2,C
13t91mw,,"I have got some idea about how to parse C without a symbol table (I don't want to parse with it, since it would make forward declarations necessary again), but I have seen that D compiles this correctly      void main() {         Person* p = new Person(""John"", 30);     }          struct Person {         string name;         int age;     }  How does the compiler do this?",0.101010101010101,C
13t91mw,,"I have got some idea about how to parse C without a symbol table (I don't want to parse with it, since it would make forward declarations necessary again), but I have seen that D compiles this correctly      void main() {         Person* p = new Person(""John"", 30);     }          struct Person {         string name;         int age;     }  How does the compiler do this?",0.101010101010101,D
13t91mw,jluepx0,D uses unlimited lookahead and disallows certain expression statements (which allows `foo * bar;` to unambiguously be parsed as a declaration).,0.21428571428571427,D
13t91mw,jltw7um,IIRC D uses multi-pass compilation.,0.0,D
13t91mw,jltx6iv,But more importantly C's current syntax makes it impossible to parse usages of types before declarations.,-0.055555555555555546,C
13t91mw,jltx6iv,In other words C parsers will parse a statement differently if it starts with an ident which is the same as a previously declared type rather than a function for example.,-0.07291666666666666,C
13t91mw,jlu2kj3,I believe the D parser does multiple passes.,0.0,D
13t91mw,jlu2kj3,"[Heres a talk by Walter on the internals of the D compiler](https://www.youtube.com/watch?v=bNJhtKPugSQ) \- 20 minutes in lists the passes  D is also open source, so you could also [take a look at the code](https://github.com/dlang/dmd/tree/master/src)  Good luck, ✌",0.35,D
13t91mw,jltxmgz,Zig began as a fork of C without the preprocessor and evolved into something quite remarkable.,0.75,C
13t91mw,jlujngw,"I don't know D's syntax, but my language has out-of-order definitions, and there it causes ambiguities in parsing declarations involving user-defined types.",0.0,D
13t91mw,jlujngw,"In examples like the following, out-of-order definations are invaluable:      record R = (int data; ref S link)     record S = (int data; ref R link)  Some languages get tied up in knots doing stuff like this.",-0.5,R
13t91mw,jlu76rr,"Thanks for the answer, I actually know how to parse context-free grammars without a symbol table, but D does not seem to be context-free, it has the same problem with declarations like C (`Person* var;`)  &#x200B;  >If there are ambiguities, you can still parse them into a tree which allows ambiguous forms, and the ambiguities can be resolved in later passes.",0.05,D
13t91mw,jlu76rr,"Thanks for the answer, I actually know how to parse context-free grammars without a symbol table, but D does not seem to be context-free, it has the same problem with declarations like C (`Person* var;`)  &#x200B;  >If there are ambiguities, you can still parse them into a tree which allows ambiguous forms, and the ambiguities can be resolved in later passes.",0.05,C
13t91mw,jlvhtf8,"> Person *var;  C deals with this via the Lexer Hack; the `typedef` must always terminate before any use of the `typedef`’d name (AFAIK—maybe you could use it in VLA dimensions), so you know it’s a typename.",0.0,C
13t91mw,jlvhtf8,"C++ has the same restriction at block, global, and namespace scopes, but not within `struct`s or `class`es.",0.0,C++
13t91mw,jlvhtf8,"Even without templates, it’s quite possible that a C++ class won’t be able to finish/resolve the parse until reaching the end of the `struct`/`class` body:   	struct Foo { 		Foo(const T &) {T *var; var=0; static_cast<void>(var);} 		typedef Foo T; 	};  With C++ templates (which, when environmentally-unlimited, are themselves a fully Turing-Complete sub-language), parsing becomes undecidable.",0.25,C++
13t91mw,jlvhtf8,Aaaaaaaaaaall of this complication results from C’s gahddangfangled declaration syntax and the contortions everything has to undergo in order to maintain it.,0.0,C
13t91mw,jlvhtf8,"It *does* make some sense to be able to do things like `&a := &b` for alias creation, but not using C type/declarator syntax, in either event, ’s fer damn sure, mmhmm.",0.5,C
13t91mw,jlvhtf8,"So the first and easiest thing to do would be *eliminate the cause of the Hack,* translate C code to your internal form at import, and move forward unconstrained.",0.125,C
13t91mw,jlvhtf8,"(You could even do this up properly and create a tool to build yourlanguage-native modules and library assemblies from C libraries/refs thereunto, their headers/refs thereunto, and any accompanying ancillary assets and autogenerators, all as an archive.",0.0,C
13t91mw,jlvhtf8,`:` is only used in C (in some relevant way—not counting e.g.,0.2,C
13t91mw,jlvhtf8,"Labels can do like Java and apply either to `{`braced`}` compound statements (`foo: {}` for the rough equivalent of `foo: (void)0;`) or control statements for use with `continue` and `break`, use a `label` keyword (`foo: label …` or `label(foo) …`; cf.",-0.5333333333333333,Java
13t91mw,jlvhtf8,"For ternary, you can use `if`/`else` as actual operators, rather than as statement markers, do Python’s unpleasant-in-practice `y if x else z` which makes it unclear whether `x` or `y` should be evaluated first, use `if`/`then`/`elif`/`else` as operators (`if x then y else z`), or use matching (switch !",0.15625,Python
13t91mw,jlvhtf8,"You can even depart from the C type system and come up with structural sum/product/union/intersection types that can be converted to/from structs and unions with or without discriminants—e.g., `S >< T` or `struct(S, T)` →roughly the effects of  	// Given 	typedef __typeof(sizeof 0) __Size; 	#define __MKREF(quals, T)typedef struct {\ 		__typename(T) quals *ptr;\ 	} T##Ref 	typedef struct {unsigned len; char c[];} __CStr; 	__MKREF(__const, __CStr); 	typedef struct __Type__STAG__ __Type; 	__MKREF(__const, __Type); 	typedrf struct __Attrs__STAG __Attrs; 	__MKREG(__const, __Attrs); 	enum __types_FldVariety { 		__types_TUPLE_ELEM, __types_UNION_ELEM, 		__types_ISECT_ELEM, __typed_SUM_ELEM, 		__types_STRUCT_FIELD, __types_UNION_FIELD, 		__types_LOCAL_VAR, __types_MODULE_VAR, 		__types_LIB_VAR, __types_PRIV_VAR, 		__types_LOCAL_LABEL, __types_ENUM 	}; 	struct __types_FldInf { 		union { 			__umax uvalue; 			__imax ivalue; 			__bfrmax bfrvalue; 			const void *pvalue; 			struct {__Size offset, align, size;}; 		}; 		__CStrRef name; 		__TypeRef type; __AttrsRef attrs; 		enum __types_FldVariety variety; 	}; 	#define __CStrRef_NIL … 	#define __AttrsRef_NIL … 	#define __TypeRef_FOR(...)… 	…  	#ifndef __product___S___T 	typedef struct { 		S __product_fld_0; 		T __product_fld_1; 	} __product___S___T; 	inline const struct __types_FldInf __product___S___T__FIELDS[2] = { 		{ 			.offset=offsetof(__product___S___T,__product_fld_0), 			.align=alignof(S), .size=sizeof(S), 			.name=__CStrRef_NIL, 			.type=__TypeRef_FOR(S), 			.attrs=__AttrsRef_NIL, 			.variety=__types_TUPLE_ELEM 		}, { 			.offset=offsetof(__product___S___T, __product_fld_1), .align=alignof(T), .size=sizeof(T), 			.name=__CStrRef_NIL, .type=__TypeRef_FOR(T), .attrs=__AttrsRef_NIL, 			.variety=__types_TUPLE_ELEM 		} 	}; 	#define __product___S___T __typename(__product___S___T) 	#endif  (which could easily be exported in a simpler table form and autogenned from that, even staying within C/++ using xmacros or xincludes), and `S -|- T` or `union(S, T)` as  	#//etc.",0.43333333333333335,C
13t91mw,jlubmby,"C has clear keywords to tell you whether something is an enum, struct, typedef etc, to allow you to parse unambiguously.",0.10000000000000002,C
13t91mw,jluc53n,"The zig compiler also compiles C and you can mix and match as required (as far as I can recall) - so yeah, there's that.",0.1,C
13t91mw,jlubcdj,**C to Python Example.,0.0,C
13t91mw,jlubcdj,**C to Python Example.,0.0,Python
13t91mw,jlubcdj,**  C:      int C = 5;  Python:     C = 5  **Are your source P.L.,0.0,C
13t91mw,jlubcdj,**  C:      int C = 5;  Python:     C = 5  **Are your source P.L.,0.0,Python
13t8usy,jlvy2o0,"C++ meanwhile just keeps invalid references in the lexical scope after a move, but nullifies them.",0.0,C++
13t8usy,jltzu4k,"It's implemented in Rust, and I use the im-crate, which provides immutable data structures.",0.0,Rust
13t8usy,jltzu4k,"So if a structure is shared, and the original is dropped, the Rust persistent data structure takes care of that under the hood.",0.375,Rust
13t8usy,jltzu4k,"There are basically two layers of memory management: the one I program, and the one that is provided by the immutable data structures in Rust.",0.0,Rust
13syh3m,jlsixt9,"For example in Rust there is crated named ""syn"" that can parse rust code and represent it in a data struct, so you can also generate this struct as your transpiler output and then deserialize into plain rust code.",-0.21428571428571427,Rust
13syh3m,jlsr58u,There are a couple C to Rust transpilers that you can look at for an example.,0.0,C
13syh3m,jlsr58u,There are a couple C to Rust transpilers that you can look at for an example.,0.0,Rust
13syh3m,jlt2xb9,"When not generating binary output files, I've used textual output as C source files, ASM source files, and IL source codes, all formats that were then processed by separate tools.",0.0,C
13syh3m,jlt2xb9,"The C version was the most challenging since the output is structured, and nested (unless you are generating very low level C - not recommended).",0.3333333333333333,C
13syh3m,jot0bj5,They are often used in web development to convert modern code written in languages like TypeScript or ES6 into backward-compatible versions that can run on older versions.,0.18333333333333335,TypeScript
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Swift
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Kotlin
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Objective-C
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,Java
13syh3m,jltx508,"I like to compare an old ""Pascal vs C"" comparison about string manipulation.",0.1,Pascal
13syh3m,jltx508,"I like to compare an old ""Pascal vs C"" comparison about string manipulation.",0.1,C
13syh3m,jlsvod4,I thought about transpiling to JavaScript through TypeScript's compiler.,0.0,JavaScript
13syh3m,jlsvod4,I thought about transpiling to JavaScript through TypeScript's compiler.,0.0,TypeScript
13syh3m,jlsvod4,"TypeScript's compiler is available as [an API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API), so the idea is to inject a compliant AST and have it do its magic.",0.45,TypeScript
13syh3m,jlso0r2,"If I were to translate my AST into Lua syntax, for example, how would it actually write that Lua?",0.0,Lua
13syh3m,jlsptvv,Are you trying to transpile to a Lua program that would be as close as possible to something a person would write?,0.0,Lua
13syh3m,jlsptvv,You could recursively traverse the AST with each node outputting a string that is the Lua code semantically equivalent to what the AST node represents.,0.0,Lua
13syh3m,jlsptvv,"However, if you are trying to transpile to a highly optimized subset of Lua, the code generation may be more akin to emitting a low-level language.",0.33,Lua
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,TypeScript
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,JavaScript
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,C++
13syh3m,jlt1n33,Here are some examples of transpilers which output Lua:   https://github.com/rochus-keller/Oberon/blob/master/ObLuaGen2.cpp  https://github.com/rochus-keller/Som/blob/master/SomLuaTranspiler.cpp,0.0,Lua
13syh3m,jltgz3s,[(Computerphile videos)](https://www.youtube.com/@Computerphile/search?query=parser)  JavaScript or Python have a buildt-in function that transforms a string into a dictionary.,0.0,JavaScript
13syh3m,jltgz3s,[(Computerphile videos)](https://www.youtube.com/@Computerphile/search?query=parser)  JavaScript or Python have a buildt-in function that transforms a string into a dictionary.,0.0,Python
13syh3m,jlzj32y,:D,1.0,D
13syh3m,jlss16m,"Lua was just an example, but yeah, that's kind of what I want.",0.6,Lua
13syfpk,,"I've been wondering how languages call functions from their host language, like Lua and C#.",0.0,Lua
13syfpk,,"I've been wondering how languages call functions from their host language, like Lua and C#.",0.0,C
13syfpk,,"I know Lua has a Metatable, and C# needs bindings/metadata, I think, but I'm not sure where it goes beyond that.",-0.25,Lua
13syfpk,,"I know Lua has a Metatable, and C# needs bindings/metadata, I think, but I'm not sure where it goes beyond that.",-0.25,C
13syfpk,jlsn93y,"When Lua calls a C function, it passes a pointer to the interpreter's stack to the C function, the C function has to manually pop off the parameters from the interpreter's stack, and if it returns something to the interpreter the C function pushes it back on the stack.",0.0,Lua
13syfpk,jlsn93y,"When Lua calls a C function, it passes a pointer to the interpreter's stack to the C function, the C function has to manually pop off the parameters from the interpreter's stack, and if it returns something to the interpreter the C function pushes it back on the stack.",0.0,C
13syfpk,jlsrdqp,"When C code calls into Lua, a value representing a lua function is pushed to the lua stack, along with it's arguments, then a lua c api function is called that pops the lua function and some number of arguments off of the stack and calls the given function with that number of arguments.",0.0,C
13syfpk,jlsrdqp,"When C code calls into Lua, a value representing a lua function is pushed to the lua stack, along with it's arguments, then a lua c api function is called that pops the lua function and some number of arguments off of the stack and calls the given function with that number of arguments.",0.0,Lua
13syfpk,jltmthm,Here's a practical example with a naive hypothethical Lua interpreter written in Python.,-0.3,Lua
13syfpk,jltmthm,Here's a practical example with a naive hypothethical Lua interpreter written in Python.,-0.3,Python
13syfpk,jltmthm,"# Lua     function inc (n)         return n + 1     end     a = 5     ---     b = inc(n)     print(b)  To keep track of the local scope, the host will probably have something like a map from names to values.",0.0,Lua
13syfpk,jltmthm,"At the `---` point, that map looks like this:      # Python     scope = {         ""inc"": LuaFunction(name=""inc"", args=[""n""], fn=<function ...>),         ""a"": LuaInteger(5),     }  The Lua statement `b = inc(n)` is then equivalent to      # Python     scope[""b""] = scope[""inc""].fn(scope[""a""])  in the host language.",0.0,Python
13syfpk,jltmthm,"At the `---` point, that map looks like this:      # Python     scope = {         ""inc"": LuaFunction(name=""inc"", args=[""n""], fn=<function ...>),         ""a"": LuaInteger(5),     }  The Lua statement `b = inc(n)` is then equivalent to      # Python     scope[""b""] = scope[""inc""].fn(scope[""a""])  in the host language.",0.0,Lua
13syfpk,jltmthm,"Now to answer your question, if you want the ""print"" function in Lua to invoke the host's ""print"", you just need to format it in a way that's compatible with the example call above, and inject it into the `scope` map.",0.0,Lua
13syfpk,jltmthm,"In this case, wrap it in a `LuaFunction` object:      # Python     host_print = lambda value_to_print: print(""From Lua:"", value_to_print.to_pystring())     scope[""print""] = LuaFunction(name=""print"", args=[""value_to_print""], fn=host_print)  Now when Lua does       # Lua     print(b)  it's executed as      # Python     scope[""print""].fn(scope[""b""].to_string())  Which is equivalent to calling Python's ""print"" like so:      # Python     print(""From Lua:"", LuaInteger(6).to_string())  You can also do it the other way around, calling Lua from Python.",-0.125,Python
13syfpk,jltmthm,"In this case, wrap it in a `LuaFunction` object:      # Python     host_print = lambda value_to_print: print(""From Lua:"", value_to_print.to_pystring())     scope[""print""] = LuaFunction(name=""print"", args=[""value_to_print""], fn=host_print)  Now when Lua does       # Lua     print(b)  it's executed as      # Python     scope[""print""].fn(scope[""b""].to_string())  Which is equivalent to calling Python's ""print"" like so:      # Python     print(""From Lua:"", LuaInteger(6).to_string())  You can also do it the other way around, calling Lua from Python.",-0.125,Lua
13syfpk,jltmthm,"After the Lua code has finished executing:      # Python     b = scope[""inc""].fn(LuaInteger(5))     print(b.to_pyint())  and you've called a Lua function from Python.",0.0,Lua
13syfpk,jltmthm,"After the Lua code has finished executing:      # Python     b = scope[""inc""].fn(LuaInteger(5))     print(b.to_pyint())  and you've called a Lua function from Python.",0.0,Python
13syfpk,jltmthm,"- Designing your VM to work with host primitives (pure `int` instead of `LuaInteger(int)`) - Injecting variables into the local scope works well (Python's `print` is itself implemented like that), but allows the guest to mess around with it in counterproductive ways (`print = exit; print(0)` is perfectly valid Python).",0.2598214285714286,Python
13syfpk,jltmthm,"I consider this a plus to prevent confusion and improve security, but if you want maximally flexible guests, you can:  - Inject all builtins (`scope.update(locals())` puts all Python's local names in the scope map).",0.0,Python
13syfpk,jlslmri,The Lua interpreter is a C program.,0.0,Lua
13syfpk,jlslmri,The Lua interpreter is a C program.,0.0,C
13syfpk,jlslmri,"If you download [the source](https://www.lua.org/download.html) and unpack it, you'll find a `src/` directory which contains the C code that does the [lexing](https://en.wikipedia.org/wiki/Lexical_analysis) and [parsing](https://en.wikipedia.org/wiki/Parsing) of Lua code, which eventually results in calling code elsewhere in the codebase (e.g.",0.0,C
13syfpk,jlslmri,"If you download [the source](https://www.lua.org/download.html) and unpack it, you'll find a `src/` directory which contains the C code that does the [lexing](https://en.wikipedia.org/wiki/Lexical_analysis) and [parsing](https://en.wikipedia.org/wiki/Parsing) of Lua code, which eventually results in calling code elsewhere in the codebase (e.g.",0.0,Lua
13syfpk,jlslmri,"In terms of the situation where Lua is embedded in a larger program, details about how it works in that context can be found in [this section of the Lua reference manual](https://www.lua.org/manual/5.4/manual.html#4).",0.0,Lua
13syfpk,jlslmri,"However, Lua doesn't have to be embedded in a larger program; it can also be run [standalone](https://www.lua.org/manual/5.4/manual.html#7).",0.0,Lua
13syfpk,jlslmri,"For example, the [Prosody XMPP chat server](https://en.wikipedia.org/wiki/Prosody_(software)) is written in Lua.",0.0,Lua
13syfpk,jlslmri,"Finally, and more generally, programming languages often have a '[foreign function interface](https://en.wikipedia.org/wiki/Foreign_function_interface)' (FFI) allowing a language to call functionality of another language (often C).",0.10625000000000001,C
13syfpk,jltg7d3,"I recently wrote a scripting language, and the way this worked for that is the host language (Java) had to tell the scripting system which static methods it wanted the scripts to be able to call, but could call instance methods freely.",0.35,Java
13syfpk,jltmtwi,"C has a standardized ABI, or a way to call a function from other machine code independently of the language.",-0.0625,C
13syfpk,jltmtwi,It's how you can just call C functions in python without any issues in the REPL.,0.0,C
13syfpk,jltmtwi,"C# goes a bit further by having a lot of compatibility with C. You can still use pointers, including function pointers, to call C functions.",0.0,C
13syfpk,jltmtwi,You can also declare a function as `extern` and then call that native function from normal C# code as if it were written in C#.,0.15,C
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,C
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,Java
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,C++
13syfpk,jlwvdhf,Though if your host language is C++ you *could* just write horrifying undebuggable templates instead.,-0.9,C++
13syfpk,jluspse,"A long time ago, I had a little C program/library that worked with a bunch of different languages, both calling into the languages and being called by the languages.",-0.07916666666666666,C
13syfpk,jluspse,"In the end, there's two problems: - Given the name of a function in the scripting language, how can you call the right C function?",0.2857142857142857,C
13syfpk,jluspse,"- How can you pass the right ""stuff"" so the C function works correctly and doesn't get horked?",0.2857142857142857,C
13syfpk,jluspse,A simple way is that the C program will pass a dictionary that maps strings that are the function names to function pointers.,0.0,C
13syfpk,jluspse,"If the C program has a ""shared library"" or ""DLL"" interface, the OS will have some functions that can paw through  the library and return a dictionary that maps strings to function pointers.",0.0,C
13syfpk,jluspse,"Of all the languages, Erlang had a ton of documentation saying how hard it was to do this, but it was actually easy.",0.07083333333333333,Erlang
13syfpk,jluspse,"And Perl had a ton of documentation saying how easy it was, but it was actually impossible in the general case (because Perl could work differently depending on what compiler you used to compile Perl, but that wasn't specified by anyone).",-0.045833333333333316,Perl
13syfpk,jlucpj1,"No, C has no standard ABI.",0.0,C
13syfpk,jlucpj1,"When a specific C compiler  exposes some function name in the the .OBJ or .o files that it's making, it will often use the common calling convention for whatever system it's on.",-0.15,C
13syfpk,jlucpj1,"On the old VAX/VMS system, for example, there was a detailed spec for how all languages were supposed to surface functions and also for listing the functions that were going to be called; the DEC C compiler followed those conventions so that it was (mostly) easy to for a program to be composed of modules written in multiple languages.",0.23333333333333334,C
13syfpk,jluhfx0,But there is a standard ABI across C programs compiled for the same platform - even if it isn't necessarily coupled to the C language - and other languages make use of that.,-0.03125,C
13syfpk,jluqt2c,"An older version of the same thing was old Mac applications, where the common calling convension for C wasn't compatible with the ""pascal"" calling convention used by the OS.",-0.008333333333333331,C
13shh4m,,"I've toyed around with compilers for a while, one (successful) lisp-like to asm, and one (less successful) C to asm; but never anything quite as complex as citrus.",0.25833333333333336,C
13shh4m,jlq4fl2,"It's a little overwhelming, but you can take a look at Rust's [internal documentation](https://rustc-dev-guide.rust-lang.org/mir/index.html).",0.10416666666666667,Rust
13shh4m,jlq4fl2,"Depending on your language semantics, you may want to look at other compilers for inspiration, such as OCaml or Haskell.",-0.0625,Haskell
13shh4m,jlq5h09,"I looked at old books for this, and I'm currently going through this book: Retargetable C Compiler, A: Design and Implementation https://a.co/d/awDr2B8  It's an old book but it's actually one of the better instruction books I've found.",0.13999999999999999,C
13shh4m,jlq5h09,It walks you on the design of an ANSI C compiler called lcc.,0.0,C
13shh4m,jlq5h09,Only downside is that some of the source is written K&R style.,0.0,R
13shh4m,jlq2yt2,"Even if you don't use C++, LLVM has bindings to most languages, so everything should still be similar.",0.25,C++
13s3f9c,jloddn1,"(I think I used something like `DPRINTF` in C, which either passed on its args to `printf`, or was an empty macro, but printing anything in C was a pig anyway.)",-0.1,C
13s3f9c,jloycur,"Julia does something similar to this; only expressions not terminated by a semicolon return a value, and only statements that return a value get printed at the REPL.",0.0,Julia
13rztfp,,This would allow creation of lazy lists that appear in functional languages like Haskell.,-0.25,Haskell
13rztfp,jlnj0gj,Dart does this.,0.0,Dart
13rztfp,jlnj0gj,"Dart also has `late` as a modifier for variable declarations, which does more or less what you describe here.",0.011111111111111118,Dart
13rztfp,jlnj0gj,"(In Dart, we check this at runtime and throw an exception if a cyclic initialization is encountered.)",0.0,Dart
13rztfp,jlnj0gj,"### Async/await  Dart, like several other languages, also has async/await.",-0.0625,Dart
13rztfp,jlnj0gj,The answer for Dart is that it doesn't: You simply can't use await inside the initializer for a late variable.,-0.15,Dart
13rztfp,jlnj0gj,We don't have that in Dart and in practice it means that sometimes you end up having to use nullable non-lazy variables and implement the lazy initialization yourself.,-0.25,Dart
13rztfp,jlo3dux,"Kotlin sort of provides this, though not as a first-class language feature.",0.0,Kotlin
13rztfp,jlo3dux,"But `by` instead invokes a Kotlin language feature called [""property delegation""](https://kotlinlang.org/docs/delegated-properties.html).",0.0,Kotlin
13rztfp,jlo3dux,I think Kotlin's approach is quite nice.,0.6,Kotlin
13rztfp,jlpzztq,"Scala has `lazy val` and ""by name"" parameters.",-0.25,Scala
13rztfp,jlolvvl,"Here is how you could do it in Java      class Lazy<A> {         // Supplier<A> is a function that takes no arguments and returns an A         private Supplier<A> thunk;         private A result;              public Lazy(Supplier<A> thunk){             this.thunk = thunk;             this.result = null;         }         public A force() {             // This means the thunk has already been forced             if (thunk == null) {                 return this.result;             } else {                 let result = thunk();                 // remove the thunk to allow it to be garbage collected                 thunk = null;                 this.result = result;                 return result;             }         }     }  Now, it might still make sense to add `lazy` expressions to the language, because allocating a closure might be more expensive than computing the result and with an expression, the compiler can make the decision to do either (if the computation is pure).",-0.03730158730158731,Java
13rztfp,jlqjjwd,Kotlin supports this but as a subset of a much more powerful operator called `by`.,0.4,Kotlin
13rztfp,jlnks8t,>Recursive references  The standard answer in a language like Haskell is that your program simply doesn't halt.,0.0,Haskell
13rztfp,jlo5rhu,"Yeah, I think this is heavily inspired by C#.",-0.2,C
13rztfp,jlo5rhu,"In the case of C#, you often want to write code that's still fairly fast for a JITed language, and explicitly seeing what's going on is a part of that.",0.2,C
13rztfp,jlqaxm5,D has a `lazy` keyword that is _only_ for function parameters and is essentially just syntax sugar for wrapping the value in a lambda as per usual.,-0.125,D
13rztfp,jlo9ub0,"To be fair, what you describe handles the `lazy { ... }` part of the Kotlin code.",0.22499999999999998,Kotlin
13rztfp,jlo9ub0,"That would be more like:      class Wrapper {         private var fooImpl = new Lazy<int>(() => 42);                  public int Foo => fooImpl.Value     }  (There might be a better way to do that now, but my C# experience is fairly old at this point.)",0.20606060606060606,C
13rztfp,jlo9ub0,"With C#, you'd use `foo.Value`.",0.0,C
13rztfp,jlo9ub0,"In Kotlin, if you just use `lazy { ... }`, you'd then use `foo.value`.",-0.25,Kotlin
13rztfp,jlot3y2,"The type isn't inferred because as far as I remember, C# only infers generic type parameters in method calls, not in constructors.",0.03333333333333333,C
13rztfp,jlqkn8l,D's system instead requires requires functions types to be augmented with some lazyness feature.,0.0,D
13rztfp,jlognnc,To my knowledge that's still the state of the art in C#.,0.0,C
13rztfp,jlpoigu,"I'd rather have the option to use lazies (even ""hidden lazies"" using Kotlin property delegation) than to be prevented from using them at all.",-0.16666666666666666,Kotlin
13rztfp,jlprj08,"And C# now has Roslyn Analyzers: basically compiler plugins that you can write as simple C# code, in parallel packages (""projects"" in a ""solution"") and that just run and do work at compile time.",0.0,C
13rnxrk,jlmscga,"If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Haskell
13rnxrk,jlmscga,"If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Rust
13rnxrk,jlmmu3g,Pass 2 is name resolution which must be done first (this also depends on language; in C you only need one pass).,0.125,C
13rnxrk,jlnurwv,"Actually Python does that for me, but ... ISTR making it explicit by calling `string.intern(...)`.",0.0,Python
13rnxrk,jlpmes8,"This arrangement works for something like C, where you can only reference stuff above.",0.0,C
13rnxrk,jlpk67r,>I would be very surprised if there wasn't some black magic that let you do this in TypeScript.,0.15444444444444447,TypeScript
13rnxrk,jlpk67r,But I still needed your explanation & the TypeScript explanation above to level me up in understanding enough to code it.,0.0,TypeScript
13rnxrk,jltk9ut,"> If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Haskell
13rnxrk,jltk9ut,"> If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,Rust
13rnxrk,jltk9ut,"FWIW, if you're using Rust or OCaml I recommend just decorating the tree externally using a separate hash table.",0.0,Rust
13rjs77,jlqbck8,:D,1.0,D
13rij54,jlkgzpe,I encourage you to look at *raw string literals* in C# 11.,-0.23076923076923078,C
13rij54,jlmdy39,Two are heredoc syntaxes      <<-SQL     SELECT * FROM food     WHERE healthy = true     SQL  And indent saving version      page = <<-HTML        Heredocs are cool & useful     HTML  You also have the %Q and %q formats these do or do not allow interpolation and let you choose the delimiterer for example %Q{..} or %Q/../ or whatever.,0.375,HTML
13rij54,jlkk8vs,"C# raw strings look cool, this is indeed a very similar idea.",0.039743589743589734,C
13rij54,jlkk8vs,":      `dedent         This is a text         across multiple         lines, which will         NOT have indentation space before each line     `  EDIT: see also [this comment](https://www.reddit.com/r/ProgrammingLanguages/comments/13rij54/multistrings_a_simple_syntax_for_heredocstyle/jlkpuun/) showing how to achieve the exact behavior of C# with a multistring which uses ' instead of linebreaks as separators.",0.125,C
13rij54,jlkk8vs,JavaScript has a similar feature known as [tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).,0.0,JavaScript
13rij54,jlki85v,"Yep, Rust's seems like a good implementation of the basic feature.",0.35,Rust
13rij54,jlki85v,Rust's syntax could be easily extended to support that.,0.43333333333333335,Rust
13rij54,jlki85v,"A similar thing can also be achieved with combining raw strings with other language features (as long as such are available, which is true for Rust).",0.049175824175824175,Rust
13rij54,jllkn76,;D,0.25,D
13rij54,jlklp7u,"C#:      indented4 =          """"""             {                 ""Name"": ""Zaphod""             }         """""";          nonindented =          """"""         {             ""Name"": ""Zaphod""         }         """""";  Here indented4 will have this value (indented 4 spaces):          {             ""Name"": ""Zaphod""         }   And nonindented:      {         ""Name"": ""Zaphod""     }",-0.75,C
13rij54,jlkotne,"***      `    |       {           ""Name"": ""Zaphod""       }     `  (a bit wacky, but short)      `dedent+         |             {                 ""Name"": ""Zaphod""             }     `  (the first line is discarded in the output; the position of `|` there dictates where to stop dedenting, effectively acting as the closing delimiter in C#)      `dedent++         |   {         |       ""Name"": ""Zaphod""         |   }     `  discard everything in every line up to and including `|` (must be space) -- I think Scala does something similar.",0.15,C
13rij54,jlkotne,"***      `    |       {           ""Name"": ""Zaphod""       }     `  (a bit wacky, but short)      `dedent+         |             {                 ""Name"": ""Zaphod""             }     `  (the first line is discarded in the output; the position of `|` there dictates where to stop dedenting, effectively acting as the closing delimiter in C#)      `dedent++         |   {         |       ""Name"": ""Zaphod""         |   }     `  discard everything in every line up to and including `|` (must be space) -- I think Scala does something similar.",0.15,Scala
13rij54,jlkotne,"In the end, you could choose to implement a variant which would work exactly like C#, allowing the closing delimiter to be indented.",0.25,C
13rij54,jlktfup,I'm sure C++ brings much excitement with its implementation.,0.35,C++
13rij54,jlkpuun,"So you could implement the `dedent` tag to work exactly like in C#, perhaps getting the best of both worlds.",0.625,C
13rij54,jlks874,":D), just to inspire people like you and start a discussion.",1.0,D
13rhbhd,,"I've written a lot of C, and I won't deny that it does come up to bite you, I still don't understand the hatred.",0.0,C
13rhbhd,,No one complains if a C function returns -1.,0.0,C
13rhbhd,,This is normal behavior when invalid inputs are given to a language that doesn't have advanced error handling like Rust.,0.275,Rust
13rhbhd,,"However, seeing people discuss them you'd think anyone who doesn't use Rust is a caveman for allowing NULL pointers to exist in their programming languages.",0.0,Rust
13rhbhd,,"As if this post wasn't controversial enough, I'm going to assert something else even more controversial: The level Rust goes to in order to prevent NULL pointers is ridiculously over the top for the majority of cases that NULL pointers are encountered.",0.29444444444444445,Rust
13rhbhd,jlk7xv6,With pointers in C the problem is you never know if the pointer returned by a function may be zero or not.,0.0,C
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,Python
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,C
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,Java
13rhbhd,jlki7kh,"In the type system of, say, C, there is no difference between a valid pointer pointing to an integer, and the invalid NULL pointer.",0.0,C
13rhbhd,jlki7kh,"Objective-C treats all nulls like ""empty"" values of their type, so a null interpreted as a number is zero, accessing a field of a null object returns another null, etc.",-0.1,Objective-C
13rhbhd,jlk9htg,I really don't see how Rust's avoidance of null pointers is over the top.,0.35,Rust
13rhbhd,jlk9htg,"I wouldn't even say Rust avoids it, it just doesn't fit into the language design given that it has Option.",0.4,Rust
13rhbhd,jlk9htg,"In C you can practically toss `(void*) 0` into anything, and in Java you can also set any type to `null`.",0.25,C
13rhbhd,jlk9htg,"In C you can practically toss `(void*) 0` into anything, and in Java you can also set any type to `null`.",0.25,Java
13rhbhd,jlk9htg,"Languages that make that distinguishment are a lot easier to reason about (whether that's in the language itself like Kotlin, or in the library like Rust).",0.0,Kotlin
13rhbhd,jlk9htg,"Languages that make that distinguishment are a lot easier to reason about (whether that's in the language itself like Kotlin, or in the library like Rust).",0.0,Rust
13rhbhd,jlk9htg,There's also the security issue that they bring alongside languages like C which is honestly enough to warrant avoiding them.,0.0,C
13rhbhd,jlkszdn,Kotlin has nulls and its type system makes it perfectly safe (and convenient) to use them whenever you need them to represent the absence of value.,0.24375,Kotlin
13rhbhd,jlkak57,"Also, I don't think having null in a language like C that has basically no seatbelts around raw pointers anyway and where only pointers can be null is much of an issue.",-0.010256410256410256,C
13rhbhd,jlkak57,"In C, returning NULL is not much worse than returning -1.",0.2,C
13rhbhd,jlkak57,It's just that most languages besides C don't use garbage values except null to indicate errors.,0.5,C
13rhbhd,jlkak57,">The level Rust goes to in order to prevent NULL pointers is ridiculously over the top for the majority of cases that NULL pointers are encountered  This is a strange argument IMO, because Rust *doesn't* do much to prevent null pointers.",0.07916666666666668,Rust
13rhbhd,jlkak57,"Rust doesn't *prevent* null, it just doesn't introduce null because there is no reason to do so if you have a generic, ergonomic `Option` type.",0.0,Rust
13rhbhd,jlkak57,Raw pointers in Rust [can absolutely be null](https://doc.rust-lang.org/std/ptr/fn.null.html).,-0.015384615384615385,Rust
13rhbhd,jlkak57,">outside of that it seems the level of hatred is extreme, and many things are blamed on NULL pointers that actually are flaws with language semantics rather than the NULL pointers themselves  In C, I agree (see above), but in high level languages, or languages with even slightly more expressive type systems, null values are absolutely an inherent flaw since they add an invalid garbage value to every single type",0.2181746031746032,C
13rhbhd,jlkf3r8,> No one complains if a C function returns -1.,0.0,C
13rhbhd,jlkyqjw,"I'm not a low level programmer, and it's probably different when you don't have Rust semantics and still want to do very controlled low level code, but the whole point of having a type system is that you *can* guarantee stuff about your code.",0.08,Rust
13rhbhd,jlkyqjw,"It's hard to make it readable with C syntax and no ability to compose functions (like a pipe operator), and we should create languages that do their best to be readable without a debugger.",0.35416666666666663,C
13rhbhd,jlkyqjw,"Rust does a pretty good job at this, ML languages do a great job at this, but C does a terrible job.",0.1875,Rust
13rhbhd,jlkyqjw,"Rust does a pretty good job at this, ML languages do a great job at this, but C does a terrible job.",0.1875,C
13rhbhd,jlkyqjw,C++ is the worst case scenario.,-1.0,C++
13rhbhd,jlkguud,Java).,0.0,Java
13rhbhd,jlk8j80,Rather than languages like ML and Rust which often times tell you what to do to fix things with types.,0.0,Rust
13rhbhd,jlkuvl0,"Because everyone's favourite language now is either Rust, or something of its ilk.",0.0,Rust
13rhbhd,jlw3r0s,"So, Java is a great leap forward in the specific sense that null-pointer has a defined behavior which is unlikely to lead to escalated privileges.",0.10000000000000002,Java
13rhbhd,jlm6o3t,"'no'; ```  Rust option without using `?`:  ``` let a = foo.map(|f| f.a).unwrap_or(""no""); ```",0.0,Rust
13rhbhd,jlk7a76,Not every language can or should be Rust that checks your inputs every step of the way.,0.0,Rust
13rhbhd,jllt9ja,> Kotlin has nulls and its type system makes it perfectly safe  Doesn't that mean its not `null` by definition?,0.09375,Kotlin
13rhbhd,jlkbu2x,"People write off C as a language simply because it cannot express optional types, when I’m saying that reaction is over the top for most cases.",0.3333333333333333,C
13rhbhd,jlkbu2x,"C is probably the worst example to illustrate my point, since the consequences are the most severe in C.   However, despite the responses I’m receiving, most languages do not have good methods of expressing errors.",0.175,C
13rhbhd,jlkbu2x,"Actually, only Rust is capable of not doing either of those things as far as I’m aware.",0.1375,Rust
13rhbhd,jlkbu2x,"However, there’s a reason 99% of all code ever written was not in Rust.",0.0,Rust
13rhbhd,jllsevc,> > No one complains if a C function returns -1.,0.0,C
13rhbhd,jllsevc,"C# is a much higher-level language than C. What do you think of [`System.String.IndexOf` returning `-1` for ""not found""](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-7.0) instead of `null` or a nullable or option type?",0.2,C
13rhbhd,jlkqddd,"Rust, Haskell and OCaml, a type like `Int` *only* contains valid integers.",0.0,Rust
13rhbhd,jlkqddd,"Rust, Haskell and OCaml, a type like `Int` *only* contains valid integers.",0.0,Haskell
13rhbhd,jlkl07t,"For example, a string in Java can be the empty string (`""""`), but it can also be `null`.",-0.1,Java
13rhbhd,jlkl07t,"For example, in Java, I can have a value of type `User` that may or may not be null.",0.0,Java
13rhbhd,jlkl07t,"In Rust, there's no built-in null, but there is the library type `Option` which can represent a value that may or may not be present.",0.0,Rust
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,Kotlin
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,Rust
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,Haskell
13rhbhd,jlmjao4,"They've been around in familiar forms for ~50 years or so dating back to Pascal and ML (possibly earlier, I don't know).",0.125,Pascal
13rhbhd,jlmecjs,"Languages such as Ada have improved upon this with the use of ranges; a day of the week can be precisely represented as `1..7`, rather than as a `u8`.",0.2,Ada
13rhbhd,jlk8eh8,"Python has exceptions as the default mechanism for error handling, and choosing to return an empty string instead of throwing an exception is a bad design decision in most cases.",-0.09999999999999994,Python
13rhbhd,jlkmq2d,"Null is just a value in Python like any other one, and you can definitely accidentally get a `None` where you were expecting a `str`, but you can also get an `int` or a `User`, or a whatever else in the same place.",-0.041666666666666664,Python
13rhbhd,jlkmq2d,"Python, by default, has no typing system, so nulls aren't worse than any other value!",-0.278125,Python
13rhbhd,jlkbyjp,Not in languages such as Haskell and Rust.,0.0,Haskell
13rhbhd,jlkbyjp,Not in languages such as Haskell and Rust.,0.0,Rust
13rhbhd,jlkbyjp,"Even in C# and others, it is very much possible to create types that cannot be constructed in a safe manner to have invalid values.",0.25,C
13rhbhd,jlkbyjp,"Haskell lets you define list type that does not have an empty constructor, in (safe) Rust a string containing other than valid UTF-8 is impossible (and in unsafe Rust it is UB), and so on.",-0.09791666666666665,Haskell
13rhbhd,jlkbyjp,"Haskell lets you define list type that does not have an empty constructor, in (safe) Rust a string containing other than valid UTF-8 is impossible (and in unsafe Rust it is UB), and so on.",-0.09791666666666665,Rust
13rhbhd,jllzf83,"Kotlin has `null`, it's just that the language will not let you dereference a `null` value.",0.0,Kotlin
13rhbhd,jlkoqxn,">People write off C as a language simply because it cannot express optional types, when I’m saying that reaction is over the top for most cases  While it is probably not the worst thing C does, I don't think this perception is over the top.",0.1,C
13rhbhd,jlkoqxn,"Sure, C could use something other than optional, but the way C uses garbage values for failure is pretty awful.",-0.13833333333333334,C
13rhbhd,jlkoqxn,"What C calls ""error handling"" really falls into two categories: Errors and nonexistence.",0.2,C
13rhbhd,jlkoqxn,"There is an argument to be made for *checked* exceptions that need to be handled at some point (Rust uses `Result`), but most languages have an answer to this.",0.5,Rust
13rhbhd,jlkoqxn,"Many languages still throw an exception since they expect the programmer to check if the map contains the value first, but the correct behavior is arguably to return an `Option` or something similar (like an explcitly nullable type in Kotlin).",0.25,Kotlin
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Java
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Scala
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Rust
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Haskell
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,Elm
13rhbhd,jlkoqxn,Kotlin and C# have explicit opt-in nullable types.,0.0,Kotlin
13rhbhd,jlkoqxn,Kotlin and C# have explicit opt-in nullable types.,0.0,C
13rhbhd,jlkoqxn,Previous versions of C# used to use `out` parameters.,-0.16666666666666666,C
13rhbhd,jlkoqxn,"Go arguably does the wrong thing with it's `if err != null` checks, but I don't think anyone in this sub considers go's behavior well designed.",-0.625,Go
13rhbhd,jlkoqxn,">However, there’s a reason 99% of all code ever written was not in Rust.",0.0,Rust
13rhbhd,jlkoqxn,"Because 99% of the time, that level of safety is not mission critical  Rust is not much safer than most statically typed high-level languages.",0.13333333333333333,Rust
13rhbhd,jlkoqxn,"If performance and predictability are not mission critical, you don't need to use Rust, althought that doesn't mean that using Rust is a bad choice in that case.",-0.3374999999999999,Rust
13rhbhd,jlmck17,"There's several things about C headers that make them bad:  - C has only one namespace, so anything included from a header is dumped into that namespace; people still create namespaces, but they have only nominal support.",-0.17499999999999996,C
13rhbhd,jlmck17,"- The C preprocessor operates in a strictly linear manner, making separate and parallel compilation difficult and introducing unexpected dependencies between files.",-0.13333333333333333,C
13rhbhd,jlmck17,This is why so much focus is put on making C and C++ parsers fast.,0.2,C
13rhbhd,jlmck17,This is why so much focus is put on making C and C++ parsers fast.,0.2,C++
13rhbhd,jlk95ku,"I mean like in Python, where error checking is not a default or enforced practice.",-0.3125,Python
13rhbhd,jlp9j5v,> There's several things about C headers that make them bad:  Right.,-0.13809523809523805,C
13rhbhd,jlp9j5v,"> C has only one namespace, so anything included from a header is dumped into that namespace; people still create namespaces, but they have only nominal support.",0.0,C
13rhbhd,jlp9j5v,"> The C preprocessor operates in a strictly linear manner, making separate and parallel compilation difficult and introducing unexpected dependencies between files.",-0.13333333333333333,C
13rhbhd,jlp9j5v,This is why so much focus is put on making C and C++ parsers fast.,0.2,C
13rhbhd,jlp9j5v,This is why so much focus is put on making C and C++ parsers fast.,0.2,C++
13rhbhd,jlmiznx,"Yes, even C has them now (as `_BitInt(N)`).",0.0,C
13rhbhd,jlkafoo,"I'd encourage you to read [PHP: A Fractal of Bad Design](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/), not necessarily because you need to know about why PHP is bad but because, to make it clear how PHP violates them, it argues very forcefully for some pretty basic principles of _good design_.",-0.01874999999999996,PHP
13rhbhd,jlkafoo,Here's an excerpt that's relevant:  > Parts of PHP are practically designed to produce buggy code.,0.45,PHP
13rhbhd,jlkafoo,"> In C, functions like strpos return -1 if the item isn’t found.",0.0,C
13rhbhd,jlkafoo,"> > In, say, Python, the equivalent .index methods will raise an exception if the item isn’t found.",0.0,Python
13rhbhd,jlkafoo,"> > In PHP, these functions return false.",-0.4000000000000001,PHP
13rhbhd,jlkafoo,"If you use FALSE as an index, or do much of anything with it except compare with ===, PHP will silently convert it to 0 for you.",-0.0666666666666667,PHP
13rhbhd,jlkafoo,"Here, PHP has actively created a subtle trap for me to fall into, and I have to be vigilant even with such mundane things as string operations and equality comparison.",-0.15833333333333333,PHP
13rhbhd,jlkafoo,PHP is a minefield.,0.0,PHP
13rhbhd,jlkbdgd,"_BUT_, because Java has nullability on _every_ non-primitive type, you totally _can_ write:      ValidatedString foo = null;  And now there's no way for any downstream functions to enforce at compile time that the input to a function _cannot_ be`null`.",0.0,Java
13rhbhd,jlkbdgd,Put another way: I'm going to give you some Java method signatures.,0.0,Java
13rhbhd,jlkbdgd,"For some further reading, I recommend looking into why `Optional<T>` is one of the big candidates for Java's Project Valhalla, which will allow you to define custom non-nullable value types.",0.0,Java
13rhbhd,jlpc7vd,"I'm not a C programmer, so for me and any other first time user they seem to only offer confusion and nothing else.",0.041666666666666664,C
13rhbhd,jlpc7vd,But since I've only dabbled in C I'll ask this with an open mind- what trade offs are there?,0.0,C
13rhbhd,jlpx7bw,I'm thinking beyond C but I'd say some advantages are:  * Clear machine-verified API.,0.10000000000000002,C
13rhbhd,jll9srd,"Some languages like TypeScript or modern C# still have null, but only for types that have explicitly been marked as nullable.",0.10000000000000002,TypeScript
13rhbhd,jll9srd,"Some languages like TypeScript or modern C# still have null, but only for types that have explicitly been marked as nullable.",0.10000000000000002,C
13rhbhd,jlq0oml,"Just my two cents here, but in my experience using languages where order matters (basically just Python), it only ever feels like it gets in my way when I'm trying to make a clean API, but as I said earlier I'm not really sure what header files have to do with that.",0.029166666666666674,Python
13rhbhd,jlqa1vc,"> Just my two cents here, but in my experience using languages where order matters (basically just Python), it only ever feels like it gets in my way when I'm trying to make a clean API, but as I said earlier I'm not really sure what header files have to do with that.",0.029166666666666674,Python
13rhbhd,jlkiop1,"You're the one who brought up programmers who have to work with legacy languages; but this subreddit isn't about that, and we can say ""C sucks"" without concern.",-0.3,C
13qqp2t,,I made a translator that converts C to my esolang (with entirely different logic structure).,0.0,C
13qqp2t,,"How is that different from say, a translator that converts C in english to C in german.",0.0,C
13qqp2t,jlgd5ff,"In software-land, examples are [Flow](https://flow.org/) which is a language whose creators refuse to call it that, and all the C dialects (GNU C, Objective-C, nesC, NQC, NXC, ...) which will depend on who you ask.",0.0,C
13qqp2t,jlgd5ff,"In software-land, examples are [Flow](https://flow.org/) which is a language whose creators refuse to call it that, and all the C dialects (GNU C, Objective-C, nesC, NQC, NXC, ...) which will depend on who you ask.",0.0,Objective-C
13qqp2t,jlgd5ff,"Then we call languages in the Lisp family ""Lisp dialects,"" for no particular technical reason.",-0.041666666666666664,Lisp
13qqp2t,jlgd5ff,"That's also how you can run Java Bytecode on .Net and vice-versa ([XMLVM](http://www.xmlvm.org/overview/), [IKVM.NET](https://en.m.wikipedia.org/wiki/IKVM.NET)).",0.0,Java
13qqp2t,jlgrbop,The underlying language is equivalent to C.,0.0,C
13qqp2t,jlgf6pr,translating call/cc from Scheme to Clojure.),0.0,Scheme
13qqp2t,jlgf6pr,translating call/cc from Scheme to Clojure.),0.0,Clojure
13qqp2t,jlg9utv,"There is no actual answer, you could, for example, grab C and just add a feature from OOP and call it ""C with classes"" (true story).",0.175,C
13qqp2t,jlgu2sz,"C to your esolang might be, depending on what your lang can do.",0.0,C
13qqp2t,jlhd81r,"Assembly is the ""narrow waist"" of how we instruct computers to do things.",-0.2,Assembly
13qqp2t,jlhd81r,Assembly isn't perfect since obviously there are a handful of different instruction sets for various manufacturers,0.25,Assembly
13qqp2t,jljftyg,"If you write a program in C, it's going to look very different than a program in Haskell as a result of its features, is there immutability by default?",0.0,C
13qqp2t,jljftyg,"If you write a program in C, it's going to look very different than a program in Haskell as a result of its features, is there immutability by default?",0.0,Haskell
13qqp2t,jljftyg,"Sure, you could translate a program from C to Haskell or vice versa, but it's gonna look horrible if you exactly do in one language what you do with the other.",-0.09375,C
13qqp2t,jljftyg,"Sure, you could translate a program from C to Haskell or vice versa, but it's gonna look horrible if you exactly do in one language what you do with the other.",-0.09375,Haskell
13qqp2t,jljftyg,"There's also the fact that Haskell needs a runtime to actually execute the code, so the C translation will effectively have to reimplement the Haskell runtime to be equivalent.",0.3,Haskell
13qqp2t,jljftyg,"There's also the fact that Haskell needs a runtime to actually execute the code, so the C translation will effectively have to reimplement the Haskell runtime to be equivalent.",0.3,C
13qqp2t,jlk5a7b,"If your lang is just C with different keywords, it has the same semantics as C and is considered C-like (or ALGOL-like more broadly), but that doesn't preclude it from being an esolang.",0.140625,C
13qqp2t,jljgfy2,"It's a derivative of Haskell, but it's a new language.",0.13636363636363635,Haskell
13qqp2t,jlgm29p,And where does Prolog fit?,0.4,Prolog
13qqp2t,jlgm29p,Forth?,0.0,Forth
13qqp2t,jlh64sg,All of those can be collapsed under Lisp ;),0.25,Lisp
13qqp2t,jljhm4t,"Python 2 Python, despite it being a different formal language than Python 3.",0.0,Python
13qqp2t,jlj58qk,"(2) The abstract semantics of Haskell don't specify a way to do I/O, nor is it precluded.",0.0,Haskell
13qqp2t,jlj58qk,"One could easily imagine a runtime for Haskell which printed every string in the program as soon as it was created in much the same way that one can graft I/O machinery onto the _implementation_ of any abstract machine, including a Turing machine.",0.2111111111111111,Haskell
13qqp2t,jljrt1v,"If language A supports self-modification and language B doesn't, then there will be no straightforward translation of A -> B, even when passing through another language C (eg.",-0.1875,C
13qqp2t,jlib57j,It sounds like you're describing [reader macros](https://lisper.in/reader-macros) :D,1.0,D
13qm38j,,again 2 lifetimes involved  Rust has some examples that can be used: [https://doc.rust-lang.org/rust-by-example/scope/lifetime.html](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).,-0.75,Rust
13q76pm,jle6tsk,"(I would also be peeved if it had turned out to be Forth, combinatory logic, a universal Turing machine, or the lambda calculus.)",0.0,Forth
13q76pm,jlno7vz,"Crenshaw was 100% hand-rolled recursive-descent, but he was aiming at a much-simplified Pascal.",0.0,Pascal
13q76pm,jlsmsgr,"Like most people on this subreddit, I *couldn't* create my own programming language by following OP's instructions because my own programming language isn't a dialect of Lisp.",0.42500000000000004,Lisp
13q76pm,jlsmsgr,Java).,0.0,Java
13q76pm,jlhiomk,"As it is, this looks like just another Lisp.",0.0,Lisp
13q76pm,jlhuclg,"> As it is, this looks like just another Lisp.",0.0,Lisp
13q76pm,jlhuclg,"And C++ looks like just another C — at least, at the outset.",-0.3,C++
13q76pm,jlhuclg,"And C++ looks like just another C — at least, at the outset.",-0.3,C
13q76pm,jlhuclg,"Nobody who knows what they're talking about looks at Rust code and says ""Ah yes, the critical essence of Rust is that its syntax is mostly C-like but with more noise.""",0.3333333333333333,Rust
13pzzah,jlcuu2n,"So are D and C# if you count [`in`](https://dlang.org/spec/function.html#in-params) as the default, instead of the actual default.",0.0,D
13pzzah,jlcuu2n,"So are D and C# if you count [`in`](https://dlang.org/spec/function.html#in-params) as the default, instead of the actual default.",0.0,C
13pzzah,jlcuu2n,"Rust is another [precedent](https://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=46f628468f8d2db9728f221417ed570f), but from another angle: when you move a value into a function, nobody can observe mutations, so a compiler is free to pass-by-reference all moved objects.",0.4,Rust
13psmjy,jlcqjg5,Common for functional or C like impl languages.,-0.3,C
13psmjy,jlcqjg5,"And you can't hide the token allocations into the parser nodes - it might then be better to batch lex rather than a streaming lexer that an LL benefits from * C style lists to build the tree enables keeping the list in the parser node allocation too  Kind regards,  M ✌",0.55,C
13psmjy,jlcihts,I can only give a C++ answer.,0.0,C++
13psmjy,jlcihts,Do you want a C++ answer?,0.0,C++
13psmjy,jlcihts,For example on my machine Go does around 85K and that is thought to be 'fast',0.2,Go
13psmjy,jlbmih8,It may even be impossible to make efficient depending on comparability constraints (see the design of Python and the poor syntax decisions with C++).,-0.5333333333333333,Python
13psmjy,jlbmih8,It may even be impossible to make efficient depending on comparability constraints (see the design of Python and the poor syntax decisions with C++).,-0.5333333333333333,C++
13pi1ox,,"So I've been steadily working on my language Vortex, and even though most of the work has gone into updating the internal interpreter code to make it run a little smoother, there are some interesting developments that I'd like to share:  **More Libraries:**  Vortex offers C interoperability out of the box and I've been building the language out using dynamic libraries.",0.19739583333333333,C
13pd2ho,,"* passable language intrinsic functions and/or standard library - string operations, sorting, hash map, basic statistics (sum, product, avg, var, std) * able to generate standalone binaries (not requiring interpreter at runtime)  Basically Fortran if it was invented in 2014 instead of 1954.",0.16666666666666666,Fortran
13pd2ho,jl91azx,"Well Rust is the most popular modern language with a huge ecosystem that is like that, but it also requires you to learn a more modern approach than ""newer Fortran"".",0.4000000000000001,Rust
13pd2ho,jl91azx,"Well Rust is the most popular modern language with a huge ecosystem that is like that, but it also requires you to learn a more modern approach than ""newer Fortran"".",0.4000000000000001,Fortran
13pd2ho,jl9151d,Ada can do all of those things.,0.0,Ada
13pd2ho,jl9151d,"The GNAT compiler is a gcc frontend, so is just as fast as C if you turn off bounds checking and avoid certain constructs.",0.20714285714285713,C
13pd2ho,jl9c6dc,"C++ itself checks all of these boxes, so is there something else you're looking for?",0.0,C++
13pd2ho,jlaq6gu,"Check out [D](https://dlang.org/), in particular since you mention metaprogramming.",0.16666666666666666,D
13pd2ho,jlaq6gu,"Here's operator overloading in D:      struct C     {         int x;         C opBinary(string op)(in C obj) const         {             mixin(""return C(x "", op, "" obj.x);"");         }                  unittest         {             const a = C(21);             const b = C(2);             const c = a * b;             assert(c.x == 42);         }     }  Here's more funky code:      static foreach(T; AliasSeq!",0.5625,D
13pd2ho,jlaq6gu,"Here's operator overloading in D:      struct C     {         int x;         C opBinary(string op)(in C obj) const         {             mixin(""return C(x "", op, "" obj.x);"");         }                  unittest         {             const a = C(21);             const b = C(2);             const c = a * b;             assert(c.x == 42);         }     }  Here's more funky code:      static foreach(T; AliasSeq!",0.5625,C
13pd2ho,jlaq6gu,"It also has both LLVM and GCC frontends, checking the ""as fast as C"" part.",0.2,C
13pd2ho,jlaq6gu,"In fact there's an entire subset of the language called D As Better C, where runtime features (GC, RTTI, exceptions) are disabled and you keep everything else.",0.09999999999999999,D
13pd2ho,jlaq6gu,"In fact there's an entire subset of the language called D As Better C, where runtime features (GC, RTTI, exceptions) are disabled and you keep everything else.",0.09999999999999999,C
13pd2ho,jlcu8hf,Crystal?,0.0,Crystal
13pd2ho,jl9szyr,Do a front-end for C++ code instead.,0.0,C++
13pd2ho,jl9szyr,"That is, transpile your ideal language into C++ source code.",0.9,C++
13pd2ho,jl9szyr,"Or maybe, since you don't seem bothered about syntax, just use C++ directly.",0.1,C++
13pd2ho,jl9szyr,"A solution in C++ would be clunky, but that language is clunky anyway.",0.0,C++
13pd2ho,jlblp7v,Fortran?,0.0,Fortran
13pd2ho,jlafkx9,Since no one has mentioned it yet...Julia.,0.0,Julia
13pd2ho,jl9tvpy,C is bad for generics.,-0.6999999999999998,C
13pd2ho,jl9tvpy,"I mean, it pulls in the C runtime.",-0.3125,C
13pd2ho,jl9tvpy,> Basically Fortran if it was invented in 2014 instead of 1954.,0.0,Fortran
13pd2ho,jlsh3an,"It has an F#, C, and a Python backend.",0.0,C
13pd2ho,jlsh3an,"It has an F#, C, and a Python backend.",0.0,Python
13pd2ho,jl91s1c,"Zig is quite intriguing to me, as is Rust.",0.30000000000000004,Rust
13pd2ho,jl91s1c,The biggest downside I was seeing to Rust is that OpenMP/MPI support is... Not?,0.0,Rust
13pd2ho,jl91s1c,"Is Rust not an imperative, procedural language?",0.0,Rust
13pd2ho,jl9249l,"I know Ada has massively fallen out of favor, even with its creator, which is somewhat surprising if it has the listed features... Am I the only one that thinks these things would be highly desirable, or do you have any good info on why it is not used so much anymore?",0.29333333333333333,Ada
13pd2ho,jl9249l,"EDIT: This thread is ancient, but covers some of the benefits/questions I had about Ada [https://www.reddit.com/r/programming/comments/b39vd/ask\_reddit\_realworld\_c\_vs\_ada\_experiences/](https://www.reddit.com/r/programming/comments/b39vd/ask_reddit_realworld_c_vs_ada_experiences/) Sounds pretty cool tbh.",0.3,Ada
13pd2ho,jl98k91,"Well Flang, or new-flang, or whatever they want to call it - the new, not production ready, Fortran compiler for LLVM requires special compiler flags to even generate an executable.",0.23116883116883116,Fortran
13pd2ho,jl98k91,The issue is really that the standard committee governing Fortran seems to have no interest in adding features to the language that would actually improve it.,0.06666666666666667,Fortran
13pd2ho,jl98k91,They won’t fix that or add an actual ‘do parallel.’ Basically the governing body running Fortran is happy to do nothing but maintain legacy codes that are replaced by C++ more and more every year.,0.36,Fortran
13pd2ho,jl98k91,They won’t fix that or add an actual ‘do parallel.’ Basically the governing body running Fortran is happy to do nothing but maintain legacy codes that are replaced by C++ more and more every year.,0.36,C++
13pd2ho,jlsk1y1,"To follow up here, I took a look at Crystal and implemented my test code incremental prime sieve.",0.0,Crystal
13pd2ho,jlsk1y1,"For nearly the same algorithm (couldn’t figure out how to jump out of nested loops) I can generate 100-1000ish primes as quickly as Fortran (gfortran, ifort, ifx, and AOCC flang), but some inefficiency catches up for 1M-10Mish type values, and Crystal goes from 50% to 100% longer runtime.",0.14444444444444446,Fortran
13pd2ho,jlsk1y1,"For nearly the same algorithm (couldn’t figure out how to jump out of nested loops) I can generate 100-1000ish primes as quickly as Fortran (gfortran, ifort, ifx, and AOCC flang), but some inefficiency catches up for 1M-10Mish type values, and Crystal goes from 50% to 100% longer runtime.",0.14444444444444446,Crystal
13pd2ho,jlsk1y1,"Overall it seems like a pretty cool language, I just think a lot of languages try to claim “we’re as fast as C” by writing some test case in the best way possible for their new language, which so happens to correspond to a rather slow way to do things in the victim language.",0.1734848484848485,C
13pd2ho,jlsk1y1,"This happens a lot when people want to rag on Python for example, so they do some compiled language and loop a bunch, copy paste that to python and say they’re 10000% faster.",0.0,Python
13pd2ho,jlbm6y6,> Do a front-end for C++ code instead  Fortran has better array handling than C++ so maybe write a front-end for Fortran?,0.5,C++
13pd2ho,jlbm6y6,> Do a front-end for C++ code instead  Fortran has better array handling than C++ so maybe write a front-end for Fortran?,0.5,Fortran
13pd2ho,jl9tbkk,"A solution in C++ would be clunky, but that language is clunky anyway.",0.0,C++
13pd2ho,jl9tbkk,"C++ is a pig and just another 40 year old, bloated kitchen sink language.",0.1,C++
13pd2ho,jlaumgs,"It would be somewhat insulting to describe Julia as ""Fortran invented in 2014"", but FWIW I think their user base is trying to solve the same kinds of problems ie writing heavy numerical code.",-0.5,Julia
13pd2ho,jlaumgs,"It would be somewhat insulting to describe Julia as ""Fortran invented in 2014"", but FWIW I think their user base is trying to solve the same kinds of problems ie writing heavy numerical code.",-0.5,Fortran
13pd2ho,jlad3db,"Rust has all the features you mentioned (i.e ADTs, pattern matching, closures....) and still uses LLVM.",0.0,Rust
13pd2ho,jlad3db,I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,C
13pd2ho,jl93r24,"As for it being more modern, calling Rust imperative and procedural is right but falls a bit short.",0.2464285714285714,Rust
13pd2ho,jl93r24,"And there are plenty of functional idioms that are usually favored when writing idiomatic Rust over C-style flow control structures + state mutation, although it's far from being what's popularly known as a ""proper"" functional language.",0.375,Rust
13pd2ho,jl93r24,"I'd describe it as something between ""what C++ would be if designed from scratch with decades of pain as learning material"" and ""systems OCaml"".",0.0,C++
13pd2ho,jl93lno,"Early Ada compilers were expensive and often buggy, which tainted people's perception of the language.",-0.2,Ada
13pd2ho,jl93lno,"Combined with a few high profile project failures and the dominance of UNIX and C, Ada lost traction.",-0.020000000000000004,C
13pd2ho,jl93lno,"Combined with a few high profile project failures and the dominance of UNIX and C, Ada lost traction.",-0.020000000000000004,Ada
13pd2ho,jl93lno,Modern Ada is a different story.,0.1,Ada
13pd2ho,jl93lno,"Ada's certainly got some historical baggage, but it's worth a try if you're looking for a language with an emphasis on safety and maintainability.",0.1714285714285714,Ada
13pd2ho,jl9byfe,It is easy to learn for anyone who knows an ALGOL family language.,0.43333333333333335,ALGOL
13pd2ho,jl9byfe,"The rules about pointer scoping/usage are very restrictive in order to avoid dangling pointers and take some getting used to, but you don't need to use pointers nearly as often as in C since you have in/out parameters and the ability to return variable-sized arrays/objects by value from functions.",0.15000000000000002,C
13pd2ho,jl94dt4,"Ada was designed by committee *and it showed, good and hard*.",0.20416666666666664,Ada
13pd2ho,jl94dt4,"Oh, and the particular vision of object-orientation espoused by then-current Ada was totally unlike the hot, sexy C++ that was making waves in industry at the time.",0.22916666666666666,Ada
13pd2ho,jl94dt4,"Oh, and the particular vision of object-orientation espoused by then-current Ada was totally unlike the hot, sexy C++ that was making waves in industry at the time.",0.22916666666666666,C++
13pd2ho,jlt22f1,"But yea they shouldn't say things like ""fast as C"" that's dumb.",-0.0875,C
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,C
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,C++
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,JavaScript
13pd2ho,jl9zar1,"If its syntax is not an obstacle, you might look at Python, especially its Numpy add-on.",0.0,Python
13pd2ho,jl9zar1,"Python itself is dead slow, but Numpy AIUI does its array processing using fast native code libraries.",-0.09999999999999999,Python
13pd2ho,jlb11ac,I think the creators of Julia would not hate that comparison.,0.4,Julia
13pd2ho,jlb11ac,And indeed some old Fortran codebases for numerical modelling are being rewritten in Julia for easier maintenance/development,0.1,Fortran
13pd2ho,jlb11ac,And indeed some old Fortran codebases for numerical modelling are being rewritten in Julia for easier maintenance/development,0.1,Julia
13pd2ho,jlb17g9,"> Rust has all the features you mentioned (i.e ADTs, pattern matching, closures....) and still uses LLVM.",0.0,Rust
13pd2ho,jlb17g9,> I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,C
13pd2ho,jlb17g9,"I also beat C on hailstones (Collatz), Sieve of Eratosthenes, ray tracer and Ackermann.",0.0,C
13pd2ho,jl9484m,Really I am searching for something more powerful than what I can do in Fortran but not the absolute hell that is C++.,0.3,Fortran
13pd2ho,jl9484m,Really I am searching for something more powerful than what I can do in Fortran but not the absolute hell that is C++.,0.3,C++
13pd2ho,jl9484m,"Thanks for responding, I will have to give Rust a go.",0.2,Rust
13pd2ho,jlauwee,"Bear in mind I'm saying this as a long term Python fan, but I probably still wouldn't make a new whitespace sensitive language.",0.06212121212121211,Python
13pd2ho,jltw0hp,"this jumps to the next iteration of the outer NUM_CHECKER loop                     end if                 end do prime_checker                 prime_ii = prime_ii + 1                 primes(prime_ii) = num                 unprimes(prime_ii) = num             end do num_checker         else if (n.eq.1) then             primes = 2         end if     end subroutine incremental_sieve ```   In Crystal, I implemented this as: ``` def incremental_sieve(n : Int32)     primes = Array(Int32).new(n)     primes.push(2)     primes.push(3)     unprimes = Array(Int32).new(n)     unprimes.push(2)     unprimes.push(3)     prime_ii = 2     num = 3     while prime_ii < n         num = num + 2         limit = Math.sqrt(num).to_i         is_prime = true         checking_primes = true         i = 1         while checking_primes             if primes[i] > limit                 checking_primes = false             else                 while unprimes[i] < num                     unprimes[i] = unprimes[i] + primes[i]                 end                 if unprimes[i] == num                     is_prime = false                     checking_primes = false                 end                 i = i + 1             end         end         if is_prime             prime_ii = prime_ii + 1             primes.push(num)             unprimes.push(num)         end     end     return primes end ```  I needed the is_prime value since I didn't see a way to jump from the inner loop `while checking_primes` to the next iteration of my main loop `while prime_ii < n`.",-0.03703703703703706,Crystal
13pd2ho,jrqgw72,  > > I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,C
13pd2ho,jrqgw72,"I also beat C on hailstones (Collatz), Sieve of Eratosthenes, ray tracer and Ackermann.",0.0,C
13pd2ho,jt8nj02,Recursive calls could use a different ABI but C compilers tend to push all calls through the ABI even when it is really inefficient.,0.1,C
13pd2ho,jlvtwor,"In Fortran you can name the different loops, and your basic loop control \`exit\` and \`cycle\` (for \`break\` and \`next\`) can be applied to a named loop outside the currently executing one if so desired.",0.0,Fortran
13pd2ho,jlvtwor,"In C or Fortran, you can also accomplish this behavior with \`goto\`.",0.0,C
13pd2ho,jlvtwor,"In C or Fortran, you can also accomplish this behavior with \`goto\`.",0.0,Fortran
13pd2ho,jlefwyo,Go see how Algol was created to see design by committee.,0.0,Go
13p3hbq,jl7kql3,"One interesting strategy is available in Prolog, which is a dynamically typed language: In Prolog, you can *ask* the system whether certain cases can arise *at all*, by posting *queries* on the toplevel, to which the Prolog system will respond in the form of *answers*.",0.37142857142857144,Prolog
13p3hbq,jl7kql3,"This is a bit similar to what other languages (also functional languages, and also statically typed functional languages such as Haskell) call a ""REPL"", a *read-eval-print-loop*.",-0.041666666666666664,Haskell
13p3hbq,jl7kql3,"However, in Prolog, the ability to post queries goes far beyond the ""eval"" of functional languages, because in Prolog, you can *generalize* parts of the query by using logic variables instead of concrete values.",0.125,Prolog
13p3hbq,jl7kql3,""", and the Prolog systems answers ""No"", then you can rely on *all* more specific queries to also fail.",0.0,Prolog
13p3hbq,jl7kql3,"This reasoning works as long as you program in the pure core of Prolog, where such logical reasoning is admissible.",0.10357142857142856,Prolog
13p3hbq,jl7kql3,"For illustration, here is an example: Suppose we have defined a Prolog predicate called `length/2`, which is supposed to relate a list to its length.",0.0,Prolog
13p3hbq,jl7kql3,The ability to express such extremely general test cases is a major attraction of logic programming languages like Prolog.,0.037500000000000006,Prolog
13p3hbq,jl7j1xv,"For example, both Ruby and JavaScript have very strong community-driven linters that report errors without running the program.",0.5633333333333334,Ruby
13p3hbq,jl7j1xv,"For example, both Ruby and JavaScript have very strong community-driven linters that report errors without running the program.",0.5633333333333334,JavaScript
13p3hbq,jl7uy8v,"Python, are currently spending a lot of effort adding on various type systems.)",0.0,Python
13p3hbq,jl8e5xp,This has been my experience with Common Lisp.,-0.3,Lisp
13p3hbq,jlqy6rt,Erlang has exhaustive pattern matching and guards on functions.,0.0,Erlang
13p3hbq,jl8mfeg,"Additionally, Erlang has a very resilient runtime failure recovery system, which helps when errors _do_ slip through.",-0.05833333333333335,Erlang
13p3hbq,jl7xesc,See Python and Erlang's dialyzer for some examples.,0.0,Python
13p3hbq,jl7xesc,See Python and Erlang's dialyzer for some examples.,0.0,Erlang
13p3hbq,jl9ple7,```  if we were to extend the JS syntax to have Enums like in Rust ``` const (Some x) = Option.Some(20) // weird pseudo syntax ```  The fault with JS is if say XYs is not iterable it'll throw an error but it doesn't throw when XYs doesn't contain 2 elements.,-0.5,Rust
13p3hbq,jl860qo,"It's not quite ""dynamic typing"" *dynamic typing*, but you can look into what Python (and others, like TypeScript) does: gradual typing!",0.0,Python
13p3hbq,jl860qo,"It's not quite ""dynamic typing"" *dynamic typing*, but you can look into what Python (and others, like TypeScript) does: gradual typing!",0.0,TypeScript
13p3hbq,jl860qo,The reason why languages like Python and TypeScript offer gradual typing is because they have to maintain backwards-compatibility with software written without types.,0.0,Python
13p3hbq,jl860qo,The reason why languages like Python and TypeScript offer gradual typing is because they have to maintain backwards-compatibility with software written without types.,0.0,TypeScript
13p3hbq,jl8iqk6,"Just out of curiosity, I've transliterated your Prolog queries into Idris 1 (a dependently-typed language) REPL inputs to see how it fares and apart from the verbosity, it works just as well (in this specific scenario):      Idris> the (length ['a', 'b', 'c'] = 3) Refl     Refl : 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = 3) (\_, _, _, _ => Refl)     \underscore, underscore, underscore, underscore => Refl : (a : Type) -> a -> a -> a -> 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = _) (\_, _, _, _ => Refl)     ... 11 lines omitted ...         3 = ([__])  For clarification, `Idris> ` is the prompt prefix and if an expression of the form `the (… = …) Refl` comes back without a type error (and it doesn't contain any holes), then the proposition `… = …` is true.",-0.10833333333333334,Prolog
13p3hbq,jl7ub22,"TypeScript, because the abstractions leak and they're not really designed by people who understand type systems.",-0.1,TypeScript
13p3hbq,jma9mgb,Similarly Elixir which runs on the same BEAM VM as Erlang.,0.0,Elixir
13p3hbq,jma9mgb,Similarly Elixir which runs on the same BEAM VM as Erlang.,0.0,Erlang
13p3hbq,jl9hft9,"I have worked a fair bit in Erlang, and yes, immutability is great, but it mainly makes sure you can read code and won't make certain dumb mistakes.",0.3343253968253969,Erlang
13p3hbq,jl9hft9,"Erlang also has a type system now (sort of), so even if the virtual machine is dynamically typed, you can still run static analysis on the code analysing types.",0.5,Erlang
13p3hbq,jl9hft9,"Look up Erlang Dialyzer, it's a great tool.",0.8,Erlang
13p3hbq,jl8345x,"The folks behind TypeScript understand type systems very well, thank you.",-0.1,TypeScript
13p3hbq,jl8345x,"Whether those tradeoffs amount to something shitty or not is subjective, but for the most part I honestly really like it...I know Haskell, Ocaml, Coq, Idris, etc.",0.35,Haskell
13p3hbq,jl8345x,perfectly well but TypeScript is my go-to for productivity work.,1.0,TypeScript
13p3hbq,jla4m8i,"I'm certainly not saying that there isn't metaprogramming in Haskell and Rust, but it is decidedly second-class, and it is not used in the same way.",-0.05357142857142857,Haskell
13p3hbq,jla4m8i,"I'm certainly not saying that there isn't metaprogramming in Haskell and Rust, but it is decidedly second-class, and it is not used in the same way.",-0.05357142857142857,Rust
13p3hbq,jla4m8i,TH and proc macros in Rust are labor saving devices.,0.0,Rust
13p3hbq,jla4m8i,"In Ruby and CommonLisp, metaprogramming is a primary modeling tool.",0.4,Ruby
13p3hbq,jl8l0pd,"> I know Haskell, Ocaml, Coq, Idris, etc.",0.0,Haskell
13p3hbq,jl8l0pd,perfectly well but TypeScript is my go-to for productivity work.,1.0,TypeScript
13p3hbq,jl8l0pd,"The language I find most productive is actually Scala but that's mostly due to the extensive collections library, which lets you express many algorithms as high-level compositions of collection primitives.",0.175,Scala
13p3hbq,jl7l59u,"I was asking in general, but a common dynamic language I like to use is Scheme.",-0.08333333333333333,Scheme
13p3hbq,jl958a9,"There's various other ways, too, where Ocaml's rigidity makes it less pleasant than TypeScript with its extreme flexibility.",0.06333333333333332,TypeScript
13p3hbq,jl958a9,"Also, don't underestimate how powerful TypeScript can be in capable hands (namely Giulio Canti's).",0.25,TypeScript
13p2x9h,,"Of course, this isn't Haskell's monadic do syntax, but as we all know, applicatives are as good as monads.",0.7,Haskell
13p2x9h,jl9vkk2,Why does Haskell add do syntax for >>== chains?,0.0,Haskell
13p2x9h,jl9vkk2,Haskell would work fine without too.,0.4166666666666667,Haskell
13p2x9h,jl9vkk2,"In Haskell, in Ocaml, or other functional languages.",-0.125,Haskell
13p2x9h,jl9wk22,def f = (|> ((+) 1) |> ((*) 2))  It would in Haskell.,-0.25,Haskell
13o1r8a,jl2ad0r,"I have made something similar, a PicoBlaze assembler and emulator in JavaScript (can be run in a modern browser): https://flatassembler.github.io/PicoBlaze/PicoBlaze.html",0.1,JavaScript
13nyb26,jl1jvbz,I like Rust's approach.,0.0,Rust
13nyb26,jl3fezd,Elm has even better and always shows the type of the result of the evaluation.,0.5,Elm
13nyb26,jl33cl8,I thought I ran across something like a *debug-print* while (trying to) learn me a Haskell (for great good).,0.75,Haskell
13nyb26,jl2ghlc,"In C#, everything (even value types) derive from an `object` base class that implements a few important methods, including a `.ToString()` that defaults to printing the fully qualified name of the type.",-0.19999999999999998,C
13nyb26,jl4ohva,Ada has an 'Img attribute which is compiler-defined.,0.0,Ada
13nyb26,jl4prn9,"Since you already know OCaml, give Rust a try.",0.0,Rust
13nyb26,jl4prn9,"Like in Haskell, you can in Rust put a clause on the structs and suddenly your structs have new possibilities.",0.06818181818181818,Haskell
13nyb26,jl4prn9,"Like in Haskell, you can in Rust put a clause on the structs and suddenly your structs have new possibilities.",0.06818181818181818,Rust
13nyb26,jl4syzs,Rust's `dbg!,0.0,Rust
13nyb26,jl1mmpr,It seems similar to what another poster says Rust does.,0.0,Rust
13nyb26,jl4d7i0,Haskell,0.0,Haskell
13nyb26,jl2opcz,"I don't speak D, but I'm pretty sure that's wrong for debugging - we want escaped strings, among other things.",0.03125,D
13nyb26,jl3g9bc,>I thought I ran across something like a debug-print while (trying to) learn me a Haskell (for great good).,0.75,Haskell
13nyb26,jl3g9bc,Converting the value to a string to be printed uses the Show type class (similar to Debug in Rust) and is completely pure.,0.10714285714285714,Rust
13nyb26,jl2o2c6,"That said, in Java and C# it's possible to semi-automatically implement `Debug` using reflection to actually print the fields.",0.0,Java
13nyb26,jl2o2c6,"That said, in Java and C# it's possible to semi-automatically implement `Debug` using reflection to actually print the fields.",0.0,C
13nyb26,jl1wwxp,"I use Rust for like everything and I never really find it all that annoying, usually what’s more annoying is when something doesn’t implement debug, but that’s rare, most Rust devs just, derive what they need, it makes life easier, and for most use cases “it just works”.",-0.01874999999999999,Rust
13nyb26,jl1wwxp,"Like procedural macros in Rust are god tier, just, muah",0.0,Rust
13nyb26,jl9o9k2,"I think that if you're worried that adding derive would become annoying, then Rust isn't for you.",-0.8,Rust
13nyb26,jl4q55x,Don't forget Common Lisp.,-0.3,Lisp
13nyb26,jl4q55x,I'd recommend Paul Grahams ANSI Common Lisp book.,-0.3,Lisp
13nyb26,jl1x4e3,"In Rust it becomes almost instinctual, like yeah when you create a new type you usually just by default write the derives you need and forget about it",-0.05681818181818182,Rust
13nyb26,jl3ajcy,My primary language is Elixir.,0.4,Elixir
13nyb26,jl5cy4t,Yep and Rust's `dbg!` inspired Elixir's [dbg](https://elixir-lang.org/getting-started/debugging.html#dbg),0.0,Rust
13nyb26,jl5cy4t,Yep and Rust's `dbg!` inspired Elixir's [dbg](https://elixir-lang.org/getting-started/debugging.html#dbg),0.0,Elixir
13ntrt7,jl240aw,When I tried Dart once it took 6 seconds to compile Hello World.,0.0,Dart
13ntrt7,jl3fxx4,"On my much weaker machine, Tiny C can turn source code into executable binary at a speed pushing 1 million lines per second (probably several million lps on yours), and generating 5-10MB per second of native code.",0.04,C
13ntrt7,jl4utrs,> When I tried Dart once it took 6 seconds to compile Hello World.,0.0,Dart
13ntrt7,jl4kxn6,"You're seriously trying to convince me that I should get mad at the fastest compiled language implementation I have ever used (with the possible exception of Go), because I need to wait 6 seconds for a full build?",-0.15208333333333332,Go
13ntrt7,jl4kxn6,"Sure, your language and C are low level and simple enough that they don't need much computational effort to be type checked and translated to machine code, and if you're content with that, that's great!",0.2833333333333333,C
13ntrt7,jl4kxn6,Scala and GHC are slow.,-0.30000000000000004,Scala
13ntrt7,jl4kxn6,Rust is slow.,-0.30000000000000004,Rust
13ntrt7,jl53jpb,">Sure, your language and C are low level and simple enough that they don't need much computational effort to be type checked and translated to machine code, and if you're content with that, that's great!",0.24,C
13ntrt7,jl53jpb,And yet there are slow C compilers too!,-0.37500000000000006,C
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,Rust
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,Haskell
13ntrt7,jl6maue,"Generic ```ocaml let min(m, n) = if m<=n then m else n ``` is indeed not optimized, but it is still one C function call.",0.0,C
13ntrt7,jla3ij9,My favorite language is Haskell.,0.5,Haskell
13ntrt7,jl6pk95,"> Generic ocaml let min(m, n) = if m<=n then m else n is indeed not optimized, but it is still one C function call.",0.0,C
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,C
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,D
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Dart
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Go
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Java
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Julia
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,Rust
13ntrt7,jl9ry7y,(A C++ test would have just used the same C test code.),0.0,C++
13ntrt7,jl9ry7y,(A C++ test would have just used the same C test code.),0.0,C
13ntrt7,jla45l3,"I went with the approach from [Practical type inference for arbitrary rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf) (which is also the one taken by GHC), except that mine doesn't do deep subsumption (even the authors of that paper view its introduction as a mistake now and modern Haskell doesn't include it anymore) and is constraint based rather than immediately performing unification.",-0.175,Haskell
13nht65,,* [Game Code](https://github.com/kjosib/sophie/blob/main/examples/guess_the_number.sg) written in Sophie * [Teletype Declarations](https://github.com/kjosib/sophie/blob/main/sophie/sys/teletype.sg) also in Sophie * [Teletype Adapter](https://github.com/kjosib/sophie/blob/main/sophie/adapters/teletype_adapter.py) Python module  I've modeled these I/O actions as a variant-record type with four cases:  * `done` is the stopped process.,-0.4,Python
13nht65,,## Taking this to the next level  Python's PRNG is pretty excellent.,0.4166666666666667,Python
13nht65,,"Supposing I pass the `teletype_adapter` a functional-process that emits numbers, I can just call that function instead of the Python PRNG from within the `teletype_adapter` module.",0.0,Python
13nht65,jl5q6bs,"This could be applied as a twist on Rust's ownership for example, once the variable is sent in a function its ownership is ""abandoned"" instantly and all you are left with is a handle to a new state.",0.04545454545454545,Rust
13nd9di,jkzf7ua,">Matches C execution speed, occasionally Bolin is faster  I am new to this programming languages thing.",0.06818181818181818,C
13nd9di,jl3ct3n,"I just extracted the files into `C:\bolin` under Windows, then switched to WSL and went to the `bolin\linux\bin` directory where there was an executable.",0.0,C
13nd9di,jl3ct3n,"If it can use a tcc backend, that sounds like it uses C intermediates, therefore gcc could work too (and there should be a option to just produce the C file).",0.0,C
13nd9di,jkzh2ai,"Our standard library has a few functions that may inline where C and C++ standard library does not, and no copying on fread/fgets https://bolinlang.com/more_optimal_standard  For the most part they're roughly the same speed",0.03333333333333333,C
13nd9di,jkzh2ai,"Our standard library has a few functions that may inline where C and C++ standard library does not, and no copying on fread/fgets https://bolinlang.com/more_optimal_standard  For the most part they're roughly the same speed",0.03333333333333333,C++
13nd9di,jl2267c,"I'm not experienced with that, but I'm curious to know a) how it works and b) how it differs from Rust.",-0.25,Rust
13nd9di,jl4z8sk,"For example, you mention that it makes use of tcc, which means that it uses intermediate C?",0.0,C
13nd9di,jl4z8sk,"But is that Clang used for processing LLVM stuff, or processing C source code?",0.0,C
13nd9di,jl50ohz,"Since I now know where `mm.exe` lives, in `C:\m\bin\` (or I can use `C:/m/bin/` internally), I can use that path (say I store it in `homepath`), to access a dependency such as `homepath + ""mm_help.txt""`, or `homepath+""../lib/etc...""`.",0.0,C
13nd9di,jl5rza3,I didn't want to write a plain C version since AVX2 has been supported for over a decade.,-0.21428571428571427,C
13nb6tq,,"// single digit error             case +1:             case -1:             case +10:             case -10:             case +100:             case -100:             printf(""Almost there, you'll get it next time!\n"");         }     }  Yes, this actually works in C and C++ 😂 I wonder if that is by design or accident?",-0.023809523809523808,C
13nb6tq,,"// single digit error             case +1:             case -1:             case +10:             case -10:             case +100:             case -100:             printf(""Almost there, you'll get it next time!\n"");         }     }  Yes, this actually works in C and C++ 😂 I wonder if that is by design or accident?",-0.023809523809523808,C++
13nb6tq,jl06dmm,"lets you do stuff like this: ```c switch(x){    ...    if(0){      case 1:; //initialization specific to 1    }    if(0){      case 2:; //initialization specific to 2    }    // logic shared by 1,2    break;    ... } ``` Yes, it definitely IS ugly, but in some places, especially in language like C where it's problematic to use lambdas for sophisticated code organization, it can help with keeping DRY.",-0.04444444444444443,C
13nb6tq,jl0fx4d,">language like C where it's problematic to use lambdas for sophisticated code organization, it can help with keeping DRY.",0.21666666666666667,C
13nb6tq,jl0fx4d,"I don't have a solution right now except for this which works for a few use-cases (here, it permanently jumps like the C example, it doesn't return):      case x                  # more general form of switch     when 1 then println ""one"";  recase 3     when 2 then println ""two"";  recase 3     when 3 then println ""three""     ...  (\*\* Actually from this perspective it doesn't sound too bad!",0.022959183673469403,C
13nb6tq,jl0fx4d,"Compared to that C `switch` example, it's the picture of elegance.",0.0,C
13nb6tq,jl156pk,"In C#, I'd just put that `print(""three"")` inside a delegate or local function and then invoke it at the end of `case 1`, `case 2`.",0.0,C
13nb6tq,jl156pk,"In C, one could ofc just make a macro and use it in the same way (I guess compiler would probably de-duplicate the code back tbh, but it still would be a terrible code smell because global macro namespacing and everything xD )  `recase` is a pretty interesting concept.",-0.041666666666666664,C
13n8v25,jky8bmy,(The C language also have \ line continuation that is something extra to complicate code - stay away from this kind of problem !),0.375,C
13n8v25,jkyhl86,That could in theory be done in lots of separate stages (the C standard is defined as though that happens).,0.0,C
13n8v25,jkygm5k,C's `\` line continuation is weirder than many realise.,0.5,C
13n8v25,jkygm5k,"My C lexer didn't bother with this (I didn't know about it), but if needed, there is an optional separate pass to splice lines split with `\`, then normal lexing is done on that.",0.15,C
13n8v25,jkyy3p7,```c #define M\ ACRO 1  MACRO ``` expands to 1.  https://godbolt.org/z/Ta156Pr5s  this is insane and should be removed from C.,-1.0,C
13n7lb8,jkz3nhx,What do you think of [Tutorial D](https://www.dcs.warwick.ac.uk/~hugh/TTM/DBE-Chapter11.pdf)?,0.0,D
13n7lb8,jloffqs,"This ""D"" is a specification of features for a family of languages, while TutorialD is a particular quick-and-dirty-ish implementation for use in teaching classes about relational algebra.",0.16666666666666666,D
13n7lb8,jloffqs,"Links to that and other implementations can be found here: [https://www.dcs.warwick.ac.uk/\~hugh/TTM/projects.html](https://www.dcs.warwick.ac.uk/~hugh/TTM/projects.html)  Also my Tailspin language has tried to take influences from the ""D"" specification, although I don't pretend to follow it entirely, and it is still incomplete (no connection to databases, no specific filtering syntax) [https://github.com/tobega/tailspin-v0/blob/master/TailspinReference.md#relations](https://github.com/tobega/tailspin-v0/blob/master/TailspinReference.md#relations)  I'll certainly promote the idea that having relations and relational algebra in a language is very useful.",-0.045119047619047614,D
13n7lb8,jkz0o47,APL,0.0,APL
13morox,jl5ygm0,"> They (Taffy) just ask you to write Rust, and we ask you to learn much easier fastn lang (https://fastn.com/ftd/)  > ftd is designed for everyone, not just programmers.",0.2,Rust
13lzxgd,jksuoyw,"Generics in Rust and especially C++ are slow, because they are implemented via momomorphization, i.e.",-0.15000000000000002,Rust
13lzxgd,jksuoyw,"Generics in Rust and especially C++ are slow, because they are implemented via momomorphization, i.e.",-0.15000000000000002,C++
13lzxgd,jksuoyw,"C++ is especially bad in this regard, since it needs to re-typecheck every single instantiation.",-0.5357142857142857,C++
13lzxgd,jksuoyw,"But Generics in Java, OCaml, Haskell, or most high level langauges for that matter don't slow down compilation.",0.0511111111111111,Java
13lzxgd,jksuoyw,"But Generics in Java, OCaml, Haskell, or most high level langauges for that matter don't slow down compilation.",0.0511111111111111,Haskell
13lzxgd,jksuoyw,"Value types are not heap alllocated, so these are compiled via monomorphization like in C++ and Rust, with the caveat, that they are monomorphized *lazily at runtime*.",-0.25,C++
13lzxgd,jksuoyw,"Value types are not heap alllocated, so these are compiled via monomorphization like in C++ and Rust, with the caveat, that they are monomorphized *lazily at runtime*.",-0.25,Rust
13lzxgd,jkst0hi,"This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,Rust
13lzxgd,jkst0hi,"This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,C++
13lzxgd,jktghpf,"The C++ compiler has to work with human-readable text, which adds some overhead.",0.0,C++
13lzxgd,jktghpf,Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C
13lzxgd,jktghpf,Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C++
13lzxgd,jktghpf,"For example, in C++, `std::array<int, 1>` and `std::array<int, 2>` are different types, while C# has no equivalent of that and you would just use `int[]` for both.",0.0,C++
13lzxgd,jktghpf,"For example, in C++, `std::array<int, 1>` and `std::array<int, 2>` are different types, while C# has no equivalent of that and you would just use `int[]` for both.",0.0,C
13lzxgd,jktghpf,"Or take `Compare` of `std::map`, which is a template parameter, while in C# the equivalent would use an `IComparer<T>` object, so the type of the collection stays the same.",0.0,C
13lzxgd,jku5saj,C++ and Rust are extremely slow at compiling generic functions.,-0.15000000000000002,C++
13lzxgd,jku5saj,C++ and Rust are extremely slow at compiling generic functions.,-0.15000000000000002,Rust
13lzxgd,jku5po7,The story for Java is a lot deeper than that.,0.0,Java
13lzxgd,jkv5ot0,It's worth noting that most of those things you talk about in Java etc.,0.4,Java
13lzxgd,jkv5ot0,"Notably this implies *not* doing type-erasure like Java does - instead, pass the vtables at runtime as an extra argument.",0.25,Java
13lzxgd,jkw47jy,"> C++ is especially bad in this regard, since it needs to re-typecheck every single instantiation.",-0.5357142857142857,C++
13lzxgd,jkw47jy,"Quick note about C++ compilation, type-checking of generics is done in two passes:   1.",0.3333333333333333,C++
13lzxgd,jkvwu25,I don't buy that it is slow to compile; the compilers for Rust and C++ that have been mentioned are slow anyway for lots of other reasons.,-0.2416666666666667,Rust
13lzxgd,jkvwu25,I don't buy that it is slow to compile; the compilers for Rust and C++ that have been mentioned are slow anyway for lots of other reasons.,-0.2416666666666667,C++
13lzxgd,jkvwu25,"After all languages where you have to do manual monomorphisation, like C, are not slow to compile.",0.15000000000000002,C
13lzxgd,jkw4df9,"> This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,Rust
13lzxgd,jkw4df9,"> This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,C++
13lzxgd,jkw4df9,AFAIK the Rust compiler already performs a few (lightweight) optimizations on the generic code itself (at MIR level) prior to generating the backend IR for each set of generic arguments and handing it off to the backend.,-0.05,Rust
13lzxgd,jku55mq,"> The C++ compiler has to work with human-readable text, which adds some overhead.",0.0,C++
13lzxgd,jku55mq,At least on my own benchmark suite .NET is competitive with C++ on register heavy tests (sometimes beating C++) and generally loses out on memory intensive tasks.,-0.05,C++
13lzxgd,jku55mq,> Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C
13lzxgd,jku55mq,> Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,C++
13lzxgd,jku55mq,"For example, in C++, std::array<int, 1> and std::array<int, 2> are different types, while C# has no equivalent of that and you would just use int[] for both.",0.0,C++
13lzxgd,jku55mq,"For example, in C++, std::array<int, 1> and std::array<int, 2> are different types, while C# has no equivalent of that and you would just use int[] for both.",0.0,C
13lzxgd,jku55mq,"C# specifically has `int[,]` for 2D arrays.",0.0,C
13lzxgd,jku55mq,"> Or take Compare of std::map, which is a template parameter, while in C# the equivalent would use an IComparer<T> object, so the type of the collection stays the same.",0.0,C
13lzxgd,jku55mq,Conversely you have .NET's `Dictionary` where its monomorphization generally seems to produce faster code than C++ hash tables AFAICT.,0.05000000000000002,C++
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,C++
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,Rust
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,C
13lzxgd,jku72p4,"The important difference between Java and C# is that in Java, monomorphization is an Optimization, while in C#, it is a compilation strategy.",0.4,Java
13lzxgd,jku72p4,"The important difference between Java and C# is that in Java, monomorphization is an Optimization, while in C#, it is a compilation strategy.",0.4,C
13lzxgd,jku72p4,"This manifests in the fact that Java does not allow polymorphic functions over value types, because it cannot compile them via the usual generic compilation.",-0.125,Java
13lzxgd,jku72p4,"In fact, AOT compiled languages like Haskell also employ monomorphization as an optimization, though not nearly as thoroughly as in JIT compilers (it's usually called Specialization when it's just an optimization, at least in the Haskell world)",-0.19999999999999998,Haskell
13lzxgd,jkw50dt,"> After all languages where you have to do manual monomorphisation, like C, are not slow to compile.",0.15000000000000002,C
13lzxgd,jkw50dt,"I remember a talk from Bryan Cantrill, where he explained learning Rust by naively translating a C program he had.",-0.3,Rust
13lzxgd,jkw50dt,"I remember a talk from Bryan Cantrill, where he explained learning Rust by naively translating a C program he had.",-0.3,C
13lzxgd,jkw50dt,"After he was done -- ie, the Rust program was compiling and seemingly working as the C program had -- he checked the performance and was surprised that the Rust program outperformed the C one, when the former had not been optimized.",0.05,Rust
13lzxgd,jkw50dt,"After he was done -- ie, the Rust program was compiling and seemingly working as the C program had -- he checked the performance and was surprised that the Rust program outperformed the C one, when the former had not been optimized.",0.05,C
13lzxgd,jkw50dt,"Wanting to understand how that came to be, he profiled both, and realized that his C program used hand-written data-structures that had been selected for their simplicity -- since they had been re-implemented in the program -- and that were type-erased.",0.0,C
13lzxgd,jkw50dt,"In contrast, the Rust program relied on the standard data-structures: generic, highly tuned, etc...",0.05333333333333334,Rust
13lzxgd,jkva4fq,">C# specifically has int[,] for 2D arrays.",0.0,C
13lzxgd,jlb3iat,"Actually, something I'd like to see explored -- though it's likely easier in Rust than C++^1 -- is _partial_ monomorphization.",-0.03333333333333333,Rust
13lzxgd,jlb3iat,"^1 _The C and C++ standards mandate that different functions, which includes different template instantiations of a template function, have a distinct address.",0.09999999999999999,C
13lzxgd,jlb3iat,"^1 _The C and C++ standards mandate that different functions, which includes different template instantiations of a template function, have a distinct address.",0.09999999999999999,C++
13lzxgd,jkwklwv,"It may be [The Summer of Rust, August 2018](https://www.youtube.com/watch?v=YKv_IDN0zCA), an informal talk (no slide, just him sitting on a chair) as it seems to be his first talk about Rust according to http://dtrace.org/blogs/bmc/2018/02/03/talks/.",0.25,Rust
13lzxgd,jkwklwv,> Cantrill appears to be a Rust evangelist so it would be surprising if he'd chosen an example that performed worse in Rust!,0.09999999999999998,Rust
13lzxgd,jkwklwv,"He didn't use to be, Cantrill used to work for Sun Microsystems then Oracle, nigh exclusively in C. This was his first foray in Rust, and he was clearly skeptic; he'd old enough to have seen many ""C-killers"" after all.",0.19,Rust
13lzxgd,jkwklwv,> My brief experience with Rust seemed to show that Debug mode produced code that was 10 times slower then Release mode; was that non-optimised version using Debug mode?,0.0,Rust
13lzxgd,jkwklwv,"Rust and C++ are on par, typically.",-0.16666666666666666,Rust
13lzxgd,jkwklwv,"Rust and C++ are on par, typically.",-0.16666666666666666,C++
13lyst8,jkshc2t,"Java, however, proves that even if you're stuck with shitty stack-based *bytecode* for legacy-loading reasons, it's still possible to turn it into register-based code for interpretation.",0.15,Java
13lyst8,jksvanv,"Anton Ertl has written several papers about this kind of optimisation in the context of Forth, which you may find useful.",0.3,Forth
13lyst8,jktbmks,"(If transpiled to C, where it ends up as a regular `switch` inside a loop, then `gcc-O3` can't manage any better.)",0.25,C
13lta2u,jkrgchf,Nitpick: you wrote ASCI C instead of ANSI C,0.0,C
13lta2u,jkrowdd,> A lot of programming/developer jobs also refer to C/C++ when they need a programmer who knows either C or C++.,0.0,C
13lta2u,jkrowdd,> A lot of programming/developer jobs also refer to C/C++ when they need a programmer who knows either C or C++.,0.0,C++
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,C
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,Haskell
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,Prolog
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C++
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,Go
13lta2u,jkrowdd,"So should I refer to Zig, Go, and Nim as C/Zig, C/Go, and C/Nim?",0.0,Go
13lta2u,jkrl9s7,"That, and most jobs I’ve had that advertised needing C/C++ was because it was an old and/or mixed bag of both legacy C code, and C++ so why not?",0.19999999999999998,C
13lta2u,jkrl9s7,"That, and most jobs I’ve had that advertised needing C/C++ was because it was an old and/or mixed bag of both legacy C code, and C++ so why not?",0.19999999999999998,C++
13lta2u,jkrl9s7,“If you’re a C programmer say you’re a C programmer” is lame as it seems to suggest that it’s like an identity rather than a skill you have.,-0.5,C
13lta2u,jkrl9s7,"For instance, I professionally work with C/C++/Python and Rust.",0.1,Rust
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,C++
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,Go
13lta2u,jkt0d5o,"So should I refer to Zig, Go, and Nim as C/Zig, C/Go, and C/Nim?",0.0,Go
13lta2u,jkt0d5o,"It's a subset because you can literally copy-paste (most) C into C++, change imports a bit, and it will compile (and usually run) in exactly the same way.",0.125,C
13lta2u,jkt0d5o,"It's a subset because you can literally copy-paste (most) C into C++, change imports a bit, and it will compile (and usually run) in exactly the same way.",0.125,C++
13lta2u,jkt0d5o,"What's not a joke is you can take basically any reasonable C program, only change headers and imports, and get a working C++ program.",0.1,C
13lta2u,jkt0d5o,"What's not a joke is you can take basically any reasonable C program, only change headers and imports, and get a working C++ program.",0.1,C++
13lta2u,jkt0d5o,"The real reason C and C++ are lumped together as C/C++ is because they, although different languages, have more in common than any other (related) language.",0.04583333333333333,C
13lta2u,jkt0d5o,"The real reason C and C++ are lumped together as C/C++ is because they, although different languages, have more in common than any other (related) language.",0.04583333333333333,C++
13lta2u,jkrg784,"I definitely agree, but article talks about scaring off C programmers...",0.0,C
13lta2u,jkrg784,"I had an interview last week for a C programming job, doing a bunch of complicated vector math.",-0.25,C
13lta2u,jksfly4,"Obviously these are different languages now, but I will keep saying C/C++ for as long as C++ programmers expect that standard platform `.h` header files can be interpreted as C++ declarations.",-0.0125,C++
13lta2u,jksfly4,"It's not unusual for various languages to be able to ingest C declarations in order to facilitate FFI, but C++ is unique in not using a dedicated facility for this, but instead hoping that the header file will contain only constructs that are valid C++ - and very likely also additional `extern ""C""`annotations!",0.12916666666666668,C
13lta2u,jksfly4,"It's not unusual for various languages to be able to ingest C declarations in order to facilitate FFI, but C++ is unique in not using a dedicated facility for this, but instead hoping that the header file will contain only constructs that are valid C++ - and very likely also additional `extern ""C""`annotations!",0.12916666666666668,C++
13lta2u,jksfhsd,"Everyone who vehemently shouts about how C and C++ are very different are technically correct, but not correct enough for me to give a shit.",-0.05,C
13lta2u,jksfhsd,"Everyone who vehemently shouts about how C and C++ are very different are technically correct, but not correct enough for me to give a shit.",-0.05,C++
13lta2u,jksfhsd,"""C/C++"" is code for ""you know C++ but aren't gonna whine when you see a malloc.""",0.0,C++
13lta2u,jkrw0z4,In the end C++ still has the allmost-full C compatibility.,0.0,C++
13lta2u,jkrw0z4,In the end C++ still has the allmost-full C compatibility.,0.0,C
13lta2u,jkrw0z4,An other issue seems to be that C and C++ are the two ends of a dialect continuum and some people just choose to sit in the middle.,-0.0625,C
13lta2u,jkrw0z4,An other issue seems to be that C and C++ are the two ends of a dialect continuum and some people just choose to sit in the middle.,-0.0625,C++
13lta2u,jkrw0z4,I do agree that quite a few C/C++ arguments are not really about C/C++ but more about just C and one should cover C++ specifically sometimes.,0.06666666666666665,C
13lta2u,jkrw0z4,I do agree that quite a few C/C++ arguments are not really about C/C++ but more about just C and one should cover C++ specifically sometimes.,0.06666666666666665,C++
13lta2u,jkrw0z4,In C++ this is mostly automatic (but unsafe with respect to dangling pointers) while in C it is mostly manual.,0.5,C++
13lta2u,jkrw0z4,In C++ this is mostly automatic (but unsafe with respect to dangling pointers) while in C it is mostly manual.,0.5,C
13lta2u,jkrw0z4,Most memory bugs are due to particularities of using either C or C++ and don't show up so much in the other.,0.11249999999999999,C
13lta2u,jkrw0z4,Most memory bugs are due to particularities of using either C or C++ and don't show up so much in the other.,0.11249999999999999,C++
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,C
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,C++
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,R
13lta2u,jksdnbw,"By this logic, Python 3 is limited because it's not compatible with Python 2.",-0.07142857142857142,Python
13lta2u,jkuz44k,Isn’t C/C++ really just C++?,0.2,C++
13lta2u,jkw3j27,I'll stop saying C/C++ when C++ is weaned from C.  How do you communicate over the network with C++?,0.0,C++
13lta2u,jkw3j27,"Hence, communicating over the network -- which, frankly, most applications tend to do nowadays -- requires writing C code.",0.5,C
13lta2u,jkw3j27,"And as long as that's the case, it means programming in C++ requires a working knowledge of C programming, to work as C/C++ programmers on C/C++ codebases.",-0.05,C++
13lta2u,jkw3j27,"And as long as that's the case, it means programming in C++ requires a working knowledge of C programming, to work as C/C++ programmers on C/C++ codebases.",-0.05,C
13lta2u,jkw3j27,"_And yes, it saddens me, I was hoping that C++17 introducing `<filesystem>` meant the end of mandatory C in C++ was nigh, but here we are, 6 years later..._",0.0,C
13lta2u,jkw3j27,"_And yes, it saddens me, I was hoping that C++17 introducing `<filesystem>` meant the end of mandatory C in C++ was nigh, but here we are, 6 years later..._",0.0,C++
13lta2u,jksacsb,Well we mix C and C++ very freely based on what we need.,0.52,C
13lta2u,jksacsb,Well we mix C and C++ very freely based on what we need.,0.52,C++
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,Python
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,C
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,C++
13lta2u,jkrpgvy,"To be fair, he wrote the C in ASCII.",0.7,C
13lta2u,jkwyqno,"But I guess if you mean nemory unsafe languages with a C style syntax, I can only think of C and C++.",-0.15625,C
13lta2u,jkwyqno,"But I guess if you mean nemory unsafe languages with a C style syntax, I can only think of C and C++.",-0.15625,C++
13lta2u,jksgl6b,"It is not at all that strange, less strange than Java/C# imo considering that the two ecosystems there are completely different, whereas there's a huge amount of ecosystem overlap with C and C++.",0.026666666666666682,C
13lta2u,jksgl6b,"It is not at all that strange, less strange than Java/C# imo considering that the two ecosystems there are completely different, whereas there's a huge amount of ecosystem overlap with C and C++.",0.026666666666666682,C++
13lta2u,jksgl6b,"Same build tools, each consuming libraries written by the other with light opaque TU boundary interfaces or convenience layers, thanks to a certain degree of source compatibility (not like Zig, which supports converting C declarations into Zig declarations via a special directive @cImport, fundamentally different from the level of compatibility between C and C++).",0.14948979591836736,C
13lta2u,jksgl6b,"Same build tools, each consuming libraries written by the other with light opaque TU boundary interfaces or convenience layers, thanks to a certain degree of source compatibility (not like Zig, which supports converting C declarations into Zig declarations via a special directive @cImport, fundamentally different from the level of compatibility between C and C++).",0.14948979591836736,C++
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,C
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,C++
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,Rust
13lta2u,jkt4d7m,[C Is Not a Low-Level Language](https://queue.acm.org/detail.cfm?id=3212479),0.0,C
13lta2u,jkrjcwa,"while I understand why people enjoy programming in C, that sounds like a really bad decision if they actually want to get anything done",-0.09999999999999994,C
13lta2u,jksczy6,"Unfortunately, even using modern C++, it is still *really* easy to mess things up.",-0.010416666666666657,C++
13lta2u,jksczy6,"With C++, you get the illusion of safety with little actual added safety.",-0.09375,C++
13lta2u,jkw0o5n,"First of all, not all C code compiles in C++.",0.25,C
13lta2u,jkw0o5n,"First of all, not all C code compiles in C++.",0.25,C++
13lta2u,jkw0o5n,"2nd of all, if you write C++ code that would be fully valid C, you're not a good C++ programmer (with the obvious exceptions).",-0.11666666666666665,C++
13lta2u,jkw0o5n,"2nd of all, if you write C++ code that would be fully valid C, you're not a good C++ programmer (with the obvious exceptions).",-0.11666666666666665,C
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,C
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,C++
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,Java
13lta2u,jks2bwn,"True, their C skills are rusty",0.35,C
13lta2u,jksd4pw,> Rust programmers who have no interest making a 30 year step backwards.,0.0,Rust
13lta2u,jksftgb,I don't think C++ is save.,0.0,C++
13lta2u,jksftgb,"But its memory management works very different from C, with some pros and cons.",0.0,C
13lta2u,jkw0h5e,C++?,0.0,C++
13lta2u,jkrop3t,"Which is why I was interrogating their choice of C. They could get identical performance and much better ergonomics with C, but the founder was fresh out of school when he started the codebase, was only exposed to gamedev C++ (its own trash dialect), and has a bunch of wrong-headed misconceptions about C++.",0.35,C
13lta2u,jkrop3t,"Which is why I was interrogating their choice of C. They could get identical performance and much better ergonomics with C, but the founder was fresh out of school when he started the codebase, was only exposed to gamedev C++ (its own trash dialect), and has a bunch of wrong-headed misconceptions about C++.",0.35,C++
13lta2u,jkrvfde,"What's more, I _can_ use an existing template expression library in C++.",0.5,C++
13lta2u,jkrvfde,"In C, I have to further doom the ergonomics by switching to pointers and temporaries.",0.0,C
13lta2u,jks3mb7,It's not just a bad reason; it's an invalid reason because memory management in C++ can trivially be just as manual as it is in C. Even Rust gives you the same level of control if you want to opt out of all the higher-level primitives for managing memory.,-0.3499999999999999,C++
13lta2u,jks3mb7,It's not just a bad reason; it's an invalid reason because memory management in C++ can trivially be just as manual as it is in C. Even Rust gives you the same level of control if you want to opt out of all the higher-level primitives for managing memory.,-0.3499999999999999,Rust
13lta2u,jkrpu0e,You're making a stronger case for C over C++ than you might think.,0.0,C
13lta2u,jkrpu0e,You're making a stronger case for C over C++ than you might think.,0.0,C++
13lta2u,jkrpu0e,"The compiler might do that on -ffast-math, but it probably wont: the only way to really guarantee those kinds of performance characteristics is to use the compiler intrinsics directly, and then you are de facto programming in C.   Sure, there are C++ libraries for SIMD operations, but if you're doing this kind of very high-performance SIMD stuff, it's an entirely reasonable decision to say ""we need very low-level control of how to optimize this stuff, so we use the intrinsics directly"".",0.23333333333333328,C++
13lta2u,jkruiqm,My issue wasn't that they were using C. It isn't _wrong_ to use C for this shit.,-0.35,C
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,C
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,C++
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,Rust
13lta2u,jkruiqm,"But if you're giving up ergonomics, it's not an acceptable answer to say ""we chose C because we wanted to manually manage our memory"".",0.0,C
13l5mq9,jkpue4y,"As an example, he said C++ almost had `auto` in its first version.",0.25,C++
13l5mq9,jkpue4y,"Due to ruining compatibility with C, it didn't make the cut.",-0.125,C
13l5mq9,jkpue4y,"His talks usually deal with the design of C++ both past, present, and future)  I realize a language could be created as a specific tool for a specific job, doing it better than more generic languages.",0.05555555555555555,C++
13l5mq9,jkqfwhr,Some examples I can think of are:  -	Rust’s phenomenal of algebraic data types and pattern matching taken from the functional world.,0.5,Rust
13l5mq9,jkqfwhr,-	Go’s concurrency model that makes threading so much nicer to use.,0.2,Go
13l5mq9,jkqfwhr,-	Python has picked up types and pattern matching.,0.0,Python
13l5mq9,jkqfwhr,"-	Rust and Swift have Macro/DSL support built in, allowing different languages to be written inside of the host language, which has a lot of useful cases.",0.15,Rust
13l5mq9,jkqfwhr,"-	Rust and Swift have Macro/DSL support built in, allowing different languages to be written inside of the host language, which has a lot of useful cases.",0.15,Swift
13l5mq9,jkw2o0g,"Rust's borrow-checking may have been based on Cyclone's region management, but it's still quite a leap, and is continuously being refined.",0.0,Rust
13l5mq9,jkw2o0g,An excellent demonstration is actually C++: it's a blob of many organically tacked together features with many subtle and baffling interactions between them.,0.33333333333333337,C++
13l5mq9,jkqkk8y,"If you look at your pattern matching example, I found:  > Early programming languages with pattern matching constructs include COMIT (1957), SNOBOL (1962), Refal (1968) with tree-based pattern matching, Prolog (1972), SASL (1976), NPL (1977), and KRC (1981).",0.3,Prolog
13l5mq9,jkqkk8y,The concept of a macro surely isn't new as we have the example of C macros.,0.13636363636363635,C
13l5mq9,jkrwlo4,"For example, very few languages support higher-kinded types, type-level programming like in TypeScript is super rare, and many or most mainstream languages support either nominal or structural types, but not both.",0.27466666666666667,TypeScript
13l5mq9,jkrwlo4,(And here I’m considering Haskell “mainstream”.),0.0,Haskell
13l5mq9,jkrwlo4,"It’s my position that programming is still in its infancy, and that most of our current languages are as primitive compared to where we’ll be in 50 years as C and Fortran are when compared to now.",0.25,C
13l5mq9,jkrwlo4,"It’s my position that programming is still in its infancy, and that most of our current languages are as primitive compared to where we’ll be in 50 years as C and Fortran are when compared to now.",0.25,Fortran
13l5cun,,"The last year I was implementing the compiler for a very basilar programming language with the rust-style syntax but c-style semantic, basically a C with generics.",0.1,C
13l5cun,,"My goal was to get a modernized version of C, but with a blazing compiler and I achieved impressive performance (about 3mln loc/s turned into special bytecode i used).",0.6785714285714286,C
13l5cun,,"(Please note that the examples in the code snippets are useful to give the idea, they are not extracted from any existing code)  I think this behavior is due to the lack of forward declarations in C which makes inline not always possible when using functions defined in .o and declared in .h (I'm aware of linktime inline, but that's not the point).",0.10625,C
13l5cun,jkojrtn,"If you had used C++ instead of C you would likely have gotten such a ""return value optimization"" guaranteed for free, or could have used placement-new to construct the object in an existing location.",0.13333333333333333,C++
13l5cun,jkojrtn,"If you had used C++ instead of C you would likely have gotten such a ""return value optimization"" guaranteed for free, or could have used placement-new to construct the object in an existing location.",0.13333333333333333,C
13l5cun,jkojrtn,"Aside from that, there's no fundamental reason why      Type create();      ...     value = create();  should be slow, assuming that the Type is trivially copyable (in C++ parlance) and that a suitable calling convention is used.",0.125,C++
13l5cun,jkojrtn,self-referential structs (which is the actual reason why RVO matters in C++).,0.0,C++
13l5cun,jkudh7s,"IMHO, this is a place where many ABIs suck and many C and C++ compilers suck and they all leave a *lot* of performance on the table as a consequence.",0.5,C
13l5cun,jkudh7s,"IMHO, this is a place where many ABIs suck and many C and C++ compilers suck and they all leave a *lot* of performance on the table as a consequence.",0.5,C++
13l5cun,jkudh7s,those that cannot be called via a C ABI) to adhere to the C ABI.,0.0,C
13l5cun,jkp9btg,>I think this behavior is due to the lack of forward declarations in C which makes inline not always possible when using functions defined in .o and declared in .h  To be able to inline requires the source code of the function to be visible.,0.125,C
13l5cun,jkohjb8,"In C, the functions you've demonstrated should compile the same way, and it's not even an optimization, but part of the standard.",0.0,C
13l5cun,jkohjb8,So in C (and C++) it should have no performance difference whatsoever.,0.0,C
13l5cun,jkohjb8,So in C (and C++) it should have no performance difference whatsoever.,0.0,C++
13l5cun,jkon2po,"> The standard literally specifies  To be pedantic, the C standard does no such thing, but then again the C standard also pretends that things such as the ""stack"" don't exist.",0.0,C
13l5cun,jkv2plw,"Calling an object ""self"" within functions that are method-like on that object is a pretty common convention in C, enough so that I'd call it idiomatic.",-0.016666666666666663,C
13k8d8k,jkjyv3b,"You are the letlang guy, the one that also did an article on the Rust parsing ecosystem!",0.0,Rust
13k8d8k,jklr5a0,"> an article on the Rust parsing ecosystem  I'd be much interested in a link to the article, I couldn't find it.",0.25,Rust
13jvof8,jkihrpn,„Can you help me debug my shunting yard?“ - moved to Trains and Locomotives Stack Exchange :D,1.0,D
13j3u3m,jkig3oq,"I don't envision Futhark running a pacemaker or a nuclear power plant, but then again they put Ada on the Arianne V rocket, and we know how that went.",0.0,Ada
13j3u3m,jkih7ea,"If you want to take a Lisp perspective (always good for the soul), it's more that sizes are *quoted expressions*.",0.6,Lisp
13j3u3m,jkih7ea,in Lisp `(= '(+ 1 2) '(+ 2 1))` is false.,-0.4000000000000001,Lisp
13iqrlm,,"To recap, for anyone who's so far managed to avoid learning how Charm works --- it embodies the [Functional Core/Imperative Shell](https://github.com/tim-hardcastle/Charm/blob/main/docs/functional-core-imperative-shell.md) pattern, in that the language is divided into commands (which have effects but don't return values) and functions (which return values but don't have effects).",0.1,Shell
13iqrlm,,"Which leaves me with the idea of commands explicitly importing globals, as in `global x`, as in Python.",0.0,Python
13iqrlm,,"I realize this is a much-hated feature of Python, and I don't have to imitate its semantics exactly, I could make it so you have to import a global both to set and to get it, if y'all think that that would be better.",0.25,Python
13iqrlm,jkbio6c,"Python sort of half-way gets away with it create-by-assign by requiring `global` or `nonlocal` statements to mutate these, but in practice declaring variables is the only way to stop typo-assignment.",0.0,Python
13iqrlm,jkduqkb,"Scheme does this in hygienic macros, IIUC, and you can do it in Common Lisp with a macro like `with-gensym` or `with-unique-names`, using `[gensym](http://clhs.lisp.se/Body/f_gensym.htm)`.",-0.3,Scheme
13iqrlm,jkduqkb,"Scheme does this in hygienic macros, IIUC, and you can do it in Common Lisp with a macro like `with-gensym` or `with-unique-names`, using `[gensym](http://clhs.lisp.se/Body/f_gensym.htm)`.",-0.3,Lisp
13iqrlm,jkhqzyf,"I'd suggest using dynamic variables, as are found in Common Lisp; all are declared ahead of use and globally, but their values can be overridden within a scope.",-0.09999999999999999,Lisp
13i9k6f,,Just an example: In C you have unknown structs like this ``` #define T struct { int x; }  T a; a = (T) { .x = 1 }; ``` but this code does not compile.,-0.425,C
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,TypeScript
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,Go
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,Haskell
13i9k6f,jkb7cgw,"Small correction, TypeScript's `interface` is still structural, [TS Playground example](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHtRmQb2QDwC5kQBXAWwCNoAaZAT2LKumQF8BuAKC4BMIEAGzhQUCdCADO2GKRAJiACgAOmcMRxESFalDqNtLKOwCUyALwA+ZHIDWIdAHcQPcVOyqsxDFgu4uyATEAIw0AQzEAExhbDyy8ipqYCZcQA).",-0.25,TypeScript
13i9k6f,jk9yqp0,"TypeScript:      type A = { x: Number };     type B = { x: Number };      type Pointer<a> = { deref: a };      type Equals<a, b> =         a extends b ?",0.0,TypeScript
13i9k6f,jkaeub7,":D      type A = { x: B };     type B = { x: A };      type Equals<a, b> =         a extends b ?",1.0,D
13i9k6f,jkaeub7,"true : false) : false;      const x: Equals<A, B> = true;  > ""assume all types are identical""   > repeatedly break aliases until there are no more contradictions  I haven't yet thought how to implement that in my compiler (which should behave like TypeScript, but doesn't), but another approach is to concurrently analyse types and have each await on each other, then all deadlocks are due to cycles which you can iterate over to deduce equivalencies.",-0.08571428571428574,TypeScript
13i4nm0,jkqjm0w,"If you have something like the following (C#):      using (var x = new T())     {         for (int i=0;i<x.length;i++)          {             x[i] = f (i);         }     }  Then `x` cannot be `Unique` because it makes no guarantee about cleanup, which is required for `using () { }`.",0.17045454545454544,C
13i1mxv,jkr5ppi,"Surprisingly, it seems that this ""direct manipulation"" or WYSIWYG style is mostly used for pure graphic design and CAD or 3D, whereas creators of webpages, arguably one of the biggest uses of programming technology, still mostly edit text files containing text-based CSS and HTML to compose the visual appearance, using cartesian coordinates, numeric dimension in units of pixels or mm  or relative percentages, etc.",0.2517857142857143,HTML
13i1mxv,jkr5ppi,"Maybe its because I used stuff like Hyper/SuperCard, THINK Pascal, MPW, and CodeWarrior back then.",0.0,Pascal
13i1mxv,jkr5ppi,"At one point I tried using some Java IDEs, like Symantec VisualCafe, IntelliJ and Eclipse but IMO, these were bloated and slow compared to what I had used on much less powerful Mac computers a decade earlier.",-0.04166666666666667,Java
13i1mxv,jkr5ppi,"Having learnt to program with Pascal and the other languages I mentioned, I very much prefer a keyword based representation to a parenthesis (curly braces) based.",0.0675,Pascal
13i1mxv,jkr5ppi,"We see this in C, where ""typename"" requires special treatment, and where the existing codebase makes the policy of reserved words useless for language evolution, necessitating the return to stropping of keywords, like ""\_\_Generic"".",-0.07142857142857142,C
13i1mxv,jk7whsf,In Python those are 'grammaticalized' in the form of `with` blocks:  ```py with open( path ) as myfile:   myfile.write( text ) # file properly closed here even ICO error; variable myfile vanished ```,-0.05,Python
13i1mxv,jk983nj,"Another is the `with` block of Pascal, which basically brings the fields of a record into the local scope.",0.0,Pascal
13i1mxv,jk983nj,"Or the `with` block of Microsoft BASICs, which does something similar but requires a leading dot to disambiguate, which is probably an improvement over the Pascal approach.",0.0,Pascal
13i1mxv,jk9ewx0,It also seems to have a fairly direct analogy in Scala's implicit parameters.,0.1,Scala
13i1mxv,jlcbfbl,&#x200B;  For the synchronization I'm probably gonna do atomic things - both with Rust's primitives and some custom ones like AtomicString and AtomicHashMap (although I'm not sure how well it will end up).,-0.25,Rust
13i1mxv,jkoyx00,"I think 는 can be seen as a scoping operator, but it's more influential than `::` or `.` in C++ because it has larger scope itself.",0.25,C++
13hwld5,jk7kcm1,"But Haskell does support such types if you use explicit type annotations, although perhaps the result is not as polymorphic as in your type system:      example :: (forall b.",-0.375,Haskell
13hwld5,jk7u01y,"Once I give annotations teeth, if I needed to draw a line in the sand around `example` I might write this:      example(m:((number)->?a, list[number])->list[?a], ns:list[number]) : pair[list[number], list[string]] = ... ... ...;  Read the annotations a bit like a cross between Pascal and ML.",0.0,Pascal
13hwld5,jk81j7h,This is essentially how C++'s templates work.,0.0,C++
13hwld5,jk81j7h,Rust).,0.0,Rust
13hulvw,jk6yura,Rust uses a form of affine typing to handle variable lifetimes and borrowing.,0.0,Rust
13hulvw,jku7fra,"Clean, ATS and Rust, IIRC.",0.3666666666666667,Rust
13hulvw,jkmfis6,"And additionally, Rust also addresses this part of the OP  > In a dynamic language I could achieve this I guess by overwriting, x = f(x).",0.0,Rust
13hulvw,jkmfis6,"But that won't work if I'm using static types  Rust allows code like this:      let x = f(x)  So even if the first `x` was not moved into `f` (it was either borrowed or copied), the shadowing the first `x` takes it out of scope.",0.3333333333333333,Rust
13ht43r,jk8ohmo,"> At a global scale   This is Haskell we're talking about, right?",0.14285714285714285,Haskell
13hjah0,jk5pizl,"The simplest way to do this is to have a uniform representation for all your values, which is what many languages do, such as Java, ~C#,~ ¹ OCaml, and Haskell.",0.25,Java
13hjah0,jk5pizl,"The simplest way to do this is to have a uniform representation for all your values, which is what many languages do, such as Java, ~C#,~ ¹ OCaml, and Haskell.",0.25,Haskell
13hjah0,jk5pizl,"For languages like Java, ~C#,~ ¹ and Haskell, this is done by having all values be _boxed_ as pointers to their actual value; in Java, this is why you have to use `Integer` (a boxed pointer) instead of `int`.",0.0,Java
13hjah0,jk5pizl,"For languages like Java, ~C#,~ ¹ and Haskell, this is done by having all values be _boxed_ as pointers to their actual value; in Java, this is why you have to use `Integer` (a boxed pointer) instead of `int`.",0.0,Haskell
13hjah0,jk5pizl,"¹ Edit: Turns out C# doesn’t quite do that – it has value types as well as reference types, so it needs to do more",0.5,C
13hjah0,jk7b96f,"Compile a variant of the generic thing for every substitution (like in C++, or JIT in C#).",0.0,C++
13hjah0,jk7b96f,"Compile a variant of the generic thing for every substitution (like in C++, or JIT in C#).",0.0,C
13hjah0,jk7b96f,That's what Java does.,0.0,Java
13hjah0,jk716h1,"In any case, you won't go wrong to look at how C++ does it.",-0.5,C++
13hjah0,jk9btwj,"Here you can read *in-depth* how is done in Swift:   Compiling Swift Generics     https://forums.swift.org/t/compiling-swift-generics-part-i/60898     https://download.swift.org/docs/assets/generics.pdf",0.0,Swift
13hjah0,jk6r5ao,"Nim is a nice language to study for that as it has generics and compiles through C so you can easily inspect the ""intermediate language"".",0.5166666666666666,C
13hjah0,jk6zpqn,C++ is an example of a language that does this through the template feature.,0.0,C++
13hjah0,jk6zpqn,"Java, on the other hand, does not - instead it boxes all objects, and the same byte code is used for all instantiations of a generic function (and a generic class too).",-0.03125,Java
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,Java
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,C
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,Haskell
13hjah0,jkaeeow,In C# you can use both value types and reference types as generics type parameters.,0.0,C
13hjah0,jkaeeow,"Java only supports reference types as type parameters, because of *type erasure*.",0.0,Java
13hjah0,jkaeeow,The Java VM does not know about generics and musty treat all generic type parameters the same.,0.0,Java
13hjah0,jkaeeow,C# generates one shared realization of a generic for *reference types* (like Java) and in addition to that one realization per unique size of value types used to realize the generic (unlike Java).,0.125,C
13hjah0,jkaeeow,C# generates one shared realization of a generic for *reference types* (like Java) and in addition to that one realization per unique size of value types used to realize the generic (unlike Java).,0.125,Java
13hjah0,jk7n1j3,"I might compile all the way down (in my final compiler, rn I'm compiling to C) to machine code but include a bit more information so that a custom ""pre-linker"" could sort all that out.",0.11481481481481481,C
13hjah0,jk7lo00,"I'm currently compiling down to C, and it would be interesting to see how nim does things yeah.",0.11481481481481481,C
13hjah0,jk616jm,"Rust and C++ solve it, so you can too :-)",0.5,Rust
13hjah0,jk616jm,"Rust and C++ solve it, so you can too :-)",0.5,C++
13hjah0,jkaeor2,I didn’t realize C#’s value types were so well-integrated into the language,0.0,C
13hjah0,jk5l1k7,"I'm not sure how it works, but maybe   Look up how the ""inline"" specifier in C++ is implemented   (it has nothing to do with inlining function calls.",-0.25,C++
13hjah0,jk8pzi2,"For user defined struct, you could use something like Go interfaces :  https://research.swtch.com/interfaces",0.0,Go
13hjah0,jk7ph8q,"I'm currently compiling down to C, and it would be interesting to see how nim does things yeah.",0.11481481481481481,C
13hjah0,jkcnnc8,"I wouldn't call what C++ and Rust do ""solving"".",0.0,C++
13hjah0,jkcnnc8,"I wouldn't call what C++ and Rust do ""solving"".",0.0,Rust
13hjah0,jk7usui,"Well, you compile a Nim program with that setup and look at the C files, that's what is happening.",0.0,C
13gt1ib,,"I'm thinking something along the lines of Rust Game Dev, where you can share your progress and get feedback from a community beyond just Reddit and Discord.",-0.4,Rust
13g4r5d,jjyx0ui,"Most times after learning the language basics and probably working through a couple of books and some coding problems, so I feel like I'm starting to get a sense for idiomatic use of the language, I'll write a Lisp interpreter (writing the reader from scratch, no parsing libraries).",0.25,Lisp
13g06id,,"The language doesn't have to be JavaScript, I can read code in a lot of languages.",0.0,JavaScript
13fm2q5,jjxhvlq,Unification is currently entirely syntactic - just as if you encoded arithmetic at the type level in Standard ML or Haskell.,0.0,Haskell
13eztdp,,C was great for my toy JIT but I don't want to rewrite expression trees in it.,0.8,C
13eztdp,,I'd like my compiler's source code to be as small and simple as possible so Rust seems out because of the borrow checker and lack of pattern matching over RC'd trees and lack of tracing GC.,-0.08333333333333333,Rust
13eztdp,,Has anyone tried Swift for this?,0.0,Swift
13eztdp,jjsmdzy,"Common Lisp is my first choice, Racket the second one, and RAKU (perl6;)) the third one.",0.04,Lisp
13eztdp,jjsmdzy,You will find Common Lisp (and the other LISPs) extremely well suited for this job :),-0.012500000000000011,Lisp
13eztdp,jjswrj0,I personally like using D for this stuff.,0.0,D
13eztdp,jjswrj0,It's quite fast and has garbage collection and decent support for calling C code.,0.18333333333333335,C
13eztdp,jjsq48a,"Prolog is a good choice for writing compilers: It has a built-in grammar mechanism (definite clause grammars, DCGs), and great support for reasoning about ASTs symbolically via a generalization of pattern matching.",0.5,Prolog
13eztdp,jjsq48a,"A compiler can be expressed in Prolog as a *relation* between source code and target code, possibly involving intermediate steps.",0.0,Prolog
13eztdp,jjsq48a,"Prolog is ideally suited for reasoning about terms, and can therefore also be easily used to implement term rewriting languages, again as relations between source and target terms.",0.6666666666666667,Prolog
13eztdp,jjst8we,Haskell.,0.0,Haskell
13eztdp,jjwa9ap,"A Lisp or ML-family language might still be a good choice, for the reasons I listed above, but don't choose a Lisp or ML-family language because it's good at parsing if you're going to be struggling with all the actually hard parts of writing a compiler because of that choice.",0.2770833333333333,Lisp
13eztdp,jjt1e5i,Another vote for Rust but you'll have to be prepared to learn the language first before trying to dive into a compiler.,0.25,Rust
13eztdp,jjshes3,"Common Lisp and Coalton, if you like high-performance, bleeding edge tech.",-0.3,Lisp
13eztdp,jjv8s69,"Rust or Haskell, or any language that supports algebraic data type with pattern matching.",0.0,Rust
13eztdp,jjv8s69,"Rust or Haskell, or any language that supports algebraic data type with pattern matching.",0.0,Haskell
13eztdp,jju6i3c,"And full interop with C#, if that matters at all.",0.35,C
13eztdp,jjubtn4,"In my case I found C to have been completely perfect for my needs, but you have already tried that so I won’t recommend it.",1.0,C
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,C
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,C++
13eztdp,jjubtn4,"D, Swift, Nim seem to fit the bill, but ultimately you probably want a language you feel comfortable in.",0.26666666666666666,D
13eztdp,jjubtn4,"D, Swift, Nim seem to fit the bill, but ultimately you probably want a language you feel comfortable in.",0.26666666666666666,Swift
13eztdp,jjubtn4,"To me C is very nice with sufficient abstractions for my needs, and I’m comfortable with it.",0.5900000000000001,C
13eztdp,jjubtn4,For someone else C is unthinkable.,-0.05,C
13eztdp,jjubtn4,"That said, if you had problems using C, then it might be worth looking at codebases which implement in C or C-ish C++ to see how they get around those issues.",0.3,C
13eztdp,jjubtn4,"That said, if you had problems using C, then it might be worth looking at codebases which implement in C or C-ish C++ to see how they get around those issues.",0.3,C++
13eztdp,jjuwxkg,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important - except when implementing an interpreter that needs to implement specific integer sizes or make use of the C math library.",0.3464285714285714,Haskell
13eztdp,jjuwxkg,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important - except when implementing an interpreter that needs to implement specific integer sizes or make use of the C math library.",0.3464285714285714,C
13eztdp,jjtmbpo,My compiler is in C++ but the prototype that I made the most progress the quickest was in C# (before it became very slow).,0.054999999999999966,C++
13eztdp,jjtmbpo,My compiler is in C++ but the prototype that I made the most progress the quickest was in C# (before it became very slow).,0.054999999999999966,C
13eztdp,jjvdxqe,If you're already used to OCaml I would suggest Haskell as an alternative that solves your two pain points (full width ints and FFI).,0.35,Haskell
13eztdp,jjvykbg,Personally I prefer C++ in a moderate style which compiles on any C++98 or C++11 compiler over everything else I've tried.,0.0,C++
13eztdp,jjvykbg,"C works up to a certain complexity, and the fancy languages (including modern modern C++) cause too much dependability.",0.20357142857142857,C
13eztdp,jjvykbg,"C works up to a certain complexity, and the fancy languages (including modern modern C++) cause too much dependability.",0.20357142857142857,C++
13eztdp,jjvykbg,"In terms of C++ library support I solved the dependability, capability and complexity issues by providing LeanQt which is very powerful but still modest and easily integratable.",0.30777777777777776,C++
13eztdp,jjsqi0c,Rust is the closest to oCaml which is also low-level.,0.0,Rust
13eztdp,jjsqi0c,> I'd like my compiler's source code to be as small and simple as possible so Rust seems out because of the borrow checker and lack of pattern matching over RC'd trees and lack of tracing GC.,-0.08333333333333333,Rust
13eztdp,jjsqi0c,"It sounds puzzling, I start learning Rust with https://tablam.org and probably was making my life harder trying to do ""advanced"" stuff when not **have any idea of what I was doing**.",0.15000000000000002,Rust
13eztdp,jjsqi0c,---  Swift is fine.,0.4166666666666667,Swift
13eztdp,jjsqi0c,"My first prototype was on python, then I move to Swift.",0.25,Swift
13eztdp,jjsqi0c,"I then later move to Rust because swift support outside the Apple ecosystem is too poor, but is a good way to just test the water if wanna.",0.07499999999999998,Rust
13eztdp,jjtati5,Swift is fine.,0.4166666666666667,Swift
13eztdp,jjugujz,"Well, I have written [the first compiler for my programming language](https://flatassembler.github.io/compiler), targetting x86, in IE6-compatible JavaScript, and [the second compiler](https://github.com/FlatAssembler/AECforWebAssembly.git), targetting WebAssembly, has been written in C++11.",0.125,JavaScript
13eztdp,jjv9vg4,I've written a compiler in Rust without much issues with borrowchecker.,0.2,Rust
13eztdp,jjx6y45,Go.,0.0,Go
13eztdp,jjx6y45,"Wrote a compiler in C before, and while I enjoyed it at the time, I don't think I'll ever do that again.",0.5,C
13eztdp,jjykjur,I'd say take a stab at Julia; (I'm an idiot!,-1.0,Julia
13eztdp,jjv198j,Try Julia with LLVM.,0.0,Julia
13eztdp,jjwpr7a,Haven’t done it myself but I’ve heard a lot of good things about Haskell in this regard.,0.7,Haskell
13eztdp,jjwpr7a,Actually got a summer job where they’ve built a whole compiler in Haskell.,0.1,Haskell
13eztdp,jjwpr7a,I saw this one guy also made a compact lil parser in less than 80 lines in Haskell.,-0.16666666666666666,Haskell
13eztdp,jjxkyr0,JavaScript.,0.0,JavaScript
13eztdp,jjzoyno,"* **Haskell**: If you're up for a drastically different programming language experience that, if strangers' opinions on the internet (including mine) is anything to go on, will make you a better programmer even when using other languages, then give this beauty a go.",0.125,Haskell
13eztdp,jjzoyno,"Here's an example compiler written in Haskell for a statically-typed, non-GCed, performance-oriented Lisp+Rust-inspired Lisp:  [https://github.com/carp-lang/Carp](https://github.com/carp-lang/Carp)",-0.75,Haskell
13eztdp,jjzoyno,"Here's an example compiler written in Haskell for a statically-typed, non-GCed, performance-oriented Lisp+Rust-inspired Lisp:  [https://github.com/carp-lang/Carp](https://github.com/carp-lang/Carp)",-0.75,Lisp
13eztdp,jjuigvm,I can suggest Clojure.,0.0,Clojure
13eztdp,jjt9wpy,"If you like Prolog, you might want to try Mercury.",0.0,Prolog
13eztdp,jjt9wpy,"It's Prolog, but with strong types, strong modes and strong determinism.",0.4333333333333333,Prolog
13eztdp,jjtx8al,"Did you ever really try to do a decompiler that way, or you are just discussing a theoretical possibility of having a decompiler as a different way of running Prolog predicates?",0.06666666666666667,Prolog
13eztdp,jjt9m3d,I would suggest to give Haskell a try as it is really easy to make parser combinator in Haskell.,0.43333333333333335,Haskell
13eztdp,jjt9m3d,Haskell also have a LLVM binding if you are doing some kind of compiled languages.,0.6,Haskell
13eztdp,jjwz2s4,"You can write a C compiler in Python, https://web.archive.org/web/20150126174629/http://people.cs.uchicago.edu:80/~varmaa/mini_c/",0.0,C
13eztdp,jjwz2s4,"You can write a C compiler in Python, https://web.archive.org/web/20150126174629/http://people.cs.uchicago.edu:80/~varmaa/mini_c/",0.0,Python
13eztdp,jk8nuvi,I too use C++,0.0,C++
13eztdp,jjvkbsx,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important  I don't understand all these arguments against full-width integers, *especially* regarding compilers.",0.3464285714285714,Haskell
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,C
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,Rust
13eztdp,jjzrah3,"> Well, I have written the first compiler for my programming language, targetting x86, in IE6-compatible JavaScript, and the second compiler, targetting WebAssembly, has been written in C++11.",0.125,JavaScript
13eztdp,jjt1le8,"If they've already eliminated C and Rust for lack of abstraction, they're definitely not going to want to use Odin.",0.0,C
13eztdp,jjt1le8,"If they've already eliminated C and Rust for lack of abstraction, they're definitely not going to want to use Odin.",0.0,Rust
13eztdp,jjsoz3p,"I wrote my first compiler in C, and at my work we use C++ (although I’m not on the compiler team myself).",0.25,C
13eztdp,jjsoz3p,"I wrote my first compiler in C, and at my work we use C++ (although I’m not on the compiler team myself).",0.25,C++
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,C
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,C++
13eztdp,jjthcw3,My JIT in C is easy because I can just call anything but if I used OCaml it would be painful having to wrap everything in stubs.,-0.1333333333333333,C
13eztdp,jju9pd8,"In addition to this specific extreme (and maybe indeed unattainable) benefit, there are other, in a sense ""less general"", benefits we automatically get from describing a parser and compiler as relations in a logic programming language, including:  - being able to easily search whether the grammar is ambiguous by *asking* the Prolog system for strings that correspond to multiple tokenizations or ASTs - being able to easily express *test cases* as queries that relate (ground or partial) source programs to intended (ground or partial) target programs and must succeed or fail.",0.06153846153846154,Prolog
13eztdp,jju9pd8,"These advantages are much easier to achieve, and in fact typical properties of compilers that are written in Prolog.",0.016666666666666677,Prolog
13eztdp,jjujzn2,I recently got a glimpse into a commercial compiler written in Rust.,0.0,Rust
13eztdp,jjwa66w,I'd rather someone use something else they find easier than stick it out with Rust being miserable.,-1.0,Rust
13eztdp,jjvqu4h,"As for slow compile and startup times, that's not generally a complain I hear about C#/F#, but perhaps your case is unique.",0.016666666666666646,C
13eztdp,jjvsgak,I do use Haskell's appropriately sized integer types to express these in my AST.,0.5,Haskell
13eztdp,jjwg9tb,Floats have a -0.0 and this leads to (see also [isNegativeZero](https://seed7.sourceforge.net/libraries/float.htm#isNegativeZero(in_float))):      isNegativeZero(0.0 * -1.0)  --> TRUE     isNegativeZero(-0.0 * 1.0)  --> TRUE     isNegativeZero(0.0 * 1.0)   --> FALSE     isNegativeZero(-0.0 * -1.0) --> FALSE  Floats have also [Infinity](https://seed7.sourceforge.net/libraries/float.htm#Infinity) and this leads to (see also [isNaN](https://seed7.sourceforge.net/libraries/float.htm#isNaN(in_float))):      0.0 * Infinity --> NaN     Infinity * 0.0 --> NaN     0.0 * NaN      --> NaN     NaN * 0.0      --> NaN  The Seed7 compiler leaves such float optimizations to the C compiler.,-0.02000000000000004,C
13eztdp,jk03bo0,Many people say Haskell is an exceptionally good language to write a compiler in.,0.6,Haskell
13eztdp,jk03bo0,"If you are not intimately familiar with Haskell, you probably shouldn't try to build a compiler in it.",-0.1875,Haskell
13eztdp,jjxqdip,There are a lot of things about JavaScript that I actually really like.,0.2,JavaScript
13eztdp,jjxqdip,"I won't go as far as Douglas Crockford in some of the details, but I agree with him that there's a fantastic programming language lurking inside of JavaScript.",0.25,JavaScript
13eztdp,jjujs6q,"The suggestion was based on my practical experiences on in other LISP dialects, Clojure has a unique position, IMHO.",0.125,Clojure
13eztdp,jju1lfi,"It doesn't require knowing Prolog, but given that there are far more Prolog tutorials around, you'll probably have an easier time of it.",0.3,Prolog
13eztdp,jju1lfi,Erlang might be good enough too.,0.35,Erlang
13eztdp,jk4whxl,For a larger compiler in Python look at  https://github.com/windelbouwman/ppci,0.0,Python
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,Rust
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,Haskell
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,Scala
13eztdp,jjuy2dc,"Strictly speaking, it's not Rust's fault, but more like an inherent complexity that comes with the lack of powerful GC.",0.4,Rust
13eztdp,jjwfngy,Functional style is pathological for Rust.,0.0,Rust
13eztdp,jjwfngy,"Rust is really an imperative language, IMHO.",0.2,Rust
13eztdp,jjv6p4e,"For example, I want to do:      add(mul(a, b), c) -> madd(a, b, c)  but Rust cannot match the inner `mul` if you have to go through an `Rc`.",0.0,Rust
13eztdp,jjulxjj,"It's not to start a debate about which is better or worse, but could you explain what is unique about Clojure about writing compilers and/or interprerers compared to other dialects like CL or Racket?",0.0875,Clojure
13eztdp,jjv6u4g,Even if you wrap everything in `Rc` Rust is painful because tail calls leak not only stack but everything tied to the scope.,-0.35,Rust
13etpti,,"I tried to design a lifetimes system both convenient and efficient, inspired by C++, Nim and Vale.",0.0,C++
13etpti,,"# Constructors  An automatic constructor allows to define a default value and to put the variable in a valid state, but does not cover all the C++ constructors use cases.",0.0,C++
13etpti,,"I don’t like exceptions but it may be useful to have a different behavior when an exception is thrown (for example, to have a [D’s scope guards](https://tour.dlang.org/tour/en/gems/scope-guards) equivalent, to solve [the obvious final step](https://akrzemi1.wordpress.com/2023/04/23/the-obvious-final-step/) or to make them compatible with [Vale’s higher RAII](https://verdagon.dev/blog/higher-raii-7drl)).",0.11000000000000001,D
13etpti,jk2u36g,C++ kinda does too when your compiler elides calls to destructors on moved objects.,0.0,C++
13etpti,jjtmj17,I can't believe you mentioned lifetimes but not Rust!,0.0,Rust
13etpti,jjtmj17,"Ok, Rust-style lifetimes aren't relevant here, but Rust does track whether variables live or not with a two-state system: either they're fully initialized, in which case they can be used in expressions and they need their destructors called, or they're uninitialized and can't be used in expressions and won't have their destructors called.",0.34545454545454546,Rust
13etpti,jjtmj17,Assignment and moves are always just a bitwise copy in Rust so they don't create any new cases.,0.13636363636363635,Rust
13etpti,jk5pkdy,"Looks like ""C++ but different"".",0.0,C++
13etpti,jk5pkdy,I have never read about C++ destructor elision before.,0.0,C++
13etpti,jjv21o0,Very nice explanation about Rust.,0.78,Rust
13etpti,jjv21o0,"I am not Rust programmer but since,  I am doing ownership check in C I need at least compare against Rust.",-0.3,Rust
13etpti,jjv21o0,"I am not Rust programmer but since,  I am doing ownership check in C I need at least compare against Rust.",-0.3,C
13etpti,jjv21o0,The perfect solution for C should be able to track this without adding any extra runtime state.,0.5,C
13etpti,jjuvwz6,"Rust handles construction/copies/moves/destruction nicely, I particulary like that it has destructive moves (through it has *only* destructive moves), however it’s prohibition of shared mutability makes it cumbersome.",-0.15,Rust
13etpti,jk5rfa9,> I have never read about C++ destructor elision before.,0.0,C++
13etpti,jjwtluc,Rust avoids it except in really weird cases where a variable is initialized in one code path and left uninitialized in another.,-0.25,Rust
13etpti,jjwvc1c,Can you help me to translate this C sample to Rust?,0.0,C
13etpti,jjwvc1c,Can you help me to translate this C sample to Rust?,0.0,Rust
13etpti,jjx69cv,This cannot happen in safe Rust.,0.5,Rust
13etpti,jjyfo1p,"Yeah, there's no equivalent of malloc in idiomatic Rust code.",0.0,Rust
13eo3pa,jjrp61r,If you look at the Haskell type `(<*>) :: (Applicative f) => f (a -> b) -> (f a -> f b)` it can be seen as distributing the functor type `f` over the function type `(->)`.,-0.175,Haskell
13eo3pa,jjrp61r,Python’s `f(*xs)`) then you can construct `liftAn` for arbitrary/inferable `n`.,0.0,Python
13eo3pa,jjrp61r,"In general, they can be partially applied to arguments in any order, but in the slightly simpler case that you don’t allow that, they would let you treat an uncurried type `(a, b, c) -> d` as if it were curried `a --> b --> c --> d`; whereas they also ensure that the function will be fully applied at some point locally (which is _almost always_ the case with applicatives in typical Haskell code) or explicitly boxed into a closure.",-0.07666666666666666,Haskell
13eo3pa,jjrhcqb,"I don't know much about your language -- if it's dynamically typed, you could make some sort of `Decode.mapMany` that takes varargs, reduces with the (binary) `<*>` to get a list of arguments with the Applicative wrapper (read: `sequenceA`), then map spread-apply on your original function  if it's not dynamically typed, you might still be able to encode this, but it involves talking about mapping over the types in a heterogeneous (argument) list (or just casting to the top type = whatever the ""supertype of everything"" is, but that's no fun :p)  not sure I explained this very well, but I'm happy to rephrase if you could tell me which languages you're familiar with (I'd guess Elm?)",0.33636363636363636,Elm
13eo3pa,jjslho3,"I'm literally typing this while watching a talk about Applicative in C++, a language without automatic currying.",0.4,C++
13eo3pa,jjslho3,"Implement manual currying, which is possible in C++.",0.0,C++
13eo3pa,jjrjd77,"Elm indeed is where I got the idea ""I need this functionality"" from, but it automatically curries so it doesn't have the issue with peeling off one argument at a time.",0.0,Elm
13eo3pa,jjrjd77,I think I'll be fine with Haskell analogies as well if you want to explain using that.,0.4166666666666667,Haskell
13eo3pa,jjvbhrr,Or perhaps C++ has some unsafe cast capability that makes the nice unlimited API expressible as well :),0.55,C++
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,C
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,C++
13elyfa,,"Def !SomeClass(){     		Log(""Goodbye :("");     	}     }          /*          Here come modules,modules can either contain extensions,attributes or helpful functions          modules can be the only thing in the file,and must start with the keyword ""extend"" followed by either ""Attribute"",""Extension[]"" or ""Helper""          modules can either be internal or public,and the access modifier attribute must be put before the extend keyword          */     @Public     extends Extension[SomeClass]               //We can add additional Functions,but not additional Variables or Properities          //We can use the Params[] Container to pass an infinite amount of objects as parameters,although it must be the last argument     @Public      Fn ExtensionFunction(val uselessStuffForExample : Params[Dyn]) : bool{     	//The When keyword takes multiple bools and checks for any falses,if detected,it returns from the method with the default value     	When{     	!false,     	true     	}          	//For loops work the same as in kotlin and rust,except we use the Range or RangeInclusive Functions     	For (i in RangeInclusive(1,10)){     		Log(i);     	}     	//While loops work as expected     	While (True){     		Break;     		//There also exists the Break keyword,the Skip keyword(similar to continue),Redo keyword(redos the current loop) and the Reloop keyword(Reloops the entire loop)     	}     	//Switch is intended to be faster and much more cleaner for checking single values similar to the C# variant and requires a constant value     	Switch(1){     		(1,2) => Logl(1),     		3 => Logl(3),     		4 => Logl(4),     		_ => Logl(""Default"")     	};     	return true;     }          //There are other object types other than Classes,these are Structs(The same as in most languages),Enums(Same as in C# but can inherit a constant and if it inherits,it must have a value) and Cases(Sames as Enums in rust)  so how does it look?",0.019940476190476186,C
13elyfa,,"also, I need some help with this language, so far I have made a simple lexer with logos in Rust and was planning to make a parser with nom and a compiler with Inkwell, but I am thinking of switching to another language, should I?",0.05,Rust
13elyfa,jjqsztg,"also, I need some help with this language, so far I have made a simple lexer with logos in Rust and was planning to make a parser with nom and a compiler with Inkwell, but I am thinking of switching to another language, should I?",0.05,Rust
13elyfa,jjqsztg,"If you are comfortable with Rust, use it, otherwise pick something else.",0.4,Rust
13elyfa,jjqwzdh,I disagree on the int thing  Int should be the same as C's int_fast32_t imo  There's no reason to explicitly specify the bit size of an integer if it's not required by the code in question.,0.0,C
13ej6fr,jjq8sc3,"Among other things in here, one thing I found interesting is that there appears to be the Interlisp source code of v1.5 of Quintus Prolog.",0.1875,Prolog
13e5ilp,jjocbyw,"Dart has come a long way since version 1, I still vaguely remember how Dart 1.x had a pluggable type system and was supposed to be a better JS.",-0.01666666666666668,Dart
13e5ilp,jjocbyw,"Of course most people writing code in Dart are doing this for Flutter as it is now, but it will be really nice to see Dart being used in other areas as well.",0.325,Dart
13e5ilp,jjnyr12,Saw this comment elsewhere:  >\> it's not bringing anything useful to the table compared to other existing languages   Dart's tooling and compiler are actually state-of-the-art.,0.05833333333333333,Dart
13e5ilp,jjnyr12,"Not many languages can claim to target every major OS (Windows, Mac, Linux, Android, iOS) in three different modes (native, JIT, interpreted) and natively compile to both JavaScript and WebAssembly, while also supporting hot-swapping code at runtime.",0.015625,JavaScript
13e5ilp,jjnyr12,Plus Dart's Pub package manager is stupidly simple and 'just works' compared to pretty much any other language I've used.,0.08125,Dart
13e5ilp,jjqs1ed,"Dart is only ""exciting"" if you fell into a coma around Java 7.",0.06666666666666667,Dart
13e5ilp,jjqs1ed,"Dart is only ""exciting"" if you fell into a coma around Java 7.",0.06666666666666667,Java
13e5ilp,jjqs1ed,"I understand it's targeting a similar kind of people as Go and they don't want to overload the minds of those feeble non-Googlers, but that doesn't explain all the feature work that is happening.",0.033333333333333326,Go
13e5ilp,jjolqep,"As in Dart, the GObject and GLib framework that started in the Gimp Open Source Paint Tool and later in the Open Sourc Linux GNome Desktop eventually become the Vala P.L.",0.0,Dart
13e5ilp,jjphj73,"None of those great things are a property of Dart, the language.",0.8,Dart
13e5ilp,jjphj73,"Dart, the language, does not bring anything new to the table.",0.13636363636363635,Dart
13e5ilp,jjphj73,"Tools and compilers are still reasons why you would pick a language over another for a project, and why Dart as a language choice can still make sense for some situations.",0.0,Dart
13e5ilp,jjphj73,But it'd be much better for absolutely everyone if the efforts spent on the Dart compiler went into improving the compiler of an existing language with extensive ecosystem.,0.15,Dart
13e5ilp,jju6svb,"""Dart is the only language that initially had design flaw X and now no longer has design flaw X"".",0.0,Dart
13e5ilp,jjqnsgn,So Kotlin and Typescript don't count then?,0.0,Kotlin
13e5ilp,jju6mp0,Kotlin.,0.0,Kotlin
13e5ilp,jju6mp0,Dart has been playing catch up to Kotlin's features for over five years now.,0.0,Dart
13e5ilp,jju6mp0,Dart has been playing catch up to Kotlin's features for over five years now.,0.0,Kotlin
13e5ilp,jjra194,Scala 3 has had it under a compiler flag for a long time too.,-0.05,Scala
13e5ilp,jjrgw0l,Kotlin and TypeScript aren't sound.,0.4,Kotlin
13e5ilp,jjrgw0l,Kotlin and TypeScript aren't sound.,0.4,TypeScript
13e5ilp,jjrupi6,"Uhm, I really don't know haha, don't work on the Dart team, was just clarifying the claim",0.2,Dart
13e5ilp,jjrgtaq,"Some examples of how language design interacts with what you might think of as ""implementation features"":  * Dart has no top level static initialization.",0.125,Dart
13e5ilp,jjrgtaq,"This means that applications can start up faster than you typically see in, for example, Java.",-0.16666666666666666,Java
13e5ilp,jjrgtaq,* Dart doesn't have class loading or other dynamic loading features.,-0.0625,Dart
13e5ilp,jjrgtaq,This makes whole-program optimization and large scale dead code elimination work in ways that are very difficult for a language like Java or C#.,-0.21190476190476193,Java
13e5ilp,jjrgtaq,This makes whole-program optimization and large scale dead code elimination work in ways that are very difficult for a language like Java or C#.,-0.21190476190476193,C
13e5ilp,jjrgtaq,* Dart's concurrency model is designed to be straightforward to compile to JavaScript while other languages struggle to have the same concurrency semantics on the web without losing a lot of performance.,0.08333333333333333,Dart
13e5ilp,jjrgtaq,* Dart's concurrency model is designed to be straightforward to compile to JavaScript while other languages struggle to have the same concurrency semantics on the web without losing a lot of performance.,0.08333333333333333,JavaScript
13e5ilp,jjrgtaq,"There's a reason every JVM has a JIT, while C++ implementations generally don't.",0.05000000000000002,C++
13e5ilp,jjrgtaq,There's a reason Ruby and Python are still mostly using bytecode interpreters and why ahead of time compilation for them hasn't been successful.,0.625,Ruby
13e5ilp,jjrgtaq,There's a reason Ruby and Python are still mostly using bytecode interpreters and why ahead of time compilation for them hasn't been successful.,0.625,Python
13e5ilp,jjw1gu5,Awfully specific asterisks that need to be appended to all these claims about Dart ...,0.0,Dart
13e5ilp,jjrgnq5,"I am talking about Dart, the language.",0.0,Dart
13e5ilp,jjrgnq5,Dart's tooling is great.,0.8,Dart
13e5ilp,jjrgnq5,And when Flutter was started there were already plenty of better options than Dart.,0.5,Dart
13e5ilp,jjzxape,> bigger than the alternative languages that run on VMs and have sound null safety  > Dart's ecosystem is bigger than comparable languages today.,0.13333333333333333,Dart
13e5ilp,jjzxape,I'd wager that even Scala's ecosystem (a language that is pretty much dying) is substantially bigger than Dart's.,0.15,Scala
13e5ilp,jjzxape,I'd wager that even Scala's ecosystem (a language that is pretty much dying) is substantially bigger than Dart's.,0.15,Dart
13e5ilp,jjryca9,It doesn't matter since Dart 3.0 seems to finally be a decent language.,0.16666666666666666,Dart
13e5ilp,jjryca9,"Could've had an easier time for everyone but here we are, and that's what my comment was pointing out: Building an ecosystem for Dart, the language, was a waste of resources.",-0.2,Dart
13e36pv,jjnq142,The Julia language is specifically built with scientific computing and researchers in mind.,0.0,Julia
13e36pv,jjnq142,"Julia approaches reproducibility from the packaging perspective: local environments (collections of installed packages) are easy to set up, the exact state of each environment is saved locally, along the ""research code"".",0.17083333333333334,Julia
13e36pv,jjnq142,"There are also Pluto notebooks, which are the Julia version of reproducible Jupyter-like notebooks.",0.0,Julia
13e36pv,jjnq142,Another thing that's often mentioned when talking about Julia for researchers is Julia's Unicode support.,0.0,Julia
13e36pv,jjnq142,"Supposedly, researchers like to use Greek letters and various fancy symbols as part of variable names, and Julia lets you do just that.",0.0,Julia
13e36pv,jjnq142,"Of course, Julia also provides a lot of tooling for all sorts of computation, optimization, solving equations, fitting neural networks, plotting stuff and so on.",0.5,Julia
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,Python
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,Fortran
13e36pv,jjor8ip,My opinion is that replacing Fortran will be tough.,-0.3888888888888889,Fortran
13e36pv,jjor8ip,"I successfully converted a friend who is doing her Ph.D. to Julia, but I don't think most of her colleagues would be able to follow.",0.5833333333333334,Julia
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,Python
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,R
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,Julia
13e36pv,jjp2p5w,I would expect Rust to become popular here if the scientific computing infrastructure for that language improves.,0.6,Rust
13e36pv,jjqyqq2,I think Julia as a language has a few significant flaws like lack of static typing/analysis and the use of multiple dispatch in large projects (which can be a death trap disguised as a feature).,0.17785714285714288,Julia
13e36pv,jjqyqq2,"Aside from that, Julia has a marketability problem.",0.0,Julia
13e36pv,jjqyqq2,Same goes for R in its own niche.,0.3,R
13e36pv,jjqyqq2,"Julia devs have made some misleading claims about Julia's performance (often citing very selective and unrealistic benchmarks), but in reality, Julia's performance is at about Java level in most cases.",0.06666666666666667,Julia
13e36pv,jjqyqq2,"Julia devs have made some misleading claims about Julia's performance (often citing very selective and unrealistic benchmarks), but in reality, Julia's performance is at about Java level in most cases.",0.06666666666666667,Java
13e36pv,jjqyqq2,So I don't see it replacing Fortran on that end of the spectrum either.,0.0,Fortran
13e36pv,jjtj3qh,"Julia offers almost no way to verify that you have written correct code: there's a lack of good linting, has no compile-time errors, it allows type piracy, it has the wildest variable scoping rules I've ever seen, its default import system is basically C-style copy-paste #includes rather than any modern approach, it has no trait/etc system to enforce invariants, etc etc etc.",0.3333333333333333,Julia
13e36pv,jjtj3qh,"(I am aware of the irony here, given Julia's decision to focus on scientific applications.)",0.25,Julia
13e36pv,jjqdrwn,Hence why I am not holding my breath for Julia to replace matlab.,0.0,Julia
13e36pv,jjtne68,"These are codes developped over decades that practically no engineer ever looked at, and they are about 500k lines of Fortran too late for refactoring.",-0.3,Fortran
13e36pv,jjtne68,Fortran is great because it allows you to write fast code without effort nor much programming knowledge.,0.39999999999999997,Fortran
13e36pv,jjql6hg,"Biologists & data scientists say ""why should I learn C++ when I can have every library I need in Python?"".",0.0,C++
13e36pv,jjql6hg,"Biologists & data scientists say ""why should I learn C++ when I can have every library I need in Python?"".",0.0,Python
13e36pv,jjql6hg,"And then I show them the source of their library, which is more often than not in C++.",0.5,C++
13e36pv,jjtoxu2,"Some are, of course, but some of those big ol pieces of code everyone is using are Fortran (or otherwise) messes that have bits of code from 40 years ago, that have been written in by every PhD student that has come, with practically no control of the quality of the code (no-one in academia has time for code review, something I've incidentally only heard of through the internet despite a PhD and postdoc in a code-heavy field), no unit testing beyond ""here's a couple of test cases, have fun"" and a bunch of print\*, git being used once every couple of years to merge part of a thesis' work in (when it's not plain e-mailing tar.gzs), etc... etc...",0.10178571428571428,Fortran
13e36pv,jjtoxu2,It just so happens that Fortran is fast by default.,0.2,Fortran
13e36pv,jjwyc0h,"I don't think Julia's devs are even trying to work on this, unfortunately.",-0.5,Julia
13e36pv,jjwyc0h,"As an example, when I'm messing around with Julia code (some numerical optimization, neural networks, data visualization and so on), the language feels just fine: I don't need to specify types, I can write functions that dispatch on whatever I need (this needs types, but it's OK), and everything is pretty fast.",0.3416666666666667,Julia
13e36pv,jjwyc0h,"I've just finished working on some Python + Equinox code (loving Equinox, BTW) that involves time-series cross-validation (which needs nested loops), and boy is it slower than Julia!",0.75,Python
13e36pv,jjwyc0h,"I've just finished working on some Python + Equinox code (loving Equinox, BTW) that involves time-series cross-validation (which needs nested loops), and boy is it slower than Julia!",0.75,Julia
13e36pv,jjwyc0h,"In Julia and Flux.jl the exact same code is literally orders of magnitude faster, just out of the box, without any optimizations.",0.125,Julia
13e36pv,jjwyc0h,"In Julia, however, I don't need to worry about JIT (except when it takes forever to run code for the first time - ha, got 'em!).",0.3125,Julia
13e36pv,jjwyc0h,I don't like it when `MyPackage.jl` basically consists of `include`s that supposedly act more like C's `#include` directives.,0.5,C
13e36pv,jjwyc0h,Even Python has abstract base classes that force you to implement the entire interface.,-0.4,Python
13e36pv,jjr6bey,"as opposed to MATLAB, which ships without a package manager and makes life hell for anyone using it.",0.0,MATLAB
13e36pv,jjqul2q,That's the point of the Python ecosystem or of libraries in general: other people have written stuff do you don't have to.,-0.03749999999999999,Python
13e36pv,jjxlkh1,"Ah, I took your mention of Julia to be a recommendation.",0.0,Julia
13e36pv,jjxlkh1,"As anecdata, I have definitely seen first-time Julia users run afoul of each of the various things I've mentioned.",0.0,Julia
13e36pv,jjxlkh1,Price of bolting a DSL on to Python.,0.0,Python
13dya1e,,"Usually this is the default behaviour of these constructs, but i found Go to be an oddball (as it usually is), here's the specification of type identity between two `struct` types ([link to the spec](https://go.dev/ref/spec#Type_identity)):  >Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags.",-0.125,Go
13dya1e,jjn2f8q,My records look like this in my static language; they are always a named user-type:      record R =         real a         string b     end      record S = (real a; string b)      # alternate compact syntax  This also defines two incompatible types `R` and `S`.,0.029999999999999992,R
13dya1e,jjnt5iq,"**Summary**  Anyway, I use record / struct types, as a typical ""C"" or ""Pascal"" program declares them.",-0.16666666666666666,C
13dya1e,jjnt5iq,"**Summary**  Anyway, I use record / struct types, as a typical ""C"" or ""Pascal"" program declares them.",-0.16666666666666666,Pascal
13dya1e,jjnt5iq,"As an example:      struct RGBA     {        int var R;        int var G;        int var B;        int var A;     }  Is not the same as:      struct ARGB     {        int var A;        int var R;        int var G;        int var B;     }  Both are Product Types, right ?",0.14285714285714285,R
13dya1e,jjnt5iq,"And a common:      union Param     {       int var I;       doubl var F;       char var C;       char* var S;     }  That's a Sum Type, right ?",-0.007142857142857145,C
13dya1e,jjnt5iq,"You will not notest much of a difference, from C or C++, in these fragments of code, except that "";"" and variable declarations aren't not supported here.",0.2,C
13dya1e,jjnt5iq,"You will not notest much of a difference, from C or C++, in these fragments of code, except that "";"" and variable declarations aren't not supported here.",0.2,C++
13dya1e,jjnt5iq,"I considering use C++ alike generics or templates but for non O.O., I ignore if they are considered Sum Types, Product Types or other concept in Type Theory.",-0.125,C++
13dya1e,jjoalx0,"Both of these types would be declared by associating labels with types, as in C. Like C, the labels correspond to offsets from the begining of the structure, so order and label names definitely both matter.",0.0,C
13dya1e,jjo71qn,"The example from the [PureScript documentation](https://github.com/purescript/documentation/blob/master/language/Records.md) is:      type Lang l = { language :: String | l }          type Language = Lang ( country :: String )     -- equivalent to { language :: String, country :: String }  I'm curious how that differs / is related to the [equivalent in TypeScript](https://www.typescriptlang.org/play?#code/C4TwDgpgBAMghgOwOYB4YD4oF4oG8oA2iSArnEhAFxQDOwATgJbJQC+UAZLAFDeiSxiZCtkHIU+AMYB7EggYhqdJi1bpeMhHSgQAHnAC2YAlTGly0HLm5RbUGXIXUA5ACEASs4A0Nu0WTCps4ACgAq3tys3EA):      type Lang<L> = { language: string } & L          type Language = Lang<{ country: string }>          let example: Language = {       country: 'BR',       language: 'PT',     }  Besides the difference in syntax, are these example fundamentally different?",-0.03333333333333333,TypeScript
13dya1e,jjnpiko,"I believe this is the same reason for Go to require ordering, requiring equal names is probably to make it easier to implement.",0.0,Go
13dya1e,jjnpiko,"edit: Go probably requires equal names to make a more stable ABI too, you have guarantee of the offset for each field name.",0.25,Go
13dya1e,jjsuzz5,"Your language looks very interesting, the only other set-based language i know is SETL, but they treat sets the same way APL treats arrays: it's their default data type.",0.13125,APL
13dya1e,jjnstgp,"I've seen this syntax being used in Lua, Javascript and Setl, i tried to come up with a nice syntax like `hashmap.key` for those but found it too difficult to fit in a static language.",0.25,Lua
13dya1e,jjo3j42,">foo = StandardEuropeanItem with PortugeseModifications  That is very cool, i was thinking about implementing the same idea in my language, but similar to how C# does it: the `{label: value, ...}` is part of the `with` syntax, it doesn't accept arbitrary objects, your idea is a interesting generalization.",0.17099999999999999,C
13dya1e,jjo7sdq,"I do think C does that [to an extent](https://stackoverflow.com/questions/42411819/c-on-x86-64-when-are-structs-classes-passed-and-returned-in-registers), i'd have to look at compiler outputs to be sure, but i think LLVM has this type of optimization.",0.5,C
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,C
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,Go
13dya1e,jjoemnx,"So, TypeScript has intersection and union types, which is closely related to the subtyping approaches I had mentioned - I should have mentioned these types by name, and used TypeScript as an example!",0.0,TypeScript
13dya1e,jjo7r1f,It's a Ruby inspired smalltalk dialect.,0.0,Ruby
13dya1e,jjo7r1f,It is inspired directly by Ruby's own `Struct` and `OpenStruct`.,0.35,Ruby
13dya1e,jjoep28,"> I do think C does that to an extent, i'd have to look at compiler outputs to be sure, but i think LLVM has this type of optimization.",0.5,C
13dya1e,jjqtupl,"In TypeScript, when the right-hand side of an intersection contains the same key(s) as the left-hand side, there are some surprising results.",0.35,TypeScript
13dya1e,jjqtupl,"I don't know if this is a TypeScript bug or actually expected, but [this is an interesting example](https://www.typescriptlang.org/play?#code/PTAEEFQZwSwGzgT1AUwB4EMC2AHOKAaUAMwHsAnaAV3JQCgAXRHFUABVJgDsGBmUALygA3qDQAuUFypYARinJFEk6XIVEAXipnzKAX0bNWHbgwBMg9px78AZCNBapKAG4LQBuvgagc1vpImNpaiEqAAjEqSZpqS-HqgIKAA8gDSdHRJQeagGDgsGORQoAykoPKgMLikULCy+CVlAMakXFAM5FRNDJlgAJIA5AAmqGgs3SUAFqzEMEU+6Nh4rPJwpADuoOswDJOkVD4DGgON5axpXig+fqZmAPoYgf4WQqGSkaDKoBYJSS248FYCnIFEu12ed1kT1uITE7yi31ioHiiTA-xwgNQ5BB5AyQA)      // A silly example, for sure     type Point3 = { x: number, y: number, z: number }     type Point2 = Point3 & { z: never }          let point3: Point3 = { x: 1, y: 2, z: 3 } // OK          // Point2 appears to be impossible to construct     // I'd expect the first example below without 'z' to be OK     let point2_a: Point2 = { x: 1, y: 2 } // compile error     let point2_b: Point2 = { x: 1, y: 2, z: 3 } // compile error  I feel like the row polymorphism example may be easier to understand in general (after you get past the ""I've never seen this before"" stage), which is probably related to what you mentioned about it being easier to implement type inference for as well.",0.13717948717948716,TypeScript
13dya1e,jjo4q82,"One other approach is what is done in C#: `tuple.Item0, tuple.Item1, ..., tuple.ItemN`, which is much simpler than generating letter labels and also fixes the parsing problem.",0.037500000000000006,C
13dya1e,jjoai3d,"> One other approach is what is done in C#: `tuple.Item0, tuple.Item1, ..., tuple.ItemN`, which is much simpler than generating letter labels and also fixes the parsing problem.",0.037500000000000006,C
13dv591,jjmg245,"I believe Python has a single integer type from the users perspective, but automatically promotes numbers as needed in the backend.",-0.07142857142857142,Python
13dv591,jjmg245,"That said, one type change that isn't as clear, division in Python 3+ between two integers will always produce a float.",0.10000000000000002,Python
13dv591,jjoupvy,"Originally, C designers used to change all integers values into integer, for operations.",0.375,C
13dv591,jjoupvy,"In C, both values were converted into signed integer bigger size ""integer"".",0.0,C
13dv591,jjpkb9p,You could take the JavaScript approach and decide that all numbers are double-precision floating point.,0.0,JavaScript
13dv591,jjpkb9p,"If you choose the latter alternative, then you'll probably want an analogue to Python's `struct` module for dealing with explicitly-sized binary data.",0.0,Python
13dv591,jjqmtvf,With a language like Python the transition is seamless.,0.1,Python
13dv591,jjuccq2,"To be fair, I once tested some computationally-heavy algorithms (I can't recall the specific use case now) written in Java with a version using the int type, and a version using the long type.",0.21666666666666665,Java
13dv591,jjuu3hg,"C for example typically uses a default 32-bit `int` type, literals are 32 bits and expressions are widened to 32 bits for evaluation, even if the operands are 8 or 16 bits.",-0.16666666666666666,C
13ds7sy,jjm3dli,See C++.,0.0,C++
13ds7sy,jjm3dli,Look at Rust.,0.0,Rust
13ds7sy,jjm3dli,You set the edition for your project and the code will run forever because it can just disable the newer features and use an old version of Rust.,0.1,Rust
13ds7sy,jjm3dli,"In the future, I can use the upcoming 2024 edition of Rust with crates that were made with the 2018 version.",0.0,Rust
13ds7sy,jjm3dli,"Rust isn't technically backwards compatible, but because the tooling is good, it doesn't matter; in essence it *is* backwards compatible.",0.35,Rust
13ds7sy,jjm3dli,"And heck, even Python when used with pip, pyenv, and virtualenv, which still isn't as good as cargo, allows you to run old code without much hassle.",0.3333333333333333,Python
13ds7sy,jjm3dli,"So basically what I'm saying is backwards compatibility, if defined as being able to use old code in an unmodified state for many years, is very very important, but backwards compatibility, if defined in terms of implementation - the language itself a la C++, is going to hold you back, and you should put your dev time into a good package manager which, if done right, should give you that first kind of backwards compatibility for free a la Rust.",0.38557142857142856,C++
13ds7sy,jjm3dli,"So basically what I'm saying is backwards compatibility, if defined as being able to use old code in an unmodified state for many years, is very very important, but backwards compatibility, if defined in terms of implementation - the language itself a la C++, is going to hold you back, and you should put your dev time into a good package manager which, if done right, should give you that first kind of backwards compatibility for free a la Rust.",0.38557142857142856,Rust
13ds7sy,jjmzmn1,"For example, the C++ std::string transition in GCC 5 is somewhat handled by `abi_tag` but that requires a bunch of manual work which better tools would've done for us.",0.5,C++
13ds7sy,jl9f972,Programs in R are probably quite extreme in that they are often treated as a short-term sratchbook.,-0.125,R
13djghc,,"The idea is that the program acts as, essentially, a compilation script for itself, allowing for Python-like flexibility at compile time with the runtime performance of C++.",0.0,C++
13djghc,,"On the one hand, I do like Rust's style of passing by move-value by default.",0.0,Rust
13djghc,,"Ideally, I want the core part of the language to only contain the elegant bare minimum, and the rest of the language to be implemented as part of the standard library (the way Python does it).",0.29,Python
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,C++
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,Rust
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,Python
13djghc,jjlumgt,"Call me old school, but I've always appreciated Java's everything is a reference and references are passed by value.",0.15000000000000002,Java
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,C++
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,Rust
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,Python
13djghc,jjplij0,C++ templates are Turing complete.,0.1,C++
13djghc,jjplij0,I imagine Rust macros probably are too.,0.0,Rust
13djghc,jjplij0,And of course Python has `eval` and the various introspective bits.,0.0,Python
13djghc,jjno1oi,"Most mutable parameters should have Rust's ""borrow"" semantics, which are marked by an \`@\` at both declaration and use:      /fn inc @v[#Var #I32] => @v.update (x => x+1)          @my_var << /var 42[#I32]     /do inc @my_var     /do @os.stdout.write_line ""updated value is {my_var.get}""  Ownership transfer of resources is also available.",0.3333333333333333,Rust
13djghc,jjm4oot,"In general, I don't want to force a garbade collector, so object ownership and lifetimes are handled akin to C++ and Rust.",0.05000000000000002,C++
13djghc,jjm4oot,"In general, I don't want to force a garbade collector, so object ownership and lifetimes are handled akin to C++ and Rust.",0.05000000000000002,Rust
13djghc,jjlv9jy,"Python does the same thing, and I like it, but as you've said, it isn't appropriate without a garbage collector",0.25,Python
13djghc,jjpmeru,"To be honest, you can already do pretty much that in Python.",0.35000000000000003,Python
13djghc,jjpmeru,"My approach is just a bit more formal, with a stricter type system and some neat things that can't be conveniently implemented in Python (like traits and macros).",0.5,Python
13djghc,jjnzh50,Immutable reference is not the same as C's const-reference.,0.0,C
13djghc,jjplslr,The issue was that I basically want the same code to be viable as a constexpr (in C++ terms) function.,0.0,C++
13cyl98,jjiznr3,"Examples are ""C"" array, union, enum, or ""Pascal"" file of, set of.",0.0,C
13cyl98,jjiznr3,"Examples are ""C"" array, union, enum, or ""Pascal"" file of, set of.",0.0,Pascal
13cyl98,jjiznr3,"Of course, ""C"" types like ""int"", ""uint*"" or ""Pascal"" types like ""byte"" or ""integer"" are subitems of ""Integer"".",0.0,C
13cyl98,jjiznr3,"Of course, ""C"" types like ""int"", ""uint*"" or ""Pascal"" types like ""byte"" or ""integer"" are subitems of ""Integer"".",0.0,Pascal
13cyl98,jjiznr3,"The hierarchy starts with a conceptual abstract root type item, like C# or Java ""object"", but also applied to simple types, not just classes.",0.0,C
13cyl98,jjiznr3,"The hierarchy starts with a conceptual abstract root type item, like C# or Java ""object"", but also applied to simple types, not just classes.",0.0,Java
13caf1f,jjq3l8y,Pascal P-Code is surprisingly elusive to track down.,0.2722222222222222,Pascal
13caf1f,jjsm70h,"The story goes that the original Pascal compiler was written in Pascal to begin with, and then manually (painstakingly) compiled to P-code.",0.375,Pascal
13caf1f,jjsm70h,"Because Pascal is designed for one-pass compilation, it's also entirely possible that partial versions of the compiler might have generated code for other parts.",-0.075,Pascal
13caf1f,jjkwszk,"But I can generate renderings of sources in C, or my ASM (or now PCL), and work from those if need be.",0.0,C
13caf1f,jjtbzwj,I haven't actually used Pascal since I was at college in the late 70's.,-0.15,Pascal
13caf1f,jjtbzwj,"But then I tracked down what I believe are the actual [sources](http://pascal.hansotten.com/px-descendants/dec-pdp-10-pascal-compiler/) for Pascal on PDP10, and the main compiler is 12Kloc (plus a 4Kloc file for the library.",0.0037037037037036904,Pascal
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,JavaScript
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Kotlin
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Swift
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Rust
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Go
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Elixir
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Java
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Haskell
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,Scala
13c53kf,jjecylm,"It's at the point where [some say a language isn't suitable for production if it doesn't have good multicore support](https://news.ycombinator.com/item?id=35852321#unv_35855074) (also see Rust speeding through getting async/await *even though they already had `Send + Sync`*, and looking to add async traits).",0.625,Rust
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,Python
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,C++
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,C
13c53kf,jjecylm,"This is what TypeScript is: you have some typed values and untyped values, and want to verify and possibly optimize the typed code while permitting the untyped code; thus, the user is able to take an existing untyped codebase and ""gradually"" add types.",0.25,TypeScript
13c53kf,jjecylm,"Besides JavaScript/TypeScript, you'll find gradual typing on pretty much any other popular untyped language including [Python](https://docs.python.org/3/library/typing.html), [Lua](https://github.com/andremm/typedlua), and [Racket](https://docs.racket-lang.org/ts-guide/).",0.23125,Python
13c53kf,jjecylm,"Besides JavaScript/TypeScript, you'll find gradual typing on pretty much any other popular untyped language including [Python](https://docs.python.org/3/library/typing.html), [Lua](https://github.com/andremm/typedlua), and [Racket](https://docs.racket-lang.org/ts-guide/).",0.23125,Lua
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,TypeScript
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,Kotlin
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,Swift
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,Rust
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,Haskell
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,TypeScript
13c53kf,jjecylm,"Rust has them and is doing great, Haskell has implemented them as a “new experimental”-kind of thing.",0.40909090909090906,Rust
13c53kf,jjecylm,"Rust has them and is doing great, Haskell has implemented them as a “new experimental”-kind of thing.",0.40909090909090906,Haskell
13c53kf,jjecylm,"Other languages are looking to incorporate some variant or alternative to Rust’s borrowing rules: [Mojo (the hyped-up “AI” language) includes them](https://docs.modular.com/mojo/programming-manual.html#argument-passing-control-and-memory-ownership), and [Val-lang](https://www.val-lang.dev/) has mutable value semantics which are similar.",-0.2916666666666667,Rust
13c53kf,jjecylm,[Swift has first-class “actors” and “distributed” methods](https://www.swift.org/blog/distributed-actors/).,0.0,Swift
13c53kf,jjecylm,"[Unison](https://www.unison-lang.org/), Erlang, and Elixir are built with distributed being one of the #1 concerns.",0.0,Erlang
13c53kf,jjecylm,"[Unison](https://www.unison-lang.org/), Erlang, and Elixir are built with distributed being one of the #1 concerns.",0.0,Elixir
13c53kf,jjecylm,"Scala has [Akka](https://akka.io/) and is used WIDELY for distributed); whereas something like linear types and typed effects, you can't emulate in a library.",-0.1,Scala
13c53kf,jjecylm,"People are also working on Effect systems for Haskell ([eff](https://github.com/hasura/eff), [fused-effects](https://hackage.haskell.org/package/fused-effects), [effet](https://hackage.haskell.org/package/effet)).",0.0,Haskell
13c53kf,jjecylm,This is *not* in most general-purpose programming languages and probably never will be (maybe we'll see formal methods to verify unsafe code in Rust...) because it's a ton of boilerplate (you have to help the compiler type-check your code) and also extremely complicated.,-0.033333333333333326,Rust
13c53kf,jjecylm,Google’s compiler works on C++.,0.0,C++
13c53kf,jjfpibn,We're seeing a lot of work in the formal methods area and it's what I'm most excited about for existing languages -- projects like RefinedC that add refinement types and ownership types to C (using [[attributes]]...) and using them to automatically generate a proof of program correctness by guided search using the language semantics to tip off the search.,0.4375,C
13c53kf,jjfpwd6,"Rust demonstrating that there can be memory safety without runtime garbage collection seems like a big deal, and I would expect more languages to use similar systems, but try to require less information from the programmer (lifetime specifiers etc).",0.08333333333333334,Rust
13c53kf,jji6y27,"Ada had full typing (you can do gradual too), tasking and distributed (in an annex) from the start.",0.35,Ada
13c53kf,jjlczgs,"For me, I am hoping for an APL revival; all of what Python/numpy/AI is doing are APL but very verbose.",0.2,APL
13buw08,jjdosl4,\- Reference capabilities similar Rust borrow checker but expanded.,0.0,Rust
13buw08,jjdosl4,"\- Data sharing with actors without (necessarily)  copying all the data (like Erlang, if I understand this correctly) .",0.0,Erlang
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,Python
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,C
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,C++
13bodyk,jjeo08u,"I actually mad a trick to extend sealed classes in C# and Java ( Decorator Software Pattern), like stringbuilder class  * It's very good your P.L.",0.14249999999999996,C
13bodyk,jjeo08u,"I actually mad a trick to extend sealed classes in C# and Java ( Decorator Software Pattern), like stringbuilder class  * It's very good your P.L.",0.14249999999999996,Java
13bodyk,jjg37oz,"Sorry,but I don't understand the first one,do you mean I should let people decided how the objects identifiers are named?,cuz i plan to let them to do that,it's just a something like snake_case for rust and PascalCase for C# By extending class,you can add methods that don't exist in that class,think of it like traits from rust or extensions from C# So I shouldn't add sealed classes?,I could do that,I thought it could be useful,so as stuff that shouldn't be inherited from should be sealed  Thanks for the compliments on props and access stuff,I also plan to add stuff like modules(similar to static classes from C#,but importing them automatically gives you the methods without the need to type of the static class name)",0.22749999999999998,C
13bodyk,jjdb0ur,"The tilde is a bitwise operator in C, it’s not some unused symbol like you’re saying.",0.0,C
13bfvx5,,"Users should be able to add their own IO by wrapping Charm around embedded Go, it shouldn't be something that can be done only by me by hard-wiring stuff.",0.3666666666666667,Go
13bfvx5,,Charm is a [Functional Core/Imperative Shell language](https://github.com/tim-hardcastle/Charm/blob/main/docs/functional-core-imperative-shell.md).,0.0,Shell
13bfvx5,,"If there's a Go library for talking to something, it's a work of minutes for anyone who pleases to write their own `get` and `put` and `post` and `delete` commands for accessing it.",0.6,Go
13bfvx5,jjb2ep3,Can you elaborate on how this differs from Haskell's use of the IO monad?,0.5,Haskell
13bfvx5,jjb2ep3,Your `get` is very similar to the `x <- readFile ...` notation of Haskell's `do`-notation (which is sugar for the `>>=`operator).,0.0,Haskell
13bfvx5,jjb2ep3,"Haskell has nothing corresponding to `put`, `post` or such things - that's usually just done by IO actions that return a unit value.",-0.125,Haskell
13bfvx5,jjb2ep3,"Haskell's IO model is not perfect, mostly in that it is not possible to limit exactly *which* kinds of IO are possible, but it is probably the most widely used system that delimits pure and impure code in a principled manner.",0.10803571428571429,Haskell
13bfvx5,jjbkire,"You don't even really need a wrapper language, you can kinda just choose to write a functional subset of Go.",0.2,Go
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,Python
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,Java
13bfvx5,jjbi0mq,>Can you elaborate on how this differs from Haskell's use of the IO monad?,0.5,Haskell
13bfvx5,jjbi0mq,I'm not a big expert on Haskell.,0.0,Haskell
13bfvx5,jjbi0mq,The way they are *similar* is that Charm and Haskell are both functional languages dealing with how you do IO.,0.0,Haskell
13bfvx5,jjbi0mq,Whereas I couldn't give you a detailed breakdown of how Haskell monads work but I'm sure it isn't like that.,0.45,Haskell
13bfvx5,jje7e1m,Am I wrong or does this look like Haskell IO monad in disguise?,-0.5,Haskell
13bfvx5,jjchhqy,"You can do the same in Haskell if you are in IO:      main :: IO ()     main = do         myVar <- newIORef ""foo""         modifyIORef myVar (<> ""bar"")         putStrLn =<< readIORef myVar // prints `foobar`  The IORef could be imported from somewhere else.",0.1111111111111111,Haskell
13bfvx5,jjbooxw,I'd rather write Charm than Go any day :-),0.5,Go
13aobtm,,"I am gravitating towards `!` because I am most familiar with C#, Java and other curly-brace languages.",0.25,C
13aobtm,,"I am gravitating towards `!` because I am most familiar with C#, Java and other curly-brace languages.",0.25,Java
13aobtm,,": {""Alice"", ""Bob""}  Eew!",-0.9375,Alice
13aobtm,,"This looks a lot better (IMO):      name ~: {""Alice"", ""Bob""}  So I am torn: Should I go for familiarity (least surprise) `!` or for aesthetics `~` or some other option?",-0.1875,Alice
13aobtm,,"(Length >= 1 && Length <= 30)          // The set of names already taken     TakenNames = allowableNames && { ""Alice"", ""Bob"" }          // The set of allowable names that are not taken     AvailableNames = AllowableNames & !TakenNames           // A ""variable"" of the type (member of the set)     myNewName : AvailableNames  The definition of `AvailableNames` uses the complement of `TakenNames`.",0.0,Alice
13aobtm,jj8wkn4,I’m seeing a lot of “Do what C does” in the comments.,0.0,C
13aobtm,jj7vjo2,My philosophy is to do what C does unless I have a good reason not to.,0.7,C
13aobtm,jj8gnji,And why use a symbol at all: even C allows you to use `not` and `compl` for `!` and `~` respectively.,0.0,C
13aobtm,jj8hy7s,"A story that might be illuminating: in Lua, the ""not equals"" operator is `~=` instead of the C-style `!=`.",0.0,Lua
13aobtm,jj8hy7s,"The reason for this is that Lua was created in Brazil, and [the portuguese keyboard](https://cdn.shopify.com/s/files/1/0810/3669/files/portuguese-brazilian-abnt2-mac-kblayout-unilingual-2021.png) has a tilde on the home row of the keyboard (where the apostrophe/quote key is on a QWERTY keyboard).",0.0,Lua
13aobtm,jj9b6od,Given that you have a focus on sets and describe your language as  >  a logic programming language based on set theory  I'd probably stray away from your typical C syntax and try to design it more intuitively for that domain.,0.16666666666666669,C
13aobtm,jj9gd6e,"C has `~` for bitwise NOT (`!` for logical NOT), so it’s still familiar to most people.",0.375,C
13aobtm,jm6akjc,i use “~” (because my language only has bitwise negation and that’s what C uses for that) but it’s kind of ugly for booleans,-0.033333333333333326,C
13aobtm,jj89827,"The only reason C has two operators, `!` and `~` is because it has no built-in boolean type.",0.0,C
13aobtm,jj87se6,"The symbol abuse in C and its subsequent proliferation in C-derived programming languages is a silly convention established because of the lack of a sufficient number of symbols in early character sets, and some misguided desire to avoid spelling things out with reserved words like ""not"", ""NOT"", or "".NOT."".",-0.13333333333333333,C
13aobtm,jj8goe0,"After seeing Rust’s janky syntax, just don’t.",0.0,Rust
13aobtm,jj844lv,> My philosophy is to do what C does unless I have a good reason not to.,0.7,C
13aobtm,jj8l2gl,Go figure.,0.0,Go
13aobtm,jj8k7ly,> And why use a symbol at all: even C allows you to use not and compl for !,0.0,C
13aobtm,jj8k7ly,I had no idea C had support for operators as words!,0.0,C
13aobtm,jj8j027,"For example, ALGOL was pretty agnostic about the exact syntax details, letting you use beautiful mathematical operators in print, but also letting you type those operators in a way that actually works on your keyboard.",0.27,ALGOL
13aobtm,jj8j027,"Similarly, C's digraphs.",0.0,C
13aobtm,jj8j027,"Similarly, there have been programming languages that invented entirely novel operators, requiring custom keyboards – notably APL.",0.16666666666666666,APL
13aobtm,jj8j027,"Such a language would not catch on nowadays, and APL's modern incarnation in the form of J has [thankfully ASCIIfied the syntax](https://code.jsoftware.com/wiki/APL2JPhraseBook).",0.1,APL
13aobtm,jj8hbnm,"The ONLY “symbol abuse” in C is that declaring and dereferencing pointers both use the asterisk, that was a bad move and I wish that was different.",-0.23333333333333328,C
13aobtm,jj8juj3,Rust introduced very little novel syntax.,-0.24375000000000002,Rust
13aobtm,jj8juj3,The rest is just a fairly bog-standard ML-family language dressed up to look like C++.,0.7,C++
13aobtm,jj87lca,"I also have good reasons, but it also means your language learning materials need to cover integer operators instead of saying “look at C”.",0.7,C
13aobtm,jj8ubo8,Rust has proven that it causes no end of confusion to do that.,0.0,Rust
13aobtm,jj8ubo8,Stick very close to C for symbolic operators.,0.2,C
13aobtm,jj8ubo8,"Don't be afraid to add new *keyword* operators, like Python has `is`, `in`, and `not in` (the last is actually two keywords!)",-0.1159090909090909,Python
13aobtm,jj858k3,JavaScript.,0.0,JavaScript
13aobtm,jj8a65i,You could look at how Julia does it.,0.0,Julia
13aobtm,jj9c1dr,APL family and Smalltalk does not have any precedence.,0.0,APL
13aobtm,jj9c1dr,"Again, APL family has strict right-associativity, which simplifies stuff a lot.",0.0,APL
13aobtm,jj8m6dk,When C and it's operators where designed there wasn't a boolean type.,0.0,C
13aobtm,jj8jz7a,"C may have a bool, but it is not disjoint from integers.",0.0,C
13aobtm,jj8kyth,APL uses keystrokes these days to make those characters.,0.0,APL
13aobtm,jja07bs,"Bro, fn instead of the return type, with the return type on the far right like C++ invented as alternative syntax in C++11  may not technically be inventing new syntax, but it’s still violates the principle of least surprise, which is my entire point.",0.037012987012987004,C++
13aobtm,jj9314v,Genuine comment : how does one type APL at a reasonable pace on a normal keyboard ?,0.25000000000000006,APL
13aobtm,jj93ijz,"Scriptsprog som HyperTalk og MPW Shell brugte mange af disse symboler, og jeg oplevede aldrig at det danske tastatur var et problem, ikke engang i C, selv om ""{}"" var Option-Shift-""("" og "")"", fordi ""\["" og ""\]"" var Option-""("" og "")"", hvilket for såvidt er en ganske fornuftig og logisk placering,som de temmelig sikkert stadig har.",0.0,Shell
13aobtm,jj93ijz,"Scriptsprog som HyperTalk og MPW Shell brugte mange af disse symboler, og jeg oplevede aldrig at det danske tastatur var et problem, ikke engang i C, selv om ""{}"" var Option-Shift-""("" og "")"", fordi ""\["" og ""\]"" var Option-""("" og "")"", hvilket for såvidt er en ganske fornuftig og logisk placering,som de temmelig sikkert stadig har.",0.0,C
13aobtm,jj9mes5,"Your language learning materials should never say ""look at C"".",0.0,C
13aobtm,jj8m0l2,Sometimes one would think that C had been deliberately designed to insultingly annoy countries that do not have English as the primary language.,-0.19999999999999998,C
13aobtm,jj8m0l2,"And no, as far as I can tell/recall (I began studying/using C in 1986-87), no European programmer ever asked for trigraphs, I think it was rather the opposite.",0.03333333333333333,C
13aobtm,jj9w14l,"Such a low precedence for the former I think is unsuitable for bitwise manipulations, and there is also no reason for the latter to have different precedences across `and or xor` (I know C thinks otherwise).",0.0,C
13aobtm,jj9w14l,"My symbols for these ops are:                 type      precedence          not        logical     and                  5, say (I'd have to go and check)     or                   6 (both and,or short-circuit)          inot       bitwise     iand                 3 (same as + -)     ior                  3     ixor                 3  (I can't remember exactly where `iand` etc came from; it might have been from Fortran.",0.041666666666666664,Fortran
13aobtm,jjb9a9e,C's syntactic innovation that declaration looks like use has been generally considered to be a mistake.,0.05000000000000002,C
13aobtm,jjb9a9e,"This is real C code, written by real C programmers:      int (*(*(foo)(int))(double))(float);  Many curly-brace languages have deviated to some degree from that madness, separating the type syntax more clearly from the expression syntax (and often, disallowing function pointers).",0.3,C
13aobtm,jjb9a9e,"In that regard, Rust's syntax for types and functions is entirely mainstream with contemporary languages, *in particular if you note that it's mostly an ML-family language dressed up with curly braces*.",0.20833333333333331,Rust
13aobtm,jjb9a9e,"Since we're in r/ProgrammingLanguages, I'd also like to point out that C style circumfix declarations have a lot of local ambiguity, so you need to parse the entire declaration in order to know what it is (compare also the [""most vexing parse"" in C++](https://en.wikipedia.org/wiki/Most_vexing_parse)).",0.16666666666666666,C
13aobtm,jjb9a9e,"Since we're in r/ProgrammingLanguages, I'd also like to point out that C style circumfix declarations have a lot of local ambiguity, so you need to parse the entire declaration in order to know what it is (compare also the [""most vexing parse"" in C++](https://en.wikipedia.org/wiki/Most_vexing_parse)).",0.16666666666666666,C++
13aobtm,jjb9a9e,"In C, this strongly pushes you towards LR style parsers.",0.4333333333333333,C
13aobtm,jjb9a9e,"In C++, the parser also needs to track a symbol table, potentially requiring the evaluation of templates during the parse.",0.0,C++
13aobtm,jjb9a9e,"In contrast, Rust's syntax makes it possible to clearly separate syntax and semantics in the compiler (at the cost of needing the turbofish `::<T>()` pseudo-operator).",0.05000000000000001,Rust
13aobtm,jj9lkqg,Special APL keyboards have the symbols written on the keys (in addition to regular letters) and an APL mode switch.,0.17857142857142858,APL
13aobtm,jj8kxv9,"Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",-0.08571428571428572,R
13aobtm,jj8kxv9,"Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",-0.08571428571428572,APL
13aobtm,jjgeymw,Raku (and Perl) is really something different.,0.1,Perl
13aobtm,jjbxx6a,"I imagine people just don't like the C++ syntax, but it's a very valid point that applies to real generics as well.",0.2,C++
13aobtm,jj8rzss,"Having coded a lot of Prolog, one of the issues I found was that it was pretty hard to use another search strategy than the default depth-first search.",-0.020833333333333343,Prolog
13aobtm,jj8rzss,":-)      \> Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",0.10952380952380954,R
13aobtm,jj8rzss,":-)      \> Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",0.10952380952380954,APL
13aobtm,jjbhqtm,"Yes you can have finer graduations, but then you end up with a scheme like C's with far too many levels, many arbitrary and unintuitive, which nobody can remember and you end up just using parentheses anyway, so that there was no point.",0.25,C
13a4id1,jj5kfw3,"Rust's `fn index_mut<T>(vec: &mut Vec<T>, index: usize) -> &mut T`; if you want to be able to write      list[index] = 5;     return list;  (or, with less syntax sugar)      *list.mut_at(index) = 5;     return list;  then you need to go from having a `&mut Vec<i32>` to a `&mut i32` with `list[index]` and then go back to having the original `Vec<i32>` so that you can return it.",0.17708333333333334,Rust
13a4id1,jj5kfw3,"Rust manages this with lifetime annotations (where in safe Rust, the borrow checker ensures that mutable references cannot alias anything else).",0.5,Rust
13a4id1,jj5kfw3,"Val fixes this essentially by using continuation passing for indexing; the Rust equivalent would be essentially      list.with_mut_at(index, |item: &mut i32| {       *item = 5;     });  and now *this* works, and is just as flexible, since e.g.",0.0,Rust
13a4id1,jj5kfw3,"A more practical example would be (just like Rust's `Mutex`) you could define a `Mutex<T>` where you write `mutex.unlock[]` to get a (mutable reference to) the item inside, which will automatically wait to lock it and unlock the mutex when you no longer use the result.",0.5,Rust
13a4id1,jj7o69w,"If you go the Rust route and have &unique references, you can internally modify them all you want without aliasing anything externally  Rust has aliasing, but if you just disable it people would just do      string1 = strip(arg);     string2 = escapeHTML(string1);  it wouldn't actually be so bad in Rust's case, a minor inconvenience",-0.07499999999999997,Rust
13a4id1,jj8z4ep,"Hence, Rust uses borrow checking by annotating all (mutable) references with lifetimes.",0.0,Rust
139jnyx,,"You either have to set a mask then OR with the mask then XOR, something like this in C:      int bitwise_not(int num) {         // Create a mask with all bits set to 1         int mask = (1 << (sizeof(int) * CHAR_BIT - 1));         mask |= mask - 1;         // XOR the input number with the mask to get its bitwise NOT         return num ^ mask;     }  --- Why do I have to avoid unary operator?",-0.75,C
139jnyx,jj50f27,"Haskell also uses concatenation for function application, but it is higher precedence than arithmetic operators:  * your first example is written `fn1 a 123 65.7` as above * but your second case needs parens:  `fn1 a (123 + 456) (65.7 * 345)` * and unary operators use the same: `fn1 a (123 + 456) (- x)`",0.1,Haskell
139jnyx,jj6c4tu,"In Haskell, all operators are unary.",0.0,Haskell
139jnyx,jj6c4tu,"In Forth, words can operate on some fixed number of arguments.",0.1,Forth
139jnyx,jj6bay4,Doesn't Julia do this?,0.0,Julia
13993w0,,"I started learning Python, which is probably a good skill to have, but its feature set where manipulating raw bits is concerned seems to be ... lacking.",0.2346153846153846,Python
13993w0,jj2isii,"It seems like you are looking for an array programming language like APL, J, BQN, or, since you mentioned Python, Numpy.",0.0,APL
13993w0,jj2isii,"It seems like you are looking for an array programming language like APL, J, BQN, or, since you mentioned Python, Numpy.",0.0,Python
138yw57,jj0h18t,Write a Forth.,0.0,Forth
138yw57,jj356qn,Maybe take a look at Scheme in 48 hours and expand upon that.,0.0,Scheme
138yw57,jj0e2m6,You can investigate Racket — which was once called PLT Scheme (PLT stands for programming language theory).,0.0,Scheme
138yw57,jj0e2m6,It’s a variant of Lisp that is tailor-made for such a project.,0.0,Lisp
138yw57,jj0e2m6,Common Lisp might be another good choice.,0.19999999999999998,Lisp
138yw57,jj0i4m7,"Python: print(""hello, world!"")",0.0,Python
138yw57,jj0i4m7,"C:   #include <studio.h>  float GPA= 4.0;  int main(){     printf(""hello, world!",0.20833333333333331,C
138yw57,jj0i4m7,"Take structs in C, and make everything a struct.",0.0,C
138yw57,jj1n7c6,"And also i learned C (primary lang ) language, Assembly (NASM for linux) deeply.",0.2,C
138yw57,jj1n7c6,"And also i learned C (primary lang ) language, Assembly (NASM for linux) deeply.",0.2,Assembly
138yw57,jj2u03a,"It's so well written, you can follow the explanation and decide whether you want to do it in Java as the book (at least for the tree-walking interpreter) or in another programming language.",-0.3,Java
138yw57,jj0pjce,"Yes, so far it looks like I will read the Crafting Interpreters to get the basics in hand and make some POC, look at Forth, Racket and LLVM, then consider the scope of application and get to it.",0.1,Forth
138yw57,jj0pjce,"So far Im very excited about it, will be tough for sure, but wouldnt be fun if it wasnt :D",0.33310185185185187,D
138yw57,jj0p2n8,"> > Python: print(""hello, world!"")",0.0,Python
138yw57,jj0n2qb,Forth is a stack-based programming language family/environment.,0.0,Forth
138yw57,jj0n2qb,I wrote a Forth as part of my degree's first year end project.,0.25,Forth
138yw57,jj0o686,"But fair enough, not everyone likes Lisp.",0.35,Lisp
138yw57,jj1w2id,If you are serious about PL design you absolutely need to look into a Scheme and Racket is amazing for writing languages.,0.15555555555555559,Scheme
138yw57,jj0sopn,That's Lisp.,0.0,Lisp
138yw57,jj0sopn,"Obviously as a class project you're not looking to invent the next C, but why not illustrate the potential?",0.0,C
138yw57,jjldxzm,"You can go down the rabbithole as far as you want with a Forth; making it on LLVM, making your own VM etc.",0.18148148148148147,Forth
138yw57,jj14jyg,> That's Lisp.,0.0,Lisp
138yw57,jj11oui,"Anyway, I actually had the idea originally as an esolang, where everything is a C struct.",0.1875,C
138swus,jj1g3jp,"I use [Asciidoctor](https://asciidoctor.org/), [highlightjs](https://highlightjs.org/), a custom highlight.js language definition and that bash script:      #!/bin/bash     asciidoctor spec.adoc     ex spec.html <<eof     11 insert     <link rel=""stylesheet"" href=""https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/routeros.min.css"">     <!-- other hljs definitions I need (C, x86asm, etc..) -->     .",-0.125,C
138swus,jj1g3jp,"(The seemingly useless removing-then-rewriting conums at the end is necessary because Asciidoctor writes annotations as HTML in the code to display, prompting highlight.js to fill your console with ""unescaped HTML"" security warnings).",-0.25,HTML
138swus,jj90o98,"The easiest might just be to give your lexer the ability to turn a token stream into HTML, which you can then style with CSS.",0.0,HTML
138swus,jj90o98,"Even better, add multiple output format support: HTML, LaTeX, Markdown, etc.",0.25,HTML
138swus,jjdem9s,"](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site)  Alternatively, you can make the lexer output HTML, render the HTML into an image (pretty much just open it in a browser and take a screenshot), then paste the image in your README.",0.15,HTML
13872od,jj0xhrh,"Not an objective metric, but a while back I had to implement parsers for a number of languages, and for testing I created a ""stress test"" file for each language ([Lua example](https://github.com/boppreh/structured-editor/blob/master/test_files/full.lua)).",0.0,Lua
13872od,jj0xhrh,"- Whether it's a keyword or symbol heavy language, and family type (C, Lisp, something exoteric).",-0.2,C
13872od,jj0xhrh,"- Whether it's a keyword or symbol heavy language, and family type (C, Lisp, something exoteric).",-0.2,Lisp
13872od,jj0xhrh,- Surprising rules (I learned some hideous tricks in Python that come in handy when golfing).,0.6499999999999999,Python
13872od,jizsh74,"There are languages that just embed SQL, Prolog or Assembly, which, as features, are not really ""big.""",0.0,Prolog
13872od,jizsh74,"There are languages that just embed SQL, Prolog or Assembly, which, as features, are not really ""big.""",0.0,Assembly
13872od,jizsh74,"To work with my language I have a 1478 lines long highlighting grammar file, of which 985 lines are dedicated to x86-64 Assembly alone; that's 66% of `cmova`, `cmovae`, `cmovb`, `cmovbe` and their friends.",-0.05,Assembly
13872od,jizsh74,C# in other words.,-0.125,C
13872od,jj08b1h,"|Language | [Ecstasy](https://github.com/xtclang/) language| |:--|:--| |Target | Interpreter, JVM bytecode (wip), LLVM IR and WASM (planned)| |EBNF | yeah| |AST node types | 95| |Compiler & runtime | 272 kloc (mostly Java, some C, some Ecstasy)| |Class libraries | 119 kloc (pure Ecstasy)| |Tests | 11 kloc|",0.35714285714285715,Java
13872od,jj08b1h,"|Language | [Ecstasy](https://github.com/xtclang/) language| |:--|:--| |Target | Interpreter, JVM bytecode (wip), LLVM IR and WASM (planned)| |EBNF | yeah| |AST node types | 95| |Compiler & runtime | 272 kloc (mostly Java, some C, some Ecstasy)| |Class libraries | 119 kloc (pure Ecstasy)| |Tests | 11 kloc|",0.35714285714285715,C
13872od,jj17y5p,"| Language | [Sourcerer](https://gitlab.com/cal-coop/utena/haaden-two/-/tree/master/Code/Sourcerer) | |--|--| | Target architecture | The [Utena VM](https://gitlab.com/cal-coop/utena/utena-specification/-/tree/new-spec) | | EBNF productions | 15 | | AST node types | 10 | | Compiler language | Common Lisp | | Compiler lines of code | 314 | | Tests | 203 lines, 13 unit tests |",-0.3,Lisp
13872od,jj1tgm0,"Much better than EBNF.| |AST Node Types|35| |Host Language|Python| |Implementation Code Size|About 2,500 lines of Python.",0.5,Python
13872od,jj0bztq,C is a P.L.,0.0,C
13872od,jj0bztq,"<edited>  Two keywords that I would like in C would be ""function"" or ""variable"", for function or variable declarations.",0.0,C
13872od,jj0bztq,Several C based P.L.,0.0,C
13872od,jj0bztq,"C designers did mentioned once, that they did considered add them, but rejected them, due it was required C programs to be as short as possible.",-0.041666666666666664,C
1378d15,jisdcgg,> We have a short bus that fetches old ladies from the home to teach our young whipper-snappers to maintain the COBOL systems those same ladies wrote before the Hula Hoop was cool.,0.11000000000000001,COBOL
1378d15,jivvvee,Async/await (at least in Rust) can be used to make a single-threaded solution but it is ugly because async/await is more complex than necessary yet lacks some of the desired functionality.,-0.16,Rust
1378d15,jisjvrr,"With checked-exceptions *as in Java*, the inject-ee appears to need static annotations about things which are not its proper concern.",0.25,Java
1378d15,jiy3cg9,"From this page:  > Haxl is a Haskell library that simplifies access to remote data, such as databases or web-based services.",0.13333333333333333,Haskell
1378d15,jisptp1,I just believe Java gets it wrong by enforcing the checking in the wrong place.,-0.5,Java
1378d15,jitztib,I have found Clojure’s dynamically scoped Vars to be very useful for dependency injection and for mocking effectful functions during testing.,0.39,Clojure
1378d15,jitrppl,"Additionally, if you do it the Rust way you force checking all exceptions.",0.0,Rust
13761ke,jis71v7,"Short version:   > In my language, Assembly and binary jumps and calls are typechecked, as in CPU and memory states are checked by a compiler, using a Dependent Type System (as in, it works by you spelling relations between live data) that specialises types down to the smallest units: values.",0.1202020202020202,Assembly
13761ke,jis71v7,"> It also understands Linux and GNU C APIs and ABIs, meaning Undefined Behaviour is impossible.",-0.6666666666666666,C
13761ke,jis71v7,"> It features, among other things, refinement types, safe GC-less aliasing semantics, automated theorem proving, algebraic effects, and a safe interface abstracting Linux and GNU C APIs, as well as System V’s syscall ABI.",0.2916666666666667,C
13761ke,jiv6wt7,"""Hey, fellow logicians, you want some basic logic programming with intuitive syntax, but without all Prolog's hustle?",0.0,Prolog
13761ke,jisrw3k,"""The paradigmatic use-case in my head is an SME using Excel and PHP and SQL and Python and duct-tape to run their show.",0.0,PHP
13761ke,jisrw3k,"""The paradigmatic use-case in my head is an SME using Excel and PHP and SQL and Python and duct-tape to run their show.",0.0,Python
13761ke,jjlzctq,:D,1.0,D
13761ke,jitomzi,Rust?,0.0,Rust
13761ke,jjsiygf,"Looks like this:      f {in rsi: s64; out rax: s64; call}:         mov rax, 2         imul rax, rsi         ret          //`^T` being pointer syntax, as in Pascal     g {in rsi: ^s64, rdi: typeof f, rdx: s64; out [rsi]; clob rax; call; stack 8}:         push rsi         mov rsi, rdx         call rdi         pop rsi         mov [rsi], rax   //useless but shows NRVO         ret          main {tailcall}:         sub rsp, 8         mov rsi, rsp         mov rdi, f         mov rdx, 21         call g                  mov rsi, [rsi]         add rsp, 8         jmp printInt    Here, the indirect call to `f` via `rdi` causes the two signatures to unify:     - `rsi` is clobbered, but `g` pushes and pops it, so the checker ignores it   - `out rax` is translated to `clob rax`  I could also manually save RAX on the stack by increasing the stack size, at which point the checker would happily let me omit the fact that it is written to.",0.48333333333333334,Pascal
13761ke,jjsiygf,"All this also is a learning experience in Assembly and systems programming for me, so I know many details are left out (EFLAGS, FP flags, etc..).",0.25,Assembly
13761ke,jjsiygf,"It all is nice in that it's some kind of a programmatically laid out ABI syntax, but there is still an ""Abstract-Concrete Barrier"" where you have to manually write a signature mapping a routine's ABI to a Haskell-like function type and how it must ignore registers and stack data that has been clobbered (EDIT: mainly talking about binary code here, not textual and typed Assembly.",0.45555555555555555,Assembly
13761ke,jjsiygf,"jnz somewhere                  sub rsp, 16     //Like in TypeScript and Ceylon         mov [rsp], rdx                  mov rdx, rdi         lea rsi, [rsp+8]         mov rdi, f         call g         mov rax, [rsi]                  mov rdx, [rsp]         add rsp, 16         ret  where `loc: some T` just means that `loc` will be matched over.",0.0,TypeScript
13761ke,jjsiygf,"As far as GNU C is concerned, I have a file that types the dynamic  jumps, so I guess that's cheating.",0.05,C
13761ke,jiw5jzn,I used to make PHP frameworks for fun before I got interested in compilers.,0.275,PHP
13761ke,jitzbfi,"Where I think I am original is that I'm exploring the Assembly and binary space: all that ported to Typed Assembly, and porting that Assembly analysis to binary code.",0.375,Assembly
13761ke,jitzbfi,That's where Linux and GNU C interop comes in: the compiler reads statically linked objects and understands the syscalls and dynamic jumps into glibc.,0.0,C
136xdss,,"Existing languages such as Verilog, and VHDL are absolutely horrible to write in and use very old school syntax and semantics.",-0.29,Verilog
136xdss,,"Existing languages such as Verilog, and VHDL are absolutely horrible to write in and use very old school syntax and semantics.",-0.29,VHDL
136xdss,,"I think there is so much room for some new HDLs that can absorb great semantics and learnings from modern languages such as Go, Rust, Python etc.",0.2672727272727273,Go
136xdss,,"I think there is so much room for some new HDLs that can absorb great semantics and learnings from modern languages such as Go, Rust, Python etc.",0.2672727272727273,Rust
136xdss,,"I think there is so much room for some new HDLs that can absorb great semantics and learnings from modern languages such as Go, Rust, Python etc.",0.2672727272727273,Python
136xdss,jisldod,You don't like Verilog?,0.0,Verilog
136xdss,jisluyw,"There are quite a few innovations in HW design, exactly because nobody really likes Verilog.",0.08333333333333333,Verilog
136xdss,jisluyw,"Already mentioned Chisel: https://www.chisel-lang.org/  Bluespec Verilog: https://en.wikipedia.org/wiki/Bluespec  SystemC: https://systemc.org/ (primarily considering  HLS)   Some companies internally mix Verilog with various templating languages such as, oh my, PHP.",0.1,Verilog
136xdss,jisluyw,"Already mentioned Chisel: https://www.chisel-lang.org/  Bluespec Verilog: https://en.wikipedia.org/wiki/Bluespec  SystemC: https://systemc.org/ (primarily considering  HLS)   Some companies internally mix Verilog with various templating languages such as, oh my, PHP.",0.1,PHP
136xdss,jisluyw,"As it has already been mentioned, all those language tools are actually transpilers that generate Verilog, because you need to integrate into a hardware design flow.",0.0,Verilog
136xdss,jisluyw,"Now imagine 1) you have some quite advanced language on input, something like Haskell, 2) considerable part of your work happens in the assembly produced by a super advanced optimizing Haskell compiler and done by different people with very different skill sets, 3) aaand, what is worse, sometimes those people get back to you and tell that some particular assembly instructions do not fit for some reason, could you please modify your Haskell code in order to generate slightly different assembly?",0.07272727272727274,Haskell
136xdss,jir8450,It's based on Scala.,0.0,Scala
136xdss,jiytiag,"I mean, Verilog as a language, for example, is certainly no worse then something like JavaScript.",-0.056249999999999994,Verilog
136xdss,jiytiag,"I mean, Verilog as a language, for example, is certainly no worse then something like JavaScript.",-0.056249999999999994,JavaScript
136xdss,jiqpo5g,"Cool thanks for sharing, looks too Haskelly for my tastes   I’d love a bastardisation of Go and Rust",0.35000000000000003,Go
136xdss,jiqpo5g,"Cool thanks for sharing, looks too Haskelly for my tastes   I’d love a bastardisation of Go and Rust",0.35000000000000003,Rust
136xdss,jisup8y,VHDL and Verilog both reduce to a RTL.,0.0,VHDL
136xdss,jisup8y,VHDL and Verilog both reduce to a RTL.,0.0,Verilog
136xdss,jisup8y,The main vendors support both VHDL and Verilog.,0.16666666666666666,VHDL
136xdss,jisup8y,The main vendors support both VHDL and Verilog.,0.16666666666666666,Verilog
136xdss,jisup8y,I'm no expert but have used VHDL a bit.,0.0,VHDL
136wdfw,,"Many note it doesn't solve their AI development woes, introduce new concepts, and offers hardly more than a Python reskin with a helping of Kotlin/Nim.",0.3090909090909091,Python
136wdfw,jirmsnm,"APL with a modern skin and the ability to JIT to Cuda, ROCM, and FPGA.",0.2,APL
136wdfw,jiszcjf,"Easier for math and logic (like Julia), and harder for shared memory and side effects (like Rust).",-0.1,Julia
136wdfw,jiszcjf,"Easier for math and logic (like Julia), and harder for shared memory and side effects (like Rust).",-0.1,Rust
136wdfw,jiszcjf,Mojo is trying to do that while being a superset of Python to make translation easier.,0.0,Python
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,Rust
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,C++
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,Python
136wdfw,jisnaim,"Already working on it.. and have been for years :)  Must be: - High performance (as fast or faster than C.. surprisingly I believe we can definitely beat C) - Easy to read and understand output by humans (Can be made easier to read than Python) - Minimize bugs that can make it past compiler and make it very easy to follow errors being thrown - and more  Checkout our very much alpha version of the website (Other than front page.. needs a lot of work, documentation and tutorials aren't real yet)  We would definitely appreciate some help if anyone is interested in helping out!",0.24672619047619046,C
136wdfw,jisnaim,"Already working on it.. and have been for years :)  Must be: - High performance (as fast or faster than C.. surprisingly I believe we can definitely beat C) - Easy to read and understand output by humans (Can be made easier to read than Python) - Minimize bugs that can make it past compiler and make it very easy to follow errors being thrown - and more  Checkout our very much alpha version of the website (Other than front page.. needs a lot of work, documentation and tutorials aren't real yet)  We would definitely appreciate some help if anyone is interested in helping out!",0.24672619047619046,Python
136wdfw,jit44ec,"Nothing, because Python already satisfied most needs and has enough momentum as the most popular language alongside JS to maintain that.",0.42000000000000004,Python
136wdfw,jit44ec,"So C, as a flawed portable assembler, is the first thing that would need to be improved, and you can work hard to make sure this is your lingua franca for programs by porting it to whatever platform there is.",-0.010416666666666685,C
136wdfw,jit44ec,"Then, once you have a better C, you would need a sort of a Java.",0.5,C
136wdfw,jit44ec,"Then, once you have a better C, you would need a sort of a Java.",0.5,Java
136wdfw,jit44ec,"And finally, you would need to have a communication layer akin to Python, or rather, an API language.",0.0,Python
136wdfw,jit44ec,"There is no way in hell you will get data scientists, which are not just used to high level language syntaxes but also sometimes not that PL savvy, to use this alternative without it at least not being as easy and easily learnable as Python, if not more.",0.09533333333333334,Python
136wdfw,jit44ec,"---  **tl;dr** An AI programming language is 3 separate languages chained together: an improved C, an improved Java, and an improved Python/JS/SQL mutant.",0.0,C
136wdfw,jit44ec,"---  **tl;dr** An AI programming language is 3 separate languages chained together: an improved C, an improved Java, and an improved Python/JS/SQL mutant.",0.0,Java
136wdfw,jit44ec,This is to be expected since modern AI development is a Python - Framework (IL/CUDA) - C(++)/FORTRAN - ASM chain.,0.05,Python
136wdfw,jit44ec,This is to be expected since modern AI development is a Python - Framework (IL/CUDA) - C(++)/FORTRAN - ASM chain.,0.05,C
136wdfw,jit44ec,"No amount of APL copium would make it usable by humans generally and considered approachable for big companies who throw money at it, and make modern AI development possible.",0.0625,APL
136wdfw,jirq0vk,What would a modern skin of APL involve?,0.2,APL
136wdfw,jiqo8v9,Do we agree that JavaScript is terrible in regards to linear algebra (which is core of machine learning) because it lacks operator overloading?,-1.0,JavaScript
136wdfw,jist58c,>Mostly ASCII instead of cryptic symbols    Why not use machine learning to do APL as it was intended?,0.0,APL
136wdfw,jjleph0,The only people who call APL read-only or linenoise are the people that never wrote anything in it.,0.0,APL
136wdfw,jiv7e09,I think this would work really nicely as a DSL in an existing flexi-imperative-functional language like Julia.,0.6,Julia
136wdfw,jirr52w,"Prolog, Forth, APL",0.0,Prolog
136wdfw,jirr52w,"Prolog, Forth, APL",0.0,Forth
136wdfw,jirr52w,"Prolog, Forth, APL",0.0,APL
136wbeh,jiqy8zy,Consider [Haskell](https://www.haskell.org/onlinereport/decls.html) which uses `infix(l|r)?,0.0,Haskell
136wbeh,jiqy8zy,An issue with the Haskell design is its limitation to 10 precedence levels.,0.0,Haskell
136wbeh,jiqy8zy,Haskell also allows using *any* non-operator function as an infix operator by surrounding it by \`backticks\`.,0.0,Haskell
136wbeh,jix43m9,"> You are the only other person I have ever seen propose this,   > nobody is doing it this way  Have a look at this article: https://blog.adamant-lang.org/2019/operator-precedence/    Rust is actually doing it too: https://doc.rust-lang.org/reference/expressions.html#expression-precedence  My language has [this precedence graph](http://lngnslnvsk.net/operator-precedence.drawio.svg).",-0.041666666666666664,Rust
136u340,jirp2jy,"In languages where we use `=` for functions, we typically shift it to the right, allowing you to read this Scala code as ""f(x) equals/is x times two.""",0.05952380952380952,Scala
136u340,jirp2jy,"def f(x) = x * 2  Languages which do that and also have support for pattern matching even allows to express a single function in multiple declarations, like this Haskell code:      map :: (a -> b) -> List a -> List b     map _ [] = []     map f (x : xs) = f x : map f xs  It's still limited to a single function type per function, but in the presence of union and intersection types, you can scale this to encompass overloading and multiple dispatch.",-0.1607142857142857,Haskell
136u340,jirqkgq,[D kinda does](https://dlang.org/spec/declaration.html#alias-reassignment).,0.0,D
136guzf,,"You may notice that the syntax is similar to class extension in Ruby where you ""open"" a class and insert things inside it.",0.0,Ruby
136guzf,jiox1sm,"In regards to accessing other classes' internals, there are some precedents: `friend` in C++, and `internal` in .NET for example.",-0.0625,C++
136guzf,jiqiqxk,Class A contains class B and or class C and delegates calls to them as appropriate.,0.5,C
136guzf,jipm667,"You might want to look into Common Lisp's ""method combinations"", which work because classes and (multi-)methods are decoupled.",-0.3,Lisp
136guzf,jiqslgt,"So in C++ like syntax, it would be something like:      boolean LoadBalancer::handleRequest(std::pair<Request, ACL::Principal> request) {         // Use request.second to check that request.first is allowed, then pass control to the existing implementation of LoadBalancer::handleRequest if it passes the check     }   Of course in C++ this would require subclassing LoadBalancer and overloading handleRequest to accept a tuple parameter instead of a plain Request, but I am wondering if it is really necessary to add new “possesses” syntax to express what seems to be a tuple of two or more types that you want to bundle together.",0.10551948051948051,C++
135vslx,jilozlr,"We can acknowledge that `+` can be used inappropriately, and agree to leave the matrix partial, or we can create another operator; Haskell uses `++` for string/list concatenation\* and `<>` for associative operations with identities in general.",-0.024999999999999994,Haskell
135vslx,jilozlr,\*Haskell strings are actually just lists of characters - a wonderful decision for ergonomics and a horrible one for performance.,0.0,Haskell
135vslx,jin5pc9,But I also got used to `.` in PHP and before long that felt fine too.,0.18333333333333335,PHP
135vslx,jiv051n,My impression is that most of my colleagues will know at least one of Python or Ruby.,0.1,Python
135vslx,jiv051n,My impression is that most of my colleagues will know at least one of Python or Ruby.,0.1,Ruby
135vslx,jilwmyt,"I guess it makes sense to not ""cram"" too much but in this case, I imagine a programmer that is familiar with Python, Ruby or JavaScript.",0.2875,Python
135vslx,jilwmyt,"I guess it makes sense to not ""cram"" too much but in this case, I imagine a programmer that is familiar with Python, Ruby or JavaScript.",0.2875,Ruby
135vslx,jilwmyt,"I guess it makes sense to not ""cram"" too much but in this case, I imagine a programmer that is familiar with Python, Ruby or JavaScript.",0.2875,JavaScript
135vslx,jimdc9x,"> Python, Ruby or JavaScript.",0.0,Python
135vslx,jimdc9x,"> Python, Ruby or JavaScript.",0.0,Ruby
135vslx,jimdc9x,"> Python, Ruby or JavaScript.",0.0,JavaScript
135vslx,jimdc9x,"That is a bug in JS', Ruby's and Python's designs.",0.0,Ruby
135vslx,jimdc9x,"That is a bug in JS', Ruby's and Python's designs.",0.0,Python
135vslx,jimdc9x,Even PHP of all languages got that one right (it uses `.` which it inherited from Perl; and Perl6/Raku uses `~` which it got from D).,0.2857142857142857,PHP
135vslx,jimdc9x,Even PHP of all languages got that one right (it uses `.` which it inherited from Perl; and Perl6/Raku uses `~` which it got from D).,0.2857142857142857,Perl
135vslx,jimdc9x,Even PHP of all languages got that one right (it uses `.` which it inherited from Perl; and Perl6/Raku uses `~` which it got from D).,0.2857142857142857,D
135tfrc,jim616n,"No Tensor scheduling, shape inference, auto diff, auto GPU memory management, AST manipulation, multi-host utilities etc  Just looks like Zig and Python mixed in some way without introducing any new capabilities",0.06818181818181818,Python
135tfrc,jils02e,"For context this is by Chris Latter, of LLVM and Swift fame.",0.0,Swift
135tfrc,jiljs4r,"Surely, their example `softmax` function spends 90% of its time in C++ anyway.",0.5,C++
135tfrc,jiontxj,> What’s wrong with Python?,-0.5,Python
135tfrc,jiontxj,"> Python has well known problems - most obviously, poor low-level performance and CPython implementation decisions like the GIL  are they serious?",-0.07777777777777778,Python
135tfrc,jimb4av,So they kinda did the Kotlin approach with Python but in the direction of low-level instead of higher-level abstractions.,0.0,Kotlin
135tfrc,jimb4av,So they kinda did the Kotlin approach with Python but in the direction of low-level instead of higher-level abstractions.,0.0,Python
135tfrc,jimb4av,"I also like to use type checking, contracts, and option type packages in Python but you'll either have to wrap all the other packages you consume or build an abstraction layer on top of it to provide meaningful benefits.",0.2916666666666667,Python
135tfrc,jio9in9,It's really difficult for me to understand what exactly they are doing when python libraries and Julia language exist.,-0.125,Julia
135tfrc,jin14m5,That's like asking C++ to be as fast as C even if you extensively use C++ abstractions.,0.1,C++
135tfrc,jin14m5,That's like asking C++ to be as fast as C even if you extensively use C++ abstractions.,0.1,C
135tfrc,jin14m5,Take a look [at this cool talk](https://www.youtube.com/watch?v=rHIkrotSwcc&t=1s) if you want concrete examples of how C++ is slower if you use all its features.,0.25,C++
135tfrc,jin14m5,"It might be a design goal of C++ to have zero-cost abstractions, but it's just not possible.",0.0,C++
135tfrc,jin14m5,Everyone would use this language for everything if it were like Python and as fast as C. It should say enough that Linus Torvalds hard banned C++ in the Linux kernel due to performance concerns.,-0.05416666666666667,Python
135tfrc,jin14m5,Everyone would use this language for everything if it were like Python and as fast as C. It should say enough that Linus Torvalds hard banned C++ in the Linux kernel due to performance concerns.,-0.05416666666666667,C++
135tfrc,jin14m5,"(Some Rust is being used now though)  The fact is if you need maximum performance, be prepared to write complex C/Rust/stripped down C++ and even a little assembly from time to time.",-0.21435185185185188,Rust
135tfrc,jin14m5,"(Some Rust is being used now though)  The fact is if you need maximum performance, be prepared to write complex C/Rust/stripped down C++ and even a little assembly from time to time.",-0.21435185185185188,C++
135tfrc,jiv3udy,"AI languages should move to be more high level and declarative, not ""pythonic C""",0.33,C
135tfrc,jnkb19y,"No, Chris Lattner isn't part of the Modular Team, it's just an impersonator who wants to deceive millions of Python developers!",0.25,Python
135tfrc,jimrhop,"Agreed, too early to really comment properly, but it kinda just looks like Nim to me, which is to say Pythonic C.",0.10000000000000002,C
135tfrc,jjvqe7x,"Agreed, my vote for a 1 language solution is Julia.",0.0,Julia
135tfrc,jinaaj0,D is a precedent there.,0.0,D
135tfrc,jinaaj0,"In fact D also has an (optional) RTS with a tracing GC, with features for systems programming including inline Assembly instead of MLIR interop.",0.0,D
135tfrc,jinaaj0,"In fact D also has an (optional) RTS with a tracing GC, with features for systems programming including inline Assembly instead of MLIR interop.",0.0,Assembly
135tfrc,jinaaj0,So it looks like Mojo and D live in the same space.,0.06818181818181818,D
135tfrc,jioasdf,I think this project shouldn't exist as a commercial product when something like Python already exists and there is Julia too.,0.0,Python
135tfrc,jioasdf,I think this project shouldn't exist as a commercial product when something like Python already exists and there is Julia too.,0.0,Julia
135tfrc,jioasdf,With Julia you can use the language like you do with Python but the core libraries are also implemented in Julia itself so if you know Julia you know the core too.,0.0,Julia
135tfrc,jioasdf,With Julia you can use the language like you do with Python but the core libraries are also implemented in Julia itself so if you know Julia you know the core too.,0.0,Python
135tfrc,jioasdf,For python almost every significant library ends up using C++ and I don't think it would be a pleasant experience for a Python programmer to debug template heavy C++ if things go south.,0.3027777777777778,C++
135tfrc,jioasdf,For python almost every significant library ends up using C++ and I don't think it would be a pleasant experience for a Python programmer to debug template heavy C++ if things go south.,0.3027777777777778,Python
135tfrc,jioasdf,I don't know much about Chris lattner beside him being the creator of llvm toolchain and Swift which I have never used.,0.2,Swift
135tfrc,jjvrqjr,Julia is the way,0.0,Julia
135tfrc,jio97sm,Beside the performance concern C++ is bloated with features and debugging template heavy code is difficult.,-0.35,C++
135tfrc,jio97sm,What they are trying to do is already being done by Julia to some degree which provides good enough speed with python-like syntax.,0.35,Julia
135tfrc,jin3a9x,"C has a stack of call frames, which is an abstraction that requires implicitly changing pointers and allocating memory, all of which happens at runtime.",0.0,C
135tfrc,jin3a9x,"We shouldn't use C.  Also, Assembly?",0.0,Assembly
135tfrc,jin3a9x,"When I write `mov` in Assembly, the assembler will implicitly deduce which opcodes I actually meant, and may not choose the fastest ones - abstractions!",0.0,Assembly
135tfrc,jj3n6rj,"Examples:  The oldest in mind is C++ and C, every C program is a C++ program right?",0.2857142857142857,C++
135tfrc,jj3n6rj,"Examples:  The oldest in mind is C++ and C, every C program is a C++ program right?",0.2857142857142857,C
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,Lua
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,Crystal
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,Ruby
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,Python
135tfrc,jj3n6rj,"Python across the years has also expanded into backend, frontend and databases.",0.0,Python
135tfrc,jjajl8f,"In addition to what u/lngns mentioned, there are some enterprise-oriented languages, including Thoroughbred BASIC and some OO language I can't remember the name of that I first saw mentioned on Hacker News (I think it starts with a C?)",0.125,C
135tfrc,jjvrdtq,I totally agree that Julia is already way ahead of Mojo and Python at truly solving by the 2 language problem.,0.0,Julia
135tfrc,jjvrdtq,I totally agree that Julia is already way ahead of Mojo and Python at truly solving by the 2 language problem.,0.0,Python
135tfrc,jinldw1,"> C has a stack of call frames, which is an abstraction that requires implicitly changing pointers and allocating memory, all of which happens at runtime.",0.0,C
135tfrc,jinldw1,">  > We shouldn't use C.  This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries.",0.21250000000000002,C++
135tfrc,jinldw1,">  > We shouldn't use C.  This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries.",0.21250000000000002,C
135tfrc,jinldw1,Or you could look at [this talk](https://www.youtube.com/watch?v=rX0ItVEVjHc) where yet another very high up programmer basically admits they have to avoid most C++ abstractions due to performance needs.,0.19433333333333333,C++
135tfrc,jinldw1,"> Also, Assembly?",0.0,Assembly
135tfrc,jinldw1,"When I write mov in Assembly, the assembler will implicitly deduce which opcodes I actually meant, and may not choose the fastest ones - abstractions!",0.0,Assembly
135tfrc,jj7jzt6,Python itself is not performant and also not a good choice for glue code.,-0.35,Python
135tfrc,jip2uqp,"> This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries  Absolutely not.",0.15000000000000002,C++
135tfrc,jip2uqp,"> This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries  Absolutely not.",0.15000000000000002,C
135tfrc,jip2uqp,"C, ""C++ that is almost the same as C"" and Rust all are, at the same time, too abstract and not abstract enough, to express optimisations I need.",0.0,C
135tfrc,jip2uqp,"C, ""C++ that is almost the same as C"" and Rust all are, at the same time, too abstract and not abstract enough, to express optimisations I need.",0.0,C++
135tfrc,jip2uqp,"C, ""C++ that is almost the same as C"" and Rust all are, at the same time, too abstract and not abstract enough, to express optimisations I need.",0.0,Rust
135tfrc,jip2uqp,"But no, C and its ""functions"" have no idea how to do that, and in fact forbid it, instead hoping that an implementation will realise the memory allocation and ABIs are just right.",0.2857142857142857,C
135tfrc,jip2uqp,"Also, whenever I need asynchronous code (which is, all the time), C is a lost cause because of assumptions with abstract ambient states which it never tells you about and just assumes you as a programmer understand.",0.0,C
135tfrc,jip2uqp,"No I am pointing out the fact that saying ""X and its abstractions are objectively worse than C on every performance-related axes, which is the pinnacle of programming discipline"" while in theory even an Assembler shares the same problems, and while in practice C is defined in ways that make some ""performant code"" impossible to express, is incorrect.",-0.35555555555555557,C
135tfrc,jj8zi04,"One criticism I encountered of Julia is their take on handling third party packages, that you can take packages that were not designed to work together, but still use them together, and everything somehow works.",0.0,Julia
135tfrc,jip9fzf,"Everyone getting paid 500+k/yr to program high performance code uses Rust, C, or a stripped down version of C++ (and I'm honestly not sure if Rust programmers must use a subset as I'm not familiar with that language like I am with C/C++).",-0.1082638888888889,Rust
135tfrc,jip9fzf,"Everyone getting paid 500+k/yr to program high performance code uses Rust, C, or a stripped down version of C++ (and I'm honestly not sure if Rust programmers must use a subset as I'm not familiar with that language like I am with C/C++).",-0.1082638888888889,C
135tfrc,jip9fzf,"Everyone getting paid 500+k/yr to program high performance code uses Rust, C, or a stripped down version of C++ (and I'm honestly not sure if Rust programmers must use a subset as I'm not familiar with that language like I am with C/C++).",-0.1082638888888889,C++
135tfrc,jip9fzf,"Linux, video game development tuned to PS5/xbox hardware) write straight up C or highly restricted C++ code (e.g.",-0.013333333333333336,C
135tfrc,jip9fzf,"Linux, video game development tuned to PS5/xbox hardware) write straight up C or highly restricted C++ code (e.g.",-0.013333333333333336,C++
135tfrc,jj948af,"Reading Julia, yes you can pretty easily mix anything you want, and 99% of the time everything works.",0.3416666666666667,Julia
135tfrc,jj948af,Python really helped push the scientific community and now it is too big to be left behind.,-0.05,Python
135tfrc,jipuf30,"If you did read what I wrote you'd have realised I'm not in disagreement with those lectures and am pointing out issues with your own claims instead: that C++ has issues doesn't mean C doesn't, and doesn't mean that different languages and toolchains with different paradigms face the same challenges (and also that you're the only person to mention C++ at all, and that the first talk literally gives solutions that are trivial outside the constraints of the C++ standard).",0.0225,C++
135tfrc,jipuf30,"If you did read what I wrote you'd have realised I'm not in disagreement with those lectures and am pointing out issues with your own claims instead: that C++ has issues doesn't mean C doesn't, and doesn't mean that different languages and toolchains with different paradigms face the same challenges (and also that you're the only person to mention C++ at all, and that the first talk literally gives solutions that are trivial outside the constraints of the C++ standard).",0.0225,C
135tfrc,jj965mr,">compiler might infer some type differently  ELI5 cause I'm a scientific programmer and not a professional one, do all JIT compilers have fancy algorithms to infer types or is it just a Julia thing?",-0.025,Julia
135tfrc,jj965mr,I assume AOT compilers (e.g Fortran) do not because types have to be declared?,0.0,Fortran
135tfrc,jiqc4ds,"The salient point this entire time is a language with the mission statement of being as expressive as Python but as fast as C, the claim of the language being discussed, is a pipedream since having nifty abstractions is at odds with being as fast as possible.",0.24,Python
135tfrc,jiqc4ds,"The salient point this entire time is a language with the mission statement of being as expressive as Python but as fast as C, the claim of the language being discussed, is a pipedream since having nifty abstractions is at odds with being as fast as possible.",0.24,C
135tfrc,jj9cifr,"Some languages enforce a strong static type (like Haskell) to make the work of the compiler easier, some are weaker around static enforcement (like C).",0.4777777777777778,Haskell
135tfrc,jj9cifr,"Some languages enforce a strong static type (like Haskell) to make the work of the compiler easier, some are weaker around static enforcement (like C).",0.4777777777777778,C
135tfrc,jj9cifr,"You can write Julia pretty loose, don't declare any types just create a function and let the compiler infer what it types it needs.",0.08653846153846154,Julia
135tfrc,jj9cifr,"function foo(x)          a=x+2         return(a)     end  In Julia with `code_warntype` macro, you can see how the compiler infers types.",0.0,Julia
135tfrc,jj9cifr,"In Julia you have this freedom to write strictly or loose, it is awesome for prototyping because you can just develop fast, but if you are not careful you will introduce some nasty correctness errors into your code.",0.034615384615384624,Julia
135tfrc,jj9g261,Here is the last one:  I'm sure you have come across the criticism of Julia about silent errors and you mention them here.,0.16666666666666666,Julia
135tfrc,jjayzf5,"I'm not the best person to answer this question since only I have extensively used Julia, Imma just say what I gathered.",0.3333333333333333,Julia
135tfrc,jjayzf5,Rust is one of those languages that makes your life hard by borrow-checker that tries to prevent most possible errors.,0.02708333333333332,Rust
135kjrl,,"Recently, I've been working on an exciting project where I'm trying to create an interpreter from scratch in C++.",0.15,C++
135kjrl,jisouiz,Vaguely resembles Tcl.,-0.5,Tcl
135kjrl,jitq088,>Vaguely resembles Tcl.,0.0,Tcl
135eooj,jijwhxv,Research related Lexer in Pascal as a graduate thesis.,0.0,Pascal
135eooj,jijwhxv,"One, to prove Modern Procedural Pascal could be used for modern P.L.",0.2,Pascal
135eooj,jijwhxv,"Two, to have modern versions of Compiler related tools, for Pascal, like GNU Flex and GNU Bison, since at that time, 25 years ago, Compiler / Interpreter/ P.L.",0.1,Pascal
135eooj,jijwhxv,tools were too focused / dominated by C / C++ .,0.0,C
135eooj,jijwhxv,tools were too focused / dominated by C / C++ .,0.0,C++
135eooj,jiya3a1,"Go to https://csrankings.org, filter research area by PL only, location by Europe, and pick publications in the last 5 years.",0.0,Go
135eooj,jiya3a1,Go to their webpages and see if the topics of their publications appeal to you.,0.0,Go
135cbu7,,"As an example, this is how I would extend the built-in String type:      extend String {        print: () => {             print(self)            ret self         },        at: (index: Number) => self[index]     }          ""hello"".at(2).print() // l  Similarly, this also works on custom types:      type Vector2 {         x: Number,         y: Number,     }          extend Vector2 {         list: () => [self.x, self.y]     }          const vec = Vector2 { x: 10, y: 20 }     const notVec = { x: 10, y: 20 }          vec.list() // [10, 20]     notVec.list() // Error  The reason I think this is one of the most useful features I've implemented, is that alongside C interop, it becomes trivial to extend the language outside of the actual interpreter code.",-0.18125,C
135cbu7,,"And because the string module was created by interoperating with C, I was able to provide type extensions that could not be achieved through vtx source code alone.",0.5,C
135cbu7,jilld1s,Ruby is famous for taking this too far.,0.3,Ruby
135cbu7,jilld1s,Rust's `impl` seems to work much better.,0.5,Rust
135cbu7,jil9m9g,"I've seen this in many languages under different names; Scala, for example, calls these ""implicits"".",0.25,Scala
135cbu7,jingfaz,Ruby was my first favorite language - leave the poor thing alone.,0.11666666666666665,Ruby
135cbu7,jio173f,Never really dealt with Ruby,-0.1,Ruby
135cbu7,jimblth,Did you mean Scala 3's `extension`s?,-0.3125,Scala
135cbu7,jiobri9,"There's this popular web framework called Rails which is famous for, among other things, extending builtin classes using this feature of the Ruby language.",0.325,Ruby
135cbu7,jiobri9,"Of course, Rails is not the only Ruby project that does this, but it used to be the starting point for Ruby developers for years, and there are anecdotes of them growing so accustomed to the extended library of methods that they struggled writing vanilla Ruby code.",0.0,Ruby
135cbu7,jimg9wa,"I remember one way in Scala 2, and a different way introduced later.",0.0,Scala
135cbu7,jip644r,Have you ever seen D's universal function call syntax?,0.0,D
1355crn,jiiuhui,"I did a bunch of other languages (only the [BASIC](https://github.com/tim-hardcastle/Charm/blob/main/examples/basic.ch) and the [Forth](https://github.com/tim-hardcastle/Charm/blob/main/examples/forth.ch) are up to date with the current version of the language I think), and I did [a tiny adventure game](https://github.com/tim-hardcastle/Charm/blob/main/examples/adv.ch) (and used it as the basis for [a tutorial](https://github.com/tim-hardcastle/Charm/blob/main/docs/writing-an-adventure-game-in-charm.md)).",-0.03125,Forth
1355crn,jiiuhui,"(You may say these are only tiny projects, which is true, but OTOH they'd be ten times longer in Java.)",0.0875,Java
1355crn,jilk9nc,"The compiler shown above translates a programming language, like a variant of Lisp, to these instruction sets for simulators of quantum computers.",0.0,Lisp
1352yh6,jihmrk8,Both Haskell and OCaml are perfectly suitable for compiler development.,0.55,Haskell
1352yh6,jihmrk8,"(Take Appel's book as an example, which uses Standard ML—or Java or C.) OCaml let's you go freewheeling with mutation and IO, like most other common languages.",0.018750000000000003,Java
1352yh6,jihmrk8,"Haskell will, more often than not, require one to either (1) program unidiomatically, or (2) re-think existing algorithms in a way compatible with Haskell's paradigm.",0.5,Haskell
1352yh6,jihmrk8,"Things like Big-O complexities frequently change with idiomatic Haskell, usually by a logarithmic factor.",-0.075,Haskell
1352yh6,jihmrk8,"If the goal is to learn Haskell's model, along with having a forcing function for you to think deeply about compiler algorithms (because it'll literally be impossible to handwave otherwise), choose Haskell.",-0.3333333333333333,Haskell
1352yh6,jik5ia5,I wrote my compiler in Haskell.,0.0,Haskell
1352yh6,jik5ia5,Haskell is rich enough to allow local state when that is useful.,0.16875,Haskell
1352yh6,jik5ia5,Although overall I would say that laziness is a minor advantage - Haskell's main advantage for compiler development is just that it's a nice language.,0.17916666666666667,Haskell
1352yh6,jik5ia5,"When choosing between Haskell and OCaml, pick the one you are more familiar with.",0.4375,Haskell
1352yh6,jik5ia5,"If you are equally familiar with both, I would pick Haskell because I find it more pleasant than OCaml.",0.5361111111111111,Haskell
1352yh6,jii6dki,Both Haskell and OCaml are highly suitable for langdev.,0.55,Haskell
1352yh6,jii6dki,"Although I'm preferential towards OCaml because I know it better, I do think Haskell has the upper hand in terms of its design, does have some deeper systems to learn and enrich yourself with, and has a bigger community.",0.16666666666666666,Haskell
1352yh6,jijw9cv,I personally make use if the FParsec parsing library as well as a C# graph theory library.,0.0,C
1352yh6,jihoo2h,I have heard predicting time and space complexity is hard in Haskell because of its lazyness nature.,-0.2916666666666667,Haskell
1352yh6,jihp8h3,"Even something as simple as lexing can be written exceedingly simply in Haskell, but secretly hide a huge time or memory cost because you recursed in the wrong order but never took that branch so it never got computed.",-0.09999999999999999,Haskell
1352yh6,jihv1sg,Is the book purely functional data structures relevant here as to reasoning about time and space complexity in Haskell?,0.30714285714285716,Haskell
1350dfw,jiid1mb,"the D compiler apparently never freed any memory at all, and that proved eventually to be a limitation.",-0.025,D
1350dfw,jiid1mb,"C++ and Zig compilers also include constexpr and comptime interpreters, which makes ownership more complicated as well.",0.0,C++
1350dfw,jik3s23,"slotmap in Rust), but it's still extra work.",0.0,Rust
1350dfw,jihtsc4,It also reminds me of how the Forth language is described.,0.0,Forth
1350dfw,jijgaf6,"I think the overall idea is known in Rust cycles as ""Avoid linked lists, use Vec instead.""",0.0,Rust
1350dfw,jijioqj,"Do you use this in Sophie or do you have another example (implemented in Python, Lua, C, whatever?)",0.0,Python
1350dfw,jijioqj,"Do you use this in Sophie or do you have another example (implemented in Python, Lua, C, whatever?)",0.0,Lua
1350dfw,jijioqj,"Do you use this in Sophie or do you have another example (implemented in Python, Lua, C, whatever?)",0.0,C
1350dfw,jijglgt,The Rust compiler totally uses this kind of pattern at every single layer of IR.,0.1761904761904762,Rust
1350dfw,jio510b,"I suspect arrays and indices are used to make it applicable in garbage-collected languages (but in this case it's strange to use Rust for the demo), but when you have bump-allocated arenas, arrays and indices are just adding extra indirections",-0.025,Rust
134z5vv,,Its syntax and some key features were inspired by Go.,0.0,Go
134z5vv,,"However, Umka doesn't rely on the Go ecosystem and only needs the C standard library to run.",0.0,Go
134z5vv,,"However, Umka doesn't rely on the Go ecosystem and only needs the C standard library to run.",0.0,C
134z5vv,,The first question I always have to answer when presenting Umka is why we need yet another language if we already have Lua.,0.25,Lua
134z5vv,,"The main difference is Umka's static typing that brings a number of advantages:  * Type mismatch error detection at compile time * Clearer program design due to explicitly specified types for function arguments and results * Native support for C data types, such as arrays and structures (in contrast to Lua ""tables"" and ""userdata"")  Umka is now used for scripting in [Tophat](https://tophat2d.dev/), a simple modular 2D game framework by Marek Maškarinec.",0.0236111111111111,C
134z5vv,,"The main difference is Umka's static typing that brings a number of advantages:  * Type mismatch error detection at compile time * Clearer program design due to explicitly specified types for function arguments and results * Native support for C data types, such as arrays and structures (in contrast to Lua ""tables"" and ""userdata"")  Umka is now used for scripting in [Tophat](https://tophat2d.dev/), a simple modular 2D game framework by Marek Maškarinec.",0.0236111111111111,Lua
134z5vv,jjdhi0o,"It's like ""MAT"" in ""MATLAB"".",0.0,MATLAB
134vg7h,jihesz4,I'm reading the material also :D thanks for it I'm just taking a bit to understand everything.,0.6,D
134vg7h,jiiucnm,"In our compiler, we call that a `TypeConstant` (and 21 subclasses, because it's Java and there is no mixin / typeclass support), but I'm sure there are 100 different names for the concept.",0.25,Java
134fyou,,"* Random (basic random number generation) * Sys (sort of like Python's sys module, for interacting with the runtime) * SDL (for interfacing with the SDL C library.",-0.3333333333333333,Python
134fyou,,"* Random (basic random number generation) * Sys (sort of like Python's sys module, for interacting with the runtime) * SDL (for interfacing with the SDL C library.",-0.3333333333333333,C
134fyou,jiete8o,"This is more personal preference, but including some way to load a dynamic (C) library (.dll, .so, .dylib) and call functions from it can be nice.",0.275,C
134fyou,jif9vww,"Check C ""stdmem.h""  * Basic String Manipulation  Check C ""string.h""  * Filesystem Operations  Create a folder, delete a folder, querying the files or folders in a path.",0.0,C
134fyou,jif9vww,"Check C ""stdio.h""  * Basic Text Input / Output access  Create, open, read, write, close a text file.",0.0,C
134fyou,jif9vww,"Defines standard Text Files like C ""stdin, stdout, stderr"" or C++ ""cin, cout, cerr"".",0.0,C
134fyou,jif9vww,"Defines standard Text Files like C ""stdin, stdout, stderr"" or C++ ""cin, cout, cerr"".",0.0,C++
134fyou,jif9vww,"Warning: Do not add text conversion functions like C ""printf"" here, the console should be only text based, like C# or Java.",0.0,C
134fyou,jif9vww,"Warning: Do not add text conversion functions like C ""printf"" here, the console should be only text based, like C# or Java.",0.0,Java
134fyou,jif9vww,"* Basic Operations for Numeric Types: - Add, Substract, Multiply - Cos, Sin functions  * Basic Operations for Date and Time types  * Type Conversion Operations: - Integer to Float and viceversa - All text to other types conversion, C ""vsprintf,"" or C++ ""fmt"" Library goes here.",-0.03125,C
134fyou,jif9vww,"* Basic Operations for Numeric Types: - Add, Substract, Multiply - Cos, Sin functions  * Basic Operations for Date and Time types  * Type Conversion Operations: - Integer to Float and viceversa - All text to other types conversion, C ""vsprintf,"" or C++ ""fmt"" Library goes here.",-0.03125,C++
134fyou,jiim1ll,"Instead give me `c_rand`, which I know is C's `rand`, `chacha20_rand`, `openssl_rand`, etc...    As for actual features:  - Containers: lists, trees, maps and sets primarily.",0.2,C
134fyou,jiim1ll,D does that very good.,0.9099999999999999,D
134fyou,jil5ctz,I actually put a bunch of thought into this and did a scrape of around 97 million imports in github Python repositories to survey what were the most commonly used modules.,0.06666666666666667,Python
134fyou,jil5ctz,"Granted, this is in Python, so it may be less applicable in your target domain.",-0.16666666666666666,Python
134fyou,jil5ctz,"And for the rest, I plan to have modules for: files and filesystem manipulations (#21, #22), OS and shell commands (#1, #22, #18), time/dates (#4, #13), HTTP requests (not actually a top Python import), base64 (#17), CSV (#14), pattern matching (#3, but I probably won't use regex, probably something more simple), and probably JSON.",0.08333333333333333,Python
134fyou,jil5ctz,"My language has very easy interoperability with C, so it's pretty fast to make lightweight wrappers to C libraries like libcurl or C standard library functionality.",0.25333333333333335,C
134fyou,jil5ctz,"The modules I chose not to mess with are things like numpy, torch, codecs, and pandas: modules with large and complicated interfaces to highly fine tuned Python libraries.",-0.011011904761904764,Python
134fyou,jizb66k,"I think Rust can be a good example - it's not completely devoid of problems, but its collections are generally very nice to use and extend.",0.51,Rust
134fyou,jjbiixz,"What no one has mention yet, is some form of unit testing - in Python, you have by default installed Unittest, Java have Junit, etc.",0.0,Python
134fyou,jjbiixz,"What no one has mention yet, is some form of unit testing - in Python, you have by default installed Unittest, Java have Junit, etc.",0.0,Java
134fyou,jieuewr,"My stdlib does consist of purely C libs that are dynamically linked, there's a lot of opportunity to expand on them.",0.21428571428571427,C
134fyou,jieuewr,Vtx supports C interop out of the box and I'm using that heavily for all of these modules.,-0.2,C
134fyou,jig2i3l,I can probably leverage a pre-existing C lib that handles that.,0.0,C
134ftny,jieqaum,"You could take a look at the GitHub actions on my [Forscape](https://github.com/JohnDTill/Forscape) repo in the .github folder, although it's probably not the most idiomatic runner scripting, but it is a C++ project like yours.",0.5,C++
134ftny,jig1y50,"I know what it offers (reactive programming, C interop, some meta programming capabilities etc.",0.1,C
134ftny,jif10lz,There are a lot of C++ specific optimisations I can do to the source code.,0.0,C++
134b775,jif152l,I highly recommend doing a project with Elm at least once in life.,-0.06999999999999999,Elm
134b775,jif152l,"In Elm, everything is 100% immutable.",0.0,Elm
134b775,jif152l,"In Elm, you usually throw everything into a single large file until there's a good reason to move some code into a separate file.",0.14821428571428572,Elm
134b775,jien4mm,"`strtok()` in C has this very issue, and it’s why `strtok_r()` was added.",0.2,C
134b775,jifrk6q,"In Haskell, I can read `=` the same way I read it in math, which is IME a foundation for equational reasoning that travels *very* far through the experience of working in the language.",0.065,Haskell
134b775,jig8shx,"A language like C requires passing `bar` by pointer to modify it, and a language like Rust requires `&mut bar`.",0.0,C
134b775,jig8shx,"A language like C requires passing `bar` by pointer to modify it, and a language like Rust requires `&mut bar`.",0.0,Rust
134b775,jifu6et,"A more specific solution for ""never sharing mutable state"" would be the borrowing and ownership model of Rust.",0.25,Rust
134b775,jigx353,"This is the main thing Rust has proven: Even the best of the best developer totally do bad things with data, even in ""simple"" programs!",0.29333333333333345,Rust
134b775,jigx353,"----  A good way to understand this point: Try Rust to do some ""simple stuff"".",0.35,Rust
134b775,jigx353,"You will get amazed at how many times the borrow checker will stop you, and you will think ""Rust is wrong, why not allow me to do this?"".",0.0,Rust
134b775,jihkrs0,"This case doesn't happen with Java ""containers"" like say ArrayList because the backing storage is hidden from the user.",-0.16666666666666666,Java
134b775,jj6vxd8,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,Rust
134b775,jj6vxd8,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,C
134b775,jiezzdx,I'll just whip out JavaScript.,0.0,JavaScript
134b775,jiflhon,"I'm glad that people are putting in serious effort so we get more options than original Java ""everything is a mutable reference""",0.2604166666666667,Java
134b775,jiia4a9,"You can also have mutable values whose size *is* known at compile time, but whose contents change (like a struct in C).",0.0,C
134b775,jiii0ym,"> A good way to understand this point: Try Rust to do some ""simple stuff"".",0.35,Rust
134b775,jiii0ym,"You will get amazed at how many times the borrow checker will stop you, and you will think ""Rust is wrong, why not allow me to do this?"".",0.0,Rust
134b775,jiii0ym,Rust's borrow checker is overly restrictive and there are many valid programs that Rust won't let you compile.,0.5,Rust
134b775,jiii0ym,"As a contrived example, these two versions of code do exactly the same thing, but Rust won't compile the first version:      // Will not compile:     let mut players = vec!",0.015625,Rust
134b775,jiii0ym,"}"", players);     let mut first = players.get_mut(0).unwrap();     first.score += 1;  The first version is not unsafe or buggy, its only crime is that it violates Rust's religious doctrines.",0.125,Rust
134b775,jiii0ym,"This is a toy example, but I think it's hard to provide any justification for why Rust is correct to call the first program invalid and the second one valid.",-0.013888888888888895,Rust
134b775,jiew19o,That's also why Haskell can have in-place mutable arrays with a pure API that looks as if it were immutable.,0.21428571428571427,Haskell
134b775,jigt3ir,This is exactly how linked lists work in Lisp.,0.25,Lisp
134b775,jj85yfe,"In Rust, this would be done with `let y = x.clone()`, the design philosophy of Rust is to make performance costs explicit.",0.0,Rust
134b775,jj85yfe,"Then that's a difference, references in Rust can be to the stack or heap, you don't need to have the performance hit of heap allocation to use a reference.",0.0,Rust
134b775,jj85yfe,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,Rust
134b775,jj85yfe,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,C
134b775,jj85yfe,Yeah I think you missed the main conclusion if that was your takeaway - Rust **disallows** this at compile time whereas C does not.,0.16666666666666666,Rust
134b775,jj85yfe,Yeah I think you missed the main conclusion if that was your takeaway - Rust **disallows** this at compile time whereas C does not.,0.16666666666666666,C
134b775,jj85yfe,Here's that example in a [Rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3936d36f15180365413d719dac9f370c) to try it out.,0.0,Rust
134b775,jj85yfe,The article may be meant for C programmers who don't think that mutable aliasing is a problem.,0.0,C
134b775,jj85yfe,"The article describes why it's also a Bad Idea™ in a single-threaded environment, which is the justification for why Rust doesn't allow it.",-0.6999999999999998,Rust
134b775,jifhk6u,Python is so good for this sort of stuff.,0.7,Python
134b775,jifhk6u,I'd say it's easy to write correct code up to about a thousand lines of Python.,0.43333333333333335,Python
134b775,jiiphxm,"Mine is, and having dogfooded it a lot I think it does have an edge over things like Python or JS in having fewer footguns.",0.0,Python
134b775,jiey760,I just wish D would be like C# where I have to say `str.decode(ref i)` or just use a pointer.,0.0,D
134b775,jiey760,I just wish D would be like C# where I have to say `str.decode(ref i)` or just use a pointer.,0.0,C
134b775,jifdfkc,"I know they have benchmarks for certain workloads where it has comparable performance, but this is just marketing talk - it's presented as if every program is going to beat C in performance.",0.21428571428571427,C
134b775,jifdfkc,"in Swift and Val, which has very similar strong guarantees by focusing on the sharing of references instead of their mutability.",0.21666666666666665,Swift
134b775,jiin0f4,> it's hard to provide any justification for why Rust is correct to call the first program invalid and the second one valid.,-0.013888888888888895,Rust
134b775,jiin0f4,"```  ---  Now, I know that Rust is more restrictive than say, oCalm or Zig, so I can see why a language that is more lenient is fine in some contexts.",0.4791666666666667,Rust
134b775,jiin0f4,"After you pay some attention to Rust, is easier to see how to apply the lessons and still be more lenient, but is pretty important to see why reducing the chance of mutability *helps* for your case of ""I wanna code more freely"".",0.425,Rust
134b775,jiexepw,"I think a lot of references are implicit, actually Go is very explicit about it by separating the concept of class and struct allowing to attach methods either with pointer or value receivers.",0.2,Go
134b775,jig4o5i,"Not sure if your comment is implying this, but Haskell doesnt need linear types to have in-place mutable arrays with a pure API, right?",0.08333333333333333,Haskell
134b775,jificju,"For more than 200 lines I usually just switch to Scala, which is just as flexible as python but with a good type system and much easier integration of external libraries.",0.22999999999999998,Scala
134b775,jificju,"The only downside is Scala's compile times, really.",0.1,Scala
134b775,jig1xee,Unsafe Rust still has to follow the same aliasing rules as safe Rust.,0.25,Rust
134b775,jifjpni,"I am so much more proficient at Python than anything else that I like to use it for almost everything, except when I need C. I want to like Scala, but the compile time really turn me down 😅",0.18148148148148147,Python
134b775,jifjpni,"I am so much more proficient at Python than anything else that I like to use it for almost everything, except when I need C. I want to like Scala, but the compile time really turn me down 😅",0.18148148148148147,Scala
134b775,jifk9k5,It's the flexibility of JavaScript.,0.0,JavaScript
134b775,jifk9k5,I know a few people who still use Java for everything.,-0.2,Java
134b775,jigfbo5,You can generally do that in Python too; just recently in fact I wanted to return a function with metadata so I just went ahead and attached a bunch of custom attributes to it and Python didn't complain.,0.02500000000000001,Python
134b775,jigfbo5,You can ask whether an object has a specifically named field in Python as well.,0.0,Python
134b775,jigfbo5,"I'm curious about the ""find *all* [emphasis mine] objects"" part, though; how do you enumerate overall objects in the system in JavaScript?",-0.05,JavaScript
13474to,jidw0a8,"Working on [Vortex](https://github.com/dibsonthis/Vortex), a reactive programming language that implements C interop.",0.0,C
13474to,jie4efn,"Right now it has a few more features than C (modules, methods on types, limited constant evaluation), but it still isn't at the point that I would call usable.",0.10285714285714284,C
13474to,jl21qzs,"Which means we have to memory management, but we do not want to export Rust like explicit management.",0.0,Rust
13474to,jie71mo,I hope to make the language C like with features like lists and garbage collection.,0.0,C
13474to,jiex4fh,I thought maybe C and I could write a JIT compiler but lack of algebraic datatypes and pattern matching would make that painful.,-0.7,C
13474to,jiex4fh,"Oh, and I already tried writing my language in my (high-level) language and it didn't work because it is so slow (~1,000x slower than C!",-0.37500000000000006,C
13474to,jifwqdg,This back end will use new Java virtual threads feature to support the Ecstasy fiber model.,0.06818181818181818,Java
13474to,jihr94r,I also implemented `break` at the same time for completeness (I already implemented both of them in the previous Java interpreter).,-0.08333333333333333,Java
13474to,jjq2bsv,"Next up is either making templates act as structs, their arguments accessible as members, or an atleast partial ""binding"" for the Lua language and some primitive to extract information from syntax elements  Edit: I've just realized it would be very easy to create a compiler for template definitions so that will be my next task",0.16766666666666669,Lua
13474to,jk55mmu,"For now it's implemented in Python, but I plan to reimplement it in my programming language once it is readier.",0.0,Python
13474to,jidl2b1,I implemented Forth in Charm again as another dogfooding exercise and to see how DX has improved since last time.,0.0,Forth
13474to,jidl2b1,"(At least on the outside, it's still written in Go on the inside ... for now.",-0.15,Go
13474to,jihogmg,"Instead of representing all objects as a Rust enum, we now have defined a memory layout (with a header word indicating of which type a value is, a reference count, and actual layouts for our types).",0.0,Rust
13474to,jine329,Writing a unit test framework for my C codebase.,0.0,C
13474to,jkgf1hv,"Also you reminded me of my first PHP CMS with its style rules written in JSON that looked like this:      [         ""header.html"",         {             ""ifprefix_forums"": [""forums_nav.html""],             ""ifprefix_me"": [""profile.html""]         },         ""footer.html""     ]  I loved that json when I was 14 lol.",-0.08333333333333333,PHP
13474to,jiexuzt,"I currently write a JIT in C++, 17 and 20 added a lot of stuff u'd see more in functional langs.",0.25,C++
13474to,jin34t2,(or to C?),0.0,C
13474to,jieyb0p,"Hmm, I haven't written any C++ in a very long time.",-0.065,C++
13474to,jieyutt,This is actually my first C++ Project 💀.,0.25,C++
13474to,jieyutt,"Transition Was pretty smooth though, I wrote a lot of rust code in the past 2 years, and C++ really felt like 95% rust if you use the ""modern c++"".",0.16,C++
13474to,jif2wie,I thought about choosing Rust but I really don't like the idea of the borrow checker.,0.2,Rust
13474to,jijsszw,"yeah, I felt so too, having written some C++ now I really don't have problems not having it, the reverse was true though.",0.275,C++
13474to,jijsszw,And static analyzers exist for C++ too.,0.5,C++
13474to,jijsszw,C++'s addition of RAII and smart pointers changed a lot for the language,0.21428571428571427,C++
1340z3r,,(Python does this.,0.0,Python
1340z3r,,"Java *appears* to, but it's complicated.)",-0.5,Java
1340z3r,,Elm's HTML module) often benefit from globular import.,0.0,Elm
1340z3r,,Elm's HTML module) often benefit from globular import.,0.0,HTML
1340z3r,,"* JavaScript has an ""import map"" mechanism that looks overcaffeinated until you remember how the leftpad fiasco happened.",0.0,JavaScript
1340z3r,,"* Speaking of Java, what's up with Java's new module system?",0.13636363636363635,Java
1340z3r,,* Python has a module for that.,0.0,Python
1340z3r,,* Java gets this completely wrong.,-0.5,Java
1340z3r,,"Or rather, Java does not bother to try.",0.0,Java
1340z3r,,"* Mistake not the platform ABI for C, nor expect it to cater to anything more sophisticated than C. In particular, Windows apparently has multiple calling conventions to trip over.",0.24333333333333335,C
1340z3r,,"* Go uses GitHub, which is odd because Google now depends on Microsoft.",-0.16666666666666666,Go
1340z3r,,* Python pretty much copied what Perl did.,0.225,Python
1340z3r,,* Python pretty much copied what Perl did.,0.225,Perl
1340z3r,,* Java: Gradle?,0.0,Java
1340z3r,,* Don't even get me started on JavaScript.,0.0,JavaScript
1340z3r,jics1xu,This is the case in Python for example where attribute access of an object and using a method from a different namespace both are done with the dot operator.,0.0,Python
1340z3r,jics1xu,In Rust or C++ you use ‘::’ for the latter,0.0,Rust
1340z3r,jics1xu,In Rust or C++ you use ‘::’ for the latter,0.0,C++
1340z3r,jicw7dg,Like other highly interactive languages (Common Lisp and Smalltalk) the runtime can save much of its state to an image file containing an abstract representation of its data.,-0.01625,Lisp
1340z3r,jid58y6,"> Go uses GitHub, which is odd because Google now depends on Microsoft.",-0.16666666666666666,Go
1340z3r,jid58y6,Go is not dependent on GitHub.,0.0,Go
1340z3r,jid58y6,"To add even more to that: even when a language has some standard mechanisms, and its ecosystem has standard tools, there's always gonna be people who will branch off in their own ecosystems and use Make for everything, and there's always gonna be a Perl script to check if some GNU library is present on the system.",0.22000000000000003,Perl
1340z3r,jicu03i,"But in Python, there is no such thing as the static namespace: There is only runtime, and modules are objects like any other.",0.09375,Python
1340z3r,jicu03i,"I'm not sure what Java's excuse is, but probably relates to its reverse-DNS system of packaging.",-0.15,Java
1340z3r,jicudaq,The only reason that C++ does that is because you need to be able to call a base class method on a derived object.,-0.10000000000000002,C++
1340z3r,jicudaq,Python avoids this by allowing you to call unbound methods directly (as static members of the base class) and passing `this` in explicitly.,-0.15000000000000002,Python
1340z3r,jicudaq,"That said, Python's descriptor protocol working at runtime is definitely suboptimal performance-wise, even with interpreter hacks.",0.0,Python
1340z3r,jid20y9,"= flip ($)          List a = interface         (::): a -> List a -> List a         Nil: List a         end  I know some languages like Haskell manage to get away with it by overloading the `.` operator, but I don't like it because `x.f` should imply both `x` and `f` are symbols in scope, but suddenly if `x` is a module then that's false and only one or neither is in scope.",0.02499999999999998,Haskell
1340z3r,jicxi56,"Foreign functions are simple to accommodate; mepros has equivalent types to those of C, and header files could be parsed at compile-time if such was considered wise.",0.14375,C
1340z3r,jihe607,"I like dependent typing, but this is very much different; it's more similar to Zig or Python.",0.16666666666666666,Python
133w4xu,jic3ysk,C:,0.0,C
133w4xu,jievj1y,:D,1.0,D
133as9f,jibi3cw,"Programming languages usually use types instead of sets, since types are much more well behaved and type inference or even just type checking is much more tractable with those, but some type systems, notably that of TypeScript, do have union types!",0.34375,TypeScript
133as9f,jiaxm8x,"In a language supporting both, like TypeScript, it may look like `(0 | 1 | Bool) -> Int`.",0.25,TypeScript
1331clq,,"Some compilers at the C level would require `bignum.dll` to be specified, and some can't even use DLLs directly, you need to use `.a` or `.lib` files as well.",0.1,C
1331clq,,"Adding `.h` files in there would be pointless, as no C compilers would know to look inside such a DLL (unless perhaps a stub program can extract such info).",-0.08333333333333333,C
1331clq,,"What I would have liked is for interface information like this to be available in universal, language-neutral format added to such DLLs, which doesn't mean using C syntax with all its crazy stuff.",0.014583333333333337,C
1331clq,,"The nearest I've seen are actually C++ libraries where if you have a tool to enumerate the function names inside a DLL, some will have function signatures coded into those names.",0.0,C++
1331clq,ji7fyfm,"I don't know what language you use, but I've found that Rust's `object` crate works well for this.",0.0,Rust
1331clq,ji7vqgg,Writing bindings to enable me to use arbitrary libraries which come in DLLs and with APIs described as C header files are a different and *much* bigger problem.,-0.03333333333333333,C
1331clq,ji7vqgg,"Apart from a program which tries to translate C to my syntax, but that only does part of the job.",-0.05,C
1331clq,ji7vqgg,This is why C header files are a poor way to describe a cross-language API.,-0.4,C
132ximy,ji6ws86,"Most implementations of Lox turn out to be significantly slower than the one in C, but this one comes really close.",0.35833333333333334,C
132ximy,jjdk0x7,As a beginner would it be just fine to follow the Web Assembly tutorial?,0.4166666666666667,Assembly
132ximy,ji7woiu,* [Writing an Interpreter in Go](https://interpreterbook.com/) / [Writing a Compiler in Go](https://compilerbook.com/) by Thorsten Ball is a great set of books.,0.8,Go
132ximy,ji7woiu,"However, since it uses Go, it piggybacks on Go's garbage collector instead of building one of its own.",0.6,Go
132ximy,ji7woiu,"This makes the implementation easier, but it also means that you'd have trouble porting it to a non-GC language (like Rust).",-0.2,Rust
132ximy,ji7woiu,"* [Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html) by Alex Kladov (one of the main authors behind rust-analyzer) is a great tutorial on building a parser in Rust.",0.17333333333333334,Rust
132ximy,ji7woiu,* [rust-langdev](https://github.com/Kixiron/rust-langdev) has a lot of libraries for building compilers in Rust.,0.0,Rust
132ximy,ji7woiu,"* [Learning Rust with Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) is a quick tutorial on unsafe Rust, which you'll need if you're building a garbage collector yourself.",0.27777777777777773,Rust
132ximy,ji7woiu,"Aside from these, if you want some inspiration for a production-grade language built in Rust, you might want to go through the source code of [Starlark](https://github.com/facebookexperimental/starlark-rust) and [Gluon](https://github.com/gluon-lang/gluon).",0.0,Rust
131seaw,ji33agv,Go is weird since it doesn't follow the standard ABI so I'm not sure how debuginfo works.,-0.25,Go
131seaw,ji4j7ha,Go language already saves the names of functions inside the binary objects.,0.0,Go
131seaw,ji4j7ha,Is it implemented somewhere apart from Go language ?,0.0,Go
131seaw,ji79pfg,We are not dividing C++ for Windows and Solaris.,0.0,C++
131seaw,ji79pfg,C++ is a standard for all people.,0.0,C++
131seaw,ji79pfg,"I know that different compilers can produce some variations in the ASM, but the main part, the principle is the same for all C++ code compiled anywhere.",0.05555555555555555,C++
131seaw,ji79pfg,To better understand what I mean it is useful to see the source code of Go language.,0.1625,Go
131s0kg,,"Hi All,   Im a Univeristy Student currently studying Computer Science at the University of Southampton, and as apart of my Dissertation / Thesis i have created a proof-of-concept tool that combines ideas from the Functional Language Haskell with the Block-Based visual paradigm.",0.0,Haskell
131s0kg,ji3f3v5,Replit supports Haskell.,0.0,Haskell
131s0kg,ji7cza4,Note that I don't know Haskell syntax but I know scala and FP plenty well.,0.0,Haskell
131s0kg,ji7gwvd,"If you like Haskell, maybe this would be more robust if you wrote what you could in elm.",0.5,Haskell
131p8jw,ji2qc3e,"For example, [Elm does the same thing](https://elm-lang.org/examples/shapes).",0.0,Elm
131p8jw,ji6ibye,"another option is to enforce a trailing comma, which I believe Go does",0.0,Go
130jm92,,Is anyone working creating tools for wasm in C?,0.0,C
130jm92,jhyeaw8,yes like wabt but in C.,0.0,C
130jm92,jhynl3m,it is in C++ https://github.com/WebAssembly/wabt/blob/main/src/tools/wat2wasm.cc,0.0,C++
130et47,jhwm8rr,"It's a compiled language similar to C++ and Rust with the compiler written in Rust, and I'd be grateful for some help if you're interested.",0.125,C++
130et47,jhwm8rr,"It's a compiled language similar to C++ and Rust with the compiler written in Rust, and I'd be grateful for some help if you're interested.",0.125,Rust
130et47,ji0fa4a,"We're working on a Standard COBOL compiler called [Otterkit](https://github.com/otterkit/otterkit), with the goal of helping the ecosystem by providing a free and open source compiler that conforms to the new COBOL 2023 standard.",0.10727272727272727,COBOL
130et47,ji0fa4a,We're open to contributors and would love to work with more people to help improve the COBOL ecosystem.,0.3333333333333333,COBOL
130et47,jhx896l,I wrote the beginnings of a JIT compiler in C  https://GitHub.com/samsquire/compiler see jitcompiler.c  And a simple language -  https://GitHub.com/samsquire/multiversion-concurrency-control  See LanguageInterpreter.java and ProgramParser.java and LanguageInterpreterRunner.java  The language resembles JavaScript.,0.0,C
130et47,jhx896l,I wrote the beginnings of a JIT compiler in C  https://GitHub.com/samsquire/compiler see jitcompiler.c  And a simple language -  https://GitHub.com/samsquire/multiversion-concurrency-control  See LanguageInterpreter.java and ProgramParser.java and LanguageInterpreterRunner.java  The language resembles JavaScript.,0.0,JavaScript
130et47,jhzcck3,You sound like someone the Julia programming language group would like.,0.4,Julia
130et47,ji6ax4k,"I want something that has the syntax of Rust and build system/package manager of Cargo (aside from a few things), but the freedom offered by C++.",-0.2,Rust
130et47,ji6ax4k,"I want something that has the syntax of Rust and build system/package manager of Cargo (aside from a few things), but the freedom offered by C++.",-0.2,C++
130et47,ji6ax4k,"I used C++ before switching to Rust (not because of memory safety, but because I got tired of implementing everything myself to simplify installation).",-0.4,C++
130et47,ji6ax4k,"I used C++ before switching to Rust (not because of memory safety, but because I got tired of implementing everything myself to simplify installation).",-0.4,Rust
130et47,ji6ax4k,"Along the way, my syntax has diverged somewhat, but it's still closer to Rust than anything else, and if you can read Rust, it should be understandable.",0.0,Rust
130an3z,ji1glmo,"C) then you can't control access within the process, as any function can do anything.",0.0,C
130an3z,jiafv3i,"Hardware memory protection is needed for C programs (or unsafe parts of other languages), but in a fully memory-safe language you'll never get a segfault, so there's no need for hardware to protect against it, and you have have a full OS as a single program.",0.05119047619047618,C
130an3z,jiakkco,This has nothing to do with C or Rust.,0.0,C
130an3z,jiakkco,This has nothing to do with C or Rust.,0.0,Rust
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,Go
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,Julia
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,Rust
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,D
1300cqc,jhupmv7,"From your list, I've already used older ones like Algol (-60 and -68), Cobol, Fortran and multiple assembly languages.",0.08333333333333333,Fortran
1300cqc,jhumdvn,Why no love for Pascal?,-0.25,Pascal
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,Prolog
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,C
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,Scheme
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,Ruby
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Ada
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,C
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,C++
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,COBOL
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Fortran
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Go
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Haskell
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Java
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Lisp
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Python
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Ruby
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,Rust
1300cqc,jhv6urp,Also Pascal and REXX.,0.0,Pascal
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,APL
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,Forth
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,Erlang
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,Eiffel
1300cqc,jhv6urp,Prolog is daunting for similar reasons.,0.0,Prolog
1300cqc,jhw2epp,I do not think 52 weeks are enough for Haskell alone.,0.0,Haskell
1300cqc,jhw0iaj,I'm having a lot of fun doing Elixir challenges.,0.3,Elixir
1300cqc,ji15ikp,Here is the example:  &#x200B;  |Ocaml is a powerful for metaprogramming|Create your own text processing app that highlits the syntax| |:-|:-| |PHP is the embeddable into the HTML.,0.44999999999999996,HTML
1300cqc,ji15ikp,However out of all fullstack apps that you create the one that you wrote with the PHP will be fastest in terms of development speed.,0.0,PHP
1300cqc,ji15ikp,Not ideal for single page apps or large portals.|Create your own server with the code that's injected into the HTML.,0.0732142857142857,HTML
1300cqc,ji15ikp,The code is generating some partso f the HTML based on the user's GeoIP| |Idris is powerful to create your own data types|Create a scientific app that simulates the chemical reactions.,0.44999999999999996,HTML
1300cqc,ji15ikp,)| |Elixir is a syntax sugar to Erlang that adds a bit of imperative paradigm|Just rewrite your Erlang app in Elixir| |Erlang is a programming language for concurrency where crash of one of the threads deosn't kill entire app.|Create a server with the admin panel.,0.0,Erlang
1300cqc,jhvb5o6,"I like to do a similar thing in my spare time with random programming languages, except that I make little games (either by interfacing with a C library like SDL or just making a terminal based game).",-0.271875,C
1300cqc,jhvb5o6,"It's a lot of fun :)  From your list I already tried [Free]Basic, [Gnu]Cobol, Factor, PHP, and Racket.",0.4,PHP
1300cqc,jhwveur,"You have already chosen Haskell and OCaml, which IMO are gateways to Agda/Idris and Coq.",0.0,Haskell
1300cqc,ji0zb1x,> 52 languages in 52 weeks  > no esoteric languages  It usually takes us about 8 weeks to take someone from zero to productive in Haskell.,-0.25,Haskell
1300cqc,jhwllop,(Except for Haskell),0.0,Haskell
1300cqc,jhxriqb,"For Forth, [Thinking Forth](https://thinking-forth.sourceforge.net/) is a lovely free book.",0.45,Forth
1300cqc,jhzeipp,> C++  I may have news for you.,0.0,C++
1300cqc,jhzeipp,"Otherwise, I think there's a few important languages that you could put in the list, especially for their genre-defining and paradigm-shifting attributes, and that I thought weird for them not to be included:  - ATS - Ceylon - Céu - Chapel - Cyclone - D - Dafny - E - Eff - Egison - Encore - L.B.",-0.075,D
1300cqc,jhzeipp,"Stanza - Lean - Pony - Red and/or REBOL - TypeScript - Verona  In particular, E is as ""genre-defining"" as is Smalltalk, Cyclone predates both Rust and D with its Borrow-Checking, Dafny and Lean are Theorem Provers, Céu, Chapel, Encore, L.B.",0.08333333333333333,TypeScript
1300cqc,jhzeipp,"Stanza - Lean - Pony - Red and/or REBOL - TypeScript - Verona  In particular, E is as ""genre-defining"" as is Smalltalk, Cyclone predates both Rust and D with its Borrow-Checking, Dafny and Lean are Theorem Provers, Céu, Chapel, Encore, L.B.",0.08333333333333333,Rust
1300cqc,jhzeipp,"Stanza - Lean - Pony - Red and/or REBOL - TypeScript - Verona  In particular, E is as ""genre-defining"" as is Smalltalk, Cyclone predates both Rust and D with its Borrow-Checking, Dafny and Lean are Theorem Provers, Céu, Chapel, Encore, L.B.",0.08333333333333333,D
1300cqc,jhzeipp,I see that you intend to learn Go; I then highly encourage you to learn L.B.,0.16,Go
1300cqc,jhzeipp,"Some honourable mentions:  - Alice - Clean - Felix - Limbo, the Dis Virtual Machine, and the Inferno Operating System - Oz  Now a question:  > Basic   > Lisp    Which ones?",0.2888888888888889,Alice
1300cqc,jhzeipp,"Some honourable mentions:  - Alice - Clean - Felix - Limbo, the Dis Virtual Machine, and the Inferno Operating System - Oz  Now a question:  > Basic   > Lisp    Which ones?",0.2888888888888889,Lisp
1300cqc,jhzeipp,"There's like a thousand of them both, and you mentioned Clojure separately.",0.0,Clojure
1300cqc,jhva3kn,"syntax-wise it's pretty close to Ada and generally close to C with extra steps, no?",0.10000000000000002,Ada
1300cqc,jhva3kn,"syntax-wise it's pretty close to Ada and generally close to C with extra steps, no?",0.10000000000000002,C
1300cqc,jhva3kn,I'm more curious what Java's doing there hehe,0.2,Java
1300cqc,jhv0c11,"I think the ones I’m most keen to lean into from my list are   APL, CommonLisp, Haskell, Rust, Smalltalk",0.5,APL
1300cqc,jhv0c11,"I think the ones I’m most keen to lean into from my list are   APL, CommonLisp, Haskell, Rust, Smalltalk",0.5,Haskell
1300cqc,jhv0c11,"I think the ones I’m most keen to lean into from my list are   APL, CommonLisp, Haskell, Rust, Smalltalk",0.5,Rust
1300cqc,jhw0dvd,"For erlang, I think this is the best book:  https://learnyousomeerlang.com/content  If you still can't wrap your head around erlang, try Elixir instead.",1.0,Elixir
1300cqc,jhw0dvd,"Elixir runs on the same VM, so it has the same approach to error handling, distribution, observability etc, but it's much more modern and fixes some of the erlang's problems like packaging, documentation, namespaces, and metaprogramming.",0.175,Elixir
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,Bash
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,C
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,C++
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,Python
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,JavaScript
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,Lisp
1300cqc,jhvem9x,"Java for the JVM mainly and OOP, probably could have dropped C# though but I was trying to get to 52",0.16666666666666666,Java
1300cqc,jhvem9x,"Java for the JVM mainly and OOP, probably could have dropped C# though but I was trying to get to 52",0.16666666666666666,C
1300cqc,jhw1j0z,"Also a vendor supplied debit card processing system, also written in COBOL, with a bit of assembler.",0.0,COBOL
1300cqc,jhw1j0z,"I don't love COBOL, but it has it's plusses, and it certainly has paid me very well for 25+ years.",0.3047619047619048,COBOL
1300cqc,jhvu4wv,"At least for most of their history, C# has been a much more interesting language than Java.",0.3,C
1300cqc,jhvu4wv,"At least for most of their history, C# has been a much more interesting language than Java.",0.3,Java
1300cqc,jhvu4wv,"Java has tended to lean toward the minimalist side while C# incorporates more experimental and innovative language features, for better or worse.",0.24000000000000005,Java
1300cqc,jhvu4wv,"Java has tended to lean toward the minimalist side while C# incorporates more experimental and innovative language features, for better or worse.",0.24000000000000005,C
12zjsyj,,I'm trying to design a programming language somewhere between C and C++.,0.0,C
12zjsyj,,I'm trying to design a programming language somewhere between C and C++.,0.0,C++
12zjsyj,,"In C, I'd loop through the string, checking if each character was the delimiter.",0.0,C
12zjsyj,,"I want to have some kind of automatic memory cleanup, aka destructor, a bit like C++.",0.6,C++
12zjsyj,jhsooxb,I think Rust does this correctly.,0.0,Rust
12zjsyj,jhsooxb,"C++ RAII ties things to the stack, Rust is more flexible about where it goes but you then have lifetime semantics.",0.5,C++
12zjsyj,jhsooxb,"C++ RAII ties things to the stack, Rust is more flexible about where it goes but you then have lifetime semantics.",0.5,Rust
12zjsyj,jhsooxb,"Side note: Rust’s string split returns an iterator, which you can then chain with other things, collect into a vec or use in a for loop.",-0.125,Rust
12zjsyj,jhvye7e,All of these have a NUL terminator if possible (exceptions are noted); this is very useful since it turns out people call a *lot* of C APIs.,0.195,C
12zjsyj,jhvye7e,If doing this from scratch you should make sure it preserves size info (note: the sliced types can't); I didn't due to the VString hack and maybe also the fact that C++ didn't support good enough UDLs at the time.,0.26875,C++
12zjsyj,jhvye7e,Remember that C++ is bad because it doesn't check generics eagerly by default.,-0.6999999999999998,C++
12zjsyj,jhsyruq,"If you'd like to write it semantically like how you'd write the C version, you could add an ability to give ownership of the string argument to the procedure.",0.0,C
12zjsyj,jhul36a,"You need either Borrow Checking as featured in D, Cyclone and Rust, or Automatic Garbage Collection.",0.0,D
12zjsyj,jhul36a,"You need either Borrow Checking as featured in D, Cyclone and Rust, or Automatic Garbage Collection.",0.0,Rust
12zjsyj,jht5lan,"I do want to implement a more rust-style borrow-checked system with lifetimes but it might be too big brain for me, so I'll probably just end up copying C++.",0.25,C++
12zjsyj,jhted7p,In what way is Rust more flexible?,0.5,Rust
12zjsyj,jhted7p,"Basic documentation seems to suggest that the Drop trait just works like a normal destructor and is called when something goes out of scope, tying it to the stack just like C++.",0.075,C++
12zjsyj,jhun3ws,"Alternatively you could use a cow like PHP does in many places, and abstract the whole memory thing away.",0.18888888888888888,PHP
12zjsyj,jht554f,Java and C# are both interpreted and my language is going to be compiled so a slight difference there.,-0.16666666666666666,Java
12zjsyj,jht554f,Java and C# are both interpreted and my language is going to be compiled so a slight difference there.,-0.16666666666666666,C
12zjsyj,jhtg0gc,"If you call `str::split` in Rust, it is impossible (assuming no unsafe) that the result of the function outlive the original `str` in question.",-0.14583333333333331,Rust
12zjsyj,jhtg0gc,"In C++ you could call split, drop the original string, and end up with now invalid pointers.",0.375,C++
12zjsyj,jhwox7b,Both Java and c# are compiled to the language of their respective vms.,0.0,Java
12zjsyj,jhwox7b,C# also has spans which look a lot like what you are looking for.,0.0,C
12zjsyj,jhu0wyr,Java is not strictly interpreted…,0.0,Java
12zjsyj,jhxoed9,"Rust ended up having *most* of these, except that it has no consistency since they grew in an ad-hoc manner, and Rust does not support all the zero-overhead conversions properly.",0.25,Rust
12zjsyj,jhv8su8,"Then in D it's written like this (minus a shim due to `decode` not being marked `@nogc`):      import std.container: Array;          @trusted @nogc     Array!string split(return scope const(string) str, dchar delim) pure     {         Array!string res;         size_t lastIdx = 0;         for(size_t i = 0; i < str.length;) {             const j = i;             if(str.decode(i) == delim) {                 res ~= str[lastIdx..j];                 lastIdx = i;             }         }         if(lastIdx < str.length) {             res ~= str[lastIdx..$];         }         return res;     }      @nogc unittest     {         scope str = ""Hello World!",0.08035714285714286,D
12zjsyj,jhv8su8,"The same signature in Rust would be looking like      fn split<'a>(s: &'a str, c: char) -> Vec<&'a str>",0.0,Rust
12zjsyj,jhum109,I was describing how I'd implement the algorithm in C.,0.0,C
12zjsyj,jhtskyt,"C++ RAII ties things to the stack, Rust is more flexible about where it goes...",0.5,C++
12zjsyj,jhtskyt,"C++ RAII ties things to the stack, Rust is more flexible about where it goes...",0.5,Rust
12zjsyj,jhtskyt,where the original resource is tidied away---Rust is identical to C++ here in that the resource lifetime is tied to the stack.,0.375,C++
12zjsyj,jhtskyt,"I understand how lifetime semantics allow the compiler to reason about the lifetimes of *borrows* safely in ways that C++ can't, and this is certainly a useful thing to add into the conversation ...",0.4,C++
12zjsyj,jhtskyt,"But there seemed to be a suggestion that the lifetime of the underlying resource is handled differently in Rust, and this doesn't seem to be true.",0.175,Rust
12zjsyj,jhvgrxm,"The compilation for Java seems to have always been planned to occur at runtime, since 1.0.",0.0,Java
12zcoe3,jhsc4uf,"I decided to just go with Number over int/float in Vortex, sort of like JavaScript.",0.0,JavaScript
12z66qi,,"Given that most Java / .Net applications are now deployed as backend applications, does it even make sense to have a VM (i.e.",0.5,Java
12z66qi,,"Java was first conceived as ""the language of the Internet"", and the vision was that your ""applet"" or whatever should be able to run in a multitude of browsers and on completely different hardware.",0.25,Java
12z66qi,jhsum8y,"Sure, Rust ensures that programs are correct reference-wise, but there is something to be said of having a *runtime* environment that provide those guarantees.",0.5,Rust
12z66qi,jhrph4s,"It's barely even Java anymore, but more of an annotation-based declarative meta-language with some glue code in Java.",0.275,Java
12z66qi,jhrph4s,Java application servers support some neat stuff like that.,0.0,Java
12z66qi,jhrph4s,"See for example C# Roslyn source generators, and Scala macros replacing the native runtime reflection framework.",0.0,C
12z66qi,jhrph4s,"See for example C# Roslyn source generators, and Scala macros replacing the native runtime reflection framework.",0.0,Scala
12z66qi,jhr92fr,"By contrast, a C++ program with a late binding will 100% of the time incur the cost of a virtual-method lookup.",-0.3,C++
12z66qi,jhrke50,For the AOT use-case my compiler generates C for another factor two in speed when compiled e.g.,0.0,C
12z66qi,jht8hr6,"So if, for example, Company In Question, LLC has been running their Java application since 2005 or thereabouts on Intel silicon, they were probably running on a Pentium 3, which supported all of the CPUID.1.EDX,ECX extensions up to SSE (packed 32-bit single-precision floating-point arithmetic and mixed bitwise ops on 8 shiny new 128-bit XMM registers).",0.06818181818181818,Java
12z66qi,jht8hr6,"But because their program is in Java, they can rely on the fine folks at Sun and the …folks at Oracle to do all that in the JVM for them, and as long as they keep their JVM up-to-date they’re fine.",0.2611111111111111,Java
12z66qi,jht8hr6,"Similarly, when you compile C or C++ code, you specify to the compiler the extensions you *know* are present (e.g., by `-m` switches), which you want it to use when optimizing and code-generating, and typically everything else is handled at the library level; e.g., the GNU/Linux ABI supports “ifuncs” which run a load-time ctor to decide how a particular function should resolve, typically based on the properties of the host CPU/platform.",-0.03333333333333333,C
12z66qi,jht8hr6,"Similarly, when you compile C or C++ code, you specify to the compiler the extensions you *know* are present (e.g., by `-m` switches), which you want it to use when optimizing and code-generating, and typically everything else is handled at the library level; e.g., the GNU/Linux ABI supports “ifuncs” which run a load-time ctor to decide how a particular function should resolve, typically based on the properties of the host CPU/platform.",-0.03333333333333333,C++
12z66qi,jht8hr6,"The contract between the Java programmer and JVM, or the C\#/CLI programmer and CLR, is just one more among many, and the ubercomputer spanning the Internet runs on this sort of contractual translation and transpiling.",0.5,Java
12z66qi,jhqw49j,More people are compiling Java to native now with Graal and such,0.25,Java
12z66qi,jhugnnp,"It is for this reason that a reasonably-written JVM program will *always* be twice as slow as the equivalent C program, but the CLR can usually match C ... unless the GC is a problem, which is often true for any nontrivial program.",-0.0666666666666667,C
12z66qi,jhugnnp,"WASM, Javascript, and Lua are major attempts at application-level sandboxing.",0.0625,Lua
12z66qi,jhtbbpi,One good example is Erlang & Go.,0.7,Erlang
12z66qi,jhtbbpi,One good example is Erlang & Go.,0.7,Go
12z66qi,jhtbbpi,Having the runtime for dealing with concurrency is a tremendous help (more in the case of Erlang that do more than just that).,0.4444444444444444,Erlang
12z66qi,jhtbbpi,"The other side, with Web Assembly, is *the reduction of capabilities*.",-0.125,Assembly
12z66qi,jhubd86,"Benefits of the JVM in the real world:  - Garbage collection means memory safety  - The JIT can often produce insane throughput by noticing properties of the data and code that could not be easily expressed in, e.g., the C type system.",-0.12222222222222223,C
12z66qi,jhubd86,"In C++ you must wire up libraries for this, whose interface can vary across applications.",0.0,C++
12z66qi,jhubd86,"In the native code world, the FFI between languages is the C ABI which is... workable.",0.0,C
12z66qi,jhvmcub,It was meant to be a go between to allow working on x86 code or C# code without having to do both at once.,0.0,C
12z66qi,jhrnrgo,"Well, [the main compiler for my programming language](https://github.com/FlatAssembler/AECforWebAssembly.git) is targetting the JavaScript Virtual Machine by outputting WebAssembly.",0.16666666666666666,JavaScript
12z66qi,jhrnrgo,"I think it's even better than targetting Java Virtual Machine, because, for one thing, your executables can run in any modern browser if you output WebAssembly.",0.35,Java
12z66qi,jhrnrgo,"If you target Java Virtual Machine, the users need to actually download your app.",0.0,Java
12z66qi,jhrnrgo,There is nothing equivalent to that for Java Virtual Machine.,0.0,Java
12z66qi,jhrnrgo,"Java Virtual Machine is designed to be implementable in hardware, so it makes trade-offs between being easy for compilers and being easy to implement in hardware.",0.43333333333333335,Java
12z66qi,jhrf3gu,"And platform-independency still matters (if not so much for Java specifically, then for other languages).",0.037500000000000006,Java
12z66qi,jht1uoo,"Java wasn't conceived of as a language for the Internet, it was designed to be an easier, safer way for enterprises to write software that is in the same space as C++.",0.0,Java
12z66qi,jht1uoo,"Java wasn't conceived of as a language for the Internet, it was designed to be an easier, safer way for enterprises to write software that is in the same space as C++.",0.0,C++
12z66qi,jht4lgn,"Since this is the PL subreddit i would also mention the VM creates a chance to be used for language design as well, F# runs on the CLR, Clojure runs on the JVM.",0.0,Clojure
12z66qi,jhskbp6,There's a reason why Java has a reputation for being slow and Rust has a reputation for being fast.,-0.05000000000000002,Java
12z66qi,jhskbp6,There's a reason why Java has a reputation for being slow and Rust has a reputation for being fast.,-0.05000000000000002,Rust
12z66qi,jhrl0qa,I have been doing such tests and measurements for years and have yet to find a VM that consistently delivers better results than C over a sufficient number of benchmarks.,0.25,C
12z66qi,jhtunk9,The memory safety provided by WASM is very different from the memory safety provided by Rust.,0.0,Rust
12z66qi,jhtunk9,"I can compile a C program with some vulnerabilities to WASM, and an attacker can achieve remote code execution inside the WASM.",-0.1,C
12z66qi,jhtunk9,"So while it is true that any sandboxed environment offers you some protection, I wouldn't compare it to the stronger memory safety guarantees offered by Rust or other languages.",0.10833333333333332,Rust
12z66qi,jhstwca,"I haven’t worked with JEE, but I’ve done a lot of Erlang in the past, which has native support for hot reloading.",0.0,Erlang
12z66qi,ji76psn,What is the difference between dependency injection in C# and C++ – if that concept exists in a machine-code language?,0.0,C
12z66qi,ji76psn,What is the difference between dependency injection in C# and C++ – if that concept exists in a machine-code language?,0.0,C++
12z66qi,ji76psn,"I learned Java and other languages in the university but I'm afraid that some ""business-code"" like JEE works completely different and you can't learn it well on your own (because it's suited for big systems created by big teams – I might be wrong).",-0.08928571428571429,Java
12z66qi,jht0sa4,"That's the first time I heard about JavaScript Virtual Machine, can you tell me more?",0.375,JavaScript
12z66qi,jht439j,"Rust, C++, C, etc.)",0.0,Rust
12z66qi,jht439j,"Rust, C++, C, etc.)",0.0,C++
12z66qi,jht439j,"Rust, C++, C, etc.)",0.0,C
12z66qi,jht4a3q,"I remember debugging a crash in Oracle's client library, C code compiled to assembly, no debug information, function names obfuscated.",0.0,C
12yqb7x,jhoh9hy,Go through that and you'll end up knowing how to write a full fledged dynamically typed language that gets interpreted in a VM.,0.35,Go
12yqb7x,jhohyfp,And then convert the ast from the parser to C code and compile that.,0.0,C
12yqb7x,jhpf7hn,I've been going through the book myself using Haskell and it's been a blast.,0.0,Haskell
12yqb7x,jhoxcoc,"And once you’ve computed all semantics information you pass AST and Sema info to code generator that produces IR, C code or whatever you use for the backend.",0.0,C
12yqb7x,jhojne4,I am more or less comfortable with C. Should I go in with C then?,0.24444444444444446,C
12yqb7x,jhpbmo4,I wrote an incomplete JIT compiler in C  The frontend is a simple javacript like language.,0.0,C
12yqb7x,jhpbmo4,See function\_only.lang and program2.lang and program.lang  [https://github.com/samsquire/compiler](https://github.com/samsquire/compiler)  The structs might be helpful when designing your AST data structure as there's a lot of manual data structure management in C.,0.0,C
12yqb7x,jhovdj8,"Else I would go with go, java, kotlin or C# because they are statically typed and garbage collected, which will make your development faster and less error prone than in C",-0.16666666666666666,C
12yeuo2,jhnls90,Anyone else who thinks doing generic programming with C macros + GCC extensions is actually a pretty good puzzle game?,0.13749999999999998,C
12yeuo2,jhoq6p2,"Some of your points remind me of the Actor model (cf Erlang, Elixir, Akka, Orleans...).",0.0,Erlang
12yeuo2,jhoq6p2,"Some of your points remind me of the Actor model (cf Erlang, Elixir, Akka, Orleans...).",0.0,Elixir
12yeuo2,jhp97jl,Orleans grains and actors in Erlang and Akka.,0.0,Erlang
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,JavaScript
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,TypeScript
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Python
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Haskell
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Bash
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Lisp
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,APL
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Ada
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,C
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Rust
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Forth
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Erlang
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,HTML
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,Assembly
12y72hc,jhmp3zg,"ADSP: The Podcast - accessible PL oriented discussion around mainly C++ and APL (but some other stuff as well), you might want to cherry pick but don't skip the ones with Sean Parent!",0.1284722222222222,C++
12y72hc,jhmp3zg,"ADSP: The Podcast - accessible PL oriented discussion around mainly C++ and APL (but some other stuff as well), you might want to cherry pick but don't skip the ones with Sean Parent!",0.1284722222222222,APL
12y72hc,jhmp3zg,"Software Unscripted - podcast about PL and implementation (most episodes anyway), very accessible  We Speak Your Language - language designers and researchers talking to language designers and researchers, fairly accessible  Corecursive - some episodes are just about PLs - you need to cherry pick - but TBH, the whole podcast is a goldmine, very accessible  Future of Coding - another goldmine, some cherry picking necessary but the paper discussions that Ivan and Jimmy do are simply the best stuff, very accessible  The Search Space - about logic and relational PLs, accessible  The Type Theory Podcast - type theory related stuff, PLs like Idris, proof assistants and more, requires some contextual knowledge  The Haskell Interlude - great stuff about Haskell ecosystem, reasonably accessible with some contextual knowledge  Elm Town - you have to cherry pick the episodes with Evan Czaplicky + some other more PL oriented, very accessible and fun  Type Theory Forall - some at least contextual knowledge makes it fairly accessible, not only type theory  Lex Fridman Podcast - you really have to cherry pick and it feels weird putting it on this list, BUT!",0.26666666666666666,Haskell
12y72hc,jhmp3zg,"Software Unscripted - podcast about PL and implementation (most episodes anyway), very accessible  We Speak Your Language - language designers and researchers talking to language designers and researchers, fairly accessible  Corecursive - some episodes are just about PLs - you need to cherry pick - but TBH, the whole podcast is a goldmine, very accessible  Future of Coding - another goldmine, some cherry picking necessary but the paper discussions that Ivan and Jimmy do are simply the best stuff, very accessible  The Search Space - about logic and relational PLs, accessible  The Type Theory Podcast - type theory related stuff, PLs like Idris, proof assistants and more, requires some contextual knowledge  The Haskell Interlude - great stuff about Haskell ecosystem, reasonably accessible with some contextual knowledge  Elm Town - you have to cherry pick the episodes with Evan Czaplicky + some other more PL oriented, very accessible and fun  Type Theory Forall - some at least contextual knowledge makes it fairly accessible, not only type theory  Lex Fridman Podcast - you really have to cherry pick and it feels weird putting it on this list, BUT!",0.26666666666666666,Elm
12y5wjc,jhogowi,"I think Rust does a really, really good job of this.",0.7,Rust
12y5wjc,jhogowi,"Here Rust also does a great job, with `rust-analyzer` rendering markdown-formatted tooltips as rich text when you hover over the relevant symbols, and Jetbrains' CLion even rendering the rich text in the source file itself if you view it in ""reader mode.""",0.48750000000000004,Rust
12y5wjc,jhogowi,"I've been writing a lot of C++ lately, and the lack of these niceties has been a little bit of a pain point.",-0.24375,C++
12y5wjc,jhq7jz6,"This is because blocks of Eve code are like Prolog horn clauses, so they compose naturally with all other blocks in the program.",-0.012499999999999997,Prolog
12y5wjc,jhmm16n,"Also the book ""Lisp in Small Pieces"".",-0.25,Lisp
12xwmo2,,"I was looking for go or odin, C or C++ is not of my preference because I make too many mistakes and it does not have an easy testing framework.",0.4666666666666667,C
12xwmo2,,"I was looking for go or odin, C or C++ is not of my preference because I make too many mistakes and it does not have an easy testing framework.",0.4666666666666667,C++
12xwmo2,jhkmktf,"I posted my sadness on my experience with C++ as a PLDI impl language a while ago, and I took 6 months to try out a range of languages.",0.0,C++
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,C
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,Rust
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,PHP
12xwmo2,jhl1vab,"If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,Rust
12xwmo2,jhl1vab,"If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,C
12xwmo2,jhl1vab,"If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,C++
12xwmo2,jhl1vab,"Rust is ""C or C++, good practiques ON"".",0.7,Rust
12xwmo2,jhl1vab,"Rust is ""C or C++, good practiques ON"".",0.7,C
12xwmo2,jhl1vab,"Rust is ""C or C++, good practiques ON"".",0.7,C++
12xwmo2,jhl1vab,"I have ""rewritten"" my lang SO MANY TIMES (probably not an exaggeration that closer to 100 times), precisely because is FAST to iterate on Rust.",0.3666666666666667,Rust
12xwmo2,jhl1vab,"I tried to learn Rust making the lang, and the first 3 months were absolutely terrible, to the point I almost drop it.",-0.375,Rust
12xwmo2,jhl1vab,This is because making another lang force to muscle your way to almost any feature Rust has and deal with things that are not Rust idioms.,0.0,Rust
12xwmo2,jhl1vab,"First, I stop implementing things that are non-idiomatic Rust like linked-list-like things, pseudo-OOP, trying to implement ""unsafe"", and trying to optimize blindly (or worry about this prematurely).",-0.125,Rust
12xwmo2,jhl1vab,"Write Rust as-is: struct, enums, pattern matching, light on traits.",0.4,Rust
12xwmo2,jhl1vab,Go for `.clone`.,0.0,Go
12xwmo2,jhl1vab,"**  If you think that Go, Swift, or similar is easier considering that is *exactly* what that language is doing: A lot of clones, things behind `Arc/Rc/Gc`, etc, only in Rust that is piece-meal.",-0.037500000000000006,Go
12xwmo2,jhl1vab,"**  If you think that Go, Swift, or similar is easier considering that is *exactly* what that language is doing: A lot of clones, things behind `Arc/Rc/Gc`, etc, only in Rust that is piece-meal.",-0.037500000000000006,Swift
12xwmo2,jhl1vab,"**  If you think that Go, Swift, or similar is easier considering that is *exactly* what that language is doing: A lot of clones, things behind `Arc/Rc/Gc`, etc, only in Rust that is piece-meal.",-0.037500000000000006,Rust
12xwmo2,jhl1vab,Is so easy on Rust to do this because refactoring works wonders here.,0.43333333333333335,Rust
12xwmo2,jhl0f4k,"My favourite and easiest to work with was in C#, back when it didn't take 2 seconds to compile hello world (which is the current case on my machine right now).",0.09523809523809523,C
12xwmo2,jhl0f4k,Pretty much every language can do 10K lines in a second and not even Go compiles 100K on my machine.,0.15,Go
12xwmo2,jhlibnp,"If Rust stops being fun, it's time for a change.",0.3,Rust
12xwmo2,jhlibnp,"May I suggest a dialect of lisp, such as Scheme or Python?",0.0,Scheme
12xwmo2,jhlibnp,"May I suggest a dialect of lisp, such as Scheme or Python?",0.0,Python
12xwmo2,jhlibnp,"(Yes, Python is a lisp, albeit a weird one.)",-0.5,Python
12xwmo2,jhlibnp,Things that don't necessarily fit trivially into Rust's ontology.,0.4,Rust
12xwmo2,jhoc27u,"I have a compiler implementation in Rust, and aside from a couple small places where I had to re-architect due to borrowck's protests to initial naive implementation I did not really have any issues.",-0.155,Rust
12xwmo2,jhnlaym,"Out of interest, have you tried using Haskell (or a similar functional language) as an implementation lang?",0.0,Haskell
12xwmo2,jhnlaym,"After trying to write a simple parser in C++, I'm realising how much I'm missing from Haskell, like ergonomic sum types and applicative parsing 😅",0.06666666666666667,C++
12xwmo2,jhnlaym,"After trying to write a simple parser in C++, I'm realising how much I'm missing from Haskell, like ergonomic sum types and applicative parsing 😅",0.06666666666666667,Haskell
12xwmo2,jhku8qy,Mind sharing your post about using C++ for this ?,0.0,C++
12xwmo2,jhmqkwl,I've been writing compilers in Go and one thing i miss very badly is sum types or at least non-nullable references.,-0.6049999999999999,Go
12xwmo2,jhlg1bt,">If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,Rust
12xwmo2,jhlg1bt,">If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,C
12xwmo2,jhlg1bt,">If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,C++
12xwmo2,jhlg1bt,"Rust is ""C or C++, good practiques ON"".",0.7,Rust
12xwmo2,jhlg1bt,"Rust is ""C or C++, good practiques ON"".",0.7,C
12xwmo2,jhlg1bt,"Rust is ""C or C++, good practiques ON"".",0.7,C++
12xwmo2,jhlg1bt,"I know, my first iteration was in C++.",0.25,C++
12xwmo2,jhlg1bt,That is why I said that preferably do not recommend me C or C++.,0.0,C
12xwmo2,jhlg1bt,That is why I said that preferably do not recommend me C or C++.,0.0,C++
12xwmo2,jhlg1bt,">If you think that Go, Swift, or similar is easier considering that is exactly what that language is doing: A lot of clones, things behind Arc/Rc/Gc, etc, only in Rust that is piece-meal.",-0.037500000000000006,Go
12xwmo2,jhlg1bt,">If you think that Go, Swift, or similar is easier considering that is exactly what that language is doing: A lot of clones, things behind Arc/Rc/Gc, etc, only in Rust that is piece-meal.",-0.037500000000000006,Swift
12xwmo2,jhlg1bt,">If you think that Go, Swift, or similar is easier considering that is exactly what that language is doing: A lot of clones, things behind Arc/Rc/Gc, etc, only in Rust that is piece-meal.",-0.037500000000000006,Rust
12xwmo2,jhlg1bt,Is so easy on Rust to do this because refactoring works wonders here.,0.43333333333333335,Rust
12xwmo2,jhnmop6,">Yes, Python is a lisp, albeit a weird one.",-0.5,Python
12xwmo2,jhl0awn,"> I am having too much friction with the borrow checker  D has a GC by default, and optional borrow checking in `@safe` code, so it should help on that front.",0.35,D
12xwmo2,jhl0awn,"Until DMD was auto-translated to D and got the GC turned on, Bright always advocated for just `malloc`ing without `free`ing, with the rationale that as a compiler is a short-lived CLI tool, the OS itself is good enough of a memory manager.",0.4666666666666666,D
12xwmo2,jhoauyl,"Haskell never really popped up for that reason, but I've just done a quick search and there's GHCJS and a Haskell compiler that outputs WASM.",0.11666666666666665,Haskell
12xwmo2,jhoaank,"[https://www.reddit.com/r/Compilers/comments/nwqil5/comment/h1b1vpm/?context=3](https://www.reddit.com/r/Compilers/comments/nwqil5/comment/h1b1vpm/?context=3)  The TLDR and update since then;   * IME Engineering effort is a good 10-20% more than other languages * Related - IME you just end up writing more code in C++ * While I can recognise common mistakes I'm making, its very difficult to develop a process, meta/framework, abstraction, lint, etc - to actually grow as a developer and move beyond the same problems * C++ modules are not great.",0.022499999999999985,C++
12xwmo2,jhoaank,"* C++ Modules also do not align with other PLs ideas of a ""Module"".",-0.125,C++
12xwmo2,jhoaank,"* Using the stdlib has limitations, which are quickly reached with compiler/graph work  I often go back to the mindset of ""C with metaprogramming"" when using C++.",0.16666666666666666,C
12xwmo2,jhoaank,"* Using the stdlib has limitations, which are quickly reached with compiler/graph work  I often go back to the mindset of ""C with metaprogramming"" when using C++.",0.16666666666666666,C++
12xwmo2,jhoaank,"Not sure if he roams reddit still, but he might be able to offer a second opinion for you too on his experiences using C++ as a PL impl lang.",0.08333333333333333,C++
12xwmo2,jhmzcab,What's the tree/graph structures like in Go?,0.0,Go
12xwmo2,jhlgk21,In my case C# was the quickest.,0.0,C
12xwmo2,jhlgk21,I haven't written any C# since it has gotten so slow.,-0.30000000000000004,C
12xwmo2,jhlgk21,My current implementation is in C++.,0.0,C++
12xwmo2,jhlgk21,"If you're strong with Java and can easily debug with it, try that",0.43333333333333335,Java
12xwmo2,jhp1tsk,"I've actually been employed working on a PL in Rust for the last (nearly) 2 years, so I have a LOT of opinions.",0.03333333333333333,Rust
12xwmo2,jhp1tsk,"I'm currently in the process of slowly erasing all the stupid shit I wrote when I started because I didn't really ""get"" Rust then.",-0.22000000000000003,Rust
12xwmo2,jhp1tsk,"(FWIW, I've been programming for more than 30 years and spent a decade on the C++ standards committee.",0.2,C++
12xwmo2,jhp1tsk,"The ""modern"" approach of building ASTs as a forest of nodes imposes memory requirements that can be tricky in Rust, and easily lead to UB in any language.",0.31666666666666665,Rust
12xwmo2,jhp1tsk,Rust is optimized for processing linearizable data.,0.0,Rust
12xwmo2,jhp1tsk,Error handling in Rust requires careful thought.,-0.1,Rust
12xwmo2,jhp1tsk,C++ is optimized for... whatever you want to optimize for.,0.0,C++
12xwmo2,jhp1tsk,And you're more likely to get it wrong than if you use Rust.,0.0,Rust
12xwmo2,ji87s10,"Yes, all graphs and trees in Go are written using pointers, otherwise the compiler can't compute the size of the recursive data structures, usually my ASTs have the structure:      type Node struct {         Lexeme Lexeme         Leaves []*Node     }  So, both `Node.Leaves` and `Node.Leaves[n]` can be a null reference.",-0.25,Go
12xvdui,,"Looking at C++, it seems that the compiler checks to see which overload it should use by looking for any casts done or arguments passed, but I want to be able to pass around the overloaded function itself in my language.",0.5,C++
12xvdui,jhl5inu,"Not that much languages have that kind of features, and the ones that come to my mind at this instant (TypeScript and Raku) all are built expecting a dynamic runtime.",0.2,TypeScript
12xvdui,jhkiklk,"Edit: _or a hash table that maps function names to hash tables mapping signatures to function bodies/addresses_   something like ``` std::map<std:: string, std::map<signature, function>> ```  in C++  I haven't put this into practice, mind.",0.0,C++
12xvdui,jhkiklk,"When I think of function overloading, I normally think of C++'s name-mangled solution (which can't support what you describe, since although we do have function objects in C++, IIRC they're not true first-class citizens, which your example implies.",-0.012499999999999997,C++
12xvdui,jhl3zc2,"In C++, you could represent them as a template and provide specializations:      template <class T>     T f(T val);      template<>     i64 f<i64>(i64 val) { return val; }       template<>     f64 f<f64>(f64 val) { return val; }      auto intz = f<i64>(0LL);     auto floatz = f<f64>(0.0);  With type inference, you could infer the template type argument from the function argument.",0.0,C++
12xo1hj,jhmr27f,Objective-C is (was?),0.0,Objective-C
12xo1hj,jhksnrg,"Is that the case here, and if not, why do you think languages like Smalltalk and Ruby allow for that configurability?",0.0,Ruby
12xo1hj,jhjrhdi,"qdbp isn't pure in the same way, for example, Haskell is.",0.10714285714285714,Haskell
12xo1hj,jhk8nbv,"in Java  ``` var s  = ""Hello world"".substring(7);// s is a new string ""world"" ```",0.13636363636363635,Java
12xo1hj,jhk8yml,"Basically I don't see how it's ""first-class OOP"", as defined by something like Smalltalk, when it can be implemented with Rust's `struct`/`impl` situation.",0.0,Rust
12xo1hj,jhkn8e1,I think the difference between qdbp and Rust in terms of object-orientedness is that centering your programming style around objects is mandatory with qdbp and not with Rust(because everything is an object in qdbp).,0.0,Rust
12xo1hj,jhkn8e1,"Yes, you can program in an object-oriented style in rust, as can you in many other languages( like [C](https://www.freetechbooks.com/object-oriented-programming-with-ansi-c-t551.html)), but I wouldn't call either of these object oriented languages.",0.1875,C
12xo1hj,jhkn8e1,"At the end of the day, however, the term ""object-oriented"" is poorly defined and has been used to refer to a lot of styles, from Smalltalk to Self to Java to the [object calculus](https://pages.cpsc.ucalgary.ca/~robin/FMCS/FMCS2014/An%20introduction%20to%20OOC.pdf), all of which have different takes on what ""object oriented"" really means.",-0.06666666666666667,Java
12xo1hj,jhkzb9t,"In short, the type system is the static version of the duck typing you get with languages like Python.",0.25,Python
12xnvrd,,"But, in the side-bar, he says "" In some other languages, like Pascal, Python, and Go, assignment is a statement. """,-0.125,Pascal
12xnvrd,,"But, in the side-bar, he says "" In some other languages, like Pascal, Python, and Go, assignment is a statement. """,-0.125,Python
12xnvrd,,"But, in the side-bar, he says "" In some other languages, like Pascal, Python, and Go, assignment is a statement. """,-0.125,Go
12xnvrd,jhkigl3,"The historical examples given by [K&R](https://kremlin.cc/k&r.pdf) for C's assignment expression were about its ability to be used as a control expression in a loop, as in      main()     {         int c;         while((c = getchar()) != EOF)             putchar(c);     }          void copy(char to[], char from[])     {         int i;         i = 0;         while((to[i] = from[i]) != '\0')             ++i;     }  This also allows for the documented pattern `nl = nw = nc = 0;` meaning `nl = (nw = (nc = 0));`.",-0.30989583333333337,R
12xnvrd,jhkigl3,"The historical examples given by [K&R](https://kremlin.cc/k&r.pdf) for C's assignment expression were about its ability to be used as a control expression in a loop, as in      main()     {         int c;         while((c = getchar()) != EOF)             putchar(c);     }          void copy(char to[], char from[])     {         int i;         i = 0;         while((to[i] = from[i]) != '\0')             ++i;     }  This also allows for the documented pattern `nl = nw = nc = 0;` meaning `nl = (nw = (nc = 0));`.",-0.30989583333333337,C
12xnvrd,jhkigl3,"In fact, even in C, the latter is a common pattern when dealing with global variables, where `setPropertyX(y)` is expected to return ""old X.""",-0.06000000000000001,C
12xnvrd,jhkigl3,"Rust says `()` is returned, and C++ invokes copy-constructors.",0.0,Rust
12xnvrd,jhkigl3,"Rust says `()` is returned, and C++ invokes copy-constructors.",0.0,C++
12xnvrd,jhlq6lb,"*Side side-bar: In Python 3.10 and up, assignment has an expression form and a statement form.",0.0,Python
12xnvrd,jhlq6lb,Pascal falls squarely into this camp.,0.0,Pascal
12xnvrd,jhlq6lb,C and its ilk (and Lox) operate in a weird middle-ground thanks to some odd circumstances.,-0.15555555555555556,C
12xnvrd,jhlq6lb,So it's in C and by extension Lox.,0.0,C
12xnvrd,jhjbesm,In Pascal      a := b;  is a statement that doesn't return a value and cannot be used in an expression.,0.0,Pascal
12xnvrd,jhm9953,">In fact, even in C, the latter is a common pattern when dealing with global variables, where    >   >setPropertyX(y)   >   > is expected to return ""old X.""",-0.06000000000000001,C
12xnvrd,jhm9953,I don't know where that might be a common pattern (Java?,-0.3,Java
12xnvrd,jhm9953,"), but it isn't C. It's not in the C standard, and in the 40 years I've known C, I haven't seen any code using such a convention or any textbook suggesting it.",0.0,C
12xnvrd,jhk0u1x,"You'll find this in the ML family especially, and the style was adapted into Rust as well.",0.0,Rust
12xcnv2,jhin6i2,:D,1.0,D
12x46f5,,Lately we’ve seen a lot of progress in low-level programming with Rust being the canonical example.,-0.3,Rust
12x46f5,,"The other trend has been the growing adoption of static typing, for example with the success of TypeScript.",0.225,TypeScript
12x46f5,jhhisc8,"Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,Python
12x46f5,jhhisc8,"Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,JavaScript
12x46f5,jhhisc8,"I saw a presentation on how to use ""gradual types"" to bridge Haskell and a full dependent type system.)",0.35,Haskell
12x46f5,jhhzyya,Cause there's very little in Rust that's C-style low level.,-0.12187500000000001,Rust
12x46f5,jhi1vh0,"But at the very least like COBOL, Visual Basic... it is allowing business' IT to create lots of low cost programs to automate away parts of repetitive labor intensive processes.",-0.128,COBOL
12x46f5,jhk7aye,"Something resembling JS lambdas, Haskell, and list comprehension altogether, but more extensible.",0.5,Haskell
12x46f5,jhk7aye,"Simpler OOP, something resembling Ruby.",0.0,Ruby
12x46f5,jhk7aye,Python's OOP feels bolted on.,0.0,Python
12x46f5,jhk7aye,Array-Oriented Features (like Julia).,0.0,Julia
12x46f5,jhk7aye,"Also, package management should be simpler than Python's black hole of pip.",-0.16666666666666666,Python
12x46f5,jhk7aye,"Julia largely executes on each of these ideas, but has a few too many flaws holding it back: 1-based indexing, no real OOP support (other than structs), no real logical constructs.",0.029421768707482993,Julia
12x46f5,jhi10et,> Lately we’ve seen a lot of progress in low-level programming with Rust being the canonical example.,-0.3,Rust
12x46f5,jhi10et,Rust has algebraic datatypes and pattern matching.,0.0,Rust
12x46f5,jhi10et,"> The other trend has been the growing adoption of static typing, for example with the success of TypeScript.",0.225,TypeScript
12x46f5,jhi10et,25 years ago the most popular languages were C++ and Java.,0.55,C++
12x46f5,jhi10et,25 years ago the most popular languages were C++ and Java.,0.55,Java
12x46f5,jhi10et,"Today, Javascript and Python are among the most popular languages.",0.55,Python
12x46f5,jhianvc,"**  I like they way Lambda Expressions are implemented in C#, but not a fan of the company.",0.0,C
12x46f5,jhianvc,"C++ syntax looks very low level programming, but it's valid, since it meant to interact with low level systems.",0.0,C++
12x46f5,jhianvc,"and related compiler developer, I started both a hobbyist static / strong versions of PHP and JavaScript years ago, before Typescript and HHVM and other appeared, but I never finished due workload and an ADDH issue...  **Other (old that look new) features are modules, exceptions, and interfaces / traits.",0.09933712121212121,PHP
12x46f5,jhianvc,"and related compiler developer, I started both a hobbyist static / strong versions of PHP and JavaScript years ago, before Typescript and HHVM and other appeared, but I never finished due workload and an ADDH issue...  **Other (old that look new) features are modules, exceptions, and interfaces / traits.",0.09933712121212121,JavaScript
12x46f5,jhianvc,"**  As a Modula / Pascal developer I have seen for years, with ""stack overflow horror"", how a lot of new P.L.",0.13636363636363635,Pascal
12x46f5,jhianvc,"(s) appeared, without proper modular support, which ""obsolete"" Pascal and ""obsolete"" Ada had for years !",0.0,Pascal
12x46f5,jhianvc,"(s) appeared, without proper modular support, which ""obsolete"" Pascal and ""obsolete"" Ada had for years !",0.0,Ada
12x46f5,jhianvc,"C++ just approved their version of Modules recently, the same for Namespaces for PHP.",0.0,C++
12x46f5,jhianvc,"C++ just approved their version of Modules recently, the same for Namespaces for PHP.",0.0,PHP
12x46f5,jhianvc,"C++ has ""concept"" (s) which is an indirect way to support interfaces.",0.0,C++
12x46f5,jhianvc,"Personally, I prefer a simple syntax with the ""interface"" keyword as Delphi and Java did originally.",0.125,Delphi
12x46f5,jhianvc,"Personally, I prefer a simple syntax with the ""interface"" keyword as Delphi and Java did originally.",0.125,Java
12x46f5,jhianvc,"**And, speak of Java, ""annotations"", modifiers, specifiers, directives, attributes  and other ways of additional metadata or extending a P.L.",-0.125,Java
12x46f5,jhianvc,"Just check how Java based C# has a lot of keywords / features that still are annotations in Java like ""@override"".",0.0,Java
12x46f5,jhianvc,"Just check how Java based C# has a lot of keywords / features that still are annotations in Java like ""@override"".",0.0,C
12x46f5,jhi7bcs,"My suspicion is that this trend will continue into AI generated code  consider opening a file in C       FILE * fp = fopen(""myFile.txt"",""r"");       // find length of file      fseek(fp,0,SEEK_END);      long length = ftell(fp);            //allocate memory      buffer = malloc(sizeof(char) * (length+1));       //read data into buffer      fseek(fp,0,SEEK_SET);      fread(fp,sizeof(char)*length,buffer);      buffer[length] = 0;  vs python        File = open(""myFile.txt"", ""r"")       Data = File.read() but these two programs do the same exact thing!",0.065625,C
12x46f5,jhhwpma,"All these ideas were from the Common Lisp Object System, with the first two appearing in Flavors around 40 years ago.",-0.024999999999999994,Lisp
12x46f5,jhhwpma,"Lisp macros are another big win for writing less, but they have to be approached carefully.",0.13333333333333336,Lisp
12x46f5,jhik6ti,"I’ve been doing low level programming in Ada for over 15 years, others have fir about 40.",0.0,Ada
12x46f5,jhik6ti,Ada has had type information via attributes since it’s inception.,0.0,Ada
12x46f5,jhledr6,"Fortran or COBOL lets you delegate things like memory layout and instruction scheduling to the compiler, among other things.",-0.125,Fortran
12x46f5,jhledr6,"Fortran or COBOL lets you delegate things like memory layout and instruction scheduling to the compiler, among other things.",-0.125,COBOL
12x46f5,jhledr6,ALGOL and LISP added a clear mathematical foundation for the definition of a programming language.,0.05000000000000001,ALGOL
12x46f5,jhledr6,"So, for instance, C is higher-level than BCPL mainly because in BCPL everything is an uninterpreted 32-bit number, whereas C can usually help you out with array indexes and byte access.",-0.04166666666666667,C
12x46f5,jhledr6,"But Algol already had semantically-meaningful data types in 1958, so C loses and BCPL loses harder.",-0.2333333333333333,C
12x46f5,jhjlbgn,">	Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,Python
12x46f5,jhjlbgn,">	Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,JavaScript
12x46f5,jhjmzyu,"Yeah, Rust is TOTALLY a *great* example of a high-level language.",0.8,Rust
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,C
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,C++
12x46f5,jhjmzyu,"You can also claim it to be higher than Haskell, depending on how you consider the monad <> borrow checker to fall into this.",0.25,Haskell
12x46f5,jhjd4om,"[Practical type inference for arbitrary-rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf) is a fantastic, relatively beginner friendly paper about type inference that even features an implementation in Haskell!",0.28958333333333336,Haskell
12x46f5,jhjd4om,In other words       A    B     --------        C  just means `If A and B then C`.,-0.125,C
12x46f5,ji3cw88,">Julia largely executes on each of these ideas, but has a few too many flaws holding it back: 1-based indexing,   So your list is missing:  12.",0.06285714285714285,Julia
12x46f5,ji3cw88,"1-based didn't really do Fortran any harm, and it's now N-based, like my stuff has always been.",0.2,Fortran
12x46f5,ji3cw88,"0-based became popular because of C; C used it because its `A[i]` terms were syntactic sugar for `*(A+i)`, where the index is an offset to a pointer; and relative offsets must start at zero.",0.3,C
12x46f5,jhi9sym,"JS and Python both have stories for typing though, with TypeScript particularly becoming the default over plain JS for tons of people.",0.11785714285714287,Python
12x46f5,jhi9sym,"JS and Python both have stories for typing though, with TypeScript particularly becoming the default over plain JS for tons of people.",0.11785714285714287,TypeScript
12x46f5,jhk3len,"> Javascript  I wouldn't look at JavaScript and say ""this is what programmers want.""",0.0,JavaScript
12x46f5,jhk3len,"Otherwise we'd have to accept _PHP_ as being a representative of ""programming language evolution"" (and if we trust the charts, was so majorly during the same period Java was).",0.03125,Java
12x46f5,jhk3len,"According to the same charts C still is, and always has been, the king anyway, far surpassing everything else.",0.05,C
12x46f5,jhitpth,"I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,Rust
12x46f5,jhitpth,"I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,C++
12x46f5,jhitpth,"You can probably hack sum types and pattern matching together in a preprocessor macro in C, but that doesn't make C + CPP high-level in any way.",0.0,C
12x46f5,jhitpth,"An example: if I want a tree data structure, in Haskell (which is high-level) I can just say `data Tree a = Leaf a | Bin (Tree a) (Tree a)`.",0.0,Haskell
12x46f5,jhitpth,"In Rust I need to explicitly box the subtrees (`Bin(Box<Tree<A>>, Box<Tree<A>>`), and if I'm unlucky enough I'll also need things like reference counting in case I want to do stuff like structural sharing (which you get for free in Haskell, although it's arguably extra useful there due to immutability).",0.11499999999999999,Rust
12x46f5,jhitpth,"In Rust I need to explicitly box the subtrees (`Bin(Box<Tree<A>>, Box<Tree<A>>`), and if I'm unlucky enough I'll also need things like reference counting in case I want to do stuff like structural sharing (which you get for free in Haskell, although it's arguably extra useful there due to immutability).",0.11499999999999999,Haskell
12x46f5,jhitpth,"(Then again, using Rc or even Box in Rust also does, as you get good old malloc/free and pointer indirection which also cost resources.)",0.39999999999999997,Rust
12x46f5,jhitpth,"As for the growing adoption of static typing, OP is probably refering to the rise of especially TypeScript.",0.25,TypeScript
12x46f5,jhitpth,Other recent-ish popular languages with static typing include Rust and Go.,0.325,Rust
12x46f5,jhitpth,Other recent-ish popular languages with static typing include Rust and Go.,0.325,Go
12x46f5,jhmoa28,"Consider the following program in Haskell:      data Person = Person { name :: String }       deriving (Show, Read)      main :: IO ()     main =  do       input <- getLine       let person = read input :: Person       print person  When we start it and enter `Person { name = ""Peter"" }` we get `Person { name = ""Peter"" }`.",0.1111111111111111,Haskell
12x46f5,jhiqx49,"I still think optional typing is an interesting approach, and a great fit for adding a type system to an existing dynamically typed language (see: TypeScript).",0.5666666666666668,TypeScript
12x46f5,jhiqx49,"But for Dart, almost all users were *much* happier when we moved to a sound type system.",0.30000000000000004,Dart
12x46f5,jhkds0h,"I think that when people talk about low-level languages, they often mean system languages and Rust is definitely that.",-0.15625,Rust
12x46f5,jhmfybr,> TypeScript particularly becoming the default over plain JS for tons of people  [9% market share](https://www.itjobswatch.co.uk/jobs/uk/typescript.do).,0.11785714285714287,TypeScript
12x46f5,jhmg8c0,"> I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,Rust
12x46f5,jhmg8c0,"> I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,C++
12x46f5,jhmg8c0,"> In Rust I need to explicitly box the subtrees (Bin(Box<Tree<A>>, Box<Tree<A>>)  Rust and Swift give you control over such things.",0.0,Rust
12x46f5,jhmg8c0,"> In Rust I need to explicitly box the subtrees (Bin(Box<Tree<A>>, Box<Tree<A>>)  Rust and Swift give you control over such things.",0.0,Swift
12x46f5,jhmg8c0,C# lets you control struct layout more than Java too.,0.5,C
12x46f5,jhmg8c0,C# lets you control struct layout more than Java too.,0.5,Java
12x46f5,jhmg8c0,Does that make C# low level?,0.0,C
12x46f5,jhmg8c0,"(Then again, using Rc or even Box in Rust also does, as you get good old malloc/free and pointer indirection which also cost resources.)",0.39999999999999997,Rust
12x46f5,jhl5ssx,Sum types and pattern matching have already been hacked together in a preprocessor macro in C; see https://github.com/Hirrolot/datatype99.,0.0,C
12x46f5,jhl7153,"I don't expect that to happen, but similar collisions can occur even in non-OO languages, such as with `clone()` for a Rust `&Rc<T>` (an independent issue which also has no such ideal solution).",0.18,Rust
12x46f5,jhkf259,"The main thing is that before Rust, ""low-level languages"" always imply ""system languages"".",0.16666666666666666,Rust
12x46f5,jhn2hiu,"As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,Swift
12x46f5,jhn2hiu,"As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,Rust
12x46f5,jhn2hiu,"And yes, struct support in C# makes it lower level than Java.",0.0,C
12x46f5,jhn2hiu,"And yes, struct support in C# makes it lower level than Java.",0.0,Java
12x46f5,jhn2hiu,(But I don't know enough about C# to go in depth here.),0.0,C
12x46f5,jhn2hiu,"In fact, C++ has reference counting too I'm pretty sure (in the form of `std::shared_ptr<T>`).",0.375,C++
12x46f5,jhn2hiu,"But I've never heard anyone call C++ a high level language, except when it was new and everything above assembly was high level.",0.1140909090909091,C++
12x46f5,jhnbenr,"Sure but you seem to be implying that zero cost features like C++ exceptions are low-level when, to me, they are just a different default.",0.25,C++
12x46f5,jhnbenr,"> As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,Swift
12x46f5,jhnbenr,"> As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,Rust
12x46f5,jhnbenr,"Again, Swift boxes by default and you cannot annotate to unbox whereas in Rust you annotate to box.",0.0,Swift
12x46f5,jhnbenr,"Again, Swift boxes by default and you cannot annotate to unbox whereas in Rust you annotate to box.",0.0,Rust
12x46f5,jhnbenr,"> In fact, C++ has reference counting too I'm pretty sure (in the form of std::shared_ptr<T>).",0.375,C++
12x46f5,jhnbenr,"But I've never heard anyone call C++ a high level language, except when it was new and everything above assembly was high level.",0.1140909090909091,C++
12x46f5,jibkth8,"You could (and many, I’m sure, have) write an AOT compiled implementation of Lisp.",0.5,Lisp
12wzu36,jhiklvp,"you are using to implement your P.L., like ""I'm using C++ for implementing the Cool P.L.""",0.35,C++
12wzu36,jhiklvp,"In this case, that means use something like Javadoc or Doxygen for C++, not ""Cool"" source code.",-0.175,C++
12wzu36,jhiklvp,"And, in this case, that means use something like Javadoc or Doxygen for ""Cool"", not C++, source code   You may want to do the same.",0.175,C++
12wzu36,jhhna0k,"For the language itself I have multiple tools in place: - for the modules (C++ code used by the VM), doxygen is used again ; I ask every module developer to add a documentation/ folder to their module, with markdown files in it that will be used by doxygen - for the code written in the language itself (eg the standard library), we have created a mini doxygen in Python, that reads the comments above every function/variable/constant declaration and outputs either html or markdown - for anything that can't be put in code, we have a docs/ folder with markdown files, describing the project architecture, how the compiler and VM work, how to embed the language in a cpp project... - for tutorials about the language itself, we write everything in pug files and I wrote a very basic processor for it, outputting plain HTML files for the website  This results in three websites: - the documentation of the language on the ""main"" website, https://arkscript-lang.dev ; - the technical documentation (+ modules) on doxygen: https://arkscript-lang.dev/impl/ - the standard library documentation on https://arkscript-lang.dev/std/  I need to find ways to unify those website more, or at least enhance the process of updating them, but since there is one tool per website it's straightforward (for now)",0.04794372294372295,C++
12wzu36,jhhna0k,"For the language itself I have multiple tools in place: - for the modules (C++ code used by the VM), doxygen is used again ; I ask every module developer to add a documentation/ folder to their module, with markdown files in it that will be used by doxygen - for the code written in the language itself (eg the standard library), we have created a mini doxygen in Python, that reads the comments above every function/variable/constant declaration and outputs either html or markdown - for anything that can't be put in code, we have a docs/ folder with markdown files, describing the project architecture, how the compiler and VM work, how to embed the language in a cpp project... - for tutorials about the language itself, we write everything in pug files and I wrote a very basic processor for it, outputting plain HTML files for the website  This results in three websites: - the documentation of the language on the ""main"" website, https://arkscript-lang.dev ; - the technical documentation (+ modules) on doxygen: https://arkscript-lang.dev/impl/ - the standard library documentation on https://arkscript-lang.dev/std/  I need to find ways to unify those website more, or at least enhance the process of updating them, but since there is one tool per website it's straightforward (for now)",0.04794372294372295,Python
12wzu36,jhhna0k,"For the language itself I have multiple tools in place: - for the modules (C++ code used by the VM), doxygen is used again ; I ask every module developer to add a documentation/ folder to their module, with markdown files in it that will be used by doxygen - for the code written in the language itself (eg the standard library), we have created a mini doxygen in Python, that reads the comments above every function/variable/constant declaration and outputs either html or markdown - for anything that can't be put in code, we have a docs/ folder with markdown files, describing the project architecture, how the compiler and VM work, how to embed the language in a cpp project... - for tutorials about the language itself, we write everything in pug files and I wrote a very basic processor for it, outputting plain HTML files for the website  This results in three websites: - the documentation of the language on the ""main"" website, https://arkscript-lang.dev ; - the technical documentation (+ modules) on doxygen: https://arkscript-lang.dev/impl/ - the standard library documentation on https://arkscript-lang.dev/std/  I need to find ways to unify those website more, or at least enhance the process of updating them, but since there is one tool per website it's straightforward (for now)",0.04794372294372295,HTML
12wqo0h,,The way Go or Rust do composition does not appeal to me.,0.0,Go
12wqo0h,,The way Go or Rust do composition does not appeal to me.,0.0,Rust
12wqo0h,,"In Rust for example, the `ToString` trait to me, is a ""genuine"" trait: It is valid for virtually every kind of object.",0.5,Rust
12wqo0h,,"Assumption:  `Protocol<Type>` = Fixed protocol for many types (generic type, like `List<String>`)  `<Protocol>Type` = Many protocol implementations for a fixed type  To give you an example, I implement types from the command pattern of this Rust example: [https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html#approach-using-trait-objects](https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html#approach-using-trait-objects)  In my hypothetical language, types have no defining keyword like ""class"" or ""struct"".",0.07500000000000002,Rust
12wqo0h,jhh4zqh,"The fact that Rust uses its `trait`s to support existential types, in the form of `dyn Trait` is largely secondary - it's very convenient that this is possible, and generally works well, but Rust would have traits even if it didn't have `dyn Trait` at all, as they're vital to getting its version of generic functions and generic types to work.",0.00714285714285715,Rust
12wqo0h,jhh4zqh,"Since ""X is a subtype of Y"" is a relationship between types, this means that in OOP languages, interfaces must be (and therefore are) types, having the (natural) semantics of existential types; if you have a Java `Stringable` it means you have a `T` where `T` is some class that implements `Stringable`.",0.1,Java
12wqo0h,jhh4zqh,"---  The concept of traits were first introduced in Haskell, where they are called typeclasses (unrelated to the OOP concept of ""classes"") was introduced essentially in the 1989 paper [How to make ad-hoc polymorphism less ad-hoc](https://dl.acm.org/doi/pdf/10.1145/75277.75283) by Wadler and Blott.",0.02777777777777778,Haskell
12wqo0h,jhh4zqh,"Historically, there were several approaches to making this work:  - All types support `==`   - This works for `==`, but it can cause problems - in particular, `==` doesn't make that much sense for function types if you have closures, and some types shouldn't be compared (at least in the ""default"" value, like hash sets), even if it's possible   - This doesn't work great for other operators, especially user-defined ones - Not all types support `==`   - Then the types of `==` and `member` are wrong, since they both claim to work on all types   - ... so we need to find new types for these functions  Haskell, being Haskell, didn't want to just cause a runtime crash if you called a generic function with a type that didn't work.",0.031502525252525254,Haskell
12wqo0h,jhh4zqh,"This approach didn't seem great for Haskell, because it's limited (it works fine for equality, but what about comparison, hashing, conversion to string, etc., ...) and Haskell was meant to be a sort of kitchen-sink for lazy functional programming.",0.22380952380952385,Haskell
12wqo0h,jhh4zqh,"In Haskell syntax, we write this as      (==) :: Eq a => a -> a -> Bool     member :: Eq a => [a] -> a -> Bool  where you can read `Eq a =>` as ""for any `a` that implements `Eq`"".",0.5,Haskell
12wqo0h,jhh4zqh,"In Rust, the surface syntax is different, but the meaning is exactly the same:      fn eq<T: Eq>(x: T, y: T) -> bool;     fn member<T: Eq>(haystack: &[T], needle: T) -> bool;  here, we can use traits as constraints on generic types.",0.0625,Rust
12wqo0h,jhh4zqh,"The fact that they're also used for existential types in Rust is because they're already used to solve the generics problem, not really the other way around.",-0.1125,Rust
12wqo0h,jhhfxqs,"In this regard, my hypothetical language would work similiar to Rust.",0.0,Rust
12wqo0h,jhhrk6p,I also don't see how your representation of `FromRequest` is any better than the one in Rust to be honest.,0.55,Rust
12wqo0h,jhpo62j,"You *think* you can build an API like actix where   > create a FromRequest type with variants Json, Header and Path   that is 100% possible with Rust if you use an enum.",0.0,Rust
12wqo0h,jhiktlg,"* A unique argument type `FromRequest` the developer can dot into for autocompletion instead of  `web::Json`, `web::Path`, `web::Header`  (web contains 19 struct types, most of them unrelated to extraction)  It just doesn't make sense to me how such types are floating around all over Rust code bases.",0.2916666666666667,Rust
12wqo0h,jhrvbzj,But with variants I have this hook (+ 1 optional case) too: In Rust I may create a new type `Csv` in my user code and then implement the required trait(s) for it.,0.13636363636363635,Rust
12wqo0h,jhrvbzj,"Rust enum:  * fixed, can not be extended  Rust trait:  * Requires at least 1 extra type (which can implement the trait) * Extra types and the very limited traits (only valid for a certain use case) pollute the API!",-0.0035714285714285665,Rust
12wqo0h,jhizs9o,"> A unique argument type `FromRequest` the developer can dot into for autocompletion instead of `web::Json`, `web::Path`, `web::Header` (web contains 19 struct types, most of them unrelated to extraction)  Ok, that's a cool functionality to have I guess and it isn't available *now* in Rust as far as I know.",0.37083333333333335,Rust
12wqo0h,jhmh7t1,"If you say it's wrong and it's an overuse of traits, then I wonder why I see it all the time in Rust code.",-0.5,Rust
12wdh6x,jhfmzw2,Even C can produce multiple files.,0.0,C
12wdh6x,jhezlxs,Idk why but I thought of Go’s _test.go pattern and thought it’d be better to use a Regex.,0.5,Go
12wdh6x,jhi5399,"There’s a generative variant used to find files in `for` statements and as part of command-line expansion (e.g.,  	for f in /*/*/*/../../../*/*/*/../../../*/*/* 	do : ""$f"" 	done  	ls /{,usr/}bin/*sh  ), and a variant used by Bourne `case`/`in`/`esac`, POSIX `${…#…}` `${…##…}` `${…%…}` `${…%%…}`, Bash/Korn `[[…==…]]`, and Bash `${…/…}` `${…/#…}` `${…/#…}` `${…//…}` as a general-purpose text matching mechanism (e.g.,  	case ""$f"" in 	///*) f=""/${f#""${f%%[^/]*}""}"" ;; 	/*) : ;; 	*) k=""$(pwd)"" || exit ""$?""",0.25,Bash
12wdh6x,jhi5399,In Bash’s `extglob` extension we do have an example of all the basic regex operators (plus `!,0.0,Bash
12wdh6x,jhi5399,Bash `${/}` and `${//}` perform unanchored search-and-replace; anchored forms can be de-anchored by a leading or trailing `*` or `**`.,0.0,Bash
12wdh6x,jhi5399,"Ime there are some desperately-lacking things like the counting quantifiers `{n}` `{n,m}` `{n,}` `{,m}`, and the ability to use lookahead and reluctance more generally would be nice, but these are mostly sugar when you broaden options beyond a single, literal matching operation—e.g., `{n}` can be approximated in Bash by  	printf -v glob '%*s' ""$n"" '' 	glob=""$be4${glob//?/$subpattern}$aftr""  and then using `$glob` unquoted.",0.3157142857142857,Bash
12wdh6x,jhi5399,Some regex languages do support backrefs (my regex for Bash’s `!,0.0,Bash
12wdh6x,jhi5399,"I do think that filesystem globbing should be done differently than for normal globs; I think something along the lines of XPath×`find` would be my preference—if you permit arbitrary commands to be mixed in you could, for example, find all PNGs that are small enough to fit in a 32×32 square, or all files which are newer than some other file, or all C files that cause `myhdr.h` to be `#include`d.",0.009375000000000001,C
12wdh6x,jhf549j,Although I chose Python before choosing to settle on a paradigm more alike to Make,0.5,Python
12wdh6x,jhfyo09,Note also that make supports `load` for arbitrary C code; this is more reliable than the much-advertised Guile.,0.2,C
12wdh6x,jhi81f6,"While it may seem that Gradle is Java/jvm centric it is in fact not, and I've been successful using it in both C++, python and even lua projects",0.375,C++
12wdh6x,jhhegrq,"Python BEAM has a cute internal DSL for representing the DAG, but afaik it doesn't do incremental recomputation.",0.25,Python
12wdh6x,jhtvzpt,"u/rust4yy: I've been building [mandala](https://github.com/amakelov/mandala), a Python framework for (among other things) incremental computing.",-0.125,Python
12wdh6x,jhtvzpt,"One way to think of it is ""a build system for Python objects"", except the units of computation are Python functions.",0.0,Python
12wdh6x,jhtvzpt,"You might be interested in how `mandala` supports Python's built-in collections (lists, dicts, sets).",0.25,Python
12w42h6,,"Racket is...  • a programming language—a dialect of Lisp and a descendant of Scheme;  • a family of programming languages—variants of Racket, and more; or  • a set of tools—for using a family of programming languages.",0.5,Lisp
12w42h6,,"Racket is...  • a programming language—a dialect of Lisp and a descendant of Scheme;  • a family of programming languages—variants of Racket, and more; or  • a set of tools—for using a family of programming languages.",0.5,Scheme
12w42h6,,"Its innovative features have influenced the development of Clojure and Rust, many other languages.",0.2916666666666667,Clojure
12w42h6,,"Its innovative features have influenced the development of Clojure and Rust, many other languages.",0.2916666666666667,Rust
12w1eup,jhgp7m9,HTML has a sublanguage for designing forms.,0.0,HTML
12w1eup,jhdzcs7,Python is the language I know best.,1.0,Python
12w1eup,jhe1r7f,**Unix based C POSIX IO standard libraries.,0.0,C
12vr7i5,jhcnamm,"Rust uses a similar ""anti-constraint"" syntax for unsizable data: `where T: ?Sized`",0.0,Rust
12vr7i5,jhco1uy,"In D we solved that by forbidding `ref`, `in` and `out` parameters in `@safe` code from escaping.",0.5,D
12vr7i5,jhco1uy,"If ported to C#, then `void Foo<T>(in T x) {}` should take in `ref struct`s, reference types, and value types, and use the borrowing/escaping rules.",0.0,C
12u92us,jh5r828,I thought a pretty good use case for C interoperability in Vortex was to dynamically link to the awesome SDL library.,0.65,C
12u92us,jh5ryv5,:D,1.0,D
12u92us,jh5ufya,np —I've been thinking about C bindings a lot lately and it's really encouraging to see someone getting it working!,-0.024999999999999994,C
12u92us,jh7t17w,:D /s,1.0,D
12tz6f1,,*  # Preamble  I have discovered that Go programming language still has an unstable ABI.,0.0,Go
12tz6f1,,"This is clearly stated in its documentation, ""Go internal ABI specification"" located at [https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md](https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md).",0.05000000000000001,Go
12tz6f1,,>This ABI is *unstable* and will change between Go versions.,0.0,Go
12tz6f1,,"This fact surprised me a lot, because:  * A stable *(non-alpha, non-beta & greater than 0.9)* version 1.0 of Go language appeared more than 10 years ago according to their website at [https://go.dev/doc/devel/release](https://go.dev/doc/devel/release).",0.3666666666666667,Go
12tz6f1,,"For example, C language was created more than 50 years ago when internet did not exist and a lot of historical information of that past time may have been lost for various reasons.",0.0625,C
12tz6f1,jh7uyrm,I don't know Go; perhaps for some things you do need to comply with that internal ABI so that it matters more whether it is stable.,0.25,Go
12tz6f1,jh7wewb,"You mention C, which does not define an ABI.",0.0,C
12tz6f1,jh7wewb,D is an exception I can think of.,0.0,D
12tz6f1,jh95zl7,>This ABI is unstable and will change between Go versions.,0.0,Go
12tz6f1,jhhkv21,"How register sized types are passed In the C case (1) consists of things like arrays, structs etc, but also types that are smaller than register sized  In addition the language / compiler may define additional calling conventions that may be faster in certain cases.",0.10714285714285714,C
12tz6f1,jhhkv21,"Have an undefined internal ABI, external ABI is the C ABI (limiting what can be exported)  2.",0.0,C
12tz6f1,jha214q,"I was trying to write a native Go adapter for C functions, something similar to FFI in the Rust language.",0.0,Go
12tz6f1,jha214q,"I was trying to write a native Go adapter for C functions, something similar to FFI in the Rust language.",0.0,C
12tz6f1,jha214q,"I was trying to write a native Go adapter for C functions, something similar to FFI in the Rust language.",0.0,Rust
12tz6f1,jha214q,"Saying native here I mean such an adapter which uses only Go compiler, i.e.",-0.10416666666666667,Go
12tz6f1,jha214q,does not use any C compiler as in CGO.,0.0,C
12tz6f1,jhhjs4p,What do you mean “C does not define an ABI”.,-0.3125,C
12tz6f1,jhhjs4p,"While it is platform dependent (obviously), the C ABI is today what we all use when making OS calls.",0.0,C
12tz6f1,jh9vfnl,"Plus it is written in C, while the language you want to use it from isn't.",0.0,C
12tz6f1,jh9vfnl,"It's not just a question of having C compiler; many of these libraries require a whole eco-system of tools in order to build, where it's half of Linux, or a 6000MB VS download.",0.17777777777777778,C
12tz6f1,jhrmwgf,">How register sized types are passed In the C case   Why do you write ""In"" using a capital letter ""I"" ?",0.0,C
12tz6f1,jhisqhu,C is defined in terms of an Abstract Machine.,0.0,C
12tz6f1,jhisqhu,> C ABI is today what we all use when making OS calls.,0.0,C
12tz6f1,jhisqhu,"Whoever at Microsoft decided that ""Standard Call"" was how to talk to the OS and that ""C decl"" was not, clearly disagree(s|d) with you.",-0.025000000000000005,C
12tz6f1,jhisqhu,"Last time I used Windows, GCC also disagreed as I had to go out of my way to get OS interop due to ""the C ABI"" not matching the system DLLs' one.",-0.0625,C
12tz6f1,jhj75go,Why would the C ABI be defined in the standard?,0.0,C
12tz6f1,jhj75go,"Rather, the C ABI basically is what the linker and OS on the OS / arch requires the ABI to be.",0.0,C
12tz6f1,jhja67q,> X defines an ABI  C does not define an ABI.,0.0,C
12tz6f1,jhja67q,"Windows and linkers disagree with each other, _when running on Windows._  > Why would the C ABI be defined in the standard  That is precisely what OP asked about, and what D does.",0.09166666666666667,C
12tz6f1,jhja67q,"Windows and linkers disagree with each other, _when running on Windows._  > Why would the C ABI be defined in the standard  That is precisely what OP asked about, and what D does.",0.09166666666666667,D
12tz6f1,jhjba7n,D defined part of its ABI as “conforming to the C ABI”.,0.0,D
12tz6f1,jhjba7n,D defined part of its ABI as “conforming to the C ABI”.,0.0,C
12tz6f1,jhjba7n,By definition the claim “C does not have an ABI” and “D has an ABI” cannot be true if the D ABI is defined from the C ABI.,0.35,C
12tz6f1,jhjba7n,By definition the claim “C does not have an ABI” and “D has an ABI” cannot be true if the D ABI is defined from the C ABI.,0.35,D
12tz6f1,jhjduas,"D also says there should exist a ""companion C compiler"" and that the ""C ABI"" is defined by that compiler.",0.0,D
12tz6f1,jhjduas,"D also says there should exist a ""companion C compiler"" and that the ""C ABI"" is defined by that compiler.",0.0,C
12tz6f1,jhjduas,"Because Bright (the dude behind D) also wrote C and C++ compilers, which have their own ABIs.",0.3,D
12tz6f1,jhjduas,"Because Bright (the dude behind D) also wrote C and C++ compilers, which have their own ABIs.",0.3,C
12tz6f1,jhjduas,"Because Bright (the dude behind D) also wrote C and C++ compilers, which have their own ABIs.",0.3,C++
12tz6f1,jhjduas,Also you misquote the spec; the real quote is   > The C ABI referred to in this specification means the C Application Binary Interface of the target system.,0.2,C
12tz6f1,jhjduas,"C and D code should be freely linkable together, in particular, D code shall have access to the entire C ABI runtime library.",0.18888888888888888,C
12tz6f1,jhjduas,"C and D code should be freely linkable together, in particular, D code shall have access to the entire C ABI runtime library.",0.18888888888888888,D
12tz6f1,jhjduas,"Implying the ""C ABI"" is variable, and in particular what is relevant is the one used by the compiler's selected C runtime library, which D compilers have to give access to.",0.2833333333333333,C
12tz6f1,jhjduas,"Implying the ""C ABI"" is variable, and in particular what is relevant is the one used by the compiler's selected C runtime library, which D compilers have to give access to.",0.2833333333333333,D
12tz6f1,jhefrd8,Some libraries built in C language use conditional preprocessing in header files and some structs have different contents on different platforms.,0.0,C
12tz6f1,jhefrd8,Now in Go language it is impossible to invent something internally because of its unstable internal ABI.,-0.2222222222222222,Go
12tz6f1,jhefrd8,"I began studying Rust language because it provides a very wide compatibility layer, the FFI.",-0.13,Rust
12tz6f1,jhefrd8,"I saw a list of languages supported by Rust's FFI and thought that this language is future, maybe it will even be able to partially replace C code in some projects in future.",0.1,Rust
12tz6f1,jhefrd8,"I saw a list of languages supported by Rust's FFI and thought that this language is future, maybe it will even be able to partially replace C code in some projects in future.",0.1,C
12tz6f1,jhf1rr1,"Yeah, back in C, I used to use conditional preprocessing for includes of implementations and perhaps opaque pointers for polymorphism of OS specific structs, but I've never seen conditional preprocessing of fields; that seems quite odd.",-0.05555555555555555,C
12tjcbg,jh4y4vj,"Apparently actual WASM source code uses a similar syntax to Lisp (examples are surprisingly elusive to find; every site starts with examples that are not Wasm):      (module       (import ""env"" ""memory"" (memory 1))       (import ""env"" ""log"" (func $log (param i32 i32)))        (data (i32.const 0) ""Hello, World!"")",-0.05937500000000001,Lisp
12tjcbg,jh97v90,"It's short but shows a C example side-by-side with  textual WASM ('WAT') and binary WASM, all clearly labeled.",0.05000000000000001,C
12tgsip,,"In my systems language and also in C, that needs to be done explicitly (C needs extensions to enable label pointers).",0.0,C
12tgsip,,I also did a C port [here](https://github.com/sal55/langs/blob/master/temp/sw.c).,0.0,C
12tgsip,,"The results with `gcc-O0` were 3.6 seconds, and with `gcc-O3` were 2.1 seconds (but results vary; using C transpiled from my language, I got 3.3 seconds and 4.2 seconds respectively - yeah, it got slower with `-O3`!).",0.0,C
12tgsip,,**eta:** I notice my C port doesn't have a `default` branch corresponding to my `else`.,0.0,C
12tgsip,jh6ir62,"This is also supported by the ""switch"" control structure of Pascal called ""case"".",0.0,Pascal
12tgsip,jh6ir62,"using ""[ ]"" before the identifier, like Java and D, right ?",0.2857142857142857,Java
12tgsip,jh6ir62,"using ""[ ]"" before the identifier, like Java and D, right ?",0.2857142857142857,D
12tgsip,jhkfkme,"I tried transpiling to C, but I don't trust that translation.",0.0,C
12tgsip,jhkfkme,"Next I tried writing a [custom C program](https://github.com/sal55/langs/blob/master/temp/fibvm.c) just for the VM execute function; mostly this was a framework machine-generated from my interpreter, with the handlers necessary filled in manually.",0.225,C
12tgsip,jhinepq,Forth newsgroup discussed this long time ago.,-0.05,Forth
12tgsip,jh98kpl,"Python has recently acquired `match` I think it is, where you compare one thing against a range of possibilities.",0.0,Python
12tgsip,jh6rx3q,"using ""\[ \]"" before the identifier, like Java and D, right ?",0.2857142857142857,Java
12tgsip,jh6rx3q,"using ""\[ \]"" before the identifier, like Java and D, right ?",0.2857142857142857,D
12tgsip,jh6rx3q,"According to [dlang.org](https://dlang.org), D declarations go right to left:      int*[]*[3] d; // array of 3 pointers to dynamic arrays of pointers to ints  So a welcome improvement on C where types can be specified in up to 3 different places, eg.",0.21714285714285717,D
12tgsip,jh6rx3q,"According to [dlang.org](https://dlang.org), D declarations go right to left:      int*[]*[3] d; // array of 3 pointers to dynamic arrays of pointers to ints  So a welcome improvement on C where types can be specified in up to 3 different places, eg.",0.21714285714285717,C
12tdn0d,,"The other day I was wondering: _""If my language supports its code being called from C, is there a way I can namespace the symbols my language exports to C in a convenient way?",-0.125,C
12tdn0d,,"""_  Of course, C doesn't have true namespaces in the same way that C++ or many other languages do, but nested named scopes to place functions (and global variables) in can be emulated slightly awkwardly using a struct of function pointers.",0.020833333333333332,C
12tdn0d,,"""_  Of course, C doesn't have true namespaces in the same way that C++ or many other languages do, but nested named scopes to place functions (and global variables) in can be emulated slightly awkwardly using a struct of function pointers.",0.020833333333333332,C++
12tdn0d,,"Take the following sample code in an imaginary C-like language that doesn't exist, declaring two prototypes in a given module's namespace:  ``` module my_module {     int transmogrify(         FILE* data     );      float butter_whicken(         float flams_per_neek,         bool growl     ); }; ```  and a possible C header and source file that get exported for them (NOTE that I've only provided C implementations of the functions to get a compiling example working, in practice the implementation functions would only be prototyped in C but actually defined in the exporting language (I guess that might make them not able to be `static` too, but I'm not completely clear on that...):  ``` // library Header file  #include <stdbool.h> #include <stdio.h> #include <stdlib.h>  struct my_module {     int (*transmogrify)(         FILE* data     );     float (*butter_whicken)(         float flams_per_neek,         bool growl     ); };  extern const struct     my_module my_module;  // library C file  static int transmogrify__implementation(     FILE* data ) {     return 0; // dummy value }  static float butter_whicken__implementation(     float flams_per_neek,     bool growl ) {     return 3.452f; // dummy value }  const struct my_module my_module = {     transmogrify__implementation,     butter_whicken__implementation, };  // program C file  int main(void) {     return my_module.butter_whicken(         my_module.transmogrify(stdout),         false     ); } ```  I can see some upsides and downsides to this approach...  #### Upsides: - `my_module.function_name()` is syntax commonly used for access member functions and module members in other languages, though not in C - Use of this form of scoping is arguably more readable than the more common `my_module_function_name()` in C  #### Downsides: - Two symbols per identifier are introduced.",0.06718749999999998,C
12tdn0d,,"- We don't get ""namespace merging"" across multiple source/header files as happens in C++.",0.0,C++
12tdn0d,,"I'm aware this technique extends beyond the realm of C bindings to other languages, but I felt as to its slight laboriousness in setting up, making use of it in a scenario where the ""export header"" is machine-written could be a good opportunity to make use of it for little effort on the user's side.",0.09416666666666666,C
12tdn0d,jh2q8jq,You could also follow the C convention and allow specifying a prefix for all exported symbols.,0.0,C
12tdn0d,jh2q8jq,This follows the $(project)_$(function_name) naming convention that already exists in many C codebases and should make LTO much happier.,0.35,C
12tdn0d,jh2d8yt,"It can be cool if you can automate it for consumption in C.   However if I were to use the C API to bind to other languages, then my code would look funky.",0.11249999999999999,C
12tdn0d,jh2izb1,Almost all of them requires either:  **1 To transpile to or generate a C full source equivalent of your P.L.,0.35,C
12tdn0d,jh2izb1,"**  **2 To compile and generate ""obj"" files compatible with a C Compiler, plus a C alike header file.",0.0,C
12tdn0d,jh2izb1,"**  In both cases, you need functions to follow a C identifier syntax.",0.0,C
12tdn0d,jh2izb1,"Let's have this source code example:             module lists      {         struct List { ... }                 int add (List* L, void* Item) { ... }      }  (1) One is to ""transpile"" your code as a C, using the namespace ID or a abbreviation of the module / namespace ID:  Like:      // lists.h       struct lists_List { ... };          int lists_add (List* L, void* Item) ;}           // lists.c       int lists_add (List* L, void* Item) { ... }      And generate the full source code for both files, or generate an ""object file"" and a C header file.",0.35,C
12tdn0d,jh2izb1,"So, another C program may access it like:      // anypprogram.c     #include ""list.h""     ...     struct lists_List* L =        malloc(sizeof(struct lists_list));     int* I =        malloc(sizeof(int));     *i = 1;     lists_add(L, i));     ...",0.0,C
12tdn0d,jh2izb1,"And, use it in your functions as a parameter:      // modules.h       struct module     {       int ModuleKey;       char ModuleName[128];     } ;           // lists.h     #include ""modules.h""           struct lists_List { ... };          int lists_add       (struct Module* M, List* L, void* Item) { ... }           // lists.c       int lists_add       (struct Module* M, List* L, void* Item) { ... }  Again, you will have to follow C function syntax, although you can add an additional metadata thru your module pointer.",0.0,C
12tdn0d,jh2izb1,"(3) A interface alike based version, like the one you posted:      // modules.h       struct Module     {       int ModuleKey;       char ModuleName[128];     } ;           // lists.h     #include ""modules.h""           struct lists_List { ... };          typedef        int (* lists_add_ftor )         (List* L, void* Item) ;          typedef       struct lists_Module       {          // shared metadata for any module:          struct Module Parent;                   lists_add_ftor add;                 // other functions functor       } ;           // singleton var for each module:     extern struct lists_Module*;           int lists_add       (List* L, void* Item) { ... }          // lists.c        // singleton var for each module:     extern struct lists_Module*;           int lists_add       (struct Module* M, List* L, void* Item) { ... }  Again, you need to follow the C syntax function.",-0.125,C
12tdn0d,jh2izb1,**Do you have or are planning to have a C source generation process ?,0.0,C
12tdn0d,jh3e9a1,"I was just thinking that if I'm going to generate some C header code anyway, I could have some fun and make it more ""elegant"", but this may be foolhardy if it harms optimisation.",0.43333333333333335,C
12tdn0d,jh2fkzj,">However if I were to use the C API to bind to other languages, then my code would look funky.",-0.125,C
12tdn0d,jh36gma,"On #1, it's also possible to use `$` in an identifier, which is accepted by GCC and MSVC, but is quite uncommon in regular C code, so you could use it to easily identify a ""module"", unlike using `_` which is common in variable names.",0.18666666666666668,C
12tdn0d,jh2p6zn,> Do you have or are planning to have a C source generation process ?,0.0,C
12tdn0d,jh2p6zn,"Sort of, only for functions exported from my language to be callable from C. I'm not planning to transpile to C currently, so this will be an extra feature that generates headers only.",0.0,C
12tdn0d,jh2p6zn,"The idea I have is that one may optionally declare functions in my language that are to be exported to C —such functions will have certain restrictions placed upon them so this can be done in a sane and well-defined way (a bit like how `extern ""C""` functions in C++ may not directly reference class objects in their signature, these need to be masked by an opaque pointer because C doesn't know what the hell's going on with thems fancy objects!).",0.07589285714285714,C
12tdn0d,jh2p6zn,"The idea I have is that one may optionally declare functions in my language that are to be exported to C —such functions will have certain restrictions placed upon them so this can be done in a sane and well-defined way (a bit like how `extern ""C""` functions in C++ may not directly reference class objects in their signature, these need to be masked by an opaque pointer because C doesn't know what the hell's going on with thems fancy objects!).",0.07589285714285714,C++
12tdn0d,jh2p6zn,"I intend to have a facility where on compiling said file (or when you run a certain command or something), file gets compiled to binary, and you also get a C header file with C code for the exported functions.",0.21428571428571427,C
12tdn0d,jh2p6zn,That header can then be used by a C compiler to link to the produced binary.,0.0,C
12tdn0d,jh2gv1x,"A C compiler may happily inline everything, but if I try to make a binding for some other language, the other compiler may just see a struct of pointer.",0.18333333333333335,C
12tdn0d,jh2gv1x,"I turned on my brain, and it may just need some wrappers if whatever I'm doing doesn't like C structs.",0.0,C
12tdn0d,jh2q6z5,"Then, you are going to have an optional feature in your compiler alike framework that generates a ""C"" header file and a ""binary file"" / ""object file"" pair.",0.0,C
12tdn0d,jh2q6z5,"Whatever you want to do, you need to generate an C equivalent that should follow C identifiers syntax, whether you mix the namespace / module ID with the function or type identifier, or not ...",0.0,C
12tdn0d,jh2q6z5,"I suggest, implement a fully ""your cool programming language"" transpiler to C first, and later turned into a full source code to binary code, where that binary code may be a single executable or pairs of header and binary ""intermediate / object"" files ...",0.1757142857142857,C
12tdn0d,jh3dwxk,">I suggest, implement a fully ""your cool programming language"" transpiler to C first,  It's a nice thought, and it would work, though currently I am planning to target libgccjit and LLVM IRbuilder",0.3,C
12t2opo,,Vortex (previously Ripple) now has the ability to interop with C or C++ (extern C) libraries!,-0.20833333333333331,C
12t2opo,,Vortex (previously Ripple) now has the ability to interop with C or C++ (extern C) libraries!,-0.20833333333333331,C++
12szecp,jh4eeim,* Go recently got generics.,0.0,Go
12szecp,jh4eeim,C++ is a monstrum.,0.0,C++
12szecp,jh932rm,"BTW, C++ was designed by a committee.",0.0,C++
12szecp,jh4gzb8,"See the reoccurring debates on e. g. not doing generics with `<>` and the usual response of ""but C++ did it so it can't be wrong!!!"".",-0.61328125,C++
12szecp,jh5dnoi,>  C++ is a monstrum.,0.0,C++
12srawa,,So here's my plans:  I adapted the garbage collector at  [Writing a Simple Garbage Collector in C (maplant.com)](http://maplant.com/gc.html)  to add extremely primitive simple register scanning.,-0.041666666666666664,C
12srawa,,Imagine being capable of running processes similar to BEAM and Go but with JIT.,0.1,Go
12srawa,jh0hsr5,Maybe you could look into how some Scheme and ML implementations use continuations to implement threads.,0.0,Scheme
12srawa,jgzylsz,In Java that's LockSupport.park()  I still think my scheme is efficient and useful because it doesn't require any additional conditions and takes advantage of the existing loop that was running anyway.,0.3,Java
12srawa,jh2d9rb,"Unlike Java's LockSupport.park, or Erlang's reduction yield check and Go's stack preemtible growth check (which I don't know if it still uses) and wasmtime's fuel implementation, my solution doesn't require any cooperation at descheduling time that the process wouldn't have already done.",0.0,Java
12srawa,jh2d9rb,"Unlike Java's LockSupport.park, or Erlang's reduction yield check and Go's stack preemtible growth check (which I don't know if it still uses) and wasmtime's fuel implementation, my solution doesn't require any cooperation at descheduling time that the process wouldn't have already done.",0.0,Erlang
12srawa,jh2d9rb,"Unlike Java's LockSupport.park, or Erlang's reduction yield check and Go's stack preemtible growth check (which I don't know if it still uses) and wasmtime's fuel implementation, my solution doesn't require any cooperation at descheduling time that the process wouldn't have already done.",0.0,Go
12srawa,jh2kk9f,"That is why Java's Loom is so awesome, because the IO doesn't block a Loom lightweight thread scheduled kernel thread   I'm not sure if they reschedule IO calls to a IO thread pool or something.",0.375,Java
12sb8ig,,&#x200B;  EDIT: right now my compiler transpiles to C++ and I have a defer macro that I use to translate the defer stmt.,0.2857142857142857,C++
12sb8ig,,This relies on C++ RAII but I want to implement it without dependening on it.,0.0,C++
12sb8ig,jgxt9pw,"There is the Go style defer, which calls the defered code at the end of the function, or a scope based defer, which calls the defered code at the end of a scope.",0.0,Go
12sb8ig,jgxt9pw,"This might be totally okay for your language (my language leans more on the C side of things, so having some hidden allocation for the defer would be a huge no no).",0.30833333333333335,C
12sb8ig,jgzmkti,"&#x200B;  &#x200B;  ¹) IIUC, defer as used in Go, which is what pops up when googling ""defer statement"", is like (`𝐝𝐞𝐟𝐞𝐫 P(x) ; Q)` becoming `(𝐩𝐫𝐨𝐜 Pdeferred: P(x) ; Q ; Pdeferred)` , iow creating a parameterless closure such that the argument x is evaluated at the beginning, but the closure and thereby procedure P is only executed at the end.",0.15,Go
12sb8ig,jgxu42j,"Mine, too, is more to the C side of things, tho I think a new feature would break this (defer on error).",0.3181818181818182,C
12sb8ig,jh0w6mf,"Go is too weird, and I won't be implementing it that way.",-0.5,Go
12sb8ig,jh0fmcz,It basically behaves like C++ destructors.,0.0,C++
12sb8ig,jh0fmcz,Go defer statement is a weird approach as is not scope based but function scope based.,-0.5,Go
12sb8ig,jh9tsr4,Go?,0.0,Go
12sb8ig,jh1zq5d,I cant remember if C++ optimized these stuff.,0.0,C++
12sb8ig,jhalcik,I transpile my language to C++ and use said mechanism,0.0,C++
12rmkjc,,"My goal is not to replace C, Rust or Go.",0.0,C
12rmkjc,,"My goal is not to replace C, Rust or Go.",0.0,Rust
12rmkjc,,"My goal is not to replace C, Rust or Go.",0.0,Go
12rmkjc,,"My plan is to do the front end in Go, and the backend in LLVM and if I figure out how, re-use Pony's runtime.",0.0,Go
12rmkjc,jgv63y4,Maybe you're planning on using a zero value like in Go?,0.0,Go
12rmkjc,jgzcddk,"Tcl is often written off, but I think its got some great ideas to this end.",0.8,Tcl
12rmkjc,jgwdm0c,"If anything this more closely resembles Smalltalk, and the way blocks are parallel by default means that useful functions look a little like Prolog.",0.153125,Prolog
12rmkjc,jgwdm0c,"Lisp has code-as-data, but Smalltalk and Prolog (and, it seems, Yz) have *data-as-code*, with data being implicitly structured by the procedures that create or access it",0.0,Lisp
12rmkjc,jgwdm0c,"Lisp has code-as-data, but Smalltalk and Prolog (and, it seems, Yz) have *data-as-code*, with data being implicitly structured by the procedures that create or access it",0.0,Prolog
12rmkjc,jidv9wq,"Back to `public static final please get out of the way greet = ""hi""` programming I started to wish of a PL where I can just remove stuff until there's nothing but blocks of code, but not to the extent of Lisp, but rather as ""familiar"" as JSON and remembered the idea of control structures  as functions and started to learn how many programming languages do things.",0.22916666666666666,Lisp
12rmkjc,jgxmvw5,"{     ""true block""  } {    ""false block"" } ```  I learned to program in Lisp using recursion so definitely there must be something there, but if I have to be honest I think there more of JSON than Lisp.",0.20999999999999996,Lisp
12rm0s6,,"Like Object in Java, GObject (  [GObject - Wikipedia](https://en.wikipedia.org/wiki/GObject)  ) these represent a global sum type that everyone derives from.",0.0,Java
12rm0s6,jgybdp2,"So, if you have an AST like:      enum ItemType     {         itInteger,         itChar,         itFloat,         itString,     } ;      union VariantItem     {         int I;         char C;         float F;         chat* S[256];     } ;          struct ASTItem     {       union VariantItem;              enum ItemType;       struct ASTItem* Parent;             // other fields      } ;        And replace it with:      enum ItemType     {         itInteger,         itChar,         itFloat,         itString,     } ;           struct ASTItem     {       // void* VariantItem;       nullptr_t VariantItem;            enum ItemType;       struct ASTItem* Parent;             // other fields       } ;      This way, you can handle different object / data types with different size.",-0.0625,C
12rm0s6,jgvx52o,I want my Ruby code to be capable of interacting with my Rust code.,0.2,Ruby
12rm0s6,jgvx52o,I want my Ruby code to be capable of interacting with my Rust code.,0.2,Rust
12rm0s6,jgvx52o,Or my Erlang code with my Java code.,0.0,Erlang
12rm0s6,jgvx52o,Or my Erlang code with my Java code.,0.0,Java
12rm0s6,jgvv7cy,"In Java if I want to inject a dependency to an interface, I can do that, but I cannot change the interface because that would break all original implementations of the interface.",0.375,Java
12rm0s6,jgxmxfj,>I want my Ruby code to be capable of interacting with my Rust code.,0.2,Ruby
12rm0s6,jgxmxfj,>I want my Ruby code to be capable of interacting with my Rust code.,0.2,Rust
12rm0s6,jgxmxfj,Or my Erlang code with my Java code.,0.0,Erlang
12rm0s6,jgxmxfj,Or my Erlang code with my Java code.,0.0,Java
12rm0s6,jgxmxfj,"And yes, one of the ways it currently achieves compatibility in practice is via the C FFI of implementations.",0.0,C
12qyhva,jgxg90x,This also includes some live-coding in Haskell towards the end.,0.0,Haskell
12qyhva,jgt7v4r,Common Lisp has mechanisms for :before :after and :around methods.,-0.3,Lisp
12qn3na,,"Then I wondered how my language deals with that example, since it also uses postfix `^`, and it's like this:      i := x^[a, b]^[c]  One difference (an important one for me), is that successive indices can go inside one pair of `[ ]` (typing `][` instead of `,` is horrible; thank you C for popularising that).",-0.3,C
12qn3na,jgqy8vh,In any case am I understanding correctly that `int i = (*(*x[a][b]))[c];` is the C code for this?,-0.75,C
12qn3na,jgr0e4e,"Postfixed ""^"" is used in Pascal:       x^ = 5;   as C's prefixed ""*"":      *x = 5;  Just a matter of taste, both work.",0.0,Pascal
12qn3na,jgr0e4e,"Postfixed ""^"" is used in Pascal:       x^ = 5;   as C's prefixed ""*"":      *x = 5;  Just a matter of taste, both work.",0.0,C
12qn3na,jgr0e4e,"You are also using Pascal's array indexing like:      a[5, 3] = 2;  Instead of C's array indexing like:       a[5][3] = 2;  Also, both work.",0.0,Pascal
12qn3na,jgr0e4e,"You are also using Pascal's array indexing like:      a[5, 3] = 2;  Instead of C's array indexing like:       a[5][3] = 2;  Also, both work.",0.0,C
12qn3na,jgr0e4e,Since I have both a Pascal syntax alike P.L.,0.0,Pascal
12qn3na,jgr0e4e,"concept project, and a C syntax alike P.L.",0.0,C
12qn3na,jgr0e4e,"Let's start with how are declared, Pascal style first:      type        // ""array of int (s)""       TypeA = array [0..5] of integers;           ...     var A: TypeA;     A[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""an array of int (s)""       TypeB = ^TypeA;           ...     var B: TypeB;     B^[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC = ^TypeB;           ...     var C: TypeC;     C^^[5-1] := 3;     ...       type        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD = TypeC[0..3];           ...     var D: TypeD;     D[3-1]^^[5-1] := 3;     ...           type        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeE = TypeD[0..9];           ...     var E: TypeE;     E[9-1][3-1]^^[5-1] := 3;     ...           type        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF = ^TypeE;           ...     var F: TypeF;     F^[9-1][3-1]^^[5-1] := 3;     ...       And it's C style counterpart:      typedef        // ""array of ints""       int TypeA[5];          ...     TypeA A;     A[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""an array of int (s)""       TypeA *TypeB;          ...     TypeB B;     B^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeB *TypeC;          ...     TypeC C;     C^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC TypeD[3];          ...     TypeD D;     D^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD TypeE[0..9];          ...     TypeE E;     E[9-1]^^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF *TypeE;          ...     TypeF F;     F^[9-1]^^[5-1] = 3;     ...       **Other P.L.",0.0625,Pascal
12qn3na,jgr0e4e,"Let's start with how are declared, Pascal style first:      type        // ""array of int (s)""       TypeA = array [0..5] of integers;           ...     var A: TypeA;     A[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""an array of int (s)""       TypeB = ^TypeA;           ...     var B: TypeB;     B^[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC = ^TypeB;           ...     var C: TypeC;     C^^[5-1] := 3;     ...       type        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD = TypeC[0..3];           ...     var D: TypeD;     D[3-1]^^[5-1] := 3;     ...           type        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeE = TypeD[0..9];           ...     var E: TypeE;     E[9-1][3-1]^^[5-1] := 3;     ...           type        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF = ^TypeE;           ...     var F: TypeF;     F^[9-1][3-1]^^[5-1] := 3;     ...       And it's C style counterpart:      typedef        // ""array of ints""       int TypeA[5];          ...     TypeA A;     A[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""an array of int (s)""       TypeA *TypeB;          ...     TypeB B;     B^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeB *TypeC;          ...     TypeC C;     C^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC TypeD[3];          ...     TypeD D;     D^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD TypeE[0..9];          ...     TypeE E;     E[9-1]^^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF *TypeE;          ...     TypeF F;     F^[9-1]^^[5-1] = 3;     ...       **Other P.L.",0.0625,C
12qn3na,jgr0e4e,"Let's start with how are declared, Pascal style first:      type        // ""array of int (s)""       TypeA = array [0..5] of integers;           ...     var A: TypeA;     A[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""an array of int (s)""       TypeB = ^TypeA;           ...     var B: TypeB;     B^[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC = ^TypeB;           ...     var C: TypeC;     C^^[5-1] := 3;     ...       type        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD = TypeC[0..3];           ...     var D: TypeD;     D[3-1]^^[5-1] := 3;     ...           type        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeE = TypeD[0..9];           ...     var E: TypeE;     E[9-1][3-1]^^[5-1] := 3;     ...           type        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF = ^TypeE;           ...     var F: TypeF;     F^[9-1][3-1]^^[5-1] := 3;     ...       And it's C style counterpart:      typedef        // ""array of ints""       int TypeA[5];          ...     TypeA A;     A[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""an array of int (s)""       TypeA *TypeB;          ...     TypeB B;     B^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeB *TypeC;          ...     TypeC C;     C^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC TypeD[3];          ...     TypeD D;     D^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD TypeE[0..9];          ...     TypeE E;     E[9-1]^^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF *TypeE;          ...     TypeF F;     F^[9-1]^^[5-1] = 3;     ...       **Other P.L.",0.0625,D
12qn3na,jgr0e4e,"(s)**  Ada with Pascal alike syntax uses ""pointer"" at declaration, but ""^"" as an operator in expressions.",0.0,Ada
12qn3na,jgr0e4e,"(s)**  Ada with Pascal alike syntax uses ""pointer"" at declaration, but ""^"" as an operator in expressions.",0.0,Pascal
12qn3na,jgr0e4e,"type       PByte = pointer to Byte;     ...     var P: PByte;     ...     P^ := 5;     ...       D and Java, both C alike syntax, uses the same ""*"" and ""[ ]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,D
12qn3na,jgr0e4e,"type       PByte = pointer to Byte;     ...     var P: PByte;     ...     P^ := 5;     ...       D and Java, both C alike syntax, uses the same ""*"" and ""[ ]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,Java
12qn3na,jgr0e4e,"type       PByte = pointer to Byte;     ...     var P: PByte;     ...     P^ := 5;     ...       D and Java, both C alike syntax, uses the same ""*"" and ""[ ]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,C
12qn3na,jgsh6ny,"`*x` is wildly known as how dererencing is done in C, so there is scope for confusion.",0.1,C
12qn3na,jgsh6ny,"And `<<` is a prefix operator, which suffers from the same problems of C's `*` that I related elsewhere.",-0.19999999999999998,C
12qn3na,jgrt2zm,"I reject this; we can have a special `NEW` singleton object and overload the normal `[]` operator with its type, so we can write `a[NEW]=val`  * Another singleton (actually, probably not) object is `END`, which has an overloaded `-` operator (and presumably `+` as well), so we can do `a[END-1]` without running into all the disasters of the Python approach.",0.16087662337662337,Python
12qn3na,jgweapp,"For what is worth, even Dennis Ritchie acknowledged that the dereferencing syntax in C is less than ideal (and that a postfix operator would've been better):  &#x200B;  >An accident of syntax contributed to the perceived complexity of the language.",0.38333333333333336,C
12qn3na,jgweapp,"The indirection operator, spelled \* in C, is syntactically a unary prefix operator, just as in BCPL and B.",0.0,C
12qn3na,jgweapp,Declarations in C must be read in an \`inside-out' style that many find difficult to grasp \[Anderson 80\].,0.0,C
12qn3na,jgtitoa,"See [the clockwise spiral rule](https://c-faq.com/decl/spiral.anderson.html) for C which is *terrible* both for the parser and for the programmer - you end up with things like `void (f(void (*)(int, int), void (*)(int, int)))(int, int);`^\[0] which is a perfectly legal declaration C for a convoluted, yet plausible, situation.",0.04,C
12qn3na,jgtitoa,"The above example in C turns into `FUNCT f(@FUNCT(INT4, INT4): VOID, @FUNCT(INT4, INT4): VOID): FUNCT(INT4, INT4): VOID;`^\[1], which, although wordier, is *a lot* more straightforward.",0.2916666666666667,C
12qn3na,jgtitoa,"Your example, with the array, would, I believe, turn into `VAR i: INT4 = x[a,b]@@[c];` where `x` is declared as `VAR x: [A,B]@@[C]INT4;` and `A`, `B`, and `C` are the highest values `a`, `b`, and `c`, respectively, can be.",-0.375,C
12qn3na,jgtitoa,Even solutions other than C make (IMO) mistakes such as putting the array type *after* the primary type (as in `char[]`) which makes it *somewhat* easier to parse and *somewhat* more intuitive but... not wholly.,0.19375,C
12qn3na,jgtitoa,"The other neat property of this is that a type is *always* distinguishable from anything else - the `@` (pointer) sign, for example, is prefixed in a type and postfixed in actual usage, as is every other part of a type - meaning that type casts have a much simpler syntax than in C. To cast some pointer to your array type above is as simple as `[A,B]@@[C]INT4(y)` - a bit confusing compared to other syntaxes, but a lot more useful in terms of i.e.",0.0325,C
12qn3na,jgtitoa,"In C, I have to type something like `((struct object *)thing)->data`, a pattern which only gets more unintuitive as the data becomes more complex.",0.19,C
12qn3na,jgtitoa,"This is a lot like Go's solution, except Go didn't quite do it right - there are still cases where you have to parenthesize the type, which actually makes things worse (i.e., something like `(type)(data)`).",-0.038095238095238106,Go
12qn3na,jgtitoa,"In C, function pointers are automatically dereferenced: `void (*f)(int x);` can be called with`f(1)`.",0.0,C
12qn3na,jgtitoa,because this is where C turns into gibberish.,0.0,C
12qn3na,jgsiup6,"I like Scopes syntax:  - `@ reference` is dereferencing - `@reference` is also allowed (prefix instead of function call, can avoid parentheses) - `@ array index` is array access - `array @ index` as a binary operator, infix notation is allowed as well - `multiarray @ index1 @ index2 @ index3` multiarray access still more concise without the need of a special syntax - `@ multiarray index1 index2 index3` is the same as a variadic macro - `(@ (@ @value index1 index2)) @ index3` same as C `(*((*value)[index1][index2]))[index3]`",0.19142857142857142,C
12qn3na,jgybgmf,"In my lang, you can ""index"" with several ""selectors"":  ```  let city = [name = ""Miami"", ""Medellin""; state = ""FL"", ""Antioquia""]  let first = city # 0 let first = city # [true, false] let first = city # :first let first = city # [name = ""Miami""] let first = city?where name = ""Miami""  let reversed = city # 1, 0 let reversed = city # :last, :first  let all = city # [true, true] ```  Internally `#` is an operator that could run the equivalent of Rust `[..].iter().find(..)`",0.17142857142857143,Rust
12qn3na,jgrgvrl,"\[`*` or `^` deref ops\]  Actually, C's `*` deref op works very poorly.",-0.26,C
12qn3na,jgrgvrl,"And for pointer-to-function, it would need `(*P)()`, except C allows `P()` without the deref.",0.0,C
12qn3na,jgrgvrl,"\[ Typing `[i,j] or [i][j]`\]  The first form is definitely sweeter, but C can't use that `[i,j]` because it decided to have a `comma operator`, so that `A[i,j]` means `i; A[j]`.",0.125,C
12qn3na,jgrgvrl,">D and Java, both C alike syntax, uses the same ""\*"" and ""\[ \]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,D
12qn3na,jgrgvrl,">D and Java, both C alike syntax, uses the same ""\*"" and ""\[ \]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,Java
12qn3na,jgrgvrl,">D and Java, both C alike syntax, uses the same ""\*"" and ""\[ \]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,C
12qn3na,jgrgvrl,I think it is well known that C is a basketcase in this area.,0.0,C
12qn3na,jgv0ch9,C is much more chaotic.,0.5,C
12qn3na,jgv0ch9,"Given the simpler type `pointer to array of int`, which I'd declare as `ref[]int P` and C as `int (*P)[]`, then you access the element by doing a deref first followed by the indexing:      P^[i]            # Mine, using ^ to make things transparent     (*P)[i]          # C  However, in C deref and index operators are completely interchangeable; you can do the index first then deref:      *(P[i])           # C, usually written as *P[i]  This is mind-boggling: given any chain of index and deref ops, C can mix and match them, and it is still valid C, except that only one will be correct.",0.14166666666666666,C
12qn3na,jgv0ch9,"Given the C solution to the type in the OP:      i = (*(*x)[a][b])[c];  You change any `*` to `[]` or vice versa, and it still compiles, so long as you have 5 in all.",-0.4,C
12qn3na,jgv0ch9,"It's not bothered with parentheses either, for example, these are both valid, as are the other 29 combinations:      i = *****x;     i = x[a][b][c][d][e];  Have I mentioned that C was a basketcase?",-0.125,C
12qn3na,jgrgy7z,There are tools to translate Odin to C?,0.0,C
12qn3na,jgsngdh,"**  In Pascal, ( yes the later versions of Pascal have pointers ), C ""&"" PTR address operator is ""@"", which is not used for anything else, as well as for the PTR contents""^"" operator.",0.0,Pascal
12qn3na,jgsngdh,"**  In Pascal, ( yes the later versions of Pascal have pointers ), C ""&"" PTR address operator is ""@"", which is not used for anything else, as well as for the PTR contents""^"" operator.",0.0,C
12qn3na,jgsngdh,"So is C ""*' PTR contents, and the equivalent Pascal is ""^"".",0.0,C
12qn3na,jgsngdh,"So is C ""*' PTR contents, and the equivalent Pascal is ""^"".",0.0,Pascal
12qn3na,jgsngdh,"I never liked the C / C++ ""array same as pointers"".",-0.15,C
12qn3na,jgsngdh,"I never liked the C / C++ ""array same as pointers"".",-0.15,C++
12qn3na,jgsngdh,"In Pascal arrays to pointers always use the PTR address operator for arrays, unlike C ""PTR address not necessary"".",0.0,Pascal
12qn3na,jgsngdh,"In Pascal arrays to pointers always use the PTR address operator for arrays, unlike C ""PTR address not necessary"".",0.0,C
12qn3na,jgsngdh,"For a procedural, C alike, P.L., I was considering a required  prefixed ""&&"" for global functors instead of the optional prefixed ""&"".",0.0,C
12qn3na,jgsngdh,"So a procedural example would be:       int add (int a, int b) { ... }      int subs (int a, int b) { ... }      int mul (int a, int b) { ... }           TypeDef          int (int a, int b) ** intfunctor;          ...     intfunctor f = nullptr;          // required ""&&"" instead of optional ""&"",     // for functors and required ""()""     f = &&add();          int c = (**f)(x, y);     ...          // or also,     // infix alternative usage of ""->"",     // instead of prefixed *, for functors     int c = f->(x, y);     ...  For an O.O., C++ alike, P.L., I was considering a prefixed ""&&&"" for C++ alike methods.",-0.75,C++
12qn3na,jpjk9wb,">In Pascal, ( yes the later versions of Pascal have pointers ),  Pascal, being a language derived from Wirth's earlier work with the language Algol W, always had pointers.",0.0,Pascal
12qn3na,jgwq6pd,"As C supports these in identifiers, it can be used in many creative ways, like for example a *very* pretty version of Bournegol.",0.44166666666666665,C
12qn3na,jgyypls,"Mine does not, but XCompose covers most of my use cases, and I set up my own [Compose, `g`, `l`] for `λ`, etc..  > Implied multiplication  The language I'm working on is in the Haskell family where whitespace is the application operator.",0.55,Haskell
12qn3na,jgwup3t,"> we're talking about mine, where multiplication is far more common than logic symbols  And in the code I write, it is far more common to port code from formal logic as-is than to roll my own, and to rely on specifications and papers which are not written by North American English-speaking C programmers.",0.15000000000000002,C
12qk13g,jgqcxz5,So the day might not be far where we can assume continuations or fibers on all platforms where Scala is running.,0.1,Scala
12qew3q,,What I'm trying to achieve with smooth is to create a build language (and build tool)  * that is simple to understand for novice users - semantic of most syntax features can be guessed as they are similar/same as in popular languages (java / python / C).,0.375,C
12q2c1e,,"I'm in the middle of reading this excellent article:  [https://openjdk.org/projects/amber/design-notes/towards-better-serialization](https://openjdk.org/projects/amber/design-notes/towards-better-serialization)  and see that object serialization is near-impossible to get right in Java without integrity, vulnerability and other imperfections.",0.08214285714285714,Java
12q2c1e,jgoratm,"class IDeserializer<T> {         T deserialize(Proto src);     }      class XDeserializer : IDeserializer<X> {         public X deserialize(Proto src) { ... }     }      class YDeserializer : IDeserializer<Y> {         public Y deserialize(Proto src) { ... }     }      Proto src = receive();     IDeserializer<X> xfact = new XDeserializer();     X x = xfact.deserialize(src);  A potential alternative is [static virtual methods](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members) in C#, which enable you to stick the factory method in the original interface.",0.16856060606060605,C
12q2c1e,jgpetcu,Lisp by far in my opinion.,0.1,Lisp
12q2c1e,jgqavas,Haskell does it pretty well using typeclasses (maybe Rust as well because of traits).,0.25,Haskell
12q2c1e,jgqavas,Haskell does it pretty well using typeclasses (maybe Rust as well because of traits).,0.25,Rust
12q2c1e,jgqm633,Haskell does it well.,0.0,Haskell
12q2c1e,jgop2jy,"Javascript and Perl do this best, in my experience.",1.0,Perl
12q2c1e,jgop2jy,"Python does okay, but it really wants to throw an exception every time it runs into an object without an explicit serialization method.",0.35,Python
12q2c1e,jgop2jy,"Everywhere I've worked where we used Python, we ended up making our own ""universal JSON"" best-effort serializer, which tries to serialize unknown types, with mixed success.",0.11666666666666665,Python
12q2c1e,jgom7rn,"And padding or packing data fields, plain C style.",-0.21428571428571427,C
12q2c1e,jgrovra,The only one from the +12 languages I have used that has been good for BOTH scenarios is Rust.,0.35,Rust
12q2c1e,jgrovra,How good `serialization/deserialization` is on Rust is one of the major reasons people like the language!,0.3890625,Rust
12q2c1e,jgrovra,"---  Rust is far from perfect, but I hope this show how much you need to think about this to make things better.",0.45,Rust
12q2c1e,jgpuzt0,"Clojure + EDN is the best i've seen, since you're coding with plain data that can be easily consumed by your functions or sent across the wire.",0.4063492063492064,Clojure
12q2c1e,jgpstpj,"In Java I'm now used to serialize a lambda Supplier<T> instead of a T, where the lambda can call capture the suppliers for the fields and call the constructor on the deserialized (.get()) field values, but the article seams to be pretty much 100% against this approach.",0.225,Java
12q2c1e,jgqit0k,"If you need to support multiple formats with Rust and serde, you'll likely need an intermediate representation for each one.",0.0,Rust
12q2c1e,jgrhfdu,You can't do that with arbitrary data in Lisp.,-0.1,Lisp
12q2c1e,jgq2i9d,"We should all give Lisp the love it deserves, the trouble is we, including myself in that statement never give it enough effort to understand how to use it, but where I have seen people proficient in it I have always been amazed with how productive they have been.",0.09999999999999999,Lisp
12q2c1e,jgp756c,"I'm not an expert, so feel free to correct me, but I believe that JavaScript's excellent serialization capabilities are due to the fact that the creator of JavaScript, Brendan Eich [wanted to make Scheme](https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/) but for NetScape, so JavaScript has a lot of the power of a LISP.",0.425,JavaScript
12q2c1e,jgp756c,"I'm not an expert, so feel free to correct me, but I believe that JavaScript's excellent serialization capabilities are due to the fact that the creator of JavaScript, Brendan Eich [wanted to make Scheme](https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/) but for NetScape, so JavaScript has a lot of the power of a LISP.",0.425,Scheme
12q2c1e,jgp756c,"However, I would say that JavaScript does not have as complete serialization as a full LISP, in that any functions implemented natively will be reduced to `function () { [native code] }`.",0.22499999999999998,JavaScript
12q2c1e,jgqh0r3,"When you say serialization for JavaScript, are you only referring to the JSON serialization format or are you considering others too?",0.0,JavaScript
12q2c1e,jgqh0r3,I'd also say that JavaScript has some very unexpected serialization behavior.,0.13,JavaScript
12q2c1e,jgqlwx1,This approach is done for example in C#.,0.0,C
12q2c1e,jgqhwxs,"In Rust, you can implement a trait for a type if you own at least one of them.",0.15,Rust
12q2c1e,jgqh5c3,"I am not familiar enough with the bitcoin protocol, but I wrote an [SWF parser](https://github.com/open-flash/swf-parser) in TS and Rust and the issue seems similar to the bitcoin protocol: there's some header at the start and it controls how to deserialize the rest of the entry.",-0.0625,Rust
12q2c1e,jgsxynk,"I got confused by their usage of the term ""special status"", because it's not Rust types that are granted special status, it's a different data model entirely (some types happen to be the same between the serde types and the Rust core types).",0.05238095238095238,Rust
12q2c1e,jgrjxpb,"Alternatively, you could allow very limited form of evaluation like JavaScript in the browser.",-0.09285714285714286,JavaScript
12q0q41,,"Some of you might recognize this as a kind of [substructural typing](https://en.wikipedia.org/wiki/Substructural_type_system), and if you look really closely, this is similar to borrowing like we see in [Austral](https://austral-lang.org/linear-types) and Rust.",0.26666666666666666,Rust
12q0q41,,"This is slightly different than languages like Rust, which I would classify as ""opt-out"", where it defaults to borrowing (which is similar to linear style), and has users explicitly opt into more expensive approaches via e.g.",0.0,Rust
12q0q41,,"It could be promising for Vale, as it means the user has a tool in their toolbox for eliminating memory safety overhead where they want, a familiar benefit of languages like Rust.",0.2875,Rust
12q0q41,,"However, linear style also feels like it might also have some of Rust's drawbacks in practice.",0.0,Rust
12q0q41,jgoitx9,"Funnily enough, Haskell allows you to [defer type errors to runtime](https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/defer-type-errors.html)!",0.0,Haskell
12q0q41,jgs1rt6,"It also seems to apply to borrowing, like Rust's &mut, which makes sense as borrowing is mostly just sugar on top of linear style.",0.5,Rust
12q0q41,jgs2lcz,"I think Swift comes closest with its value types, but we can't really take references to them.",0.2,Swift
12q0q41,jgtk3gg,"> It also seems to apply to borrowing, like Rust’s &mut   Yep, &mut pushes constraints upward in your program in the same way as linearity.",0.0,Rust
12pz95g,jgoiv0y,"I don't know of any resources off the top of my head (hopefully others have some good ones), but most of my LLVM knowledge comes from three places:   * Using the '-S -emit-llvm' flags when compiling a C program, and looking at the generated .ll LLVM file and comparing it to the original C.  * Looking at others' compilers source code, like Cone and Zig.",0.51875,C
12pz95g,jgpm5dt,Target C or some other language that targets LLVM instead (if you can afford to do so).,-0.125,C
12pz95g,jgpm5dt,"Targeting C is a well-known practice, and plenty of compilers do it.",0.0,C
12pz95g,jgr8fmr,"Targeting C is well-known and a valid technique, but this post is simply not about that.",0.0,C
12pz95g,jgqmla2,"And yeah, Nim is an example that primarily compiles to C and plenty of other languages have that as well, even if it's not their ""main"" compiler (using ""main"" in a very loose sense).",0.10166666666666666,C
12pv9c2,jgnopnx,"This works best in languages like Haskell or OCaml, where you also delc1re functions with it so “let foo (of) x = (be) x + 10 in” makes sense (actual code doesn’t include the stuff in parentheses)",0.08333333333333333,Haskell
12pv9c2,jgnvp0g,I think we can all agree that C’s choice of `auto` makes the least sense compared to `let` or `var`,-0.3,C
12pv9c2,jgnyjme,"So we want to *encourage better practices* and that requires changing terminology so people think ""ok, why Rust doesn't have `var` and now learn why this changed.",0.5,Rust
12pv9c2,jgntf6i,"let means immutable data by default (Rust, OCaml, Nim), It is more “mathematical” in a sense.",0.25,Rust
12pv9c2,jgrim7y,"JavaScript uses let instead of var, because var already existed and had inconsistent behaviors.",0.0,JavaScript
12pv9c2,jgusvw3,This is not true in some languages like Rust where `let` is `var` under disguise.,-0.175,Rust
12pv9c2,jgr54a9,"In Haskell you don't usually use let, just `foo x = x + 10` is enough.",-0.125,Haskell
12pv9c2,jgo9kfy,C++ just reused an existing obsolete keyword that kind of fit instead of adding a brand new one.,0.37878787878787873,C++
12pv9c2,jgnw6wt,I think you mean C++  The idea of automatic assignment isn't just a C++ thing either.,-0.3125,C++
12pv9c2,jgnw6wt,Go has `a := funcThatReturnsComplicatedType()` and it's extremely useful.,0.3,Go
12pv9c2,jgnwirm,auto is not a replacement of let or var (which doesn’t exist in C to begin with) but a keyword saying: the compiler can and should derive the type of the variable.,0.0,C
12pv9c2,jgnwirm,This is the same syntax as any variable declaration in C which is the ˋtype nameˋ pattern.,0.0,C
12pv9c2,jgv6h7v,C's choice does make sense.,0.0,C
12pv9c2,jgv6h7v,What doesn't is C++'s.,0.0,C++
12pv9c2,jgnv76u,"In JavaScript, let is also mutable, but the difference is mainly in scoping   > let allows you to declare variables that are limited to the scope of a block statement, or expression on which it is used, unlike the var keyword, which declares a variable globally, or locally to an entire function regardless of block scope.",0.031746031746031744,JavaScript
12pv9c2,jgo5o6w,Scala does this and it's fantastic.,0.4,Scala
12pv9c2,jgpsy0h,`auto` in C++ is pretty much the same thing as `var` in C# and Java.,0.15,C++
12pv9c2,jgpsy0h,`auto` in C++ is pretty much the same thing as `var` in C# and Java.,0.15,C
12pv9c2,jgpsy0h,`auto` in C++ is pretty much the same thing as `var` in C# and Java.,0.15,Java
12pv9c2,jgv6fan,"In C the type declarator replaced the function of ""auto"" in virtual every case.",0.0,C
12pv9c2,jgpg70z,But C doesn’t have var or let syntax!,0.0,C
12pv9c2,jgpg70z,What you are talking about is type inference which many languages do have but C did not until auto was introduced in C23,0.5,C
12pv9c2,jgpgdkr,Furthermore auto only exists in C23 which very few C Programmers use.,-0.13,C
12pv9c2,jgpggis,The link is a C++ header file…,0.0,C++
12pv9c2,jgpiabn,"It seems like you’re saying type inference could fail, but in a language like Haskell I _can_ explicitly define types and don’t have to rely on inference.",-0.5,Haskell
12pqhnt,jgqncyf,"I'm making a big deal of this because the title suggests that OCaml is _literally_ adopting Rust's borrow-checking system as-is, with no changes, and that is absolutely not what's happening.",-0.05,Rust
12pqhnt,jgqno27,"with e.g., which I think I did here 🎃)  I don’t disagree that it’s “not just Rust tacked-on”, but I suspect that it being Rust-like-in-ways-that-are-interesting-to-general-audiences is exactly the useful takeaway for said general audiences.",0.20000000000000004,Rust
12pqhnt,jgqsb9z,"Rust's borrow checker isn't ""for the sake of example"", which is what that roughly translates to.",-0.1,Rust
12pqhnt,jgqsb9z,The modal type system being proposed is quite different from Rust's borrow-checker.,0.0,Rust
12pqhnt,jgqsb9z,"It does incorporate the borrow-checking and linearity stuff that Rust has, but a little different, and combined with other facets.",-0.10416666666666667,Rust
12pqhnt,jgqsb9z,The fact that they don't explicitly say anything about Rust is itself an indication that this is very different.,0.0,Rust
12pqhnt,jgqsb9z,"They are likely doing it specifically to avoid confusion and conflation, though I personally would have liked at least a bit of the proposal to explicitly draw some parallels and contrasts for the benefit of people already familiar with Rust, who will very obviously note the connections but may not be equipped to suss out the differences.",0.1125,Rust
12pqhnt,jgqsb9z,"And then I came over here and you had (inadvertently) claimed that this proposal was copy/pasting Rust's borrow-checker into OCaml and I had _feelings_, which I let get the best of me.",1.0,Rust
12pqgvu,jgnyqpv,I’ve been meaning to learn more about COBOL,0.5,COBOL
12pqgvu,jgrulfq,COBOL farms remembers,0.0,COBOL
12po6rc,jgn7r92,(C++ uses `< >` because it's all done with templates where types are parameters.,0.0,C++
12po6rc,jgn7r92,(I wish C had been like that.),0.0,C
12po6rc,jgmsl19,"First, one thing you should ask yourself is “what does my language do that makes it special?”   C was higher level (for the time), not horribly slow and worked on multiple systems (with effort)  Java had “write one, run anywhere”.",0.20142857142857143,C
12po6rc,jgmsl19,"First, one thing you should ask yourself is “what does my language do that makes it special?”   C was higher level (for the time), not horribly slow and worked on multiple systems (with effort)  Java had “write one, run anywhere”.",0.20142857142857143,Java
12po6rc,jgmsl19,Rust has the borrow checker.,0.0,Rust
12po6rc,jgmsl19,Python is easy to write.,0.43333333333333335,Python
12po6rc,jgmsl19,Go has easy concurrency and decent performance.,0.3,Go
12po6rc,jgpvztm,You might consider using `..<` as in Swift or Nim.,0.0,Swift
12po6rc,jgne8ng,"I actually kind of stole the `val`/`var` idea from Kotlin :P  The brackets in a lot of cases are intended to be optional since types can be inferred in a lot of cases, so you could just have `fn add(val<i32> x, val<i32> y)` and for the structure `val<Person> bob = ${...}` or `val bob = $<Person>{...}`.",0.675,Kotlin
12po6rc,jgne8ng,(I wish C had been like that.),0.0,C
12po6rc,jgmwkun,I've thought about trying to do something similar to Rust's traits but feels like that could potentially be headache inducing given how the structure syntax works...,0.0,Rust
12po6rc,jgqcaq3,Istr Ruby uses .. for conventional half-open range and ... for inclusive range.,-0.14285714285714285,Ruby
12po6rc,jgqnktf,It has nothing ressembling C's character literals.,0.0,C
12po6rc,jgqnktf,"In fact that is why Unicode-aware languages tend to drop the idea of a ""character"" altogether (or to go the [D route](https://dlang.org/spec/type.html#basic-data-types)): not only does Unicode not use that idea, but ""anything encoded in UTF-8,"" even if it is only one symbol, is a variably-sized array of code units, also known as ""a string.""",0.0,D
12pk48d,jgmoei0,"I forgot how much stuff I read about compilers that quickly discard because I know I CAN'T replicate all that alone, but lately, I see the code of  https://c9x.me/compile/  and was impressed by a)how clean it looks despite being C!",0.3383333333333334,C
12pk48d,jgmoei0,"and b) it is TRULY small (and if not using C, using chatgpt to port this code look very feasible!)",0.0,C
12pk48d,jgnz0bj,"Take a look a [MLTon](http://mlton.org/WholeProgramOptimization) or [Clang Fortran](https://github.com/flang-compiler/flang)   The real optimization work is in compiling for AI accelerators, scheduling sparse matrix multiplications.",0.2,Fortran
12pk48d,jgpugk1,Also the classical [Secrets of the Glasgow Haskell Compiler inliner](https://www.cs.tufts.edu/comp/150FP/archive/simon-peyton-jones/secrets-of-the-glasgow-haskell-compiler-inliner.pdf).,0.0,Haskell
12pk48d,jgmo0jb,"and it's related compiler framework in Go, and never used C++ or Plain C, and the book is in C or C++, you may have a problem with it.",-0.10714285714285714,Go
12pk48d,jgmo0jb,"and it's related compiler framework in Go, and never used C++ or Plain C, and the book is in C or C++, you may have a problem with it.",-0.10714285714285714,C++
12pk48d,jgmo0jb,"and it's related compiler framework in Go, and never used C++ or Plain C, and the book is in C or C++, you may have a problem with it.",-0.10714285714285714,C
12pk48d,jgmo0jb,"BTW I'm practicing in both C and C++, although not my daily work P.L.",0.0,C
12pk48d,jgmo0jb,"BTW I'm practicing in both C and C++, although not my daily work P.L.",0.0,C++
12pk48d,jgmo0jb,"This is done a lot with destination Plain C or C++, but works well with another P.L.",-0.21428571428571427,C
12pk48d,jgmo0jb,"This is done a lot with destination Plain C or C++, but works well with another P.L.",-0.21428571428571427,C++
12pk48d,jh7prp5,It’s literally a walk through the first C compiler.,0.25,C
12p0od6,,"If this functionality is implemented for every type, that means that there is always a possibility to move a value from one location to another (which sounds logically correct), but there are several problems here too: what is the default version of move operator going to look like, is accepting C++ interpretation of valid but unspecified state ok, what if someone wants their type not to be movable.",0.2375,C++
12p0od6,jgltmba,"There's no `Copy` trait as in Rust, instead a handful of types are marked as value types by the compiler, and these are copied when moved.",0.1,Rust
12p0od6,jgv8biu,"Rust assume all types to be movable, but you could easily make this restriction, it will make RAII way less nice however: Because Rust allows all types to be moved trivially, all new values can only be created in aggregate expressions and bond to temporaries and variables can only be initialized by moving an existing value into them.",0.16717171717171717,Rust
12p0od6,jgm2b4g,"As for `Copy`, you can either use a marker trait (like `Copy` in Rust) and give your compiler knowledge of this trait, or introduce a special keyword that turns types into copy/value types.",0.35714285714285715,Rust
12oke5n,jgix3j2,I don't think I've seen a lang implemented in Fortran before.,0.0,Fortran
12oke5n,jgj17s2,"I’ve been using Fortran professionally for about 10 years, so I know it better than any other language.",0.15833333333333333,Fortran
12oke5n,jgj17s2,Also this is a good opportunity for me to do things that Fortran isn’t usually used for.,0.22499999999999998,Fortran
12oke5n,jgj17s2,"In hindsight C++ might have been a more convenient host language, maybe I’ll do that for the next project :)",0.3333333333333333,C++
12o49eo,,I've been researching bytecode interpreter optimizations (without JITing) and to test them out made a few simple C implementations: [https://gist.github.com/kartiknair/bef81356d5a4b9eb9ccbbafde4fa87d9](https://gist.github.com/kartiknair/bef81356d5a4b9eb9ccbbafde4fa87d9).,-0.31666666666666665,C
12o49eo,jgh7y52,"👍  Both C and C++ have the bad reputation of been overused at a way that look like a ""cryptography code"".",-0.6999999999999998,C
12o49eo,jgh7y52,"👍  Both C and C++ have the bad reputation of been overused at a way that look like a ""cryptography code"".",-0.6999999999999998,C++
12o49eo,jgi8dh7,"So perhaps there is room for improvement, but whether that is possible with pure C, I'm not sure.",-0.01190476190476191,C
12o49eo,jgiiqin,"\> So perhaps there is room for improvement, but whether that is possible with pure C, I'm not sure.",-0.01190476190476191,C
12o49eo,jgisnku,"(\*\*Update\*\*: my test using C took 3.9 seconds for the 100M loop, with `gcc-O0`.",0.0,C
12o49eo,jgisnku,"I think I will try a different way...)  Running that loop in native code takes `0.28` seconds in C, optimised or not.",0.0,C
12o49eo,jgisnku,I'd say that 3 times as slow as optimised C is pretty good.,0.21666666666666665,C
12o49eo,jgisnku,I guess GNU C is bit more portable than assembly.,0.5,C
12o49eo,jgliqk5,"Which was poor, until I applied the modest optimiser of an older compiler version, then it ran it in just under 1.6 seconds, a little better than gcc's 1.65 seconds on the C version.",0.035833333333333314,C
12o49eo,jgliqk5,"ETA:  >This is quite interesting, would be curious to see the code/generated assembly to see what's causing that  This is the [C code](https://github.com/sal55/langs/blob/master/pcl100.c).",0.2,C
12o49eo,jgliqk5,Tiny C ran it a little slower than `gcc-O0`; 'bcc' (my own compiler) ran it a little faster.,0.056249999999999994,C
12nqbra,,"After doing some research, I found that Lua's VM, for example, doesn't support hardware registers, but makes an array of virtual registers on the stack.",0.0,Lua
12nqbra,jghjjc3,Have you ever read C(++) system headers with thousands of `#ifdef` in them?,0.0,C
12nqbra,jgfo7uy,"Yes, but that's why Java got .jit to replace their instructions with physical optimized equivalents ...  >> 2.1 E.G.",0.0,Java
12nqbra,jgfo7uy,"**  Most of the existing compiler tool frameworks like GCC or LLVM use a platform independent intermediate representation code, similar to a V M. interpreter that is transformed into specific hardware platforms, just like Java V.M.",0.125,Java
12nqbra,jgfo7uy,Java V.M.,0.0,Java
12nqbra,jggmr3s,"For example, a language intended for data-crunching will benefit a lot from compilation (see Julia), though it might be sufficient to just delegate to native routines (see Python/Numpy).",0.0,Julia
12njii1,,"Anyone might implement Forth once, but why *twice*?",0.0,Forth
12njii1,,"Well, the first real dogfooding I did was implementing a large subset of [Nick Morgan's Easy Forth](https://skilldrick.github.io/easyforth/) in Charm.",0.27440476190476193,Forth
12njii1,,Here's [the code for the Forth](https://github.com/tim-hardcastle/Charm/blob/main/examples/forth.ch).,0.0,Forth
12njii1,,Also special commands `quit` to stop Forth and `reset` to return it to its clean state.,0.36190476190476195,Forth
12njii1,,Forth > 2 2 + .,0.0,Forth
12njii1,,4 Forth > : sqr  dup * ;  OK.,0.5,Forth
12njii1,,Forth > 2 sqr  OK.,0.5,Forth
12njii1,,Forth > .,0.0,Forth
12njii1,,4 Forth > 10 0 do i sqr .,0.0,Forth
12njii1,,loop  0 1 4 9 16 25 36 49 64 81 Forth > variable A 10 cells allot  OK.,0.5,Forth
12njii1,,Forth > 10 0 do i dup sqr swap A + !,0.0,Forth
12njii1,,Forth > 10 0 do i A + ?,0.0,Forth
12njii1,,loop  0 1 4 9 16 25 36 49 64 81 Forth >                 ```,0.0,Forth
12njii1,jgge53y,"Pre-splitting the input line into whitespace separated words is very untypical for Forth, since it makes parsing words impossible (so you need to special case string handling, and even seem to have a bug of collapsing multiple spaces into one within strings).",-0.027380952380952367,Forth
12njii1,jgge53y,"I am aware that this is just an exercise in using your own language Charm, I would just like to note that it should not be considered a typical way to implement Forth.",0.22777777777777777,Forth
12my72a,jgcf8v6,"I've implemented the Python approach, where a module corresponds to a file.",0.0,Python
12my72a,jgdex1q,"So anyway, in my language I mostly copied Rust, in that you have root ""project"" files which contain either inline module declarations or _`extern`_ module declarations, the latter of which causes a filesystem read, and in that you have to tell the compiler about _all_ those roots.",0.25,Rust
12my72a,jgdex1q,"As far as splitting modules into files go, I do like Rust:    - `ns Whatever.Example with /*...*/ end` declares the `Whatever.Example` module and the compiler immediately registers it.",0.1,Rust
12my72a,jgdex1q,"Now how do I use those, I mostly copied from D as I consider it the most ergonomic.",0.5,D
12my72a,jgf1ndy,C++ / PHP namespaces work but aren't the best way.,1.0,C++
12my72a,jgf1ndy,C++ / PHP namespaces work but aren't the best way.,1.0,PHP
12my72a,jgf1ndy,That's why the C++ comite just reinvented a new syntax for modules.,0.13636363636363635,C++
12my72a,jgf1ndy,"Java and C# static Classes does work as modules, but aren't either.",0.5,Java
12my72a,jgf1ndy,"Java and C# static Classes does work as modules, but aren't either.",0.5,C
12my72a,jgf1ndy,"**  C++ mixes both ways, but make it's confusing.",-0.3,C++
12my72a,jgf1ndy,"The module folder kind, called ""assemblies"" in C# and ""Packages"" in Delphi/ FreePascal, can only contain other modules, not directly code.",0.10625,C
12my72a,jgf1ndy,"The module file kind, called ""package"" in Java, and ""unit"" in Delphi / FreePascal, are usually single files that contain directly code.",0.20952380952380953,Java
12my72a,jgf1ndy,"The module file kind, called ""package"" in Java, and ""unit"" in Delphi / FreePascal, are usually single files that contain directly code.",0.20952380952380953,Delphi
12my72a,jgf1ndy,"They are similar to a C++ file where only a new single non anonymous namespace is declared, and all declarations are inside of it.",0.016233766233766232,C++
12my72a,jgf1ndy,Pascal's branch of P.L.,0.0,Pascal
12my72a,jgf1ndy,"(s) like Modular, Oberon and Ada, does support multiple nested modules in a single file similar to C++ nested namespaces, but I still consider the single file module per file much better.",0.07142857142857142,Ada
12my72a,jgf1ndy,"(s) like Modular, Oberon and Ada, does support multiple nested modules in a single file similar to C++ nested namespaces, but I still consider the single file module per file much better.",0.07142857142857142,C++
12my72a,jgf1ndy,"There's may be other predefined module folders, bit it's better to group them inside a single one, like the predefined, compilation time, C++ ""std"" namespace or ""system"" module.",0.1011904761904762,C++
12my72a,jgf1ndy,"**Check C#, Delphi or FreePascal they have a better module system than the other P.L.",0.1875,C
12my72a,jgf1ndy,"**Check C#, Delphi or FreePascal they have a better module system than the other P.L.",0.1875,Delphi
12my72a,jgfva36,Point is to solve some configuration management problems I experienced with the Python approach.,0.8,Python
12mx8q9,,"It seems current programming landscape trends is moving toward improving modularity (package dependency), functional programming (unison-lang, amazon lambda), immutability (Haskell), reproducible build (nix) and portability (web assembly).",0.0,Haskell
12mx8q9,jgcxmgf,C standard library if you can interop with C,0.0,C
12mx8q9,jgl0mjf,Strings in C rust java or python don't necessarily have the same byte code implementation.,0.0,C
12mvqv1,,"In the Lisp world one of the major differences between the Scheme/Racket languages and others such as Common Lisp is that CL is a ""Lisp2"" language, meaning that there are two namespaces for symbols: one for variables and a separate one for functions.",-0.07916666666666666,Lisp
12mvqv1,jgc7uo3,The Rust languages allows for some fairly confusing stuff due to its name resolution.,-0.2125,Rust
12mvqv1,jgc8b3h,"> I am not aware of any other languages like this  Java, for example.",-0.125,Java
12mvqv1,jgcjyf6,Haskell also has a namespace for values and a namespace for types.,0.0,Haskell
12mvqv1,jgcc98s,"C has a struct namespace, a variable namespace, and a label namespace.",0.0,C
12mvqv1,jge11xq,With the exception of Scheme I can't think of any language that only has one namespace (Common Lisp has I think 6 or 7 namespaces btw.).,-0.15,Scheme
12mvqv1,jge11xq,With the exception of Scheme I can't think of any language that only has one namespace (Common Lisp has I think 6 or 7 namespaces btw.).,-0.15,Lisp
12mvqv1,jge11xq,All languages I know except Scheme have 3 more namespaces.,0.5,Scheme
12mvqv1,jge11xq,"Funny Java expample showing `x` used as a classname, member name, parameter name, method name and variable name:      jshell> class x {        ...>       x x;        ...>       x(x x) {        ...>             this.x = x;        ...>       }        ...>       x x() {        ...>             return this.x;        ...>       }        ...> }     |  created class x          jshell> x x = new x(null)     x ==> x@28c97a5          jshell> x.x()     $3 ==> null          jshell>",0.19318181818181818,Java
12mvqv1,jgcdyhu,Shell languages kinda?,0.0,Shell
12mvqv1,jgcj10c,C is similar but not exactly like this.,-0.0625,C
12mvqv1,jgcj10c,"C features this phenomenon between types and variables/functions:  ``` int stat(   const char *restrict pathname,   struct stat *restrict statbuf ); ```  although admittedly, this example is less how I remembered it, I remembered it more like:  ``` typedef struct { ... } stat;  int stat (..., stat* ...); ```",0.16666666666666669,C
12mvqv1,jgcq0p8,"After all most languages allow different instances of `foo` because of block scopes, or shadowing, or, in C with its 3 main namespaces, if `foo` is a variable name, extra `foo`s in the same scope can only be struct/enum tags, or labels.",0.1111111111111111,C
12mvqv1,jgdj1jq,It's the convention for the (automatic) getters of Java record components:      record Person(String name) {}     person.name == person.name()  (as long as you have access to the private fields of the record),-0.025,Java
12mvqv1,jgdmrsg,Or do Lisp let bindings have a different semantic than in ML?,0.0,Lisp
12mvqv1,jgh4e3x,"In the case of Common Lisp, however, it is not unimportant that `(do-something list)` could macro-expand into code that uses the `list` function.",-0.04999999999999999,Lisp
12mvqv1,jgh4e3x,"Common Lisp doesn't have hygienic macros, but between separate function namespace and the package system, it almost never suffers from this fact.",0.0,Lisp
12mvqv1,jgh4e3x,"(An early paper introducing hygienic  macros for Scheme introduced the ""problem"" using a few motivating examples.",-0.05,Scheme
12mvqv1,jgh4e3x,*None* of them would have caused problems if Scheme hadn't unified the namespaces.),0.0,Scheme
12miujn,,**  Go to the [proposal page](https://area51.stackexchange.com/proposals/127456/programming-language-design) and click commit.,0.0,Go
12lz9ky,jgau3v2,"I don't have experience of Bash, but I just ran a Fibonacci benchmark using Bash under Windows WSL.",0.0,Bash
12lz9ky,jgau3v2,It's likely that Bash is reparsing the source each time it executes a line.,0.0,Bash
12m738n,,I noticed the other day that it won't allow you to generate a function with a name that is not a valid C identifier...,-0.125,C
12m738n,,"Edit: I've just realised my test case doesn't completely prove that it's possible to generate such identifiers with the JIT (I remember seeing some code deep in its library implementation that replaces all invalid C identifier characters with underscores), but given the backend support in the GNU assembler, it should still be technically possible to achieve.",0.02,C
12m738n,jg9ryrm,"Any char not in the ""simple"" C identifier set (_A-Za-z0-9) unicode code point (and the letter capital Q) is encoded as Qxx where xx is a hexadecimal number like 20 or ff.",0.0,C
12m738n,jg9v42l,"For Inko's upcoming LLVM compiler I'm doing something similar: mangled names are in the form `_IXT_NAME` where `X` is the version and `T` a type indicator (`M` for methods, `T` for types, `C` for constants).",0.0,C
12m738n,jgu74ke,"[For anyone not aware, I have a proposal for C and might propose it to C++ as well to overload operators without name mangling](https://www.reddit.com/r/cpp/comments/12rcywj/operator_overloading_without_namemangling/)",-0.125,C
12m738n,jgu74ke,"[For anyone not aware, I have a proposal for C and might propose it to C++ as well to overload operators without name mangling](https://www.reddit.com/r/cpp/comments/12rcywj/operator_overloading_without_namemangling/)",-0.125,C++
12m738n,jga6q0c,Not in C++.,0.0,C++
12m738n,jg9xpyq,"I've also considered (in case I wanted to restrict my language's symbols to C identifiers but use arbitrary symbols in the binary) using some form of ""dense symbol encoding"" that turns the (base53,base62...) symbols of C identifiers into a base-255-encoded string, which is more compact although not trivial to encode (base conversions is an area of special interest to me!)",0.011607142857142858,C
12m738n,jg9zhrc,"In theory, nothing to stop this from happening for C++ code, as if I'm not mistaken, name mangling is an implementation detail that's not standardised as part of the language.",0.0,C++
12m738n,jgaagz1,:D  _One `/bin` to call them all_   _One `/bin` to `find` them_   _One `/bin` to `wget` them all_   _And in the network stack `bind` them!_,1.0,D
12m738n,jgbzbud,"Java and MS jumped all over this in 1993 and it's a failure, IMHO.",-0.3166666666666667,Java
12m738n,jgbzbud,"For example, my ""R"" turned backwards is not necessarily the Cyrillic letter called ""Я"".",0.0,R
12m738n,jgbsgnl,My (overly conservative) encoding works with C compilers predating the unicode standard.,0.0,C
12m738n,jgbsgnl,"The output is so simple that every tool we know that processes C code (or object files where these are called symbols) can handle Q encoded ""symbols"".",0.0,C
12m738n,jgbsgnl,"[[Actually, I know this to be false since some C compilers and linkers had a length limitation way back when.]]",-0.13333333333333336,C
12m738n,jgbsgnl,"Modern C compilers, and especially the GNU toolchain, explicitly allow additional characters beyond my overly conservative set (for example $) though C compilers are supposed to use the unicode notion of ""alphanumeric"" to determine if a code point is legal or not in an identifier (comma and space and parens will never be valid parts of C identifiers).",0.13333333333333333,C
12m738n,jgbsgnl,"They must be a super-set of their C compilers though, otherwise, no one would like them.",0.0,C
12m738n,jgbsgnl,"While they aren't bound to (multiple) international standard like C (and C++), if they don't handle C and C++, they'd likely fall out of use or more likely improved to handle C. Linkers *likely* treat everything as sequences of bytes that end in NUL, aka utf-8 NUL terminated strings, but I can't credibly talk about Windows or actually GNU tools since they change every few years.",0.06999999999999999,C
12m738n,jgbsgnl,"While they aren't bound to (multiple) international standard like C (and C++), if they don't handle C and C++, they'd likely fall out of use or more likely improved to handle C. Linkers *likely* treat everything as sequences of bytes that end in NUL, aka utf-8 NUL terminated strings, but I can't credibly talk about Windows or actually GNU tools since they change every few years.",0.06999999999999999,C++
12m738n,jgbsgnl,It's kind of strange that GCC and Microsoft have different ways of name mangling especially since cfront (the first C++ transpolar)  must have also done this and that would form a common basis.,0.08333333333333333,C++
12m738n,jga9fh2,"I thought I was going mad for a second there when I saw that comment, I was pretty sure they weren't in C++!",0.0625,C++
12m738n,jga9fh2,:D,1.0,D
12m738n,jgeruku,"I'm not sure if this is allowed, by the C standard, although is possible.",-0.08333333333333333,C
12m738n,jga9l00,I think it's because linkers back when C++ was created were only designed to support C identifiers.,0.0,C++
12m738n,jga9l00,I think it's because linkers back when C++ was created were only designed to support C identifiers.,0.0,C
12m738n,jgestv7,"> I'm not sure if this is allowed, by the C standard, although is possible.",-0.08333333333333333,C
12m738n,jgestv7,I'm not modifying the C compiler.,0.0,C
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,C++
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,Ada
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,D
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,C
12m738n,jgestv7,"Although libgccjit's structure is evidently C-inspired, it's not a C program builder, it's a builder for GCC's internal IR, so AFAIK C language rules generally don't apply here (it's legal to use arbitrary identifier names in the GNU assembler after all, and AFAIK what I'm doing is roughly the JIT equivalent).",0.05000000000000001,C
12m738n,jgcprco,I believe utf-8 will be their biggest contribution that will live longer than the C language itself.,0.13636363636363635,C
12m738n,jgaz25p,"I mean in C++ argument names aren't part of the type ... but I didn't realize that you were referring to your own mangling scheme, thus the miscommunication.",0.14375,C++
12m738n,jgb2unv,"Nah, I just conflated parameter names being part of the type with them being part of ""the mangled name"" where I was thinking of that of common implementations--but the only name mangling at issue here is your own, not that of existing C++ implementations.",0.09999999999999999,C++
12lyh50,,"How would a language like Rust define the element type of my bytecode array, or access the various values?",0.0,Rust
12lyh50,jg8r785,"They're useful, but I can't say they're wanted here; I myself use an array of bytes to do this (along with a large-integer encoding) in Rust.",0.3,Rust
12lyh50,jgc5oqx,In Elm there is this idea of using a pattern like `type UserId = UserId String` where you have a `String` representation of a `UUID` that is tagged in order to make sure you are not accidentally using the `UUID`  of some other structure for `UserId`.,0.1875,Elm
12lyh50,jgahdn4,"Not entirely familiar with Rust, but I believe it supports basic ADTs (via enum) and C-like unions as orthogonal features.",-0.09375,Rust
12luon1,,"The idea then arose to allow the comma on the other side, to be able to apply the second argument instead, which would be analogous to `(flip swap) y` in Haskell.",0.125,Haskell
12luon1,jg82e4e,"After a few experiments, and being in the C family more or less, we ended up with `&` as “do not dereference”, and `_` as “do not bind”.",0.044444444444444446,C
12luon1,jgamqs5,For example Swift uses named arguments.,0.0,Swift
12luon1,jgaok31,"Swift had a notoriously bad implementation of ""tuple-splat"" that they had to [remove it](https://github.com/apple/swift-evolution/blob/main/proposals/0029-remove-implicit-tuple-splat.md).",-0.6999999999999998,Swift
12luon1,jgaqhgn,dont confuse Swift's implementation with the idea.,0.0,Swift
12lsz7o,jg7nbq7,"Creating bindings for it was too hard so I decided to just port it to Rust all at once, thankfully project is small enough.",-0.18055555555555558,Rust
12lsz7o,jg7nbq7,I am using it to make JIT compiler for my R7RS Scheme.,0.0,Scheme
12lsz7o,jg898p2,30k LOC is B3 IR + Assembly IR with opts and all passes.,0.0,Assembly
12lsz7o,jg898p2,"Note that masm-rs rn only supports x86-64, I am soon going to add ARM64 so expect another 6k LOC :D",0.5,D
12lsz7o,jg85js2,"masm-rs is also a port of JSC \`assembler/\` directory, there are some changes in API to work better with Rust.",0.5,Rust
12lsz7o,jg8b9ss,"(Btw, do you have a good overview of ""macroassemblers written in Rust""?",0.7,Rust
12lkmyl,,"[Jactl](https://jactl.io) is intended to be used as a scripting language for real-time Java applications to allow users to provide customisations/extensions in a safe, controlled, manner.",0.5,Java
12lkmyl,,It has a syntax that borrows heavily from Groovy (with a bit of Perl mixed in) and is suitable for event-loop/reactive applications because scripts are guaranteed to never block the execution thread.,0.11666666666666668,Groovy
12lkmyl,,It has a syntax that borrows heavily from Groovy (with a bit of Perl mixed in) and is suitable for event-loop/reactive applications because scripts are guaranteed to never block the execution thread.,0.11666666666666668,Perl
12ktce4,,"Ripple is open source, you can check out the repository here: [Ripple on Github](https://github.com/dibsonthis/Ripple)  Below is a basic Ripple program:      var length, area, diff = 0          length::onChange = () => {         area = length ^ 2     }          area::onChange = (old) => {         diff = area - old     }          for (1..10) {         length = length + 1         print(""L: "" + string(length) +                "" - A: "" + string(area) +                "" - D: "" + string(diff) + ""\n"")     }  The way it works is pretty simple.",-0.19999999999999998,D
12ktce4,,"This is a printout of the results:      L: 1.000000 - A: 1.000000 - D: 1.000000     L: 2.000000 - A: 4.000000 - D: 3.000000     L: 3.000000 - A: 9.000000 - D: 5.000000     L: 4.000000 - A: 16.000000 - D: 7.000000     L: 5.000000 - A: 25.000000 - D: 9.000000     L: 6.000000 - A: 36.000000 - D: 11.000000     L: 7.000000 - A: 49.000000 - D: 13.000000     L: 8.000000 - A: 64.000000 - D: 15.000000     L: 9.000000 - A: 81.000000 - D: 17.000000  Ripple is still very much a work in progress, but the repo can be found here: [Ripple](https://github.com/dibsonthis/Ripple)  **Important Note:** Yes, I know side effects may be seen as an anti-pattern, and I am fully aware that this may be a bad idea in many situations.",-0.006666666666666636,D
12ktce4,jg40rzk,"This language vaguely resembles rule based languages, did you take some inspiration from things like Prolog?",-0.5,Prolog
12ktce4,jg4amjw,"You made me remember  ""reactive banana"" a library in Haskell for reactive functional programming.",0.0,Haskell
12ktce4,jgbljkp,"But, people use this return parameter idiom in Java.",0.0,Java
12ktce4,jgdro71,"AH, i've seen this a lot when working with C# in industry, i didn't know that name.",0.0,C
12ktce4,jgdro71,"In C# it's like `int F()` becomes `void F(out int)`, so i think they have a different name.",0.0,C
12ke7n4,,That Python trick of using and object's (original) memory address as its key in a dictionary?,0.1875,Python
12ke7n4,jg2x7tc,"That's why in ""C++"" there's a ""typeinfo"" type, but this type is not restricted to other base type, some compiler / interpreters use a pointer, some uses a ""struct"", others a pointer to another type.",-0.4625,C++
12ke7n4,jg2x7tc,"(s) are known to be good tools to implement an interpreter/ compiler, I personally learned Lisp.",0.35,Lisp
12jgfqi,jfylo5r,interesting Python fact: that's not how it works actually.,0.25,Python
12jgfqi,jfylo5r,"Calling a member of Python is always just calling a function, but when you instantiate an object, members are created with the names of the method and bound to closures that call the method with the instance as first parameter.",0.25,Python
12jgfqi,jfylo5r,"class A:         def foo(self):             return 42      a, b = A(), A()     print(a.foo == A.foo)  # False     print(a.foo == b.foo)  # False     print(type(a.foo))  # method     print(type(A.foo))  # function  So syntaxically, Python does not distinguish methods from other attributes.",-0.3083333333333334,Python
12jgfqi,jfzqm5s,"That's the C++ solution: ""if the result of a member access expression resolves to a member function, then that expression can only be the left operand of a call expression.""",0.0,C++
12jfq6s,,"Take the following pseudocode:      # A, B, C are type-parameters          let black_box<A, B>(f: func(A) -> B, g: func(A) -> B) -> (func(A) -> B){        if rand() > 0.5 { f } else { g }     }              let foo = func<A>(a: A) -> (A, number){       return (a, 1)     }          let bar = func<A>(a: A) -> (A, number){       return (a, 2)     }          let result_func = black_box(foo, bar)          result_func(""a"");  # Returns either (""a"", 1) or (""a"", 2)  Is this even possible to typecheck using a hindley-milner-ish type system without further annotations?",0.0,C
12jfq6s,jfxxb0j,"Here's the Haskell equivalent:      module Main (main) where          blackBox :: (a -> b) -> (a -> b) -> (a -> b)     blackBox f g = f          foo :: a -> (a, Int)     foo x = (x, 1)          bar :: a -> (a, Int)     bar x = (x, 2)          resultFunc :: a -> (a, Int)     resultFunc = blackBox foo bar          result :: (String, Int)     result = resultFunc ""a""          main :: IO ()     main = print result  And the result:      (""a"",1)  I think you made a mistake with your signature for `black_box`, it introduces `b` and `c` but then you give the type `(a -> b) -> (a -> b) -> (a -> b)`.",-0.34259259259259267,Haskell
12jfq6s,jfy5kkv,"If you're implementing this in Haskell (Rust might work as well, though it's going to have a few rougher edges),  [Trees That Grow](https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf) will make annotating variables pretty easy.",0.16111111111111112,Haskell
12jfq6s,jfy5kkv,"If you're implementing this in Haskell (Rust might work as well, though it's going to have a few rougher edges),  [Trees That Grow](https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf) will make annotating variables pretty easy.",0.16111111111111112,Rust
12im9hi,,"While not quite a new programming language per se, `mandala` provides a single decorator + context manager which radically reduces the code needed to manage computational artifacts, and gives ordinary Python programs some interesting features from a PL point of view: - it turns programs into interlinked, persistent data as they run.",0.07873376623376624,Python
12im9hi,jfw7dbz,I like the idea of decorators handling the workload in Python.,0.0,Python
12im9hi,jfxy9gj,It's great how hackable Python is with so little extra syntax on the user side - the amount of logic you can tie to a decorator is amazing.,0.30312500000000003,Python
12il3xp,jfu6l34,C# 11 has it.,0.0,C
12il3xp,jfuaeze,I think it should urgently be added to C++.,0.0,C++
12il3xp,jfvvz3b,Kotlin's companion objects seem to basically do that; would you consider that a solution (replacing the static part with singleton objects that can thus use polymorphism)?,0.5,Kotlin
12il3xp,jfvp2ut,Objective-C's methods are all resolved dynamically.,0.0,Objective-C
12il3xp,jfvp2ut,"Or as D's FI for Objective-C says it, _the static methods are virtual_.",0.5,D
12il3xp,jfvp2ut,"Or as D's FI for Objective-C says it, _the static methods are virtual_.",0.5,Objective-C
12il3xp,jfvp2ut,"In PHP, `Self` refers to the early bound type, while `static` refers to the type name that was used to invoke the current static method.",0.275,PHP
12il3xp,jfw3mkj,Python example of what I want to implement:  ``` class Parent:     NAME = 'BASE'          def print_self(self):         print(type(self).NAME)  class ChildA(Parent):     NAME = 'Child A'  class ChildB(Parent):     NAME = 'Child B'  def print_name(T: type):     print(T.NAME)   if __name__ == '__main__':     print_name(Parent)     print_name(ChildA)     print_name(ChildB)          p = Parent()     a = ChildA()     b = ChildB()          p.print_self()     a.print_self()     b.print_self() ```,-0.3166666666666667,Python
12il3xp,jfwh7cd,(C# added a similar feature last year in version 11.),0.0,C
12il3xp,jg1260f,This is also present in ActionScript 3.,0.0,ActionScript
12il3xp,jg1c486,"I went ahead and knocked together a C implementation which could be used as part of a source-to-source language, which relies upon a guarantee that the ""ClassClass"" structs are data-layout compatible (i.e.",0.0,C
12il3xp,jfuhz32,It is often my experience that C# contains features which are on my common-sense wishlist!,0.0,C
12il3xp,jfuhq38,"I agree, I found when I tried to use it in C++ and it didn't work, it was a case that contradicted reasonable expectations of how it should function.",0.2,C++
12il3xp,jfvwqdt,"I would say it is _a_ solution just as using const getters in C++ is (or a workaround if you will), but I am looking to implement a system providing class-level polymorphism in approximately the form I described.",-0.4,C++
12il3xp,jfvihyg,"In fact Scala and Kotlin make it explicit in that instead of ""static methods,"" you got a global ""companion global object.""",0.16666666666666666,Scala
12il3xp,jfvihyg,"In fact Scala and Kotlin make it explicit in that instead of ""static methods,"" you got a global ""companion global object.""",0.16666666666666666,Kotlin
12il3xp,jfw426c,"Btw, I added a Python example demonstrating exactly what I want to implement in my language.",0.25,Python
12il3xp,jfywvz2,"FWIW I realise it's a bit more difficult to visualise what I want in dynamic languages like Python and Raku, where there isn't a direct equivalent of ""calling derived methods from a pointer or reference of base type"" but basically, I'm talking about the ability to have static members accessed in base methods which can be overridden in the derived classes such that base's methods access the derived static variable, not the base one.",-0.19090909090909092,Python
12il3xp,jfywvz2,"I think my Python snippet elsewhere in thread illustrates more or less what I want, sans ""calling from a reference of base type"" part",-0.15555555555555556,Python
12il3xp,jg5ynp2,> dynamic languages like Python and Raku  Raku is statically typed (albeit gradually).,0.0,Python
12id0uv,jft49fd,It's a graph machine that proceeds by graph rewriting and is used for compiling/executing Haskell.,0.0,Haskell
12id0uv,jft5s1h,"Alternatively, [this is a really nice introduction to the G machine for lazy languages](https://amelia.how/posts/the-gmachine-in-detail.html), and a [less pretty but more rigorous introduction to the Spineless Tagless G Machine](https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf) that GHC (Haskell) uses internally.",0.15555555555555556,Haskell
12id0uv,jfxlxue,"Besides the G-machine, you might like looking at the internals of the Erlang VM(AKA the 'BEAM').",0.0,Erlang
12id0uv,jfwa4uc,"A massively parallel, optimal functional runtime in Rust https://github.com/HigherOrderCO/HVM  Good discussions:   * https://news.ycombinator.com/item?id=35336113  * https://news.ycombinator.com/item?id=30219452  * https://zicklag.github.io/blog/interaction-nets-combinators-calculus/",0.35,Rust
12icyia,jftil6b,"The [Kotlin intermediate representation](https://kotlinlang.org/spec/asynchronous-programming-with-coroutines.html), e.g., makes a pass to transform all asynchronous functions to CPS.",0.0,Kotlin
12icyia,jft8bpl,For example Chez Scheme's nanopass compiler uses more than 30 ILs.,0.5,Scheme
12icyia,jfued8g,"Back in the day I was on the frontend side of an OOPish C-embedding language that was translated to plain C in continuation-passing style, for use with an async computing runtime; it could be a bit fiddly, but we were able to use it to walk a contextual “self” around the network, carrying its data with it, and we even got it to distribute execution semi-automatically to the GPU when available.",0.17142857142857143,C
12icyia,jfxuygv,"When programming in an imperative language such as C, we take for granted the notion of a call stack, which is actually an abstraction.",0.0,C
12icyia,jfxuygv,"When calling a function, e.g., through the `call` instruction, we give the return address as an extra parameter in a register: but that's actually just the continuation parameter that implictly exists in C but explictly exists in CPS and assembly.",0.0,C
12icyia,jfzmw51,Consider the `longjmp` function in the C standard library.,0.0,C
12icyia,jg2ayab,"You may compare this to how Go, Stackless Python and Chez Scheme implement their stacks.",0.0,Go
12icyia,jg2ayab,"You may compare this to how Go, Stackless Python and Chez Scheme implement their stacks.",0.0,Python
12icyia,jg2ayab,"You may compare this to how Go, Stackless Python and Chez Scheme implement their stacks.",0.0,Scheme
12hwafs,jfqvg19,"We infer the add-on’s permission-set automatically, over both its binary and JavaScript sides, via a set of novel program analyses.",0.0,JavaScript
12hhfe5,jfsmnsh,"All the theory in the world is no good if they're not implemented, and Haskell is the only near-mainstream language with a ton of theory, and it's a complete disaster for any practical work.",-0.08333333333333333,Haskell
12hhfe5,jfvw1e7,"I've used Haskell for practical work and I love it, I've written a game in it, I've made a REST server in it.",0.04999999999999999,Haskell
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,JavaScript
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,Python
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,Ruby
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,Groovy
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,PHP
12hhfe5,jfvw1e7,Imagine how many JavaScript frameworks and libraries wouldn't have been made if JavaScript had any amount of solid theory behind its design.,0.033333333333333326,JavaScript
12hhfe5,jfsszh0,"I thought Rust and Haskell were more-or-less the same language, the primary difference being that Rust has more C-like syntax.",0.3,Rust
12hhfe5,jfsszh0,"I thought Rust and Haskell were more-or-less the same language, the primary difference being that Rust has more C-like syntax.",0.3,Haskell
12hhfe5,jfsszh0,"Since Rust is definitely not a disaster for practical work (in fact, it's the most loved language in the world), Haskell is not either.",0.39999999999999997,Rust
12hhfe5,jfsszh0,"Since Rust is definitely not a disaster for practical work (in fact, it's the most loved language in the world), Haskell is not either.",0.39999999999999997,Haskell
12hhfe5,jft4ml3,How much Haskell experience do you have?,0.2,Haskell
12hhfe5,jg01iui,"> Haskell is the only near-mainstream language with a ton of theory, and it's a complete disaster for any practical work.",0.05,Haskell
12hhfe5,jg01iui,In the real world though... where I just finished writing professional Haskell code...,0.15000000000000002,Haskell
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,Java
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,C++
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,C
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,Rust
12hhfe5,jfx7u3z,"Also, in terms of actual benefits from a practical statically typed system, I'd wager that Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.1,Rust
12hhfe5,jfx7u3z,"Also, in terms of actual benefits from a practical statically typed system, I'd wager that Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.1,Haskell
12hhfe5,jfsw3ai,"I disagree with the person you’re replying to, but Haskell and Rust are *very* different languages.",0.0,Haskell
12hhfe5,jfsw3ai,"I disagree with the person you’re replying to, but Haskell and Rust are *very* different languages.",0.0,Rust
12hhfe5,jfsw3ai,"Based on my admittedly limited knowledge of Rust:  Rust doesn’t have HKTs, which are crucial to how many things in the Haskell standard library work (for example, the Functor, Applicative and Monad type classes).",0.16571428571428573,Rust
12hhfe5,jfsw3ai,"Based on my admittedly limited knowledge of Rust:  Rust doesn’t have HKTs, which are crucial to how many things in the Haskell standard library work (for example, the Functor, Applicative and Monad type classes).",0.16571428571428573,Haskell
12hhfe5,jfsw3ai,Haskell’s main form of branching is pattern matching on algebraic data types (the other kinds of branching actually compile down to this in GHC’s IR).,-0.028472222222222232,Haskell
12hhfe5,jfsw3ai,Regarding the safe part of Haskell: Rust functions are not necessarily referentially transparent while Haskell’s are.,0.25,Haskell
12hhfe5,jfsw3ai,Regarding the safe part of Haskell: Rust functions are not necessarily referentially transparent while Haskell’s are.,0.25,Rust
12hhfe5,jfsw3ai,Haskell does not have a borrow checker or any notion of ownership or lifetime.,0.0,Haskell
12hhfe5,jfsw3ai,"In fact, Haskell doesn’t even have a notion of identity based on memory location.",0.0,Haskell
12hhfe5,jfsw3ai,Haskell uses lazy evaluation by default and Rust uses strict evaluation by default.,-0.25,Haskell
12hhfe5,jfsw3ai,Haskell uses lazy evaluation by default and Rust uses strict evaluation by default.,-0.25,Rust
12hhfe5,jfsw3ai,"As a result, infinite data structures can be directly defined in Haskell, but not so in Rust.",0.1,Haskell
12hhfe5,jfsw3ai,"As a result, infinite data structures can be directly defined in Haskell, but not so in Rust.",0.1,Rust
12hhfe5,jfsw3ai,Side effects are not controlled in Rust like they are in Haskell.,0.0,Rust
12hhfe5,jfsw3ai,Side effects are not controlled in Rust like they are in Haskell.,0.0,Haskell
12hhfe5,jfsw3ai,"A stronger argument is that Haskell has been used for years at Facebook for fighting spam, handling millions of requests per second.",0.0,Haskell
12hhfe5,jft8qop,"Secondly, there have been calls on various Rust forums encouraging people to go and vote actively, regardless of whether they actually use the language, know about the language, or love/hate the language.",-0.03333333333333333,Rust
12hhfe5,jft8qop,"Thirdly, the vast majority of users claiming to use Rust on a daily basis does not match up with the actual number of Rust users in the industry.",0.0,Rust
12hhfe5,jft8qop,"The vast majority of the people claiming to love Rust have actually either never used it, or have simply done a few tutorials on it.",0.06,Rust
12hhfe5,jft8qop,"Rust does have some features borrowed from Haskell, but Rust is a strongly imperative language while Haskell is a pure* Functional language.",0.32380952380952377,Rust
12hhfe5,jft8qop,"Rust does have some features borrowed from Haskell, but Rust is a strongly imperative language while Haskell is a pure* Functional language.",0.32380952380952377,Haskell
12hhfe5,jft9fdv,"Go read https://old.reddit.com/r/haskell/comments/12eu6ij/is_it_viable_to_get_your_first_programming_job/, for instance.",0.0,Go
12hhfe5,jft9fdv,"Both Haskell and Rust have failed in this regard, albeit for different reasons.",-0.25,Haskell
12hhfe5,jft9fdv,"Both Haskell and Rust have failed in this regard, albeit for different reasons.",-0.25,Rust
12hhfe5,jft9fdv,"Secondly, a language that requires knowledge of a subset of a million different ""extensions"" to the point that core members have to advocate for a return to ""Simple Haskell"" (which is, unfortunately, not powerful enough for most industry work) is symptomatic of deep issues within the language itself.",0.049999999999999996,Haskell
12hhfe5,jft9fdv,"Thirdly, for a very strongly typed language, Haskell is notorious for its atrocious error messages and it abysmal build and dependency tooling.",-0.04555555555555554,Haskell
12hhfe5,jft9fdv,"Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon), Jones (onto the disaster called ""Verse'), and the few jobs outside of some banks that were create due to Haskell evangelists have been drying up and dying off.",0.034999999999999996,Haskell
12hhfe5,jft9fdv,"Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon), Jones (onto the disaster called ""Verse'), and the few jobs outside of some banks that were create due to Haskell evangelists have been drying up and dying off.",0.034999999999999996,Rust
12hhfe5,jft9fdv,"Hell, I'd wager that Facebook probably uses more OCaml than it does Haskell.",0.5,Haskell
12hhfe5,jft9fdv,"Haskell has been moribund for some time, and it's deep issues not only with the language, but the very core design of the language and its community.",0.06666666666666667,Haskell
12hhfe5,jfxals9,"Java, C++, and C# all have *awful* type systems.",-1.0,Java
12hhfe5,jfxals9,"Java, C++, and C# all have *awful* type systems.",-1.0,C++
12hhfe5,jfxals9,"Java, C++, and C# all have *awful* type systems.",-1.0,C
12hhfe5,jfxals9,"Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,Java
12hhfe5,jfxals9,"Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,C++
12hhfe5,jfxals9,"Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,C
12hhfe5,jfxals9,"Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,Rust
12hhfe5,jfxals9,"Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,C
12hhfe5,jfxals9,"It's a nice, well considered language if a little verbose from its C aesthetics.",0.20625,C
12hhfe5,jfxals9,It's pretty much equivalent to Haskell's type system with a different syntax- it's all Hindley Milner + Type classes.,0.15,Haskell
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,Java
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,C++
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,C
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,Rust
12hhfe5,jg02x6k,> ... even though it's not remotely as expressive as Haskell's.,-0.4,Haskell
12hhfe5,jg02nov,"> Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.13333333333333333,Rust
12hhfe5,jg02nov,"> Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.13333333333333333,Haskell
12hhfe5,jg02nov,On what grounds do you claim Rust is both not as expressive as Haskell but more powerful?,0.5333333333333333,Rust
12hhfe5,jg02nov,On what grounds do you claim Rust is both not as expressive as Haskell but more powerful?,0.5333333333333333,Haskell
12hhfe5,jfsx5u1,"OK, I know neither Rust nor Haskell.",0.5,Rust
12hhfe5,jfsx5u1,"OK, I know neither Rust nor Haskell.",0.5,Haskell
12hhfe5,jfv06yg,And your analysis of simple Haskell is mostly flawed; many of us enjoy a broad amount of the extensions for the ability to great soundly typed programs with ease.,0.23750000000000002,Haskell
12hhfe5,jg028we,"> to the point that core members have to advocate for a return to ""Simple Haskell""   ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.32499999999999996,Haskell
12hhfe5,jg028we,"> to the point that core members have to advocate for a return to ""Simple Haskell""   ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.32499999999999996,Scala
12hhfe5,jg028we,"> to the point that core members have to advocate for a return to ""Simple Haskell""   ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.32499999999999996,Java
12hhfe5,jg028we,"> Hell, I'd wager that Facebook probably uses more OCaml than it does Haskell.",0.5,Haskell
12hhfe5,jg028we,Target uses Haskell for supply chain management... again core infrastructure.,0.0,Haskell
12hhfe5,jg028we,"> Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon),  Overblown.",0.25,Haskell
12hhfe5,jg028we,"> Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon),  Overblown.",0.25,Rust
12hhfe5,jg028we,"> Haskell has been moribund for some time, and it's deep issues not only with the language, but the very core design of the language and its community.",0.06666666666666667,Haskell
12hhfe5,jfxd5af,"> Java, C++, and C# all have awful type systems.",-1.0,Java
12hhfe5,jfxd5af,"> Java, C++, and C# all have awful type systems.",-1.0,C++
12hhfe5,jfxd5af,"> Java, C++, and C# all have awful type systems.",-1.0,C
12hhfe5,jfxd5af,Nowhere in your original post did you showcase anything that could only be solved by Haskell.,0.1875,Haskell
12hhfe5,jfxd5af,"> Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,Java
12hhfe5,jfxd5af,"> Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,C++
12hhfe5,jfxd5af,"> Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,C
12hhfe5,jfxd5af,OOP is orthogonal to Functional Programming - this is why languages like Scala still have them.,0.0,Scala
12hhfe5,jfxd5af,"Sure, it's a bit silly, but is it easier to use than, say, in Haskell?",0.0,Haskell
12hhfe5,jfxd5af,"Do a simple experiment - find a couple of colleagues with no experience in either Golang or Haskell, and teach them both error handling in both languages.",0.0,Haskell
12hhfe5,jfxd5af,"Again, in your original post you have made no mention of any feature remotely better solved (or indeed solely solved) by using something like Haskell.",0.4375,Haskell
12hhfe5,jfxd5af,"I'd be surprised if your average application, including the REST server and game that you mentioned were better solved in Haskell or practically any other randomly chosen static language.",-0.010714285714285707,Haskell
12hhfe5,jfxd5af,"Maybe you should showcase something in your projects where Haskell's uber type system was indispensable - either in expressiveness, performance, or both.",0.4,Haskell
12hhfe5,jfxd5af,"> Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,Rust
12hhfe5,jfxd5af,"> Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,C
12hhfe5,jfxd5af,"It's a nice, well considered language if a little verbose from its C aesthetics.",0.20625,C
12hhfe5,jfxd5af,It's pretty much equivalent to Haskell's type system with a different syntax- it's all Hindley Milner + Type classes.,0.15,Haskell
12hhfe5,jfxd5af,"I'm sorry, but Rust is nowehere near an ML.",-0.2,Rust
12hhfe5,jfxd5af,"Rust is the exact opposite - strongly imperative and with ubiquitous mutation with an intelligent system that can still provide strong guarantees (extending beyond just memory), and a type system with features inspired from ML and Haskell.",0.38333333333333336,Rust
12hhfe5,jfxd5af,"Rust is the exact opposite - strongly imperative and with ubiquitous mutation with an intelligent system that can still provide strong guarantees (extending beyond just memory), and a type system with features inspired from ML and Haskell.",0.38333333333333336,Haskell
12hhfe5,jfxd5af,Rust's type system in not equivalent to Haskell's by any stretch of the imagination.,0.0,Rust
12hhfe5,jfxd5af,Rust's type system in not equivalent to Haskell's by any stretch of the imagination.,0.0,Haskell
12hhfe5,jg1wr9w,Writing a REST server or a game is not where a language like Haskell shines compared to a run-of-the-mill static language.,0.04999999999999999,Haskell
12hhfe5,jfylt7b,"More interesting still is note (1) at the end: their startup wasn't written just in Lisp, but in Lisp, C and later Perl.",0.3333333333333333,Lisp
12hhfe5,jfylt7b,"More interesting still is note (1) at the end: their startup wasn't written just in Lisp, but in Lisp, C and later Perl.",0.3333333333333333,C
12hhfe5,jfylt7b,"More interesting still is note (1) at the end: their startup wasn't written just in Lisp, but in Lisp, C and later Perl.",0.3333333333333333,Perl
12hhfe5,jfylt7b,"Looking back at the beginning, it says it's written *primarily* in Lisp; funny how easily missed or ignored that bit.",0.27083333333333337,Lisp
12hhfe5,jfylt7b,"So, apparently Lisp and its macros is not quite all-powerful enough to do the whole job after all!",0.09999999999999999,Lisp
12hhfe5,jfylt7b,"Regarding Haskell, it's one of those languages I can admire but would never be able to use.",0.5,Haskell
12hhfe5,jfylt7b,I remember in a C forum where someone would post a 10-line Haskell solution to a task that took 100 or 200 lines of C. I would follow it up with a version that was maybe 15-20 lines but in my scripting language.,0.0,C
12hhfe5,jfylt7b,I remember in a C forum where someone would post a 10-line Haskell solution to a task that took 100 or 200 lines of C. I would follow it up with a version that was maybe 15-20 lines but in my scripting language.,0.0,Haskell
12hhfe5,jfylt7b,The difference was that the Haskell verson would be incomprehensible; it would be just too clever.,0.16666666666666666,Haskell
12hhfe5,jfx7c0f,And your analysis of simple Haskell is mostly flawed; many of us enjoy a broad amount of the extensions for the ability to great soundly typed programs with ease.,0.23750000000000002,Haskell
12hhfe5,jfx7c0f,This is the classic Scala varying feature subsets problem on steroids.,0.16666666666666666,Scala
12hhfe5,jfx7c0f,"Sure, but C++ (or C for that matter) are expected to be hard to build - too low-level (which Haskell is not).",0.036111111111111115,C++
12hhfe5,jfx7c0f,"Sure, but C++ (or C for that matter) are expected to be hard to build - too low-level (which Haskell is not).",0.036111111111111115,C
12hhfe5,jfx7c0f,"Sure, but C++ (or C for that matter) are expected to be hard to build - too low-level (which Haskell is not).",0.036111111111111115,Haskell
12hhfe5,jfx7c0f,Even Rust with its usually great `Cargo` tool often breaks down with native dependencies depending on the platform.,0.32222222222222224,Rust
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,Java
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,C
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,Ruby
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,Haskell
12hhfe5,jfx7c0f,"Also, the ""enlightenment"" achieved by Haskell (much like in the case of Lisps) is greatly over-exaggerated.",0.5,Haskell
12hhfe5,jfx7c0f,"Moreover, the situations involved in the creation of Viaweb, if you study them, will reveal that using Common Lisp was neither necessary for it to have succeeded, nor did it persist (Yahoo rewrote it in C++ IIRC).",-0.15,Lisp
12hhfe5,jfx7c0f,"Moreover, the situations involved in the creation of Viaweb, if you study them, will reveal that using Common Lisp was neither necessary for it to have succeeded, nor did it persist (Yahoo rewrote it in C++ IIRC).",-0.15,C++
12hhfe5,jg1ymt0,There is a reason why Scala failed - too many different paradigmatic feature subsets to the point where two teams would often end up not being able to work together because of the differing subsets that they'd settled upon.,0.125,Scala
12hhfe5,jg1ymt0,"So also for Haskell, and even a cursory search on the matter will prove that this is a problem.",0.0,Haskell
12hhfe5,jg1ymt0,"> ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.4333333333333333,Haskell
12hhfe5,jg1ymt0,"> ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.4333333333333333,Scala
12hhfe5,jg1ymt0,"> ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.4333333333333333,Java
12hhfe5,jg1ymt0,Target uses Haskell for supply chain management... again core infrastructure.,0.0,Haskell
12hhfe5,jg1ymt0,"The data about Haskell usage is conflicting and inconclusive, and may be definitely outdated, and that was for the large part due to people like Marlow who were evangelising it.",-0.1035714285714286,Haskell
12hhfe5,jg1ymt0,"I have a suspicion  they're transitioning large chunks of Haskell into other, more pragmatic languages, and OCaml is an excellent fit for that.",0.39785714285714285,Haskell
12hhfe5,jg3jfc3,The best kind - the absolute genius idea of looking at publicly available data which show that Haskell in the industry has been an unmitigated failure.,0.3766666666666667,Haskell
12hhfe5,jg0f7vn,"And yes, Haskell programs can be far too clever than they ought to be.",0.13333333333333333,Haskell
12hhfe5,jg0f7vn,"That is, it's *easy* to write *complex*, hard to understand code in java (think about all your Abstract classes or Proxies or Factories, God forbid an AbstractSingletonProxyFactoryBean), while other languages like Haskell tend to have *hard* to write code (i.e.",-0.11499999999999999,Haskell
12hhfe5,jfxp85q,In 2003 he noted that they wrote a C++ lisp interpreter for some of the files because they were still written in lisp.,0.0,C++
12hhfe5,jfxp85q,No language does parser combinators as well as Haskell at the moment.,0.0,Haskell
12hhfe5,jg3kjaa,What publicly available data shows Haskell in industry has been an unmitigated failure?,0.04166666666666666,Haskell
12hhfe5,jg3kjaa,"You pretend as if you are talking more empirically, but my anecdotal real world professional Haskell experience holds more weight than your ""used Haskell some"" combined with armchair opinions.",0.27999999999999997,Haskell
12hhfe5,jg3jqsk,"If you think that a REST server or a game requires Haskell's powerful type system, then you have bigger problems than you realise.",-0.03333333333333335,Haskell
12hhfe5,jg2a587,"> God forbid an AbstractSingletonProxyFactoryBean)  Yeah, try using Haskell to write one of those enterprise apps with a team of around 25-30 developers spread across 2-3 subteams.",0.0,Haskell
12hhfe5,jg2a587,"Java's abject simplicity (vis-a-vis Haskell) leads to inevitable verbosity, but also excellent maintainability.",0.5,Java
12hhfe5,jg2a587,"Java's abject simplicity (vis-a-vis Haskell) leads to inevitable verbosity, but also excellent maintainability.",0.5,Haskell
12hhfe5,jfy23jl,The homoiconicity of Lisp again is simply an artifact of its origins.,0.0,Lisp
12hhfe5,jfy23jl,after Lisp's birth.,0.0,Lisp
12hhfe5,jfy23jl,They are also Lisp-specific in the sense that Lisp needed them to become somewhat useful in the modern world.,0.25,Lisp
12hhfe5,jfy23jl,In 2003 he noted that they wrote a C++ lisp interpreter for some of the files because they were still written in lisp.,0.0,C++
12hhfe5,jfy23jl,"Here's his response, verbatim (if he's reading this, I hope he doesn't mind me sharing it here):  ""At the time I wanted to believe I'm better than other people, so I attached to Lisp.",0.1875,Lisp
12hhfe5,jfy23jl,"It's laughably naive, but you know what they say, it's a pity youth is wasted on the young :)  Lisp is a useful language to learn and program in for a few months.",0.014285714285714266,Lisp
12hhfe5,jfy23jl,Ruby and Python are the obvious suspects.,0.0,Ruby
12hhfe5,jfy23jl,Ruby and Python are the obvious suspects.,0.0,Python
12hhfe5,jfy23jl,Clojure's pretty good too.,0.475,Clojure
12hhfe5,jfy23jl,"I've dabbled in Common Lisp for many years myself, and came to the same conclusion.",0.06666666666666667,Lisp
12hhfe5,jfy23jl,"Just as with the Graham example, over-exaggerating things leads to disaster - like the first version of Reddit itself being in Common Lisp (despite having had no reason to), which resulted in a very unstable and immature product till they switched over to Python soon thereafter.",0.05000000000000001,Lisp
12hhfe5,jfy23jl,"Just as with the Graham example, over-exaggerating things leads to disaster - like the first version of Reddit itself being in Common Lisp (despite having had no reason to), which resulted in a very unstable and immature product till they switched over to Python soon thereafter.",0.05000000000000001,Python
12hhfe5,jfy23jl,No language does parser combinators as well as Haskell at the moment.,0.0,Haskell
12hhfe5,jfy23jl,"Hence why the more pragmatic Refinement Types (a la Liquid Haskell, Ada, or even Racket) became more dominant than Dependent Types.",0.5,Haskell
12hhfe5,jfy23jl,"Hence why the more pragmatic Refinement Types (a la Liquid Haskell, Ada, or even Racket) became more dominant than Dependent Types.",0.5,Ada
12hhfe5,jfy23jl,"""Referential transparency"" is no good when it comes at massive performance costs or when the whole point is rendered moot by more tractable type systems such as Rust's (or ATS') which can prove more useful and more powerful facts about mutation (which is much easier to use than immutability).",0.21500000000000002,Rust
12hhfe5,jfy23jl,So also with monads (which were a sort of hack to accommodate the lack of effects in Haskell to begin with) which have inspired streams in Java and enums in Rust (specifically for error handling).,0.0,Haskell
12hhfe5,jfy23jl,So also with monads (which were a sort of hack to accommodate the lack of effects in Haskell to begin with) which have inspired streams in Java and enums in Rust (specifically for error handling).,0.0,Java
12hhfe5,jfy23jl,So also with monads (which were a sort of hack to accommodate the lack of effects in Haskell to begin with) which have inspired streams in Java and enums in Rust (specifically for error handling).,0.0,Rust
12hhfe5,jg4azaw,"If you choose to ignore the non-existent job market in Haskell, the whole reddit thread from /r/haskell that I linked to in a comment in this post's comments about the difficulty of even securing a job in Haskell, about the migration of Haskell stalwarts away from Haskell, about literally every PL ranking out there, about the systemic flaws in the Haskell ecosystem, particularly its tooling, about the abject mess of extensions leading to innumerable SO posts by newbies (and even intermediates) confused by realworld Haskell projects, about the practically nil usage in the industry (or even in academia where OCaml is still more popular), then you are not only disingenuous, but also needlessly truculent and delusional.",0.048958333333333326,Haskell
12hhfe5,jg2awn4,With Haskell the code is really easy to read but often harder to write (but when you do it's very easy to maintain and deal with!).,0.3458333333333334,Haskell
12hhfe5,jg2ov47,"The former is inevitable, and the latter is practically non-existent in Java (or similar) whereas it's aplenty in languages with entire sub-languages and too many conceptual ideas in the language itself (Scala, Haskell, Idris et al).",0.08333333333333333,Java
12hhfe5,jg2ov47,"The former is inevitable, and the latter is practically non-existent in Java (or similar) whereas it's aplenty in languages with entire sub-languages and too many conceptual ideas in the language itself (Scala, Haskell, Idris et al).",0.08333333333333333,Scala
12hhfe5,jg2ov47,"The former is inevitable, and the latter is practically non-existent in Java (or similar) whereas it's aplenty in languages with entire sub-languages and too many conceptual ideas in the language itself (Scala, Haskell, Idris et al).",0.08333333333333333,Haskell
12hhfe5,jg2ov47,>  With Haskell the code is really easy to read but often harder to write (but when you do it's very easy to maintain and deal with!).,0.3458333333333334,Haskell
12hhfe5,jg2ov47,"This goes against every single complaint by beginners to Haskell who, having finished a book or two on Haskell, then jump into real world code to find themselves completely lost.",-0.017857142857142856,Haskell
12hhfe5,jg2ov47,"Hence the call for ""boring Haskell"" or ""Simple Haskell' (i.e,, the simple core language that is Haskell 98 or Haskell 2010 even).",-0.3333333333333333,Haskell
12hhfe5,jg2ov47,"As for maintainability, there is no empirical data that shows that type towers created using Haskell are more maintainable than say, in Java.",0.225,Haskell
12hhfe5,jg2ov47,"As for maintainability, there is no empirical data that shows that type towers created using Haskell are more maintainable than say, in Java.",0.225,Java
12hhfe5,jg2ov47,"One might imagine that at least refactoring would be rendered easier, but again due to the absymal state of tooling coupled with the horrendous error-reporting systems in Haskell, it's more of a pain in Haskell than in Java.",0.025000000000000005,Haskell
12hhfe5,jg2ov47,"One might imagine that at least refactoring would be rendered easier, but again due to the absymal state of tooling coupled with the horrendous error-reporting systems in Haskell, it's more of a pain in Haskell than in Java.",0.025000000000000005,Java
12hhfe5,jg2ov47,"It's about as meaningless as mocking Haskell's inability to compile to native binaries with no GC, or the fact that Haskell is non-strict by default.",-0.5,Haskell
12hhfe5,jg2ov47,Java is not one.,0.0,Java
12hdjdx,jfohab0,V8's tier 1 JavaScript compiler is a non-optimizing compiler.,0.0,JavaScript
12hdjdx,jfohab0,"To some extent sure, this is one of the motivations for Java.",0.5,Java
12hdjdx,jfohab0,"In Java, every method is virtual, so if you were to compile this naively, you would need to compile every call to an indirect vtable call and could not inline or perform any optimizations unless you absolutely know the runtime class of a value.",-0.04999999999999999,Java
12hdjdx,jfohab0,Haskell is another great example.,0.8,Haskell
12hdjdx,jfohab0,"Even though Haskell is probably one of the most static languages there are, it would absolutely benefit from JIT compilation!",0.4166666666666667,Haskell
12hdjdx,jfohab0,"GHC (the standard Haskell AOT compiler) performs a ton of demand analysis to try and optimize laziness out as much as possible, but it is limited by the information it has at compile time.",-0.023809523809523808,Haskell
12hdjdx,jfohab0,"Similarly, type classes are desugared into dictionaries (effectively structs of functions), which are (in the polymorphic case) compiled to indirect calls and cannot be inlined, similar to virtual calls in Java.",0.19999999999999998,Java
12hdjdx,jfohrwa,Clojure compiles all expressions to JVM bytecode at runtime and then runs it - is it a JIT?,0.0,Clojure
12hdjdx,jfojuel,"There are tools which can AOT compile Java Bytecode and CLR bytecode, but they put some limitations on the features available for use in the language - reflection is usually off the table.",0.07500000000000001,Java
12hdjdx,jfonx6x,"Also note that languages like Java are typically AOTed from source to bytecode, then JITed from bytecode to machine code.",-0.16666666666666666,Java
12hdjdx,jfonx6x,They did it that way to make it more easily portable (especially given stuff like the old Java applets).,0.25833333333333336,Java
12hdjdx,jfok4gn,"When you compile your app to CIL or Java Bytecode the result (theoretically) runs wherever the compatible VM is available; so you don't have to deploy to all these architectures yourself, just to one architecture.",0.2,Java
12hdjdx,jfok4gn,"for my Oberon+ implementation, where during development and debugging the code runs on the Mono VM; when ready the app can be either deployed as a CLR compatible assembly or AOT compiled to a specific architecture via generated C, reusing the existing, very powerful toolchains.",0.19666666666666668,C
12hdjdx,jfqh1fw,"Languages are most of the times compiled in IR, and even though the IR is sometimes the final product that is bundled to user, this is always understood to be an AOT (maybe you can say in Python is not AOT, as it is done transparently to you), but the JIT is the part of the runtime that executes the operations of the program on a target machine, typically by generating the binary code.",0.11111111111111112,Python
12hdjdx,jfqh1fw,"The main advantages of tracing JITs are multiple:   \- you compile sub-parts of program, meaning that this JIT time, even you do ""complex"" optimizations, it will not add up to much, so it is less ""JIT'tery"" (no pun intended :) )   \- basic blocks are layed out in memory linearly, so compared with a method compiler, that can be large (in Java you can have up-to 65K bytecodes, and if expanded in an IR that you interpret against, it could be a better part of a megabyte), typically these basic blocks are small and even with compiler's data structures, wouldn't go to high memory consumption   \- another amazing advantage for these JITs is that they can decide not to do it: if you would make a JIT for the entire method (like Java or Android would do it, or C#/CLR for that matter), if your JIT has a bug not to support division because your underlying processor doesn't have a division operation (like lower end ARM CPUs) and you don't want to add support for it, this is not an issue for tracing JITs, only blocks with divisions would not be JITted.",0.06297619047619049,Java
12hdjdx,jfqh1fw,"The main advantages of tracing JITs are multiple:   \- you compile sub-parts of program, meaning that this JIT time, even you do ""complex"" optimizations, it will not add up to much, so it is less ""JIT'tery"" (no pun intended :) )   \- basic blocks are layed out in memory linearly, so compared with a method compiler, that can be large (in Java you can have up-to 65K bytecodes, and if expanded in an IR that you interpret against, it could be a better part of a megabyte), typically these basic blocks are small and even with compiler's data structures, wouldn't go to high memory consumption   \- another amazing advantage for these JITs is that they can decide not to do it: if you would make a JIT for the entire method (like Java or Android would do it, or C#/CLR for that matter), if your JIT has a bug not to support division because your underlying processor doesn't have a division operation (like lower end ARM CPUs) and you don't want to add support for it, this is not an issue for tracing JITs, only blocks with divisions would not be JITted.",0.06297619047619049,C
12hdjdx,jfqh1fw,"If I would be you, depending on specifics of the language, I would try to convert it to JavaScript and run it in NodeJS if you want fast speed.",0.2,JavaScript
12hdjdx,jfqh1fw,"If you are familiar with Java, use Java code or Java bytecode to generate live code.",0.2556818181818182,Java
12hdjdx,jfqh1fw,"Or for C#, there are also many ways to generate C# or IL.",0.5,C
12hdjdx,jfoih60,"Ditto with Clojure generating bytecode, so only the JVM has a JIT.",0.0,Clojure
12hdjdx,jfqtntt,>I would try to convert it to JavaScript and run it in NodeJS if you want fast speed.,0.2,JavaScript
12hdjdx,jfqtntt,"If you are familiar with Java, use Java code or Java bytecode to generate live code.",0.2556818181818182,Java
12hdjdx,jfp3zk7,"You can also compile Clojure code to bytecode ahead of time, and even compile the bytecode to machine code ahead of time using Graal.",0.0,Clojure
12hdjdx,jfp3zk7,"**EDIT:** Clojure is even more nuanced in this regard, since an expression is compiled to bytecode on demand and then then the JVM profiles and compiles hot spots to machine code.",0.375,Clojure
12hdjdx,jfqk0wi,> I'd say that producing machine code is a criterion  That would disqualify Java Bytecode to WASM/JavaScript/V8 Bytecode JIT compilers.,0.0,Java
12hdjdx,jfqk0wi,As well as Java Bytecode to CIL JIT compilers.,0.0,Java
12hdjdx,jfqk0wi,"That would also disqualify JSP to Java Bytecode JIT compilers, as well as several other HTML/CSS template compilers which target JS, PHP, or some bytecode.",-0.0625,Java
12hdjdx,jfqk0wi,"That would also disqualify JSP to Java Bytecode JIT compilers, as well as several other HTML/CSS template compilers which target JS, PHP, or some bytecode.",-0.0625,PHP
12hdjdx,jfotuix,"I've usually seen the argument given with respect to Java, x86-to-x86 JITs and similar stuff, where things like branch prediction (or even vectorized instructions) rarely make up for the overhead.",0.016666666666666663,Java
12hdjdx,jft9ert,"If you consider that binary to binary translation is not your use-case, there were also dynamic languages which use tracing JITs used as far as my memory goes initially in Adobe's Flash and Firefox 3.x era, Android 2.2 up to version 4.4 (KitKat allowed you to use ""method JIT"" named ART), Lua and PyPy as you said.",0.03333333333333333,Lua
12hdjdx,jft9ert,So for your question: ActionScript and JS were using a tracing JIT.,0.0,ActionScript
12hdjdx,jft820j,"So most likely for your simplicity, to pass a function to a C API you have 2 options: either provide some template (like C++ templates) and this function is a stub, where you can even specify what interpreter function would be called to return the requested value.",0.25,C
12hdjdx,jft820j,"So most likely for your simplicity, to pass a function to a C API you have 2 options: either provide some template (like C++ templates) and this function is a stub, where you can even specify what interpreter function would be called to return the requested value.",0.25,C++
12hdjdx,jft820j,"When the threshold is met, assuming that there is no branch, when you see that a liner sequence is found by a number of times, a JIT would generate the code (you can use a C compiler for what it worth, compile it as a libSO/dll, load the function) and call it later",0.15,C
12gmxpt,,"Features I often like using are : sum types / Rust-like enums and generics  Here are the languages I'm considering and the potential downsides :  C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C++ : not really pleasant to work with for me, and like in C, I don't really like the header system  Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  Zig : am not really familiar with Zig but I'm willing to learn it if someone thinks it would be a good idea to write a JIT compiler in Zig  Nim : same as Zig, but (from what I know ?)",0.08784722222222223,C
12gmxpt,,"Features I often like using are : sum types / Rust-like enums and generics  Here are the languages I'm considering and the potential downsides :  C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C++ : not really pleasant to work with for me, and like in C, I don't really like the header system  Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  Zig : am not really familiar with Zig but I'm willing to learn it if someone thinks it would be a good idea to write a JIT compiler in Zig  Nim : same as Zig, but (from what I know ?)",0.08784722222222223,C++
12gmxpt,,"Features I often like using are : sum types / Rust-like enums and generics  Here are the languages I'm considering and the potential downsides :  C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C++ : not really pleasant to work with for me, and like in C, I don't really like the header system  Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  Zig : am not really familiar with Zig but I'm willing to learn it if someone thinks it would be a good idea to write a JIT compiler in Zig  Nim : same as Zig, but (from what I know ?)",0.08784722222222223,Rust
12gmxpt,,it seems to have an even smaller community  A popular choice seems to be C++ and honestly the things that are holding me back the most is the verbosity and unpracticality of the headers and the way I know of to do sum types (std::variant).,0.33999999999999997,C++
12gmxpt,,"I'm also really considering C, due to the simplicity and lack of stuff hidden in constructors destructors and others stuff.",-0.030555555555555548,C
12gmxpt,jflb5li,"Writing it in Rust should be fine, though it is by no means obligatory.",0.4166666666666667,Rust
12gmxpt,jflf8pe,"Any language that has bindings to libllvm, or that has libraries that emit llvm IR, combined with llvm's `ORC` JIT compiler: https://llvm.org/docs/ORCv2.html  If you're looking to roll your own, however, I would suggest Rust, as it has both good support for ""high level"" constructs (such as algebraic data types) and good support for more systems-level matters such as linking.",0.37999999999999995,Rust
12gmxpt,jfl0ss9,">Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  So do all the other options, but at least you can isolate and limit the unsafe bits.",-0.11875,Rust
12gmxpt,jfl0ss9,"I'd say Haskell might also be worth considering, at least.",0.0,Haskell
12gmxpt,jfmgn1n,As someone who writes a lot of Rust; the safety aspect of Rust is only one small bit.,-0.125,Rust
12gmxpt,jfmgn1n,You'll still get access to lots of libraries and the Rust language (which does a lot).,0.0,Rust
12gmxpt,jfmgn1n,"If you wanted reasons to favour some over others; I'd go for Rust, followed up by C++.",0.0,Rust
12gmxpt,jfmgn1n,"If you wanted reasons to favour some over others; I'd go for Rust, followed up by C++.",0.0,C++
12gmxpt,jfmgn1n,"Both have the most support for libraries and such to use (although obviously there is a lot for C too), and both would be the most useful to know in the future.",0.21666666666666667,C
12gmxpt,jfmgn1n,"C++ is used heavily in the industry today, and Rust use is growing heavily.",-0.2,C++
12gmxpt,jfmgn1n,"C++ is used heavily in the industry today, and Rust use is growing heavily.",-0.2,Rust
12gmxpt,jfmgn1n,C would be my third place choice (for similar reasons).,0.0,C
12gmxpt,jflk3j2,"The actual ""emit code and be able to call it"" part is particularly well-suited to C and not many other languages, but you could probably enjoy it more with a nice free Pascal.",0.2435185185185185,C
12gmxpt,jflk3j2,"The actual ""emit code and be able to call it"" part is particularly well-suited to C and not many other languages, but you could probably enjoy it more with a nice free Pascal.",0.2435185185185185,Pascal
12gmxpt,jflk3j2,"It's a bit less popular for historical reasons, but I find Pascal generally makes it easier to not get lost.",0.12083333333333335,Pascal
12gmxpt,jfm6god,"Assembly, X64 or ARM.",0.0,Assembly
12gmxpt,jfm6pk7,"If you're having trouble with Rust, I'd advise giving D a try.",-0.2,Rust
12gmxpt,jfm6pk7,"If you're having trouble with Rust, I'd advise giving D a try.",-0.2,D
12gmxpt,jfm6pk7,"You also get interop with [inline Assembly](https://dlang.org/spec/iasm.html) and [C](https://dlang.org/spec/importc.html), and [CTFE](https://dlang.org/spec/function.html#interpretation), for free.",0.4,Assembly
12gmxpt,jfm6pk7,"You also get interop with [inline Assembly](https://dlang.org/spec/iasm.html) and [C](https://dlang.org/spec/importc.html), and [CTFE](https://dlang.org/spec/function.html#interpretation), for free.",0.4,C
12gmxpt,jfm6pk7,"You can manually write FFIs with [C++](https://dlang.org/spec/cpp_interface.html) too, including supporting inheritance.",0.25,C++
12gmxpt,jfm6pk7,> C++ [...] sum types (std::variant).,0.0,C++
12gmxpt,jfoeapz,I'm giving my vote to Rust.,0.0,Rust
12gmxpt,jfoeapz,"The ""Haskell-lite"" type system and pattern matching are really handy for all things langdev, and at the same time it has all the bit-banging pointer-twiddling abilities that C and C++ have.",0.3,C
12gmxpt,jfoeapz,"The ""Haskell-lite"" type system and pattern matching are really handy for all things langdev, and at the same time it has all the bit-banging pointer-twiddling abilities that C and C++ have.",0.3,C++
12gmxpt,jflgxfd,Rust is probably the nicest language for writing compilers that exists right now.,0.2857142857142857,Rust
12gmxpt,jflte57,"Rust seems like a reasonable choice, since you know it.",0.2,Rust
12gmxpt,jflgpkn,"> C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C supports single-definition generics via the `_Generic` mechanism.",0.12708333333333333,C
12gmxpt,jflybpa,"Rust is probably the nicest out of these for the compiler on its own, an ML or Haskell might be even better.",0.55,Rust
12gmxpt,jflybpa,"Rust is probably the nicest out of these for the compiler on its own, an ML or Haskell might be even better.",0.55,Haskell
12gmxpt,jflybpa,"If you don't want to deal with all of Rust's safety guarantees, Zig, while quite small and quickly developing, is probably your best option.",0.3611111111111111,Rust
12gmxpt,jfmat31,The ruby JIT compiler is written in C and there is one written in Rust.,0.0,C
12gmxpt,jfmat31,The ruby JIT compiler is written in C and there is one written in Rust.,0.0,Rust
12gmxpt,jfnwp5m,Crystal lang?,0.0,Crystal
12gmxpt,jfl9k3r,"C: lacking basic amenities and the idiotic header files  C++: an insanely complex mound of flaws, and also idiotic header files combined with templates for snail compilation speeds  Rust: straitjacket language that dictates how you can or cannot structure your data.",-0.4083333333333333,C
12gmxpt,jfl9k3r,"C: lacking basic amenities and the idiotic header files  C++: an insanely complex mound of flaws, and also idiotic header files combined with templates for snail compilation speeds  Rust: straitjacket language that dictates how you can or cannot structure your data.",-0.4083333333333333,C++
12gmxpt,jfl9k3r,"C: lacking basic amenities and the idiotic header files  C++: an insanely complex mound of flaws, and also idiotic header files combined with templates for snail compilation speeds  Rust: straitjacket language that dictates how you can or cannot structure your data.",-0.4083333333333333,Rust
12gmxpt,jfl9k3r,"Tried it several times, don't want to touch it again  Zig: too new and unstable, buggy  Nim: buggy and has too many memory models, incoherent  D: has crappy garbage collector  Ada: nobody uses it and when I installed Gnat IDE it couldn't even build hello world  Vala: nice and compiles to C, but nobody uses it  Personally, I chose C and it's... palatable.",0.1727272727272727,D
12gmxpt,jfl9k3r,"Tried it several times, don't want to touch it again  Zig: too new and unstable, buggy  Nim: buggy and has too many memory models, incoherent  D: has crappy garbage collector  Ada: nobody uses it and when I installed Gnat IDE it couldn't even build hello world  Vala: nice and compiles to C, but nobody uses it  Personally, I chose C and it's... palatable.",0.1727272727272727,Ada
12gmxpt,jfl9k3r,"Tried it several times, don't want to touch it again  Zig: too new and unstable, buggy  Nim: buggy and has too many memory models, incoherent  D: has crappy garbage collector  Ada: nobody uses it and when I installed Gnat IDE it couldn't even build hello world  Vala: nice and compiles to C, but nobody uses it  Personally, I chose C and it's... palatable.",0.1727272727272727,C
12gmxpt,jfmnw5l,"Try Julia, it’s extremely productive!",-0.15625,Julia
12gmxpt,jfmnw5l,"The differentiable programming community for Julia is amazingly capable and you could absolutely tie into that and further, the broadcasting syntax and ability to write basically pythonic code and compile it like C is a game changer cuz you can implement crazy stuff without the separation front end vs backend.",-0.12,Julia
12gmxpt,jfmnw5l,"The differentiable programming community for Julia is amazingly capable and you could absolutely tie into that and further, the broadcasting syntax and ability to write basically pythonic code and compile it like C is a game changer cuz you can implement crazy stuff without the separation front end vs backend.",-0.12,C
12gmxpt,jfmnw5l,I really like the einsum package for Julia because it lets you make badass array code with one liner stencils,0.2,Julia
12gmxpt,jflbizw,I think for writing compilers Haskell deserves to make the list.,0.0,Haskell
12gmxpt,jfl7a1q,"The first choice may be Java or Scala, due JIT been crossplatform.",0.0625,Java
12gmxpt,jfl7a1q,"The first choice may be Java or Scala, due JIT been crossplatform.",0.0625,Scala
12gmxpt,jfl7a1q,"**  I considered once making my own JVM custom P.L., lile adding Delphi / C# real properties to a Java syntax alike P.L.",0.4,Delphi
12gmxpt,jfl7a1q,"**  I considered once making my own JVM custom P.L., lile adding Delphi / C# real properties to a Java syntax alike P.L.",0.4,C
12gmxpt,jfl7a1q,"**  I considered once making my own JVM custom P.L., lile adding Delphi / C# real properties to a Java syntax alike P.L.",0.4,Java
12gmxpt,jfl7a1q,It's an Open Source Crossplatform updated version of Pascal / Delphi / Mac Object Pascal.,0.0,Pascal
12gmxpt,jfl7a1q,It's an Open Source Crossplatform updated version of Pascal / Delphi / Mac Object Pascal.,0.0,Delphi
12gmxpt,jfl7a1q,"It would work similar to C++, but it's has better features like a better module system, and not messing with C /  C++ headers, or some of Java and JVM oddities.",0.3333333333333333,C++
12gmxpt,jfl7a1q,"It would work similar to C++, but it's has better features like a better module system, and not messing with C /  C++ headers, or some of Java and JVM oddities.",0.3333333333333333,C
12gmxpt,jfl7a1q,"It would work similar to C++, but it's has better features like a better module system, and not messing with C /  C++ headers, or some of Java and JVM oddities.",0.3333333333333333,Java
12gmxpt,jfl7a1q,"I started two internal crossplatform projects with Plain C and C++, and switched to FreePascal plus the Lazarus IDE, for productivity.",-0.10714285714285714,C
12gmxpt,jfl7a1q,"I started two internal crossplatform projects with Plain C and C++, and switched to FreePascal plus the Lazarus IDE, for productivity.",-0.10714285714285714,C++
12gmxpt,jfl7a1q,"Or, as you already mentioned, C++ ...",0.0,C++
12gmxpt,jfln77h,"I started writing a JIT compiler for a forth/lisp-like for x64 windows and linux  (and soon Aarch64 mac) 2 days ago in Rust,   it's going pretty well, but if I knew C++ or Zig I would have chosen them.",0.25,Rust
12gmxpt,jfln77h,"I started writing a JIT compiler for a forth/lisp-like for x64 windows and linux  (and soon Aarch64 mac) 2 days ago in Rust,   it's going pretty well, but if I knew C++ or Zig I would have chosen them.",0.25,C++
12gmxpt,jfln77h,Rust provides a lot of safety etc.,0.0,Rust
12gmxpt,jfs1qjt,"Delphi, or/and also see LLVM.",0.0,Delphi
12gmxpt,jfsxpii,Write in Common Lisp :),0.1,Lisp
12gmxpt,jfnsy2k,In some cases you want a completely different control flow to what Rust (or C) offers.,0.05,Rust
12gmxpt,jfnsy2k,In some cases you want a completely different control flow to what Rust (or C) offers.,0.05,C
12gmxpt,jfnsy2k,"Oh, and you probably want tail call optimization, which is not guaranteed in Rust.",0.0,Rust
12gmxpt,jfnsy2k,These would be a complete PITA if you are using Rust.,0.1,Rust
12gmxpt,jfllloi,"I haven't mentioned it in my post, but I plan on adding more things like a garbage collector and other stuff that would require precise memory manipulation (and doesn't play that well into Rust's rules for unsafe code)  That aside, Rust is definitely a strong contender",0.3020833333333333,Rust
12gmxpt,jflku5v,I really like Rust but I've tried to write a VM / bytecode interpreter already (somewhat different project) and in lots of places I felt like it was just needlessly painful,-0.16666666666666666,Rust
12gmxpt,jfl4os3,"And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) https://zackoverflow.dev/writing/unsafe-rust-vs-zig/",0.275,C
12gmxpt,jfl4os3,"And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) https://zackoverflow.dev/writing/unsafe-rust-vs-zig/",0.275,C++
12gmxpt,jfmhgmt,"(I didn't look into it much haha)  Rust seems to be recommended a lot, so I'm like 70% sure I'll end up using it.",0.35,Rust
12gmxpt,jflnhjh,\> particularly well-suited to C  It's true... C doesn't really have much competition in that niche haha  \> Pascal  Variant records seem like a very cool feature !,0.2809027777777777,C
12gmxpt,jflnhjh,\> particularly well-suited to C  It's true... C doesn't really have much competition in that niche haha  \> Pascal  Variant records seem like a very cool feature !,0.2809027777777777,Pascal
12gmxpt,jflnhjh,I'm considering learning Pascal now haha  \> All of this suggests JIT is a rather large project.,0.20714285714285713,Pascal
12gmxpt,jfogvus,One more Rust vote then !,0.625,Rust
12gmxpt,jfllbjz,"Currently the biggest reason I'd prefer Rust over C is, as you mentioned, the enums + match, as well as the module system which is just much better than C's headers",0.25,Rust
12gmxpt,jfllbjz,"Currently the biggest reason I'd prefer Rust over C is, as you mentioned, the enums + match, as well as the module system which is just much better than C's headers",0.25,C
12gmxpt,jflvsa6,"I also know C haha, but yeah I might go with Rust",0.2,C
12gmxpt,jflvsa6,"I also know C haha, but yeah I might go with Rust",0.2,Rust
12gmxpt,jflz358,"Hmm another Rust / Zig vote then  \>  It has powerful metaprogramming, sum types, a stripped down version of pattern matching while still being very low level and clear in what it's doing.",0.0611111111111111,Rust
12gmxpt,jg93hb3,"Rust why not, LLVM no because I'm creating my own stuff from scratch",0.6,Rust
12gmxpt,jfmhmhb,I linked that same article to someone else in the comments haha  But lots of people seem to recommend Rust.,0.1,Rust
12gmxpt,jfoj1uq,"Hmmm interesting suggestion, but Crystal seems to work with a GC with does not make it a great candidate for writing a JIT compiler with a GC",0.65,Crystal
12gmxpt,jfohazx,"(As you can see my previous project was in C++ haha)  Maybe there are better ways to do all those things I'm doing, but then I really don't know where to learn about that.",0.18333333333333335,C++
12gmxpt,jfohazx,"In fact, I grew a little tired of trying to look up the best way to do X in C++ every time I did something new just because there is so many ways to do X",0.20977272727272728,C++
12gmxpt,jfl4wim,And creating one from scratch in Python is ...far from being the best idea.,1.0,Python
12gmxpt,jflkl9n,I wouldn't call Rust a straightjacket language !,0.0,Rust
12gmxpt,jflkl9n,"But I agree that it's probably not the best choice in this case...  C is definitely a strong contender in my opinion, even with all the missing features",0.41111111111111115,C
12gmxpt,jfmdicc,"I think you're missing some FP options :) OCaml is ideal for writing PLs (Rust was originally written in OCaml) and Haskell is basically the same (in capability, not design) except with a larger non-academic community  ETA: Haskell isn't *great* for writing JITs.",0.3392857142857143,Rust
12gmxpt,jfmdicc,"I think you're missing some FP options :) OCaml is ideal for writing PLs (Rust was originally written in OCaml) and Haskell is basically the same (in capability, not design) except with a larger non-academic community  ETA: Haskell isn't *great* for writing JITs.",0.3392857142857143,Haskell
12gmxpt,jfmdicc,OCaml runs its own JIT though iirc it's written in C,0.6,C
12gmxpt,jfmmu9k,You can use D without a GC.,0.0,D
12gmxpt,jfmpgnr,"Well, I'll take a look at Julia, but from what I know it doesn't seem quite low level enough to create my own JIT compiler in it... Maybe I'm wrong though",0.024999999999999994,Julia
12gmxpt,jflmsr3,I'm not sure Haskell would be a great language for writing a JIT compiler (maybe I'll use it for the source -> IL compiler ?),0.275,Haskell
12gmxpt,jfl8i8u,"I will take a look at Pascal but I would've obviously preferred a more ""modern"" language haha  \> Java or Scala   I'm afraid those would be too slow for me, and I don't think the JVM has great support for directly manipulating memory",0.11249999999999999,Pascal
12gmxpt,jfl8i8u,"I will take a look at Pascal but I would've obviously preferred a more ""modern"" language haha  \> Java or Scala   I'm afraid those would be too slow for me, and I don't think the JVM has great support for directly manipulating memory",0.11249999999999999,Java
12gmxpt,jfl8i8u,"I will take a look at Pascal but I would've obviously preferred a more ""modern"" language haha  \> Java or Scala   I'm afraid those would be too slow for me, and I don't think the JVM has great support for directly manipulating memory",0.11249999999999999,Scala
12gmxpt,jflnqe1,"But Rust seems like a comfortable choice indeed haha, it's the one I know the best out of all three",0.5333333333333333,Rust
12gmxpt,jfml472,I personally struggle with Rust but see it’s pros and just can’t seem to get over it’s cons.,0.0,Rust
12gmxpt,jfml472,"D is good, GC *”unfortunately.”*  Zig seems powerful but young and buggy  Odin is also young and has bugs, but I haven’t encountered any issues for game making and simple programs.",0.04285714285714285,D
12gmxpt,jfs8rhv,"I won't use LLVM because the goal is to make my own JIT compiler, not use an existing one  I'll look into Delphi I don't really know anything about it",0.4,Delphi
12gmxpt,jfmbia3,"> precise memory manipulation  Rust lets you use lifetimes to precisely model memory, even in unsafe code.",0.4,Rust
12gmxpt,jfmbia3,"Rust gives you a lot of tools for encapsulating unsafe code in abstractions which provide safe APIs, with the compiler model checking how you manipulate memory.",0.5,Rust
12gmxpt,jflo40l,">And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) [https://zackoverflow.dev/writing/unsafe-rust-vs-zig/](https://zackoverflow.dev/writing/unsafe-rust-vs-zig/)  Depends on what you mean by ""better experience"".",0.184375,C
12gmxpt,jflo40l,">And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) [https://zackoverflow.dev/writing/unsafe-rust-vs-zig/](https://zackoverflow.dev/writing/unsafe-rust-vs-zig/)  Depends on what you mean by ""better experience"".",0.184375,C++
12gmxpt,jflo40l,In Rust you just run [MIRI](https://github.com/rust-lang/miri) which tells you exactly where you have undefined behavior as long as you have at least one test which exercises the affected code path.,-0.033333333333333326,Rust
12gmxpt,jfml45x,It is a mix a little like D.,-0.1875,D
12gmxpt,jflu081,I’ve written a couple interpreters in Free Pascal.,0.4,Pascal
12gmxpt,jfmu9w5,"IMO, C is easily the best contender for writing a JIT.",0.7166666666666667,C
12gmxpt,jfmu9w5,"C++ is a close second, since it can use most of the features, but I would probably avoid it, because to use most of its features you would probably end up getting tied into C++'s calling conventions.",0.3333333333333333,C++
12gmxpt,jfmu9w5,Using C can be a bit more powerful when you become familiar with the [GCC extensions](https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions).,0.39166666666666666,C
12gmxpt,jfmu9w5,"Another tool which is handy here is LuaJIT's [DynAsm](https://luajit.org/dynasm.html), which can interleave dynamic assembly into C code.",0.3,C
12gmxpt,jfmu9w5,"Although it is ugly, making use of the C preprocessor is useful for writing ""generics"", as you write templated code which essentially emits the monomorphized version of generics, and you can control how to dispatch yourself.",-0.13333333333333333,C
12gmxpt,jfmu9w5,"At some point, you will probably want an FFI in your language to make it useful, and that essentially means interfacing with the C calling convention.",0.15,C
12gmxpt,jfmu9w5,It's easier to do this when your runtime is in C too.,0.0,C
12gmxpt,jfmu9w5,I'm working on a runtime in C but it's not in a state ready to share yet.,0.2,C
12gmxpt,jfmu9w5,A possible option is to implement in another language but have it emit C code.,0.0,C
12gmxpt,jfn480t,Assembly is not binary.,0.0,Assembly
12gmxpt,jflpbtz,There's nothing stopping you from doing that in Rust.,0.0,Rust
12gmxpt,jflpbtz,See [rust-gc](https://github.com/Manishearth/rust-gc) for an example of a GC implemented in Rust.,0.0,Rust
12gmxpt,jflpbtz,"Another example is [mozjs](https://github.com/servo/mozjs), which is Rust bindings to SpiderMonkey.",0.0,Rust
12gmxpt,jflpbtz,"The GC there is implemented in C++, but it shows how you'd structure wrapper types for GC'd pointers in Rust so that you can use them safely, even with all the ""ugliness"" of a browser-grade GC.",0.1,C++
12gmxpt,jflpbtz,"The GC there is implemented in C++, but it shows how you'd structure wrapper types for GC'd pointers in Rust so that you can use them safely, even with all the ""ugliness"" of a browser-grade GC.",0.1,Rust
12gmxpt,jfm1en1,On the other Rust's unsafe story is still pretty work in progress.,0.0625,Rust
12gmxpt,jfo0n2e,In that C code in the first link it is straightforward.,0.3125,C
12gmxpt,jfog4an,"Julia itself is already a JIT build&run system, it has native support of AST generation/translation/compilation, you do LISP style homoiconic  AST manipulations, the running process will convert your AST to LLVM IR and compile to runnable machine code for you to call immediately.",0.0,Julia
12gmxpt,jfog4an,Also Julia is itself already GCed.,0.0,Julia
12gmxpt,jflg2u5,what you just said  Java has a foreign memory API now which includes replacements for sun.misc.Unsafe which was historically used for manual memory manipulation outside the JVM.,-0.041666666666666664,Java
12gmxpt,jflg2u5,It also includes a foreign function API that is meant to let you be able to call other native libraries directly from Java code.,0.0875,Java
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,C
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,C++
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,Python
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,Ruby
12gmxpt,jfljsd8,"Pascal ""been not modern or obsolete"" is just a tag applied by other P.L.",-0.1125,Pascal
12gmxpt,jfljsd8,"Unless you prefer C++, or even Rust.",0.0,C++
12gmxpt,jfljsd8,"Unless you prefer C++, or even Rust.",0.0,Rust
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,C++
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,Pascal
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,Delphi
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,Java
12gmxpt,jfljsd8,"Are you considering ""modern hyped"" Haskell or Python ?",0.2,Haskell
12gmxpt,jfljsd8,"Are you considering ""modern hyped"" Haskell or Python ?",0.2,Python
12gmxpt,jfmmw9h,"The C ABI is a proven means to integrate libraries, and C/C++ is the common choice for the majority of VMs I'm aware of.",-0.024999999999999994,C
12gmxpt,jfmrpsr,I think [Austral](https://borretti.me/article/introducing-austral) too will be a strong contender against these (esp Rust) in a few years.,0.11666666666666664,Rust
12gmxpt,jfmrpsr,"IMO, it has a better type system and borrowing approach than Rust, but is still at a very early stage and not production ready.",0.27666666666666667,Rust
12gmxpt,jfmi230,"I think the longer you keep something a reference, the more dangerous it is, because of Rust's aliasing rules (aka cannot have 2 mutable refs to the same region in memory).",-0.033333333333333326,Rust
12gmxpt,jfmi230,"Maybe I'm wrong though, I didn't look that much into unsafe Rust.",-0.15,Rust
12gmxpt,jfmoq3s,"I've heard about D as well, I'll take a look !",0.0,D
12gmxpt,jfos7h5,"Assembly _is_ binary, but it's not binary machine code.",0.0,Assembly
12gmxpt,jflvpnf,"Nothing is stopping me from implementing a GC in Rust, you're right, I'm just wondering if it's really the best choice for those kinds of things",0.49523809523809526,Rust
12gmxpt,jfmd5h3,> Rust's unsafe story is still pretty work in progress  Care to elaborate?,0.375,Rust
12gmxpt,jfoitdo,That's not really the hard part in Rust either,-0.19583333333333336,Rust
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,Java
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,C
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,C++
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,Rust
12gmxpt,jflis1i,Yes I had look to that ( Java interaction with outer platforms ).,0.0,Java
12gmxpt,jflmhq4,"I could probably use their JIT compiler through reflection, but it's not what I'm looking for, I'm looking to create my own  \> Unless you prefer C++, or even Rust.",0.6,C++
12gmxpt,jflmhq4,"I could probably use their JIT compiler through reflection, but it's not what I'm looking for, I'm looking to create my own  \> Unless you prefer C++, or even Rust.",0.6,Rust
12gmxpt,jflmhq4,"Out of all the languages I listed, I'm really considering C and Rust.",0.2,C
12gmxpt,jflmhq4,"Out of all the languages I listed, I'm really considering C and Rust.",0.2,Rust
12gmxpt,jflmhq4,I wouldn't use Haskell or Python either for a JIT compiler...,0.0,Haskell
12gmxpt,jflmhq4,I wouldn't use Haskell or Python either for a JIT compiler...,0.0,Python
12gmxpt,jflmhq4,"I'm looking for a low level language that's nicer to use than C or C++, and would better fit my use case than Rust.",0.3,C
12gmxpt,jflmhq4,"I'm looking for a low level language that's nicer to use than C or C++, and would better fit my use case than Rust.",0.3,C++
12gmxpt,jflmhq4,"I'm looking for a low level language that's nicer to use than C or C++, and would better fit my use case than Rust.",0.3,Rust
12gmxpt,jfmpr6u,"Well, thing is, most ""low level"" languages support the C ABI, so I still have a wide selection of languages to choose from.",0.13333333333333333,C
12gmxpt,jfmpr6u,Thinking of Rust and Zig.,0.0,Rust
12gmxpt,jfmkwae,"> I think the longer you keep something a reference, the more dangerous it is, because of Rust's aliasing rules  Lifetimes are there to ensure your references don't last longer than they should.",-0.033333333333333326,Rust
12gmxpt,jfpksdn,"Just for clarity, its RPython not Python.",0.0,Python
12gmxpt,jfpksdn,Its  a subset of python that is transcompiled to C and the compiler can automagically inserts a JIT compiler to your code.,0.0,C
12gmxpt,jj1b69y,"Well, Julia JIT compiles all your stuff, so you’d be able to use that as the scaffold and customize with macros and stuff.",0.5,Julia
12gmxpt,jj1b69y,But yeah maybe Python needs a JIT.,0.0,Python
12gmxpt,jj1b69y,Julia IS a JIT haha.,0.2,Julia
12gmxpt,jj1b69y,"I also got great results from making a Python graph class which can do a legit topological sort function on its data as a method and return a functional tf.keras.Model, if you’re doing linear algebra JIT compilation then that is a nice way to have something adjacent to the py data stack.",0.7,Python
12gmxpt,jj1b69y,"Hasura is a good compiler, but Haskell is pretty intense lol",0.4875,Haskell
12gmxpt,jfmpadf,"I personally don't think I'll generate complete executables from my IL, because I want to add a lot of reflection features into my language, and have it be able to change its IL at runtime then ask for recompilation (a bit like C# and the CIL)",0.19999999999999998,C
12gmxpt,jj3s4w7,"In that case, you might be better off sucking it up and writing it in rust to jit compile for Python, since Python does need a speed up, it would benefit a lot potentially.",0.25,Python
12gmxpt,jj3s4w7,"So a more generalized jit would be useful for Python developers for sure, especially if it could handle a wider variety of input terminal data types and function primitives than the current most popular Python JIT options (which you could benchmark your novel solution against to make a great clickbait blog post): numba, jax, tf.keras.Model.compile I think, I believe pytorch may have a jit, also PyPy is really good too, but it’s not a decorator for one function, it compiles your whole script.",0.41000000000000003,Python
12gmxpt,jj3s4w7,"The cpython team is also working on multiple ways to speed up Python which would be worth looking at but the Python version release schedule is pretty slow, 1x per year in October.",0.0625,Python
12gmxpt,jj3s4w7,"Finally, make sure to check out Codon, which came out this year as another allegedly super performant Python compiler.",0.27777777777777773,Python
12gmxpt,jj3s4w7,Let me know if Python wasn’t the language you wanted to compile and maybe we can think about the other language if there’s a different one to compile.,-0.0625,Python
12gmxpt,jjcul2a,I recommend Rust because it’s low level and focused on correctness and performance,0.0,Rust
12g5ekt,jfmo55k,"some C ""tricks"" like using the for statement as a quick hack to have something execute after every iteration instead of putting it at the end of a while is a bit annoying but fine.",-0.01666666666666668,C
12g5ekt,jfjlcj0,"Any FFI code intended to be linked with my VM must be recompiled using my `malloc`, as this is the only way I can ensure the C code does not interfere with the way I allocate memory.",0.0,C
12fkfij,jfi1ti6,"In a world where even purist functional programming communities are being taken over by the likes of Rust (which I like, tbc) and others, having the courage to publish something theoretically clean and satisfying without worrying about the semantics of reading from padding between struct fields feels refreshing.",0.45555555555555555,Rust
12fg0l6,jfflo17,"Not literally a null value, however I think Option/Maybe types and their accompanying monads in languages like Haskell and F# do basically this.",0.0,Haskell
12fg0l6,jffwkk2,"Generic functions in Common Lisp dispatch on all the (required) arguments, so one can add methods that dispatch if a parameter is nil (the CL null value.)",-0.15,Lisp
12fg0l6,jfgoiyk,Objective-C allows sending any message (== calling a method) to a nil pointer.,0.0,Objective-C
12fg0l6,jfgi03i,Many languages like Haskell or Rust enable your functions to return a monadic value `Option<X>` with thus being either `X` or `None`.,0.5,Haskell
12fg0l6,jfgi03i,Many languages like Haskell or Rust enable your functions to return a monadic value `Option<X>` with thus being either `X` or `None`.,0.5,Rust
12fg0l6,jfih0qx,"If someone understands what's meant by ""Applicative functors are the programming equivalent of lax monoidal functors with tensorial strength in category theory"" and they think that's something they need --- then they'll be delighted to learn that Haskell already exists.",0.55,Haskell
12fg0l6,jfjm1w1,"One way is to define the following:  1. a way to convert a value into an optional value (in Haskell this is called `pure` or `return`) 2. a way to apply an optional function to an optional argument to product an optional result (in Haskell this is the `<*>` operator)  Instead of (2), you could (equivalently) define a way to apply a function of two arguments to two optional arguments to produce an optional result.",0.10714285714285714,Haskell
12fg0l6,jfjm1w1,"Haskell calls this `liftA2`, but I'm sure you can come up with a better name.",0.5,Haskell
12fg0l6,jfjm1w1,"For example, in Haskell, the `pure`/`return`/`liftA2` functions and the `<*>` operator work for any applicative functor, not just the optional type (which Haskell calls `Maybe`).",0.4,Haskell
12fg0l6,jfjm1w1,"A common and good way to achieve this is what Rust calls ""traits"" and what Haskell calls ""type classes"".",0.19999999999999998,Rust
12fg0l6,jfjm1w1,"A common and good way to achieve this is what Rust calls ""traits"" and what Haskell calls ""type classes"".",0.19999999999999998,Haskell
12fg0l6,jfljqq3,"If this seems faintly shocking to you, then this is because you're thinking of the sorts of use-cases for FPLs for which one uses Haskell and ML.",-1.0,Haskell
12fg0l6,jfljqq3,"I'm thinking of the use-cases which are presently addressed by PHP, SQL, Python, and Microsoft Excel.",0.0,PHP
12fg0l6,jfljqq3,"I'm thinking of the use-cases which are presently addressed by PHP, SQL, Python, and Microsoft Excel.",0.0,Python
12ex1yj,jff6a0f,"This is essentially a recursive pointer structure, so it'll let you see how Jank compares to Clojure in that regard as well (also, you get another pretty picture).",0.125,Clojure
12ev4cm,jfdurj4,"Many other dynamic languages, especially Ruby, are close to Smalltalk in terms of 'purity'.",0.09375,Ruby
12ev4cm,jfdurj4,"Go was [inspired by Smalltalk](https://go.dev/talks/2015/gophercon-goevolution.slide#19) in its interface system - designer Rob Griesemer had worked on [Strongtalk](http://strongtalk.org/history.html), which added an F-bounded polymorphism type system to Smalltalk and was ultimately eaten by Java to become HotSpot.",0.0,Go
12ev4cm,jfdurj4,"Go was [inspired by Smalltalk](https://go.dev/talks/2015/gophercon-goevolution.slide#19) in its interface system - designer Rob Griesemer had worked on [Strongtalk](http://strongtalk.org/history.html), which added an F-bounded polymorphism type system to Smalltalk and was ultimately eaten by Java to become HotSpot.",0.0,Java
12ev4cm,jfdurj4,"Common Lisp has a multiple-inheritance, multiple-dispatch system that is less pure but still incredibly powerful, especially with its metaobject protocol.",0.009523809523809523,Lisp
12ev4cm,jfdurj4,"Most programmers kneejerk reaction to it is based on their encounters with Java and C++ in braindead college courses, blogposts, or whatever, that starts out by defining it in terms of data and procedures, or polymorphism, inheritance, and encapsulation (remember: the pie is a lie!).",0.625,Java
12ev4cm,jfdurj4,"Most programmers kneejerk reaction to it is based on their encounters with Java and C++ in braindead college courses, blogposts, or whatever, that starts out by defining it in terms of data and procedures, or polymorphism, inheritance, and encapsulation (remember: the pie is a lie!).",0.625,C++
12ev4cm,jfdx4tr,"Arguably this is proper Java style with getters/setters, but it's easy to accidentally circumvent, and requires much typing to achieve (or Lombok).",0.2111111111111111,Java
12ev4cm,jfded84,"For example, in Java, booleans are byte-sized and are defined as 0 and 1 behind the scenes.",-0.4,Java
12ev4cm,jfded84,"It's all done through various trickery like that; in a way, it's akin to how many versions of Lisp are defined within themselves.",0.25,Lisp
12ev4cm,jfded84,"Lastly, the Little Smalltalk is a complete system in a few thousand lines of C, making it very understandable.",-0.017499999999999995,C
12ev4cm,jfdq4b9,"There's a reason why ""let it crash"" systems like Erlang are so incredibly resilient and ""avoid errors at all cost"" systems crash and burn in the face of scaled up distributed concurrency, and it's related to Erlang's *combining* of both views of computing rather than just one, and the underlying reason is directly grounded in the fundamental fork in thinking about ""object orientation"" that happened in the late 1960s and early 1970s.",0.15999999999999998,Erlang
12ev4cm,jfd5x3g,Let's talk Java.,0.0,Java
12ev4cm,jfd5x3g,"In terms of OOP, the difference is mostly that Java added a lot of complexity and conceptual impurity.",0.5,Java
12ev4cm,jfd5x3g,"Some of the simplicity comes from the dynamism - the class/object distinction in Java, to some extent, is a reflection (hah) of a static/dynamic distinction, or of compile-time/run-time distinction, but no such thing exists in Smalltalk, so classes are objects and reflection is ""built-in"".",0.0,Java
12ev4cm,jfd5x3g,"Because they're all dynamic, Smalltalk's OOP model really isn't very far off from Python or Ruby (especially Ruby), which pretty much just split the difference between Smalltalk-y internals with a Java-like candy coating, mostly owing to Java's popularity.",0.18000000000000002,Python
12ev4cm,jfd5x3g,"Because they're all dynamic, Smalltalk's OOP model really isn't very far off from Python or Ruby (especially Ruby), which pretty much just split the difference between Smalltalk-y internals with a Java-like candy coating, mostly owing to Java's popularity.",0.18000000000000002,Ruby
12ev4cm,jfd5x3g,"Because they're all dynamic, Smalltalk's OOP model really isn't very far off from Python or Ruby (especially Ruby), which pretty much just split the difference between Smalltalk-y internals with a Java-like candy coating, mostly owing to Java's popularity.",0.18000000000000002,Java
12ev4cm,jfcua37,"In Java for example, not everything is an object.",0.0,Java
12ev4cm,jfcua37,"Java has primitive types and their counterpart boxed types (which are objects, or rather classes that can be instantiated to objects).",0.0,Java
12ev4cm,jfcua37,"In other OO languages that follow Smalltalk more closely, such as Ruby, everything _is_ an object.",0.125,Ruby
12ev4cm,jfdk358,Python and Ruby follow Smalltalk very closely.,0.2,Python
12ev4cm,jfdk358,Python and Ruby follow Smalltalk very closely.,0.2,Ruby
12ev4cm,jfdk358,"Java, JavaScript, C++ don’t, and aren’t as dynamic.",0.0,Java
12ev4cm,jfdk358,"Java, JavaScript, C++ don’t, and aren’t as dynamic.",0.0,JavaScript
12ev4cm,jfdk358,"Java, JavaScript, C++ don’t, and aren’t as dynamic.",0.0,C++
12ev4cm,jfd7m6w,"The OOP style of Java and C++ stems from Simula, which predates Smalltalk.",0.0,Java
12ev4cm,jfd7m6w,"The OOP style of Java and C++ stems from Simula, which predates Smalltalk.",0.0,C++
12ev4cm,jfd10ip,"Whereas in Java, exceptions were always out of place.",0.0,Java
12ev4cm,jfga95r,"Comparing Smalltalk and Java also risks getting lost in the static/dynamic divide, which may be interesting in itself but has no bearing on OOP .",0.5,Java
12ev4cm,jfga95r,"Also, objects are absolutely necessary for lazy evaluation, so Haskell couldn't exist withot being powered by objects.",-0.125,Haskell
12ev4cm,jfga95r,Getting back to Java code it can be either OOP or close to FORTRAN (or even FP).,0.0,Java
12ev4cm,jfhmgq0,"In Delphi, object properties are not used as references.",0.0,Delphi
12ev4cm,jfd9rlt,"**Classes vs Prototypes**  JavaScript / ECMAScript are ""Object Prototype"" based.",0.0,JavaScript
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,C++
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,Java
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,C
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,Pascal
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,Delphi
12ev4cm,jfd9rlt,"In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,C
12ev4cm,jfd9rlt,"In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,Delphi
12ev4cm,jfd9rlt,"In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,Pascal
12ev4cm,jfd9rlt,"P.  Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,Java
12ev4cm,jfd9rlt,"P.  Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,C++
12ev4cm,jfd9rlt,"Java and C++ comites keep avoiding them, while adding a lot of other ""fancy"" features, some of then unnecessary.",-0.2625,Java
12ev4cm,jfd9rlt,"Java and C++ comites keep avoiding them, while adding a lot of other ""fancy"" features, some of then unnecessary.",-0.2625,C++
12ev4cm,jfd9rlt,"version of PHP have each one, also a unusual way to support properties.",0.2,PHP
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,Java
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,C++
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,C
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,Delphi
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,PHP
12ev4cm,jfd9rlt,"**Message Passing vs Methods**  MacOS Objective -C is similar to C, but not like C++, supporting objects with a different syntax.",0.0625,C
12ev4cm,jfd9rlt,"**Message Passing vs Methods**  MacOS Objective -C is similar to C, but not like C++, supporting objects with a different syntax.",0.0625,C++
12ev4cm,jfd9rlt,"In C++, operations are perform thru local functions A.K.A.",0.0,C++
12ev4cm,jfd9rlt,"(s) took this concept also like Java, C#, Delphi.",0.0,Java
12ev4cm,jfd9rlt,"(s) took this concept also like Java, C#, Delphi.",0.0,C
12ev4cm,jfd9rlt,"(s) took this concept also like Java, C#, Delphi.",0.0,Delphi
12ev4cm,jfd9rlt,"But, in Java all methods are virtual, but their syntax is misleading.",0.0,Java
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,C
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,Delphi
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,C++
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,Java
12ev4cm,jfd9rlt,There was a version of Object Pascal that did supported message passing.,0.0,Pascal
12ev4cm,jfd9rlt,"Personally, Object Pascal (Delphi) is my preferred style and syntax.",0.0,Pascal
12ev4cm,jfd9rlt,"Personally, Object Pascal (Delphi) is my preferred style and syntax.",0.0,Delphi
12ev4cm,jfd9rlt,"C#, Java and Delphi added them later.",0.0,C
12ev4cm,jfd9rlt,"C#, Java and Delphi added them later.",0.0,Java
12ev4cm,jfd9rlt,"C#, Java and Delphi added them later.",0.0,Delphi
12ev4cm,jfd9rlt,"(s) like Java, a class can be used by itself as if it was an single existing object by itself that doesn't requires to be created or destroyed.",-0.07142857142857142,Java
12ev4cm,jfd9rlt,C# and Delphi added them in later versions.,0.0,C
12ev4cm,jfd9rlt,C# and Delphi added them in later versions.,0.0,Delphi
12ev4cm,jfd9rlt,It was originally conceived in a version of Pascal called Modula in response to the Plain C feature of including files.,0.08035714285714286,Pascal
12ev4cm,jfd9rlt,It was originally conceived in a version of Pascal called Modula in response to the Plain C feature of including files.,0.08035714285714286,C
12ev4cm,jfd9rlt,"C++ have a very simple version where you can group classes, types and functions in groups of code called ""namespaces"".",0.0,C++
12ev4cm,jfd9rlt,Java expanded those namespaces modules to be hierarchical instead of been as a single list.,-0.07142857142857142,Java
12ev4cm,jfd9rlt,"like Modular, Oberon and Ada had a more powerful but complex use of modules.",0.16666666666666666,Ada
12ev4cm,jfd9rlt,"(s), a module could also had a special Initialization function and a special finalization function similar to Constructors and destructors in objects   Delphi (Free Pascal) supports this.",0.2785714285714286,Delphi
12ev4cm,jfd9rlt,"(s), a module could also had a special Initialization function and a special finalization function similar to Constructors and destructors in objects   Delphi (Free Pascal) supports this.",0.2785714285714286,Pascal
12ev4cm,jfd9rlt,"In Java besides namespaces, static Classes are used as modules as well, using static methods and fields to emulate the initialization and finalization and global variables that a namespace doesn't support   Just my two cryptocurrency coins contribution.",0.3333333333333333,Java
12ev4cm,jfd0mgf,"C++, Java and their successors dropped this constraint, making objects imperative and mutable, which kinda defeats the purpose in most cases.",0.5,C++
12ev4cm,jfd0mgf,"C++, Java and their successors dropped this constraint, making objects imperative and mutable, which kinda defeats the purpose in most cases.",0.5,Java
12ev4cm,jfes4h6,Doesn’t seem too different than Python.,0.0,Python
12ev4cm,jfes4h6,Python doesn’t reduce if..else to methods but seems like everything else is doable?,0.0,Python
12ev4cm,jfdb4cy,"Python and Ruby are both older than Java, I believe.",0.16666666666666666,Python
12ev4cm,jfdb4cy,"Python and Ruby are both older than Java, I believe.",0.16666666666666666,Ruby
12ev4cm,jfdb4cy,"Python and Ruby are both older than Java, I believe.",0.16666666666666666,Java
12ev4cm,jffi6gc,"In Smalltalk, Ruby, Python you get a runtime exception, you can catch it or do reflection etc.",0.0,Ruby
12ev4cm,jffi6gc,"In Smalltalk, Ruby, Python you get a runtime exception, you can catch it or do reflection etc.",0.0,Python
12ev4cm,jffi6gc,In Python and Ruby you get a stack trace (or you're using Rails and you get ActiveBlackMagic behavior).,0.0,Python
12ev4cm,jffi6gc,In Python and Ruby you get a stack trace (or you're using Rails and you get ActiveBlackMagic behavior).,0.0,Ruby
12ev4cm,jffi6gc,In Java that does doesn't compile.,0.0,Java
12ev4cm,jfdr2x9,In what way is JavaScript not late bound?,0.15,JavaScript
12ev4cm,jffjjek,"> but Smalltalk actually had messages  That's true for Smalltalk-72, but Stmalltalk-76 onwards had polymorphism with compiled methods and dispatch based on lookup tables quite similar to Simula-67 (the ancestor of C++ and Java).",0.11666666666666665,C++
12ev4cm,jffjjek,"> but Smalltalk actually had messages  That's true for Smalltalk-72, but Stmalltalk-76 onwards had polymorphism with compiled methods and dispatch based on lookup tables quite similar to Simula-67 (the ancestor of C++ and Java).",0.11666666666666665,Java
12ev4cm,jffqwy2,You're using messages in the Smalltalk sense as soon as you use interfaces in Java.,0.0,Java
12ev4cm,jffswrf,">In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,C
12ev4cm,jffswrf,">In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,Delphi
12ev4cm,jffswrf,">In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,Pascal
12ev4cm,jffswrf,">Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,Java
12ev4cm,jffswrf,">Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,C++
12ev4cm,jffswrf,"(s) like Java, a class can be used by itself as if it was an single existing object by itself that doesn't requires to be created or destroyed.",-0.07142857142857142,Java
12ev4cm,jffswrf,Java classes and static methods are modules with scoped functions (that's what \*static\* means).,0.5,Java
12ev4cm,jfghbp4,"* People go on and on about Lisp machines, but they don’t have anything on Smalltalk.",0.0,Lisp
12ev4cm,jfghbp4,It’s like the Common Lisp condition system *but better.,0.1,Lisp
12ev4cm,jffcdr5,"Yeah, on principle, languages like Python and Ruby are much closer to Smalltalk than Java (even though the Hotspot JVM was historically derived from a Smalltalk VM).",0.1,Python
12ev4cm,jffcdr5,"Yeah, on principle, languages like Python and Ruby are much closer to Smalltalk than Java (even though the Hotspot JVM was historically derived from a Smalltalk VM).",0.1,Ruby
12ev4cm,jffcdr5,"Yeah, on principle, languages like Python and Ruby are much closer to Smalltalk than Java (even though the Hotspot JVM was historically derived from a Smalltalk VM).",0.1,Java
12ev4cm,jffcdr5,"To me, the most practical advantage of those languages over Java in daily programming is that classes are objects or at least first-class things, which means that constructors are normal (factory) methods and you don't need factories.",0.0875,Java
12ev4cm,jfffxkr,"In a 2019 discussion between three of the biggest names in concurrency in the world, Sir Tony Hoare said, with instant vigorous agreement from Carl Hewitt (creator of the Actor model) and Joe Armstrong (creator of Erlang), the key test of whether a PL has gotten concurrency right is that the same PL can be used to program communicating processes in software or hardware, occurring over arbitrary space and time scales, from less than nanometers to millions of miles (currently, and the scale is set to continuously increase) and less than nanoseconds to decades (and, again, the scale is set to continuously increase).",-0.018452380952380953,Erlang
12ev4cm,jfh51hl,"In reality, we do everything we can do reduce the cost of these calls across service boundaries; we have designed it to optimize all the way down to a few instructions plus a vtable call in many cases, but it's a dynamic optimization that requires the ability to deopt to a concurrent queue (I think the Erlang designers called is a ""post office box"" or something like that).",0.036111111111111094,Erlang
12ev4cm,jfh51hl,"Smalltalk was infamously insecure (it just was not designed to be secure), and its performance is often 10000%+ worse than C/C++/Rust, and 2500%+ worse than C#/Java/Javascript.",-0.225,C
12ev4cm,jffik4u,As I understand it Elixir is the most interesting.,0.5,Elixir
12ev4cm,jffik4u,* Scala.,0.0,Scala
12ev4cm,jffik4u,"I recall doubting they'd gotten it right when I last looked at where they went with unifying Akka with the PL itself, but that was a long time ago and they've released Scala 3 since then.",0.07857142857142857,Scala
12ev4cm,jfehzi8,"Ruby started life in 1993, with first people using it beside Matz in late 1995.",-0.024999999999999994,Ruby
12ev4cm,jfehzi8,"Java started as Oak somewhere in 1989, ~~Oracle~~ Sun started the Java Platform project in 1990, and first demos were shown in 1992.",0.25,Java
12ev4cm,jfehzi8,Python started life in december 1989.,0.0,Python
12ev4cm,jfh69lc,"They were all in the same ""generation"", but Python and Ruby both appeared before Java.",0.0,Python
12ev4cm,jfh69lc,"They were all in the same ""generation"", but Python and Ruby both appeared before Java.",0.0,Ruby
12ev4cm,jfh69lc,"They were all in the same ""generation"", but Python and Ruby both appeared before Java.",0.0,Java
12ev4cm,jfh69lc,"Java somehow got a huge bump from Netscape and the whole ""world wide web"" thing, which no one really understood, and therefore went crazy over (like bitcoin a few decades later).",-0.01428571428571426,Java
12ev4cm,jfh69lc,"Ruby took off when DHH released Ruby on Rails, which was a seriously amazing project for its time (but unfortunately, super inefficient).",0.4666666666666667,Ruby
12ev4cm,jfh69lc,"Python just kept on chugging along and growing its user base slowly, until it really took off about ten years ago for a couple different reasons, including big data analysis and ML workloads -- thanks to its easy C library integration.",-0.033333333333333354,Python
12ev4cm,jfh69lc,"Python just kept on chugging along and growing its user base slowly, until it really took off about ten years ago for a couple different reasons, including big data analysis and ML workloads -- thanks to its easy C library integration.",-0.033333333333333354,C
12ev4cm,jfezmz2,‘employee.name()’ is essentially a function call in JavaScript.,0.0,JavaScript
12ev4cm,jfgtjad,"> People go on and on about Lisp machines, but they don’t have anything on Smalltalk.",0.0,Lisp
12ev4cm,jffp0u4,I much prefer that kind of special case to Java's primitive types or Python's `len` is a function not a message.,0.38571428571428573,Java
12ev4cm,jffp0u4,I much prefer that kind of special case to Java's primitive types or Python's `len` is a function not a message.,0.38571428571428573,Python
12ev4cm,jfhoyzs,Just to clarify something for myself and for perhaps OP: the distinction that you're drawing isn't between Smalltalk and say Java.,0.0,Java
12ev4cm,jfhoyzs,You're more drawing a distinction between say Erlang and Java.,0.5,Erlang
12ev4cm,jfhoyzs,You're more drawing a distinction between say Erlang and Java.,0.5,Java
12ev4cm,jfhoyzs,"I think that the ""let it die"" attitude of Erlang does have nice properties w.r.t.",0.6,Erlang
12ev4cm,jfhoyzs,"overall system robustness (though only when married with a process supervision system, which Erlang also provides).",0.08333333333333333,Erlang
12ev4cm,jfhoyzs,And Erlang doesn't force that.,0.0,Erlang
12ev4cm,jfhoyzs,But you wouldn't want to use VHDL to program business applications.,0.0,VHDL
12ev4cm,jfh2z3i,"Thanks, I didn't know that about Erlang, and Pony, and didn't know Inko at all.",0.2,Erlang
12ev4cm,jfienjs,There might be some tricks around partial evaluation to get the dynamic case fast though; I recall they managed to optimise out reflection-heavy Ruby code.,0.03333333333333333,Ruby
12ev4cm,jfh7p4d,Java had a hugely funded marketing campaign.,0.4000000000000001,Java
12ev4cm,jfh6ta4,Java's type system is sound.,0.4,Java
12ev4cm,jfh6ta4,"There was a **bug** ([ACM paper](https://dl.acm.org/doi/10.1145/2983990.2984004)) reported a year or two back, accompanied by [a blog article](https://hackernoon.com/java-is-unsound-28c84cb2b3f) saying ""Java's type system is unsound"".",0.0,Java
12ev4cm,jfh6ta4,"However, there is a small but important difference between ""_there is a bug in the JDK that allows something unsound to compile and run_"", and ""_the Java type system is unsound_"".",0.07500000000000001,Java
12ev4cm,jfh7auo,"If B is a subtype of A, then Java allows you to pass as an argument (or return) an array of B where an array of A is specified in the type signature.",0.0,Java
12ev4cm,jfh7auo,Java's type system will allow you to call this method with an array of Dog which will blow up at runtime on the assignment to the array element.,0.0,Java
12ev4cm,jffeh4f,"In fact, Smalltalk is *more* static in some ways than JS, Python, Ruby: objects have a size and internal format fixed at the time their class declaration is compiled.",0.275,Python
12ev4cm,jffeh4f,"In fact, Smalltalk is *more* static in some ways than JS, Python, Ruby: objects have a size and internal format fixed at the time their class declaration is compiled.",0.275,Ruby
12ev4cm,jfi2hdr,Emacs is the closest thing we have to a Lisp machine.,0.0,Lisp
12ev4cm,jfi2hdr,I’m aware of some restoration projects to get a VM Lisp machine working but not very current on them.,0.125,Lisp
12ev4cm,jfi2hdr,You know how people always rave about REPL driven development with Common Lisp?,-0.3,Lisp
12ev4cm,jfh7r8u,Ruby 3.x gets close with Ractors.,0.0,Ruby
12ev4cm,jfhhz7a,"They're self-similar, but written in three different PLs -- Raku, nqp, and C -- and the ability to program what happens in each one is at a lower level than the prior one.",0.0,C
12ev4cm,jfhceqz,"Yet Sun simply relied on the Internet, Java's technical merit, and the efforts of one Kim Polese._""  The other article was 7 years later, talking about what Sun was talking about possibly spending in the future 🤣 ...  Look, I know a bit about Sun (and worked on the acquisition of Sun by Oracle), and there is one thing you can be certain of: Sun couldn't market its way out of a paper bag.",0.012755102040816325,Java
12ev4cm,jfl27te,For example I tried getting into Lisp a few times but reading books and trying stuff out just couldn’t keep me motivated.,-0.2,Lisp
12ev4cm,jgli10k,"But the experience will probably be similar to the one you've had with Lisp; in fact the active community is probably smaller (less open source implementations, less dialects, and less presence on social code plaforms)",-0.075,Lisp
12ev4cm,jfheksu,Sun did a great job marketing Java but how does one monetize a programming language?,0.8,Java
12ev4cm,jfheksu,"On the other hand, without Java, Sun would have sank (set?)",-0.125,Java
12ehsjf,jfb6m9b,"Past me was bit by rather messy mocking in Java which would break abstraction boundaries; I'd write that `findBlahByName` returns something, but `getAllBlahs` would do some default thing which was plain wrong.",-0.29107142857142854,Java
12ehsjf,jfb6m9b,"Though making any other language also elegantly solves the problem of using Java, so.",0.1875,Java
12ehsjf,jfb6m9b,"This was borne out of discussing how such a scheme might behave in Common Lisp for SICL, since thread-local GC was initially planned but we came up with several cases where repeated escapes ruin performance.",-0.075,Lisp
12ehsjf,jfb9tbv,"So I would like it to be an interactive system like Mathematica, and have a decent and efficient and correct way to implement all these computations that are basically pipelines of ""read some data, run some formulas, print results in CSV, generate a plot"" which are quite common in natural science (I am in the middle of developing one of these pipelines in C++ for a paper that I'm working on with my professor, by the way).",-0.008333333333333331,C++
12ehsjf,jfcjx5n,"* HTML: too verbose, no macros, middling conversion to bbcode.",0.0,HTML
12ehsjf,jfb2qzj,"A language that provides a way to specify multithreaded synchronisation at the language-level, as in a bit like in C++ how you can use RAII to do memory cleanup in your dtors, and like D's invariants; well, this imaginary language would encode senantics for shared access and critical sections in the language itself...",0.0,C++
12ehsjf,jfb2qzj,"A language that provides a way to specify multithreaded synchronisation at the language-level, as in a bit like in C++ how you can use RAII to do memory cleanup in your dtors, and like D's invariants; well, this imaginary language would encode senantics for shared access and critical sections in the language itself...",0.0,D
12ehsjf,jfh0z43,"Support for both true immutable types and internal asynchronous/concurrent services (concurrent actors, like Erlang processes).",0.175,Erlang
12ehsjf,jfdv3d4,"It's hard to explain in one go, but imagine the sort of small business/charity/school/department of a large business/etc that runs off a mess of Excel and Python and SQL and PHP, where someone needs to produce an app for the use of Jared and Samantha from Accounting ... this would all work much better if they had a bunch of [Charm](https://github.com/tim-hardcastle/Charm) services running off a Charm hub wrapped around their database.",-0.0004761904761904745,Python
12ehsjf,jfdv3d4,"It's hard to explain in one go, but imagine the sort of small business/charity/school/department of a large business/etc that runs off a mess of Excel and Python and SQL and PHP, where someone needs to produce an app for the use of Jared and Samantha from Accounting ... this would all work much better if they had a bunch of [Charm](https://github.com/tim-hardcastle/Charm) services running off a Charm hub wrapped around their database.",-0.0004761904761904745,PHP
12ehsjf,jfcn1hf,"We come from a background writing full stack webapps in Scala, and we're building a language that lets us do more of that with less obstacles.",0.15833333333333333,Scala
12ehsjf,jftdt54,"I am making the Lapla programming language with the goal of stopping all critical runtime errors (things that would cause the program to stop unexpectedly, like a panic in Rust or an uncaught exception in Java) **at compile time**.",0.05,Rust
12ehsjf,jftdt54,"I am making the Lapla programming language with the goal of stopping all critical runtime errors (things that would cause the program to stop unexpectedly, like a panic in Rust or an uncaught exception in Java) **at compile time**.",0.05,Java
12ehsjf,jftdt54,"The Lapla programming language transpiles to C and currently has basic number types, local and static variables, functions and namespaces, with references, structs, enums, generics and a standard library coming soon.",0.1,C
12ehsjf,jfcps47,Rust - because there definitely wasn't enough self righteous software Devs.,0.0,Rust
12ehsjf,jfbueqz,"Emscripten always assumes there is a C standard library present on the virtual machine, so it is an overkill for most such small programs.",0.05,C
12ehsjf,jfeq0sq,It's syntax is similar to MATLAB and Octave.,0.0,MATLAB
12ehsjf,jffl393,* Writing patterns directly in C (or C++) is kinda clumsy.,-0.09999999999999999,C
12ehsjf,jffl393,* Writing patterns directly in C (or C++) is kinda clumsy.,-0.09999999999999999,C++
12ehsjf,jffl393,"However, a fair amount of code in patterns in match.pd is still written in C using blocks { ... } because we haven't yet found a good enough set of abstractions to represent those in DSL.",0.4666666666666666,C
12ehsjf,jg6kz1x,I wrote [Jactl](https://jactl.io) as way to embed a scripting language into real-time Java applications where scripts would never block the execution thread making it suitable for event-loop/reactive applications.,0.55,Java
12ehsjf,jg6kz1x,"I didn't want to use a language which could invoke arbitrary Java code and create their own threads, or access the file system outside the control of the application developer.",0.16666666666666666,Java
12ehsjf,jfg262q,Seems Java's `synchronized` keyword does exactly this.,0.25,Java
12dod7u,,The language features both a tree-walk interpreter and a compiler that can translate programs written in Nox to Lua.,0.0,Lua
12dod7u,,"impure) approach it takes to functional programming (Nox features mutable reference cells and while loops) and its implementation of Hindley-Milner type inference, as well as by Lua for the more ""dynamic"" aspects of the language, such as polymorphic records (which behave a lot like Lua tables) and the idea that modules are just sequences of statements that can return values to be exported.",0.16666666666666666,Lua
12dod7u,,"While it would be possible to implement them with a combination of records, polymorphic variants and references, performance of the resulting code would probably be subpar compared to a built-in implementation exploiting Lua arrays.",0.0,Lua
12dod7u,jfspugd,"Does a Box of <A,B,...> fit inside a Box of Box of <A,B,C,...>?",0.4,C
12dadmy,,"It was first introduced in the [Flavors](https://www.softwarepreservation.org/projects/LISP/MIT/nnnfla1-20040122.pdf) system for the Lisp Machine, which also contained a mixin-based multiple inheritance system.",0.125,Lisp
12dadmy,,"Both of these features would be carried into the Common Lisp Object System, which also had multiple dispatch and generic functions.",-0.09999999999999999,Lisp
12dadmy,jf5uhjo,Ruby has `prepend` which mixes in a module “in front” of the current module instead of behind it in the inheritance chain.,-0.2,Ruby
12dadmy,jf61l8j,"Not sure if fully related (I'd have loved to see an example) but C# has a feature that allows you to have a lot of power over which methods compose to what, as long as you do it manually:  You can implement an interface method explicitly, e.g.",0.09999999999999999,C
12dadmy,jfa7qid,"""method combination"" is kind of a 1950s Lisp thing.",0.6,Lisp
12dadmy,jfhplg2,"There is now support for using mixins in Java :)  One of the Ecstasy developers [""ported"" the Ecstasy mixin concept to Java](https://github.com/xtclang/jmixin/blob/main/src/main/java/org/xtclang/jmixin/Mixin.java).",0.5,Java
12dadmy,jfib2od,> There is now support for using mixins in Java :)  Truly it is the Borg of languages.,0.5,Java
12dadmy,jfjd8zi,Java is just *gross* at this point and because of backward compatibility all anyone can even *suggest* to improve the language is adding more stuff on.,0.25,Java
12dadmy,jfk9is7,"I did mean to add an /s 😉  Also, that's just a library that one of the Ecstasy developers wrote, that adds mixin functionality to Java (as a library, not as part of the language).",-0.3125,Java
12dadmy,jfk9is7,"I'm sure if Ecstasy takes off, Java will add mixins, but until then, you'll have to get by with the library ...",0.5,Java
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,Python
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,Bash
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,Java
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,C
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,Go
12d5dek,jf4y6qg,"If you really hate Java then the Go book is pretty much the same thing as crafting interpreters, but in go.",-0.08750000000000001,Java
12d5dek,jf4y6qg,"If you really hate Java then the Go book is pretty much the same thing as crafting interpreters, but in go.",-0.08750000000000001,Go
12d5dek,jf8yhyv,I did it in TypeScript and had a lot of fun!,0.375,TypeScript
12d5dek,jf8yhyv,"There's no need to hate on Java, it's perfectly fine for the job and a good choice for an educational book like Crafting Interpreters.",0.14166666666666666,Java
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,Kotlin
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,Dart
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,Java
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,Python
12d5dek,jf51slf,"Hi again 😁  If you really need help choosing, go for Writing an interpreter in Go.",0.2,Go
12d5dek,jf51slf,It seems like you’re already interested in learning  Go; this book is a pretty good for getting started with it.,0.39999999999999997,Go
12d5dek,jf51slf,"I love Crafting interpreters, but it’s written while heavily relying on the chosen implementation languages (Java and C).",0.15,Java
12d5dek,jf51slf,"I love Crafting interpreters, but it’s written while heavily relying on the chosen implementation languages (Java and C).",0.15,C
12d5dek,jf51slf,"Writing an interpreter in Go has a sequel that builds on it, called Writing a compiler in Go.",0.0,Go
12d5dek,jf86nvi,"I find ""Writing and interpreter in Go"" a bit more approachable than the first part of Crafting Interpreters (which is the part that covers the same topics covered in the interpreter book).",0.25,Go
12d5dek,jf86nvi,"The first part of crafting interpreters uses Java but not only it does uses java, but it goes with a technique that I found a bit weird which was generating java code and classes which I personally found hard to understand and a bit unnecessary to me, given that I was following the book using JS.",-0.13452380952380955,Java
12d5dek,jf79nc2,"JLox could easily be rewritten in Go, or pretty much any high-level language.",0.29444444444444445,Go
12d5dek,jf79nc2,"C isn't the only such language, but I'd argue that even Rust is a bit higher-level than you want: the safety features of Rust get in the way of some tricks which CLox uses to achieve its performance.",0.0,C
12d5dek,jf79nc2,"C isn't the only such language, but I'd argue that even Rust is a bit higher-level than you want: the safety features of Rust get in the way of some tricks which CLox uses to achieve its performance.",0.0,Rust
12d5dek,jf79nc2,Go is even higher-level than Rust.,0.0,Go
12d5dek,jf79nc2,Go is even higher-level than Rust.,0.0,Rust
12d5dek,jf79nc2,"You'd certainly learn from inventing Go solutions to the problems covered in the book, but I think you'd be diverging from what's in the book so far that the book isn't really a useful part of that process.",0.20476190476190478,Go
12d5dek,jf79nc2,"Given how much of the programming world is built on C, I think it's a useful thing to learn.",0.25,C
12d5dek,jf5xwdb,"However, to get your feet wet with programming language development I recommend (as always) [Compiling to Assembly from Scratch](https://keleshev.com/compiling-to-assembly-from-scratch/).",-0.1,Assembly
12d5dek,jf5xwdb,It is using TypeScript to write a compiler but teaches you some basics that will be useful for writing an interpreter too.,0.3,TypeScript
12d5dek,jf5xwdb,This book translates this approach reasonably well into TypeScript.,0.2,TypeScript
12d5dek,jf5xwdb,"To quote from the page:  > If you’re into statically-typed functional programming languages (Haskell, OCaml, or Reason ML), you will find that the class structure I used has a nice translation to an algebraic data type.",0.55,Haskell
12d5dek,jflxgth,Follow the first half by translating jlex into Python.,0.04166666666666667,Python
12d5dek,jflxgth,"If you don't like C, try Pascal.",0.0,C
12d5dek,jflxgth,"If you don't like C, try Pascal.",0.0,Pascal
12d5dek,jflxgth,"Yes, you'll be learning Pascal along the way, but you'll only actually need basic core-language stuff for this particular journey so it should not be a big problem.",0.03333333333333333,Pascal
12d5dek,jfmaybj,"Some nice options would be: Zig, C++, Odin, C among others.",0.6,C++
12d5dek,jfmaybj,"Some nice options would be: Zig, C++, Odin, C among others.",0.6,C
12d5dek,jf6uqva,"+1, I went thru Crafting Interpreters in Dart of all things.",0.0,Dart
12d5dek,jf4ym19,"I like Go as a lang over Java, just looks simpler and less bloated, easier to learn, less terse, modern",-0.04444444444444443,Go
12d5dek,jf4ym19,"I like Go as a lang over Java, just looks simpler and less bloated, easier to learn, less terse, modern",-0.04444444444444443,Java
12d5dek,jf52feg,"Yeah I think that’s confirmed the choice for me 🥹 really excited to pick it up, always really fun experience learning a new language (unless it’s Bash lol)",0.40227272727272734,Bash
12d5dek,jf5rrjb,"In my experience, Part 1 can be written in any language, although I wouldn’t recommend doing it in C, you can do it in Rust (with reference counting, probably) or Kotlin or JS.",0.0,C
12d5dek,jf5rrjb,"In my experience, Part 1 can be written in any language, although I wouldn’t recommend doing it in C, you can do it in Rust (with reference counting, probably) or Kotlin or JS.",0.0,Rust
12d5dek,jf5rrjb,"In my experience, Part 1 can be written in any language, although I wouldn’t recommend doing it in C, you can do it in Rust (with reference counting, probably) or Kotlin or JS.",0.0,Kotlin
12d5dek,jf80dyx,but it makes a lot of sense  so ig just go ahead and pick any language you want to follow Crafting Interpreters with  when I was reading it I picked Rust because I knew it had a C part and I really didn't want to write C,0.2,Rust
12d5dek,jf80dyx,but it makes a lot of sense  so ig just go ahead and pick any language you want to follow Crafting Interpreters with  when I was reading it I picked Rust because I knew it had a C part and I really didn't want to write C,0.2,C
12d5dek,jf5hl3j,They must have irrational love for Java or something.,0.5,Java
12d5dek,jf7cej8,"Java has a much more powerful type system, a more mature ecosystem, and is extremely portable.",0.255,Java
12d5dek,jf7cej8,"Java made some mistakes which newer languages had the benefit of learning from, and some languages (such as C#) have learned from those mistakes and improved.",0.0,Java
12d5dek,jf7cej8,"Java made some mistakes which newer languages had the benefit of learning from, and some languages (such as C#) have learned from those mistakes and improved.",0.0,C
12d5dek,jf7cej8,"My biggest critique of Go is that there are many cases where they \*didn't\* learn from the mistakes of previous languages, instead initially opting for macros (go generate) over generics, and now finally adding a bolted-on implementation of generics after learning the hard way that macros are bad (which everyone else already knew).",-0.10972222222222221,Go
12d5dek,jf7cej8,"And look: Go has some real upsides over Java, too.",0.2,Go
12d5dek,jf7cej8,"And look: Go has some real upsides over Java, too.",0.2,Java
12d5dek,jf7cej8,"My point isn't that Go is bad, or that Java is good, it's that both these languages have their positives and negatives, and are the right tools for different jobs.",0.07142857142857145,Go
12d5dek,jf7cej8,"My point isn't that Go is bad, or that Java is good, it's that both these languages have their positives and negatives, and are the right tools for different jobs.",0.07142857142857145,Java
12d5dek,jf8udi8,"I implemented clox in Rust, using the GC approach I described to provide a mark and sweep, compacting GC.",0.0,Rust
12d5dek,jf72b4h,"So, what's stopping you from writing a GC in Go that nulls out or removes the items from the list instead of using free()?",0.4,Go
12d5dek,jf5hn4y,"Sorry I meant Go is less Verbose it seems than Java, and more concise!",-0.010416666666666657,Go
12d5dek,jf5hn4y,"Sorry I meant Go is less Verbose it seems than Java, and more concise!",-0.010416666666666657,Java
12d5dek,jfbeqdx,"I *have* gone through the book, and I'm telling you that C was chosen as the language for the second half of the book for reasons that you can't simply ignore because you don't like C.  There *are* other language that would work, but a language that doesn't let you manually manage memory simply won't work.",-0.05833333333333333,C
12d5dek,jf754xe,Modern Java is refreshingly terse and expressive.,0.5,Java
12d5dek,jf5rvxa,I’m planning on doing the Go book/s then crafting interpreters,0.0,Go
12czblp,,"I've revised the syntax and going to pick up ""Writing an interpreter in Go"" and learn Go to undertake this challenge.",0.0,Go
12czblp,,"true: false          // Loop modifier ""%""     {% i=0; i<10; i++,        // do stuff     }          // Function modifier #, params with ""..."", return with ""@""     sum = {# ...a, ...b,              @ a + b           }     product = {# ...c, ...d, @ c * d}          // Function chaining with ""->"" and placeholder return value ""$""     out = sum(1, 2) -> product($, 4)          // Try block modifier ""++"", Catch block modifier ""--""     {++       // try code     } {--        // catch code     }          // Scoped code blocks:     {       x = 0       y = 0     }  ... just syntax-wise, I converted one of my Python programs to this syntax to get an idea of how it all comes together.",-0.26666666666666666,Python
12czblp,jf50u2g,I feel like languages fall into 3 extremes: 1 where keywords get in the way a lot of the languages expressiveness (Java) but offer flexibility; and the other where syntax is poor or confusing (Bash) and less flexible.,-0.24791666666666665,Java
12czblp,jf50u2g,I feel like languages fall into 3 extremes: 1 where keywords get in the way a lot of the languages expressiveness (Java) but offer flexibility; and the other where syntax is poor or confusing (Bash) and less flexible.,-0.24791666666666665,Bash
12czblp,jf50u2g,"I feel like I’m similar to Bash, but trying to make the syntax much more concise.",0.19999999999999998,Bash
12czblp,jf50u2g,"I’m really inspired by the Pug templating language which rethinks HTML with block modifiers, and find it really beautiful and easy to pick up and understand.",0.49444444444444446,HTML
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,Bash
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,Python
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,JavaScript
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,C
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,Rust
12czblp,jfbyfnm,"And to be fair, I don't think many people think too deep about how the meaning of `static` relates to its use in Java, C, or C++.",0.425,Java
12czblp,jfbyfnm,"And to be fair, I don't think many people think too deep about how the meaning of `static` relates to its use in Java, C, or C++.",0.425,C
12czblp,jfbyfnm,"And to be fair, I don't think many people think too deep about how the meaning of `static` relates to its use in Java, C, or C++.",0.425,C++
12czblp,jfbyfnm,"""wasabi language"" should work pretty well to disambiguate... it works well for Rust, after all.",0.25,Rust
12czblp,jf56j1d,"Consider how Typescript is built on top of Javascript, or Kotlin on top of Java.",0.5,Kotlin
12czblp,jf56j1d,"Consider how Typescript is built on top of Javascript, or Kotlin on top of Java.",0.5,Java
12cj0b3,jfli0f8,"Here's mine, written in Python: [https://github.com/kjosib/booze-tools](https://github.com/kjosib/booze-tools) It also has a few extra bits.",-0.31666666666666665,Python
12cc5ib,,"The idea is it's a fully keyword-less syntax inspired by APL (but using only what's on your keyboard) for the base language, immutable by default, with special modifiers.",-0.14761904761904762,APL
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,APL
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,Bash
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,Rust
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,Python
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,HTML
12cc5ib,jf2k7vp,"I’m currently working on my own language as well, and I’m using Writing an Interpreter in Go and Make A Lisp as references, as well as Crafting Interpreters.",0.3,Go
12cc5ib,jf2k7vp,"I’m currently working on my own language as well, and I’m using Writing an Interpreter in Go and Make A Lisp as references, as well as Crafting Interpreters.",0.3,Lisp
12cc5ib,jf2k7vp,"I personally think that you should hold off on learning Rust for building this project, especially if performance is not a top priority.",-0.08333333333333333,Rust
12cc5ib,jf2k7vp,"It’s going to take a tremendous effort to learn a new language (let alone Rust, which is already super difficult to learn to use properly), while also trying to learn a new concept.",0.07323232323232322,Rust
12cc5ib,jf2k7vp,"Personally, I’m familiar with Go, so I’m using Go for my own.",0.4875,Go
12cc5ib,jf2k7vp,"Trust me, I’m having to suppress my urges to learn Rust every day 😁",0.0,Rust
12cc5ib,jf0x3cu,"Given my programming experience (3 YOE, fullstack - python, node, JavaScript, typescript, bash)  How long do you reckon it would take to make a very basic interpreter and what language should I write the interpreter with?",-0.025,JavaScript
12cc5ib,jf2pvj6,"If you want a keyword-less language, you should also have a look at Lisp (like Common Lisp, Scheme, etc.).",-0.3,Lisp
12cc5ib,jf2pvj6,"If you want a keyword-less language, you should also have a look at Lisp (like Common Lisp, Scheme, etc.).",-0.3,Scheme
12cc5ib,jf2pvj6,```  Which is extensible for else-if like in Arc Lisp:  ``` {?,0.0,Lisp
12cc5ib,jf2pvj6,"Would probably look like this:  ```Rust struct Program {      expressions: Vec<Expression>, }  enum Expression {     Assignment(name: String, Block),     Block(Block),     FunctionCall { // like ""say""         name: String,         arguments: Vec<Expression>,     },     ... }  struct Block {     symbol: String, // would be ""?&"" for else-if     arguments: Vec<Expression>, } ```  It would be nice if you could define your own syntax (similar to macros or reader macros).",0.39999999999999997,Rust
12cc5ib,jf2o50w,"Not sure where to start with typescript because I haven’t seen any good books for it, I’ve definitely heard of Writing an Interpreter in Go - should I learn Go?",0.15,Go
12cc5ib,jf2ox5z,"Something else you can do is following the first half of Crafting Interpreters, which is written with Java in the book, but using Typescript.",0.02777777777777778,Java
12cc5ib,jf25l0p,I’m guessing C would be the best bet?,1.0,C
12cc5ib,jf25l0p,As in lowest barrier to learn (besides all the C lack of safety),0.0,C
12cc5ib,jf4kb91,"Rust got it from C++, actually.",0.0,Rust
12cc5ib,jf4kb91,"Rust got it from C++, actually.",0.0,C++
12cc5ib,jf26p9l,I'd recommend C++ or Rust.,0.0,C++
12cc5ib,jf26p9l,I'd recommend C++ or Rust.,0.0,Rust
12cc5ib,jf26p9l,"With C, you don't get features like RAII (destructors), methods, and generics.",0.0,C
12cc5ib,jf26p9l,"Since you're coming from higher level languages, I think you'd be better with Rust.",0.375,Rust
12cc5ib,jf2ntvh,Works the same way JavaScript works eg (sorry on mobile)  if () { } if () { } else { }  Would be parsed as IF (IF ELSE) etc,-0.25,JavaScript
12cc5ib,jf4kjf3,"I saw it in Rust and really liked it, assumed most languages used dot notation .",0.55,Rust
12cc5ib,jf272uu,Thanks I’ve been itching for a reason to learn Rust so this could be really fun.,0.25,Rust
12cc5ib,jf2f99i,"Rust also has some really good tooling for writing languages… Stuff like rowan, logos, nom, etc., all make writing things really nice… Rowan is a library for lossless syntax trees (no parsing is handling with it, it just provides a way for you to abstractly represent your syntax tree in a manner that is, well, lossless.",0.44999999999999996,Rust
12cc5ib,jf2f99i,"Rust-analyzer, the current LSP for Rust, uses it internally).",0.0,Rust
12cc5ib,jf2fjaq,Exciting 🦀 looks like I’ll be learning Rust 🦀🦀,0.3,Rust
12cc5ib,jf2f67o,"Thank you, I’ll have a bit of a read up and see how Doable and convenient it is - else I’ll take your advice and investigate Rust!",0.0,Rust
12cc5ib,jf2hggi,"Errors: https://crates.io/crates/codespan-reporting  Depending on how you plan on using it, you might find it worthwhile to look into `parking_lot` and `tokio` for concurrency (Rust's `async` is similar to JS).",0.25,Rust
12bui3u,,"There are currently two ways to compile multiple JavaScript files into a portable executable:  * **The Electron way:** This will ship a browser inside the executable, along with DLLs to make it portable.",0.0,JavaScript
12bui3u,,"The shipped browser interprets the compiled JavaScript code to run itself, and the shipping of a browser makes itself portable.",0.0,JavaScript
12bui3u,,"Let's say that we create a framework that ships Chromium as the JavaScript compiler, and Rustup to modify the compiled JavaScript code into what an operating system can run.",0.0,JavaScript
12bui3u,,"So, Chromium will compile JavaScript into some low level code, and Rustup will compile and modify the code to make it runnable on an operating system.",0.0,JavaScript
12bui3u,,This framework will compile JavaScript like your average C++ program.,-0.15,JavaScript
12bui3u,,This framework will compile JavaScript like your average C++ program.,-0.15,C++
12bui3u,,"**Edit:** To clarify some information, Chromium is not a compiler, but we can try to manipulate its components to compile JavaScript code.",0.0,JavaScript
12bui3u,,"Rustup is a Rust compiler, and the reason why choosing Rust is to manipulate low level data, while C++ is a good alternative, it would be better if it's done by memory safe language who can reach low level.",0.33999999999999997,Rust
12bui3u,,"Rustup is a Rust compiler, and the reason why choosing Rust is to manipulate low level data, while C++ is a good alternative, it would be better if it's done by memory safe language who can reach low level.",0.33999999999999997,C++
12bui3u,,"So, Chromium will try to interpret JavaScript, but we will modify the interpreting components, so it actually compiles JavaScript, and Rustup will compile it further to make it portable on an operating system.",0.0,JavaScript
12bui3u,jezd6jf,>Chromium as the JavaScript compiler  I don't understand what you mean by this.,-0.3125,JavaScript
12bui3u,jezjpd6,"Electron (and Tauri, I assume) is not about ""compiling JavaScript files into a portable executable,"" it is about ""distributing a **web application** to offline machines.""",0.0,JavaScript
12bui3u,jezjpd6,"Chromium is not a ""JavaScript compiler;"" it is a [web browser](https://www.chromium.org/chromium-projects/) that you can install and use just like Firefox, IE, or, may Arceus forgive me for uttering those two words, Google Chrome.",0.0,JavaScript
12bui3u,jf0jb75,How does JavaScript enter the picture in the first place?,0.25,JavaScript
12bui3u,jf0jb75,"Go have a look at [https://www.destroyallsoftware.com/talks/wat](https://www.destroyallsoftware.com/talks/wat) before answering these questions, too.",0.0,Go
12bno5i,jexyf6p,"Visual Basic, Logo, Delphi, HTML Editors,  Adobe Flash Builder, ColdFusion, Smalltalk,   These are languages which thrived because of their high power custom IDEs.",0.05333333333333334,Delphi
12bno5i,jexyf6p,"Visual Basic, Logo, Delphi, HTML Editors,  Adobe Flash Builder, ColdFusion, Smalltalk,   These are languages which thrived because of their high power custom IDEs.",0.05333333333333334,HTML
12bno5i,jezth0j,Delphi was an also ran to Visual Basic but that still was hundreds of thousands of jobs....,0.0,Delphi
12bno5i,jf05cb3,Variants of Smalltalk like Objective-C became mainstream.,0.0,Objective-C
12bll1a,jexia9s,"The D programming language generalizes this by allowing D code to be declared as ""static"", which is run at compile-time.",0.5,D
12bll1a,jf0aocw,Maybe a GADT in Haskell?,0.0,Haskell
12bll1a,jez9bfr,"D has a _lot_ of metaprogramming features, including a few that use the `static` keyword - namely, `static if`, `static foreach`, and `static assert` - but what's useful about those is that they are declarations, allowing for [conditional compilation](https://dlang.org/spec/version.html) and [programmatic code generation](https://dlang.org/spec/module.html#mixin-declaration).",0.35000000000000003,D
12bll1a,jez9bfr,"Regardless of whether or not you use `static` branches, D's CTFE will run any code you ask it to with only the following definition  > CTFE is subject to the following restrictions:   > - Expressions may not reference any global or local static variables.",0.14814814814814817,D
12bl2ml,jezf023,"Take Rust, where you can have some `Vec<T>`, but cannot specify, within the type system, how many `T`s should exist (analogous to regex’s `{m,n}` construct).",0.5,Rust
12bl2ml,jf1z9j4,"Admittedly, I'm not well versed in Lisp, but it seems to have the essential operations, `*` for Kleene star (and complementary `+`), `cat` for concatenation, and `or` for alternation.",0.0,Lisp
12bl2ml,jeznln7,"One thing that comes to mind is TypeScript interfaces, which feels similar to defining a schema for a document database.",0.0,TypeScript
12bl2ml,jf4dfem,"Even with just Rust, the Flux compiler plugin offers a refinement type checker (a subset of dependent typing which is easier to solve) which can express cardinality constraints as a simple annotation",0.05,Rust
12bl2ml,jf0dkg7,"TypeScript is one of my favorite languages, but I don't think it quite contains what I have in mind.",0.5,TypeScript
12bl2ml,jf0dkg7,"TypeScript most certainly has alternation in the form of ""union types"".",0.35714285714285715,TypeScript
12bl2ml,jg4v9j6,"In a way, C - by complete accident of course - ""has"" the Kleene star type, and it works almost exactly in the way I would expect it to work.",0.175,C
12bl2ml,jg4v9j6,"If you have thought of C in the meantime, you may have figured out that the ""Kleene star"" type in C is simply pointers.",0.0,C
12bl2ml,jg4v9j6,"And by sheer luck (if you disregard ""declaration mirrors use"", and don't declare multiple variables in one declaration) it looks like this:  T\* x;  And like in Algol 68 with unions, in C a T\* does not have actual values.",0.0,C
12bl2ml,jg4v9j6,"I have been thinking about how a ""purified"" version of C might work, with fat pointers storing the size, so you can always ask for example an **int**\* ap what size array it refers to.",0.0,C
12bl2ml,jg1iijr,"I would be interested if it could be the type system which imposes structure and thus informs the semantics what to do, sort of like `pure` or a reader in Haskell.",0.23214285714285715,Haskell
12bl2ml,jgbhtau,">(at least in my naïve understanding of regular expression types)  u/theangeryemacsshibe pointed us to **rational type expressions**, with an implementation of such a type system in Common Lisp.",-0.15,Lisp
12bl2ml,jgbhtau,"[https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3](https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3)  It makes sense to apply such a type system to a dynamic language, and I think it would work well as an extension to other dynamic languages like Python and JavaScript.",-0.03125,Python
12bl2ml,jgbhtau,"[https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3](https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3)  It makes sense to apply such a type system to a dynamic language, and I think it would work well as an extension to other dynamic languages like Python and JavaScript.",-0.03125,JavaScript
12bl2ml,jfymxcr,"Actually I believe in the past PL-theorists have put a great effort into making type systems that are \_not\_ Turing complete, to avoid situations like C++, where the template system is TC, and you cannot in principle be sure your code will finish to compile.",0.22999999999999998,C++
12bl2ml,jgppgfr,"As the analogy is completely coincidental, caused by the choice of ""\*"" for pointer dereference in C, it is not useful in any concrete way.",0.03333333333333335,C
12bl2ml,jgppgfr,"I do believe it could be used to make a language almost indistinguishable from C, with a safe and consistent type system.",0.375,C
12bi2ov,jf0fssc,"Now there's the question: Do you curry everything like Haskell, or do you implicitly pass tuples to functions like Algol?",0.0,Haskell
12bi2ov,jexwl77,"Haskell has a function taking `Void` as an argument, and it's called `absurd`.",-0.5,Haskell
12bi2ov,jf62nyg,"This is definitely not what C means when it says void, otherwise \`void f()\` would be saying a function which returns an element from the empty set.",-0.05,C
12bi2ov,jf13g99,in Dart this is not the case.,0.0,Dart
12bi2ov,jf679f9,"but overall, it's probably meaningless to consult C for type theory lol, was just giving another perspective :)  btw since C functions are allowed to diverge sometimes the empty type is a valid return type for them",0.14,C
12bi2ov,jfz4f5f,"yes but it's exceedingly rare for languages to have proper empty type support like Rust's \`!\`, C doesn't have it and I don't even think haskell does.",0.06666666666666667,Rust
12bi2ov,jfz4f5f,"yes but it's exceedingly rare for languages to have proper empty type support like Rust's \`!\`, C doesn't have it and I don't even think haskell does.",0.06666666666666667,C
12bi2ov,jfzp438,"Haskell does, both as `Void` in the standard library and via the `EmptyDataDecls` extension.",0.0,Haskell
12bi2ov,jfzp438,"it's such a minor difference though, that a language like C won't care (or need to care)",-0.025,C
12bi2ov,jeykmpf,"\(x :: Int) -> x * 2  and      \x -> (x :: Int) * 2  In Haskell, you would call the first one something like a ""pattern type annotation (or type annotation in a pattern)"" and the second one just a ""type annotation"".",0.125,Haskell
12bf369,jewsl8k,One the ILs of the GHC Haskell compiler is called C--.,0.0,Haskell
12bf369,jewsl8k,One the ILs of the GHC Haskell compiler is called C--.,0.0,C
12bf369,jexq1vq,"If you wanna really break your brain, check out [""High Level Assembly""](https://en.wikipedia.org/wiki/High_Level_Assembly).",0.18,Assembly
12bf369,jf4m29i,"Those names are marked with `*`:      Lang Ext   Tool      Name             Descripton          M    .m    mm.exe    M compiler       Translate to exe/pcl/asm/mc/ma                ms.exe    *Run M           Run M from source ('m script')                mc.exe    M transpiler     Translate to C source, or exe via C compiler          PCL  .pcl  pcc.exe   PCL compiler     Translate to exe/asm                pci.exe   PCL interpreter  Run PCL file from source          Q    .q    qc.exe    Q compiler       Compile to .pc bytecode file          ASM  .asm  aa.exe    ASM interpreter  Translate ASM source to exe/obj          --   .pc   pc.exe    Q interpreter    Interpret binary bytecode file          --   .mc   run.exe   *Run 'mc' file   Execute private binary format          Key:          M     - Static systems language     PCL   - Static intermediate language when used outside a compiler     Q     - Dynamic scripting language     ASM   - x64 assembly code in my symtax     .pc   - Binary bytecode file from Q compiler.",0.15714285714285717,C
12bf369,jeypcpm,"I don't think it needs a while new name just because the target language is C rather than Assembly, or JavaScript instead of JVM bytecode.",0.13636363636363635,C
12bf369,jeypcpm,"I don't think it needs a while new name just because the target language is C rather than Assembly, or JavaScript instead of JVM bytecode.",0.13636363636363635,Assembly
12bf369,jeypcpm,"I don't think it needs a while new name just because the target language is C rather than Assembly, or JavaScript instead of JVM bytecode.",0.13636363636363635,JavaScript
12bf369,jez8vvd,The linker links functions from the libraries that you used in your program such as `printf` in C,0.0,C
12bf369,jyhlm46,"Whenever we write a story/program in a language like C++, Java, or Python, the compiler starts translating the story/program into a language that can be understood  by the computer, which is the ""machine code.""",0.0,C++
12bf369,jyhlm46,"Whenever we write a story/program in a language like C++, Java, or Python, the compiler starts translating the story/program into a language that can be understood  by the computer, which is the ""machine code.""",0.0,Java
12bf369,jyhlm46,"Whenever we write a story/program in a language like C++, Java, or Python, the compiler starts translating the story/program into a language that can be understood  by the computer, which is the ""machine code.""",0.0,Python
12bf369,jyhlm46,"Assembly language, in general, is a bit easier for humans to understand than machine code, but the computer still doesn't know what to do with it.",0.05000000000000002,Assembly
12bf369,jeyzujo,"Back in college, I knew a guy who enjoyed programming in C-- directly.",0.19999999999999998,C
12bf369,jeyzujo,"I somehow doubt it was at all associated with GHC, considering Haskell itself hadn't come out yet...",0.0,Haskell
12bf369,jez6fh8,C-- was designed as an IL for GHC by Simon Peyton Jones and someone else who I don't remember atm.,0.0,C
12bf369,jez6fh8,It came out in 1998 (well after Haskell).,0.0,Haskell
12bf369,jez9nhr,So there must have been another C-- at least as early as 1994.,-0.09999999999999999,C
12bf369,jf0z9k2,"No actually C-- was its own project to start with, and a dialect was later included in GHC.",0.19999999999999998,C
12bf369,jf0z9k2,"If you take a look at the old page, you'll see that GHC isn't even mentioned: https://web.archive.org/web/20080611074310/http://www.cminusminus.org/code.html  However that branch of C-- went extinct, and only in GHC's DNA you'll find C-- :)",0.04999999999999999,C
12bcyj6,jewbxyi,There were things like a Chinese version of BASIC and a Russian version of C++ but most programming languages based on non-english languages are teaching languages.,0.125,C++
12bcyj6,jewbxyi,Most popular programming languages even limit identifier names to plain latin characters except for JavaScript.,0.29523809523809524,JavaScript
12bcyj6,jewayqc,Fun fact: Ruby was created by a Japanese engineer but still keeps the same common contructs as the other 'English based' languages,-0.020833333333333332,Ruby
12bcyj6,jewe9kr,But learning Pascal in school around the age of 12 or 13 or so I don't remember ever thinking that this is weird.,-0.5,Pascal
12bcyj6,jewbsu3,"Also, there are languages that only use symbols, like APL o very few words like Prolog.",-0.13,APL
12bcyj6,jewbsu3,"Also, there are languages that only use symbols, like APL o very few words like Prolog.",-0.13,Prolog
12bcyj6,jewwna6,"The developer of this feature was later in the ALGOL comitee, which was staffed by an international crew, but designed an English based language.",0.0,ALGOL
12bcyj6,jf04stp,"*Could be* even easier for somebody with no knowledge of spoken English to understand this dialect than try to explain to somebody that do why (in C) ""true & false"" is not false, but 0.",0.037499999999999985,C
12bcyj6,jexibzq,"I guess there could be locale shims and you could depend on the kindness of open-source to populate the appropriate translations, but even massive projects championed by big companies like Jest and Rust still have trouble with translations.",0.075,Rust
12awbwx,,That also means that JavaScript won't be improved as fast anymore.,0.2,JavaScript
12awbwx,,"So, are the browsers still competing to improve JavaScript, or did that war end long ago?",-0.05,JavaScript
12awbwx,jeu78ah,"> So, are the browsers still competing to improve JavaScript  JavaScript's evolution, or what you call ""improvements,"" does not come from competition but from recent [ECMA TC39](https://tc39.es/) standardisation.",0.0,JavaScript
12awbwx,jeu78ah,"Before last decade the word ""JavaScript"" itself had multiple meanings, mainly ""Mozilla-Flavoured ECMAScript,"" and ""ECMAScript.""",0.05555555555555555,JavaScript
12awbwx,jey8kb6,That also means that JavaScript won't be improved as fast anymore  I cannot agree with this observation.,0.2,JavaScript
12awbwx,jey8kb6,JavaScript had a long interstitial period of sluggish to no change to the language in the 10 years between 1999 and 2009.,-0.05,JavaScript
12awbwx,jetxt1a,"Yes, JavaScript will continue to improve.",0.0,JavaScript
12awbwx,jetxt1a,"I'm not really an expert in the politics of this, but as long as Google has an interest in keeping web applications competitive with native applications, they have an interest in improving JavaScript.",-0.07500000000000001,JavaScript
12awbwx,jf7p7c0,"JavaScript stopped being ""improved"" a long time ago, instead opting to add lowest-common-denominator features that exist only because people couldn't be arsed to learn the features JavaScript already had.",-0.025,JavaScript
12awbwx,jf7p7c0,"The best thing JavaScript can do is give WASM full power to do everything JS does without having to use JS as an intermediary, and let JavaScript die.",0.675,JavaScript
12au6kd,jeuurln,"> what syntax should imports have  When writing D code, it is best practice to selectively `import` only the symbols you actually need, and to do it only when you need them.",0.25,D
12au6kd,jeuurln,I found that D may be the only language that supports this without having `import` be an expression.,0.0,D
12au6kd,jeuurln,"Oh and then you will have people writing code in your language and in Java _at the same time_ but their Java framework, _which you have never heard about_, uses a directory structure that breaks the way people share code for your interpreter, and now you got one person complaining about needing to manually import `../../../../../java/acme/src/whatever/boot.py`.",0.0,Java
12au6kd,jeuurln,Java's [classpath](https://en.wikipedia.org/wiki/Classpath) also comes to mind.,0.0,Java
12au6kd,jeuurln,Also look at [Java Modules](https://www.oracle.com/uk/corporate/features/understanding-java-9-modules.html) and [Rust Crates](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html).,0.0,Java
12au6kd,jeuurln,Also look at [Java Modules](https://www.oracle.com/uk/corporate/features/understanding-java-9-modules.html) and [Rust Crates](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html).,0.0,Rust
12au6kd,jeuvuh1,"Even so, you could do worse -- it's more-or-less what the C preprocessor does.",-0.4,C
12au6kd,jevlo6q,C++ comitee just approved to change from namespaces like Java to modules.,0.0,C++
12au6kd,jevlo6q,C++ comitee just approved to change from namespaces like Java to modules.,0.0,Java
12au6kd,jevlo6q,Is it similar to C include files or PHP include files ?,0.0,C
12au6kd,jevlo6q,Is it similar to C include files or PHP include files ?,0.0,PHP
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,Perl
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,PHP
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,Python
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,Ruby
12au6kd,jeuyy5h,"Python also allows local imports like that but I would fire any programmer who used it except in a very few special cases (lazy loading of modules, essentially).",-0.030571428571428572,Python
12au6kd,jeuy1c5,How could you do worse than the C preprocessor?,-0.4,C
12au6kd,jev1sar,"If I use `m.f` in a single function in a class I write      class C     {         void g()         {             import m: f;             f(""HI"");         }     }  And if I use it in two functions in that class then I write      class C     {         import m: f;         void g()         {             f(""HI"");         }         void h()         {             f(""IH"");         }     }  etc...  > And then when you do centralize  Never!",-0.08928571428571427,C
12au6kd,jev1sar,""");     }  like you would in Java.",0.0,Java
12au6kd,jev1sar,Yes but D works like Haskell and requires you to be more explicit about it.,0.5,D
12au6kd,jev1sar,Yes but D works like Haskell and requires you to be more explicit about it.,0.5,Haskell
12au6kd,jeuz6yq,"It's actually a fun (if mildly frustrating) exercise to prove to yourself that the C processor cannot do anything significantly smarter than ""copy-paste the file"" without dropping some functionality.",0.09166666666666666,C
12alw4w,jesq07c,"Ruby grew in popularity around 2005 because it allows a ""natural language-style"" syntax for programming (which Rails took full advantage of).",0.22499999999999998,Ruby
12alw4w,jesvt7x,"I mostly agree with all points, including point 1, but I'll notice that Lisp took ""make it easy for the parser"" to an extreme and it seems to me that that limited its reach.",0.1842261904761905,Lisp
12alw4w,jettkuq,"But in fact I keep muttering that line from The Zen of Python to myself about how ""complex is better than complicated"" and putting in one more kludge to convert from the syntax the user would expect to the syntax my parser knows how to parse.",0.05,Python
12alw4w,jex63j2,"For example, in Dart, local functions don't have a leading keyword.",0.0,Dart
12alw4w,jex63j2,"I would still prefer if Dart had a leading keyword for functions, and I do think it's a good guideline to avoid unbounded lookahead unless you really love the syntax it enables.",0.6,Dart
12alw4w,jex63j2,Do you do no inference like C++ before auto?,0.0,C++
12alw4w,jex63j2,Local inference like C#/Java/etc.?,0.0,C
12alw4w,jex63j2,Is the type system object-oriented with subtyping like Java?,0.0,Java
12alw4w,jex63j2,Functional with algebraic datatypes like Rust?,0.0,Rust
12alw4w,jex63j2,"Both, like Swift and Scala?",0.0,Swift
12alw4w,jex63j2,"Both, like Swift and Scala?",0.0,Scala
12alw4w,jex63j2,Are generics erased like Java and SML?,0.0,Java
12alw4w,jex63j2,Reified like C# and Dart?,0.0,C
12alw4w,jex63j2,Reified like C# and Dart?,0.0,Dart
12alw4w,jex63j2,Monomorphized like Rust?,0.0,Rust
12alw4w,jex63j2,Or are they duck typed like templates in C++?,0.0,C++
12alw4w,jex63j2,Or with bounds like Java?,0.0,Java
12alw4w,jex63j2,Traits like Rust?,0.0,Rust
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,C++
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,C
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,Kotlin
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,Java
12alw4w,jex63j2,* C++ gave you object-oriented programming and generic programming while allowing incremental migration from C.  * C rode on UNIX's coattails.,0.0,C++
12alw4w,jex63j2,* C++ gave you object-oriented programming and generic programming while allowing incremental migration from C.  * C rode on UNIX's coattails.,0.0,C
12alw4w,jex63j2,* Kotlin is pushed by JetBrains and has amazing IDE integration.,0.6000000000000001,Kotlin
12alw4w,jex63j2,* Objective-C was a gateway to iOS.,0.0,Objective-C
12alw4w,jevjoek,J is APL in ASCII.,0.0,APL
12alw4w,jesyz2s,"In regards to Ruby, I don't think the Ruby syntax is special.",0.35714285714285715,Ruby
12alw4w,jesvcy4,"Ruby grew in popularity around 2005 because it allows a ""natural language-style"" syntax for programming (which Rails took full advantage of).",0.22499999999999998,Ruby
12alw4w,jesvcy4,Ruby had a syntax many considered elegant.,0.5,Ruby
12alw4w,jesvcy4,Ruby took off with Rails.,0.0,Ruby
12alw4w,jesvcy4,So did Ruby.,0.0,Ruby
12alw4w,jetagzu,Assembly and BASIC may be even simpler to parse (EDIT: or nearly so).,0.05,Assembly
12alw4w,jeywaqs,"> For example, in Dart, local functions don't have a leading keyword.",0.0,Dart
12alw4w,jeywaqs,Language features are mostly GCC C extensions people like to use.,0.5,C
12alw4w,jeywaqs,"Syntax changes are things already well tested in languages with C-like syntax, like C++ or Java.",0.0,C++
12alw4w,jeywaqs,"Syntax changes are things already well tested in languages with C-like syntax, like C++ or Java.",0.0,Java
12alw4w,jetour1,> I don't think the Ruby syntax is special.,0.35714285714285715,Ruby
12alw4w,jetour1,"While Ruby's syntax may not be compelling *to you*, it is compelling to many others.",0.3666666666666667,Ruby
12alw4w,jet7gmc,I suspect Ruby faltered due to performance and lack of scalability.,-0.125,Ruby
12alw4w,jet7gmc,"I know of at least 3 projects which started on Ruby on Rails, but later had to be completely reengineered when they failed to scale.",-0.175,Ruby
12alw4w,jeuoa4x,"Assembly, maybe, but not if you're writing a real assembler, since those usually need to be able to use (constant) arithmetic expressions as operands, typically written in standard algebraic notation.",0.04722222222222222,Assembly
12alw4w,jeuohb3,"Other people I think have mention Lisp, I could adduce Forth ...",-0.125,Lisp
12alw4w,jeuohb3,"Other people I think have mention Lisp, I could adduce Forth ...",-0.125,Forth
12alw4w,jewcdlx,"No language *needs* macros, but Haskell is lazy yet has a quite powerful and relatively widely used macro system in the form of Template Haskell.",-0.016666666666666673,Haskell
12alw4w,jew7mt4,"But the other obvious solution is to use dot-ident like in C initializers:      x = foo(.count = a);  It is not as elegant, but as I started writing more code, I realized that scanning `x = foo(count = a)` was hard, I had to mentally flip things around ""oh it's not count = a, it's a named parameter assignment!"".",0.07638888888888888,C
12alw4w,jetu4dh,Ruby is really slow among slow languages.,-0.30000000000000004,Ruby
12alw4w,jewda35,Ruby is around Python speed these days ams improving a lot more with latest JITs,0.5,Ruby
12alw4w,jewda35,Ruby is around Python speed these days ams improving a lot more with latest JITs,0.5,Python
12alw4w,jfac43r,"I like Ruby much better than Python, so less Python and more Ruby would be a win in my book.",0.4083333333333333,Ruby
12alw4w,jfac43r,"I like Ruby much better than Python, so less Python and more Ruby would be a win in my book.",0.4083333333333333,Python
12afe2b,,"The main inspirations are Scopes, Penne, Rust and Markdown.",0.16666666666666666,Rust
12afe2b,jerzan2,Languages with C style syntax don't need indentation but their still used for readability.,0.0,C
12afe2b,jes89oz,Like Python.,0.0,Python
12afe2b,jes89oz,"C programs are famous for these, but coerced identation is not the solution.",0.5,C
12afe2b,jes89oz,"C standard just did the opposite, just confirmed ""bool"", ""false"", ""true"" as official keywords instead of macros.",0.06999999999999998,C
12afe2b,jes89oz,"Extended ""if"" like ""elif"", Pascal's ""case+of"" or C ""switch+case"", ""select"", may help.",0.0,Pascal
12afe2b,jes89oz,"Extended ""if"" like ""elif"", Pascal's ""case+of"" or C ""switch+case"", ""select"", may help.",0.0,C
12afe2b,jes89oz,"And explicit end-less loop like you mentioned, instead of a ""for (;true;) { ... }"" of C like ""loop { }"", also a good idea, some P L. (s) already have it.",0.4333333333333333,C
12afe2b,jes89oz,"C and Pascal does keep ""go-to"" for teaching control structure, but their communities suggest use the others.",0.0,C
12afe2b,jes89oz,"C and Pascal does keep ""go-to"" for teaching control structure, but their communities suggest use the others.",0.0,Pascal
12afe2b,jes89oz,"doesn't allow variable declarations outside a function, Java and C#, doesn't outside a class or class function ( a method ).",0.0,Java
12afe2b,jes89oz,"doesn't allow variable declarations outside a function, Java and C#, doesn't outside a class or class function ( a method ).",0.0,C
12afe2b,jes89oz,"C allows them as ""global vars"".",0.0,C
12afe2b,jes89oz,Check good old style Pascal.,0.39999999999999997,Pascal
12afe2b,jew1j5s,">not indentation based  Other than Python, what languages are indentation based?",-0.125,Python
12afe2b,jesd1is,"This would be nice, too; but this only works if indentation doesn't contain information (like in Python), and we should probably have autoformatting, too ;)  Doing the version control not on the text, but on the AST might also be interesting.",0.3375,Python
12afe2b,jesd1is,"People using GC languages also might think, C is backwards, just because it doesn't use GC.",0.0,C
12afe2b,jerus73,In Rust I already used compare and match when I wanted different things to happen for all three cases.,0.0,Rust
12afe2b,jerus73,And match in Rust is pretty cumbersome.,0.25,Rust
12afe2b,jeshkgg,"When programming in Rust, I already have to do multiple matches.",0.0,Rust
12afe2b,jeshkgg,"But the problem with the Rust match is, it almost always causes the level of indentation to increase by two instead of one.",0.0,Rust
12afe2b,jeshkgg,"Match can even reduce nesting:  ```Rust match (a, b, c) {     (true, true, false) => ...,     (true, false, _) => ...,     (_, _, true) => ...,     ... } ```  >It effectively makes calls first class objects.",0.18124999999999997,Rust
12afe2b,jeshkgg,"It's like C++, but the only function you are allowed to define is the `()` operator.",0.0,C++
12afe2b,jf2r6nw,">It can be interpreted too for real time coding  I thought of it as a language at a similar level as C, just like the inspiration languages.",0.1,C
12afe2b,jewpuzr,Assembly isn't cross platform and doesn't support macros or generics.,0.0,Assembly
12afe2b,jewshm4,">Other than Python, what languages are indentation based?",0.0,Python
12afe2b,jewluss,Maybe it could become Lisp without parentheses ;),0.25,Lisp
12afe2b,jevdw7j,"For everything else, we have basically every other programming language made over the last 3 decades that aren't C or assembly that come with more goodies to help with creating code quicker, with less errors, and with more intention imparted to the reader.",0.14166666666666666,C
12afe2b,jewre5r,>C or assembly  Being close to C in terms of simplicity and features is the point.,0.0,C
12afe2b,jp0f839,The stimulus was short Python programs that solve leetcode easys.,0.0,Python
12a2e1u,,"I feel like it is a good idea, but I'm interested in second opinions      // Stack Style     fac :: i32 -> i64 :: n => {         n 2 = not         n 1 - fac 2 branch         n *     }          // Haskell Style     fac :: i32 -> i64 :: n     fac 2 => 2     fac n => n 1 - fac n *          main :: [str] -> i32 :: args => {         // Equivalent to Python: print(fac(int(args[0])))         args 0 at:i32 fac print          0     }  Div by zero - This is the first draft for ADTs and unwraping      Maybe a = Just a | Nothing      // Stack Style     div :: i32 -> i32 -> Maybe(f32) :: a b => {         b 0 = not         a b / Just         Nothing         branch     }          // Haskell Style     div :: i32 -> i32 -> Maybe(f32)     div a 0 => Nothing     div a b => a b / Just          main :: [str] :: args => {         args split div         (Just unwrap:str)         (Nothing ""DIV/0 ERROR"")         match         print         0     }",0.004166666666666666,Haskell
12a2e1u,,"I feel like it is a good idea, but I'm interested in second opinions      // Stack Style     fac :: i32 -> i64 :: n => {         n 2 = not         n 1 - fac 2 branch         n *     }          // Haskell Style     fac :: i32 -> i64 :: n     fac 2 => 2     fac n => n 1 - fac n *          main :: [str] -> i32 :: args => {         // Equivalent to Python: print(fac(int(args[0])))         args 0 at:i32 fac print          0     }  Div by zero - This is the first draft for ADTs and unwraping      Maybe a = Just a | Nothing      // Stack Style     div :: i32 -> i32 -> Maybe(f32) :: a b => {         b 0 = not         a b / Just         Nothing         branch     }          // Haskell Style     div :: i32 -> i32 -> Maybe(f32)     div a 0 => Nothing     div a b => a b / Just          main :: [str] :: args => {         args split div         (Just unwrap:str)         (Nothing ""DIV/0 ERROR"")         match         print         0     }",0.004166666666666666,Python
12a2e1u,jeqmt5h,"The Haskell style seems dramatically more concise and readable, though it's less consistent with the rest of the language; replacing it with a `case`/`match` construct could make it more consistent and obviate the need for computing values ahead of time (which interferes with recursion).",0.2388888888888889,Haskell
12a2e1u,jf0lwj1,"If you're going to do a stack language, I think avoid what looks like Haskell.",0.0,Haskell
12a2e1u,jf0lwj1,"You seem to have type-declarations, and they look like Haskell.",0.0,Haskell
12a2e1u,jf0lwj1,Are you familiar with the comment-convention in Forth for illustrating the *stack-effect* of each word?,0.375,Forth
12a2e1u,jf0lwj1,Forth has `then` / `else` / `if` compiling-words which I see no analogy to.,0.0,Forth
12a2e1u,jeq9n2w,"It does look indeed like a lot of ideas are aligned, although I'm not super proficient with Rust, that could be a good learning opportunity",0.26666666666666666,Rust
129uw2a,,"My idea for a language (it's must be language, because it will be patching Javascript and PHP's craziness (unlike ts which just make typing static)).",0.5,PHP
129uw2a,,"**No nulls, because, it's the cool thing in Rust (I really am not sure how it handles it)**   2.",0.04999999999999999,Rust
129uw2a,,**Compiles down to PHP (ReactPHP for asynchronous) and Javascript (for the frontend).,-0.15555555555555559,PHP
129uw2a,,**Error handling fashioned like Rust.,0.0,Rust
129uw2a,,"So this language should be able to deal with that, either in Rust-fashion, or Java checked exceptions.",0.5,Java
129uw2a,,"**Fully built around RxJS**, which I admit, may be a very big stumbling block for beginners, but here's how a code snippet would look like (a little like Angular... and with **@ Input** as **observables**):      component Product {         constructor (private ProductService productService) {}              // Starts off as { loading: true }, and finally emits as         //{ loading: false, success: true, data: T }         response$ = #purchaseButton.click$.pipe(             throttleTime(1000),             switchMap(() => productService.makePurchase()),         )              // here's where HTML goes         !",0.08333333333333331,HTML
129uw2a,jeq75qs,"Instead of compiling to JS & PHP, just pick one.",0.0,PHP
129uw2a,jeq9v9x,Agree but I may not heed the advice :D 4.,1.0,D
129uw2a,jeq9v9x,"I figured we could do so like C#, completely drop .pipe()    1.",0.1,C
129uw2a,jesgxvm,"Just trying to show that if you're creating this new cool thing, you don't have to be bound by the existing syntax of JavaScript!",0.2869318181818182,JavaScript
129motb,jeoq4n9,"Start doing videos with titles as ""improved C"" ""the better C++"" ""downsized c++"" and so on, so you appear in more searches for ppl that appeal to this language.",0.5,C
129motb,jeoq4n9,"Start doing videos with titles as ""improved C"" ""the better C++"" ""downsized c++"" and so on, so you appear in more searches for ppl that appeal to this language.",0.5,C++
129i9zd,,"BUT, it is possible in C# (which is very close to TS) with extension methods.",0.1,C
129i9zd,,"},     			StringSplitOptions.RemoveEmptyEntries     		).Length;     	}     }  Here's how you use it:      class Program{         public static void Main(string[] args){             int wordCount = ""meme meeme meemeee"".WordCount();         }     }  It's defeintely more verbose than Rust, but that's just c# as a language.",0.3333333333333333,Rust
129i9zd,jenqb09,"Another thing that the extension methods lack that struct impls give you (like… by definition) is that you cannot implement an interface using extension methods, and C# does not have structural typing.",0.0,C
129i9zd,jenhhfc,"In the C# approach, it is done with vtables, where your object has attached to it a pointer to a vtable for every interface it implements.",0.0,C
129i9zd,jeozu2x,"As noted in some of the other responses, it's fairly safe for the compiler to assume that a certain arbitrary function `R f(T, ...)` can be used in a situation in which a method on `T` is required with the signature `R f(...)` (where `...` represent 0 or more specific parameters).",0.16488095238095238,R
129i9zd,jeozu2x,"Languages like Scala have been doing this trick for years: https://docs.scala-lang.org/scala3/reference/contextual/extension-methods.html  I had used the same trick in past work, and found that a number of languages were calling it a _trait_ (although there are lots of terms, and no two languages agree on what any one term means).",-0.125,Scala
129i9zd,jeozu2x,"Instead of using ""auto detection"" like in the Scala extension method example (where just having the extension method ""visible"" to the compiler makes it eligible for use), traits typically need to be explicitly glued onto a class.",-0.16666666666666666,Scala
129i9zd,jeozu2x,"Starting with the Scala example from the link above (and apologies if ""old reddit"" messes up the formatting):  ``` case class Circle(x: Double, y: Double, radius: Double)  extension (c: Circle)   def circumference: Double = c.radius * math.Pi * 2 ```  A trait would look something like this:  ``` trait CircleEx : Circle   def circumference: Double = c.radius * math.Pi * 2   def area: Double = c.radius * c.radius * math.Pi ```  It's like a sub-class, but instead of being a concrete sub-class with a super, it's an extension to any class that happens to be ""_is a_"" Circle.",0.053030303030303025,Scala
129i9zd,jeozu2x,"We bind mixins to a class using the `@` annotation concept, loosely stolen from Java I think:  ``` return schema.enablePointers         ?",-0.07692307692307693,Java
129i9zd,jeozu2x,"It provides all of the benefits of C++ multi-inheritance, but none of the downsides (like the diamond problem).",0.0,C++
129i9zd,jenh6ti,"Struct impls in Rust can't attach additional methods in foreign crate, trait impls can and it's different functionality than linked post asks about.",-0.0625,Rust
129i9zd,jep9n89,C# extensions that can implement interfaces are on the way.,0.0,C
129i9zd,jeowea4,This is more a C#-related issue than an extension-related one.,0.5,C
129i9zd,jeowea4,"C# also have you write those ""extension methods"" in a different and **static** ""class.""",0.25,C
129i9zd,jeowea4,"C# also actually does have something called ""namespace"" which is, somehow, entirely unrelated to the subject at hand.",-0.05555555555555555,C
129i9zd,jeowea4,"Oh and C# also actually supports writing functions outside classes, such as in functions, but not in namespaces, just to blow your mind.",0.0,C
129i9zd,jeowea4,"Anyway, [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/) and [Scala](https://docs.scala-lang.org/scala3/book/ca-extension-methods.html) both allow extensions to implement interfaces.",0.0,Swift
129i9zd,jeowea4,"Anyway, [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/) and [Scala](https://docs.scala-lang.org/scala3/book/ca-extension-methods.html) both allow extensions to implement interfaces.",0.0,Scala
129i9zd,jeozrs0,"In C#, the dispatch is per object, i.e.",0.0,C
129i9zd,jeoxzp8,Extension methods are not the problem in C#.,0.0,C
129i9zd,jep15uy,">C# also actually supports writing functions outside classes, such as in functions, but not in namespaces  You're talking about the Main() function?",0.041666666666666664,C
129i9zd,jep15uy,"I think that's the only place where that's possible, although I haven't heavily used the latest version of .NET Core and C#, so I'm not sure.",0.009999999999999998,C
129i9zd,jepc0a0,"In Rust, a function can accept a type which implements multiple traits, if that's what you mean, e.g.",-0.15625,Rust
129i9zd,jep3svg,"Those have been around since C#7, 6 years ago.",0.0,C
129i9zd,jesbd04,Do you think the main issue is the same syntax and having a different syntax (or other tooling; IntelliJ highlights extension methods in Kotlin in italics) would alleviate it?,0.010416666666666664,Kotlin
1292vwo,,"I guess some options could be having to explictly anotate that a variable is going to be passed implicitly into functions: ``` fun game() {   let implicit world = World::new();   spawn(Entity::Zombie); // world here is taken implicitly } ```  Also not sure if ""implicit""/""imply"" are the best keywords  EDIT: what Scala does seems closer to what i had in mind.",0.16249999999999998,Scala
1292vwo,jellrcv,Scala probably has the most popular implementation -- they even have their own implicit calculus IIRC -- but most theorem provers and (hopefully) future versions of OCaml have something similar.,0.3666666666666667,Scala
1292vwo,jellrcv,"Haskell also has these under the ImplicitParams language extension, where they are implemented in terms of type classes (in a pretty hacky way IMO).",0.25,Haskell
1292vwo,jelw681,"For example, in Scheme:          (define world1 ...)      (define world (make-parameter world1))      (define (spawn entity) (world-add-entity (world) entity))      (spawn zombie1) ;; adds zombie1 to world1  You can temporarily change the value of world for a given scope, and it will revert back to its previous value once this dynamic scope exits.",-0.22916666666666666,Scheme
1292vwo,jelpi5s,"I remembered my frustration refactoring a C library a few years ago where I was splitting long functions up into smaller ones, how often I ended up with long argument lists for functions which only existed to split the code up.",-0.06,C
1292vwo,jemaeqv,"From Java patterns, we learn that at about four parameters, a function becomes unmaintainable.",0.0,Java
1292vwo,jenowgd,Swift recently introduced task-local values.,0.0,Swift
1292vwo,jenowgd,In Swift you can write something like this:      struct Game { // Just a namespace         @TaskLocal static var world: World?,0.04999999999999999,Swift
1292vwo,jeoajpz,"However, unlike Scala's implicit parameters, this all can be inferred by a compiler (as in, an intermediary function `f` in a call stack `handler(E); f; g raised E;` does not have to explicitly declare the `E` type), this, in turn, allows individual functions to compose with each other.",-0.0625,Scala
1292vwo,jeoajpz,This wouldn't work in Scala where `map` would need to itself be aware of `Log`.,0.25,Scala
1292vwo,jf2i6y2,"I don't think this actually works well (and controversially, that includes Scala's implementation).",0.275,Scala
1292vwo,jf2i6y2,You can still sort of trace implied arguments in Scala but it's traced a different way from everything else.,0.0,Scala
1292vwo,jemqerq,"So they reworked it to a system called ""given and using"" to provide the same functionality in Scala 3.",0.0,Scala
1292vwo,jfk0oz3,"I also want my language to have something similar to typeclasses (which I'm trying to conceptualize as adhoc modules), so the way Scala has using/given to deal with that could also work for me",0.0,Scala
1292vwo,jemezhq,"> From Java patterns, we learn that at about four parameters, a function becomes unmaintainable.",0.0,Java
1292vwo,jemtcwt,"yeah, that final design is very similar to what i was thinking about, but it's not it  it seems in that case the caller would have no control over what actually gets passed into that function, where i want to pass something invisibly  what Scala does is actually much closer to what i meant",0.05,Scala
1292vwo,jemeus6,"Scala doesn't answer your question, though.",0.0,Scala
1292vwo,jeo2l5b,"If I understand what you're asking correctly, this seems to be exactly what Kotlin's context receivers are:  https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md",0.25,Kotlin
128waxk,,"C itself has been widely castigated for being too low level and unsafe, especially in a forum like this which prefers its languages a few levels higher.",-0.010000000000000009,C
128waxk,,Yet C is still tremendously popular for many reasons.,0.55,C
128waxk,,"(I find it annoying that C is associated with low-level programming, that people talk about C-APIs, or even C-ABIs, or C-level types, and describe it as the closest thing to the hardware, as though C had invented low level.",-0.4,C
128waxk,,Yet C doesn't even have a 8-bit byte type!),0.0,C
128waxk,,Can any of them offer an implementation that matches Tiny C's 250KB compiler?,0.0,C
128waxk,,"\[My generated C code requires only 180KB `tcc.exe` plus one of its libraries to build.\]  So, I won't say try harder; how about trying less!",-0.10277777777777779,C
128waxk,,In my case 80% of the issues with C are its syntax; and most C alternatives have the same syntax more or less.,0.20833333333333334,C
128waxk,,"My own systems language, is another private one (I can't support it) that I've always used in place of C. Below I've listed 35 or so differences and enhancements to C (I could write 50 more), and yet it is not much higher level.",0.24375000000000002,C
128waxk,,In C functions are not marked at all; you have to infer where they are!,-0.0625,C
128waxk,,No micromanaging visibility via combinations of C's 30 standard headers.,0.0,C
128waxk,,"`u64` rather than 16 combinations of `long long unsigned [int]`) (C has `uint64_t` in stdint.h, but not really supported by the rest of the language.)",-0.06666666666666667,C
128waxk,,"* Default 64-bit ints and floats (C could have 64-bit `int`, but is typically 32 bits, which means 32-bit literals and a discontinuity between 32 and 64 bits) * Separate Pointers and Arrays.",-0.16666666666666666,C
128waxk,,"(If `P` is a pointer-to-array in C, you need `(*P)[i]` to access an element: deref then index.",0.0,C
128waxk,,But C also allows `*(P[i])`: index then deref.,0.0,C
128waxk,,"C offers some combination of `#define`, `enum`, `const`, and soon `constexpr`, none of which tick all the boxes * Table data: initialise parallel arrays, and optional enums, in table form.",0.05,C
128waxk,,C requires hideous 'x-macros\` to do a similar thing * Bit and bitfield accesses: `A.,0.0,C
128waxk,,"* Far less UB than in C * Compiler options to run directly from source, or produce a single amalgamated source file for a whole application.",0.032380952380952385,C
128waxk,jel1823,Oddly enough pascal is a credible replacement for C and has always been.,0.2,C
128waxk,jekpn6p,"C2 is just a tiny addition on top of C, C3 has more, but not that much more - additions are mainly based on GCC extensions to C. Odin is not huge either.",0.24444444444444446,C
128waxk,jemano9,It’s not hard to be better than C.  It’s hard to be _enough_ better than C to displace C.  Rust shows some promise.,0.17083333333333334,C
128waxk,jemano9,It’s not hard to be better than C.  It’s hard to be _enough_ better than C to displace C.  Rust shows some promise.,0.17083333333333334,Rust
128waxk,jemano9,I recommend reading Dennis Ritchie’s paper on C from the second History of Programming Languages conference around 1993 (HOPL-II).,0.0,C
128waxk,jemano9,"I was lucky enough to hear his talk, and I left with a great appreciation for what he was trying to do with C and how well he succeeded.",0.2833333333333333,C
128waxk,jemano9,That was the day I stopped being a C hater.,0.0,C
128waxk,jemano9,"And OP, isn’t C++ _the_ mainstream alternative to C.  I have a few colleagues who are always nattering that I should be using it instead of C.  They haven’t convinced me.",-0.2,C++
128waxk,jeksgwz,Zig or Rust,0.0,Rust
128waxk,jekzv62,We don't have C replacements so to speak because the need isn't really there.,0.2,C
128waxk,jel2vjk,Odin is a great C replacement in my opinion.,0.8,C
128waxk,jemdsjx,"Forth might be viable as an alternative for some things, Rust for others.",0.0,Forth
128waxk,jemdsjx,"Forth might be viable as an alternative for some things, Rust for others.",0.0,Rust
128waxk,jemdsjx,Pascal and Fortran were competitors in the same spaces at one time as well as some variants of Basic (I wrote a good amount of PBasic at one point).,0.2333333333333333,Pascal
128waxk,jemdsjx,Pascal and Fortran were competitors in the same spaces at one time as well as some variants of Basic (I wrote a good amount of PBasic at one point).,0.2333333333333333,Fortran
128waxk,jemdsjx,"The problem at this point is that C is actually pretty hard to beat, for some non-obvious reasons:  1.",-0.020833333333333343,C
128waxk,jemdsjx,"For example, there was a blog post I saw recently about working through *Crafting Interpreters* using Rust, and the author pretty quickly had to dip into unsafe Rust to be able to achieve anything resembling the same performance.",0.21666666666666665,Rust
128waxk,jemdsjx,"And if you're using unsafe, a lot of Rust's reason for existence gets thrown out the window.",0.0,Rust
128waxk,jemdsjx,"If you're just using C to write an intepreter for your high-level language, that doesn't matter and so C's design, but there are a lot of lower-level portability situations where that matters quite a bit.",0.0,C
128waxk,jemdsjx,The ecosystem of C is vast and more pervasive than you can imagine.,0.25,C
128waxk,jemdsjx,The processor you're viewing this page on was literally built with optimizations on C idioms built into the physical silicon.,0.0,C
128waxk,jemdsjx,"There are a lot of mistakes C made in design, but at this point you'll have to copy those mistakes to interop with the world which has also copied those mistakes when it isn't just written in C.",0.0,C
128waxk,jekooj8,Rust is the primary C alternative and is even accepted in the Linux kernel now.,0.4,Rust
128waxk,jekooj8,Rust is the primary C alternative and is even accepted in the Linux kernel now.,0.4,C
128waxk,jekooj8,"The most interesting thing about C isn't it normal programming applications, but rather it's place as the underlying language for many programming languages.",0.4125,C
128waxk,jekooj8,"Python for example is written in C. So in many ways, python is a replacement for C when you need to do higher level tasks.",0.375,Python
128waxk,jekooj8,"Python for example is written in C. So in many ways, python is a replacement for C when you need to do higher level tasks.",0.375,C
128waxk,jekvx4p,In C functions are not marked at all; you have to infer where they are!,-0.0625,C
128waxk,jekvx4p,"---------  What I'm doing:  I'm working on Yaksha as kind of a C replacement (at least for me personally), it compiles to C too.",0.09999999999999999,C
128waxk,jekuryi,"You'd get some of those features in D, but it's much more C-like than what you've described.",0.5,D
128waxk,jeo461t,"C closesed competitor used to be Pascal and Modula, but the emerging dominance of the C-based Unix systems and the lack of standartisation beyond a teaching focussed subset allowed C to beat them decisively.",0.0,C
128waxk,jeo461t,"C closesed competitor used to be Pascal and Modula, but the emerging dominance of the C-based Unix systems and the lack of standartisation beyond a teaching focussed subset allowed C to beat them decisively.",0.0,Pascal
128waxk,jeo461t,"Rust reignited an interest in low level languages and a few C likes have popped up, with Zig (which is however not that similar, if you think about it) on the top.",0.075,Rust
128waxk,jeo461t,"Rust reignited an interest in low level languages and a few C likes have popped up, with Zig (which is however not that similar, if you think about it) on the top.",0.075,C
128waxk,jeo461t,"The only languages that really took of in the recent years are does that managed to provide some benefit even a manager could gasp (like Rust with its memory savety or Python with it's good support for scientific, but also data processing capabilities.)",0.22499999999999998,Rust
128waxk,jeo461t,"The only languages that really took of in the recent years are does that managed to provide some benefit even a manager could gasp (like Rust with its memory savety or Python with it's good support for scientific, but also data processing capabilities.)",0.22499999999999998,Python
128waxk,jekz2rs,"The ""begin end"" was **carefully studied and designed** by it's Pascal inventor Nicklaus Wirth, as **code encapsulation**, several lines of code been encapsulated as a single concept.",-0.05714285714285714,Pascal
128waxk,jekz2rs,"There are other ways, like lambda parentheses style or space identation style like Python or keyword plus end keyword like Basic's ""for end for"" that other P.L.",-0.08333333333333333,Python
128waxk,jekz2rs,"I learned Basic first, later Pascal and C, and lambda style LISP.",0.08333333333333333,Pascal
128waxk,jekz2rs,"I learned Basic first, later Pascal and C, and lambda style LISP.",0.08333333333333333,C
128waxk,jekz2rs,"I also learned a version of Basic that was space idented just like Python does this days, and although I like code to be idented for clarity reasons, ...  ...",0.0,Python
128waxk,jekz2rs,I disagree to use Python or any P.L.,0.0,Python
128waxk,jekz2rs,"**  If you or any developer needs close access to the processor (s), motherboard, or O.S., it should be a P.L., than like C uses pointers, can't pass or returns parameters that aren't bigger than a CPU's register.",0.0,C
128waxk,jekz2rs,"Otherwise, Pascal and other P.L.",-0.125,Pascal
128waxk,jekz2rs,"**A lot of developers want the features of a C, without it's pitfalls.",0.0,C
128waxk,jekz2rs,**  Which are some of C's pitfalls besides using semicolons and braces ?,0.0,C
128waxk,jekz2rs,"There have been requested those types to be added to JS and Java, cause in some cases, they may interact with A.P.I.",0.0,Java
128waxk,jekz2rs,"So, a C alternative should consider this.",0.0,C
128waxk,jekz2rs,Rust did.,0.0,Rust
128waxk,jekz2rs,"This is one of oddest things that C doesn't have as an standard, even if it's a very ""close to hardware"" feature.",0.1,C
128waxk,jekz2rs,"A C alternative should have this implemented as an standard in the P.L., syntax, libraries and compiler.",0.0,C
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,Pascal
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,C
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,C++
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,Java
128waxk,jekz2rs,"But not C, due backward compatibility.",0.0625,C
128waxk,jekz2rs,"**Instead of suggesting C alternatives, I started mention the features that a valid C P.L.",0.0,C
128waxk,jet3wzp,"Here are some characteristics of C (from a deleted post in response to a specific suggested language, but I feel are worth listing generally):  * It has a primitive type system that more or less matches current hardware * It allows unrestricted conversions between any types (except, oddly, between object and function pointers, but that can be bypassed easily) * It allows untagged, unchecked unions * It allows type punning * Its type system is used in the APIs of 1000s of libraries and is low level enough to be accessed from many higher level languages (eg.",0.1416666666666667,C
128waxk,jet3wzp,"I can use those libraries from my interpreted, dynamic language) * It can be implemented for a modern PC in 180KB for the compiler (Tiny C; my attempt was 360KB) * It can be compiled at 1 million lines per second on a modest PC with a single core (again tcc) * It has raw pointers and `goto`; basic building blocks, that allow you express anything, and which simplify using this as a transpilation target * It is small and simple enough for someone to feel like they understand the language and can write code they can be confident about  The picture is one of a small, flexible, lightweight, manageable and dependable tool, which doesn't try to do too much (like a pencil, or a screwdriver).",0.0141287284144427,C
128waxk,jet3wzp,"However, C itself has many issues.",0.5,C
128waxk,jf12n4t,">My own systems language, is another private one (I can't support it) that I've always used in place of C. Below I've listed 35 or so differences and enhancements to C  On one side you list enhancements over C, that your systems language has, and on the other side you state that you can't support it.",0.15833333333333333,C
128waxk,jf4wkku,In short: C is too adequate in its domain.,0.16666666666666666,C
128waxk,jf4wkku,"It is easy to get wrong, but if you manage to play by the rules then C rules the world with truth and grace.",-0.033333333333333326,C
128waxk,jf4wkku,(Let Earth receive her C!),0.0,C
128waxk,jekyb94,"Pascal was a C alternative, but sadly other circumstances killed its usage and ""C won"".",-0.1625,Pascal
128waxk,jekyb94,"Pascal was a C alternative, but sadly other circumstances killed its usage and ""C won"".",-0.1625,C
128waxk,jekyb94,"A lot of people claim to work on C alternatives, upgrades or fixes, but ultimately end up with a language that is really unlike C. I would say that perhaps Zig is closest to a C alternative, but the language has drifted away from C's philosophy quite a bit (which is not necessarily bad, it's just that it's a different kind of language).",0.22999999999999998,C
128waxk,jekyb94,"I'm trying to create a C alternative myself, but I'm convinced at this point that I'll end up with a completely different language.",0.0,C
128waxk,jekyb94,"✅ - Arrays with value semantics ❌ (lol, code smell) - Slices ✅ (but not first-order) - Properties such as... ❌✅ (handled differently) - Built-in read and print statements ❌ (lol, platform dependent and potentially completely absent on some platforms) - Functions: keyword parameters and optional parameters with default values ✅ - Reference parameters ✅ - Multiple function return values ❌✅ (done with array/tuple under the hood) - and multiple assignments ❌ (lol, code smell) - Expresson-based [sic]: statements and expression are interchangeable ❌ (lol, code and design smell) - Named constants ❌✅ (not handled explicitly) - Table data ❌ (LOL, the language would DEFINITELY not be a C alternative if this was built in) - Bit and bitfield accesses ✅ - Embedded text and binary files ❌ (biggest code smell I have heard of, YIKES) - Chained comparisons ❌ (have a better way of doing it) - range checks ✅ (but general solution) - check against N values ✅ (also general solution) - Extra built-in ops ❌ (everything but basic binary ops is opt-in) - Far less UB than in C ✅ (but depends on what far less means) - Compiler options to run directly from source ❌ (the compiler is not an interpreter or launcher, infeasible given how long some compilation times are potentially) - produce a single amalgamated source file for a whole application ❌ (but because it is not generally possible) - The compiler itself is self-contained ✅ - compiler is very fast.",0.185379188712522,C
128waxk,jekyb94,"❌✅ (depends on the definition of very fast, objectively it is not fast because it does a lot of optimisations, relatively it is)  Some of these are so disjoint from what C is and aims to be you should really reconsider how you call the language you're looking for.",0.09,C
128waxk,jekyb94,"Based on these points it's something other than a ""C alternative"".",-0.125,C
128waxk,jekyb94,The language you're looking for is closer in scope to C++.,0.0,C++
128waxk,jelwdwq,This is literally why Rust exists,0.0,Rust
128waxk,jemrfef,It's always baffled me why no one has come up with a valid C alternative in 50 years.,0.0,C
128waxk,jemrfef,"For example, one of C's essential features is stability and spec conformance.",0.0,C
128waxk,jemrfef,What do Nim and D introduce?,0.0,D
128waxk,jemrfef,"And Walter Bright has the audacity to include a ""better C"" flag.",0.6000000000000001,C
128waxk,jemrfef,"No, Walter, it's not a better C if it has conservative ""gc"".",-0.25,C
128waxk,jenvd2s,"C does have 8-bit signed and unsigned integer types: `int8_t` and `uint8_t` in `<stdint.h>`, though they may not be defined if no other types with such bitwidths exist.",0.03125,C
128waxk,jenvd2s,"If you don't need a precise width, you can also use `[u]int_least8_t` for the smallest type with at least that width and `[u]int_fast8_t` for the fastest type with that width; this variety is considerably more than Rust or Zig offer.",0.20000000000000004,Rust
128waxk,jermrah,Am I the only one here that knows about `_Bitint(n)` in C?,0.0,C
128waxk,jemhpnt,"Yeah, I'm just old enough to remember when Pascal nearly ruled the world --- I progressed from Turbo Pascal to Delphi and I still write in Lazarus when I want to knock up anything portable with a GUI.",0.06666666666666667,Pascal
128waxk,jemhpnt,"Yeah, I'm just old enough to remember when Pascal nearly ruled the world --- I progressed from Turbo Pascal to Delphi and I still write in Lazarus when I want to knock up anything portable with a GUI.",0.06666666666666667,Delphi
128waxk,jemjfz3,The most popular Pascal is nowadays Ada.,0.55,Pascal
128waxk,jemjfz3,The most popular Pascal is nowadays Ada.,0.55,Ada
128waxk,jhro0ob,"I like the good old Delphi, the son of Turbo Pascal.",0.39999999999999997,Delphi
128waxk,jhro0ob,"I like the good old Delphi, the son of Turbo Pascal.",0.39999999999999997,Pascal
128waxk,jhro0ob,But for some reason modern versions of Delphi are absolutely different from the original Delphi language.,0.19166666666666665,Delphi
128waxk,jel5kc2,"👍  But they need a huge community support like Rust, or big commercial sponsor support like Google Go or Microsoft C.",0.13333333333333336,Rust
128waxk,jel5kc2,"👍  But they need a huge community support like Rust, or big commercial sponsor support like Google Go or Microsoft C.",0.13333333333333336,Go
128waxk,jel5kc2,"👍  But they need a huge community support like Rust, or big commercial sponsor support like Google Go or Microsoft C.",0.13333333333333336,C
128waxk,jen1c21,"If you want to address C programmers, you need a ""goto"".",0.0,C
128waxk,jeniznt,"I agree for Zig, but not for Rust.",0.0,Rust
128waxk,jeniznt,Today a lot of PL us a C compiler.,0.0,C
128waxk,jeniznt,Try to do the same with a Rust compiler.,0.0,Rust
128waxk,jelgp8n,"You can do low level programming in a high level language, I’ve done loads in Ada.",0.08,Ada
128waxk,jeuf1a7,The C subreddit has more members than this one for example!,0.625,C
128waxk,jeuf1a7,>We don't have C replacements so to speak because the need isn't really there.,0.2,C
128waxk,jeuf1a7,Nearly every cross-language library exposes a C-like interface expressed in C syntax.,0.1,C
128waxk,jeuf1a7,I use Windows and Linux via functions with interfaces expressed as C headers.,0.0,C
128waxk,jeuf1a7,"Every other language seems to be implemented in C, or targets C.  It does seem there is a need for such a lower level language.",-0.0625,C
128waxk,jenfttn,I was going to mention Forth and Fortran as well as still being used low level alternatives.,0.0,Forth
128waxk,jenfttn,I was going to mention Forth and Fortran as well as still being used low level alternatives.,0.0,Fortran
128waxk,jenfttn,Chips are designed to run C fast.,0.2,C
128waxk,jenfttn,The last language which seriously challenged C on this was Java where there was meaningful talk of creating low level JVM support in silicon.,0.04166666666666667,C
128waxk,jenfttn,The last language which seriously challenged C on this was Java where there was meaningful talk of creating low level JVM support in silicon.,0.04166666666666667,Java
128waxk,jenfttn,"If memory servers, Fujitsu and an Arm vendor put out chips around Java specifications in the 1997-2002 timeframe.",0.0,Java
128waxk,jeop39w,"> And if you're using unsafe, a lot of Rust's reason for existence gets thrown out the window.",0.0,Rust
128waxk,jeop39w,"Yes, writing the unsafe block itself is just as bad as C, or even a bit worse because of the extra invariants you have to uphold, but it's much clearer which code you have to double check.",-0.18,C
128waxk,jeop39w,The unsafety is much more localised in Rust.,0.5,Rust
128waxk,jeop39w,"Rust also has isize and usize, for when you want to have an integer of the native size.",0.0,Rust
128waxk,jepq3h6,"For the unsafe bit, I mean that’s not really a reason to toss Rust, I would assume the unsafe bits are related to the VM and the like.",-0.13749999999999998,Rust
128waxk,jepq3h6,"So yeah needing unsafe in some parts of performant code isn’t bad, like I think you still would greatly benefit from Rust overall at all the other parts of the PL development process… Like yeah needing unsafe in some parts isn’t a reason to ditch Rust, if it was, the entire standard library would need to be dropped because the safety those types provided, is backed by unsafe code… So yeah, the main rule of thumb is avoid unsafe as much as you can, and be damn fucking careful when you need it.",0.026851851851851877,Rust
128waxk,jepq3h6,"So yeah for me the ergonomics of working with Rust (I find it much easier than C to work with), as well as all of the assurances I get in all the places I don’t use unsafe code, outweighs for me the negatives of needing to use unsafe code here and there to maximize performance where I know stuff is safe.",0.35,Rust
128waxk,jepq3h6,"So yeah for me the ergonomics of working with Rust (I find it much easier than C to work with), as well as all of the assurances I get in all the places I don’t use unsafe code, outweighs for me the negatives of needing to use unsafe code here and there to maximize performance where I know stuff is safe.",0.35,C
128waxk,jepq3h6,"I say this as a Rust “fanboy”, and yeah I’ve written my fair share of safe rust, unsafe rust, etc, etc, and yeah I’ve enjoyed it all much more than working with C, and have found maintaining code a lot easier, personally.",0.44000000000000006,Rust
128waxk,jepq3h6,"I say this as a Rust “fanboy”, and yeah I’ve written my fair share of safe rust, unsafe rust, etc, etc, and yeah I’ve enjoyed it all much more than working with C, and have found maintaining code a lot easier, personally.",0.44000000000000006,C
128waxk,jgukz0a,"For example: types like “int” seem risky as opposed to “i64” but they exist for a reason: …  C integer types were a mistake, in fact they hurt portability.",0.0,C
128waxk,jgukz0a,"Ada’s approach to integer types is vastly superior for portability, as well as more elegant.",0.5666666666666667,Ada
128waxk,jgukz0a,>	The ecosystem of C is vast and more pervasive than you can imagine.,0.25,C
128waxk,jgukz0a,The processor you’re viewing this page on was literally built with optimizations on C idioms built into the physical silicon.,0.0,C
128waxk,jgukz0a,Modern hardware does not bow down to C,0.022222222222222213,C
128waxk,jelozmx,"I didn't try C until 1992, and decided I prefered my own half-baked, buggy language (the current one is better!).",0.4083333333333334,C
128waxk,jelozmx,"This analogy may have been used before, but if C was a Model T Ford, I'd be looking for a more modern car for my everyday use.",0.16666666666666666,C
128waxk,jelozmx,"Or maybe I started off with C being a bike, I can't remember!",0.0,C
128waxk,jelozmx,"But this is the C equivalent:      #include <stdio.h>     #include <math.h>          int main(void) {         for (int i=1; i<=10; ++i) {             printf(""%d %f\n"", i, sqrt(i));         }     }  Meanwhile here is the same task in my systems language (the `main` function is not needed, but I left it in to keep it fair; most programs use it):      proc main=         for i to 10 do             println i, sqrt i         end     end  So, I have a preference for clean, clear code.",0.25,C
128waxk,jem43m3,"> Rust is the primary C alternative  No, it's a C++ alternative.",0.4,Rust
128waxk,jem43m3,"> Rust is the primary C alternative  No, it's a C++ alternative.",0.4,C
128waxk,jem43m3,"> Rust is the primary C alternative  No, it's a C++ alternative.",0.4,C++
128waxk,jem43m3,Have you seen the madness of copying and rewriting parts of the kernel's internal API from C to Rust?,0.0,C
128waxk,jem43m3,Have you seen the madness of copying and rewriting parts of the kernel's internal API from C to Rust?,0.0,Rust
128waxk,jem43m3,"If anything, the immense patch that added ""partial"" (read ""incomplete"") Rust support to the Linux kernel should be an indictment of the language, implementation and fanbase.",-0.05,Rust
128waxk,jekxs7a,Rust is not a C alternative.,0.0,Rust
128waxk,jekxs7a,Rust is not a C alternative.,0.0,C
128waxk,jekxs7a,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,Rust
128waxk,jekxs7a,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,C++
128waxk,jekxs7a,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,C
128waxk,jenbfj7,Look at the task I mentioned [here](https://www.reddit.com/r/ProgrammingLanguages/comments/128waxk/comment/jelozmx/?utm_source=share&utm_medium=web2x&context=3); what would it look like in Forth?,0.0,Forth
128waxk,jenbfj7,"And frankly, I'd have no idea how to write Forth.",0.0,Forth
128waxk,jel6vfu,"In C you'd have to use shifts and masks, which is error prone.",0.0,C
128waxk,jel6vfu,An example without bit extraction might be written like this:      const capsmask   = 128     const capsshift  = 7          capslock := (lastkey.ctrlkeystate iand capsmask) >> capsshift  Or maybe using C's `!,-0.9375,C
128waxk,jel6vfu,"Perhaps I should have filtered out the C shortcomings that are commonly improved upon, but my list was things that can enhance C, and yet still keep the spirit of the language.",-0.3,C
128waxk,jelnu6x,I disagree to use Python or any P.L.,0.0,Python
128waxk,jelclha,">   >The ""begin end"" was carefully studied and designed by it's Pascal inventor Nicklaus Wirth, as code encapsulation, several lines of code been encapsulated as a single concept.",-0.05714285714285714,Pascal
128waxk,jelclha,"I said `begin-end` was as bad as braces, for example:      if cond then begin s1; s2 end else begin s3; s4 end     if (cond) {s1; s2;} else {s3; s4;}  compared with languages which got it right, like Algol68 (or Lua for something more recent):      if cond then s1; s2 else s3; s4 end  The first block is delimited with `then .. else`, the second with `else .. end`; what more is needed?",0.11938775510204083,Lua
128waxk,jempc4t,"C has _Bool and since C23, `bool`, `true` and `false` are keywords.",-0.02500000000000005,C
128waxk,jf1aagg,"Given that C *is* extensively used as it is, why shouldn't you be able to do the same thing with say, a more palatable syntax?",0.25,C
128waxk,jf1aagg,"(My simplest function pointer type is `ref proc`, C's is `void(*)(void)`; WTF?)",-0.5,C
128waxk,jf1aagg,"Another is that, if *I*, as an amateur language developer, can make a viable systems language that is one-up on C (one that was used in a commercial environment for 20 years), why can't anybody?",-0.125,C
128waxk,jf1aagg,"That is, either something to replace C without creating something quite different and throwing away too much, or to independently create a language to do that job, as I did.",0.0,C
128waxk,jf1aagg,"There must be 1000s of amateur C compilers about, which slavishly implement all its poor features and quirks.",-0.325,C
128waxk,jf63ewt,"My first attempt at writing a substantial C program (around 2012, after 36 years of not using C), I had used a syntax wrapper to make it more palatable.",0.375,C
128waxk,jf63ewt,"If I *had* to write C, it would only be by using such an approach, because the language as it is frankly stinks.",-0.19999999999999998,C
128waxk,jf63ewt,(BTW Rust is frequently touted as a C-replacement.,0.1,Rust
128waxk,jen9zrw,"Here's another, one of a block of such lines:      ichar h_stdio = strinclude ""headers/stdio.h""  This is used in my C compiler to incorporate the standard headers, to make it self-contained in one file.",0.0,C
128waxk,jen9zrw,>Some of these are so disjoint from what C is and aims to be you should really reconsider how you call the language you're looking for.,0.2,C
128waxk,jen9zrw,"Actually, both my C compiler and my systems language compiler are about 400KB (disregarding any bundled support files); all my features do not make the compiler much bigger.",0.0,C
128waxk,jenazdq,"Not specifically of my language, but of a systems language without all of C's baggage, or its vagaries, but which is still ultra lightweight and small-footprint.",0.0,C
128waxk,jen62ly,"> For example, one of C's essential features is stability and spec conformance  It's true that the language hasn't significantly evolved.",0.24166666666666667,C
128waxk,jen62ly,"So to me, C is the opposite of stable: anyone can specify the dialect of C that they want, and how strict they want it.",0.0,C
128waxk,jen62ly,"Every other C program seems to define its own set of integer types, even when `stdint.h` is available (maybe `int32_t` is just too ugly).",0.04375000000000001,C
128waxk,jenxqy9,Of course D wouldn't fill the same role as C with conservative garbage collection; that's what the 'Better C' mode disables.,0.25,D
128waxk,jenxqy9,Of course D wouldn't fill the same role as C with conservative garbage collection; that's what the 'Better C' mode disables.,0.25,C
128waxk,jenxqy9,"(It leaves the compile-time features intact, though, and D still has dramatically more than C.)",0.5,D
128waxk,jenxqy9,"(It leaves the compile-time features intact, though, and D still has dramatically more than C.)",0.5,C
128waxk,jeojnzz,"Because C has to work on everything, those built-in types are only vaguely defined.",-0.25,C
128waxk,jeojnzz,"Of course, being an optional bolt-on in user code, C knows nothing about those types.",0.0,C
128waxk,jeojnzz,"So, for the basic 8 types (8/16/32/64-bit signed/unsigned), there are dozens of possible denotations in C; some may refer to the same type; some are the same size and signedness, but incompatible.",0.0,C
128waxk,jeojnzz,"If a C replacement did nothing except fix this aspect, that would make a welcome change.",0.8,C
128waxk,jeojnzz,1000s of libraries have APIs expressed as C headers using C types.,0.0,C
128waxk,jerwpvb,"(I used to have a syntax like this for integer sizes:      int*8          # (from Fortran) 8 bytes or 64 bit     int:32         # 32 bits  Then I realised I was never going to use anything other than power-of-two widths, and switched to a handful of fixed, single-token denotations like every other language.)",-0.049999999999999996,Fortran
128waxk,jerynmi,"You write at the top of the lead module `A` (usually that only contains module stuff):      module B     module C     module D  And now, all modules `A B C D` effectively import each other: the exported names of each module are visible to the others.",0.145,C
128waxk,jerynmi,"You write at the top of the lead module `A` (usually that only contains module stuff):      module B     module C     module D  And now, all modules `A B C D` effectively import each other: the exported names of each module are visible to the others.",0.145,D
128waxk,jeq9rzc,Isn't Delphi the reason that Pascal died out?,0.0,Delphi
128waxk,jeq9rzc,Isn't Delphi the reason that Pascal died out?,0.0,Pascal
128waxk,jeq9rzc,"People still using Pascal were told to move to Delphi, but then Borland drove off its customers with its licensing structure, so everyone switched to Free Software compilers.",0.4,Pascal
128waxk,jeq9rzc,"People still using Pascal were told to move to Delphi, but then Borland drove off its customers with its licensing structure, so everyone switched to Free Software compilers.",0.4,Delphi
128waxk,jen3bln,"I use goto in C a lot, so it’s definitely not like I think it’s “bad practice”",-0.3499999999999999,C
128waxk,jepp5p5,"I mean are we talking about a “replacement” for C or something that is “C, but better”?",0.09375,C
128waxk,jepp5p5,"I mean Rust is a very similar, but simultaneously extremely different language than C, and yeah I’m currently unaware of the viability of transpiling Rust to C, which is what I assume you’re suggesting, then piping that into a C compiler… Like yeah it doesn’t seem all that viable, and like idk it feels rather unnecessary when, you can use Rust code from C if you need to, and vice versa… I may be misinterpreting what you mean, but yeah for something to “replace” C, I don’t think it needs to use a C compiler, like it may be a nice to have, but I fail to see it as a bad thing… Lemme know what you think as I could be wrong here",-0.2125,Rust
128waxk,jepp5p5,"I mean Rust is a very similar, but simultaneously extremely different language than C, and yeah I’m currently unaware of the viability of transpiling Rust to C, which is what I assume you’re suggesting, then piping that into a C compiler… Like yeah it doesn’t seem all that viable, and like idk it feels rather unnecessary when, you can use Rust code from C if you need to, and vice versa… I may be misinterpreting what you mean, but yeah for something to “replace” C, I don’t think it needs to use a C compiler, like it may be a nice to have, but I fail to see it as a bad thing… Lemme know what you think as I could be wrong here",-0.2125,C
128waxk,jgz2pov,">C integer types were a mistake, in fact they hurt portability.",0.0,C
128waxk,jgz2pov,"Ada’s approach to integer types is vastly superior for portability, as well as more elegant.",0.5666666666666667,Ada
128waxk,jgz2pov,I don't know Ada's integer system so I can't say C's is better--it would not surprise me at all if Ada's was better.,0.5,Ada
128waxk,jgz2pov,I don't know Ada's integer system so I can't say C's is better--it would not surprise me at all if Ada's was better.,0.5,C
128waxk,jgz2pov,Modern hardware does not bow down to C  It seems like you could have read the sentence you quoted!,0.002777777777777768,C
128waxk,jemaufz,"You might have liked Pascal/VS, which was IBM’s dialect of Pascal.",0.6,Pascal
128waxk,jemqv0s,"I mean if you’ve ever worked with embedded Rust, as well as Rust, you would understand why… I mean you COULD just reuse the C versions of various things you need, but then you’d need to write unsafe code in order to interact with them everywhere… So what then?",-0.20833333333333334,Rust
128waxk,jemqv0s,"I mean if you’ve ever worked with embedded Rust, as well as Rust, you would understand why… I mean you COULD just reuse the C versions of various things you need, but then you’d need to write unsafe code in order to interact with them everywhere… So what then?",-0.20833333333333334,C
128waxk,jemqv0s,"Then you write a safe wrapper around the unsafe code, so that you can use Rust well, safely, which is one of the selling points of the language.",0.5,Rust
128waxk,jemqv0s,"What isn’t, is weighing whether adding the language is a detriment, and what it offers and whether it is worth it… You can’t criticize Rust for adding a lot of code to the kernel, a famously fucking massive project…  As for the incompleteness, I would say that’s more the result of A: Linux being a large project using C and B: for a “complete” Rust experience you would, need to integrate cargo… Like I’m not currently aware of exactly how Linux is built (what build system it uses, how it’s configured, etc.",0.1674107142857143,Rust
128waxk,jemqv0s,"What isn’t, is weighing whether adding the language is a detriment, and what it offers and whether it is worth it… You can’t criticize Rust for adding a lot of code to the kernel, a famously fucking massive project…  As for the incompleteness, I would say that’s more the result of A: Linux being a large project using C and B: for a “complete” Rust experience you would, need to integrate cargo… Like I’m not currently aware of exactly how Linux is built (what build system it uses, how it’s configured, etc.",0.1674107142857143,C
128waxk,jemqv0s,"), but I would assume that it would be somewhat, idk, awkward to integrate cargo into it, somehow…   I mean with all this in mind, I really think it suggests that Rust, isn’t shit, I mean why go through all the hassle, all of that extra work, to intregrate some new fangled language into the Linux kernel, the largest open source project, the thing that runs virtually all of the internet?",-0.13607954545454543,Rust
128waxk,jemqv0s,"I highly doubt they did it for nothing, instead I would assume that those working on the Kernel see Rust as, well something that brings a lot to the table here… Those in charge of the kernel have a lot to weigh when making major decisions like using Rust in the Kernel, and the fact they said “yeah do it”, and went through all that hassle, says to me that they think Rust is valuable to the development of the Kernel, that Rust’s downsides in respect to being used in the Kernel, do not outweigh the benefits.",0.11125,Rust
128waxk,jemqv0s,Like what compiling being slow and Rust devs being passionate?,-0.17500000000000002,Rust
128waxk,jemqv0s,"Like what do you mean here, because yeah all I see here in your post is you describing those in charge of one of the most important pieces of software determining that Rust is ultimately worth the effort, like yeah idk, I’m not too familiar with all the specifics but even if I was entirely wrong up to this point, your criticism still suggests the opposite of what you think it should imply.",0.10892857142857142,Rust
128waxk,jel5f8s,"There is Rust code in the Linux kernel now, I think that's about as OS writing as you can get these days.",0.0,Rust
128waxk,jeky9ea,"I've dropped C entirely in favor of Rust for 5 years now, no issue (embedded systems engineer for space critical systems with hard real-time constraints)",-0.09722222222222222,C
128waxk,jeky9ea,"I've dropped C entirely in favor of Rust for 5 years now, no issue (embedded systems engineer for space critical systems with hard real-time constraints)",-0.09722222222222222,Rust
128waxk,jelcxtr,Dunno why you’re being downvoted for pointing out that Rust is a c++ alternative.,0.0,Rust
128waxk,jemkzjn,>Rust is not a C alternative.,0.0,Rust
128waxk,jemkzjn,>Rust is not a C alternative.,0.0,C
128waxk,jemkzjn,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,Rust
128waxk,jemkzjn,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,C++
128waxk,jemkzjn,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,C
128waxk,jemkzjn,"I don't know Rust myself, I have seen it from afar.",0.0,Rust
128waxk,jemkzjn,(a) Rust is if anything a C++ replacement rather than a C replacement.,0.0,Rust
128waxk,jemkzjn,(a) Rust is if anything a C++ replacement rather than a C replacement.,0.0,C++
128waxk,jemkzjn,(a) Rust is if anything a C++ replacement rather than a C replacement.,0.0,C
128waxk,jemkzjn,"The particular virtue of C, and the reason why it carried the day in its day, is that it's portable assembly.",0.16666666666666666,C
128waxk,jemkzjn,Rust's own mother couldn't claim that of Rust.,0.6,Rust
128waxk,jemkzjn,Rust answers the same question as C++: how do we get close to the metal while being able to have high-level language constructs?,0.25,Rust
128waxk,jemkzjn,Rust answers the same question as C++: how do we get close to the metal while being able to have high-level language constructs?,0.25,C++
128waxk,jemkzjn,"(b) Yes, C was designed to write an OS for the PDP-11.",0.0,C
128waxk,jenjg37,The Algol like low level language is C.   The advantage of Forth is that it is incredibly easy to reason about programs because they decompose cleanly.,0.26666666666666666,Forth
128waxk,jenjg37,You don't write tens of thousands of lines of code in Forth you write dozens at most and get the performance advantages where you need them.,0.5,Forth
128waxk,jenjg37,"Languages like Factor, Postscript and Joy extend Forth to a higher level.",0.525,Forth
128waxk,jenjg37,Here is a reasonable Forth [walk through of the compiler from scratch in assembly](http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.S;h=45e6e854a5d2a4c3f26af264dfce56379d401425;hb=66c56998125f3ac265a3a1df9821fd52cfeee8cc) which is under 2000 lines of assembly.,0.2,Forth
128waxk,jenjg37,Most experienced programmers can learn a Forth in a few days.,0.3666666666666667,Forth
128waxk,jenjg37,The HP calculators used to use a Forth variant because it ran energy efficient on bad hardware quickly while making programming simple and powerful.,-0.016666666666666635,Forth
128waxk,jeolffj,"Regarding the distinction between ""procedure"" and ""function"":  As I see it, the use of the word function in imperative languages like C is a mistake.",0.0,C
128waxk,jeolffj,"Wirth used the word ""function"" in Pascal, but wisely decided to revert to ""procedure"" in Modula.",0.7,Pascal
128waxk,jelx4c0,"I would also like Pascal to be something like:      if ( some boolean expression )     begin         then ... ;         else ... ;     end;  Where ""..."" could be a single instruction or a block, as originally intended, without the ambiguous syntax of the current Pascal.",0.1011904761904762,Pascal
128waxk,jelx4c0,"And C like:      if ( some boolean expression )     {         then ... ;         else ... ;     }  Where ""..."" could be a single instruction or a block, as originally intended, without the ambiguous syntax of the current C.  Cheers.",0.1011904761904762,C
128waxk,jep8fz6,"PASCAL looks good, allowing you to write  **if** *b1* **then** *c1* **else** **if** *b2* **then** *c2* **if** *b3* **then** *c3* **else** *c4*  where as a naive version of ALGOL has  **if** *b1* **then** *c1* **else** **if** *b2* **then** *c2* **else** **if** *b3* **then** *c3* **else** *c4* **fi** **fi** **fi**  with a pile up of closers at the end.",0.19999999999999998,ALGOL
128waxk,jep8fz6,Sophisticated versions of ALGOL style syntax of course allow  **if** *b1* **then** *c1* **elif** *b2* **then** *c2* **elif** *b3* **then** *c3* **else** *c4* **fi**  so yes Algol68 gets it right.,0.39285714285714285,ALGOL
128waxk,jf8nbqw,"C also has trigraphs, so if you can't type braces, you're not sunk.",0.0,C
128waxk,jelgujd,People say C replacement but really it's something else.,0.2,C
128waxk,jet9k72,I used `int2pow<size_t>` (C++) at some point.,0.0,C++
128waxk,jf3xagk,"Arguably Borland is the reason Delphi died out, but Pascal stood the test of time.",0.0,Delphi
128waxk,jf3xagk,"Arguably Borland is the reason Delphi died out, but Pascal stood the test of time.",0.0,Pascal
128waxk,jen7mp9,"A common use of C is as a target language for compilers and transpilers, where `goto` is necessary to emulate control flow constructs that don't exist in the target.",-0.15,C
128waxk,jen7mp9,Sometimes 'linear' C is generated which only uses `if` and `goto` for all control flow.,0.0,C
128waxk,jew2ep6,I've meant transpiling any language (that currently uses a C compiler) to Rust code that then is compiled by the Rust compiler.,0.0,C
128waxk,jew2ep6,I've meant transpiling any language (that currently uses a C compiler) to Rust code that then is compiled by the Rust compiler.,0.0,Rust
128waxk,jelmu28,"Ada was green, the red manual is online, blue and yellow are not; not related to the red you’re talking about.",-0.03333333333333333,Ada
128waxk,jewgn2p,"But the HLL does need to know the API used, and this API is very often expressed via a C header file (in the case of GTK, via 700 header files across a dozen directories).",0.2,C
128waxk,jewgn2p,The HLL will need to create bindings in its own language (unless it incorporates an entire C subsystem like Zig).,0.3,C
128waxk,jewgn2p,"Those C headers won't be a single, flat header without nested includes, conditional blocks, C-compiler-specific code (there is no C compiler!",-0.05133928571428571,C
128waxk,jewgn2p,"It will be a mess, one that needs a C compiler to make sense of.",-0.175,C
128waxk,jewgn2p,"So at the very least, if we're going to be stuck with C for this purpose, try harder to create conservative header files such as I've described, that could even be processed with a script rather than needing half a C compiler.",-0.16416666666666666,C
128waxk,jewgn2p,"(This is getting off the topic of a C replacement, but it shows C is entrenched everywhere.)",0.0,C
128waxk,jh1srp4,"C integer types are a half-assed measure for portability, they divorce the language from any particular platform *but they actively harm cross platform code portability*.",0.011111111111111108,C
128waxk,jh1srp4,In K&R C there’s no fucking way to understand what `int a` means without knowing what platform *it was written on!,0.375,R
128waxk,jh1srp4,In K&R C there’s no fucking way to understand what `int a` means without knowing what platform *it was written on!,0.375,C
128waxk,jh1srp4,* It’s the entire reason C89 introduced minimums on C integer types.,0.0,C
128waxk,jenkxhb,> You can’t criticize Rust for adding a lot of code to the kernel  You're not my supervisor!,0.0,Rust
128waxk,jenkxhb,Adding Rust to the pot was a mistake.,0.0,Rust
128waxk,jenkxhb,"> I really think it suggests that Rust, isn’t shit  Which was the whole point - impressing people who know nothing about the Linux kernel (or Rust, for that matter).",0.06666666666666667,Rust
128waxk,jeldg9g,"We had people writing Linux code/modules in Ada over a decade ago, the blogs are still out there if you search for it, but nobody tried to donate it to the kernel because Linus probably would’ve thrown a hissy fit.",0.4,Ada
128waxk,jelbs2s,It does not change what Rust or C are.,0.0,Rust
128waxk,jelbs2s,It does not change what Rust or C are.,0.0,C
128waxk,jelbs2s,"One should also acknowledge that in terms of Rust's role in the Linux kernel, it has been criticized many times by Linus for essentially not being able to bend according to the kernel's needs.",0.3333333333333333,Rust
128waxk,jelbs2s,"Now, it is true that Linus only really likes C (to some extent), and it is true that he is a highly opinionated and dramatic individual, however, if you are trying to commit an appeal to authority, then Linus is a much greater authority on C than whatever implication is being made by Rust being used for Linux' kernel.",0.14083333333333334,C
128waxk,jelbs2s,"Now, it is true that Linus only really likes C (to some extent), and it is true that he is a highly opinionated and dramatic individual, however, if you are trying to commit an appeal to authority, then Linus is a much greater authority on C than whatever implication is being made by Rust being used for Linux' kernel.",0.14083333333333334,Rust
128waxk,jel445c,"This does not mean Rust is a C alternative, this simply means you have replaced C with Rust for whatever it is you do.",0.078125,Rust
128waxk,jel445c,"This does not mean Rust is a C alternative, this simply means you have replaced C with Rust for whatever it is you do.",0.078125,C
128waxk,jel445c,"That does not change what C or Rust are and aim to do, that just changes how you use either of them.",0.0,C
128waxk,jel445c,"That does not change what C or Rust are and aim to do, that just changes how you use either of them.",0.0,Rust
128waxk,jel445c,"I have also initially replaced C with C#, and then with Python, but I would call neither of them an alternative for their predecessor.",0.0,C
128waxk,jel445c,"I have also initially replaced C with C#, and then with Python, but I would call neither of them an alternative for their predecessor.",0.0,Python
128waxk,jeld3wu,I'm also surprised but I assume the Rust cult took it as an insult (even though it's not meant to be one).,0.1,Rust
128waxk,jennmah,>The Algol like low level language is C.  Algol-style is quite different from C which uses braces.,0.0,C
128waxk,jennmah,I said in my OP that 80% of my issues with C were with its syntax.,0.0,C
128waxk,jennmah,With Forth it would be more like 98%!,0.625,Forth
128waxk,jennmah,&#x200B;  >You don't write tens of thousands of lines of code in Forth you write dozens at most and get the performance advantages where you need them.,0.5,Forth
128waxk,jennmah,"If a program *needs* 10,000 lines of code to do what it has to do, then how would a Forth program magically reduce that to 10-100 lines?",0.5,Forth
128waxk,jennmah,"As for performance, I actually have no idea whether Forth is compiled, interpreted or both.",0.0,Forth
128waxk,jennmah,I get the impression that Forth is a language you make up as you go.,0.0,Forth
128waxk,jennmah,"Forths can have around 3-8k compilers, complex ones might be 32k  The GForth I downloaded for Windows a few weeks ago (to do with a sub-thread about using Forth as a target language), was 130KB.",-0.25,Forth
128waxk,jennmah,"As I said, it's not meant for users to directly program in, but I would  find it considerably easier to do so compared with Forth.",0.1,Forth
128waxk,jennmah,"Here's the square root program in my link, expressed in that IL (I've switched from `println` to C's `printf` to keep it more compact):      proc main export         local    i64   .i      ;------------------------         loadimm  i64   1          store    i64   .i      #25:         load     i64   .i          float    r64 i64          sqrt     r64            load     i64   .i          loadimm  u64   ""%lld %f""          callp          printf* 3 2         forup          #25 .i 10 1     end  >250k compiler.",0.2222222222222222,C
128waxk,jennmah,"That was the minimum installation size for a C compiler that would build my generated code, which uses no headers.",0.0,C
128waxk,jennmah,It might have been more like 230KB for the 2-3 Tiny C files needed.,0.25,C
128waxk,jeq4ey3,"Algol60, Pascal and C approach it by only allowing single statements in all branches.",-0.03571428571428571,Pascal
128waxk,jeq4ey3,"Algol60, Pascal and C approach it by only allowing single statements in all branches.",-0.03571428571428571,C
128waxk,jeq4ey3,"Preferably a tangible one (not one you have to infer, as in ~~Pascal~~ Python and Nim, from a negative change in indentation, assuming something follows).",-0.3,Python
128waxk,jencuw0,"So say you have this:        ...     if (...) goto A;     ...     if (...) goto B;     ...     A:     ...     B:     ...  Then this can be rewritten as:     switch (START)     {       case START:         ...         if (...) nextcase A;         ...         if (...) nextcase B;         ...         nextcase;       case A:         ...         nextcase;       case B:         ...     }  Not particularly elegant, but will work *exactly* like the C example down to the underlying instructions.",-0.051851851851851864,C
128waxk,jenvijo,">A common use of C is as a target language for compilers and transpilers, where goto is necessary to emulate control flow constructs that don't exist in the target.",-0.15,C
128waxk,jenvijo,Sometimes 'linear' C is generated which only uses if and goto for all control flow.,0.0,C
128waxk,jenvijo,"I've seen C used as a transpilation target many times, but haven't heard of 'linear' C or languages that have such control flow as in the 2nd paragraph.",0.16666666666666666,C
128waxk,jeohwau,You just keep using C as your compiler target.,0.0,C
128waxk,jew5rsv,It seems to be relatively easy to transpile C to Rust.,0.43333333333333335,C
128waxk,jew5rsv,It seems to be relatively easy to transpile C to Rust.,0.43333333333333335,Rust
128waxk,jf6ffwf,"If you're looking to replace C as a compilation target, then the answer is LLVM IR.",0.0,C
128waxk,jh35yp1,"C integer types are a half-assed measure for portability, they divorce the language from any particular platform but they actively harm cross platform code portability.",0.011111111111111108,C
128waxk,jh35yp1,In K&R C there’s no fucking way to understand what int a means without knowing what platform it was written on!,0.375,R
128waxk,jh35yp1,In K&R C there’s no fucking way to understand what int a means without knowing what platform it was written on!,0.375,C
128waxk,jh35yp1,It’s the entire reason C89 introduced minimums on C integer types.,0.0,C
128waxk,jh35yp1,"No one cares about K&R C.  > Also, your example is bad because there are many, many cases where a 64 bit integer is legitimately needed, and chopping that down to anything less breaks the program.",-0.0044444444444444176,R
128waxk,jh35yp1,"I can, however, reasonably assume that the person reading this page is doing so using an Intel, AMD, or ARM chip, all of which do in fact have instructions geared toward supporting C semantics.",0.225,C
128waxk,jeoiz5b,"Like yeah no it’s one thing to be sketical and entirely another thing to look at one of the most important pieces of software integrating a new language, a project that has been famous for it’s strict policy of “C, C everywhere, everything on C”, and to go “yeah those people in charge of that, and maintainers of that, yeah they’re just doing it for ‘prestige’, couldn’t possibly be any other reason”.",0.20162337662337662,C
128waxk,jeoiz5b,"Do you realize how fucking stupid you sound, you literally remind me of the fucking weirdos who hate Rust because they have a code of conduct that essentially says “don’t be a fucking bigot and we aight”, like you’re extremely attached to this idea that it’s a shitty language in it’s entirety and I seriously have to ask, why?",-0.3572916666666667,Rust
128waxk,jemr100,"and Rust still made it in, which says something, no?",0.0,Rust
128waxk,jem07ap,"From my point of view the major issues with C are in fact safety related, when you're doing low level bit twiddling you *really* don't want to accidentally overwrite the wrong memory location, since on embedded systems devices are usually memory mapped and there's no OS to stop you from doing dangerous things.",-0.15535714285714283,C
128waxk,jem07ap,Source: I'm an embedded systems engineer interested in robotics and looking to learn Rust soon because I see it being used in my space more and more as a C alternative.,0.4166666666666667,Rust
128waxk,jem07ap,Source: I'm an embedded systems engineer interested in robotics and looking to learn Rust soon because I see it being used in my space more and more as a C alternative.,0.4166666666666667,C
128waxk,jeli8ny,"The sheer size of Rust prevents it from being used in certain circuits like onboard aircraft systems etc  Linus, an opinionated jerk, and linux is not an all encompassing test",0.10714285714285714,Rust
128waxk,jel4mta,Thus for my use cases Rust is a great alternative to C. Like Python could be for some of your use cases.,0.8,Rust
128waxk,jel4mta,Thus for my use cases Rust is a great alternative to C. Like Python could be for some of your use cases.,0.8,Python
128waxk,jel4mta,I have yet to see any use case where Rust would be a bad alternative to C,-0.6999999999999998,Rust
128waxk,jel4mta,I have yet to see any use case where Rust would be a bad alternative to C,-0.6999999999999998,C
128waxk,jelwiq9,Just checking in to say that I agree with you on rust not being a C alternative in the sense that it could not fill the entirety of C use cases.,0.0,C
128waxk,jelwiq9,There’ll never be a _”true”_ alternative to C because one is not needed.,0.35,C
128waxk,jelwiq9,"C has become so elementary as to be cemented on most platforms, becoming part of the stack in a sense.",0.4166666666666667,C
128waxk,jelwiq9,"Rust will never be as light, pervasive nor portable as C, and C will never be as safe, approachable and maintainable as Rust.",0.45,Rust
128waxk,jelwiq9,"Rust will never be as light, pervasive nor portable as C, and C will never be as safe, approachable and maintainable as Rust.",0.45,C
128waxk,jeldtec,"If ""Rust is a C++ replacement"" and ""C++ is an extended C"" (or, in other words, C++ is a superset of C), then Rust has to be a replacement for C as well.",-0.125,Rust
128waxk,jeldtec,"If ""Rust is a C++ replacement"" and ""C++ is an extended C"" (or, in other words, C++ is a superset of C), then Rust has to be a replacement for C as well.",-0.125,C++
128waxk,jeldtec,"If ""Rust is a C++ replacement"" and ""C++ is an extended C"" (or, in other words, C++ is a superset of C), then Rust has to be a replacement for C as well.",-0.125,C
128waxk,jeldtec,It can do everything C can.,0.0,C
128waxk,jen843i,"This does not mean that Java's purpose was writing OS' for small computers, that it is good at it, or that it is by extension a C alternative.",0.2020833333333333,Java
128waxk,jen843i,"This does not mean that Java's purpose was writing OS' for small computers, that it is good at it, or that it is by extension a C alternative.",0.2020833333333333,C
128waxk,jeowvrc,*A fortiori* it's possible to do that in Rust and C++.,0.0,Rust
128waxk,jeowvrc,*A fortiori* it's possible to do that in Rust and C++.,0.0,C++
128waxk,jeowvrc,But C was for that particular: the fact that it was successful for other purposes was because back then the control it gave you over use of memory and time was worth the sacrifice of having as little abstraction as the authors could get away with.,0.15069444444444444,C
128waxk,jeoqipv,Braces function in C as shorthand for 𝐛𝐞𝐠𝐢𝐧 and 𝐞𝐧𝐝.,0.0,C
128waxk,jeoqipv,"C even has a preprocessor that permits you to do:      #define BEGIN {     #define END }  and additionally, as I know you prefer the Algol 68 style of bracketing flow constructs:      #define IF if(     #define THEN ) {     #define ELIF } else if(     #define ELSE } else {     #define FI }     ...  (and I know this ""Bournegol"" style - used by Steven Bourne - is both ridiculed and scorned by ""real"" C programmers; however, it's consistent use could have prevented the 2014 Apple ""goto fail"" vulnerability for example.)",-0.016666666666666663,C
128waxk,jeoqipv,"However, what I believe is a far worse omission in C, is the lack of real nested block structure.",-0.03333333333333335,C
128waxk,jeoqipv,"At least Pascal has it in a degenerate form, allowing nested procedures.",-0.3,Pascal
128waxk,jeoqipv,"And apparently this is *so* hard to add to C, that even the GNUC extension for it is problematic (something about trampolines, NX and executable stack...",-0.12083333333333335,C
128waxk,jep1fke,> Algol-style is quite different from C which uses braces.,0.0,C
128waxk,jep1fke,I said in my OP that 80% of my issues with C were with its syntax.,0.0,C
128waxk,jep1fke,With Forth it would be more like 98%!,0.625,Forth
128waxk,jep1fke,You are obviously fairly comfortable with Assembly which means you can handle a pretty high degree of awkward syntax.,0.05250000000000002,Assembly
128waxk,jep1fke,"> As I said, it's not meant for users to directly program in, but I would find it considerably easier to do so compared with Forth.",0.1,Forth
128waxk,jep1fke,I agree that looks easy though not sure why it is easier than Forth (at least one like gforth which has more stuff in it).,0.09583333333333334,Forth
128waxk,jf4x80y,Pascal on the JVM!,0.0,Pascal
128waxk,jhroffs,I know at least one modern program which still uses Pascal / Delphi.,-0.04999999999999999,Pascal
128waxk,jhroffs,I know at least one modern program which still uses Pascal / Delphi.,-0.04999999999999999,Delphi
128waxk,jfaujqw,It's really nice to use the Free Pascal toolchain for Atmel microcontrollers.,0.5,Pascal
128waxk,jenzn3q,"A Fibonacci function might end up as this C:      static i64 fib(i64 n) {         u64 S1, S2;         S1 = n;         S2 = 3;         if ((i64)S1 >= (i64)S2) goto L2;         S1 = 1;         goto L3;     L2:         S1 = n;         S2 = 1;         *(i64*)&S1 -= (i64)S2;         S1 = fib(S1);         S2 = n;         S3 = 2;         *(i64*)&S2 -= (i64)S3;         S2 = fib(S2);         *(i64*)&S1 += (i64)S2;     L3:         goto L4;     L4:         return S1;     }  The `S1 S2` etc represent the stack of the VM (only 2 slots are needed here).",-0.4166666666666667,C
128waxk,jenzn3q,The generated C requires an optimising compiler to mop up all the redundant temps.,-0.2,C
128waxk,jenzn3q,"For examples of erratic use of `goto`, try and look at examples of Fortran IV or earlier.",0.0,Fortran
128waxk,jenzn3q,"Conceivably, somebody might want to port a routine in that language directly into C, rather than try and rewrite it.",0.1,C
128waxk,jem14ie,Rust has the ability to drop the standard library and everything else so you are writing code with zero dependencies.,0.0,Rust
128waxk,jem14ie,"I've seen a few research kernels written entirely in Rust, you still get the compile time safety checks and runtime bounds checks (unless you disable that too for speed, it's also an option) so it's still safer than C while being able to target pretty much everything (that has compiler support) that C can.",0.15,Rust
128waxk,jem14ie,"I've seen a few research kernels written entirely in Rust, you still get the compile time safety checks and runtime bounds checks (unless you disable that too for speed, it's also an option) so it's still safer than C while being able to target pretty much everything (that has compiler support) that C can.",0.15,C
128waxk,jem14ie,"Note the compiler support, that is one area that C has a legitimate leg up in, and it's because a lot of embedded systems use a customized gcc compiler,  since rust doesn't yet have a GCC frontend and even if it did most of those tool chains are too old to use it, C is your only option still.",0.19999999999999998,C
128waxk,jemreao,"So yeah not sure the exact limitations of these systems but you can make Rust extremely small, embedded Rust can be extremely small, like as I said I managed to fit all of that into 512 bytes.",-0.019999999999999997,Rust
128waxk,jel5q8a,"However, Rust cannot be another possibility or choice for the tasks C was made and intended for, because it inherently isn't made to do those tasks, nor does it do them particularly well.",0.16666666666666666,Rust
128waxk,jel5q8a,"However, Rust cannot be another possibility or choice for the tasks C was made and intended for, because it inherently isn't made to do those tasks, nor does it do them particularly well.",0.16666666666666666,C
128waxk,jel5q8a,"Although Rust is a replacement for you given your workload, and perhaps an alternative language for what you do, Rust cannot fundamentally be a C alternative, because it isn't even meant to do what C does and is intended for.",0.0,Rust
128waxk,jel5q8a,"Although Rust is a replacement for you given your workload, and perhaps an alternative language for what you do, Rust cannot fundamentally be a C alternative, because it isn't even meant to do what C does and is intended for.",0.0,C
128waxk,jel5q8a,Good luck doing that without `unsafe` or with whatever targets Rust emits code for.,0.7,Rust
128waxk,jel5q8a,Good luck targetting those architectures with Rust (whereas implementing a C compiler for such a platform was usually done in a week).,0.15,Rust
128waxk,jel5q8a,Good luck targetting those architectures with Rust (whereas implementing a C compiler for such a platform was usually done in a week).,0.15,C
128waxk,jel5q8a,"Also, good luck fitting the Rust compiler on what constituted a small computer (also called minicomputer) back when C was developed (or even now).",0.21000000000000002,Rust
128waxk,jel5q8a,"Also, good luck fitting the Rust compiler on what constituted a small computer (also called minicomputer) back when C was developed (or even now).",0.21000000000000002,C
128waxk,jelgk0x,But I did not claim I got downvoted because of the Rust cult.,0.0,Rust
128waxk,jelgk0x,I claimed that I assume the Rust cult took it as an insult.,0.0,Rust
128waxk,jelgk0x,The Rust cult is widespread over programming subreddits and was sighted here multiple times.,0.0,Rust
128waxk,jem52rc,"Unless you've been living under a rock, both Rust and Zig have their toxic brigadeering hordes... the latter increasingly outdoing the former.",0.0,Rust
128waxk,jeleft3,"C++ was not meant to inherit the purpose of C. It was supposed to be C with classes at first, yes, but it was always intended for large systems, unlike C. It lacked the purpose of building operating systems altogether, let alone for small computers specifically (although mainframe/minicomputer distinction was dying by the time C++ was developed).",0.07857142857142857,C++
128waxk,jeleft3,"C++ was not meant to inherit the purpose of C. It was supposed to be C with classes at first, yes, but it was always intended for large systems, unlike C. It lacked the purpose of building operating systems altogether, let alone for small computers specifically (although mainframe/minicomputer distinction was dying by the time C++ was developed).",0.07857142857142857,C
128waxk,jeleft3,Rust can never be a C alternative simply because it is too different.,0.0,Rust
128waxk,jeleft3,Rust can never be a C alternative simply because it is too different.,0.0,C
128waxk,jeleft3,"Really, no modern GPL can be a C alternative given that it would be too big and given that today's motivation for GPLs is much different than those that existed when C was developed.",0.0,C
128waxk,jeleft3,"Not to mention that it's highly likely that a language of similar size to C would be considered incomplete (look at most common Go criticism, ex.).",0.05,C
128waxk,jeleft3,"Not to mention that it's highly likely that a language of similar size to C would be considered incomplete (look at most common Go criticism, ex.).",0.05,Go
128waxk,jeleft3,"So no, Rust being a C extension transitively does not imply Rust is a C alternative.",0.0,Rust
128waxk,jeleft3,"So no, Rust being a C extension transitively does not imply Rust is a C alternative.",0.0,C
128waxk,jeleft3,Just like Java being a C replacement (words from authors) does not mean Java is a C alternative.,0.15625,Java
128waxk,jeleft3,Just like Java being a C replacement (words from authors) does not mean Java is a C alternative.,0.15625,C
128waxk,jeleft3,"Every turing complete language can do everything C can, that is a redundant argument.",-0.05,C
128waxk,jeleft3,I've given examples of where Rust sucks for the very purpose C was built for in another comment as well.,-0.04999999999999999,Rust
128waxk,jeleft3,I've given examples of where Rust sucks for the very purpose C was built for in another comment as well.,-0.04999999999999999,C
128waxk,jep1gtc,">C even has a preprocessor that permits you to do:  The extraordinary thing about the C preprocessor is that it has Algol-style blocks for its conditional statements:      #if     #elif     #else     #endif  It has clearer, safer syntax then the main language!",0.2708333333333333,C
128waxk,jep1gtc,">what I believe is a far worse omission in C, is the lack of real nested block structure.",-0.03333333333333335,C
128waxk,jep1gtc,"At least Pascal has it in a degenerate form, allowing nested procedures.",-0.3,Pascal
128waxk,jeq1ke6,Forth is just TOO much stack based.,0.2,Forth
128waxk,jeq1ke6,I have taken something away from Forth which is the `(a--b)` notation that describes the stack behaviour.,0.0,Forth
128waxk,jfb4fsw,Nobody else would want to learn Pascal.,0.0,Pascal
128waxk,jemrlw9,"Yeah I wrote a shitty bootloader in Rust (MBR), that had the ability to print and encode numbers to hexadecimal (without a buffer, I used logarithms, I can’t remember the exact specifics of how I did it), a small bump allocator, and so on, and it all fit within 512 bytes, with various optimizations enabled and fucking with the linker, but yeah if you’re main issue is size constraints, you were probably already doing that… So yeah, Rust, fucking small language when you need it to be.",-0.04047619047619048,Rust
128waxk,jem5ces,"If something goes wrong, you only need to check the areas marked explicitly with unsafe, rather than the entire code base as you would in C. Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",-0.04375000000000001,Rust
128waxk,jem5ces,"If something goes wrong, you only need to check the areas marked explicitly with unsafe, rather than the entire code base as you would in C. Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",-0.04375000000000001,C
128waxk,jem5ces,"You'd do that on your development machine, which is significantly more powerful, and I'm pretty sure that you wouldn't be able to run modern C compilers like Clang (which uses the same backend as rust) on such limited systems anyway.",0.24206349206349204,C
128waxk,jem5ces,Why would we care if the compiler can run on machines that were around when C was first invented?,0.25,C
128waxk,jem5ces,"Yeah, it probably couldn't, and at the time C was awesome.",1.0,C
128waxk,jem5ces,"But times have changed, we've gotten a lot better at making programming languages, our computers have gotten a lot more powerful, and a lot of people have been bitten by C's lack of safety.",0.43333333333333335,C
128waxk,jem5ces,"Rust isn't for everyone, and that's fine, but making up excuses for why we shouldn't use it is not a solution to a very obvious set of problems we have in front of us today.",0.20833333333333334,Rust
128waxk,jem5ces,"Rust can do everything C can, and it can do it with better safety, something that is particularly important in the areas that traditionally only C was used, like embedded systems.",0.3,Rust
128waxk,jem5ces,"Rust can do everything C can, and it can do it with better safety, something that is particularly important in the areas that traditionally only C was used, like embedded systems.",0.3,C
128waxk,jem5ces,Source: I'm an embedded systems engineer who has seen *a lot* of bugs caused by C that would have been caught by rust.,0.0,C
128waxk,jem9he7,>I did not claim I got downvoted because of the Rust cult.,0.0,Rust
128waxk,jels0fs,"And Rust meets that criteria regarding C.  If you just look at the qualities of a language, you'll have a much harder time finding alternatives.",-0.1,Rust
128waxk,jels0fs,"As many of C's qualities are a product of its time, and not necessarily central to its idea/purpose, you're not going to find many new languages that are very similar to it (even though they might be made to solve the same problems).",0.18939393939393936,C
128waxk,jeu2c4w,Maybe you have never programmed in Pascal?,0.0,Pascal
128waxk,jeqgkew,Again no one does that with Forth.,0.0,Forth
128waxk,jeqgkew,Forth doesn't claim to allow you to write good 40k line programs.,0.7,Forth
128waxk,jeqgkew,"It wants to be your replacement for Assembly language, or possible C.   What you would likely do is create a DSL in Forth and write a short program in the customized DSL.",0.05,Assembly
128waxk,jeqgkew,"It wants to be your replacement for Assembly language, or possible C.   What you would likely do is create a DSL in Forth and write a short program in the customized DSL.",0.05,Forth
128waxk,jeqgkew,Functional language programs are a lot shorter than C programs.,0.0,C
128waxk,jeqgkew,Anyway you don't like the language then not your replacement for C.,0.0,C
128waxk,jfbicmx,Nobody else would want to learn Pascal.,0.0,Pascal
128waxk,jfbicmx,"I keep getting pinged about a remote opportunity where they're looking for Pascal + .NET + AWS and I have to say, I'm both horrified and intrigued by that combination.",-0.1,Pascal
128waxk,jen94l2,Except none of this points justify considering Rust a C alternative.,0.0,Rust
128waxk,jen94l2,Except none of this points justify considering Rust a C alternative.,0.0,C
128waxk,jen94l2,"As mentioned before, every turing complete language can do what C does, so the capabilities of a language are at most sufficient, but not necessary condition for a language to be called some other language's alternative.",0.11875,C
128waxk,jen94l2,"Instead, these points only somewhat acknowledge that:  - there is a mismatch in the puprose of C and Rust - there is a mismatch of supported platforms of C and Rust - there is a philosophical difference of C and Rust - there is a difference in how C and Rust are handled by programmers  The point that an alternative or replacement for a given workflow is distinct from an alternative for a language is completely missed.",0.1,C
128waxk,jen94l2,"Instead, these points only somewhat acknowledge that:  - there is a mismatch in the puprose of C and Rust - there is a mismatch of supported platforms of C and Rust - there is a philosophical difference of C and Rust - there is a difference in how C and Rust are handled by programmers  The point that an alternative or replacement for a given workflow is distinct from an alternative for a language is completely missed.",0.1,Rust
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,Java
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,Go
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,C
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,Rust
128waxk,jen94l2,- Why would we care if the compiler can run on machines that were around when C was first invented?,0.25,C
128waxk,jen94l2,"Finally, there are several strawmen that I will point out, but will not be addressing, the author should be ashamed of making:  - no that does not invalidate rust's advantages - you wouldn't be able to run modern C compilers like Clang (which uses the same backend as rust) on such limited systems anyway.",0.08979591836734693,C
128n19y,,"But for it to be truly effective, I'd have to have it interop with C++, so that users can define their own interfaces.",0.6,C++
128n19y,jejhwic,"Swift's property wrappers were a somewhat novel approach to solving the scoping problem, kinda, sorta.",0.0,Swift
128n19y,jekuf6q,"For C++, there is also [rxqt](https://github.com/tetsurom/rxqt) which ties into Qt's signal's and slots (analogue of C#'s events which were one of the motivations of the original Rx library), and Qt provides you with all of the UI components you need.",0.375,C++
128n19y,jekuf6q,"For C++, there is also [rxqt](https://github.com/tetsurom/rxqt) which ties into Qt's signal's and slots (analogue of C#'s events which were one of the motivations of the original Rx library), and Qt provides you with all of the UI components you need.",0.375,C
128n19y,jekuf6q,"He also developed a Haskell version related to the monad `do` notation, which became [`docase`](https://github.com/tpetricek/Haskell.Joinads) (implemplented as a pre-processor rather than a language extension).",0.05,Haskell
128b7pg,jeip0er,"Go do something else, like basketball, or rock climbing, or weightlifting, or competitive programming.",0.0,Go
128b7pg,jei4j7h,"Also, if you have a way for people to install and reuse code snippets, then it can grow like Julia or Elm.",0.0,Julia
128b7pg,jei4j7h,"Also, if you have a way for people to install and reuse code snippets, then it can grow like Julia or Elm.",0.0,Elm
128b7pg,jeia6ig,"Basically what various langusges do for JS, but for PHP, VBA etc.",0.0,PHP
128b7pg,jejt79k,"Programming in C and C++, the only assembly I even use is inlined so I'm stuck with the GNU syntax anyway.",0.0,C
128b7pg,jejt79k,"Programming in C and C++, the only assembly I even use is inlined so I'm stuck with the GNU syntax anyway.",0.0,C++
1284mk4,jeiuvot,"Another plan is to write a version of the interpreter directly in C (not transpiled from my language), so as to make this back-end available for others to use.",0.17500000000000002,C
1284mk4,jeiuvot,"This is a minimal Hello program, using C's `puts` as my `print` routines require lots of support:      proc main         loadimm  u64  ""Hello World""         callp         puts* 1 0     end  I believe this will work as it is.",0.033333333333333326,C
1284mk4,jeybmjv,I wrote my language in Go and also have it compiling to wasm so I could embed it in my personal website as a usable demo.,0.0,Go
1284mk4,jeybmjv,I have met my goal in making something usable and now I have a performance goal of making my language run as fast as Go's implementation of regex.,0.2,Go
1284mk4,jejiu11,Switching from Gradle Kotlin to Gradle Groovy.,0.0,Kotlin
1284mk4,jejiu11,Switching from Gradle Kotlin to Gradle Groovy.,0.0,Groovy
1284mk4,jei5zv4,"Random Q:  I’ve been programming exclusively in Python the last 8 or so years, but I studied C++ in college before.",-0.25,Python
1284mk4,jei5zv4,"Random Q:  I’ve been programming exclusively in Python the last 8 or so years, but I studied C++ in college before.",-0.25,C++
1284mk4,jei5zv4,How much of C++ do I need to pick up to be comfortable with LLVM code?,0.30000000000000004,C++
1284mk4,jei5zv4,"Also, what would be a good resource for learning modern C++?",0.44999999999999996,C++
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,C
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,Java
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,Lua
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,Python
1284mk4,jeqerqo,Linked byte code transpiles into C or run on a byte code interpreter,0.0,C
1284mk4,jh5cv0i,"I have altered perl.vim, the vim syntax highlighting file for Perl, to hide backslashes and escape characters, and use color to distinguish between escaped characters, strings literals, and code.",0.0,Perl
1284mk4,jh5cv0i,Here is the file:  [perl.vim](https://pastebin.com/yCZ1wkYY)     I picked Perl because most programmers find the regex syntax especially hard to read.,-0.2777777777777778,Perl
1284mk4,jfqtwz6,I couldn't finish it and in retrospective it was basically a reskin for Java (classes inheritance etc).,0.0,Java
1284mk4,jfqtwz6,"Now I'm trying again, dropped an 'R' so is now Yz :D, and is still very similar to mainstream, oop langs but **absurdly** simplified.",0.16666666666666666,R
1284mk4,jfqtwz6,"Now I'm trying again, dropped an 'R' so is now Yz :D, and is still very similar to mainstream, oop langs but **absurdly** simplified.",0.16666666666666666,D
1284mk4,jekipq5,"> Also, what would be a good resource for learning modern C++  When I don't know something, I like reading the C++ standard and C standard.",0.22499999999999998,C++
1284mk4,jekipq5,"> Also, what would be a good resource for learning modern C++  When I don't know something, I like reading the C++ standard and C standard.",0.22499999999999998,C
1284mk4,jekipq5,"Also, I like reading [cppreference](https://en.cppreference.com/w/cpp), it has the newest info on C++ drafts.",0.0,C++
1284mk4,jfsmpo9,"I wanted something with R since it's basis is Rebol, where also all the lack of reserved words and homoiconicity comes from and I thought about something ""organic"" ... if previous generation of languages were named more by minerals: perl, ruby, ...",0.16666666666666669,R
1284mk4,jfsmpo9,Current ones can be seen here:   [https://refaktor.github.io/rye/TOUR\_0.html](https://refaktor.github.io/rye/TOUR_0.html) \- tour   [https://refaktor.github.io/rye/INTRO\_1.html](https://refaktor.github.io/rye/INTRO_1.html) \- intro to Python programmers     I thought quite long about error handling and I think I have found interesting concept by taking a step back and maybe a step forward but in a different direction than try/catch which I don't like because it muddies the code and is sort of GOTO statement.,-0.05000000000000001,Python
1284mk4,jfsutsm,"For errors I'm thinking of being values (like in Go), and maybe generics would solve the checking (like `Result` in Rust), that's something I'm still not clear about.",-0.05000000000000001,Go
1284mk4,jfsutsm,"For errors I'm thinking of being values (like in Go), and maybe generics would solve the checking (like `Result` in Rust), that's something I'm still not clear about.",-0.05000000000000001,Rust
1284mk4,jft1bqi,"This was inspired by Go and I think this document: https://middlemost.com/failure-is-your-domain/  Since Failure is just a Rye value, there are also just Rye functions that help you handle them, only they have a flag set that they can handle errors.",-0.15833333333333335,Go
1284mk4,jfw858k,I tried your example using `Result` / `Option` like in Rust(tm).,0.0,Rust
1284mk4,jfxnxxb,"Hey, this is awesome example with Rust!",1.0,Rust
1284mk4,jfxnxxb,:)  I would say it makes sense that Rust returns result wrapped in Result/Option and a dynamic language can return the result or a failure directly.,0.07083333333333333,Rust
1284mk4,jfxnxxb,"In Go these are two return values, but in Rye it makes no sense that we would need two, since it can't fail and return correct result at the same time :)  Your Rust example is really nice ... can I use it in a blogpost when I try to explain how Failures in Rye work?",0.15,Go
1284mk4,jfxnxxb,"In Go these are two return values, but in Rye it makes no sense that we would need two, since it can't fail and return correct result at the same time :)  Your Rust example is really nice ... can I use it in a blogpost when I try to explain how Failures in Rye work?",0.15,Rust
1284mk4,jfxohlp,"Of course, except that that's not Rust, that my fictional language :( but rust has if naturally (even Java).",-0.21666666666666667,Rust
1284mk4,jfxohlp,"Of course, except that that's not Rust, that my fictional language :( but rust has if naturally (even Java).",-0.21666666666666667,Java
1284mk4,jfxt9o6,"haha :"")  I've updated the gist with actual Rust.. (going to try to paste it here)  ```rust fn main() {     let x = split_and_save(10.0, 0.0).unwrap_or_else(|_| -> f32 {1.0});     println!",0.1361111111111111,Rust
127h71c,jef36gw,The Indiana version of `concepts` in C++0x could be used to implement modules *properly* in C++.,0.0,C++
127h71c,jefnuc1,I am more familiar with Rust -- its trait is closed to Haskell's typeclass -- and reading the complaints I feel like I can define modular code using Rust trait.,0.25833333333333336,Rust
127h71c,jefnuc1,I am more familiar with Rust -- its trait is closed to Haskell's typeclass -- and reading the complaints I feel like I can define modular code using Rust trait.,0.25833333333333336,Haskell
127h71c,jefnuc1,"For example, with regard to the stack:      trait Stack<T> {         fn make_empty() -> Self;         fn is_empty(&self) -> bool;         fn pop(&self) -> Option<(Self, T)>;         fn push(&self, item: T) -> Self;     }  And using associated types, it generalizes to the filesystem example:      trait Filesystem {         type Handle: Handle;         type File: File;         type Directory: Directory;         type DirectoryIterator: Iterator<Item = Handle>;          //  some functions     }  There's no built-in theorem prover in Rust, so no compile-time guarantees can be made... for now.",0.0,Rust
127h71c,jegjnt2,Like Python and Java both have a concept of modules.,0.0,Python
127h71c,jegjnt2,Like Python and Java both have a concept of modules.,0.0,Java
127h71c,jegjnt2,"But in Python, apparently a module is essentially just a source file.",0.025,Python
127h71c,jegjnt2,"While in Java it's a special kind of way to group your code together (as an alternative to a jar file) using a special `module-info.java` file listing dependencies, exported packages, and other directives.",0.29732142857142857,Java
127h71c,jegjnt2,"Meanwhile, this article seems to assert a very specific definition for the concept of modules, which perhaps either does or does not intersect either Python or Java's usage of the term.",0.0,Python
127h71c,jegjnt2,"Meanwhile, this article seems to assert a very specific definition for the concept of modules, which perhaps either does or does not intersect either Python or Java's usage of the term.",0.0,Java
127h71c,jee9cob,"for 2 decades, yet it's wrongly considered ""obsolete"" due misinformation: Pascal.",-0.3125,Pascal
127h71c,jee9cob,"This was due to a, now obsolete magazine's article, that mentioned early version's of Pascal's pinfalls.",-0.012499999999999997,Pascal
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,Haskell
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,Ruby
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,Python
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,Rust
127h71c,jee9cob,"The same goes for any variant with a different name: Delphi, Ada, FreePascal, Oberon, and of course ""Modula"".",0.0,Delphi
127h71c,jee9cob,"The same goes for any variant with a different name: Delphi, Ada, FreePascal, Oberon, and of course ""Modula"".",0.0,Ada
127h71c,jee9cob,"And, also ""reinvented"", again and again, most of the times with ingenious, but unnecessary ""hacks"", instead of just learning from Pascal's Modula.",0.19999999999999998,Pascal
127h71c,jee9cob,"Another simple ""hack"" was to add the same prefix to all the global non O O. methods to each library file like early  (Plain) C, C++ or PHP files did.",-0.022857142857142854,C
127h71c,jee9cob,"Another simple ""hack"" was to add the same prefix to all the global non O O. methods to each library file like early  (Plain) C, C++ or PHP files did.",-0.022857142857142854,C++
127h71c,jee9cob,"Another simple ""hack"" was to add the same prefix to all the global non O O. methods to each library file like early  (Plain) C, C++ or PHP files did.",-0.022857142857142854,PHP
127h71c,jee9cob,"Then, C++ and Java ""namespaces"" arrived.",0.0,C++
127h71c,jee9cob,"Then, C++ and Java ""namespaces"" arrived.",0.0,Java
127h71c,jee9cob,**Java did add a more organized hierarchical way of namespaces instead of a single plain list like original Modula / Pascal did.,0.14732142857142858,Java
127h71c,jee9cob,**Java did add a more organized hierarchical way of namespaces instead of a single plain list like original Modula / Pascal did.,0.14732142857142858,Pascal
127h71c,jee9cob,"**  Then, 'static classes"" with ""static members"" arrived, again with Java.",0.5,Java
127h71c,jee9cob,"**  This was supported thru ""static class constructors"" and ""static class destructors"" which already existed in Modula / Pascal with a better syntax.",0.5,Pascal
127h71c,jee9cob,"C++ community quietly accepted this, and finally switched to ""full real modules"" with specific keywords, syntax or semantics, last year, even if it was proposed also 10 years ago.",0.09166666666666667,C++
127h71c,jee9cob,"But, again the ""we don't need anything from Modula / Pascal cause is obsolete and we don't want to be contaminated with obsolescence"" appeared, and their implementation seems ""clunky"".",0.0,Pascal
127h71c,jee9cob,from C# / VS to FreePascal / LazarusIDE.,0.0,C
127h71c,jeeccoo,I remember how refreshing it was learning about Haskell's [`containers`](https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map-Strict.html).,0.5,Haskell
127h71c,jef47mg,"Currently it's all ""hope your compiler can read C"".",0.0,C
127h71c,jegb7rn,"The brute force of industry, OTOH, doesn't have that luxury, and instead produces monstrosities like C++.",0.0,C++
127h71c,jei7mut,"The article addresses typeclasses in Haskell:   > The downside though is that, without doing some super-advanced stuff, there can be only one such read function for each type.",0.16666666666666666,Haskell
127h71c,jei7mut,Go back to having separate readEmployeeFormat1 and readEmployeeFormat2 functions like a pleb.,0.0,Go
127h71c,jegzhsd,> reading the complaints I feel like I can define modular code using Rust trait.,0.0,Rust
127h71c,jegzhsd,"The big thing ""modules"" in oCalm and others have that most do not is just like (again, as Rust):  ```rust mod stack<T> { //suspiciously look like struct as if a module is not an invisible construct but a first-class thing I can manipulate }  // then maybe you don't need ""hide by default"" because modules hide by default:  -- in file utils.rs mod util {   struct Stack<T> {} //is pub(crate) by default }  -- in file stack.rs mod stack<T> {   use util::Stack //is pub(crate) by default    fn make_empty() -> Stack {} }  // And because modules are first class like structs: fn print_mod(of:&stack<i32>) {}  fn main {   let s = stack<i32>;   print_mod(&s);   let my_stack = s.make_empty() } ```",0.21666666666666665,Rust
127h71c,jehs26k,"Oh sure you can, if you want run-time reflection with full generic support such as Java does *not* provide but IIRC .net does.",0.2125,Java
127h71c,jeftbj1,"in Java prior to the explicit module system, classes were the smallest unit of modularity.",0.0,Java
127h71c,jeftbj1,You can view both Java packages and classes as modules with interfaces.,0.0,Java
127h71c,jefq6pd,Yeah I just checked Pascal out of curiosity and honestly it seemed much better than OO mainstream languages for code organization.,0.55,Pascal
127h71c,jesqye7,"Doug G wrote the C++ front-end for LLVM, then joined the Swift team; 3.",0.0,C++
127h71c,jesqye7,"Doug G wrote the C++ front-end for LLVM, then joined the Swift team; 3.",0.0,Swift
127h71c,jeicd2m,I worked with modules in SML and OCaml before I ever used Haskell seriously.,-0.3333333333333333,Haskell
127h71c,jeicd2m,"In fact, this issue is pretty much what led me to switch from ML to Haskell.",0.225,Haskell
127h71c,jeicd2m,"Here's a challenge for someone who wants to defend these sort of modules: can you implement something like the Haskell monad transformer stack, using modules instead of type classes?",0.2,Haskell
127h71c,jeitsig,"My point was more that, as far as I am concerned, _traits are the modules the author is looking for_ in Rust.",0.3,Rust
127h71c,jej4b8c,"For example, the module      module type FileSystem = sig         type filehandle         type dir         type fs_watcher        ...     end  can be written in Java like so       public class FileSystem {         public static class FileHandle {             private int privateField;         }         public static class Dir {}         public static class FsWatcher {}     }",0.1875,Java
127h71c,jehrhzb,"To be fair, I studied Pascal in college.",0.7,Pascal
127h71c,jeht8q8,"Java was famous at one point for getting people to always write an interface first, then the class, whether or not there would ever be more than one class for that interface.",0.4166666666666667,Java
127h71c,jeii5p7,"Just because Haskell's type system lets you do that doesn't mean you have to, nor that it's a good engineering approach.",0.19374999999999998,Haskell
127h71c,jeii5p7,OCaml's modules have different tradeoffs than Haskell's type classes and have different strengths.,0.0,Haskell
127h71c,jeii5p7,"OCaml's type system is certainly not as powerful as Haskell's, but I consider that a feature.",-0.15,Haskell
127h71c,jep8s9w,"Newtyping may work, but specifically for low-level Rust mixed with generics, it will get messy.",-0.1,Rust
127h71c,jep8s9w,"In Rust, I'd have to either:   * Change the inner type to `StackListAlt<i32>`, potentially infecting other non-serialization code with this implementation detail (because I'd either need to change signatures or add `as_ref`, `as_mut`, and `into_inner` calls).",-0.041666666666666664,Rust
127h71c,jep8s9w,"Personally, I think Rust would have benefitted with OCaml-style modules (although I don't know consequences that entails).",0.0,Rust
127h71c,jekgkou,"So I think that no, Rust's Traits do not fulfill the Module requirements the blog post is alluding to.",0.0,Rust
127h71c,jeln56d,Nothing stops you from solving your actual problems in Haskell.,0.0,Haskell
127h71c,jeln56d,"In fact, what I was saying is that I ended up preferring using Haskell over the ML family precisely because it was easier to solve actual problems with typeclasses than with parameterized modules.",0.2,Haskell
127h71c,jeln56d,Rust is a recent example of this.,0.0,Rust
127h71c,jen34l6,"Seems to fit the bill, though I'm far from a Java IDE right now, can't check.",0.2619047619047619,Java
127h71c,jep61pt,"Go all the way back to 1971 and David Parnas's paper ""[On the criteria to be used in decomposing systems into modules](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf)"".",0.0,Go
127h71c,jep61pt,Ruby traits are mix-ins.,0.0,Ruby
127h71c,jep61pt,"Haskell type-classes are contract specifications, but they only focus on one type at a time.",0.0,Haskell
1279h73,,"Sophie is pure and lazy, similar to Haskell, but has an algebraic syntax reminiscent of Pascal.",-0.008928571428571432,Haskell
1279h73,,"Sophie is pure and lazy, similar to Haskell, but has an algebraic syntax reminiscent of Pascal.",-0.008928571428571432,Pascal
1279h73,,"* [Documentation, including tutorial and various technical notes](https://sophie.readthedocs.io) * [Literate Formal Grammar](https://github.com/kjosib/sophie/blob/main/sophie/Sophie.md) * [Main GitHub page](https://github.com/kjosib/sophie) * [Examples](https://github.com/kjosib/sophie/tree/main/examples)  # The Current State of Affairs:  Initial implementation is in Python, but the semantics are as unlike Python as I can manage.",0.03333333333333333,Python
1279h73,jedokct,It's still Python and has been used for a number of language projects.,0.0,Python
1279h73,jege24b,The `end.` (with a period) at the end of a file is actually a nod to Pascal.,0.0,Pascal
1279h73,jedjtlc,I had a Haskell setup at first but then I leave it without touch for two months and when I wanted to use it again... too much wait.,0.225,Haskell
1279h73,jehi4jw,I at once recognized `end.` with a period as a borrowing from Pascal.,0.0,Pascal
1279h73,jehi4jw,"In the late 1980s, Pascal was big.",-0.15,Pascal
1279h73,jehi4jw,Why did C win out over Pascal?,0.8,C
1279h73,jehi4jw,Why did C win out over Pascal?,0.8,Pascal
1279h73,jehi4jw,"(Python is even shorter, and therefore perhaps even better than curly brace languages.)",0.5,Python
1279h73,jehi4jw,"I've written a fair amount of Pascal, and I can tell you it really is tedious to have to type ""begin"" and ""end"" over and over.",0.09999999999999998,Pascal
1279h73,jehi4jw,Pascal code is littered with `THEN BEGIN` and `END ELSE BEGIN` verbiage.,0.0,Pascal
1274jaw,jedsbp1,Also ur using C in which i'm in love.,0.5,C
1274jaw,jedk6fa,Rust's match keyword,0.0,Rust
1274jaw,jeflk6j,"some people are too serious, but i don't care about downvotes :D",0.33333333333333337,D
1274jaw,jecsmoq,"Tbh, I only went the C style switch route cause it was pretty challenging to get them to work.",0.25,C
1274jaw,jee9t1g,See Python for an example of how it can look in dynamically typed languages.,0.0,Python
1274jaw,jedpt19,"I believe that C is like that because of C being ""portable assembly"" --- `break` corresponds to a jump instruction, whereas falling through corresponds to no instruction and so is the default.",0.0,C
1274jaw,jedpt19,"But although that's a reason why C was like that, it's not a reason why we should copy it, we can spare a few more clock cycles on compilation nowadays.",0.15,C
1274jaw,jee3pdo,The crude way that C's `switch` works means that fallthrough is essential.,-0.35,C
1274jaw,jee3pdo,"Although you'd lose the other weird behaviours of C's completely unstructured switch, where `case` and `default` labels can appear literally anywhere, and at any nested level, within the statement that follows `switch (x)`.",-0.17500000000000002,C
1274jaw,jee3pdo,"I noticed also that the OP is keeping C's `for` loop syntax alive, although TBF that was in Lox too.",0.1,C
1274jaw,jekl19k,"Just like in Java, or any other language that supports these keywords.",-0.125,Java
126jwi7,jed8xmh,"Yes, Lisp style, thank you for the remark.",0.0,Lisp
126d6cl,,I'm building a small interpreted language in Rust.,-0.25,Rust
126bz6c,je8zlk8,This would include Turing-complete PLs --- though IIRC I was leaning on the idea that every culture no matter how alien must basically invent Lisp and Forth or something very like them.,-0.024999999999999994,Lisp
126bz6c,je8zlk8,This would include Turing-complete PLs --- though IIRC I was leaning on the idea that every culture no matter how alien must basically invent Lisp and Forth or something very like them.,-0.024999999999999994,Forth
126bz6c,je95kwo,"https://github.com/kesh-lang/kesh  I already had some ideas for what JavaScript could have become had it not taken a wrong turn in its early days, when it was called Mocha.",-0.2,JavaScript
126bz6c,jnxcpnf,"--- because code in JVM bytecode is written by computers, and designed to be written by computers, whereas humans use Java, designed for humans, to keep them from having to touch or know about the bytecode.",0.0,Java
126bz6c,jnyyzr8,"So I'm supposing an alien race for whom something like Forth would genuinely be more ergonomic than OOP, so they'd overwhelmingly use that.",0.25,Forth
1268gl2,jec612f,This is just a wrapper for Python - it is literally just Python with a different syntax.,0.0,Python
1268gl2,jec612f,"You wouldn't say that C and Python are isomorphic because even though you can do the same things, some things in Python take a lot more work in C, and vice versa.",0.25,C
1268gl2,jec612f,"You wouldn't say that C and Python are isomorphic because even though you can do the same things, some things in Python take a lot more work in C, and vice versa.",0.25,Python
1268gl2,jec612f,Saying this is isomorphic to Python is an important point because it does the exact same things Python does.,0.21666666666666667,Python
1264f31,je91k0l,I'm just glad the Haskell gang are finally gettin paid real money and are getting rockstar popularity.,0.2333333333333333,Haskell
12649s2,,(Does that mean I can write C in Swahili?),-0.3125,C
12649s2,je7pb9l,"But usually they don't exist in isolation:  * APIs for the OS will likely use English-based names for functions, macros, variables, types, enums * APIs for 1000s of external libraries will do the same * Other associated languages like make files or scripts will likely still have keywords in English * External tools like linkers will still have their original names, will use the original English-based command-line options, and messages are likely to be in English unless they adapt to locale * File formats like HTML will use English-based tags etc  I suspect most languages limit internationalisation to Unicode identifiers, string literal data and comments.",0.0673076923076923,HTML
12649s2,je7pb9l,"Even if there was a Swahili C version, you might have trouble sharing your code with someone using C customised to another language.",-0.2,C
12649s2,je8dc5o,"Java, and by extension JRE languages, support unicode in identifiers.",0.0,Java
12649s2,je8dc5o,"If you want to make a language-agnostic language, APL gets mentioned because it has only symbols.",0.0,APL
12649s2,je8dc5o,So for example Python's `getattr(...)` function is toast.,0.0,Python
12649s2,je81dej,"Not exactly more than one human language, but APL might interests you.",-0.125,APL
12649s2,je918av,"In Japan, it’s even more so, because, if you look at the Japanese     COBOL text, you find verbs and connecting words and Roman characters in English and the     nouns in Japanese and Japanese characters.",0.1,COBOL
12649s2,je918av,"Actually, COBOL has become a language you can talk to programmers around the world.",0.0,COBOL
12649s2,je92kvi,"Not exactly what you asked for, but there are programming languages that do not have keywords and therefore make sense in almost all human languages  Off the top of my head, I can think of APL, BQN, and brainfuck, but I'm sure there are more",0.275,APL
12649s2,je7kni0,Swift comes to mind.,0.0,Swift
12649s2,je7kni0,I would need to double check Rust and I am not sure about kotlin/java or javascript.,-0.125,Rust
12649s2,jehvdpt,"> If you want to make a language-agnostic language, APL gets mentioned because it has only symbols.",0.0,APL
12649s2,jehvdpt,APL truly is the most egalitarian language - all humans don't understand it equally.,0.25,APL
12649s2,jec6nju,> So for example Python's  `getattr(...)`   function is toast.,0.0,Python
12649s2,jec6nju,That's all a very tall order for Python but I suspect it's doable using a variation of the symbol-related functions used to write `syntax-case` macros in R6RS Scheme.,0.2,Python
12649s2,jec6nju,That's all a very tall order for Python but I suspect it's doable using a variation of the symbol-related functions used to write `syntax-case` macros in R6RS Scheme.,0.2,Scheme
12649s2,je8y5z0,"I learned to program using Basic (and then Comal, Pascal, C, ...) without understanding that GOSUB referred to ""go run sub-routine"".",0.0,Pascal
12649s2,je8y5z0,"I learned to program using Basic (and then Comal, Pascal, C, ...) without understanding that GOSUB referred to ""go run sub-routine"".",0.0,C
12649s2,jeaqex2,"Early Ruby libraries were often written in Japanese if I recall, which shows a preference for unicode everything where possible.",0.03333333333333333,Ruby
12649s2,jeaw7l7,"In his 1995 book Komputika Leksikono, Sergio Pokrovskij gives code samples in a version of Pascal with Esperanto keywords.",0.0,Pascal
12649s2,je9ogt3,Lisp Factor Smalltalk are all good exames,0.7,Lisp
125qpy1,,"Spinnaker is my attempt to address the pet peeves I have in regards to the functional programming languages I've tried (mainly Haskell, Elm, OCaml, Roc...) and a way to create something fun and instructive.",0.23333333333333334,Haskell
125qpy1,,"Spinnaker is my attempt to address the pet peeves I have in regards to the functional programming languages I've tried (mainly Haskell, Elm, OCaml, Roc...) and a way to create something fun and instructive.",0.23333333333333334,Elm
125qpy1,,"My ultimate aim is to compile to C. Right now the available targets are JS, Scheme and an interpreter.",0.22857142857142856,Scheme
125qpy1,,I also didn't know Haskell very well before starting this project.,0.1,Haskell
125qpy1,je60jqf,Haskell programmers usually use `Text` from the [text](https://hackage.haskell.org/package/text) package instead.,-0.25,Haskell
125qpy1,je60jqf,"I know Haskell programmers are pretty bad at using good names, but please try to come up with something more useful than that.",0.21000000000000002,Haskell
125qpy1,jeb7l5y,"SML, OCaml and Haskell have demonstrated that a good choice of data representation can give extremely solid performance with a simple compilation scheme that supports polymorphism.",0.2333333333333333,Haskell
125qpy1,je8q9bg,Waiting for C backend so Spinnaker can be more low level.,0.25,C
125qpy1,jedscko,"Cool project, I would dive into the code, but I don't know Haskell, so out of curiosity, what is the compilation model?",0.35,Haskell
125qpy1,jedscko,What is the Scheme implementation currently targeted?,0.0,Scheme
125qpy1,je6unmo,"I would like to self host some day, so whatever feature I use in Haskell, I'd have to implement in Spinnaker (this is why I don't use records).",0.0,Haskell
125qpy1,jebwlge,"Monomorphization was one of the easiest parts to implement, and it makes it dead-simple to compile down to C.  While Haskell does have solid performance, it achieves it through a great deal of research on optimization, special-casing and runtime trickery.",0.21481481481481482,Haskell
125qpy1,jeeb12l,"Gambit is cool because it compiles to quite fast C, but god is it slow at compiling medium-sized code.",0.08333333333333333,C
125qpy1,je9eoqd,"GHC uses these to maintain data dependencies between `IO` statements since Haskell is lazy, but if your language is strict, you already have control flow dependencies.",-0.25,Haskell
125qpy1,je9eoqd,"Well, I hope you don't represent strings as linked lists of UTF-32 codepoints, so it's not like Spinnaker has an equivalent to Haskell `String`s :)  You only need to implement a string type that mimics the subset of the `Text` interface that you use in the compiler, but you would probably want to do that anyway, right?",0.2619047619047619,Haskell
125qpy1,je7xp66,:D  https://www.northsails.com/sailing/en/2021/01/difference-between-gennaker-and-spinnaker,1.0,D
125qpy1,jedrhij,"> While Haskell does have solid performance, it achieves it through a great deal of research on optimization, special-casing and runtime trickery.",0.4,Haskell
125qpy1,jedrhij,Haskell is hampered by being a lazy-by-default language.,0.0,Haskell
125qpy1,jedrhij,"On the other hand, OCaml (or, for example, Chez Scheme) get good performance by implementing simpler optimization and judicious runtime-representation choices.",0.2875,Scheme
125qpy1,jedrhij,"I don't think you would need monomorphization to compile down to C. Functional languages that don't do monomorphization typically pick a uniform/untyped representation of values, and you can compile down to C by using this uniform representation in the C code.",-0.1592592592592593,C
125qpy1,jedrhij,"Currently your backends can rely on a garbage collector in their implementation language (Scheme, Haskell), so you don't have to worry about garbage collection.",0.0,Scheme
125qpy1,jedrhij,"Currently your backends can rely on a garbage collector in their implementation language (Scheme, Haskell), so you don't have to worry about garbage collection.",0.0,Haskell
125qpy1,jedrhij,For a C backend you would have to implement your own garbage collector.,0.6,C
125qpy1,je9odxs,"Of course the `js` and `scm` backends don't care, but with C it would need some work.",0.0,C
125qpy1,je9odxs,"> Well, I hope you don't represent strings as linked lists of UTF-32 codepoints, so it's not like Spinnaker has an equivalent to Haskell Strings :)  Guess what, that's exactly what I'm doing :).",0.4166666666666667,Haskell
125qpy1,jeit5nf,"I think the ""platform"" idea makes more sense if you come from Elm, which gives you a set way to interact with the browser and then leaves the rest to port and custom html components.",0.5,Elm
125qpy1,jedvyu7,"There is similar doc in the GHC commentary, but it is more complex / harder to read in my experience : https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects  I haven't been able to find again a pointer to similar information for Chez Scheme.",0.09999999999999999,Scheme
125qpy1,jej57nr,"I would really like to know how Chez works as it is said to be the most performant Scheme implementation, beating event the compiled ones, but the code base feel quite overwhelming.",0.09999999999999998,Scheme
125nu69,je565tl,"But, if you want to add either C alike unions or enumerated values, you could use the pipe:      ( gameobjectenum = ( enemyID | playerID | obstacleID | weaponID )  And:    ( player = (       (ID: gameobjectenum),       (Health: Word ),       (Armor: Word ),       (Weapon: Word ),       (Damage: Word),     )  Since the previous was a type declaration, how do your make a variable of that type ?",-0.6333333333333333,C
1258dwg,,[Rust is a Scalable Language](https://matklad.github.io/2023/03/28/rust-is-a-scalable-language.html)   [Everything's an API](https://buttondown.email/hillelwayne/archive/everythings-an-api/),0.0,Rust
1258dwg,je3yhsa,"Rust in particular thrives despite Cargo, not because of it.",0.16666666666666666,Rust
1258dwg,je3xeaa,**Rust's Module System promotes API stability.,0.0,Rust
1258dwg,je4qeaz,"The problem with an universal tool is that all those libraries would still have no interop, because some people decided that all we need is pretending everything is C.",0.0,C
1258dwg,je8w4o2,"But you can look at the Java world (yes, really) as a decent example to follow: Gradle supports bidirectional interop with both Maven and Ant builds, and both Maven and Ivy packages, and all three build systems are extensible to other languages like Kotlin.",0.02083333333333333,Java
1258dwg,je8w4o2,"But you can look at the Java world (yes, really) as a decent example to follow: Gradle supports bidirectional interop with both Maven and Ant builds, and both Maven and Ivy packages, and all three build systems are extensible to other languages like Kotlin.",0.02083333333333333,Kotlin
1252ekz,je2cg1p,"It's probably the most explicit language with a large amount of available samples, like Java 8 or something.",0.37142857142857144,Java
124yk3s,je1pj1l,That's the big difference between the traditional JS and Rust here.,0.0,Rust
124yk3s,je1pj1l,"> I personally like having a method ""namespaced"" to a class/struct, since it provides a kind of organization that I personally like (indented), but I also quite enjoy Rust/Go struct style  Is the Rust syntax not already indented?",0.25,Rust
124yk3s,je1pj1l,"The use of the word ""but"" implying not, however I think you have both of what you want in the Rust syntax.",0.0,Rust
124yk3s,je1v9p1,A counterargument (inspired by Go's comment style) would be that it makes grepping for a class's methods within a directory easier.,0.0,Go
124yk3s,je4yhvo,"That is why in C++ we more commonly use friend functions that have access to the arguments' private members, but are otherwise free functions with two arguments.",0.15000000000000002,C++
124yk3s,je4yhvo,"Even in languages like D, operator overloading requires both `opBinary`, `opBinaryRight` and their friends, and `==` is rewritten into a call to static `Object.opEquals` which does (among other things) `lhs.opEquals(rhs) && rhs.opEquals(lhs)`.",0.1875,D
124yk3s,je4yhvo,"(f: a -> b): b = f x          test ""dot operator"" with         let f = (+) in         assert (40 .f 2 == 42)  In fact languages such as Haskell and L.B.",0.0,Haskell
124yk3s,je4yhvo,"foo (x: Int) (y: Int) = x + y     foo (x: Int) (y: Float) = x + floor y          test ""foo"" with         assert (foo 40 2 == 42);         assert (foo 40 2.5 == 42);         assert (40 .foo 2 == 42);         assert (40 .foo 2.5 == 42)  Doing the same with ""methods"" as are in Java, Rust or PHP, is simply impossible.",-0.3333333333333333,Java
124yk3s,je4yhvo,"foo (x: Int) (y: Int) = x + y     foo (x: Int) (y: Float) = x + floor y          test ""foo"" with         assert (foo 40 2 == 42);         assert (foo 40 2.5 == 42);         assert (40 .foo 2 == 42);         assert (40 .foo 2.5 == 42)  Doing the same with ""methods"" as are in Java, Rust or PHP, is simply impossible.",-0.3333333333333333,Rust
124yk3s,je4yhvo,"foo (x: Int) (y: Int) = x + y     foo (x: Int) (y: Float) = x + floor y          test ""foo"" with         assert (foo 40 2 == 42);         assert (foo 40 2.5 == 42);         assert (40 .foo 2 == 42);         assert (40 .foo 2.5 == 42)  Doing the same with ""methods"" as are in Java, Rust or PHP, is simply impossible.",-0.3333333333333333,PHP
124yk3s,je4yhvo,"C# surprisingly, can do it with static methods and `dynamic` objects using the DLR, where everything is determined at runtime.",0.39999999999999997,C
124yk3s,je7a8ry,"> foo = Foo(2, 'goodnight');     > foo     { bar = 2, baz = 'goodnight' }     > foo.addToBar(1)     { bar = 3, baz = 'goodnight' }     > foo.appendToBaz(', moon')     { bar = 2, baz = 'goodnight, moon' }  Where this gets powerful is that you can define something similar to extension methods in C# fairly easily, simply by placing the method definition outside the function:      > def appendToBaz(thingWithBaz, toAppend) =>     .",0.16,C
124yk3s,je6xuse,One note is the TypeScript way conflicts with some uses of generics.,0.0,TypeScript
124yk3s,je6xuse,"Example:      struct Identity<T> {       inner: T     }      impl I<i32> {       // I can call foo.add(10),       // but only if foo : Identity<i32>       fn add(self, x: i32) -> Identity<i32> {         Identity { inner: self.inner + x }       }     }  As far as I know there isn’t a good way of doing this in TypeScript.",0.15999999999999998,TypeScript
124yk3s,je6xuse,"Scala had the same issue, and there you often workaround this by asking for an implicit equality witness.",0.0,Scala
124yk3s,je1qhv6,"Yes definitely, you're right, I actually had Go in mind writing that (where functions/methods are in the same level as the struct), I like Rust's approach, the only difference in syntax being the declarations in a different place (within the \`impl\`).",0.047619047619047616,Go
124yk3s,je1qhv6,"Yes definitely, you're right, I actually had Go in mind writing that (where functions/methods are in the same level as the struct), I like Rust's approach, the only difference in syntax being the declarations in a different place (within the \`impl\`).",0.047619047619047616,Rust
124yk3s,je1qhv6,"Really good point about the inheritance, tbh inheritance is so natural to me when programming Python that I never though about it that much, with Go composition normally is good enough, and Rust it seems the mindset is so different, traits tend to solve that most of the times, I'm not a big fan of the composition via Enum thing though.",0.275,Python
124yk3s,je1qhv6,"Really good point about the inheritance, tbh inheritance is so natural to me when programming Python that I never though about it that much, with Go composition normally is good enough, and Rust it seems the mindset is so different, traits tend to solve that most of the times, I'm not a big fan of the composition via Enum thing though.",0.275,Go
124yk3s,je1qhv6,"Really good point about the inheritance, tbh inheritance is so natural to me when programming Python that I never though about it that much, with Go composition normally is good enough, and Rust it seems the mindset is so different, traits tend to solve that most of the times, I'm not a big fan of the composition via Enum thing though.",0.275,Rust
124yk3s,je2grll,"Swift and kotlin allow you to have class/struct/enum ""extensions"", which can add new methods onto existing classes, and of course more dynamic languages like smalltalk, ruby etc.",0.21212121212121213,Swift
124yk3s,je787pv,"EDIT: Also, [TypeScript's intersection types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types) (and [Ceylon's](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types)) and how they allow to represent a multimethod's type as `(a -> b) & (c -> d)` (I know TypeScript doesn't document it for whatever reasons, but `((x: T) => U) & ((y: V) => W)` is valid code).",0.0,TypeScript
124h3n7,,From my Prolog days I recall that the compiler would warn if a predicate could be satisfied in more than one way.,0.5,Prolog
124h3n7,jee3h9e,"Actually, it will be up to libraries as I try to avoid the Prolog default depth-first search strategy when faced with choices (*non-determinism* in Prolog).",0.0,Prolog
123sn1i,jdxnb64,"//implicit Haskell style:     add x y = x + y     //etc...     applyTo x f = f x          fs = [add 2, mul 2, flip div 2] //note the need of flip     main = putStrLn (map (applyTo 5) fs) //[7, 10, 2.5]  --      //explicit Scala style:     ...          def fs = [(add 2 _), (mul 2 _), (div _ 2)] //note the underscore's placement     def main = putStrLn(map(_(5), fs)) //[7, 10, 2.5]  I'll let you imagine how many different routines I'd have to manually write to get the same effect in C, at which point I'd just manually roll my own loops rather than reuse library functions.",0.23888888888888885,Haskell
123sn1i,jdxnb64,"//implicit Haskell style:     add x y = x + y     //etc...     applyTo x f = f x          fs = [add 2, mul 2, flip div 2] //note the need of flip     main = putStrLn (map (applyTo 5) fs) //[7, 10, 2.5]  --      //explicit Scala style:     ...          def fs = [(add 2 _), (mul 2 _), (div _ 2)] //note the underscore's placement     def main = putStrLn(map(_(5), fs)) //[7, 10, 2.5]  I'll let you imagine how many different routines I'd have to manually write to get the same effect in C, at which point I'd just manually roll my own loops rather than reuse library functions.",0.23888888888888885,Scala
123sn1i,jdxnb64,"//implicit Haskell style:     add x y = x + y     //etc...     applyTo x f = f x          fs = [add 2, mul 2, flip div 2] //note the need of flip     main = putStrLn (map (applyTo 5) fs) //[7, 10, 2.5]  --      //explicit Scala style:     ...          def fs = [(add 2 _), (mul 2 _), (div _ 2)] //note the underscore's placement     def main = putStrLn(map(_(5), fs)) //[7, 10, 2.5]  I'll let you imagine how many different routines I'd have to manually write to get the same effect in C, at which point I'd just manually roll my own loops rather than reuse library functions.",0.23888888888888885,C
123sn1i,jdwrzyt,To me Ruby is the best for things like this.,1.0,Ruby
123sn1i,je1g4kd,Rust does that very well.,0.2,Rust
123sn1i,je1g4kd,"I love Lisp macro systems, especially the one of Common Lisp.",0.06666666666666667,Lisp
123sn1i,je1g4kd,Especially the macros in Rust.,0.0,Rust
123sn1i,je1g4kd,"In some cases, they are useful to create default implementations, like derive-macros in Rust.",0.3,Rust
123sn1i,jdw85bn,Using macros in C do allow for a lot less code duplication but they are not typed and checked like in rust.,-0.16666666666666666,C
123sn1i,je0jrkn,C++ concepts are amazing except for template syntax.,0.6000000000000001,C++
123sn1i,je0jrkn,"Meta Assembly Language (MASS, on Handmade Network) does concepts with full meta evaluation of functions would would be amazing for fully programmable generics.",0.47500000000000003,Assembly
123sn1i,jdy3746,I would also love to see what it would look like in C (if you have the time of day),0.5,C
123sn1i,jdx178p,"True with C, not true with Rust (macros are perfectly integrated in CLion and VSCode).",0.39166666666666666,C
123sn1i,jdx178p,"True with C, not true with Rust (macros are perfectly integrated in CLion and VSCode).",0.39166666666666666,Rust
123sn1i,jdwi2p5,(Or being necessary to implement half of C++.),-0.08333333333333333,C++
123sn1i,jdwi2p5,Surely implementing half of C++ is a valid use of generics?,0.16666666666666669,C++
123sn1i,jdy3n2m,"C tries to do this, and what does it end up with?",-0.1,C
123sn1i,je0lt6m,"The same Scala code is like this C++:      int add(int x, int y) { return x + y; }     //etc...          const auto fs[] = {         [](int x) { return add(2, x); },         [](int x) { return mul(2, x); },         [](int x) { return div(x, 2); }     };     int main()     {         std::cout << map([](int(*f)(int)) { return f(5); }, fs) << std::endl;     }  Not too bad.",-0.17777777777777773,Scala
123sn1i,je0lt6m,"The same Scala code is like this C++:      int add(int x, int y) { return x + y; }     //etc...          const auto fs[] = {         [](int x) { return add(2, x); },         [](int x) { return mul(2, x); },         [](int x) { return div(x, 2); }     };     int main()     {         std::cout << map([](int(*f)(int)) { return f(5); }, fs) << std::endl;     }  Not too bad.",-0.17777777777777773,C++
123sn1i,je0lt6m,"The Haskell one is trickier because in Haskell the `->` type operator is just a binary right-associative operator, meaning a function `a -> b -> c` is a recursive function `a -> (b -> c)`.",0.0,Haskell
123sn1i,je0lt6m,"int(*)(int) add(int x)     {         return [x](int y) {             return x + y;         };     }     //etc...     (int(*)(int(*)(int))) applyTo(int x)     {         return [x](int(*f)(int)) {             return f(x);         };     }     (int(*)(int))(*)(int) flip((int(*)(int))(*f)(int))     {         return [f](int x) {             return [f, x](int y) {                 return f(y)(x);             };         };     }          const auto fs[] = {         add(2),         mul(2),         flip(div)(2)     };     int main()     {         std::cout << map(applyTo(5))(fs) << std::endl;     }  Now I'm using anonymous function literals and closures, which C _does not have_.",0.16666666666666666,C
123sn1i,je0lt6m,"So all this in C would require each function to have its own separate definition, with explicit stack allocations.",0.6,C
123sn1i,je0lt6m,"Though [GNU C's nested functions](https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html) can do that, but are still verbose.",0.0,C
123sn1i,je0x4fr,I was thinking of Lisp-style macros and not C. I'm not familiar with Rust's macros so I need to check them out but how does the IDE cope when you completely change the language's syntax?,-0.04375,Rust
123sn1i,jdwmfmx,>Surely implementing half of C++ is a valid use of generics?,-0.16666666666666666,C++
123sn1i,je0znpu,"It's very simple actually: CLion (and VSCode as well I suppose) expand the macro in the background by compiling it, and if the compilation succeeds, the editor shows no error, even when the macro contains completely arbitrary, non Rust, code.",0.15,Rust
1238nxa,,"I've been looking at actor systems like Erlang and Akka because I (think I) want to make actors central to Sophie's way of interacting with the world, which opens an industrial-sized can of design-decision worms.",0.0,Erlang
1238nxa,,"Now, suppose actor Alice wishes to interact with Bob and Carol.",0.0,Alice
1238nxa,,"Suppose further that Bob and Carol both might send Alice a message called ""Right"".",0.14285714285714285,Alice
1238nxa,,Alice cannot easily receive messages from both Bob and Carol unless she can distinguish the semantics.,0.43333333333333335,Alice
1238nxa,,Akka documentation suggests not to let Bob or Carol address Alice directly.,0.1,Alice
1238nxa,,*  The Lisp crowd tells us that *design patterns* reflect deficient syntax.,-0.4,Lisp
1238nxa,,"Here's a vague proposal to maybe solve both:  Going back to the initial Alice/Bob/Carol problem, let Alice define two separate *receptors*.",-0.16666666666666666,Alice
1238nxa,,In some imagined syntax:      behavior Alice:         for BobProtocol:             on message Right:                 ... turn Alice's steering wheel ...             ... etc ...         for CarolProtocol(session_id):             on message Right:                 ... Alice feels validated ...             ... etc ...         ... etc ...                  on init:             $bob := create Bob reply_to: @here.BobProtocol;             $carol := create Carol reply_to: @here.CarolProtocol(42);  SO: What could *possibly* go wrong?,0.023809523809523798,Alice
1238nxa,jdvgkdr,"The correct thing to do is have proper types rather than just symbols (atoms), as used by Erlang et al.",0.0,Erlang
1238nxa,jdvgkdr,"enum Direction { Left, Right }     channel BobChannel     {         ...         output Direction Request;     }     agent Bob : channel BobChannel     {         Bob ()         {             ...             primary::Request <-- Direction.Right;             ...         }     }      enum Correctness { Right, Wrong }     channel CarolChannel     {         ...         output Correctness Request;     }     agent Carol : channel CarolChannel     {         Carol ()         {             ...             primary::Request <-- Correctness.Right;             ...         }     }  Axum was similar to C# and interoperable with a slightly modified subset of C# which removed `static` and replaced it with an `isolated` keyword, which ensured that multiple threads could not access some shared global state.",0.04497354497354497,C
1238nxa,jdvgkdr,> Akka documentation suggests not to let Bob or Carol address Alice directly.,0.1,Alice
1238nxa,jdvgkdr,"It is not necessary, and it is very common in Erlang to pass the Pid of the sender to the recpient of any message, but there can be consequences to doing so which might not be obvious.",-0.13,Erlang
1238nxa,jdvgkdr,"Suppose Alice creates actors Bob and Carol, and sends them her own Pid.",0.6,Alice
1238nxa,jdvgkdr,"Now if Alice ever wishes to revoke the ability of Bob or Carol to send her messages, she must somehow revoke her own Pid (ie, destroy herself).",0.19999999999999998,Alice
1238nxa,jdvil9l,"From what I understand, it sounds like you are proposing that one interface (Alice's interface) should be decomposable into constituent interfaces (the part of the interface that gets exposed to Bob, and the part of the interface that gets exposed to Carol)—is this correct?",0.0,Alice
1238nxa,jdvil9l,"For instance, if you have an interface with methods `foo`, `bar`, and `baz`, you may want Alice to have access to `foo` and `bar` while Bob has access to `bar` and `baz`.",0.0,Alice
1238nxa,jdvil9l,"In this case, it's trivial to just define `bar` twice, once for Alice and once for Bob, but it gets messy with more methods and more receptors—if you have n methods and m receptors, you may need to respecify O(n) methods for all m versions of the interface.",0.26666666666666666,Alice
1238nxa,jdu23ax,"On the other hand, Erlang messages are basically just string-ly typed tuples with zero ceremony.",-0.125,Erlang
1238nxa,jdw2i7i,"Proxy-actors allow to expose specialized/parameterized interfaces to Bob and Carol, but then a proxy cannot directly update Alice: it must send another message to Alice, which means inventing (or adopting) yet another protocol and bouncing more messages around the system.",0.3,Alice
1238nxa,jdweiyg,"> Proxy-actors allow to expose specialized/parameterized interfaces to Bob and Carol, but then a proxy cannot directly update Alice: it must send another message to Alice, which means inventing (or adopting) yet another protocol and bouncing more messages around the system.",0.3,Alice
1238nxa,jdweiyg,"I agree that the visibility part is very important—if Bob is only supposed to use one of Alice's methods, he shouldn't even be able to *accidentally* access the others.",0.2333333333333333,Alice
1238nxa,jdweiyg,"Furthermore, even if Bob is known to use the interface correctly, he might pass Alice's interface on to Carol who incorrectly uses methods that Bob doesn't.",0.0,Alice
122ng8f,,"How do JIT compiled languages compare to static ones like C++ and Rust in runtime, disk space and RAM usage?",0.5,C++
122ng8f,,"How do JIT compiled languages compare to static ones like C++ and Rust in runtime, disk space and RAM usage?",0.5,Rust
122ng8f,jdr49kd,"JIT-accelerated dynamic languages like Python (via PyPy) and Lua (via LuaJIT) can give results similar to native code, when running tiny benchmarks.",0.0,Python
122ng8f,jdr49kd,"JIT-accelerated dynamic languages like Python (via PyPy) and Lua (via LuaJIT) can give results similar to native code, when running tiny benchmarks.",0.0,Lua
122ng8f,jdr49kd,"The other, a JPEG decoder, doesn't have a Lua version.",-0.125,Lua
122ng8f,jdr49kd,"I've been meaning to create a more substantial test program (like a compiler) for years, but coding in either Python or Lua is a slog, given the lack of features I usually rely on.",0.125,Python
122ng8f,jdr49kd,"I've been meaning to create a more substantial test program (like a compiler) for years, but coding in either Python or Lua is a slog, given the lack of features I usually rely on.",0.125,Lua
122ng8f,jdrhrta,"Here is what you are looking for:   1: https://github.com/rochus-keller/Oberon/blob/master/testcases/Are-we-fast-yet/Are-we-fast-yet_results_linux.pdf  2: http://software.rochus-keller.ch/are-we-fast-yet_lua_results_2020-10-12.pdf  Based on the Are-we-fast-yet benchmark suite the results demonstrate that Lua 5.4.1 (interpreter) takes about 5 times as long as LuaJIT for the same benchmark (ref 2:), whereas Node.js (i.e.",0.15,Lua
122ng8f,jdrhrta,"JS V8) takes about half as long as LuaJIT, and the same benchmark transpiled to C and compiled/optimized with GCC is about four times as fast as LuaJIT (ref 1:).",0.09666666666666666,C
122ng8f,jdros49,"The Dynamic nature of Lua and JavaScript make optimizations more difficult -- which is why they typically use a JIT -- although there are techniques usable in JavaScript to ""lock-in"" some types such as integers.",-0.03333333333333333,Lua
122ng8f,jdros49,"The Dynamic nature of Lua and JavaScript make optimizations more difficult -- which is why they typically use a JIT -- although there are techniques usable in JavaScript to ""lock-in"" some types such as integers.",-0.03333333333333333,JavaScript
122ng8f,jdros49,"On the other hand, modern Browsers typically have multi-tiered evaluation strategies for JavaScript: Interpreter -> Lightweight JIT -> Heavy JIT.",-0.07291666666666666,JavaScript
122ng8f,jdros49,"Even the ""Heavy"" tiers for JavaScript tend to apply only a subset of the optimizations an AOT compiler such as the GCC or LLVM backends will.",-0.06666666666666667,JavaScript
122ng8f,jdros49,"Any task that benefits from vectorization, for example, will typically perform much better in native languages (C++ and Rust) simply because even if the compiler is not smart enough to auto-vectorize, the developer can use vector intrinsics in the code itself.",0.045238095238095244,C++
122ng8f,jdros49,"Any task that benefits from vectorization, for example, will typically perform much better in native languages (C++ and Rust) simply because even if the compiler is not smart enough to auto-vectorize, the developer can use vector intrinsics in the code itself.",0.045238095238095244,Rust
122ng8f,jdros49,"Lua and Javascript typically do not offer vector intrinsics, and JITs typically do not perform auto-vectorization, so that's an entire domain of benchmarks where the difference is stark.",-0.008333333333333338,Lua
122ng8f,jdrsc5s,"If you want code to be fast, allocate output arrays ahead of time and pretend you only know enough of the language to write code that looks like C, all just loops, arrays, and arithmetic.",0.06666666666666667,C
122ng8f,jdrfwi9,Lua and Jokescript are single-threaded.,0.0,Lua
122ng8f,jdrfwi9,C++ and Rust are multi-threaded.,0.0,C++
122ng8f,jdrfwi9,C++ and Rust are multi-threaded.,0.0,Rust
122ng8f,jdv52bo,IME Lua and JS are >5x slower than C++ and Rust but other JIT-compiled languages like those on .NET are comparable to C++ and Rust.,-0.125,Lua
122ng8f,jdv52bo,IME Lua and JS are >5x slower than C++ and Rust but other JIT-compiled languages like those on .NET are comparable to C++ and Rust.,-0.125,C++
122ng8f,jdv52bo,IME Lua and JS are >5x slower than C++ and Rust but other JIT-compiled languages like those on .NET are comparable to C++ and Rust.,-0.125,Rust
122ng8f,jdsyjki,source: https://old.reddit.com/r/programming/comments/6eg0x/where_are_the_fast_dynamic_languages_is_lisp_the/c03md43/  > the inner loop of mandelbrot is now identical (at the ucode IR level) to the IR generated by a C compiler.,0.0,C
122ng8f,jdsyjki,"Of course it depends on the workload, but it's not uncommon for LuaJIT to match C code when dealing with pure numerics.",-0.09285714285714287,C
122ng8f,jdsyjki,"In a larger program you'd have to write your code to avoid allocations in hot spots, which would be a major pain in the ass, but less of a pain than writing C code.",0.036458333333333336,C
122ng8f,jdsyjki,Plus typically you only have to worry about optimizing the hot spots rather than taking the productivity hit of C across your entire program.,0.020833333333333336,C
122ng8f,jdsyjki,C does very well on the former and very badly on the latter.,-0.17749999999999994,C
122ng8f,jds9aus,There's a third axis actually:  * inlined objects vs indirect objects  C tends to use inlined objects - structs are stored directly inside other structs.,-0.006249999999999999,C
122ng8f,jds9aus,"Java OTOH forces them all to be allocated separately, and this is a major cause of Java being 2x slower for all real-world programs (and also taking up 2x RAM, which is mostly separate from the latency issue proper unless cache misses are a relevant problem).",0.240625,Java
122ng8f,jdtcxzu,"(Who would take a substantial C app and rewrite line by line in Lua, or vice versa?)",0.0,C
122ng8f,jdtcxzu,"(Who would take a substantial C app and rewrite line by line in Lua, or vice versa?)",0.0,Lua
122ng8f,jdtcxzu,"While Lua itself has introduced an `i64` type, LuaJIT doesn't support that.",0.0,Lua
122ng8f,jdtcxzu,"(I do have one reasonable sized project written in dynamic code, an assembler, that I may port to Lua and/or Python, just for the purpose of comparing throughput.",0.1,Lua
122ng8f,jdtcxzu,"(I do have one reasonable sized project written in dynamic code, an assembler, that I may port to Lua and/or Python, just for the purpose of comparing throughput.",0.1,Python
122ng8f,jdrbq8z,"I remember watching a long running Python batch processor ""warm up"" when run under PyPy.",0.27499999999999997,Python
122ng8f,jdsazvw,"You wouldn't take a CPython program that somehow runs across 28 cores, and compare that with a C version that only uses one, and conclude that CPython outperforms C. But you want to allow such misleading results when things are the other way around.",-0.041666666666666664,C
122ng8f,jdteq9l,"> Who would take a substantial C app and rewrite line by line in Lua, or vice versa?",0.0,C
122ng8f,jdteq9l,"> Who would take a substantial C app and rewrite line by line in Lua, or vice versa?",0.0,Lua
122ng8f,jdtcqzm,It is also incorrect; several JavaScript runtimes provide the means to create new threads.,0.06818181818181818,JavaScript
122mhjm,jdquh6j,"For example, Python's indentation, although it doesn't need much context, makes it context-sensitive.",0.2,Python
122mhjm,jdquh6j,"You could take any such language (there are many - Rust, even C is context-sensitive), you could reimplement that grammar and discuss benefits and drawbacks of such an approach.",0.16666666666666666,Rust
122mhjm,jdquh6j,"You could take any such language (there are many - Rust, even C is context-sensitive), you could reimplement that grammar and discuss benefits and drawbacks of such an approach.",0.16666666666666666,C
122mhjm,jdquh6j,"Now, this doesn't mean you have to create a braced Python.",-0.3125,Python
122mhjm,jdquh6j,"For example, Python's context-sensitivity could be eliminate if you would allow for intermittently changing scopes, ex.",0.0,Python
122mhjm,jdts7b4,"Many CS schools have an undergrad class called ""compilers"" in which you'll implement (from the ground up) either a Scheme or a thing-that-is-like-Java called decaf, or possibly you'll implement Scheme and just *call* it decaf.",0.25,Scheme
122mhjm,jdsz4xl,One idea I was toying with was an MLIR frontend for array languages (APL in particular).,0.16666666666666666,APL
122mhjm,jdsz4xl,"APL is a strange old language that kind of just amuses me, but I think it'd have great benefit from tying into the lastest and greatest matrix stuff.",0.49000000000000005,APL
122mhjm,jduv08y,"For my Bachelor thesis, I have implemented a [PicoBlaze assembler and emulator in JavaScript](https://flatassembler.github.io/PicoBlaze/PicoBlaze).",0.0,JavaScript
122mhjm,jdrb3oa,The reason Python's indentation is context-sensitive is because you have to remember which indentation you're on.,0.0,Python
122mhjm,jdrb3oa,"If you didn't track it, then Python grammar for lines is simply:      INDENT*...  See, no context needed, at least not for grammar.",-0.15,Python
122mhjm,jdrb3oa,"Here's how an overengineered Hello World could look like then:      def hello():         print(""Hello"")      def world():         print(""World"")      hello()         print("" "")             world()  Despite resembling Python, this grammar is actually context-free.",0.0,Python
122mhjm,jdrb3oa,"Furthermore, the consequence of such syntax would for      def hello():         print(""Hello"")     def world():         print(""World"")  produce code equal to Python 3's      def hello():         print(""Hello"")          def world():             print(""World"")  ---  Overall, I won't spoil the potential bachelor thesis further.",0.0,Python
122mhjm,jdsgjt0,"Given that Python has to at least once go over the code to compile it, this would be a benefit, especially for large codebases or in hot reloading scenarios.",0.04107142857142857,Python
122mhjm,jdsgjt0,"This is not about Python, this is about computing theory.",0.0,Python
122mhjm,jdsgjt0,> misses the big benefit of python's syntax  The big benefit of Python's syntax is readabaility.,0.0,Python
122mhjm,jdsgjt0,"In fact, the example I provided enhances it, since now it would be possible to group related things under some indentation, something that isn't possible in Python out of the box.",0.0,Python
122mhjm,jdst6gq,Fair  > The big benefit of Python's syntax is readabaility  The big benefit is that the code always behaves exactly like you would read pseduo code.,0.2375,Python
122mhjm,jdsuoi8,Python has to use a specialized grammar to generate its parser.,0.0,Python
122mhjm,jdsuoi8,There are plenty of differences between Python and pseudocode.,0.0,Python
122mhjm,jdsuoi8,"The most obvious one is the use of `=` for equality in pseudocode, while Python uses it for assignment.",0.25,Python
122mhjm,jdsuoi8,"For example, Python code does not perform as it reads because there are inherently no significant limitations on naming entities, whereas, with pseudocode, the intent and functionality has to be apparent from the name.",-0.06875,Python
122mhjm,jdsuoi8,"It is fully possible to construct pseudocode where differing indentation has no meaning, and therefore the notion that Python is somehow related to pseudocode falls into water.",0.0,Python
122mhjm,jdsuoi8,"In other words, let me make myself clear - while Python may be very liberally described as having a significant overlap of pseudocode, pseudocode is, of course, much greater than Python or any specific language it has similarities with, and Python is not really its subset.",0.13571428571428573,Python
122mhjm,jdsuoi8,"I also hope you understand that my recommendation (in the sense of making it context-free: the exact recommendation of INDENT/DEDENT may not be) is a superset of Python, so everything you can do in Python, you can do in this hypothetical language.",0.25,Python
122mhjm,jdsuoi8,This is because the context-sensitivity in Python comes from the extra constraint it puts into how indentation is used - simpy removing those constraints does not remove expression from the grammar.,0.0,Python
122mhjm,jdsuoi8,"Finally, I hope you understand that that implies that any concern you might have can be resolved by limiting this new superset of Python in some way, but without making it context-sensitive.",0.06818181818181818,Python
122mhjm,jdsuoi8,"In other words, let me rephrase that, there is no critique you can give on this hypothetical language that would not be a critique of Python, PEP8 or the users.",-0.125,Python
122mhjm,jdt52je,There are plenty of differences between Python and pseudocode  Sure!,0.625,Python
122mhjm,jdt52je,"> so everything you can do in Python, you can do in this hypothetical language  But you can do things you can't do in Python, and this is a problem.",0.0,Python
122mhjm,jduuqj2,"I am talking about a language, one of which is Python, as a whole.",0.2,Python
122mhjm,jduuqj2,"In terms of indentation, some pseudocode resembles Python, but not pseudocode as a concept.",0.0,Python
122mhjm,jduuqj2,"That is demonstrably false, as there are braced languages, formatting standards, as well as tools like Prettify that clearly utilize indentation the same way as Python.",-0.10000000000000002,Python
122mhjm,jduuqj2,It is also wrong in the sense that Python provides tools that allow you to bypass this.,-0.5,Python
122mhjm,jduuqj2,"> But you can do things you can't do in Python, and this is a problem.",0.0,Python
122mhjm,jduuqj2,"So, because turning the grammar to a CF one creates a superset of Python, you can create the exact same language with it.",0.125,Python
1226y82,jdrkpqy,"For example, in Haskell `case x of { 1 -> … }` is not the same as `let { y = 1 } in case x of { y -> … }`.",0.0,Haskell
1226y82,jdp7tv2,"""**  Start implementing an explicit variable introduction, and later you may add an additional shorter version, that's how C# lambda style functions, gradually changed syntax thru time and different versions.",0.0,C
1226y82,jdp7tv2,"is not C, but here are more practical examples, about using a lambda syntax style functions.",0.5,C
1226y82,jdp7tv2,"C style suggestion:      int mult (int a, b) -> { return a * b; }          void incptr (int p&) -> { p++; }          ...     int b = 7;     int x = mult(3, b);     int q = &b;     incptr(q);     ...     int a[5];     int b[5];     int c[5];          for (int i=0; i < 5; i++)     {        a[i] = i; b[i] = (10 - I); c[i] = 0;     }          void Map(int (*func) (int a, b))     for (int j=0; j < 5; j++)     {        c[i] = func(a, b);     }          ...     Map( &mult );     ...",-0.75,C
1220v2y,jdxve47,"When a function is fully declared in C, the compiler is creating a symbol and compiling its body.",0.0,C
1220v2y,jdxve47,"One-pass compilers aren't as relevant nowadays because we have lots of memory, but especially for low-level programming (such as in C) a one-pass compiler is often preferred as it can get similar effects with *much* less memory usage.",0.046666666666666676,C
1220v2y,jdzsomt,"Some languages (Python, Rust) decided to not include the operator at all.",0.0,Python
1220v2y,jdzsomt,"Some languages (Python, Rust) decided to not include the operator at all.",0.0,Rust
1220v2y,jdz7yy0,"The idea that you can't redefine things didn't come with C.  The compiler C was designed on was just a naive transformer to assembly, and the assembler was just a naive transformer to a simple object file which the linker patched up.",-0.19999999999999998,C
1220v2y,jdz7yy0,Why bother keeping track of extra information your language (original C) doesn't need?,0.1875,C
121xhmg,,"A transpiler is a compiler that translates languages within the same level abstractions, like JavaScript and Python.",0.0,JavaScript
121xhmg,,"A transpiler is a compiler that translates languages within the same level abstractions, like JavaScript and Python.",0.0,Python
121xhmg,,"So, here is a list of all available transpilers:  * `C` **->** `Rust` **=** c2rust **OR** crust * `C++` **->** `Rust` **=** crust  Please help me with filling the list by telling me all of the available transpilers, so I can add it in the list.",0.4,C
121xhmg,,"So, here is a list of all available transpilers:  * `C` **->** `Rust` **=** c2rust **OR** crust * `C++` **->** `Rust` **=** crust  Please help me with filling the list by telling me all of the available transpilers, so I can add it in the list.",0.4,Rust
121xhmg,,"So, here is a list of all available transpilers:  * `C` **->** `Rust` **=** c2rust **OR** crust * `C++` **->** `Rust` **=** crust  Please help me with filling the list by telling me all of the available transpilers, so I can add it in the list.",0.4,C++
121xhmg,jdo1hrl,"Well, all of nims backends are transpilers to C, C++, C# and JS.",0.0,C
121xhmg,jdo1hrl,"Well, all of nims backends are transpilers to C, C++, C# and JS.",0.0,C++
121xhmg,jdo1hrl,"Is llvm really that much lower level than C, i.e.",0.2,C
121xhmg,jdo1hrl,What about BF->C?,0.0,C
121xhmg,jdoopya,"There's a ton of languages that compile to JS - OCaml, TypeScript, Flow, ReScript, ReasonML, CoffeeScript, [and like a hundred more in this incomplete list](https://gist.github.com/matthiasak/c3c9c40d0f98ca91def1).",0.5,TypeScript
121xhmg,jdo5taq,"[https://github.com/cmspeedrunner/Pyf](https://github.com/cmspeedrunner/Pyf)   Python to brainfuck, pyfuck",0.0,Python
121xhmg,jdo3rsw,"All your examples count as transpilers IMO, except for C to LLVM.",0.0,C
121xhmg,jdorzer,remember when ES6 was routinely transpiled to JavaScript?,0.0,JavaScript
120ybk7,jdp0vc1,"TBF, this is a simpler optimisation than the C example, where the compiler has to determine unequivocally that a variable set to `FLAG` was never used.",0.0,C
120c0ss,,"Context: I want to create a web-based C interpreter as a personal project (which can do visualization of memory as a teaching aid) and I was thinking that an explicit control evaluator would be appropriate for gotos (continue, break, return, etc) as those seem to be harder to implement in a tree-walk interpreter, and I don't really wish to create a whole bytecode for a bytecode interpreter.",0.16,C
120c0ss,jdh0g51,"**  I haven't worked with an Explicit Control Evaluator, but I do have worked with Interpreters, and other related tools, and with some C like compilers.",-0.0625,C
120c0ss,jdh0g51,"The other choice would be a CGI compiled tool integrated into a web server, like PHP, Java or Server side JS does.",-0.125,PHP
120c0ss,jdh0g51,"The other choice would be a CGI compiled tool integrated into a web server, like PHP, Java or Server side JS does.",-0.125,Java
120c0ss,jdh0g51,"**There's also the C macro issue, that makes both a compiler and interpreter, or any tool like the Explicit Control Evaluator, difficult to implement, compared to a P.L.",-0.5,C
120c0ss,jdh0g51,"**  And, I do have worked with a C alike macroprocessor, and detecting which location in source code is interpreted, is complex.",-0.3,C
120c0ss,jdh0g51,"Bytecode were called Intermediate Code Representation code in compilers, and aren't always ""byte"" sized, but sometimes ""words"" (2 bytes) or more bytes, but the original Java team wanted to keep it as ""byte"" sized instruction, when most compilers / interpreters were already 2 or 4 based.",0.4583333333333333,Java
120c0ss,jdkgubd,"PHP, Ruby and Perl main implementations were tree-walking interpreters for a long time.",0.05833333333333333,PHP
120c0ss,jdkgubd,"PHP, Ruby and Perl main implementations were tree-walking interpreters for a long time.",0.05833333333333333,Ruby
120c0ss,jdkgubd,"PHP, Ruby and Perl main implementations were tree-walking interpreters for a long time.",0.05833333333333333,Perl
120c0ss,jdh11q8,"The interpreter doesn't have to be fast, nor encompass the entire C standard, but most features should be there (eg pointers, memory allocation).",0.175,C
120c0ss,jdhrmlt,"`progn` in Common Lisp, `begin` in Scheme, `$sequence` in Kernel).",-0.3,Lisp
120c0ss,jdhrmlt,"`progn` in Common Lisp, `begin` in Scheme, `$sequence` in Kernel).",-0.3,Scheme
120c0ss,jdh3gar,"Don't get surprised if some people try to discourage you, for not using C or C++.",0.1,C
120c0ss,jdh3gar,"Don't get surprised if some people try to discourage you, for not using C or C++.",0.1,C++
120c0ss,jdh3gar,**  I had a similar issue because I did an interpreter related project in procedural / modular Pascal.,0.0,Pascal
120c0ss,jdh3gar,"Note: I also wanted to make a PHP extension that included types, before they were added.",0.0,PHP
120c0ss,jdh3gar,"My interpreter related graduated project took 6 months, and other similar projects that are done in free time have been going on by years, including a C macroprocessor.",0.06875,C
120c0ss,jdh3gar,"Seems you only want to use the simple ""#include"" feature of the C macroprocessor without the ""#define x(...) ..."" feature, which would be a difficult issue,  for your project.",-0.16666666666666666,C
120c0ss,jdh3gar,**Have you already implemented a short version of the C lexer and parser in Typescript?,0.0,C
120c0ss,jdh3gar,"**  You could start with that, recognize a valid set of C files, detecting  valid text tokens, confirm that those C tokens match a valid C syntax, and leave the rest for later.",0.0,C
120c0ss,jdjzpn2,"(define f ()         (print ""one"")         (print ""two"")         (print ""three""))  Because Lisp has syntax sugar for defining lambdas and multi-expression lambdas.",0.0,Lisp
120c0ss,jdjjkvg,`goto` isn't at all hard to emulate; the problem with it is how it interacts with other features and control flow (the simplest example being C variable declarations).,-0.20833333333333334,C
120c0ss,jdjjkvg,"And they're not very fast, though better than non-delimited continuations (Scheme's `call/cc`).",0.21153846153846154,Scheme
120c0ss,jdk4u1z,"If you are interpreting C rather than compiling it, you can also only go back to a label which the interpreter has seen (you can't jump forward), unless you pre-evaluate all of the labels of a given scope before evaluating the code under the labels.",0.0,C
120c0ss,jdk4u1z,"`goto` is simple in ISO C, but in GNU C, you also have computed gotos/[first-class labels](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#Labels-as-Values), among other extensions which make it a more complex feature.",0.018750000000000003,C
120c0ss,jdk4u1z,"Also, don't forget that setjmp/longjmp is part of ISO C, and scoped goto is insufficient for providing it.",0.0,C
11zo078,jdekece,"the people actively cramming new stuff into Python today have probably been intertwined with the language for like 15 years and it's impossible for them to be able to think like someone who's confronted with the whole thing as it currently stands, for the first time.",0.040909090909090916,Python
11zo078,jdf5u5x,"I think it's also worth mentioning the ""Curse of Lisp"".",0.3,Lisp
11zo078,jddmmpj,Among the many things I like about Erlang is that the language is quite small.,0.125,Erlang
11zo078,jddmmpj,"We had a weeklong Erlang class one time, and covered the full language in the first two days.",0.3,Erlang
11zo078,jddtasl,"Rather, follow a few rules:  * never rely on a language solution if a library solution would be better * never rely on a library solution if a language solution would be better * have a good story for generated code  C++, for example, is an example that makes the language more complex in order to support library solutions for things that would be much simpler if they were implemented in the language in the first place.",0.26875,C++
11zo078,jddh9hb,"Also relevant, especially as it relates to his mention of patterns/abstractions and Lisp, is Peter Norvig's [critique of GoF patterns](http://www.norvig.com/design-patterns/design-patterns.pdf) in dynamic langauges like Lisp, Smalltalk, and Dylan.",0.13333333333333333,Lisp
11zo078,jddh9hb,"GoF is focused on C++ issues stemming from its half-assed object-orientation, such as lack of first-class classes and functions.",0.0,C++
11zo078,jdlnln6,"> Lua was, and is, a small language — and, probably not coincidentally, so is its implementation.",-0.25,Lua
11zo078,jdlnln6,"The [Lua repo](https://github.com/lua/lua) is 33,742 lines of code.",0.0,Lua
11zo078,jdlql82,"For example, recently I've discovered a nasty bug in Kotlin (incorrect values of constants).",-0.5,Kotlin
11zo078,jdlql82,And it's no coincidence that Kotlin's maintained by a small team in a company whose main business is IDEs.,-0.04166666666666667,Kotlin
11zo078,jdlql82,"Java, on the other hand, while being ostensibly a worse language, is maintained by a huge company for which it it one of the main cash cows, and huge and expert teams are allocated to it.",0.08833333333333335,Java
11zo078,jdlql82,"And lo and behold, I've never ever encountered a bug in Java.",0.0,Java
11zo078,jddcasf,"**  C and C++ have the ""fame"" of avoiding and keeping all new keywords as less as possible, even already useful new keywords took a long time to be approved.",0.05934343434343434,C
11zo078,jddcasf,"**  C and C++ have the ""fame"" of avoiding and keeping all new keywords as less as possible, even already useful new keywords took a long time to be approved.",0.05934343434343434,C++
11zo078,jdjm7yr,What meta-languages do I know of in Common Lisp?,-0.3,Lisp
11zo078,jdjm7yr,"There's Coalton, which adds a type system on to Common Lisp.",-0.3,Lisp
11zo078,jdjm7yr,"There's an implementation of APL, several of minikanren, and some shell syntaxes (hybrids of unix shell and CL itself).",0.0,APL
11zo078,jdlmehg,Forth is another example.,0.0,Forth
11zo078,jdea2rq,That's the problem with Erlang though.,0.0,Erlang
11zo078,jde806q,"> GoF is focused on C++ issues stemming from its half-assed object-orientation, such as lack of first-class classes and functions.",0.0,C++
11zo078,jdeml29,"I've been using JavaScript as my primary language at work for about a dozen years now, and ES6 is *vastly* more pleasant to use than earlier versions.",0.4083333333333333,JavaScript
11zo078,jdeumtz,"You'd have both `for` and `fcollect`, not to mention the rest of the stuff you can do with iterators, if you converted to them instead; Rust and Python both do this and the ergonomics of it are fine.",0.4166666666666667,Rust
11zo078,jdeumtz,"You'd have both `for` and `fcollect`, not to mention the rest of the stuff you can do with iterators, if you converted to them instead; Rust and Python both do this and the ergonomics of it are fine.",0.4166666666666667,Python
11zo078,jdm0fhw,"I don't know a huge amount about lisps, but you see this to a certain extent at the moment with Rust, where async programming is split into different ecosystems that struggle to interoperate, because they rely on different underlying runtimes that cannot be exchanged.",0.15357142857142858,Rust
11zo078,jdgpdv4,"No, the problem with Erlang is that it doesn't have a static type system.",0.5,Erlang
11zo078,jddrn3l,"Yes, programmers are afraid of anything that doesn't look like C.",-0.6,C
11zo078,jdese6h,"Well, if you're using TypeScript that is.",0.0,TypeScript
11zo078,jdeu1ao,"They're certainly not the most popular - that title goes to JS and Python, largely because of their platforms (browsers, scientific computing engines).",0.30178571428571427,Python
11zo078,jdf5avh,Given Python regularly sits at the top of the TIOBE index (swaps positions with C occasionally) that's a pretty strange conclusion.,0.13999999999999999,Python
11zo078,jdf5avh,Given Python regularly sits at the top of the TIOBE index (swaps positions with C occasionally) that's a pretty strange conclusion.,0.13999999999999999,C
11zo078,jdewy8n,Rust and Python do this just fine because they have their own runtime; Fennel does not have a runtime.,0.5083333333333333,Rust
11zo078,jdewy8n,Rust and Python do this just fine because they have their own runtime; Fennel does not have a runtime.,0.5083333333333333,Python
11zo078,jdewy8n,It is strictly a compiler and cannot add any new features that don't already exist in the targeted runtime (the Lua VM) unless they can be implemented purely at compile time.,0.17532467532467533,Lua
11zo078,jdllf24,"Here the difference is in limitations: if we look at a C function invocation ""foo(x)"", we know from the limitations of C functions that x will not be modified, nor will in fact any of the local variables unless the address of those have escaped.",0.0,C
11zo078,jdllf24,In C we do have the possibility that this changes globals.,0.0,C
11zo078,jdllf24,"For C++ - which I consider a worse language from the readability point of view, we can no longer say that x will not be modified (due to implicit ref), we cannot even know that ""foo"" is a function!",-0.278125,C++
11zo078,jdllf24,"This allows C++ to express more syntax-like extensions, but at the cost of local comprehension, and consequently readability.",0.25,C++
11zo078,jdllf24,And the extensions that the talk argues for goes beyond what C++ offers.,0.1,C++
11zo078,jdppi46,"The problem is that almost all (barring ones using reader macros and such) wind up looking exactly like normal Lisp code, and so people sometimes have a tough time discerning them as separate languages, but they definitely are mini-languages of their own.",0.10185185185185186,Lisp
11zo078,jdoanhp,When was the last time you read C code with an `unless` macro?,0.0,C
11zo078,jdoanhp,And C _is_ a language that is heavily reliant on macros due to a lack of genericity.,-0.1625,C
11zo078,jdoanhp,"(Because, as it turns out, nobody wants to type out a full C routine signature for every type or syscall under the sun).",0.275,C
11zo078,jdjwj7m,"I have to admit that it was a long time ago since I used Erlang, but I don’t remember that I missed static type checking.",0.225,Erlang
11zo078,jdgqx5l,"I don't wish to claim that dynamic languages don't have their place, but I'm a big fan of static typing myself, and when I was dabbling with Erlang, it certainly was annoying as hell having to deal with the dynamic type system.",-0.01428571428571429,Erlang
11zo078,jdf6oj4,"Back when the Matasano challenges were a thing, I worked through them in Erlang.",0.0,Erlang
11zo078,jdf6oj4,"Erlang by itself does have some neat features, but they're just neat.",0.0,Erlang
11zo078,jdeboll,"The whole selling point of Erlang is its concurrency story, and while the core language provides the primitives for it, it's practically impossible to create usable concurrency without the OTP.",-0.2333333333333333,Erlang
11zo078,jddw0jm,And C++.,0.0,C++
11zo078,jdfcmys,"Js rules the web space because it was chosen as a browser language and python sees broad general purpose use but is only a category leader in the data space, and even that's just to be a wrapper around C",0.037500000000000006,C
11zo078,jdh85l4,"They're certainly not the most popular - that title goes to JS and Python, largely because of their platforms (browsers, scientific computing engines).",0.30178571428571427,Python
11zo078,jdh85l4,"Yes, in terms of absolute numbers, sure JS and Python though they are not nearly the same as they used to be.",0.16249999999999998,Python
11zo078,jdh85l4,"Python had type annotations galore, and there's clamour (and inevitably fierce debates) about adding actual static typing to the language, which is rather silly in my opinion.",0.0,Python
11zo078,jdh85l4,"This is more symptomatic of Python being used across domains where it doesn't really fit, and even there, as /u/Jmc_da_boss mentioned, quite a lot of Python's usage comes from being a script to drive the native (C, mostly) libraries in scientific computing, NLP, ML et al.",0.4666666666666666,Python
11zo078,jdh85l4,"This is more symptomatic of Python being used across domains where it doesn't really fit, and even there, as /u/Jmc_da_boss mentioned, quite a lot of Python's usage comes from being a script to drive the native (C, mostly) libraries in scientific computing, NLP, ML et al.",0.4666666666666666,C
11zo078,jdh85l4,"I am a big fan of dynamic languages (Common Lisp being my favourite), but only as prototyping tools, for scripting support, or for small-to-medium projects.",-0.075,Lisp
11zo078,jdh85l4,A year of Clojure + Ruby on a growing project was a nightmarish experience for me.,0.0,Clojure
11zo078,jdh85l4,A year of Clojure + Ruby on a growing project was a nightmarish experience for me.,0.0,Ruby
11zo078,jdh85l4,"Okay, I am exaggerating a bit, but there's a very big reason why TypeScript has become so popular on the frontend - JS developers can actually focus on the code instead of being bogged down with banal type errors.",0.06349206349206352,TypeScript
11zo078,jdg3bor,"C#, java, c++and typescript  are a used years they aren't the 1 but they are the most part of the top 10 , and most developer work in some of this langues",0.5,C
11zo078,jdms8ov,"A case in point would be the new streams+lambda feature set in modern Java which feels like a language within a language, and therefore violates those espoused principles.",0.16818181818181818,Java
11zo078,jdprrwg,Practically every large Lisp project does that.,0.21428571428571427,Lisp
11zo078,jdprrwg,"Also, for the record, C macros are nothing like Lisp macros.",0.0,C
11zo078,jdprrwg,"Also, for the record, C macros are nothing like Lisp macros.",0.0,Lisp
11zo078,jdprrwg,Lisp macros operate on the AST unlike C macros which are basically text substitution.,0.0,Lisp
11zo078,jdprrwg,Lisp macros operate on the AST unlike C macros which are basically text substitution.,0.0,C
11zo078,jddyd1q,"Erlang certainly has it's own noisy bits, but overall is minimal and elegant.",0.24285714285714288,Erlang
11zo078,jdgi1y9,"I know it hasn't taken off quite as much in Python yet, but most big projects that I've seen (both open and closed source) use Typescript rather than Javascript directly.",0.11666666666666665,Python
11zo078,jdh6ylk,"It entails practically all aspects of software development using Erlang - concurrency, error recovery, state management, event management et al.",0.0,Erlang
11zo078,jdh6ylk,"If you really believe that the primitives in Erlang proper are enough to build industrial applications, try building a gen_server yourself and see how that fares in the **real** world.",0.1,Erlang
11zo078,jdghtkj,"Using the primitives that Erlang provides, and not using the OTP, you'd basically have to reinvent the OTP to have any modicum of actual real-world concurrency support.",0.0,Erlang
11zo078,jdghtkj,Your whole initial comment was about how simple Erlang was.,0.06666666666666667,Erlang
11zo078,jdghtkj,Or that Haskell 98 is simple when it's practically useless.,-0.25,Haskell
11zo078,jddz4v9,"Erlang's syntax isn't pretty, but the semantics are!",0.3125,Erlang
11zo078,jddz4v9,"I've wondered why there isn't a ""CoffeeScript"" for Erlang.",0.0,Erlang
11zo078,jddz4v9,"Yes, there's Elixir, but I'm thinking of pure Erlang just with cleaner syntax.",0.21428571428571427,Elixir
11zo078,jddz4v9,"Yes, there's Elixir, but I'm thinking of pure Erlang just with cleaner syntax.",0.21428571428571427,Erlang
11zo078,jdh791i,"Even the Python community, reading their forums, want more and more static typing support (even though current Python already has, albeit unenforced, type annotations that at least provide warnings).",0.24,Python
11zo078,jdpp1be,"The second goes into some details about his plans for Java itself (most of which didn't go through) and he mentions about Generics, Operator Overloading (possibly constrained), and Value Objects.",0.16666666666666666,Java
11zo078,jdpp1be,"Unfortunately, only the first one landed in Java and that too in a semi-broken way.",0.125,Java
11zo078,jdh014h,Is a statically type language for the BEAM that compiles to Erlang and JS.,0.0,Erlang
11zo078,jdm25po,"Type annotations in Python do not produce any warnings, and probably never will (that would be far too costly at runtime for an already relatively slow language).",-0.10000000000000002,Python
11zo078,jdm25po,"You may be thinking of PHP, which I believe does use type annotations at runtime for both warnings and errors (although I've not followed that for a long time).",-0.05,PHP
11zo078,jdm25po,"In Python, static typing is generally provided through external linting tools like Mypy and Pyright.",0.18333333333333335,Python
11zo078,jdkz6yq,"Based on my own experiences learning Erlang and working with it (admittedly a long time ago, but I doubt the core language has changed that much), I find it hard to believe that there are such massive applications out there not using the OTP at all (the initial version at least, as you claim).",0.019791666666666666,Erlang
11zfe98,,So `'A'` in Rust corresponds to `$A` in Hlang.,0.0,Rust
11zfe98,jdcs1s5,"The ultimate “no reserved keywords” language is Tcl:      proc if {tst then _else elsethen} {         set res [uplevel ""expr $tst""]         switch -exact $res {             1 {uplevel $then}             0 {uplevel $elsethen}         }     }      set x 8      if {$x > 7} {         puts ""Yes""     } else {         puts ""No""     }  Above, I hackily overwrite the built in `if` and Tcl doesn’t care because it’s just treated like any other function.",0.03125,Tcl
11zfe98,jdkwpwk,Fixed form Fortran has no keywords.,0.1,Fortran
11zfe98,jdci3w7,"However, like in Rust, the unary `=` works on the top-most context other than the global context, where it's not allowed and raises a syntax error.",-0.0625,Rust
11zfe98,jdci3w7,It's like Elixir or Go in this regard.,0.0,Elixir
11zfe98,jdci3w7,It's like Elixir or Go in this regard.,0.0,Go
11zfe98,jdevtpr,Lisp's not hard to understand because of a lack of keywords; it uses largely the same ones as other languages.,0.058779761904761904,Lisp
11zfe98,jdevtpr,"You could make a Lisp with those forms defined; it might be less visually appealing than one that provides special parsing rules to them, but it shouldn't be harder to understand, because it says the same things.",0.1180952380952381,Lisp
11zfe98,jdgzp5b,Java designers exploring adding keywords with dashes after discovering this is backwards compatible with existing lexer behavior to reject these)  And lots of languages struggle with evolving new features when they interact with unfortunate existing design choices that they're stuck with.,-0.18181818181818182,Java
11yz68i,,My current starting point is Rust.,0.0,Rust
11yz68i,,Or whose patterns design is better or different than that of Rust (even if only on specific points).,0.125,Rust
11yz68i,jdb0xtx,"When talking about pattern matching, I can't not mention Prolog, Erlang and Elixir.",0.0,Prolog
11yz68i,jdb0xtx,"When talking about pattern matching, I can't not mention Prolog, Erlang and Elixir.",0.0,Erlang
11yz68i,jdb0xtx,"When talking about pattern matching, I can't not mention Prolog, Erlang and Elixir.",0.0,Elixir
11yz68i,jdajjyt,"Scala's pattern matching allows programmers to write their own patterns, which is pretty neat.",0.425,Scala
11yz68i,jdajjyt,"C#'s pattern matching also works in any boolean expression and can declare new variables inside of that expression, which is weird and a little janky but really helpful when writing C# code.",-0.08778409090909091,C
11yz68i,jdaphp4,Check out Haskell’s or standard ml’s pattern matching capabilities.,0.0,Haskell
11yz68i,jdbjca8,Have a look at Haskell's [pattern synonyms extension](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pattern_synonyms.html),0.0,Haskell
11yz68i,jdbtl23,I always liked how Kotlin's smart casts and Typescript's narrowing work.,0.40714285714285714,Kotlin
11yz68i,jdc6rdh,"The unification feature could go from the power even more in the **Prolog** direction, that would be ingenious.",0.5,Prolog
11yz68i,jdc6rdh,"I think languages like Prolog offer extremely much,but are partially simply so different, so that one must throw very much experience knowledge from the other programming languages overboard to be able to program with it.Prolog is very hard at first if you come from imperative programming, for example.",0.0544047619047619,Prolog
11yz68i,jdc6rdh,"Edit: oh, and as mentioned her elsewhere, pattern matching on **Erlang binaries** is also awesome.",1.0,Erlang
11yz68i,jdc6rdh,"e.g:  ``` let (|Even|Odd|) input = if input % 2 = 0 then Even else Odd  let TestNumber input =    match input with    | Even -> printfn ""%d is even"" input    | Odd -> printfn ""%d is odd"" input ```` Scala has something similar to offer, only solved a little differently.",-0.09821428571428571,Scala
11yz68i,jdc6rdh,Scala e.g.,0.0,Scala
11yz68i,jdbuynk,"I don’t know rust, but I’m not aware of any other lang that has anything similar to Erlang’s binary pattern matching.",-0.08333333333333333,Erlang
11yz68i,jdbuynk,"Erlang is fundamentally built around pattern matching, and has almost no other syntax.",0.0625,Erlang
11yz68i,jdewqhc,"I'm designing a C like language so I wanted to design a c-compatible pattern matching construct, if you could call it like that.",0.0,C
11yz68i,jdewqhc,"With that in mind, I really liked how Swift designed their switch statement, more than C# and D.",0.55,Swift
11yz68i,jdewqhc,"With that in mind, I really liked how Swift designed their switch statement, more than C# and D.",0.55,C
11yz68i,jdewqhc,"With that in mind, I really liked how Swift designed their switch statement, more than C# and D.",0.55,D
11yz68i,jdck3aa,"Rust cannot handle something like so:        let rec stack_or_reduce lex stack = match lex , stack with           Lint n ,  _      ->  (Texp (ExpInt n))::stack         | Lident v ,  _    ->  (Texp (ExpVar v))::stack         | Lstring s , _    ->  (Texp (ExpStr s))::stack        | Lsymbol ""("" , _  ->  Tlp::stack        | Lsymbol "")"" , (Texp e)::Tlp::st  ->  (Texp e)::st        | Lsymbol "")"" , _ -> stack_or_reduce lex (reduce 0 stack)         | Lsymbol s , _              -> let symbol =                   if s<>""-"" then tsymb s                   (* remove the ambiguity of the ``-'' symbol           *)                  (* according to the last exp element put on the stack *)                  else match stack                        with (Texp _)::_  ->  Tbin MINUS                                      | _ ->  Tunr UMINUS                 in ( match symbol with                        Tunr op  ->  (Tunr op)::stack                      | Tbin op  ->                          ( try stack_or_reduce lex (reduce (priority_binop op)                                                     stack )                           with ParseError -> (Tbin op)::stack )                     | _ -> raise ParseError )        | _ , _ -> raise ParseError ;;  (Source: https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html#toc82)  Specifically, something like this bit (destructuring the elements of the stack `stack`):      | Lsymbol "")"" , (Texp e)::Tlp::st  ->  (Texp e)::st  (Well, it can, sort of, but it's very unwieldy, bare minimum, and then too only for certain types like `Vec` and `VecDeque`, and you could always run into issues with the Borrow Checker).",0.1080357142857143,Rust
11yz68i,jdck3aa,"Of course, that being said, it is actually amazing that Rust can have so much of pattern matching support while not being an actual Functional language.",0.26666666666666666,Rust
11yz68i,jdcxf1u,Doesn't Rust use PCRE?,0.0,Rust
11yz68i,jdcxf1u,Look up regular expressions in Perl or Raku.,0.0,Perl
11yz68i,jdd0amx,Erlang’s bit syntax is amazing,0.6000000000000001,Erlang
11yz68i,jdbicpk,> C#'s pattern matching also works in any boolean expression and can declare new variables inside of that expression  We're actually generalizing this idea in what we facetiously call the *Ultimate Conditional Syntax* (UCS).,0.04545454545454545,C
11yz68i,jde0q8b,"Oh very interesting, the C# `is` expression seems to very similar to what I had in mind when I said ""better"" pattern matching.",0.3833333333333333,C
11yz68i,jdc9w9m,Haskell also has an interesting extension called View Patterns.,0.5,Haskell
11yz68i,jdbg55g,Some of this has been implemented in Haskell (which should also be a given language of interest if you haven't looked at it).,0.0,Haskell
11yz68i,jdf4o3l,The `is` expression certainly seems to be the way to generalize many special cases like those of Rust.,0.35714285714285715,Rust
11yz68i,jdcmi2a,"At this stage, Haskell is more like a family of languages than a single one!",0.20535714285714285,Haskell
11yz68i,jdbjnr9,(I'm not a C# developer),0.0,C
11yz68i,jdbbnwl,"Because, at least in my experience writing and reviewing a ton of code (in C#, not academic): most of the time, I'm interested in one or two patterns, with a default branch.",0.1125,C
11yz68i,jdbbnwl,"In the case of C#, the base type gets an abstract `Match` function which takes a handler closure for each case.",-0.8,C
11yz68i,jdbbnwl,"That way I get both C#'s very powerful but undecidable pattern matching, and exhaustivity for the types that need it.",0.39,C
11yz68i,jdbytfj,A language designed that way with full interop with TypeScript seems like a dream!,0.4375,TypeScript
11yz68i,jdbjz3m,"If you have some experience with Rust or Haskell, you will start to appreciate case-exhaustiveness matching",0.0,Rust
11yz68i,jdbjz3m,"If you have some experience with Rust or Haskell, you will start to appreciate case-exhaustiveness matching",0.0,Haskell
11yz68i,jdb69s3,"It is not easy to implement, but languages like Rust does it.",-0.21666666666666667,Rust
11yz68i,jdcum1r,I implemented a prototype of the core algorithm in about 30 lines of Dart code.,0.0,Dart
11yz68i,jdbr296,I do have Scala and Haskell experience.,0.0,Scala
11yz68i,jdbr296,I do have Scala and Haskell experience.,0.0,Haskell
11yz68i,jdbr296,Scala has exhaustive matching under some circumstances (sealed traits).,0.0,Scala
11yz68i,jdbr296,"But maybe that's a symptom of ""if you don't have nails, nothing looks like a hammer"" - the lack of proper coproduct types on C#.",0.0,C
11yz68i,jdchs64,"Does this mean that it will be fully interoperable with the *types* in TypeScript as well, ie giving type-checking and intellisense from imported TypeScript files?",-0.3125,TypeScript
11yz68i,jdchs64,Definately a valuable aim to allow working with TypeScript because so much of the world is moving there.,0.2,TypeScript
11yz68i,jdchs64,And for me not being able to let go of TypeScript interop is the one thing keeping me from working with other appealing languages.,0.2916666666666667,TypeScript
11yz68i,jdcljf5,"We have a very flexible type system with subtyping, structural typing, and equirecursive types which is basically compatible with TypeScript (with a few differences here and there which we hope to smooth over with time).",0.13333333333333333,TypeScript
11yz5rf,jdavjg9,This is something OCaml and Haskell get right: structure types should use the same syntax as discriminated unions.,0.14285714285714285,Haskell
11yz5rf,jdgwfaw,"When declaring formal parameters, you use traditional Algol/C syntax: `(type_t1 arg1, type_t2 arg2 ...)`, but when declaring variables with let, you use ""Pascal"" style: `let somevar : type_t`.",0.0,Pascal
11yz5rf,jdbqzer,"I don't really like this concept from OCalm or Haskell, I don't even like the syntax of functional languages.",0.2,Haskell
11yz5rf,jdee72w,I think this is something Haskell gets wrong.,-0.5,Haskell
11yz5rf,jdet3a9,"I agree, Haskell doesn't get that part right.",0.2857142857142857,Haskell
11yrcnl,jdb40mh,"Also, from the talk today, they mentioned that they want Verse to be ""the JavaScript of the metaverse"" (paraphrased), so I guess they're trying to push a more functional future in gamedev, rather than just for their own tools.",0.3666666666666667,JavaScript
11ymq2f,jd8u1og,"Interesting questions—I have seen vexing errors like that in beginners’ code a lot, including of course my own code when I was just learning FP in Haskell & OCaml.",0.55,Haskell
11ymq2f,jdb43og,"I'd also add that we typically add at least some type annotations to Haskell code, making the errors less likely to sum up to a big mess.",-0.13472222222222222,Haskell
11ye7c0,jd7zfx2,"As a concrete example, the SBCL implementation of Common Lisp generates machine code from source code.",-0.07499999999999998,Lisp
11ye7c0,jd7zfx2,"> hey, you probably shouldn't just go around calling that a compiler because that will confuse people who are expecting an AOT compiler  On the contrary, it has surprised many people that there is a compiler making sense of forms typed at a Lisp REPL, because they equate ""compiler"" with ""batch compiler"", my past self included.",0.11666666666666665,Lisp
11ye7c0,jd83gbh,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,C
11ye7c0,jd83gbh,C Code) to a lower level (e.g.,0.0,C
11ye7c0,jd87ca7,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,C
11ye7c0,jd8ir2b,"I think to be abundantly clear, 90% of the time I will use the word ""interpreter"" to describe what's running JavaScript (if forced to choose one word or the other), not just Python.",-0.10833333333333334,JavaScript
11ye7c0,jd8ir2b,"I think to be abundantly clear, 90% of the time I will use the word ""interpreter"" to describe what's running JavaScript (if forced to choose one word or the other), not just Python.",-0.10833333333333334,Python
11ye7c0,jd8ir2b,"It's really a whole specific runtime/implementation for the JavaScript virtual machine; on a high level, it really feels more like an interpreter that uses compiled fragments, which I would say seems the same for most of the runtime compilers that you're describing.",0.22285714285714286,JavaScript
11ye7c0,jd8kjol,Python being run through CPython will never touch actual C since that all got erased when CPython was AOT compiled.,0.0,Python
11ye7c0,jd8kjol,Python being run through CPython will never touch actual C since that all got erased when CPython was AOT compiled.,0.0,C
11ye7c0,jd8kjol,It's hard to even argue that it gets translated to operations previously represented in C because it doesn't really.,-0.08611111111111112,C
11ye7c0,jd8recj,And each bytecode is executed by some C code which has already been compiled ahead of time (perhaps years previously) to machine code.,-0.16666666666666666,C
11ye7c0,jd8recj,There is no C nor machine code which has been specifically created for the program you wrote 10 seconds ago and are executing now.,0.0,C
11ye7c0,jd8recj,JIT products like PyPy are different: they may well generate dedicated machine code (C source is very unlikely) for the program you are running now.,-0.325,C
11yayy5,jd6xjah,"CS50  Structure and Interpretation of Computer Programs  Concepts, Techniques, and Models of Computer Programming  Haskell Programming from First Principles",0.25,Haskell
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Go
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,R
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,C
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Java
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Python
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Perl
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Haskell
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Erlang
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,Ruby
11yayy5,jd94tmi,Probably hands down the best was [Why's \(Poignant\) Guide to Ruby](https://poignant.guide/).,0.4222222222222222,Ruby
11yayy5,jd94tmi,"Beyond the quirky popular appeal, it was written in a smart way and played to the strengths of Ruby.",0.2714285714285714,Ruby
11yayy5,jdbidxl,"The Rust community has put a ton of effort into onboarding/language adoption resources and documentation— the book, the Rustlings course and “Rust by Example” are all quite good: https://www.rust-lang.org/learn",0.7,Rust
11yayy5,jd7zgw9,Elixir has a really clear walk through of the language prominently displayed on their site.,0.3,Elixir
11yayy5,jdalin2,The Rust book,0.0,Rust
11yayy5,jd908t7,Learn You A Haskell,0.0,Haskell
11yayy5,jd8qngh,K&R demystified the whole concept of programming for me.,0.2,R
11xppvw,jd523i8,"I had coded my regular expression programming language in Go, so I compiled it to wasm and made an npm package for it.",0.0,Go
11xppvw,jd523i8,"Rust, C++, and I think js and typescript can compile to wasm.",0.0,Rust
11xppvw,jd523i8,"Rust, C++, and I think js and typescript can compile to wasm.",0.0,C++
11xn1gp,,"To me, the profusion of programming language choices today is a symptom of the decrepit state of C and of C++.",0.0,C
11xn1gp,,"To me, the profusion of programming language choices today is a symptom of the decrepit state of C and of C++.",0.0,C++
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,Go
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,Rust
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,C
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,C++
11xn1gp,,"It's not like C or C++ projects will dissappear completely, so they might as well benefit from enriched standards.",0.1,C
11xn1gp,,"It's not like C or C++ projects will dissappear completely, so they might as well benefit from enriched standards.",0.1,C++
11xn1gp,,Both C and C++ are steadily modernizing.,0.16666666666666666,C
11xn1gp,,Both C and C++ are steadily modernizing.,0.16666666666666666,C++
11xn1gp,,"I'd like to see C do showcased on stage, what its preprocessor has been doing behind the curtains all these years.",-0.4,C
11xn1gp,jd56kkt,Unpopular opinion here but... Leave C and C++ alone.,0.0,C
11xn1gp,jd56kkt,Unpopular opinion here but... Leave C and C++ alone.,0.0,C++
11xn1gp,jd56kkt,Go and Rust for example have objectively excellent tooling regardless of what people think of those languages.,1.0,Go
11xn1gp,jd56kkt,Go and Rust for example have objectively excellent tooling regardless of what people think of those languages.,1.0,Rust
11xn1gp,jdbso9m,"I agree with the headline to 50%, namely for C++.",0.0,C++
11xn1gp,jdbso9m,In my opinion C is really stable and mature.,0.15000000000000002,C
11xn1gp,jdbso9m,What is really missing in C?,-0.2,C
11xn1gp,jdbso9m,But for C++ I totally agree.,0.0,C++
11xn1gp,jdbso9m,"While this can be great for a lot of slow updating companies to mix various libraries compiled with different C++ standards, it really blocks the language.",0.13999999999999999,C++
11xn1gp,jdbso9m,Then the user can choose: Mix use of C++ standards or use the newest only but without all the problems which are there because of the frozen ABI.,0.0,C++
11xn1gp,jd7p7x0,What about improving C as an IR with features like tail calls and ABIs that pass structs in registers?,0.0,C
11xn1gp,jdn33cs,I couldn't care less of C or C++.,-0.16666666666666666,C
11xn1gp,jdn33cs,I couldn't care less of C or C++.,-0.16666666666666666,C++
11xn1gp,jdq63jy,C is stable and IMO fine as it is.,0.4166666666666667,C
11xn1gp,jdq63jy,"C++ is already overfeatured, yet lacking lots of essential things, with no plausible timeframe to cover them.",-0.125,C++
11xn1gp,jd6s10r,"I don't care for C++ but please don't change C. Stability is one of its main pillars, and I would NOT want to see any major new features in it.",0.12184343434343432,C++
11xn1gp,jd6s10r,"The world is running on C, after all.",0.0,C
11xn1gp,jd6s10r,"Stability is in fact the reason I use C despite hating it, and am not using Zig despite loving it.",0.6,C
11xn1gp,jdgvmhu,There was an effort in that direction called [C--](https://en.wikipedia.org/wiki/C--).,0.0,C
11xn1gp,jdgvmhu,"It seems ghc uses a fork of C-- called [cmm](https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/cmm), for it's IR.",0.0,C
11xn1gp,jd7be5e,"Some of the ""stable"" features of C include enforced undefined or implementation-defined behavior.",0.0,C
11xn1gp,jd7be5e,"If the ANSI C committee simply mandated that all integer types must be 2s complement and wrap around with predictable semantics (i.e., the ones supported by x86, PowerPC, Alpha, Arm, MIPS, SPARC, 68K, and anything else that isn't braindead) would that ruin its stability?",-0.1,C
11xn1gp,jd7be5e,"If the ANSI C committee augmented the varags functionality to be able to tell when you have consumed past the end of a ... argument list, would that ruin its stability?",0.125,C
11xn1gp,jd7be5e,"If the ANSI C committee mandated a function to let you multiply two of the largest integers (signed or unsigned) supported by the compiler to yield a double output result (which literally every CPU architected from the 1990s onward supports, and is otherwise emulatable) would that ruin its stability?",0.0,C
11xn1gp,jd7be5e,If the ANSI C committee simply removed strtok() and replaced it with GCC's strtok_r() would that ruin its stability?,0.0,C
11xn1gp,jd7be5e,"On the other hand, the ANSI C committee saw fit to specify ""wchar_t"" before Unicode solidified as a standard.",0.09166666666666667,C
11xn1gp,jd7be5e,"If the ANSI C committee instead defined a unicodeunit_t type and then defined a bunch of APIs to treat and parse it as Unicode data (the Unicode Consortium already has a bunch of sample code for such things), and deprecated usage of wchar_t would that ruin its stability?",0.0,C
11xn1gp,jd42zfp,It's similar to this subreddit but people are much smarter and program only in Forth,0.06666666666666667,Forth
11xn1gp,jd7vf53,"So support for ""a function to let you multiply two of the largest integers"" is propable (but in next C that is C29).",0.0,C
11xn1gp,jd9cy5s,"First, reply in substance: C powers the browser you are using, the OS you are using, the myriad libraries like `libpng` or `zlib` that you take for granted, it powers spaceships, airplanes, cars and God know what else, and it does that without any fancy features like closures, GC or whatever strange stuff you're requesting.",0.1,C
11xn1gp,jd9cy5s,"Just look at C++ modules, haha.",0.2,C++
11xn1gp,jd9cy5s,> If the ANSI C committee mandated a function to let you multiply two of the largest integers ...  and is otherwise emulatable  You have your answer.,0.0,C
11xn1gp,jd9cy5s,"> If the ANSI C committee simply removed strtok() and replaced it with GCC's strtok_r() would that ruin its stability  Write your own `strtok`, the C committee isn't there to babysit you.",0.3,C
11xn1gp,jd9cy5s,C code doesn't need emojis of poop in all colors of the rainbow.,0.0,C
11xn1gp,jd5a3ur,Forth is life,0.0,Forth
11xn1gp,jdbuvza,>  C powers the browser you are using ...  You're arguing incumbency as a justification for its brokenness?,0.0,C
11xn1gp,jdbuvza,Are you not aware that the Rust language was literally designed so that the Firefox people could transition away from using C/C++?,-0.125,Rust
11xn1gp,jdbuvza,Who the hell wants to put in weird features like those into C?,-0.15,C
11xn1gp,jdbuvza,> > If the ANSI C committee mandated a function to let you multiply two of the largest integers ... and is otherwise emulatable  > You have your answer.,0.0,C
11xn1gp,jdbuvza,"The point is that writing the emulation code in current C takes at least 4 times as long and relies on full 2s complement semantics (which until recently, apparently was not mandated).",0.01,C
11xn1gp,jdbuvza,"The crypto community, of course, didn't bother to wait for the ANSI C committee to get its act together, they use ""GMP"" which uses assembly language to implement it.",0.0,C
11xn1gp,jdbuvza,"> > If the ANSI C committee simply removed strtok() and replaced it with GCC's strtok_r() would that ruin its stability > Write your own strtok, the C committee isn't there to babysit you.",0.3,C
11xn1gp,jdbuvza,> C code doesn't need emojis of poop in all colors of the rainbow.,0.0,C
11xn1gp,jd7jbnn,>  But what about A*B*C?,0.0,C
11xn1gp,jd7jbnn,The purpose is not to define where you end -- it's to leverage the multi-billion dollar investment by CPU vendors into the transistors on your CPU that went into supporting that feature and is currently inaccessible in ANSI C.  > The big thing about C is that it supports all sorts of devices.,0.08333333333333333,C
11xn1gp,jd7jbnn,"> I proposed once that C should be split into two languages, one for small microcontrollers, the other for ordinary processors used on desktop machines, tablets etc, and which are now predominately 64 bits.",-0.20833333333333334,C
11xn1gp,jd7jbnn,"It's called ANSI C 89 for microcontrollers, and ANSI C 99 (which I believe was finally adopted by the predominant players a few years ago -- only about 15 years late) for everything else.",-0.125,C
11xn1gp,jd7jbnn,I already have a guaranteed 8-bit byte type -- that's because market forces and simple sanity have prevailed over the embrace of vagueness from the ANSI C committee.,0.0,C
11xn1gp,jd7jbnn,"The features I am pointing out are not unavailable to me -- I roll my own, use intrinsics or inline assembly as required, and ignore the proclamations of the ANSI C committee.",0.6,C
11xn1gp,jd7jbnn,"), which the ANSI C committee should be providing, and so the language languishes.",0.0,C
11xn1gp,jd7jbnn,Just another reason to be unimpressed with the ANSI C committee.,0.0,C
11xjwwk,jd3mxj0,"The way I see it, it's at least quarternary: Strong/Weak and Static/Dynamic - you've a typo in the option ""cmputible fields"" for the features question - compile time function evaluation/code execution probably should be a feature option - I would suggest adding a feature option for ""constrained types"" like Ada's type constraints and D's invariants - I would add ""call <lang> code"" and ""be called from <lang> code"" as options, thinking about C++ and other languages with which one may wish to be interface-compatible with - should ""hybrid"" be an option for memory management, or are you happy to capture this as ""other""?",0.06250000000000001,Ada
11xjwwk,jd3mxj0,"The way I see it, it's at least quarternary: Strong/Weak and Static/Dynamic - you've a typo in the option ""cmputible fields"" for the features question - compile time function evaluation/code execution probably should be a feature option - I would suggest adding a feature option for ""constrained types"" like Ada's type constraints and D's invariants - I would add ""call <lang> code"" and ""be called from <lang> code"" as options, thinking about C++ and other languages with which one may wish to be interface-compatible with - should ""hybrid"" be an option for memory management, or are you happy to capture this as ""other""?",0.06250000000000001,D
11xjwwk,jd3mxj0,"The way I see it, it's at least quarternary: Strong/Weak and Static/Dynamic - you've a typo in the option ""cmputible fields"" for the features question - compile time function evaluation/code execution probably should be a feature option - I would suggest adding a feature option for ""constrained types"" like Ada's type constraints and D's invariants - I would add ""call <lang> code"" and ""be called from <lang> code"" as options, thinking about C++ and other languages with which one may wish to be interface-compatible with - should ""hybrid"" be an option for memory management, or are you happy to capture this as ""other""?",0.06250000000000001,C++
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,C
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,C++
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,Objective-C
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,Java
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,JavaScript
11xjwwk,jda2df0,"> what other languages beyond the ""big six""  Rust is winning with 20 entries.",0.125,Rust
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,Haskell
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,Go
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,C
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,C++
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,Rust
11xjwwk,jda2df0,"Is Objective-C really deserving its place in ""the big six?""",0.3,Objective-C
11xjwwk,jd8ekac,"Python, Erlang, and Lua all have a smattering of smaller languages targeting their respective runtimes.",0.0,Python
11xjwwk,jd8ekac,"Python, Erlang, and Lua all have a smattering of smaller languages targeting their respective runtimes.",0.0,Erlang
11xjwwk,jd8ekac,"Python, Erlang, and Lua all have a smattering of smaller languages targeting their respective runtimes.",0.0,Lua
11xjwwk,jd8ekac,PHP has a few but really only Hack is notable.,0.09999999999999999,PHP
11xjwwk,jd8ekac,"I don't know of any 3rd-party languages that target the Objective-C runtime, just Swift.",0.0,Objective-C
11xjwwk,jd8ekac,"I don't know of any 3rd-party languages that target the Objective-C runtime, just Swift.",0.0,Swift
11xjwwk,jd8ekac,Swift is notable for being the first (afaik) where the hosted language became more popular than the original language the platform was designed for.,0.445,Swift
11xjwwk,jda5lst,"sounds like Objective C probably should be replaced with Rust for this definition, good idea!",0.4375,C
11xjwwk,jda5lst,"sounds like Objective C probably should be replaced with Rust for this definition, good idea!",0.4375,Rust
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,Objective-C
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,Java
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,C
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,Go
11xjwwk,jda3vfc,"Their dialects even have features for interop with Objective-C's runtime, like RC modifiers and autorelease pools.",0.0,Objective-C
11x3k9q,jd1vs5f,"APL was originally designed to be written on a board, and coincidently could make a return for phones.",0.375,APL
11x3k9q,jd1ohfo,"You can download a keyboard to program in APL or BQN too, though you have to know all the shortcuts!",0.0,APL
11x3k9q,jd3mgqx,I had the idea of a “conventional” language (a lisp-like) but having a secondary notation roughly APL or J style that could be expanded to the first.,-0.0732142857142857,APL
11x3k9q,jd3s3g2,"J, the successor to APL",0.0,APL
11wtv7v,jd6x9yq,Professionally I use Blazor Webassembly to create SPAs using C# for both backend and frontend.,0.1,C
11wtv7v,jfj6llb,"I don’t think JavaScript is going away for a long time, WASM or no.",-0.05,JavaScript
11wtv7v,jfj6llb,"WASM is still pretty niche and I don’t really see that changing, it’s something you have to *want* to do and takes a lot of extra work whereas JavaScript has a huge amount of infrastructure and tooling.",0.21250000000000002,JavaScript
11wiqhz,jczbf7v,"_Note: Rust does not support indexes over `isize::MAX`, or pointer arithmetic with offsets over `isize::MAX`, despite using `usize`.",0.0,Rust
11wiqhz,jcy8qly,"Rust uses unsigned, machine sized integers for sizes and indexes, although it is a pretty different language.",0.125,Rust
11wiqhz,jcyl0z9,"C's implicit conversions are the devil, as it mixing unsigned and singed numbers, so anything to do away with such problems is a good idea.",0.35,C
11wiqhz,jcze2u1,in Python you often have to add `or None` to avoid edge-case bugs.,0.0,Python
11wiqhz,jczg6m9,"> Note: Rust does not support indexes over isize::MAX, or pointer arithmetic with offsets over isize::MAX, despite using usize.",0.0,Rust
11wiqhz,jczg6m9,"I can buy the point of `usize` for languages that really need to be able to have structures that cover over half of the memory space, which is pretty much only operating systems or memory managers, but it seems like that won't really work in Rust with this restriction.",0.1638888888888889,Rust
11wiqhz,jczg6m9,I wonder if Rust's definition of `usize` is to simplify the interaction with the `size_t` world.,0.0,Rust
11wiqhz,jd0k855,"Ugh, try implementing symmetric cryptography or anything that relies heavily on bitwise arithmetic in Java.",-0.2,Java
11wiqhz,jd0k855,"And then Java had to introduce a special ""unsigned right shift"" (`>>>`) operator to ignore the sign bit when faking unsigned integers this way.",0.3214285714285714,Java
11wiqhz,jd08wgn,"> Note: Rust does not support indexes over `isize::MAX`  Nitpick: this is possible, but only for array/slices of zero sized types.",0.0,Rust
11wiqhz,jcziyu6,"Right, I think Rust demonstrates that unsigned can work well for this.",0.2857142857142857,Rust
11wiqhz,jcziyu6,Rust's slice abstraction focuses on the slice as a contiguous sequence of constant-size values.,0.0,Rust
11wiqhz,jczx0a9,"Well excluding pointer arithmetic, which is a thing in unsafe rust, I think this is more a limitation of LLVM than Rust from what I’m told… So yeah like if you’re implementing your own Vec struct and you use the add method on a pointer to do pointer math, it turns internally uses the offset method, which it itself uses LLVM stuff iirc",0.3666666666666667,Rust
11wiqhz,jcztw6n,">Rust uses unsigned, machine sized integers for sizes and indexes  I wonder why modern languages are so allergic to arrays with arbitrary lower bounds?",0.05,Rust
11wiqhz,jcylj5d,"In C, isn't it mostly backwards compatibility that prevents `ssize_t` from being used everywhere?",0.5,C
11wiqhz,jd49puw,What are the cases where you need `or None` in Python?,0.0,Python
11wiqhz,jcz8uf5,"> Because of historical accident, the C++ standard also uses unsigned integers to represent the size of containers - many members of the standards body believe this to be a mistake, but it is effectively impossible to fix at this point.",-0.04166666666666666,C++
11wiqhz,jcz76a6,"Amusingly, the reason Rust only uses `usize` for indexing is type inference issues.",0.3,Rust
11wiqhz,jd145sc,"Both the [CLR](https://learn.microsoft.com/en-us/dotnet/standard/numerics) and [Mono](http://docs.go-mono.com/index.aspx?link=T%3ASystem.UInt32) have them as extensions, and they are standard in [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types).",0.0,C
11wiqhz,jd2ebpt,"This used to be true, a decade ago, but Java added library functions to support unsigned arithmetic.",0.35,Java
11wiqhz,jd12i5l,"In D, we even have `void[]` as ""array of arbitrary bytes"" being distinct from `byte[]` where `byte` is an integer type (and that distinction has relevance because ""arbitrary bytes"" include pointers to scan during GC).",0.033333333333333326,D
11wiqhz,jczvld3,">Right, I think Rust demonstrates that unsigned can work well for this.",0.0,Rust
11wiqhz,jd0aj5x,C's rules are reversed.,0.0,C
11wiqhz,jd10c8y,"When there is a syntax error after a multi-line string in Perl, the compiler tells me I may have forgot to close the string.",0.0,Perl
11wiqhz,jd10c8y,"When I do funny parentheses business in D, it tells me that ""this kind of C casts is not supported.""",0.425,D
11wiqhz,jd10c8y,"When I do funny parentheses business in D, it tells me that ""this kind of C casts is not supported.""",0.425,C
11wiqhz,jd10c8y,Did you mean Haskell's `flip`?,-0.3125,Haskell
11wiqhz,jcym7tu,"> In C, isn't it mostly backwards compatibility that prevents ssize_t from being used everywhere?",0.5,C
11wiqhz,jcym7tu,Because reurning two things is simply out of the question for most C code!,0.3125,C
11wiqhz,jd071ej,"EDIT:  After a little more digging, I think I found the motivation in the C standard draft n3047 section 6.5.6  > When an expression that has integer type is added to or subtracted from a pointer... produces an overflow, the behavior is undefined  > the expression `Q` points to the last element of the same array object ... `((Q)-(P))+1` ... has the value zero if the expression `P` points one past the last element of the array object  I'm assuming that pointer operations operate under the same restriction, so the type MUST be signed in order to avoid underflow and the ""warping"" behavior also warned by the Rust docs.",0.0078125,C
11wiqhz,jd071ej,"EDIT:  After a little more digging, I think I found the motivation in the C standard draft n3047 section 6.5.6  > When an expression that has integer type is added to or subtracted from a pointer... produces an overflow, the behavior is undefined  > the expression `Q` points to the last element of the same array object ... `((Q)-(P))+1` ... has the value zero if the expression `P` points one past the last element of the array object  I'm assuming that pointer operations operate under the same restriction, so the type MUST be signed in order to avoid underflow and the ""warping"" behavior also warned by the Rust docs.",0.0078125,Rust
11wiqhz,jd0cp4q,"If that's what you're going for - a small number of types that are maximally flexible, like Python or Javascript objects - that's fine, but it has costs in terms of the ability to express correct, mechanically provable, and efficient code.",0.08333333333333334,Python
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,Go
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,Lua
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,Python
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,C
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,Julia
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,Rust
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,D
11wiqhz,jd0jpv2,"When I want that, then I'll code in Ada (or rather, someone else can do so on my behalf).",0.0,Ada
11wiqhz,jd0jcil,Rust has `checked_sub` and `saturating_sub` to prevent that.,0.0,Rust
11wiqhz,jd1oi5a,"> Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.10714285714285715,Rust
11wiqhz,jd1oi5a,"> When I want that, then I'll code in Ada (or rather, someone else can do so on my behalf).",0.0,Ada
11wiqhz,jd2hbat,"),  C and Algol68 are over 50 years old.",0.1,C
11wiqhz,jd2hbat,"But Zig, Odin, Go, D, Nim, Julia are much more recent.",0.25,Go
11wiqhz,jd2hbat,"But Zig, Odin, Go, D, Nim, Julia are much more recent.",0.25,D
11wiqhz,jd2hbat,"But Zig, Odin, Go, D, Nim, Julia are much more recent.",0.25,Julia
11wiqhz,jd2hbat,"There is also Dart, which doesn't have a special unsigned or size type either.",0.35714285714285715,Dart
11wiqhz,jd4qgzf,"Certainly C++ has gone much too far in the direction of ""implement everything in the library"", and it is *sometimes* beneficial to prefer a simpler solution in the compiler itself.",0.1714285714285714,C++
11wiqhz,jd04s2v,"In the end the truth is that C programmers (and Futhark it seems) are the kind of people that think they will never make mistakes and so they want a language that uses the same type for both indexes and index difference, and for indexing to work exactly like in hardware(on certain CPUs), where the CPU doesn't care about the sign of the index.",0.26607142857142857,C
11whkpu,jd19iud,"In my spare time language I go a similar route with unit and intersection types, similar to TypeScript.",0.0,TypeScript
11whkpu,jcyi8t3,Haskell I try to make the binding implicit by working with declarative and referential expressions.,0.0,Haskell
11whkpu,jd4hju9,"[TypeScript](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html), [Scala](https://docs.scala-lang.org/scala3/book/types-intersection.html) and [Ceylon](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types) are languages which share that property.",0.0,TypeScript
11whkpu,jd4hju9,"[TypeScript](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html), [Scala](https://docs.scala-lang.org/scala3/book/types-intersection.html) and [Ceylon](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types) are languages which share that property.",0.0,Scala
11vnm65,jcvcjhh,The comparison of Yaksha to Python and the niche it occupies remind me very much of Nim: https://nim-lang.org/  Are Yaksha's goals distinct from Nim?,0.28,Python
11vnm65,jcv8xjo,"Looks good, also I would say that you have some work to do on how you relate to Python.",0.7,Python
11vnm65,jcv8xjo,"The more you compare your language to Python, the easier it will be for users to be confused when your language differ from Python in ways that are not obviously required by a different semantic.",0.024999999999999994,Python
11vnm65,jcv8xjo,"For example from the home page of your website I can tell that print doesn't work ""as expected"", just like import (because import foo.bar bring foo.bar into the scope in Python and bar in yaksha).",-0.1,Python
11vnm65,jcv8xjo,"You can decide you prefer it that way, but then don't talk about Python this much.",0.2,Python
11vnm65,jcu3qos,I have seen bunch of Python like languages that do this these days.,0.0,Python
11vnm65,jda1l53,And also put that burden on the language user to manage memory like C or C++ would do!,0.0,C
11vnm65,jda1l53,And also put that burden on the language user to manage memory like C or C++ would do!,0.0,C++
11vd0q9,,"For example, an array of the 1 and 2 letter abbreviations for the chemical elements usually has to be something like this:  `elements = [""H"",""He"",""Li"",""Be"",""B"",""C"",""N"",""O"",""F"",""Ne"", ....];`  If the string literals were shown in reverse video, or bold, or whatever distinct way the display supports, the quote marks would not be needed:  `elements = [`**H**`,`**He**`,`**Li**`,`**Be**`,`**B**`,`**C**`,`**N**`,`**O**`,`**F**`,`**Ne**`, ....];`  Regexes could be a lot cleaner looking.",0.12777777777777777,C
11vd0q9,,"This snippet of Perl (actually, Raku):  `/ '\\\'' /;          # matches a backslash followed by a single quote: \'`   would instead be this:  `/` **\\'** `/;          # matches a backslash followed by a single quote: \'`  Here are lots more examples, using regexes from the Camel book: [https://jsfiddle.net/twx3bqp2/](https://jsfiddle.net/twx3bqp2/)     Programming languages all stick to symbology.",-0.12755102040816327,Perl
11vd0q9,jcsxr3o,[colorForth](https://colorforth.github.io/) by Chuck Moore (the original inventor of Forth) does this.,0.375,Forth
11vd0q9,jcso03s,"If you use (optionally hidden) start/end markers (like in HTML, and like [WordPerfect's control sequences](https://de.wikipedia.org/wiki/Datei:Wordperfect_steuerzeichen.png) you end up with a more verbose equivalent of quotes.",0.16666666666666669,HTML
11vd0q9,jcuqxt3,This reminds me of Terry A. Davis' [DolDoc](https://web.archive.org/web/20220506081504/https://templeos.holyc.xyz/Wb/Doc/DolDocOverview.html#l1) format where the Holy C code can embed 3D graphics.,0.0,C
11vd0q9,jctqom7,"~~Like Erlang or Lisp where `:foo == ""foo""` (or `(== :foo ""foo"")` rather).~~  Like Opal whee `:foo == ""foo""`.",0.0,Erlang
11vd0q9,jctqom7,"~~Like Erlang or Lisp where `:foo == ""foo""` (or `(== :foo ""foo"")` rather).~~  Like Opal whee `:foo == ""foo""`.",0.0,Lisp
11vd0q9,jcu28m3,"Yes, I think the approach used in HTML is the right approach.",0.2857142857142857,HTML
11vd0q9,jcu28m3,But HTML is much too verbose.,0.2,HTML
11vd0q9,jcunqjm,"Those who complain about Python's use of ""significant space"" I say are really complaining about ASCII markup.",0.2875,Python
11vd0q9,jcunqjm,I think HTML is on the right track.,0.2857142857142857,HTML
11vd0q9,jcunqjm,"If the terminal supported an HTML like text positioning system, then utilities could use this.",0.0,HTML
11vd0q9,jcunqjm,"HTML is fundamentally hierarchical, and I think ASCII markup should be that too.",0.0,HTML
11vd0q9,jcunqjm,"HTML's parent, SGML, actually has a `</>` tag.",0.0,HTML
11vd0q9,jcunqjm,"A typeless open analogous to a blank HTML tag, `<>`, if such a thing existed, I believe won't be enough, got to have some means of adding type.",0.0,HTML
11vd0q9,jcvpxry,"OP would need their own text rendering system, but it's totally possible - ALGOL did it, LISP did it, Smalltalk did it, etc.",0.3,ALGOL
11vd0q9,jcx1f9a,"`""foo""` is a string in Lisp.",0.0,Lisp
11vd0q9,jcx1f9a,"In Common Lisp one may well write `|this is a symbol|` which is a symbol, however.",-0.3,Lisp
11vd0q9,jcx1f9a,"Erlang tells me `foo == ""foo""` is false too.",-0.4000000000000001,Erlang
11vd0q9,jcxl16w,Erlang calls them [atoms](https://www.erlang.org/doc/reference_manual/data_types.html#atom).,0.0,Erlang
11vd0q9,jcxl16w,"Clojure says you have to manually intern them (I guess) before checking with `(== :foo (keyword ""foo""))`.",0.0,Clojure
11vd0q9,jcxl16w,"Searching a bit had me find that Ruby agrees too, but not Opal.",0.0,Ruby
11vd0q9,jcvjqok,Like HTML's `<div>` element.,0.0,HTML
11vd0q9,jcxnpd4,"Clojure lets me `(== 'foo (symbol ""foo""))`.",0.0,Clojure
11vd0q9,jcxnpd4,"Ruby calls the colon-prefixed ones [symbols](https://docs.ruby-lang.org/en/master/syntax/literals_rdoc.html#label-Symbol+Literals), and JRuby says `:foo == ""foo""` is true too.",0.35,Ruby
11vd0q9,jcxqobr,"Ruby says `""foo"".class` is String; I suspect there's type punning going on in the comparison.",0.0,Ruby
11vd0q9,jcxqobr,"In Common Lisp I can opt in to a bit of type punning by `(string= 'foo ""FOO"")` (the symbol name being uppercased for historical raisins).",-0.15,Lisp
11vd0q9,jcyhpwp,Thank you for teaching me more about Lisp!,0.625,Lisp
11uhq7c,jcobtpo,The approach I took to modules is modeled after Python.,0.0,Python
11uhq7c,jcobtpo,"The approach Python takes is to have the ""GET_GLOBAL"" opcode first check the globals table, and then do some complicated second-stage lookup for a `__builtins__` entry within that globals table and then lookup things in that; by default, every module has a `__builtins__` member that points to the `builtins` module, and if there is no `__builtins__` member then the `builtins` module is used as a fallback anyway.",-0.125,Python
11uhq7c,jcop8tp,"Even with a module scheme with namespace control, that wouldn't stop `pi` being changed like this:      var pi = 3.14     pi = 100  Either on the next line, or in a function in the same module (assuming functions have read/write access to globals; in Python for example `pi` would need declaring as a global inside functions).",0.0,Python
11uhq7c,jctxb92,"In C++, there's no distinction between file modules or folder modules, only namespaces, I recommend do not do this.",0.0,C++
11uhq7c,jctxb92,"In C++, namespaces are used by modules, but a file can contain several modules at the same level.",0.0,C++
11uhq7c,jctxb92,"// windows.hpp          namespace controls.windows     {     }           // buttons.hpp          namespace controls.buttons     {     }           // grids.hpp          namespace controls.grids     {     }       Or this:      // controls.hpp          namespace controls     {       namespace windows       {         // ...       }             namespace buttons        {         // ...       }             namespace grids       {         // ...       }           } // controls       In C++, you can use a previous declared same modular namespaces for new items.",-0.010101010101010102,C++
11uhq7c,jcosij2,"Otherwise, we search through an ordered list of module directories (which is available as a `list` in a built-in system module, as `kuroko.module_paths` - this is equivalent to Python's `sys.path`) and look for `{path}/{module}/__init__.krk`, `{path}/{module}.so`, and `{path}/{module}.krk` one by one, in each directory, until we find one.",0.4,Python
11uhq7c,jcosij2,"For the `.so` case, we load the C extension module (using `dlopen`, or `LoadLibraryA` on Windows) and try to [run an exported initializer function](https://github.com/kuroko-lang/kuroko/blob/f09f62e4410addf131ebefa0970b297ca77522d7/src/vm.c#L1347) (which [is expected to return a module object itself](https://github.com/kuroko-lang/kuroko/blob/f09f62e4410addf131ebefa0970b297ca77522d7/src/vm.c#L1369)).",-0.1,C
11u6zgp,jcmonk6,"It sounds like you're talking about ""static"" in C#, which can be combined with accessibility modifiers like public/private/protected.",0.5,C
11u6zgp,jcxknmh,"Here is an example:      interface Logger {       def warning(message: String): Unit     }      interface User {       def getName(): String     }      def main() = {        def logger = new Logger {         def warning(message) = { println(message) }       }        def user1 = new User {         def getName() = { ""Alice"" }       }        def user2 = new User {         def getName() = { logger.warning(""gotten name""); ""Bob"" }       }        println(user1.getName())       println(user2.getName())      }  We create two users where one of them logs every access to its name.",0.14393939393939392,Alice
11u4dr1,jcqtwxz,"> explain more about the coroutines  AFAIK, they are very similar to generators of Python and JS.",0.25,Python
11ttpcd,jcmv3qo,The problem with Lisp.,0.0,Lisp
11ttpcd,jcm6sn7,"The biggest problem with Lisp is that it saw itself as an end goal, rather than merely an attempt.",-0.5,Lisp
11ttpcd,jcm6sn7,Other languages have taken the good parts of Lisp while abandoning the bad.,-0.04166666666666663,Lisp
11ttpcd,jclxns3,Modern FP languages are far superior to Lisp.,0.3333333333333333,Lisp
11ttpcd,jcm5aa3,I have a theory about Lisp: it's all in the name.,0.0,Lisp
11ttpcd,jcm5aa3,"Lisp is what people who consider themselves superior (or ""smug"", as one might say) use as intermediate language to communicate so that us, mere mortals, won't understand (because we get lost in the multitude of parens).",0.09999999999999998,Lisp
11ttpcd,jcnl96s,I'd also add that Common Lisp's desire to be the last and final Lisp was a terrible dead end that crippled Lisp proper for a long time.,-0.22142857142857145,Lisp
11ttpcd,jcpitkl,"Common Lisp is a multi paradigm language, not a functional one (though functional programming is one of those paradigms, along with good old imperative/structured and object oriented - especially the latter).",0.1,Lisp
11ttpcd,jcpitkl,Scheme is a lisp that's embraced functional style.,0.0,Scheme
11ttpcd,jcpitkl,(And actually predates Common Lisp) if you're looking for that kind of beast.,0.09999999999999999,Lisp
11ttpcd,jcnjg7w,"There used to be the ""search for an adequate Lisp"" to replace Common Lisp.",0.016666666666666663,Lisp
11ttpcd,jcnjg7w,My feeling is Haskell was that replacement.,0.0,Haskell
11ttpcd,jcnjg7w,"It plays the same intellectual role, Lisp used to.",0.15,Lisp
11ttpcd,jcnjg7w,While the Haskell community invented (or mainstreamed) tons of ideas the core ideas of Haskell are all from Lisp.,0.0,Haskell
11ttpcd,jcnjg7w,While the Haskell community invented (or mainstreamed) tons of ideas the core ideas of Haskell are all from Lisp.,0.0,Lisp
11ttpcd,jcnks5a,The biggest bad part of Lisp is that it is extremely difficult to optimize performance in terms of execution speed or memory usage.,-0.5999999999999999,Lisp
11ttpcd,jcnks5a,And because of the way Lisp resolves itself often quite hard to figure out what to do about it.,-0.2916666666666667,Lisp
11ttpcd,jcnks5a,In terms of performance the enormous chain of resolutions give Lisp it's conceptual power and also give Lisp the ability to run dog slow due to small changes.,-0.16875,Lisp
11ttpcd,jcnks5a,But they broke a lot of Lisp's simplicity and elegance.,0.0,Lisp
11ttpcd,jcnks5a,If more people had helped Mark out it is entirely possible that we could have had a modern Lisp which didn't have those gotchas.,0.2333333333333333,Lisp
11ttpcd,jcnks5a,Clojure of course is also a serious player.,-0.3333333333333333,Clojure
11ttpcd,jcok3mg,"Much of Haskell is his type system, which does not come from Lisp in particular.",0.18333333333333335,Haskell
11ttpcd,jcok3mg,"Much of Haskell is his type system, which does not come from Lisp in particular.",0.18333333333333335,Lisp
11ttpcd,jcnt4hm,While I love Haskell it's definitely not 100% superior and there are somethings that it just can't do or at least can't do well e.g.,0.22499999999999998,Haskell
11ttpcd,jcnt4hm,Does this mean Haskell is bad?,-0.5062499999999999,Haskell
11ttpcd,jcodwri,"https://www.cs.nott.ac.uk/~pszgmh/fold.pdf  > The fold operator has its origins in recursion theory (Kleene, 1952), while the use of fold as a central concept in a programming language dates back to the reduction operator of APL (Iverson, 1962), and later to the insertion operator of FP (Backus, 1978).",0.0,APL
11ttpcd,jcodwri,"The notions of fold, cons, lambda calculus, etc, did not come from Lisp.",0.0,Lisp
11ttpcd,jcodwri,This is not to take away the achievement in CS that Lisp represents but our understanding of computation has advanced much further than when Lisp came out.,0.2,Lisp
11ttpcd,jcodwri,The fact that type theory can be much easily expressed in Haskell makes it a superior language.,0.5666666666666667,Haskell
11ttpcd,jcorjoz,"The invention of type systems is clearly Fortran's modes to Algol's types, I'll grant that.",0.10000000000000002,Fortran
11ttpcd,jcorjoz,When we talk about the Haskell type system it needs to prevent segfault like the Algol ones and while also allowing for rich computational models.,0.375,Haskell
11ttpcd,jcorjoz,Something like Haskell's type system IMHO comes out of James Morris 1968 work at MIT on allowing for a recursion enabling type system for dynamic programming (https://dspace.mit.edu/bitstream/handle/1721.1/64850/23882173-MIT.pdf?sequence=2&isAllowed=y).,0.0,Haskell
11ttpcd,jcorjoz,Needless to say the Lisp community.,-0.5,Lisp
11ttpcd,jcorjoz,And from there (with a few more steps) Haskell.,0.15,Haskell
11ttpcd,jcorjoz,You have types in Common Lisp for objects and the interpreter does allow you to ask type related questions (describe).,-0.15,Lisp
11ttpcd,jcorjoz,It wasn't allowed for variables  because Lisp was firmly in the dynamic not static camp.,-0.15,Lisp
11ttpcd,jcorjoz,But it was optional and in more niche parts of the Lisp language.,0.5,Lisp
11ttpcd,jcorjoz,(Lisp types for Haskell programmers: http://alhassy.com/TypedLisp),0.0,Lisp
11ttpcd,jcorjoz,(Lisp types for Haskell programmers: http://alhassy.com/TypedLisp),0.0,Haskell
11ttpcd,jcn5hyz,Lisp is fast and has very high expressiveness and a good environment.,0.36933333333333335,Lisp
11ttpcd,jcn5hyz,I suppose C just took over with Unix due to better licensing than lisp machines had.,0.1875,C
11ttpcd,jcp8dma,"I meant that its type system was not from the Lisp language, I agree that its community is close to / tied to ML-style functional programming.",0.0,Lisp
11ttpcd,jcp8dma,"However, I wouldn't say that Haskell type system is invented in this kind of early contributions : even ML is now quite far away from all the subsequent features which are now essential to program with it.",0.15999999999999998,Haskell
11ttpcd,jcqtv8v,"Type Classes, in particular, were very much a Haskell innovation.",0.21333333333333332,Haskell
11ttpcd,jcqtv8v,"Also, the use of monads to allow expressing input/output in a pure functional language which I think was first pioneered in Haskell (I'm less certain of this though).",0.1279761904761905,Haskell
11ttpcd,jcnl4v1,Today it isn't just familiarity bias...  modern CPUs (and I mean the last 30 years) are designed to run C fast.,0.021875000000000006,C
11ttpcd,jcnl4v1,Odd that Python ended up owning so much of the space.,0.016666666666666677,Python
11ttpcd,jcpd2rz,My point was that even for the type system Lisp was a critical component of the chain.,0.0,Lisp
11ttpcd,jcpd2rz,Basically Haskell is really just an evolution of Lisp.,0.2,Haskell
11ttpcd,jcpd2rz,Basically Haskell is really just an evolution of Lisp.,0.2,Lisp
11ttpcd,jcrd2wy,Monads predate Haskell.,0.0,Haskell
11ttpcd,jcrd2wy,The Gopher community (one of Haskell's direct parents) did the early work before there even was a Haskell.,0.1,Haskell
11ttpcd,jcrd2wy,"I'd certainly consider Gopher to be part of the ""Haskell Community"" in a vague sense; the only reason anyone remembers anything from Gopher is because of Haskell.",-0.09523809523809523,Haskell
11ttpcd,jcrd2wy,Haskell made monads popular rather than a nice computer science concept.,0.6,Haskell
11ttpcd,jcrd2wy,The classic Num typeclass is a Haskell innovation.,0.16666666666666666,Haskell
11ttpcd,jcrd2wy,That one Haskell gets deservedly.,0.0,Haskell
11ttpcd,jcrxvft,"From my perspective, Type Classes are \*the\* big idea in Haskell.",0.0,Haskell
11ttpcd,jcrxvft,One of things I love about Rust is that Traits are so obviously influenced by them - I'm at the point now where I almost find it painful programming without something like that.,-0.06666666666666665,Rust
11ttpcd,jcs3hyf,It will feel like Haskell.,0.0,Haskell
11ttpcd,jcs3hyf,Gofer was an attempt to implement most of the early Haskell report in a way that could run on an 8mhz 8086 processor with 640k.,0.3,Haskell
11tt0jv,,Its like the Java Meta Model and the JVM in one.,0.0,Java
11tt0jv,jcm50ho,"No, jokes aside :D Actually, I had the idea when seeing a game on someone's phone, in which you had to solve puzzles with kind-of circulating visual elements.",0.15,D
11tt0jv,jcm50ho,I also really like Minecraft :D,0.6,D
11tt0jv,jcnyefr,"Ok, maybe it didn't search for it that long :D Still a fascinating game",0.35,D
11tsjq6,,"ago, there was a discussion here about using Forth as an intermediate language.",0.0,Forth
11tsjq6,,"Unfortunately, I cannot find it right now :/  So, more generally, just as C is sometimes used as an intermediate language, what are the arguments (or counter-arguments) for using Forth as an intermediate language?",0.017142857142857144,C
11tsjq6,,"Unfortunately, I cannot find it right now :/  So, more generally, just as C is sometimes used as an intermediate language, what are the arguments (or counter-arguments) for using Forth as an intermediate language?",0.017142857142857144,Forth
11tsjq6,,"Personally, I would be happy even with pointers to articles or concepts that demonstrate either a pro or con to using Forth for this purpose....but a bit of description around just posting a URL is always welcome :)  I have to say, I have made some very simple translations in terms of mapping basic language constructs (e.g.",0.35000000000000003,Forth
11tsjq6,,"The thing is that Forth can run on anything....so using it as an intermediate language would make the re-use of existing, robust, debugged code (but written in another language), very easy to re-use in all sorts of targets.",0.5633333333333334,Forth
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,C
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,Pascal
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,Java
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,Forth
11tsjq6,jckkq96,I think Forth would make a good stack vm.,0.7,Forth
11tsjq6,jclugh3,One of the guys in #ada is using forth in this way to bootstrap an Ada compiler.,0.0,Ada
11tsjq6,jcnbccv,"In the CLox section of *Crafting Interpreters*, the bytecode generated consists *mostly* of instructions that look suspiciously like Forth.",0.5,Forth
11tsjq6,jcnbccv,"However, if you're compiling from a language that isn't strictly stack-based, I think you'll find the adherence to stack-oriented programming in Forth limiting.",0.0,Forth
11tsjq6,jcnbccv,This is reflected in CLox where a minority of the instructions in the bytecode are ones that *aren't* in Forth.,0.0,Forth
11tsjq6,jcmav32,"J or APL as targets have the same robustness and simple parsing benefits, if you were starting from something like numpy or other array centered code.",-0.03125,APL
11tsjq6,jckw6qw,"This is a terrible idea; Forth is the worst [kind of stack (or other) machine](https://www.reddit.com/r/ProgrammingLanguages/comments/up206c/stack_machines_for_compilers/i8ikupw/) since it is prone to desynchronization, and even if you avoid that it requires non-constant indices to access local variables.",-0.305,Forth
11tsjq6,jco20cj,I had a crush on Forth and wanted it to be more useful.,0.4,Forth
11tsjq6,jcumei4,"As presented in, say, Starting Forth or Thinking Forth, the main features you'll miss as a translation target for any other language is a base-pointer for an activation record and a static pointer for finding lexically-enclosed activation records.",0.13541666666666666,Forth
11tsjq6,jcmkyl2,"Forth is an *idea*, like Scheme.",0.0,Forth
11tsjq6,jcmkyl2,"Forth is an *idea*, like Scheme.",0.0,Scheme
11tsjq6,jcmkyl2,it isn't a platform like Java.,0.0,Java
11tsjq6,jclm4f2,"Forth is incredibly small, you usually ""take the compiler with you"" and yes it is possible to generate binaries.",-0.16666666666666666,Forth
11tsjq6,jclm4f2,"As far as speed is concerned, Forth can generate high quality code.",0.13,Forth
11tsjq6,jclm4f2,"More recent Forth's also have libraries for GUis, opengl, etc.",0.25,Forth
11tsjq6,jclm4f2,"You don't have to bundle anything, your compiler could generate Forth and that code would be used to generate the final program in any reasonably up to date Forth compiler.",0.1,Forth
11tsjq6,jclm4f2,"As far as the stack frame comment is concerned, think of Forth like ASM.",0.1,Forth
11tsjq6,jclm4f2,"It is the same in Forth, you just push values on the stack and CALL a function.",0.0,Forth
11tsjq6,jclm4f2,"I suppose that if you were compiling from a higher level language to generate an ""equivalent"" as it would be expected in other languages, you would have to create a stack frame data structure within Forth.",0.008333333333333331,Forth
11tsjq6,jcoeh34,"Since then, ANS Forth was invented.",0.0,Forth
11tsjq6,jcomqab,(How can one not have a crush on Forth?),0.0,Forth
11tsjq6,jcon7b0,Forth can do recursive calls.,0.0,Forth
11tsjq6,jcon7b0,My comment about recursion was with regards to compiling a higher level language like C and whether the stack frame would have to be preserved exactly as it is or could even be improved.,0.25,C
11tsjq6,jcv1zm7,"I alluded to the stack frame difficulties and was wondering if there has been a way to go around it, perhaps using RECURSE too, that may have been known by more seasoned Forth programmers.",0.375,Forth
11tsjq6,jcm8795,"If you want to compile to an existing ""language"" use C or LLVM tbh.",0.0,C
11tsjq6,jcq2wj9,"There is [ANS/ISO Forth ""94""](http://www.forth.org/svfig/Win32Forth/DPANS94.txt) and the ongoing draft [Forth ""2012""](https://forth-standard.org/standard/words).",0.0,Forth
11tsjq6,jcq2wj9,"Even those are predated by [Forth 79](https://www.complang.tuwien.ac.at/forth/fth79std/FORTH-79.TXT) and [Forth 83](https://www.complang.tuwien.ac.at/forth/fth83std/FORTH83.TXT) from the Forth Standards Team, though both of those have been made practically obsolete due to hard-wired assumptions like that of the address space being less or equal to 2^16 8-bit bytes.",-0.09722222222222221,Forth
11ti9sc,jcjt14c,Compare compile errors from Java generics with C++ templates.,0.0,Java
11ti9sc,jcjt14c,Compare compile errors from Java generics with C++ templates.,0.0,C++
11ti9sc,jcjt14c,"There's a reason why Elm has neither type classes nor higher kinded types: you don't really need them for frontend code, and the error messages and tooling are amazingly pleasant to work with.",0.39444444444444443,Elm
11ti9sc,jcjzi5u,"Because of how different it is, if a language don't have the correct foundation it won't be used at all and will just become a distraction (think about how to combine 2 libraries, one uses Effects and the other Monads)   I recently talked a bit in the OpenJDK, project Amber, mailing list about enhancing Java's checked exceptions.",-0.041666666666666664,Java
11ti9sc,jcjzi5u,"Java's checked exceptions is the closest thing we have in the mainstream languages, I claimed that *specifically in Java*, having a stronger checked exceptions system (which turns out to requires to have a stronger generic system) is the better solution than Monads, specifically because it is already integrated in Java, and making the exception system easier to use and enhancing its power will actually unify more libraries rather than leaving it as is, or focusing on Monadic type system.",0.25,Java
11ti9sc,jcja9vu,"In the Haskell case, I'm under the impression that:  - Nobody has fully solved the performance hit of effects over monad transformers (but maybe Eff does now?)",0.0,Haskell
11ti9sc,jf64dgt,**Multiple resumptions and linear resources**  Could this be solved with Rust style ownership semantics?,0.0,Rust
11ti9sc,jf64dgt,"If the continuation is of type `A -> B` in Rust it would be represented as some type which implements `Fn(A) -> B`, `FnMut(A) -> B`, or `FnOnce(A) -> B`.",0.0,Rust
11ti9sc,jd13lj8,> Compare compile errors from Java generics with C++ templates.,0.0,Java
11ti9sc,jd13lj8,> Compare compile errors from Java generics with C++ templates.,0.0,C++
11ti9sc,jdhozxf,"This allows distinguishing multiple instances of the same kind of effects:  - Idris - [Labelled Effects](https://docs.idris-lang.org/en/latest/effects/state.html#labelled-effects)  - Helium - [Effect Instances](https://bitbucket.org/pl-uwr/helium/wiki/popl20/Tutorial_Instances)   Also, in my library of algebraic effects for Scala, effects are always [uniquely labelled](https://marcinzh.github.io/turbolift/advanced/labelled.html).",0.24375,Scala
11ti9sc,jck2pty,"> [..]  I claimed that specifically in Java, having a stronger checked exceptions system (which turns out to requires to have a stronger generic system) is the better solution than Monads [..]  That may well be the case for Java.",0.25,Java
11ti9sc,jck2pty,"My personal opinion about checked exceptions in Java is that the main problem is that the effect system lacks polymorphism (this may be what you mean by ""stronger generic system""), which makes effectful code anti-modular and anti-composable.",-0.036458333333333336,Java
11ti9sc,jcjp8ss,I'm not sure if these really qualify as problems with effects from a PL-design perspective since they're both so Haskell specific.,-0.016666666666666663,Haskell
11ti9sc,jd15ump,"What I mean: templates are much more abstract than Java generics, in that they are much less specific and much less constrained.",-0.029166666666666664,Java
11ti9sc,jcm3l2v,"Yeah, sometimes it seems like everyone except me (and the Elm people I guess) who's writing a functional language is doing it to prove a point I don't understand.",0.0,Elm
11ti9sc,jcmjbyn,"Totally agree about checked exceptions in Java, with the addition that there are a number of usability issues such as syntax overhead at the use site and high cost of defining new exception types.",0.0740909090909091,Java
11ti9sc,jcqp093,">  Delphi,..., FoxPro,   These are(were) legitimately powerful tools.",0.3,Delphi
11ti9sc,jclfvwl,"To get full Koka-style *extensible* effects, you need a bit more, but not much (Koka has a notion of row polymorphism), and if your type system is powerful enough, you can even express this through other features like type classes (as in Haskell).",0.15416666666666667,Haskell
11ti9sc,jclsaco,Typed delimited continuations are (as far as I'm aware) usually implemented like [ContT](https://hackage.haskell.org/package/transformers-0.6.1.0/docs/Control-Monad-Trans-Cont.html#t:ContT) in Haskell.,0.033333333333333326,Haskell
11thzs6,jcj65e9,"As far as I can see, Oil is the only path out of the 8th most used language on Github, and 6th fast growing language of 2022   :)  https://octoverse.github.com/2022/top-programming-languages  We're converging on a fast, compatible shell in pure C++!",0.25255102040816324,C++
11thzs6,jcj65e9,Garbage-collected C++ is actually kind of fun -- it makes you realize how much of the language has to do with   book-keeping of memory.,0.36666666666666664,C++
11thzs6,jcmclt6,"Can you say something about how it is largely Bash compatible and also  >Oil is a brand new shell language with Python-like expressions on typed data, Ruby-like blocks, and more.",0.28354978354978355,Bash
11thzs6,jcmclt6,That doesn't sound like Bash at all.,0.4,Bash
11thzs6,jcmclt6,Can I run Bash scripts with minimal changes?,-0.1,Bash
11tajru,jcj4au4,"In any case, Rust is decently mature now.",0.1,Rust
11tajru,jckct7g,"I don't know Rust but I do know C++, I assume the definition of ""move"" here is the same as that of _move semantics_ as used in C++..?",0.0,Rust
11tajru,jckct7g,"I don't know Rust but I do know C++, I assume the definition of ""move"" here is the same as that of _move semantics_ as used in C++..?",0.0,C++
11tajru,jckitwg,"The concept is the same, but the way it's implemented is very different  In Rust, move semantics are the default and built into the language, so if you write `let a = b;` then the value of `b` is moved into `a` and you are no longer allowed to access `b`.",0.0,Rust
11tajru,jcmjcmd,* Rust only has destructive moves.,-0.3,Rust
11tajru,jcmjcmd,"* C++ only has non-destructive moves, and allows them to be customized (but also has type traits to detect when they're not, which is often used to *emulate* destructive moves for efficiency).",-0.3,C++
11tajru,jckmqqs,"I see, so to get an actual copy, one has to explicitly invoke it, a bit like `deepCopy()` in JavaScript..?",0.0,JavaScript
11ta0eh,je0uchd,Playing with ChatGPT I find it gives awesome code for Javascript and Python programming but mostly-non-working code for languages like OCaml and terrible code for languages like MMA.,0.0,Python
11t057s,jch893k,"But (I don't know Rust well) in that case, I'd want something that integrates nicely into functional Result-type-based error handling (Try/Success/Failure), as opposed to just abruptly panic-ing, which Rust's `assert` appears to do.",0.2375,Rust
11t057s,jcj829k,"of fine-grained static types for the AST, and they have templates List<T> and C++ namespaces, so that that single assert() took up hundreds of kilobytes of data space in the executable  The solution was to change it do DCHECK(), so it only expands in debug builds, not release builds",0.14285714285714288,C++
11t057s,jchdi1e,"The closer equivalent to guards (like Swift) is `let ... else`, which is a really nice and not that well known feature.",0.6,Swift
11sz6jr,,"For example: in my new language I'm designing, I want to use public and private labels very similar to what C++ does in its declaration of classes.",0.03409090909090909,C++
11sz6jr,jcge88h,"the C++ standard) can be copyrighted, meaning that you cannot verbatim reproduce the document in part or in whole, but you can e.g.",0.1,C++
11sz6jr,jcgkm96,"The C language family contains many languages such as ISO C, C++, and Objective-C.",0.25,C
11sz6jr,jcgkm96,"The C language family contains many languages such as ISO C, C++, and Objective-C.",0.25,C++
11sz6jr,jcgkm96,"The C language family contains many languages such as ISO C, C++, and Objective-C.",0.25,Objective-C
11sz6jr,jcgkm96,"While ISO C++ provides a standard, compilers differ a bit in which features of the standard are supported, and many have non-standard language extensions (e.g.",0.16666666666666666,C++
11sz6jr,jcgkm96,GNU C++).,0.0,C++
11sz6jr,jcgkm96,"While Clang, GCC, Intel, and Microsoft probably bought a copy of the ISO C++ standard document, they didn't “license” the language in any meaningful way.",0.25,C++
11sz6jr,jcgkm96,Oracle controls Java.,0.0,Java
11sz6jr,jcgkm96,"However, all that Oracle actually owns is the trademark for the *name* “Java”, and copyright in the reference implementation.",0.0,Java
11sz6jr,jcgkm96,"But that reference implementation (OpenJDK) is now GPL-licensed, so you're perfectly allowed to modify it in any way you like (as long as you don't market your dialect as “Java”).",0.475,Java
11sz6jr,jcgkm96,"That language is now C#, and its early versions were *heavily* inspired by Java – the syntax and semantics are mostly identical, just with a different standard library and a different naming convention.",0.06666666666666667,C
11sz6jr,jcgkm96,"That language is now C#, and its early versions were *heavily* inspired by Java – the syntax and semantics are mostly identical, just with a different standard library and a different naming convention.",0.06666666666666667,Java
11sz6jr,jcgqzdm,"Oh, wait, Perl....",0.0,Perl
11sz6jr,jcgf4ia,"If however, you made a C++ clone and tried to monetize that, then yeah you'd get a call from a lawyer.",0.0,C++
11sz6jr,jch0328,"Since the holder of C++ is Danish, C++' grammar does not have a license (meaning the authors retain all copyright) and Danish law includes copyright on keywords, it's not straightforward.",-0.1875,C++
11sz6jr,jch0328,"And I don't think Bjarne or the C++ committee would be ever suing you, seeing as how such syntax is not characteristic to the language and might even be fair use.",0.24444444444444444,C++
11sz6jr,jchlak0,"Borland sued Microsoft for some copyright about Delphi syntax, decades ago.",0.0,Delphi
11sz6jr,jchlak0,Sun sued Microsoft about Microsoft J that didn't match Java syntax.,0.0,Java
11sz6jr,jcgpg9l,"(Like C# and Java, for one severe example of similarities across multiple various levels.)",0.0,C
11sz6jr,jcgpg9l,"(Like C# and Java, for one severe example of similarities across multiple various levels.)",0.0,Java
11sz6jr,jchfgyy,"Java class-style enums are patented (expires soon), which is a big part of why C# hasn't adopted them (unclear if Oracle would actually go after them, though given their history with Google I imagine MS' lawyers didn't want to chance it).",0.0,Java
11sz6jr,jchfgyy,"Java class-style enums are patented (expires soon), which is a big part of why C# hasn't adopted them (unclear if Oracle would actually go after them, though given their history with Google I imagine MS' lawyers didn't want to chance it).",0.0,C
11sz6jr,jchav0a,But so many other languages use the same keywords as C++.,0.125,C++
11sz6jr,jchav0a,"Like for my example, Java scopes accessibility of identifiers using the same keywords of public and private on an individual basis, rather than in groups following a label.",0.0,Java
11sz6jr,jchav0a,Plus in my case it wouldn't be exactly C++'s syntax.,0.25,C++
11sz6jr,jcuadtw,"As long as you don't call your language Java, C#, or Go, you'll probably be just fine.",0.18333333333333335,Java
11sz6jr,jcuadtw,"As long as you don't call your language Java, C#, or Go, you'll probably be just fine.",0.18333333333333335,C
11sz6jr,jcuadtw,"As long as you don't call your language Java, C#, or Go, you'll probably be just fine.",0.18333333333333335,Go
11sz6jr,jcuadtw,C# and Java are pretty much isomorphic and both have litigious corporations pushing them.,0.225,C
11sz6jr,jcuadtw,C# and Java are pretty much isomorphic and both have litigious corporations pushing them.,0.225,Java
11sz6jr,jcuadtw,"The harshest that got was Oracle telling MS not to say ""Java"" when describing ""Visual J++"".",0.0,Java
11sz6jr,jchctvu,"Look at the shenanigans that Oracle tried to pull on Google regarding Java, and they failed.",-0.5,Java
11sz6jr,jchctvu,> Plus in my case it wouldn't be exactly C++'s syntax.,0.25,C++
11sz6jr,jcioi52,"So, unless you're saying people copied C style features from ada lovelace and Charles Baggage, US copyright lasts that long.",-0.05,C
11sqf4f,,"(+3))(1) = 6  	# Like “it” in Kotlin 	{ f(x, y, z) } ≡ { x, y, z -> f(x, y, z) }",0.0,Kotlin
11sqf4f,jcgiyfb,"    # Like “it” in Kotlin     { f(x, y, z) } ≡ { x, y, z -> f(x, y, z) }  I'm not a fan of this at all.",0.0,Kotlin
11sqf4f,jcgiyfb,"The meaning of `{ f(x, y, z) }` depends on whether variables called `x`, `y`, or `z` are defined anywhere in the parent scope (which is not that unlikely, compared to Kotlin's `it`).",-0.5,Kotlin
11sqf4f,jcgiyfb,"If they're not, then that function type syntax is extremely misleading and confusing, especially since `A -> B -> C` and `A -> (B -> C)` presumably mean different things?.",-0.14750000000000002,C
11sqf4f,jcgiyfb,"replace(old, new) = map     {         old -> new,         any -> any     }  I guess this means the same as (in Haskell)?",0.09318181818181817,Haskell
11sqf4f,jcvkb75,"I think having special names (like kotlin's `it`, or Swift's `$0, $1, ...`) would be better than implicit parameters w/any names",0.4285714285714286,Swift
11sqf4f,jcfafin,"`x`, `y`, `z` are implicit lambda parameter names, like [`it` in Kotlin](https://kotlinlang.org/docs/lambdas.html#it-implicit-name-of-a-single-parameter).",0.0,Kotlin
11sqf4f,jcgwyjr,"The meaning of { f(x, y, z) } depends on whether variables called x, y, or z are defined anywhere in the parent scope (which is not that unlikely, compared to Kotlin's it).",-0.5,Kotlin
11sqf4f,jcgwyjr,"I love Haskell, but there are a few things about its syntax that I think are unnecessarily exotic:  1.",0.26666666666666666,Haskell
11sqf4f,jcgwyjr,"`map g $ filter f xs` goes in the opposite direction from the data flow and also conflicts with the traditional monad direction (`(>>=)` is used much more often than `(=<<)`); I also absolutely love the way method chaining looks:  ``` fibs: Sequence(Int) fibs = (0, 1)     .iterate { (a, b) -> (b, a + b) }     .map(first) ```  > If they're not, then that function type syntax is extremely misleading and confusing, especially since `A -> B -> C` and `A -> (B -> C)` presumably mean different things?",0.0011363636363636374,C
11sqf4f,jcgwyjr,I do have an alternative syntax:  > I guess this means the same as (in Haskell)?,0.25,Haskell
11sqf4f,jcj95c2,"What really is the point of putting brackets around the parameter list, unless the function can have a variable number of parameters, like C's `printf()`?",0.2,C
11sqf4f,jcfcrft,"The 6th one is the same as [`it` in Kotlin](https://kotlinlang.org/docs/lambdas.html#it-implicit-name-of-a-single-parameter), implicit lambda parameter names, but 1–3 instead of just one.",0.0,Kotlin
11sqf4f,jcfed7j,Python and list comprehension won out in the end.,0.0,Python
11sqf4f,jcfje1v,Just like in Rust and Haskell.,0.0,Rust
11sqf4f,jcfje1v,Just like in Rust and Haskell.,0.0,Haskell
11sqf4f,jcfje1v,Python and list comprehension won out in the end.,0.0,Python
11sqf4f,jcfje1v,"Python still has `map`, `filter` etc., they just don’t compose well (you have to write `map(g, filter(f, xs))` or create temporary variables) and aren’t considered pythonic (because Guido has no idea what good code is).",0.7,Python
11sqf4f,jcfje1v,"List comprehensions are the opposite of expressive code, as is Python in general.",0.2833333333333334,Python
11sqf4f,jckc4y2,> Just like in Rust and Haskell.,0.0,Rust
11sqf4f,jckc4y2,> Just like in Rust and Haskell.,0.0,Haskell
11sqf4f,jckc4y2,"Here is a non redundant one:      x = filter(x, f)     x = map(x, g)  Here is a cleaner, and actually more expressive one (unrelated to function call syntax):      x = g(y) for y in x if f(x)  > Python still has `map`, `filter` etc.",0.3666666666666667,Python
11sqf4f,jckc4y2,"Guido wanted them removed from Python 3 but ultimately they had to stay, and a lot of people nowadays want lambdas removed.",0.0,Python
11sqf4f,jckc4y2,"Know that if lambdas get removed, presumably in Python 4 alongside the GIL, if it ever happens, `map` and `filter` will go too.",0.0,Python
11sqf4f,jckc4y2,"I would say he has a pretty good idea of what good code is, but I would argue he was less wise 30 years ago when `map` and `filter` were getting added to Python 1.0.",0.43666666666666665,Python
11sqf4f,jckc4y2,It was a Lisp programmer.,0.0,Lisp
11sqf4f,jckc4y2,"Given that Lisp a severely non-Pythonic language in terms of syntax, it figures that those additions would ultimately be bad for the language.",-0.6999999999999998,Lisp
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,Python
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,Rust
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,Haskell
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,Python
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,Rust
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,Haskell
11sqf4f,jcko0gv,"I said that Python's list comprehension represents a more expressive way of representing filter and map, which seems to be the consensus.",0.65,Python
11sqf4f,jcko0gv,"I also said that imitating Rust's and Haskell's syntax is not something to be proud of given that their syntax is widely regarded as ugly, complicated or not readable.",-0.12499999999999997,Rust
11sqf4f,jcko0gv,"I also said that imitating Rust's and Haskell's syntax is not something to be proud of given that their syntax is widely regarded as ugly, complicated or not readable.",-0.12499999999999997,Haskell
11sqf4f,jcko0gv,"For these two things, those who counter the consensus are usually found within the bubble that's being criticised - in this case, these would be the FP and Rust cultist bubbles.",-0.25,Rust
11sqf4f,jckvk6a,"> I said that Python's list comprehension represents a more expressive way of representing filter and map, which seems to be the consensus.",0.65,Python
11sqf4f,jckvk6a,"Yes, among Python developers.",0.0,Python
11sqf4f,jckvk6a,More Python developers?,0.5,Python
11sqf4f,jckvk6a,"> these would be the FP and Rust cultist bubbles  Yes, exactly, because people outside those bubbles (and also the Kotlin one) don’t know a thing about expressive code.",0.35000000000000003,Rust
11sqf4f,jckvk6a,"> these would be the FP and Rust cultist bubbles  Yes, exactly, because people outside those bubbles (and also the Kotlin one) don’t know a thing about expressive code.",0.35000000000000003,Kotlin
11s1nmn,jcjdfxm,"Compose in Python with those semantics would be approximately:      def compose(f,g):         def h(*args, **kwargs):             return f(g(*args, **kwargs))         return h  The point being that the resulting function has the same signature as the rightmost argument of the *compose* operator, and all the functions to the left presumably take a single argument.",-0.11785714285714285,Python
11s1nmn,jcww1dq,"Using D' quasiquoting `mixin`:      paramCount: type -> UInt     paramCount (a -> b) = 1 + paramCount b     paramCount a = 0          unpack f =         let xs = map (\x -> ""_"" ++ toString x) 0..<(paramCount $ typeof f) in         mixin $ ""\("" ++ join "","" xs ++ "") -> f "" ++ join "" "" xs  Use:      (neg .",-0.75,D
11rvqne,jccwp03,I'm curious since both languages are based on Elm.,-0.1,Elm
11rmek1,,"\---  ETA: I forgot to say, but if one of you has already written, or knows of, a VM in Go that you think would serve the purpose, then I'm not doing this as a learning experience but to make my lang go faster --- so please point it out.",0.0,Go
11rmek1,jc9kjgq,And certainly there are multiple-dispatch libraries for Python.,0.21428571428571427,Python
11rmek1,jcdlyvf,"That said, runtime operator overloading is actually simpler than the general case due to the types usually being ""the same"", which is how Python manages to have something that works pretty well using the ""check derived and call the reversed method first if necessary"" thing.",0.021875000000000006,Python
11rmek1,jcb5rn5,I suggest to look into Julia for ideas about the quote “wacky semantics of multiple Dispatch”,0.25,Julia
11rmek1,jcai5am,"In order to answer your original question, does your VM have high level bytecode instructions like Java with objects ?",0.2675,Java
11qm30i,jc4r6j0,"In C / C++, a ""+"" and a ""="" are considered single tokens, but a ""+="" combination is also considered a single token.",-0.07142857142857142,C
11qm30i,jc4r6j0,"In C / C++, a ""+"" and a ""="" are considered single tokens, but a ""+="" combination is also considered a single token.",-0.07142857142857142,C++
11qees1,,But the interpreter itself is being written in Java.,0.0,Java
11qees1,,Simply because Java is the language I am most proficient in.,0.25,Java
11qees1,,"So while it certainly has many features similar to languages I'm familiar with (Java, Python, C), I am attempting to keep the syntax and operators used to define everything as unique and original as I can.",0.30654761904761907,Java
11qees1,,"So while it certainly has many features similar to languages I'm familiar with (Java, Python, C), I am attempting to keep the syntax and operators used to define everything as unique and original as I can.",0.30654761904761907,Python
11qees1,,"So while it certainly has many features similar to languages I'm familiar with (Java, Python, C), I am attempting to keep the syntax and operators used to define everything as unique and original as I can.",0.30654761904761907,C
11qees1,jc509h2,"* Lowering:     * to handle arbitrary function calls, you *must* either require forward declarations (like C) or else perform two passes over the input (most languages).",0.2,C
11qees1,jc509h2,"* in particular, if you support constexpr evaluation, you need a bytecode interpreter even if you're producing machine code         * but don't make the mistake C++ did and push things to the standard library when they would be simpler in the compiler in the first place.",0.13888888888888887,C++
11qees1,jc509h2,"Don't make the mistake Rust did in assuming ""incremental compilation"" will suffice.",0.0,Rust
11qees1,jc509h2,Note that Java is a weird example because its bytecode *appears* to be stack-based but the first thing it does it turn it back into something very similar to register-based.,-0.0625,Java
11qees1,jc509h2,"C# has examples for opt-in approach here; Java has been ""we're working on it"" for like a decade and it's clear they don't even understand the problem (based on some of the weird requirements in their proposals).",-0.19999999999999998,C
11qees1,jc509h2,"C# has examples for opt-in approach here; Java has been ""we're working on it"" for like a decade and it's clear they don't even understand the problem (based on some of the weird requirements in their proposals).",-0.19999999999999998,Java
11qees1,jc509h2,Do this (think about relocations) even for interpreted languages; don't copy Java's abominable ThreadLocal design.,0.0,Java
11qees1,jc4ln5l,"o Go ahead and read/implement ""Crafting Interpreters"" (which others have mentioned).",0.0,Go
11qees1,jc361xd,"In Java land, I would highly recommend ANTLRv4.",0.16,Java
11qees1,jcg2o17,I've always just depended on Java handling stuff pretty easily for me with its defaults.,0.3416666666666667,Java
11qees1,jcg8u6w,I say that and then I realize I want to basically directly copy C++'s public/private labels for type members.,0.1,C++
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,Pascal
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,Go
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,Python
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,Fortran
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,C
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,C++
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,PHP
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,Ruby
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,Python
11qees1,jc6lz7l,"Perl does this with the `use` statement, the same statement that handles module imports:      use v5.24.1;  That's probably the best, simplest implementation imaginable.",0.5,Perl
11qees1,jc6sm2i,":D  Probably im biased as I just wrote a schoolwork interpreter for a lang spec that used :=, and also I've taught programming to total non-programmers who will not immediately grasp that = is a totally different thing from equality.",0.3333333333333333,D
11qees1,jcepezz,Python's versioning is a good example of how _not_ to do things.,0.7,Python
11qees1,jc4eezp,"PHP, JS, Java, and Actionscript copied ideas just fine.",0.4166666666666667,PHP
11qees1,jc4eezp,"PHP, JS, Java, and Actionscript copied ideas just fine.",0.4166666666666667,Java
11qees1,jc76fhu,"I've stumbled on this so much with different languages, and I see people stumbling on it with JavaScript a lot.",0.1,JavaScript
11qees1,jc7o2rk,Explain why you feel C is generally bad.,-0.6999999999999998,C
11qees1,jc7o2rk,I'll offer up that C acts more like an instruction set for assembly.,0.5,C
11qees1,jc7o2rk,I could easily write something in HTML with errors and it would work for the public.,0.21666666666666667,HTML
11qees1,jc7o2rk,"C, I have to revise, debug, test, and put extra effort to make my C programs ""consumable"" to users.",0.0,C
11qees1,jc7o2rk,"With all that work, and with how use to browsers we all are, more people would probably prefer the HTML page.",0.5,HTML
11qees1,jc7o2rk,Even though I've put much more effort into the C project.,0.5,C
11q26yv,jc2fp8g,"I intend to add a pipeline operator similar to Elixir, to be used with an std::result module which will provide functions to ease writing such complex code.",-0.09999999999999999,Elixir
11q26yv,jc2fp8g,I may take inspiration on an Elixir library I wrote a while ago: https://github.com/linkdd/rustic_result,0.0,Elixir
11q26yv,jc8vvbk,"Here's old PHP code that does your IO example:      //Given:     function RegisterTemp($service, $f)     {         Services::Register($service, $f);         return new class($service) {             function __construct(private $s) {}             function __destruct()             {                 Services::Unregister($this->s);             }         };     }          Services::RegisterTemp(""Log"", function($lvl, $msg) {         switch($lvl) {         case ""debug"": /* nothing */             break;         default:             echo($msg);         }     });     //do {     Services::Log(""debug"", ""lol"");     Services::Log(""info"", ""Hello World!",0.24659090909090908,PHP
11q26yv,jc1ro5a,"Also if you want to learn more, study Koka language and their papers and also there is a great book ""The Common Lisp Condition System: Beyond Exception Handling with Control Flow Mechanisms "" that reimplements condition system step by step in CL.",0.3333333333333333,Lisp
11pxnu8,,"Over the past few days I've been working on a simple preprocessor that enables metaprogramming in languages that don't support it, such as C.  It's based on Lua and a bit hacky, as it currently transforms the code into a Lua program, and then executes it.",-0.09,Lua
11pxnu8,,"As such I might switch to a fully homebrew language and interpreter, or maybe base it on something pure and lazy such as Haskell.",-0.16714285714285715,Haskell
11pxnu8,,"For example on how to deal with the lazy-eval issue, or the (currently somewhat hairy) syntax, or how to do multi-file stuff (which isn't really supported, except by loading standard Lua modules, or running multiple files in sequence).",0.05,Lua
11pp9hu,,"But more about Barn, It's an compiled programming language to C++.",0.5,C++
11pp9hu,jbzupl1,"I took a look at the code and it looks like the compiler does a very literal line-by-line translation from your language to C++  Of course, this makes the compiler really fast, but it also means you're restricting yourself to all the limitations that come with C++, like the limited type inference, having to forward declare stuff, etc  If you first build the AST entirely and do operations on that before you start generating code, you're going to be able to move your language further away from C++",0.15408163265306124,C++
11pp9hu,jbzqbya,"Writing in Go to compile via C++ is an interesting choice, how did you make it?",0.5,Go
11pp9hu,jbzqbya,"Writing in Go to compile via C++ is an interesting choice, how did you make it?",0.5,C++
11pp9hu,jbzqbya,"(I see from your code that it *isn't* because you started with Thorsten Ball's Writing An Interpreter in Go, you've clearly taken your own path.)",0.35,Go
11pp9hu,jbzg6ga,"Take a look at [Crystal](https://crystal-lang.org/) to pick a random decent example - they start with a basic syntax example, and then have further examples to demonstrate unique features (or at least *features*).",-0.0011904761904761943,Crystal
11pp9hu,jc1keyp,The docs say it compiles to C. Where does C++ come into it?,0.0,C++
11pp9hu,jc1c1vb,When I was starting to write Barn Lang I did learning Go so i just wanted to improve my skills in it so i created a language lol,0.4,Go
11pp9hu,jc1cfnm,"Barn don't have any specifi goal i just want to create a language in a type i like a good low level one if i can even name it like that lol  Actually i didn't seen that previously, but yes in the variables i use let name: type but in the arguments like in C i use type name that's maybe not good but i like it  It wasn't negative thanks for this 🦧",0.11041666666666666,C
11pp9hu,jc1qnba,> The docs say it compiles to C. Where does C++ come into it?,0.0,C++
11pp9hu,jc1qnba,"That might have been a mistake, this reddit post and the github about both say it compiles to C++, and you'll see it's C++ if you look at any function in the std library, for example: ``` fun println(string s) {     __code__(""std::cout << s << std::endl;"")     __use__(s) } ```  > even if doing line-by-line transpilation, you don't necessarily still need forward declarations  It is true that you can add a forward declaration to the beginning of the file every time you generate code for a function to make the C++ compiler happy, but if you want to do any sort of static analysis (like type checking) on the Barn code before you generate C++, you need to know about functions that come later in the code, and you don't have this information with a single-shot compiler",0.325,C++
11pp9hu,jc1uceo,Wait where does it say about C?,0.0,C
11pp9hu,jc1uceo,Actually Barn was firstly compiled to C and then to C++,0.125,C
11pp9hu,jc1uceo,Actually Barn was firstly compiled to C and then to C++,0.125,C++
11pp9hu,jc23dxu,"From your link: [https://github.com/barn-lang/barn](https://github.com/barn-lang/barn):  ""*It's a simple programming language written in Go that is compiled to C.*""",-0.375,Go
11ozuzq,,"In Haskell, you can apply `map` to any type that implements the right type-class.",0.2857142857142857,Haskell
11ozuzq,,"In Elm there is `map` also, but you often see `List.map` to distinguish from other kinds of `map`.",-0.125,Elm
11ozuzq,,This suggests that Elm lacks a type-class system.,0.0,Elm
11ozuzq,,It also means Elm code contains more redundant references to the concrete types of data structures.,0.15,Elm
11ozuzq,,The Haskell style seems to require a more sophisticated translator.,0.5,Haskell
11ozuzq,jbw2i6b,"The system at play here are typeclasses/traits, which Haskell has and Elm lacks.",0.0,Haskell
11ozuzq,jbw2i6b,"The system at play here are typeclasses/traits, which Haskell has and Elm lacks.",0.0,Elm
11ozuzq,jbw2i6b,"Haskell also has higher-kinded types (HKTs) which are necessary for `map` to work (since it's polymorphic on the list constructor `List :: * -> *` and not just a type, e.g.",0.0,Haskell
11ozuzq,jbw2i6b,"These systems are directed by namespacing rather than types, which makes them more verbose, but also a very powerful system that leads itself to different idioms than Haskell's system.",0.2966666666666667,Haskell
11ozuzq,jbw2i6b,"There are some languages, Elm, maybe Go, which can get away with weaker systems and focus more on abstraction in other areas.",0.1875,Elm
11ozuzq,jbw2i6b,"There are some languages, Elm, maybe Go, which can get away with weaker systems and focus more on abstraction in other areas.",0.1875,Go
11ozuzq,jbwjv55,Read up on this approach in this excellent post from the Haskell world:  https://www.haskellforall.com/2012/05/scrap-your-type-classes.html?m=1,1.0,Haskell
11ozuzq,jbvovxz,"What `Elm` and similar languages are missing is Functors (ocaml style functors, not Haskell's Functor/endofunctor).",-0.1,Elm
11ozuzq,jbvovxz,"What `Elm` and similar languages are missing is Functors (ocaml style functors, not Haskell's Functor/endofunctor).",-0.1,Haskell
11ozuzq,jbwahzl,"The notion of ""parameterized modules"" sounds promising, although the phrase gives me flashbacks to using Ada in college.",0.2,Ada
11ozuzq,jbwr7z7,Perhaps I've been writing too much Python.,0.2,Python
11ozuzq,jbw27so,"I know what it is in math, but C++, Haskell, OCaml, etc.",0.0,C++
11ozuzq,jbw27so,"I know what it is in math, but C++, Haskell, OCaml, etc.",0.0,Haskell
11ozuzq,jby34g6,"Luckily, Haskell can be configured to be more like System F in that regard.",0.41666666666666663,Haskell
11ozuzq,jbw3kzn,"The Haskell and, I believe, SML meaning come from category theory.",0.0,Haskell
11ozuzq,jbw3kzn,The other meanings (like in C++ and in Prolog) still ultimately derive from the ancestor of its meaning in category theory (Carnap's usage).,-0.0625,C++
11ozuzq,jbw3kzn,The other meanings (like in C++ and in Prolog) still ultimately derive from the ancestor of its meaning in category theory (Carnap's usage).,-0.0625,Prolog
11ovkfj,,"Consider the following example declaring a sum type which should be familiar to Rust devs: ```     enum Variants<T> {         Foo(T),         Bar(MyType),         Baz     } ``` I think what I want to happen here is the following:   - The args `T` and `MyType` in `Some(T)` and `Bar(MyType)` are treated exactly the same, both stored as identifiers to user-defined types regardless of the fact that one is concrete and one is generic.",0.11071428571428572,Rust
11ovkfj,jbx4q16,"Functional with excellent pattern matching, but not as rigid as Haskell.",1.0,Haskell
11ojt84,,"The 0.10.0 Release comes with:  * Tuples and Named Tuples * Passthrough data type * fine grained Core Library configuration * extended filesystem functions * partial evaluation (experimental via low level API)  Also, the license of the TeaScript C++ Library has been changed.",0.10416666666666666,C++
11ojt84,,"**   Here is a nice overview and some highlights:   [https://tea-age.solutions/teascript/overview-and-highlights/](https://tea-age.solutions/teascript/overview-and-highlights/)  The Github repo for the TeaScript C++ Library:   [https://github.com/Florian-Thake/TeaScript-Cpp-Library](https://github.com/Florian-Thake/TeaScript-Cpp-Library)  The Download page for bundles of the Host Application (Win+Lin) and the Library with some more examples:   [https://tea-age.solutions/teascript/downloads/](https://tea-age.solutions/teascript/downloads/)  # EDIT:  Important information for readers who are not familiar with C++ Libraries, or who are wondering about the discussion / comments below.",-0.13392857142857142,C++
11ojt84,,"In C++ exists so called ""header only"" Libraries.",0.0,C++
11ojt84,jbteay4,">Also, the license of the TeaScript C++ Library has been changed.",0.0,C++
11ojt84,jbv6j87,Nice set of features and the language looks accessible (putting aside the use of C++).,0.4875,C++
11ojt84,jbx7s9i,The programmer has to do proper cleanup - same as in the hosting language (C++).,0.0,C++
11ojt84,jbx6fc2,"Well, the one thing what is difficult to understand, is, that my project is a dual used project with 2 topics:  * the C++ Library for to be used in C++ software projects.",-0.5,C++
11ojt84,jbx6fc2,* the TeaScript langauges which can be used without to program any C++ software.,0.0,C++
11ojt84,jbx6fc2,The AGPL license applies for the C++ Library.,0.0,C++
11ojt84,jbx6fc2,"That means, if you and only if you distribute new C++ software based on that Library you are bound to the license.",0.06818181818181818,C++
11ojt84,jbx6fc2,BTW: What is wrong about use C++?,-0.5,C++
11ojt84,jbx9pnc,"Yes, exactly, using the CLI (or even anything compiled with the Lib privately / undistributed) is a complete different thing as to build a new software (what ever it may do) with the C++ LIB \_and\_ distribute this new software program.",0.10378787878787878,C++
11ojt84,jbx9pnc,Program TeaScript files or execute them has nothing to do with the used License of the C++ Library.,0.0,C++
11ojt84,jbtsjmk,"C++ lets you write any code you like in header files and thanks to its lack of a usable module system, writing everything in headers makes libraries much easier to distribute.",0.2,C++
11ojt84,jbtsjmk,"If you have an issue with this approach, I'm with you, but that is a fight you will have to take out with the C++ folks.",0.0,C++
11ojt84,jbtv8s6,"Ok, are you not familiar with C++ Libraries?",0.15625,C++
11ojt84,jby2wd7,"So I guess what I'm trying to say is that unless TeaScript has really cool, advanced, and automatic C++ interoperability features, of the kind JRuby has with Java; then I'd find it weird if people are repelled by the licence.",0.21250000000000002,C++
11ojt84,jby2wd7,"So I guess what I'm trying to say is that unless TeaScript has really cool, advanced, and automatic C++ interoperability features, of the kind JRuby has with Java; then I'd find it weird if people are repelled by the licence.",0.21250000000000002,Java
11ojt84,jby2wd7,"I mean if tomorrow PHP gets under the Anti-Capitalist Software Licence, maybe 2 websites tops will have to refactor their code into a different process, and nothing else will change.",-0.15625,PHP
11ojt84,jbttqv2,"is totally free, only the C++ Library has the AGPL license.",0.2,C++
11ojt84,jbttqv2,The C++ Library is meant to be used in C++ Application to extend them dynamically during runtime with arbitrary scripting tasks.,-0.1,C++
11ojt84,jbttqv2,"So, if you program software, you can use TeaScript in C++ projects only.",0.0,C++
11ojt84,jbttqv2,"If you want programming scripts, you don't need the C++ Library at all, but just a Host App to execute the script.",0.0,C++
11ojt84,jbttqv2,The complete language with all its features is inside the C++ Library inside the repo.,0.1,C++
11ojt84,jbttqv2,Just if you want to distribute a derived software from the C++ Library you are bound to the license.,0.0,C++
11ojt84,jbtxqo9,"And, yes the C++ Library should be used by companies either in Open Source projects, or via a purchased license or not at all.",0.0,C++
11ojt84,jbtxqo9,For the language itself you don't need the C++ Lib.,0.0,C++
11ojt84,jbtyn2i,This is not unusual for embeddable C++ projects.,-0.1,C++
11ojt84,jbu1lu0,It just also uses only the C++ TeaScript Library as well.,0.0,C++
11o9mqy,,"Originally, the project started as an exercise to learn C programming for a real project, it eventually evolved into the creation of a new language in C. Initially, I had chosen the LLVM backend, but I later decided to pause development and write a backend that targets WebAssembly directly.",0.13522727272727272,C
11o9mqy,,"For heap memory allocation and management, I am looking to implement Rust's object ownership approach, which sounds more attractive, especially in real-time programming.",0.43333333333333335,Rust
11o9mqy,jbv9tm1,"Rust's model gives you memory safety with mutation by controlling aliasing, and in consequence the runtime cannot move objects around.",0.0,Rust
11o9mqy,jbxsr90,"My plan is  to use the [Component](https://github.com/WebAssembly/component-model) approach to establish linkage, allowing me to gradually replace portions of the mlang compiler written in C with ones written in mlang itself.",0.0,C
11o9mqy,jby7c71,Reminds me of someone’s high frequence trading system written in Java.,0.16,Java
11nzw0x,jbpx6qp,"This post is mostly about Rust, but I found it really interesting and gave me a new perspective on language design in general, so I thought it was worth sharing here.",0.29727272727272724,Rust
11nzw0x,jbriae8,"Personally I'm not a crustacean, but what you describe foreshadows Rust jumping the shark.",0.0,Rust
11nzw0x,jbriae8,"* If the Rust community seems slow to add a feature, and if that delay stems from a concern for the cost/benefit balance, then I think they're doing it right.",-0.007142857142857173,Rust
11nzw0x,jc1e4r6,"We have effects:      effect Exception {       def throw[A](): A     }          effect Iteration[E] {       def yield(item: E): Unit     }          effect Asynchronicity {       def await(): Unit     }   Then we have effectful functions:      def someFunction(): Unit / {Iteration[Int], Asynchronicity, Exception} = {       do yield(5);       do await();       do throw()     }  And finally we have handlers:      def intoOption[R] { program: () => R / Exception }: Option[R] =       try {         val result = program();         Some(result)       } with Exception {         def throw[A]() = None()       }      def intoList[E] { program: () => Unit / Iteration[E] }: List[E] =       try {         program();         Nil()       } with Iteration[E] {           def yield(item) = { val rest = resume(()); Cons(item, rest) }       }      type Future[R] {       Pending(poll: () => Future[R] at {});       Ready(result: R)     }      def intoFuture[R]( program: () => R / Asynchronicity  at {} ): Future[R] =       try {         val result = program();         Ready(result)       } with Asynchronicity {         def await() = Pending(fun() { resume(()) })       }  In fact this is how we usually introduce effect handlers in our talks.",-0.5416666666666666,R
11nzw0x,jbsdebo,"It's talking about a different meaning of the word, ""any of the varieties of a language that a speaker uses in a particular social context,"" and mapping that definition to programming languages, Rust in particular.",0.09166666666666666,Rust
11njprl,jbom8d0,"going to be translated as another P.L., like C, called ""transpiled"" ?",0.0,C
11njprl,jbpie6q,Python creates a namespace and assigns it to a name in the global scope of the caller.,0.0,Python
11njprl,jbpie6q,C++ separates the namespace from the container.,0.0,C++
11njprl,jbpie6q,"Make two or three namespaces, C++ don't care!",0.0,C++
11njprl,jbpie6q,"The type-oriented languages (ML, Haskell, etc.)",0.0,Haskell
11njprl,jbpie6q,"Are you an everything-is-an-object language, like Python?",0.0,Python
11njprl,jbpie6q,"Or a the-coder-is-always-in-charge like C++, or all-functions-are-global-overloads like the functionals?",0.0,C++
11njprl,jbs367h,C++ also has modules now and I think they're separate from namespaces.,0.0,C++
11njprl,jbs367h,"It's worth mentioning that C++ is also a very special case in a lot of ways since it separates header files and implementation, which complicates compilation.",0.3821428571428571,C++
11ncg8q,jbnxniq,Your transpiler's written in Python.,0.0,Python
11ncg8q,jbn9072,What if the real brainfuck was the Python we wrote along the way?,0.2,Python
11ncg8q,jbon9q8,[Source](https://github.com/thefunguys/biffle/blob/master/biffle.c) (it’s very bad C),-0.9099999999999998,C
11n2kz7,jbp76jl,"In the topic of features, generic plugin interfaces wrapping over some built-in OS commands should come in handy, so the project would not need to reimplement very common functionality (for instance using curl as a backend for network requests instead of an ad-hoc plugin written in Rust)",0.06999999999999999,Rust
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,C++
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,Go
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,Rust
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,Kotlin
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,Swift
11n2cpy,jboi8xi,"I can't say how Jot could work since I'm not the author, but in Rust you can specify how you'd like the enum values to be serialized.",0.0,Rust
11n2cpy,jboi8xi,"In Rust it would be 1 byte for the discriminant, +3 bytes for padding, then the payload.",0.0,Rust
11n2cpy,jboi8xi,Java has an implementation of sum types using inheritance so everything is heap allocated and it'll do a bunch of pointer chasing.,0.0,Java
11n2cpy,jboi8xi,"Sure, maybe it's an internal data model of a CSS color that will later be serialized as part of a chunk of HTML.",0.16666666666666666,HTML
11n2cpy,jboi8xi,"TypeScript takes it a step further, in addition to integers, it's also possible to associate string data with variants.",0.0,TypeScript
11n2cpy,jboi8xi,I believe that Rust & Swift chose this keyword to be familiar to programmers who came from C family languages.,0.375,Rust
11n2cpy,jboi8xi,I believe that Rust & Swift chose this keyword to be familiar to programmers who came from C family languages.,0.375,Swift
11n2cpy,jboi8xi,I believe that Rust & Swift chose this keyword to be familiar to programmers who came from C family languages.,0.375,C
11n2cpy,jboi8xi,"The ML family (OCaml, F#, Haskell) express this concept with clearer syntax.",0.0,Haskell
11n2cpy,jbowwk4,"In Rust it would be 1 byte for the discriminant, +3 bytes for padding, then the payload  This is the source of confusion.",0.0,Rust
11n2cpy,jbowwk4,"But then, *my* enums are those I first encountered in Pascal in the 1970s, and the ones I have in my own languages, where there *can* be associated data, but not the way it is in that `Colours` example:      enumdata colourvalues =         (red,     0xFF0000),         (green,   0x00FF00),         (blue,    0x0000FF)     end  this defines constants `red green blue` with values `1 2 3`, and a separate, corresponding array of values.",-0.03333333333333334,Pascal
11n2cpy,jbowwk4,"In the original Pascal, you cannot access the internal numerical values of `red green blue`.",0.034999999999999996,Pascal
11mpom9,,"It's written in TypeScript and works with a ""boxed"" representation of values at runtime (`type RuntimeValue = BoxedInt | BoxedString | FunctionRef | ...`), does simple runtime checks (e.g.",0.0,TypeScript
11mpom9,,Builtin functions (like `add` or `mul` for numbers) are implemented in TypeScript as well.,0.0,TypeScript
11mpom9,,"This one turns code in my language to simple JavaScript code with conditionals, function calls, etc.",0.0,JavaScript
11mpom9,,"It prepends to the output a separately-defined ""prelude"" of builtin functions ported to JavaScript.",0.0,JavaScript
11mpom9,,"For example, my interpreter is typed in the host language (TypeScript).",0.0,TypeScript
11mpom9,,"However, my JS-targeting compiler simply emits a string of JavaScript code which will throw no errors in cases where my interpreter would panic.",0.0,JavaScript
11mpom9,,"This is not a problem for the interpreter, but my JavaScript output, which contains `let identifier = ...` for each variable, crashes in these cases with `Identifier has already been declared`.",0.0,JavaScript
11mpom9,,"Using `var` in JavaScript would solve this, but it would introduce other undesired behavior.",-0.125,JavaScript
11mpom9,jbjmffy,"I work on Dart and we have a JIT VM, native code compiler, incremental JS compiler, whole-world JS compiler, in-progress WASM compiler, IDE static analyzer, and probably some other pieces I'm forgetting.",0.1875,Dart
11mpom9,jbk5oaj,">For example, my interpreter is typed in the host language (TypeScript).",0.0,TypeScript
11mpom9,jbk5oaj,">However, my JS-targeting compiler simply emits a string of JavaScript code which will throw no errors in cases where my interpreter would panic.",0.0,JavaScript
11mpom9,jbk5oaj,"This is not a problem for the interpreter, but my JavaScript output, which contains let identifier = ... for each variable, crashes in these cases with Identifier has already been declared.",0.0,JavaScript
11mpom9,jbk5oaj,"Using var in JavaScript would solve this, but it would introduce other undesired behavior.",-0.125,JavaScript
11mpom9,jbjv2vw,I had a similar problem while working on a parser that guarantees identical results for arbitrary string-embedded TypeScript syntax between the static (i.e.,0.13333333333333333,TypeScript
11mpom9,jbjv2vw,parsed via TypeScript generics) and dynamic (i.e.,0.0,TypeScript
11mpom9,jbjv2vw,parsed via standard JavaScript at runtime) results.,0.0,JavaScript
11mpom9,jbjv2vw,"if it only exists within TypeScript's type system, hehe...  What I ended up implementing was a small test framework that allowed me to make assertions about both at the same time like this:  ```ts it(""zero divisor"", () => {                 attest(() => type(""number%0"")).throwsAndHasTypeError(                     ""% operator must be followed by a non-zero integer literal (was 0)""                 )             }) ``` (the original source can be found [here](https://github.com/arktypeio/arktype/blob/9a5d3bad70aa09ee3cceb94bf247878b11fc32f5/dev/test/semantics.test.ts#L8) alongside similar tests)  I would definitely prefer using some kind of automated proof system if that is possible, but if there are cases for which it is not, you may have success extending a solution like this to validate several compilers in parallel.",0.09318181818181817,TypeScript
11mpom9,jbnnas4,"This is not a problem for the interpreter, but my JavaScript output, which contains let identifier = ... for each variable, crashes in these cases with Identifier has already been declared.",0.0,JavaScript
11mpom9,jbnnas4,"Using var in JavaScript would solve this, but it would introduce other undesired behavior.",-0.125,JavaScript
11mpom9,jbkrpds,The [CompCert](https://en.wikipedia.org/wiki/CompCert) C compiler is written and formally verified in Coq,0.0,C
11mpom9,jbk5ql1,"Python is an example of a runtime type checked language on the ""strong"" side of that spectrum, whereas JS is also runtime type checked but on the ""weak"" side.",0.029166666666666646,Python
11mpom9,jbl1m2d,RTTI in C++ and the Java equivalent demonstrate.,0.0,C++
11mpom9,jbl1m2d,RTTI in C++ and the Java equivalent demonstrate.,0.0,Java
11mpom9,jbojnxc,"Hypothetically, if I created an interpreter for C that did this, would that make it strongly typed?",0.4333333333333333,C
11mncyk,,"Types like `String` or `List(Int)` would not include this value and if you wanted a type that does, you need to explicitly allow it using a union: `String | Unit` or `String | """"` or using the `String?` sugar, similarly how you do it for objects in Typescript or modern C#.",0.1,C
11mncyk,jbjhefi,"A function with a type like, say      first<A> : List(A) -> A | Unit  is already problematic in languages like TypeScript if `A` is instantiated to a type of the form `B | Unit`, since a returned `()` value could either mean that the list is empty or that the first element is `()`.",-0.05416666666666666,TypeScript
11mncyk,jbkw28d,"Things get kind of blurred in a language like TypeScript, where `null` and `undefined` are types as well as values, but TypeScript also has a unit type for every primitive value, and the way I see it, all of those unit types are only meant to be used in conjunction with union types, overloaded functions, etc.",0.3,TypeScript
11mncyk,jbkw28d,"The TypeScript type that corresponds to `Unit`, `()`, etc.",0.0,TypeScript
11mncyk,jbkz0l1,Perl does a lot of implicit conversions of that type.,0.0,Perl
11mncyk,jbkz0l1,In general for most Perl statements there is a list context and a scaler context.,0.275,Perl
11mncyk,jblk483,"Then you have if A then B else C is just `A B C` or `A(B,C)`.",0.0,C
11mncyk,jblora9,You could very much have:  ``` ListOrEmpty a = List a | Empty ```  or:  ``` List a = NonEmptyList a | Empty ```  See [Haskell's Non-empty list](https://wiki.haskell.org/Non-empty_list).,0.02,Haskell
11mncyk,jbiyl9h,The plan was automatic narrowing (inspired by Typescript - and by null checks in C#):      stack: List(Int)?,0.0,C
11mfg44,jbil110,Answer B is probably the most sane behavior given that JavaScript represents *all* numbers as floats.,0.5,JavaScript
11mfg44,jbil110,I just wish TypeScript would allow us to annotate integers and floats to catch unexpected number coercions though.,0.1,TypeScript
11m0583,jbftu6f,"I'm quite positive that there is no such resource which is up-to-date, for example Haskell went through several phases of refining Monads and Monoids which ended up adding operators such as `(<*>)` or `(<>)` but they are nowhere on any of the pages referenced so far.",0.06545454545454546,Haskell
11m0583,jbiid9r,"Among main-stream PLs, I find only Haskell and alikes (Agda, Idris etc.)",0.0,Haskell
11m0583,jbiid9r,"C family (C++, Java, C# etc.",0.0,C
11m0583,jbiid9r,"C family (C++, Java, C# etc.",0.0,C++
11m0583,jbiid9r,"C family (C++, Java, C# etc.",0.0,Java
11m0583,jbiid9r,"), Fortran, and phenomenal ones (Python, Julia, Erlang, Go, etc.)",0.5,Fortran
11m0583,jbiid9r,"), Fortran, and phenomenal ones (Python, Julia, Erlang, Go, etc.)",0.5,Python
11m0583,jbiid9r,"), Fortran, and phenomenal ones (Python, Julia, Erlang, Go, etc.)",0.5,Julia
11m0583,jbiid9r,"), Fortran, and phenomenal ones (Python, Julia, Erlang, Go, etc.)",0.5,Erlang
11m0583,jbiid9r,"), Fortran, and phenomenal ones (Python, Julia, Erlang, Go, etc.)",0.5,Go
11m0583,jbiid9r,"Think about Python's `is not`, `not in` operator, and the users can invent their own.",0.6,Python
11m0583,jbhrrfo,And some languages like Scala allow you to define pretty much any operator you can think of in User Code.,0.225,Scala
11m0583,jbih6bi,"Huh, there are many languages but not Rust funnily enough",0.25,Rust
11lq5tn,jbebmw1,"for more OO languages then `list.toTuple()` or `.asTuple()` feel pretty natural  for functional languages, I like the way Erlang does it, because its very clear and no need to memorize anything.",0.245,Erlang
11lq5tn,jbebmw1,"Erlang has a ton of built in functions in the style of `x_to_y` for converting between the built in types, including `list_to_tuple`.",0.0,Erlang
11lq5tn,jbe2zv4,"---  `tie(xs)` : this kind of makes sense, but does deviate from what I know C++'s `std::tie` does _(`std::tie(x, y, z)` makes a tuple `(x, y, z)`)_.",0.6,C++
11lq5tn,jbf9tge,"You don't have to ""unhex"" a hexadecimal 0xFF, for example in C, it simply means the same thing: 255.",0.0,C
11lq5tn,jbf9tge,"(Speaking of C and several similar languages; I never will understand why there is a perceived need for indicating whether a literal number is a float, a double, signed or unsigned, long or short etc.",-0.01,C
11lq5tn,jbf9tge,"The only place I can think of where this is of ""true"" semantic significance is C's division, because it can mean both proper division and ""integer division with remainder"".",0.009374999999999994,C
11lq5tn,jbfbwrj,"If you have something like Rust's From/Into traits, use that because it's user-extensible.",0.0,Rust
11lq5tn,jbfpo8o,"In a language like Python, these issues don't matter, because Python is dynamically typed and all values are either 64 bits or are 64-bit pointers to data.",0.0,Python
11lq5tn,jbgba25,">I never will understand why there is a perceived need for indicating whether a literal number is a float, a double, signed or unsigned, long or short etc  When you are referring to C in particular, it's a macro assembler.",0.029166666666666664,C
11le4wn,jbcncdd,Very cool seeing the article I wrote about null safety in Dart used here.,0.45499999999999996,Dart
11le4bb,,"The closest I've seen to this is the recently released [Python 3.10 Update](https://docs.python.org/3/whatsnew/3.10.html), which matches explicit list patterns, variables, and objects using switch case.",0.0,Python
11le4bb,,"is optional 0 or 1 occurrences [_,_/2] ~= [2,1]|[6,3]         // _ is a tracked variable which must match each [1,:*,2] ~= [1,2]|[1,0,4,8,2]  // :* matches arbitrary values between  //Possible expansions illustrating the concept [_0,_1,:,_0+1,_1*2] ~= [5,2,""ignore"",6,4]  // _0 and _1 for 2 tracked variables [?=1,2,3] ~= [2,3]                         // lookbehind [[""X"",:,:],[:,""X"",:],[:,:,""X""]] ~= box     // winning tictactoe pattern ``` In the above examples, I'm using `~=` as a pattern-matching operator, similar to how Perl's `=~` operator matches regexes with strings.",0.2333333333333333,Perl
11le4bb,jbctxj7,"Rust and other languages allow to match sequences in lists, writing it `[1, .., 2]`.",-0.125,Rust
11le4bb,jbctxj7,"EDIT: I tried doing the same in Scala with an `or` function returning an anonymous object containing an `unapply` method, but the `match` expression doesn't like such parametric patterns.",0.0,Scala
11le4bb,jbctxj7,So I don't think Scala can do that.,0.0,Scala
11le4bb,jbc4fpe,"If you are not very familiar with pattern matching in languages, you might want to look at languages like OCaml, Elixir, Rust, or Haskell.",-0.14423076923076922,Elixir
11le4bb,jbc4fpe,"If you are not very familiar with pattern matching in languages, you might want to look at languages like OCaml, Elixir, Rust, or Haskell.",-0.14423076923076922,Rust
11le4bb,jbc4fpe,"If you are not very familiar with pattern matching in languages, you might want to look at languages like OCaml, Elixir, Rust, or Haskell.",-0.14423076923076922,Haskell
11le4bb,jbd2uzc,"It sounds suspiciously like you really want an array language like APL, BQN, J, and so forth.",0.2,APL
11le4bb,jbcbug0,This [Python documentation](https://peps.python.org/pep-0636/) gets close.,0.0,Python
11le4bb,jbd639q,PatternForth is a thing: http://www.bradrodriguez.com/papers/ms/   Also: https://micsymposium.org/mics_2009_proceedings/mics2009_submission_72.pdf  TIL Forth can do pattern matching too.,0.0,Forth
11l7ksq,jbcj46y,"    a::<T> #a is a variable of some type  Right, this is often written as _a_ : T (Haskell: `a :: T`).",0.2857142857142857,Haskell
11l7ksq,jbcj46y,"For example, Int : \* or Int : Type (Haskell: `Int :: Type`) where \* / Type is the kind that describes those types that describe values.",0.175,Haskell
11l7ksq,jbcj46y,"In fact, GHC Haskell does this, and moreover it ascribes different kinds to unboxed values with different constraints (integers, floats, SIMD vectors) and uses this information during code generation.",0.0,Haskell
11l7ksq,jbbu0nx,For example something like C++'s vector has this kind `Type -> Type`.,0.6,C++
11l7ksq,jbbu0nx,"Haskell famously uses typeclasses combined with higher kinded types to allow you to abstract over functors, applicatives, monads, etc.",0.375,Haskell
11l7ksq,jbdovid,Consider the Haskell code:      data Void  This is a complete definition for the `Void` type.,0.1,Haskell
11l7ksq,jbdovid,"That is, we can always ""prove"" (in the sense of Curry-Howard) *any* proposition *and* its negation in a Turing complete language with a type system along the lines of Haskell.",0.1,Haskell
11l7ksq,jbfq2cb,Sometimes Coq is used like this: Make an embedded domain specific language to generate C code (for example) and then prove certain properties of the code you generate.,0.10714285714285714,C
11kxwql,jbadiu7,"There might be some insights and/or potential issues to watch out for described in the blogs for `rustc_codegen_gcc`, it's a similar project of taking the Rust frontend and compiling to GCC IR (Rust currently compiles to LLVM IR) https://blog.antoyo.xyz/",0.0,Rust
11kxwql,jbaeuwf,"C++), then that would be a problem anyway.",0.0,C++
11kxwql,jbafyop,One thing to think about: is there a good reason you can't just target C?,0.7,C
11kxwql,jbafyop,Of course there are good reasons you might have for not targeting C!,0.875,C
11kxwql,jbahkls,"You can very easily support and test generating code using all of: libgccjit, gcc plugin, LLVM C API, LLVM C++ API, libfirm, and C source code.",0.5633333333333334,C
11kxwql,jbahkls,"You can very easily support and test generating code using all of: libgccjit, gcc plugin, LLVM C API, LLVM C++ API, libfirm, and C source code.",0.5633333333333334,C++
11kxwql,jbahkls,At *some* point you're going to have to generate C code.,0.0,C
11kxwql,jbahkls,***  MinGW and MSVC have different C++ calling conventions but they can speak C to each other just fine.,0.09722222222222222,C++
11kxwql,jbahkls,***  MinGW and MSVC have different C++ calling conventions but they can speak C to each other just fine.,0.09722222222222222,C
11kxwql,jbbu482,Using **libclang**'s C API to parse C headers for calling into the C stdlib without having to write glue for _every_ stdlib declaration (and also allowing the ability to link to anything with a C interface) seems like a really nice idea :),0.55,C
11kxwql,jba4v6l,C?,0.0,C
11kxwql,jba4v6l,C++?,0.0,C++
11kxwql,jba4v6l,Ideally one'd want something like a compiler-agnostic version of LLVM IR for the middle layer but I guess C might be the closest alternative...,0.45,C
11kxwql,jbak4a2,"The way I see it, the main advantage of targeting C as a source-to-source compiled language is, well, ease of development and also good portability, as you mentioned.",0.4333333333333333,C
11kxwql,jbak4a2,"Some concerns I have, are firstly, how much using C as an intermediary may complicate things for me if I want to structure my language in a way that's quite different to C's semantics.",0.15,C
11kxwql,jbak4a2,"It's a bit difficult for me to put it exactly into words, but I suppose what I'm basically saying is I'm concerned how much this approach may end up with me building a middle-layer which is almost like a virtual machine or interpreter...  Secondly, it feels almost a daft thing to say, but I'm a bit worried about efficiency —especially if I end up building a lot of _quality of life_ stuff in the language, whether this will be as well-optimised if written in C vs LLVM IR, which seems to have lots of extra language constructs for communicating intent and optimisation opportunities to the compiler.",-0.009999999999999998,C
11kxwql,jbak4a2,I also know C much better than LLVM IR!,0.625,C
11kxwql,jbak4a2,C is a much smaller language in comparison to it..!,0.0,C
11kxwql,jbalc10,"""_  Thanks for the reference to libgccjit btw, I've not heard of that before, it sounds like a useful tool for many things, including for instance, assisting in hacking in self-modification into C programs, for fun and learning!",0.34375,C
11kxwql,jbauksm,"I am currently leaning towards either just building a source-to-source compiler targeting C, or targeting LLVM only...",0.0,C
11kxwql,jbaaim0,C?,0.0,C
11kxwql,jbaaim0,C++?,0.0,C++
11kxwql,jbaaim0,Ideally one'd want something like a compiler-agnostic version of LLVM IR for the middle layer but I guess C might be the closest alternative...,0.45,C
11kxwql,jbaaim0,"I'd say C.  I feel more positive about C++ than many here do, but for something intermediate and machine-generated, I don't see what it adds.",0.4090909090909091,C++
11kxwql,jbaaim0,"Moreover, standard C allows you to get at least decent performance of the output code, regardless of the semantics of your input language.",-0.044444444444444446,C
11kxwql,jbaaim0,"And, if performance is critical and the C compiler doesn't do it automatically, you can always incorporate intrinsics in assembler or compiler-specific pragmas to get that last ounce of speed.",0.0,C
11kxwql,jbaaim0,"Of course, using C for your intermediate representation also makes it relatively easy to link (or even compile) with all sorts of libraries without having to worry about calling conventions, etc.",0.43333333333333335,C
11kxwql,jbaaim0,I seem to recall a couple of at least moderately successful languages (like Haskell) with initial implementations that were just translators to C that allowed them to run pretty much anywhere pretty efficiently.,0.19166666666666665,Haskell
11kxwql,jbaaim0,I seem to recall a couple of at least moderately successful languages (like Haskell) with initial implementations that were just translators to C that allowed them to run pretty much anywhere pretty efficiently.,0.19166666666666665,C
11kxwql,jbanxoc,"One big issue I have is due to the fact that the Rust intermediate representation (MIR) is more similar to LLVM IR than GIMPLE, so some stuff like unwinding was awkward to implement.",-0.045,Rust
11kxwql,jbbb49v,"That said, it would tend to think that getting a translator to C would be faster and easier and allow you to easily run your code through other compilers (like gcc or whatever Visual Studio uses) when LLVM doesn't meet your needs.",0.10277777777777779,C
11kxwql,jbbb49v,One thing I wouldn't worry too much about is your language's semantics being too different from C.  The corollary to C's requirement that you do pretty much everything by hand is that you \*can\* do pretty much everything.,0.18333333333333335,C
11kxwql,jbbb49v,"And given that the translation to C is a fixed cost (i.e., it needs to be done just once by the translator) rather than a marginal (i.e., something every coder in the language needs to do), the cost is readily amortized if your language has more than a few users.",0.15000000000000002,C
11kxwql,jbbb49v,"For example, Haskell to this day by default is transpiled to a restricted subset of C called C-- (literally, C minus minus).",-0.1,Haskell
11kxwql,jbbb49v,"For example, Haskell to this day by default is transpiled to a restricted subset of C called C-- (literally, C minus minus).",-0.1,C
11kxwql,jbbb49v,And the semantics of Haskell couldn't be any more different from those of C.,0.25,Haskell
11kxwql,jbbb49v,And the semantics of Haskell couldn't be any more different from those of C.,0.25,C
11kxwql,jbbjx16,">Some concerns I have, are firstly, how much using C as an intermediary may complicate things for me if I want to structure my language in a way that's quite different to C's semantics.",0.15,C
11kxwql,jbbjx16,I have an option to target C in my systems-language compiler.,0.0,C
11kxwql,jbbjx16,That whole-program compiler produces a single C source file representing the whole application (it doesn't even use any `#include` lines).,0.0642857142857143,C
11kxwql,jbbjx16,"The minimum C implementatation needed is about 230KB using Tiny C (180KB for the compiler, plus there is a library it uses).",0.0,C
11kxwql,jbbjx16,"I have to avoid certain features if it needs to go through C, so it cripples my language.",0.21428571428571427,C
11kxwql,jbb67af,"Compiling to C as an intermediate representation has merits, including being far more compiler agnostic, and having a human-readable intermediate format (easy debugging).",0.3444444444444444,C
11kxwql,jbac7hi,C also doesn't have abysmal compilation times like C++ does.,0.0,C
11kxwql,jbac7hi,C also doesn't have abysmal compilation times like C++ does.,0.0,C++
11kxwql,jbac7hi,"I think it'll either be LLVM or C for me, thanks for the advice..!",0.25,C
11kxwql,jbboruc,"Ah yes, I have heard of C--, I was wondering even if it might be a good idea to follow something like a subset of C were I to use it myself as an intermediate language!",0.875,C
11kxwql,jbbto5v,The best I can think of for C is wrapping things in a struct or pointer.,1.0,C
11kxwql,jbe74yl,"(I want this because I'd like to make a language that can execute arbitrary code at compile time —like C++'s `constexpr` only you can do ~~foolish~~ _wacky_ things like read files, communicate over the network, etc... at compile time too.",0.13333333333333333,C++
11kxwql,jbch395,"With a higher level source language, you wouldn't expect to use a direct C version of an expression, but generate code full of function calls, casts and temporaries, and hope the C optimiser will sort out the mess.",0.13124999999999998,C
11kxwql,jbch395,C is quite flexible.,0.0,C
11kxwql,jbch395,"Some of the problem areas are more subtle:  **char** C has 3 `char` types, of which plain `char` doesn't match anything in my language.",-0.01587301587301586,C
11kxwql,jbch395,"If I want to directly call C's `puts` from language, it is defined there with the equivalent of `u8*` type, but this causes a mismatch with `puts` in `stdio.h` which uses `char*`.",0.1,C
11kxwql,jbch395,"The solution I use is to generate my version of `puts` in generated C using `u8*`, eschewing `stdio.h`, but compilers like gcc don't like it and require `#pragma` or options to ignore.",0.0,C
11kxwql,jbch395,"**UB** Many things are UB in C which are well-defined in my language, and well defined on my known target machines.",0.5,C
11kxwql,jbch395,"While most C compilers accept it, Tiny C (my preferred compiler), requires me to specify `-dollars-in-identifiers`, which is ridiculous.",0.05555555555555556,C
11kxwql,jbch395,"I take little advantage of this (for example `switch` can be used in an expression and returns a value), but when I do, that doesn't translate into C.  **Multiple evaluation** Some constructs, such as `case s++^ when 'A' then ... when 'B' then...`, are translated to an `if-else` chain in C, which repeats the control expression `s++^` in each branch.",-0.0625,C
11kxwql,jbch395,"**Type-punning** is allowed on arbitrary r-value expressions, C only makes it easy with l-values (`(*(T*)&x)`).",0.11111111111111112,C
11kxwql,jbch395,**Inline Assembly** My systems languages have always had easy-to-use inline assembly.,0.0,Assembly
11kxwql,jbch395,"This is just not practical for a C target (and gcc's inline assembler is absolutely hopeless, and not standard).",0.1,C
11kxwql,jbch395,**Mixed sign arithmetic** C's rules are complex; mine are much simpler.,-0.033333333333333326,C
11kxwql,jbch395,My attitude to my C transpiler is that it just needs to work for some selected applications.,0.0,C
11kxwql,jbch395,"Basically, generating C looks superfically easy, but there are dozens of small and large issues.",0.13253968253968254,C
11kxwql,jbch395,"Given a choice between C and LLVM however, I'd still go with C.",0.0,C
11ks5fc,jba59xa,If you don't care about these then just use C ffi.,0.0,C
11ks5fc,jbaam4m,"That's not much of a problem for languages like JS, but as apajx mentioned Rust's constraints are much more complex to embed into another language.",0.03333333333333335,Rust
11ks5fc,jbah49k,"Haskell, C, OCaml, Java, all do widely different things with widely different RTSs and widely different typesystems.",0.0,Haskell
11ks5fc,jbah49k,"Haskell, C, OCaml, Java, all do widely different things with widely different RTSs and widely different typesystems.",0.0,C
11ks5fc,jbah49k,"Haskell, C, OCaml, Java, all do widely different things with widely different RTSs and widely different typesystems.",0.0,Java
11ks5fc,jbah49k,"You'll have to write a binary-level typesystem (as in, you check CPU and memory states and mutations), and you may want to implement an effect system too (as in, Haskell and Java code will expect things to exist in global memory, which your host language may have no clue about, but you still must have the typesystem encode it for otherwise nothing gets ever done).",0.0,Haskell
11ks5fc,jbah49k,"You'll have to write a binary-level typesystem (as in, you check CPU and memory states and mutations), and you may want to implement an effect system too (as in, Haskell and Java code will expect things to exist in global memory, which your host language may have no clue about, but you still must have the typesystem encode it for otherwise nothing gets ever done).",0.0,Java
11ks5fc,jbah49k,Look at Typed Assembly languages for prior art.,0.0,Assembly
11ks5fc,jbak46l,This is one reason why C based FFI is very popular: Because C is small adding its concepts to your language is kind of simple.,0.2825,C
11ks5fc,jbak46l,"In addition most C-FFIs cannot use C concepts, e.g.",0.5,C
11ks5fc,jbak46l,"For this reason, C++ is notoriously difficult to interact with.",-0.5,C++
11ks5fc,jbak46l,"One example here is C++ which copies most of C's features, even if they contradict its design or a straight up annoying.",-0.03333333333333336,C++
11ks5fc,jbak46l,"One example here is C++ which copies most of C's features, even if they contradict its design or a straight up annoying.",-0.03333333333333336,C
11ks5fc,jbak46l,Carbon tries to maintain a lot of compatibility with C++.,-0.1,C++
11ks5fc,jbak46l,Some other more moderate close candidates are C++ FFI in D.,0.125,C++
11ks5fc,jbak46l,Some other more moderate close candidates are C++ FFI in D.,0.125,D
11ks5fc,jbd5ya5,"You compile to JVM and you get JNI for free, and from there you can jump into the C and Fortran pools.",0.4,C
11ks5fc,jbd5ya5,"You compile to JVM and you get JNI for free, and from there you can jump into the C and Fortran pools.",0.4,Fortran
11ks5fc,jbd5ya5,"But you've mentioned security and C in the same post, so ... 'nuf said.",0.0,C
11ks5fc,jbioxml,I think C FFI is the gold standard for access to libraries and performance.,0.0,C
11ks5fc,jbioxml,"Depending on the semantics of your language,  you might be copying between structs for interoperability between your language's types and C's structs.",0.0,C
11ks5fc,jbdlqtp,I've never studied assembly (I'm most familiar with Haskell and Python).,0.4375,Haskell
11ks5fc,jbdlqtp,I've never studied assembly (I'm most familiar with Haskell and Python).,0.4375,Python
11ks5fc,jbdldk6,"What do you mean by ""because C is small adding its concepts to your language is kind of hard""?",-0.06354166666666668,C
11ks5fc,jbeux3b,CIL and Java Bytecode are what I have in mind.,0.0,Java
11ko8mc,jbav6y2,"When I compare this to the Python scripts I've had to write for work recently, seething with global variables and mutability and side-effects ...",0.0,Python
11ko8mc,jbd2ajk,"I too write Python for work, and without global variables or mutation (subject to a few idiomatic caveats).",-0.12222222222222223,Python
11k5s9o,,"Hi there, in 2020 I started to dig deep in compilers and interpreters in a practical approach and this is my recent project, it's a Hungarian notation based language written in Java.",0.0,Java
11jpxqo,jb6jvbf,"The null-""safe"" languages like Kotlin still allow unwrapping nullables with `!",0.625,Kotlin
11jpxqo,jb6jvbf,"I still don't believe having two references to the same object stored in the same heap is a crime, and won't approach Rust within a mile radius.",0.0,Rust
11jpxqo,jb7webi,"OP is arguing that mutable aliasing should be forbidden by a complex system of annotations and compile-time checks (basically, exactly Rust's system).",-0.024999999999999994,Rust
11jpxqo,jbkghgh,"The author is \*just\* on the edge of explaining separation logic, but jumps right to Rust.",0.2857142857142857,Rust
11jpxqo,jb45qib,It's why C# still has pointer arithmetic and mutable structs if you really need them.,0.2,C
11jpxqo,jb8wflq,What is the problem with Go slices?,0.0,Go
11jpxqo,jb8wflq,"I feel like the issue is with Go's concurrency model, not its slices",0.0,Go
11jpxqo,jb8qbn8,"In Rust, the aliasing equivalent of unwrapping nulls is RefCell.borrow_mut()",0.0,Rust
11jpxqo,jb7dgwj,"In my world, functional is a better match to the business environment (but we're stuck on Python anyway).",0.5,Python
11jpxqo,jb4qrlm,"Brings to mind this quote from a former Rust core dev:  ""pure functional programming is an ingenious trick to show you can code without mutation, but Rust is an even cleverer trick to show you can just have mutation.""",0.2380952380952381,Rust
11jpxqo,jbkg2yh,"Well, non-trivial without extra runtime bookkeeping like with \`RefCell\` in Rust (which is effectively a single-threaded mutex), transactional memory or the harsh restriction of only being able to use certain primitive operations and functions when an invariant is open.",0.15918367346938772,Rust
11jpxqo,jbpehb9,"It happens that the browser's implementation of DOM manipulation methods is in C++ or whatever, but the system would work similarly if the browser's layout engine was written in javascript.",0.0,C++
11jpxqo,jbpguu3,"Congratulations, this is the same approach as Rust.",0.0,Rust
11jpg6i,,"Sophie evaluates lazily, call-by-need, after the fashion of Haskell.",-0.25,Haskell
11jpg6i,jb6uypp,This is allowed in Haskell and most ML-s.,0.5,Haskell
11jpg6i,jb54kly,\+1 on that question :D Consider me interested in formal solutions to this kind of problem.,0.6166666666666667,D
11jeszx,jbhzdfr,"Assembly is like it is because it's low-level, and the point is to be a direct translation of things.",0.1,Assembly
11j73jg,jb1om5t,"I second the recommendation of koka, but I will say that Haskell also provides mechanisms for doing this.",0.0,Haskell
11j73jg,jb1om5t,"The neat thing about Haskell is that ""Contexts"" arent first-class in the language, but the language is expressive enough to implement it ad-hoc.",0.4,Haskell
11j73jg,jb1om5t,"The key thing about Haskell is that a function _must_ be monadic to do non-pure actions, so you can specify a generic monad parameter that satisfies various constraints (mtl-style) or a concrete monad with a type level list of constraints enabled (effects systems / free monads).",0.11000000000000001,Haskell
11j73jg,jb1pm60,"Common Lisp dynamic bindings does this well, if I understood the problem.",-0.15,Lisp
11j73jg,jb27dl3,"Proof of concept in Common Lisp:      (defvar *contexts* nil       ""Alist of current contexts.",-0.35000000000000003,Lisp
11j73jg,jb27dl3,"A function can be defined along with some required ""context"", that is, pairs of items of the form `(local-variable-name class-name)`, just as (from what I can see) the syntax `context(UserAccount, Logger)/this@...` you used in Kotlin.",0.0,Kotlin
11j73jg,jb27dl3,"This is easy to change, but not knowing Kotlin, I assumed it worked like this, as you only give classes name to the `with` keyword ...)  Now, you can set contexts using the `with/without` macros (each taking an arbitrary number of objects).",0.11111111111111112,Kotlin
11j73jg,jb2truh,An example of this is Rust's approach to memory management.,0.0,Rust
11j73jg,jb1udqn,The terminology is so different that it seemed easier to use Kotlin's conventions rather than tying it in to research languages,0.0,Kotlin
11j73jg,jb96wn3,"Yes, and in Haskell there has been further advancement in composing effects, I don't see Koka went that deep.",0.0,Haskell
11j73jg,jb2l2oz,Also `call/cc` + `dynamic-wind` in Scheme,0.0,Scheme
11j73jg,jbibtkh,"I know Lisp has a different relationship between 'runtime' and 'compile time' than a lot of other languages but still, changing the test snippet to:  ``` (with (*logger-1*)     (log-sum 42 13)     (complex-operations 3 4 5)     (without (*logger-1*)         (log-sum 12 3))) ```  Still prints:  `;; Hey 55;; Hey 7;; Hey 8;; Hey 9;; Counter: 4`  Before it notices anything is wrong.",-0.025,Lisp
11j73jg,jb348y0,"Scheme has dynamic bindings too, `parmeterize`.",0.0,Scheme
11j73jg,jbivzp2,"(In terms of related things being available in somewhat-mainstream languages, Scala has a [Capture Checking](https://dotty.epfl.ch/docs/reference/experimental/cc.html#) experimental extension (available in the standard implementation under a pragma) that is worth looking at, even though it does not provide a `without` construct.)",0.19999999999999998,Scala
11j56u0,,"I am thinking of offsetting by UTF-8 code points (The programming language that I am most familiar with is Go, and string indexing retrieves bytes.",0.4375,Go
11j56u0,,"String         // UTF-8 encoded Char array ```  - The length of a String will be the number of code points, not bytes (unlike Go).",0.0,Go
11j56u0,jb1eubf,Check out how Swift does it.,0.0,Swift
11j56u0,jb1j5xy,"> The length of a String will be the number of codeunits, not bytes (unlike Go).",0.0,Go
11j56u0,jb5f4wf,I'm still annoyed by the fact PHP still doesn't have native Unicode support and it requires third-party solutions like mbstring or ICU.,-0.4,PHP
11j56u0,jb3r404,"So, um, all heresy aside, I think Python has a good approach: Bytes are not text, and text is internally whatever smallest encoding gives it O(1) scalar indexing.",0.35,Python
11j56u0,jb3r404,"You can certainly make UTF-8 the default codec for I/O, but unless you're going to tag strings with their encoding (Ruby 1.9 - style) then I'd suggest you make the encoding invisible to the user.",0.21428571428571427,Ruby
11j56u0,jb4g2uo,"I'd suggest moving all the dangerous string functions to a ""parser"" module, with extra helpers like [Python's hidden re.Scanner class](https://www.reddit.com/r/ProgrammerTIL/comments/4tpt03/python_til_about_rescanner_which_is_useful_for/).",-0.25555555555555554,Python
11j56u0,jb4g2uo,"[1] File paths, URLs, unstructured logs, CSV, JSON/YAML, HTML, HTTP (cookies, headers, query strings), IP addresses, domain names, shell commands, parsing your own programming language, dates,",0.6,HTML
11j56u0,jb1ezy5,"Thanks, I will look into Swift strings.",0.2,Swift
11j56u0,jb1gxlj,"Rust strings are always UTF-8 and they support O(1) indexing with byte indices, which you can easily get by traversing the string.",0.43333333333333335,Rust
11j56u0,jb50p2j,Rust's bstr is a nice example in my eyes.,0.6,Rust
11j56u0,jb1kyck,Also why some libraries like C# ones prefer it.,0.0,C
11j56u0,jb29x1b,Swift docs has an example using Hangul just like that.,0.0,Swift
11j56u0,jbkm865,"`if s ~= /^\p{Lu}/` is *way* better than `if s.Length > 0 && Char.IsUpper(s[0])`, especially if you're in a language like Java where that looks at UTF-16 so is fundamentally wrong for anything outside the BMP.",0.0,Java
11i1coh,je9562c,""")))`, you can put Python function call between `output our string` and `.`.",0.0,Python
11htnwr,,Are there any resources available to convert a code from Basic to C++?,0.2,C++
11htnwr,jav5tse,[QB64](https://qb64.com/) compiles QBasic to either C or C++; not sure which.,-0.25,C
11htnwr,jav5tse,[QB64](https://qb64.com/) compiles QBasic to either C or C++; not sure which.,-0.25,C++
11htnwr,jav5tse,But it might not be useful for generating standalone C++ code.,0.3,C++
11htnwr,jb0i0g9,"This is more of a small tutorial than an actual tool, but it guides you through transpiling a subset dialect of Basic to C (implemented in Python).",0.0625,C
11htnwr,jb0i0g9,"This is more of a small tutorial than an actual tool, but it guides you through transpiling a subset dialect of Basic to C (implemented in Python).",0.0625,Python
11hil82,jau0zgb,"When C++ came out, we all still thought null-terminated strings were the best thing.",1.0,C++
11hil82,jau0zgb,"When Java came out, checked exceptions seemed like a great idea, and `null` seemed like an inevitable consequence of language design.",0.4,Java
11hil82,javivmd,For instance: “try to pre empt the things people will complain about and bully you into adding to the language.” Like generics in Go and Java.,0.0,Go
11hil82,javivmd,For instance: “try to pre empt the things people will complain about and bully you into adding to the language.” Like generics in Go and Java.,0.0,Java
11hil82,javivmd,"Another good one is: “stay up to date with new innovations, and don’t idolize the past so much.” Like when they presented Go and someone in the audience asked why they had decided to ignore most language design innovations from the 00’s, the 90’s, and half of the 80’s.",0.1866161616161616,Go
11hil82,jb4wqj3,Forth?,0.0,Forth
11hil82,jbhxziy,Go hide in an ivory tower and ignore what else is going on?,0.0,Go
11hil82,javkp16,"Object and Void in Java), ""terminating types"" (e.g.",0.0,Java
11hil82,javkp16,"Nothing in Kotlin), ""higher order functions"", ""algebraic data types"" (union types and product types), ""generalized ADT"" (recursive types), ""higher order types"", etc.",0.25,Kotlin
11hil82,jav42uv,I can make a pretty good argument that most of Java's problems with them (including the ecosystem issues of widespread misuse) stem from poor ergonomics.,0.26249999999999996,Java
11hil82,javb5pl,"> When C++ came out, we all still thought null-terminated strings were the best thing.",1.0,C++
11hil82,javb5pl,"Well, C++ didn't have namespaces at first, so `string`?",0.25,C++
11hil82,jausjzl,I don’t use Python but I’ve done a good amount of Haskell.,0.7,Python
11hil82,jausjzl,I don’t use Python but I’ve done a good amount of Haskell.,0.7,Haskell
11hil82,javzjy2,"As a regular Python user, this comment absolutely is a perfect example of what OP is talking about.",0.5,Python
11hil82,javjus0,"The main problem with Java's checked exceptions I would argue comes from the dissonance between it's **3** different type systems (""classes"", ""generics"" and ""effects"" (i.e.",0.08333333333333333,Java
11hil82,javjus0,Koka was designed to have a uniform type system and hence the whole language (including the effect system) is very natural and we don't feel the same pain as in Java.,0.11,Java
11hil82,javjus0,"I [implemented](https://github.com/Holo314/Coeffect) a Coeffect system into Java, and encounter a problem with the **4th** type system of Java (yes, there are 4 separate type systems in Java), the annotations type system.",0.0,Java
11hil82,jau9ft7,Rust errors are values in the language.,0.0,Rust
11hil82,jau9ft7,"I can write functions that operate on Rust error objects, and I can deal with several, or collate them, in one expression.",0.0,Rust
11hil82,jau9ft7,"And there's also the fact that Java doesn't give you a ""bail-out"" mechanism.",0.0,Java
11hil82,jau9ft7,"In Rust, if something I/O related goes wrong, I want to do one of two things: handle it immediately, or bail out of the whole program.",-0.09999999999999999,Rust
11hil82,jau9ft7,"That's `unwrap` (or `expect`), and it's a pretty common response to I/O errors in a Rust program that cannot continue in the presence of an I/O error.",-0.024999999999999994,Rust
11hil82,jau9ft7,"On the other hand, my only choices in Java are to propagate to all of my callers with `throws IOException` or to... swallow the exception.",-0.0625,Java
11hil82,jau9ft7,"Which leads to folks either (a) swallowing exceptions, or (b) writing several lines of workaround code involving `RuntimeException` for code that *should* be as short as `if (io_is_bad) { fail_fast() }`  I'm not saying Rust's approach is perfect.",0.3333333333333333,Rust
11hil82,jau9ft7,"But we're worlds ahead of where we were, and at least in my opinion Rust has some of the best error handling tools on the market today.",0.35,Rust
11hil82,javrtoh,"D, for all its many flaws, is a better C++.",0.5,D
11hil82,javrtoh,"D, for all its many flaws, is a better C++.",0.5,C++
11hil82,javrtoh,"Zig is a better C, F# is a better OCaml, Ruby is a better SmallTalk, Kotlin is a better Java, C# is a better Java, Go is a better Java; you get the idea.",0.5,C
11hil82,javrtoh,"Zig is a better C, F# is a better OCaml, Ruby is a better SmallTalk, Kotlin is a better Java, C# is a better Java, Go is a better Java; you get the idea.",0.5,Ruby
11hil82,javrtoh,"Zig is a better C, F# is a better OCaml, Ruby is a better SmallTalk, Kotlin is a better Java, C# is a better Java, Go is a better Java; you get the idea.",0.5,Kotlin
11hil82,javrtoh,"Zig is a better C, F# is a better OCaml, Ruby is a better SmallTalk, Kotlin is a better Java, C# is a better Java, Go is a better Java; you get the idea.",0.5,Java
11hil82,javrtoh,"Zig is a better C, F# is a better OCaml, Ruby is a better SmallTalk, Kotlin is a better Java, C# is a better Java, Go is a better Java; you get the idea.",0.5,Go
11hil82,javrtoh,"(Go did that _very_ wrong, but still.)",-0.65,Go
11hil82,jayry0a,"If a Haskell dev could speak, we would not understand him.",0.0,Haskell
11hil82,jav7x8r,"""And it is written that, in the days of the Invasion of the Python Monsters, the Tribe of Brace Worshippers from the Land of C, and their ancient enemies the Tribe of Parenthesis Worshippers from the Land of Lisp, finally found themselves united against a common enemy.""",-0.15,Python
11hil82,jav7x8r,"""And it is written that, in the days of the Invasion of the Python Monsters, the Tribe of Brace Worshippers from the Land of C, and their ancient enemies the Tribe of Parenthesis Worshippers from the Land of Lisp, finally found themselves united against a common enemy.""",-0.15,C
11hil82,jav7x8r,"""And it is written that, in the days of the Invasion of the Python Monsters, the Tribe of Brace Worshippers from the Land of C, and their ancient enemies the Tribe of Parenthesis Worshippers from the Land of Lisp, finally found themselves united against a common enemy.""",-0.15,Lisp
11hil82,jav1h1m,"I love Haskell, but I will say that being indentation sensitive makes it nigh impossible to write a correct syntax definition for Sublime Text.",-0.022222222222222216,Haskell
11hil82,jaw3koy,"For Haskell it might be only an annoyance because it's strict enough to fail compilation if you indent it poorly, but Python is much worse because it will happily accept wongly pasted code.",-0.08333333333333333,Haskell
11hil82,jaw3koy,"For Haskell it might be only an annoyance because it's strict enough to fail compilation if you indent it poorly, but Python is much worse because it will happily accept wongly pasted code.",-0.08333333333333333,Python
11hil82,jauwpem,"Also, there are differences between indentation semantics between Python and Haskell which makes it substantially easier in Haskell.",0.0,Python
11hil82,jauwpem,"Also, there are differences between indentation semantics between Python and Haskell which makes it substantially easier in Haskell.",0.0,Haskell
11hil82,jawded3,"The null termination is just stored to make conversion to a C string a noop, but it doesn't influence iterating, algorithms and such.",0.0,C
11hil82,jauf6zz,"Java (as with most old languages) are statement-based rather than expression-based, so it's hardly surprising that Java's checked exceptions work with statements whereas Rust's works with expressions.",0.4333333333333333,Java
11hil82,jauf6zz,"Java (as with most old languages) are statement-based rather than expression-based, so it's hardly surprising that Java's checked exceptions work with statements whereas Rust's works with expressions.",0.4333333333333333,Rust
11hil82,jauf6zz,"If you try to program in Java like you would with Rust (or vice versa), you're obviously going to get cognitive mismatches.",0.0,Java
11hil82,jauf6zz,"If you try to program in Java like you would with Rust (or vice versa), you're obviously going to get cognitive mismatches.",0.0,Rust
11hil82,jauf6zz,Rust's system is hardly great - hence the constant updates at the API level (instead of the language level) for `Option` and `Result` with each release.,0.4,Rust
11hil82,javgy6l,If this was a real issue we’d expect Python and Haskell code to regularly render incorrectly on web pages.,0.1,Python
11hil82,javgy6l,If this was a real issue we’d expect Python and Haskell code to regularly render incorrectly on web pages.,0.1,Haskell
11hil82,javgy6l,"> Also, there are differences between indentation semantics between Python and Haskell which makes it substantially easier in Haskell.",0.0,Python
11hil82,javgy6l,"> Also, there are differences between indentation semantics between Python and Haskell which makes it substantially easier in Haskell.",0.0,Haskell
11hil82,javgy6l,It also makes Guido’s opinion on the matter moot outside of Python.,0.0,Python
11hil82,jaxwue8,When did you actually need to insert unindented Python code that you couldn't just indent as a single unit?,-0.03571428571428571,Python
11hil82,javflcm,It’s one of the unfortunate shortcomings of Scheme that it didn’t take the lambda calculus more seriously in that respect.,-0.1111111111111111,Scheme
11hil82,jautesn,"Rust provides that also, so that “whole point” doesn’t require checked exceptions, just ordinary typechecking of values.",-0.024999999999999994,Rust
11hil82,jautesn,"I don’t think Rust’s system is perfect, but I think it does show that the Java-style approach leaves a lot to be desired.",1.0,Rust
11hil82,javl6y5,HTML can collapse whitespace and typesetting a PDF can replace spaces with changed text geometry.,0.0,HTML
11hil82,javmz7t,"I know this is anecdotal but you're literally asking for an anecdote: I once had a college professor send me Python code in the body of an email, which I then had to re-indent by hand.",0.0,Python
11hil82,javmz7t,"HTML, the thing most of the internet is built on, notoriously doesn't preserve whitespace.",0.5,HTML
11hil82,javmz7t,"If it had been C code the indentation also would have been lost, and I think I've manually reindented some C code as well, before I knew of formatters.",0.0,C
11hil82,jaw4bw8,"I don't use Python, but I imagine that this example would be problematic.",0.0,Python
11hil82,javg2on,"I still fail to see the advantage of opt-in mutable besides preventing accidental mutation, which Scheme achieves by convention, where all functions that mutate end in `!`.",-0.625,Scheme
11hil82,javg2on,"If I write a Rust program and then I change every `let` to `let mut`, the program will work just fine.",0.4166666666666667,Rust
11hil82,javw5z2,Java's exception mechanism meshes well with the rest of Java's features whilst Rust's iterator based (semi) monadic style meshes well with the rest of the Rust language.,0.0,Java
11hil82,javw5z2,Java's exception mechanism meshes well with the rest of Java's features whilst Rust's iterator based (semi) monadic style meshes well with the rest of the Rust language.,0.0,Rust
11hil82,javw5z2,"When it comes down to it, Rust disallows vast vast quantifies of perfectly valid code simply because said code doesn't conform to the Rust model (and it's not even mandated by safety reasons, but purely on the basis of Rust's type system).",0.17645502645502645,Rust
11hil82,javw5z2,"No amount of handwaving on that part will make it disappear, and yet people are perfectly willing to work around those in Rust.",0.25,Rust
11hil82,javw5z2,So also with the whole exception handling business in Java.,0.2,Java
11hil82,jauxl6y,"For most of its life, Java did not bother about composition at all.",0.5,Java
11hil82,jauxl6y,">  I don’t think Rust’s system is perfect, but I think it does show that the Java-style approach leaves a lot to be desired.",1.0,Rust
11hil82,jauxl6y,"Please refer back to the bit where I mentioned that the fact that the API has to be constantly updated (`ok`, `ok_or`, `map`, `map_err` et al) shows fundamental issues in the way Rust handles errors as well.",0.16666666666666666,Rust
11hil82,jauxl6y,"And speaking of composition, composition works nicely in Rust when dealing with expressions - not so much when working with side-effecting operations - the `for_each` function for instance.",0.4,Rust
11hil82,jawm3nl,"No offence, but I lost my will to make an actual response the moment I read the part where Rust is claimed to be more ergonomic than Java.",0.25,Rust
11hil82,jawm3nl,"No offence, but I lost my will to make an actual response the moment I read the part where Rust is claimed to be more ergonomic than Java.",0.25,Java
11hil82,javse99,"These features have been around for a long time, they’re not the cause of slow compilation in eg Rust.",-0.17500000000000002,Rust
11hil82,jaw7dmw,"I think it is silly to ignore the practical differences between checked exceptions, which people complain a lot about, and Rust's monadic errors, which people seem to really like.",-0.15,Rust
11hil82,jaw7dmw,> Java's exception mechanism meshes well with the rest of Java's features whilst Rust's iterator based (semi) monadic style meshes well with the rest of the Rust language.,0.0,Java
11hil82,jaw7dmw,> Java's exception mechanism meshes well with the rest of Java's features whilst Rust's iterator based (semi) monadic style meshes well with the rest of the Rust language.,0.0,Rust
11hil82,jaw7dmw,"Unchecked null pointers and implicit conversions between pointers, integers and arrays mesh very well with the rest of C's features, but that doesn't negate the damage those features have done.",0.2,C
11hil82,jaw7dmw,> and yet people are perfectly willing to work around those in Rust.,0.25,Rust
11hil82,jaw7dmw,"Rust's designers had the benefit of 50 years of communal programming experience, 30 more than Java's designers had.",0.5,Rust
11hil82,jaw7dmw,"Rust's designers had the benefit of 50 years of communal programming experience, 30 more than Java's designers had.",0.5,Java
11hil82,jaw7dmw,"I think even with just plain old match statements, its error handling is miles beyond what C, C++ or Java offer.",-0.057142857142857134,C
11hil82,jaw7dmw,"I think even with just plain old match statements, its error handling is miles beyond what C, C++ or Java offer.",-0.057142857142857134,C++
11hil82,jaw7dmw,"I think even with just plain old match statements, its error handling is miles beyond what C, C++ or Java offer.",-0.057142857142857134,Java
11hil82,jaw7dmw,"The try operator `?` introduced in Rust 1.13 is the current best of both worlds (explicit error handling with the convenience that exceptions), and they're currently working on a v2 of `std::try::Ops`.",0.3333333333333333,Rust
11hil82,jaw7dmw,"You seem to see that as a proof of its failure, but I think it shows that Rust is improving.",-0.3166666666666667,Rust
11hil82,jaw7dmw,And the fact that it *can* improve is another great part of Rust's design.,0.8,Rust
11hil82,jaw7dmw,"I would say the Rust edition system is a direct response to C++'s single biggest flaw: ""we can never fix 50 year old mistakes because backward compatibility"".",0.042857142857142864,Rust
11hil82,jaw7dmw,"I would say the Rust edition system is a direct response to C++'s single biggest flaw: ""we can never fix 50 year old mistakes because backward compatibility"".",0.042857142857142864,C++
11hil82,jaw7dmw,"And the best part is that 5 or 10 or 20 years from now, a new language will come around that will blow Rust out of the water.",0.5681818181818181,Rust
11hil82,jauzqm4,"> For most of its life, Java did not bother about composition at all.",0.5,Java
11hil82,jauzqm4,Java changed a lot too in its first couple of decades.,0.25,Java
11hil82,jauzqm4,"Hopefully at some point Rust will standardize on something like that, and then you’ll have to look a lot harder to find things to nitpick.",-0.1,Rust
11hil82,jauzqm4,> shows fundamental issues in the way Rust handles errors   What’s “fundamental” about them?,0.0,Rust
11hil82,jauzqm4,> composition works nicely in Rust when dealing with expressions - not so much when working with side-effecting operations - the for_each function for instance.,0.4,Rust
11hil82,jauzqm4,"The exact same thing is true of Haskell, which is about as functional and compositional as it gets.",0.19999999999999998,Haskell
11hil82,jawo064,"The styles of error-as-multiple-values (Go), checked exceptions (Java) and the monadic error handling (Haskell/Rust) force you to polute the code by manually bubbling up the error upwards.",0.0,Go
11hil82,jawo064,"The styles of error-as-multiple-values (Go), checked exceptions (Java) and the monadic error handling (Haskell/Rust) force you to polute the code by manually bubbling up the error upwards.",0.0,Java
11hil82,jawo064,Ocaml's much better than Haskell.,0.5,Haskell
11hil82,jawo064,Ada's much better than Rust.,0.5,Ada
11hil82,jawo064,Ada's much better than Rust.,0.5,Rust
11hil82,jaxaudg,"Markdown doesn't leave spaces and tabs intact (which already disqualifies it from um-actuallying me), nor angle brackets (inline HTML).",0.0,HTML
11hil82,jb0o58i,BTW Python came out around 1990.,0.0,Python
11hil82,jazgrjs,Java's absolute simplicity (which inevitably leads to some measure of verbosity) is precisely why it's so maintainable and powers the vast majority of software in the real world.,0.16,Java
11hil82,jazgrjs,Java changed a lot too in its first couple of decades.,0.25,Java
11hil82,jazgrjs,"Hopefully at some point Rust will standardize on something like that, and then you’ll have to look a lot harder to find things to nitpick.",-0.1,Rust
11hil82,jazgrjs,Rust is not a new language.,-0.06818181818181818,Rust
11hil82,jazgrjs,"I've been following Rust since it was around 0.3, and it's well over a decade in its making, and almost a decade since its 1.0 release.",0.0,Rust
11hil82,jazgrjs,"Something as basic as `box patterns` is *still* unstable a decade after 1.0 (leading to the inability to even allocate on the heap directly, instead of crashing, in safe Rust - nothing short of ridiculous).",0.05333333333333333,Rust
11hil82,jazgrjs,Rust is well beyond that stage already.,0.0,Rust
11hil82,jazgrjs,"This is precisely the attitude that ensures that Rust doesn't become mainstream, and never will - no other language community (barring the Zig community) can be so myopic, hypocritical, and yet seemingly unaware of it at the same time.",0.115625,Rust
11hil82,jazgrjs,Java has flexibility and safety at the expense of performance.,0.0,Java
11hil82,jazgrjs,"C++ has performance and flexibility at the expense of safety, and Rust has performance and safety at the expense of flexibility.",0.0,C++
11hil82,jazgrjs,"C++ has performance and flexibility at the expense of safety, and Rust has performance and safety at the expense of flexibility.",0.0,Rust
11hil82,jazgrjs,"For instance, Modern C++ is much safer than older versions, but still not safe enough.",0.06333333333333332,C++
11hil82,jazgrjs,"So also, Rust today (thanks to NLL et al) is much more flexible, but not enough.",0.2333333333333333,Rust
11hil82,jazgrjs,"Likewise, Java today (due to the JVM, of course) is much more performant and lightweight than before, but not in the same league as native languages.",0.125,Java
11hil82,jazgrjs,"The exact same thing is true of Haskell, which is about as functional and compositional as it gets.",0.19999999999999998,Haskell
11hil82,jazgrjs,"Yes, with the difference that Haskell, unlike Rust, is actually a pure Functional language and so doesn't have the dissonance amongst its features that leads to crippled APIs in Rust (like the `foreach` iterator function which doesn't allow any error returns within it at all - a bigger deal vis-a-vis Haskell since Rust has mutability and side-effecting functions galore).",0.10714285714285714,Haskell
11hil82,jazgrjs,"Yes, with the difference that Haskell, unlike Rust, is actually a pure Functional language and so doesn't have the dissonance amongst its features that leads to crippled APIs in Rust (like the `foreach` iterator function which doesn't allow any error returns within it at all - a bigger deal vis-a-vis Haskell since Rust has mutability and side-effecting functions galore).",0.10714285714285714,Rust
11hil82,jayw8rx,"> The styles of error-as-multiple-values (Go), checked exceptions (Java) and the monadic error handling (Haskell/Rust) force you to polute the code by manually bubbling up the error upwards.",0.0,Go
11hil82,jayw8rx,"> The styles of error-as-multiple-values (Go), checked exceptions (Java) and the monadic error handling (Haskell/Rust) force you to polute the code by manually bubbling up the error upwards.",0.0,Java
11hil82,jayw8rx,"I remember working on a Ruby codebase once that look immaculately clean - hardly any error-handling code in the codebase itself, and all of the actual error-handling being done at the interface to the outside world.",0.018750000000000003,Ruby
11hil82,jayw8rx,> Ocaml's much better than Haskell.,0.5,Haskell
11hil82,jayw8rx,Ada's much better than Rust.,0.5,Ada
11hil82,jayw8rx,Ada's much better than Rust.,0.5,Rust
11hil82,jazrj1t,Go excels at that; I can write utter garbage in terms of layout and gofmt will sort it out for me.,0.0,Go
11hil82,jazrj1t,"Even _with_ a dedicated Python IDE, I’m still indenting and un-indenting all the time because the IDE doesn’t know what scope I want to be in.",0.0,Python
11hil82,jazrj1t,"Python’s indentation rule, was (I reckon) probably inspired by some really badly indented code from the time period it was created.",-0.6999999999999998,Python
11hil82,jazfegh,"The reason why languages like C++ rely on static analysers (or dynamic languages like Erlang, which *have* to) is because of their weak type systems unlike, say, Rust.",0.041666666666666664,C++
11hil82,jazfegh,"The reason why languages like C++ rely on static analysers (or dynamic languages like Erlang, which *have* to) is because of their weak type systems unlike, say, Rust.",0.041666666666666664,Erlang
11hil82,jazfegh,"The reason why languages like C++ rely on static analysers (or dynamic languages like Erlang, which *have* to) is because of their weak type systems unlike, say, Rust.",0.041666666666666664,Rust
11hil82,jazfegh,"Just like (referring to a different comment in this thread), tying a language (Python) to an IDE just to be able to work sensibly with it (due to indentation sensitivity) is borderline madness.",0.125,Python
11hil82,jazfegh,"The Conditions system works nicely for Common Lisp, but would probably be overkill for Java, for instance.",0.15,Lisp
11hil82,jazfegh,"The Conditions system works nicely for Common Lisp, but would probably be overkill for Java, for instance.",0.15,Java
11hevox,jatq2mu,The downside is that it is going to be like COBOL: so many keywords that they are easy to forget.,0.4666666666666667,COBOL
11hevox,jazkqp9,But it just rewrites it as Python and then does `eval`.,0.0,Python
11hevox,jazkqp9,This is Python but with more steps.,0.5,Python
11hczze,,"I've been following this sub for a little over a year since I started working on [ArkType](https://github.com/arktypeio/arktype), which at the time was an experiment to determine whether a TypeScript syntax parser written using TS's own generic types could be performant.",0.103125,TypeScript
11hczze,,"At this point, I started working on an ""isomorphic"" parser that would allow definitions to be parsed and enforced identically at compile-time via TypeScript and at runtime in JavaScript using parallel static and dynamic implementations [like this](https://github.com/arktypeio/arktype#how).",0.16666666666666666,TypeScript
11hczze,,"At this point, I started working on an ""isomorphic"" parser that would allow definitions to be parsed and enforced identically at compile-time via TypeScript and at runtime in JavaScript using parallel static and dynamic implementations [like this](https://github.com/arktypeio/arktype#how).",0.16666666666666666,JavaScript
11hczze,,It could easily be serialized and ported to languages outside the TS/JS ecosystem entirely (although I'm not sure if other type systems would be as cooperative as TypeScript in accommodating the compile-time parser).,0.011666666666666669,TypeScript
11hczze,,"Unfortunately, I still have quite a lot of documentation to catch up on, but I would love to hear this community's thoughts, particularly on some of these syntax extensions and rules that couldn't be adapted directly from TypeScript (the descriptions I've added summarize the current rules enforced by the parsers):  - Single-bound (`""string<=10""`): allows `""<"", "">"", ""<="", "">="", ""==""` comparators, must be on the right of the bounded definition, bounded definition must be a subtype of number, string or array, limit must be a number literal.",0.09206349206349207,TypeScript
11hczze,,"I was a bit torn about how to represent this, as the current syntax is as close as possible to the equivalent TypeScript (`{myKey?",0.0,TypeScript
11hczze,,": string}`), but it requires the key name be enclosed in quotes to be legal syntax in JavaScript.",0.1,JavaScript
11hczze,jatmfsi,"* Zod claims the following in [their docs](https://zod.dev/?id=recursive-types):  >You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred.",0.0,TypeScript
11h5pyf,jarx9ji,Plato is a pure functional programming language based on C# syntax that targets .NET bytecode and JavaScript.,0.21428571428571427,C
11h5pyf,jarx9ji,Plato is a pure functional programming language based on C# syntax that targets .NET bytecode and JavaScript.,0.21428571428571427,JavaScript
11h5pyf,jaso7d4,Have you used ANTLR's C# bindings?,0.0,C
11h5pyf,jb1if9t,"I did some performance testing parsing a 40MB JSON file, and a handful of C# files.",0.0,C
11h5pyf,jb4rxry,"I've written multiple RD libraries in different languages over the last 20 years (YARD in C++, Jigsaw in C#, Myna in TypeScript, and now Parakeet).",0.0,C++
11h5pyf,jb4rxry,"I've written multiple RD libraries in different languages over the last 20 years (YARD in C++, Jigsaw in C#, Myna in TypeScript, and now Parakeet).",0.0,C
11h5pyf,jb4rxry,"I've written multiple RD libraries in different languages over the last 20 years (YARD in C++, Jigsaw in C#, Myna in TypeScript, and now Parakeet).",0.0,TypeScript
11h1yl3,jarwdqt,APL (and its variants J/K/BQN etc.),0.0,APL
11h1yl3,jarwdqt,+ Haskell are some of the few languages to use combinators.,-0.2,Haskell
11h1yl3,jarwdqt,"Haskell’s elegant map, predicate, and scan notations aren’t fully captured in languages today.",0.5,Haskell
11gn93x,,What's better or worse in Rust with affine types?,0.04999999999999999,Rust
11gn93x,,What's better or worse if Rust had linear types instead?,0.04999999999999999,Rust
11gn93x,jaq966v,"If you consider ""Drop must run"" as linear types, then the combination of shared ownership (`Rc`/`Arc`/ecc ecc) and internal mutability (`RecCell`/`Cell`/`Mutex`/`RwLock`/ecc ecc) makes it possible to leak values without consuming them, so if Rust wanted linear types (by default) it would had to forbid one of the above set of types.",0.0,Rust
11gn93x,jarpy46,"Rust has `#[must_use]` which makes something function as a linear type, albeit with a warning instead of an error if it's not used.",0.0,Rust
11gn93x,jar7jpn,"I think, in Rust at least, it's linear types but with the idea of borrowing added.",-0.3,Rust
11gn93x,jar7jpn,Note that this is strictly weaker than linear types because a Rust type can't opt out of being borrowable.,0.0,Rust
11gn93x,jar9vni,Rust is based on an affine type system.,0.0,Rust
11gn93x,jarlib0,"In Rust, it seems like you can use primitive values multiple times, but they are actually being copied, so it isn't the same value - i.e.",0.0,Rust
11gn93x,jargkv7,How do you classify type systems of C and Java?,0.0,C
11gn93x,jargkv7,How do you classify type systems of C and Java?,0.0,Java
11giy06,jat1pr4,What about the Rust interpreter in Lisp?,0.0,Rust
11giy06,jat1pr4,What about the Rust interpreter in Lisp?,0.0,Lisp
11giy06,jat2kxp,"If I were able to do that, I would not be writing Python for a living.",0.5,Python
11g8kaj,jarj84w,Are signed <-> unsigned assignment rules as complicated as in C or worse?,-0.45,C
11g8kaj,janvoi2,It was written in C# and took several seconds to compile which annoyed me every time I made a change.,-0.2,C
11g8kaj,janvoi2,I did first see properties and array indexors (as a function) in C#.,0.25,C
11g8kaj,jayc6ph,C code uses the latter  The standard library has an _ExternC block which lets you define C functions.,0.0,C
11g8kaj,jayc6ph,Some C functions like gettimeofday want a pointer to memory and returns an int.,0.0,C
11g8kaj,jayc6ph,If you wrote it in the multiple return value style the compiler would think the return value is a pointer to a tuple which isn't what the C function does,0.0,C
11g8kaj,janx3nz,"It one page with 3 examples  I think I may be biased by being familiar with C and Dependent Typing, so I think it's straight to the point.",0.2875,C
11g8kaj,jarsx45,"I sort of get the logic behind the `_On<Stuff>` convention, but I feel like adding one or two short and consistent keyword wouldn't be too bad (like Python has `for...else`, maybe you could get your way by reusing other keywords, but it might loses clarity.",-0.2125,Python
11g8kaj,jb6mg5n,"And supported the other, if it's inevitable, only for C interoperability functions.",-0.041666666666666664,C
11fv8cl,jan07ae,"Wow, I remember writing a Lisp interpreter in SPWN years ago.",0.1,Lisp
11fv8cl,jayyzy7,A *lot* of the microdecisions were in fact subsumed by the macrodecision to do as Go does by default.,0.0,Go
11fv8cl,jatx8be,"Currently Claro has no associated types, so the closest you could get would be:      contract Add<A,B,C> {         function add(lhs: A, rhs: B) -> C;     }  This unfortunately means that whatever implementations you had, the desired return type would always need to be asserted so that it's statically known what impl you're referencing:      var intRes: int = Add::add(1, 2);     var strRes: string = Add::add(1, 2);  This obviously gets super gnarly super quickly the second you want to pass the result of addition to some generic procedure arg position as it requires a cast all the sudden:      function foo<T>(t: T) -> ... {...}     _ = foo((int) Add::add(1, 2));  I'm planning on taking notes from Rust (and now Haystack :)) to add support for associated types as well.",0.1,C
11fv8cl,jatx8be,"Currently Claro has no associated types, so the closest you could get would be:      contract Add<A,B,C> {         function add(lhs: A, rhs: B) -> C;     }  This unfortunately means that whatever implementations you had, the desired return type would always need to be asserted so that it's statically known what impl you're referencing:      var intRes: int = Add::add(1, 2);     var strRes: string = Add::add(1, 2);  This obviously gets super gnarly super quickly the second you want to pass the result of addition to some generic procedure arg position as it requires a cast all the sudden:      function foo<T>(t: T) -> ... {...}     _ = foo((int) Add::add(1, 2));  I'm planning on taking notes from Rust (and now Haystack :)) to add support for associated types as well.",0.1,Rust
11fskiu,,"It's kind of like Rust's procedural macros, except you can change code that you didn't write.",0.6,Rust
11fskiu,jao7zup,I think this makes code harder to reason about for readers in a similar way that runtime monkey patching does in Ruby or Python.,-0.05000000000000001,Ruby
11fskiu,jao7zup,I think this makes code harder to reason about for readers in a similar way that runtime monkey patching does in Ruby or Python.,-0.05000000000000001,Python
11fskiu,jamnkma,"Something similar to C++ templates is probably a better solution for this  this      fn add(a, b):         if type a == int and type b == int then             add_ints a b // Call a concrete integer addition function         else if type a == real and type b == real then             add_reals a b         else compile_error $""{type a} and {type b} cannot be added""  can be directly translated to a function template:      auto operator+(auto a, auto b) {         using ta = decltype(a);         using tb = decltype(b);         if constexpr (std::same_as<ta, int> and std::same_as<tb, int>)             return add_ints(a, b);         else if constexpr (std::same_as<ta, double> and std::same_as<tb, double>)             return add_doubles(a, b);         else             static_assert(sizeof(ta) == -1, ""+: operands are not addable"");     }",0.19166666666666668,C++
11fskiu,jalcokf,"It's not a stupid idea, in fact it's the primary paradigm and core feature of Julia (multiple dispatch).",0.26666666666666666,Julia
11fskiu,jalcokf,Your example can be translated directly to Julia with just syntactic changes.,0.1,Julia
11fskiu,janb5ho,Compile-time code interpretation is standard in Forth.,0.0,Forth
11fskiu,jalex61,":+  julia> +(x::Vec2, y::Vec2) = Vec2(x.x + y.x, x.y + y.y);  julia> x = Vec2(1, 2);  julia> y = Vec2(3, 4);  julia> x + y Vec2{Int64}(4, 6) ``` At compile time, Julia selects the ""most specific method"" matching the given type signature.",0.25,Julia
11fskiu,jaqpc5b,But Forth is not standard anywhere.,0.0,Forth
11fskiu,jau1m0d,"There are Forth standards, although that really goes against the intent of the creator, Charles Moore.",0.2,Forth
11fskiu,jalp5td,"I have implemented it in my own language, though not optimized to the extent that a language with more resources like Julia would.",0.55,Julia
11fskiu,jaoa4d3,"I made a multimethod library for Java a couple of years ago, called MultiJ.",0.0,Java
11fgksu,jaj5uxo,"in C on Linux, these are controlled by `feenableexcept` and friends.",0.0,C
11fgksu,jajgz0b,This is what MSVC does with C++.,0.0,C++
11fg0q7,,"I used to write C# professionally, and I could write a function like this:      public void changeValue(out int x) {       x = x + 1;     }  and then call it like this:      int y = 1;     changeValue(out y);  and the value of `y` would be `2`.",0.05,C
11fg0q7,,"However, I have not seen such a construct since leaving C# back in like 2017.",0.0,C
11fg0q7,,"I've worked with Java, Python, and Ruby since leaving that job and as far as I know, none of these languages have this construct.",0.1,Java
11fg0q7,,"I've worked with Java, Python, and Ruby since leaving that job and as far as I know, none of these languages have this construct.",0.1,Python
11fg0q7,,"I've worked with Java, Python, and Ruby since leaving that job and as far as I know, none of these languages have this construct.",0.1,Ruby
11fg0q7,jajdvez,Python or Java.,0.0,Python
11fg0q7,jajdvez,Python or Java.,0.0,Java
11fg0q7,jajnl6z,"Probably worth noting this is not valid C# code, the compiler error is:  > Error CS0269: Use of unassigned out parameter `x'  If OP made this mistake in their own trivial example, it could be an indication that this feature is not intuitive.",0.4666666666666666,C
11fg0q7,jajrq4e,"In Java, if I say:      int x = 3;     object.foo(x);     // the value of x is still 3  In languages with call by reference, I have to check the signature of foo to be sure.",0.5,Java
11fg0q7,jajrq4e,"Since Python and Ruby support returning lists or tuples anyway, and Java is trying to encourage very straightforward code, the value of output parameters is probably seen as less than the complexity it adds to interpreting every function call.",0.1604166666666667,Python
11fg0q7,jajrq4e,"Since Python and Ruby support returning lists or tuples anyway, and Java is trying to encourage very straightforward code, the value of output parameters is probably seen as less than the complexity it adds to interpreting every function call.",0.1604166666666667,Ruby
11fg0q7,jajrq4e,"Since Python and Ruby support returning lists or tuples anyway, and Java is trying to encourage very straightforward code, the value of output parameters is probably seen as less than the complexity it adds to interpreting every function call.",0.1604166666666667,Java
11fg0q7,jajrq4e,"(Footnote: you can build a mutable data structure out of an assignable local variable and a closure, by the way:      interface MutableRef<T> {          T get();          void set(T);          static MutableRef<T> build() {             T x;              return new MutableRef<T>() {                 T get() { return x; }                 void set(T x1) { x = x1; }             };         }     }  Java syntax, but not valid Java because Java doesn't let you reference mutable variables in an inner class, I think for JVM implementation reasons.",0.1590909090909091,Java
11fg0q7,jak4m59,Java is changing very slowly and would take ages to gain out variables.,-0.39000000000000007,Java
11fg0q7,jak4m59,Python has tuples.,0.0,Python
11fg0q7,jak4m59,Ruby has array destructuring that's commonly used as multiple return values.,-0.15,Ruby
11fg0q7,jak4m59,Go has multiple return values.,0.0,Go
11fg0q7,jak4m59,Rust has tuples.,0.0,Rust
11fg0q7,jak4m59,"Tuples aren't always as convenient as the `TryParse` pattern, but Go set up its syntax and semantics to allow it to be roughly the same, and Rust uses `Option<T>` with some convenience stuff to make it nicer to use.",-0.05,Go
11fg0q7,jak4m59,"Tuples aren't always as convenient as the `TryParse` pattern, but Go set up its syntax and semantics to allow it to be roughly the same, and Rust uses `Option<T>` with some convenience stuff to make it nicer to use.",-0.05,Rust
11fg0q7,jajgaeg,"In C# specifically, an async method can't have out parameters.",0.0,C
11fg0q7,jajgaeg,I suspect the only reason this feature was added to C# in the first place was to in order to support interoperation with C or C++.,0.125,C
11fg0q7,jajgaeg,I suspect the only reason this feature was added to C# in the first place was to in order to support interoperation with C or C++.,0.125,C++
11fg0q7,jajgaeg,"In C in particular, you see parameters used as ~~inputs~~ outputs *all the time*, but that's because the language doesn't give you a lot of other options for how to do things.",0.02083333333333333,C
11fg0q7,jak4g26,It's everywhere in C and C++.,0.0,C
11fg0q7,jak4g26,It's everywhere in C and C++.,0.0,C++
11fg0q7,jak4g26,It's there in Rust.,0.0,Rust
11fg0q7,jak4g26,It's there in Python.,0.0,Python
11fg0q7,jaj5xq1,"> Java, Python, and Ruby   Those are all weak, high-level languages that don't even support the concept of value types (well, Java aspires to with its ""Project Valhalla"", but hasn't had any real success yet), let alone references to stack variables.",0.03749999999999998,Java
11fg0q7,jaj5xq1,"> Java, Python, and Ruby   Those are all weak, high-level languages that don't even support the concept of value types (well, Java aspires to with its ""Project Valhalla"", but hasn't had any real success yet), let alone references to stack variables.",0.03749999999999998,Python
11fg0q7,jaj5xq1,"> Java, Python, and Ruby   Those are all weak, high-level languages that don't even support the concept of value types (well, Java aspires to with its ""Project Valhalla"", but hasn't had any real success yet), let alone references to stack variables.",0.03749999999999998,Ruby
11fg0q7,jaj5xq1,"They simply lack the facilities for this feature unlike C# which has real C++ heritage and supports a lot of such flexible, high-performance stuff.",0.06666666666666667,C
11fg0q7,jaj5xq1,"They simply lack the facilities for this feature unlike C# which has real C++ heritage and supports a lot of such flexible, high-performance stuff.",0.06666666666666667,C++
11fg0q7,jaj5xq1,"Rust, you would have a totally different impression.",0.0,Rust
11fg0q7,jamcdw3,"The limit of one return value per function comes from the way C was conceived, at a time were every byte was important.",0.4,C
11fg0q7,jamcdw3,"In C / C++, it became convention, when you wanted to return more than one value from a function, to have pointers or references as parameters.",0.5,C
11fg0q7,jamcdw3,"In C / C++, it became convention, when you wanted to return more than one value from a function, to have pointers or references as parameters.",0.5,C++
11fg0q7,jamcdw3,"C# solves this by explicitly defining ""ref"" and ""out"" keywords instead.",0.0,C
11fg0q7,jamcdw3,"High-level languages like C# or Java can afford to waste CPU cycles, and they support tuples.",-0.2,C
11fg0q7,jamcdw3,"High-level languages like C# or Java can afford to waste CPU cycles, and they support tuples.",-0.2,Java
11fg0q7,jamcdw3,"In C#, it's perfectly possible to do this:      (bool success, int?",-0.15,C
11fg0q7,jamcdw3,"value) TryParse (string str) { ... }  It doesn't look good, because you have to name the members in a tuple, but nothing stops C# from implemented some syntactic sugar so this function looks like this:      (bool, int?)",-0.025000000000000022,C
11fg0q7,jajpndc,Python or Java.,0.0,Python
11fg0q7,jajpndc,Python or Java.,0.0,Java
11fg0q7,jajpndc,because I've worked at Java codebases and have read code where that's very much in use.,0.26,Java
11fg0q7,jajpndc,and in C/C++ you have `*void/*const void` which allow you to be explicit that a function can mutate it's parameters  and in Rust you have `&T/&mut T` that force you to be explicit via the borrow checker that a function mutates it's arguments,0.0,Rust
11fg0q7,jajf1fk,"I think this is the answer, but on the other hand, Tweag has an article on [destination-passing style](https://www.tweag.io/blog/2020-11-11-linear-dps/) that discusses how it may still be useful (even in Haskell, with its support for algebraic types and pattern matching) in situations where it's important who does the allocation, and how that code can still be pure in a linear-typed context.",0.19732142857142856,Haskell
11fg0q7,jamd94y,"When C# does this:      bool TryParse (string s, out int i);  It doesn't really make much sense.",0.2,C
11fg0q7,jamd94y,"The only reason it's this way is because C# syntax is inherited from C, which was built around functions returning just one value.",0.0,C
11fg0q7,jamd94y,"We are now in 2023, the concerns dmr had when building C are mostly gone, and we now try to design flexible, concise languages that prioritize easy to read and hard to fuck up code over extreme performance.",0.03611111111111107,C
11fg0q7,jajh8xi,"C# has another keyword, `ref`, for ""inout"".",0.0,C
11fg0q7,jajh8xi,"I'm not sure since I don't use `out` much, but I don't even think OP's example is legal; I thought the C# compiler would forbid you from using a variable with `out` if it's already been given a value.",0.05000000000000001,C
11fg0q7,jajklxb,"Lack of variance in languages like Go means `A <: B` does not imply `[]A <: []B`, where `<:` means ""is subtype of"" (for the purpose of implicit conversions, say).",-0.75,Go
11fg0q7,jak7ltx,"`By Reference`)  The difference between the last two can be subtle; consider this example in Python:      def F(x):         x[2] = 777          def G(x):         x = ""Donkey""          A = [10,20,30]     F(A)     print(A)                 # A is now [10,20,777]          A = [10,20,30]     G(A)     print(A)                 # A is still [10,20,30]  It is impossible for `G()` to replace the caller's `A` with a completely different object.",-0.25,Python
11fg0q7,jal7daj,"I'm not sure what the rules are in C#, but I would hope you can't read from an `out` parameter and must assign a value to it.",-0.25,C
11fg0q7,jak26l2,And Java and Python do pass by reference everywhere (at least for everything that is not a basic type in Python).,-0.15,Java
11fg0q7,jak26l2,And Java and Python do pass by reference everywhere (at least for everything that is not a basic type in Python).,-0.15,Python
11fg0q7,jakwiyw,Doesn't Go have this as well?,0.0,Go
11fg0q7,jajoehp,"It seemed straightforward to me, but I don't know C#",0.375,C
11fg0q7,jakm2zi,It's absent in Python et al.,0.0,Python
11fg0q7,jajy0dz,"Ada, not ADA.",0.0,Ada
11fg0q7,jaltwen,"I mean, I know some Ada, but I don't know what you are talking about.",-0.3125,Ada
11fg0q7,jamcq0o,Java is a victim of the past.,-0.1625,Java
11fg0q7,jamcq0o,"Languages like Rust or Kotlin, which are newer, have built mutability in their syntax from the start, which makes using it painless and allows you to move a lot of potential bugs to compile time errors.",0.0,Rust
11fg0q7,jamcq0o,"Languages like Rust or Kotlin, which are newer, have built mutability in their syntax from the start, which makes using it painless and allows you to move a lot of potential bugs to compile time errors.",0.0,Kotlin
11fg0q7,japd34q,See for example Haskell or Clojure.,0.0,Haskell
11fg0q7,japd34q,See for example Haskell or Clojure.,0.0,Clojure
11fg0q7,japd34q,"Meanwhile, C did not get `const` until C89/C90, after C++ got it, leading to function signatures which do not use it even when not mutating, and being the reason why C++ has `const_cast`: because old immutable C data structures are represented like in Java, and modern C++ type safe code needs to interoperate with it.",0.26666666666666666,C
11fg0q7,japd34q,"Meanwhile, C did not get `const` until C89/C90, after C++ got it, leading to function signatures which do not use it even when not mutating, and being the reason why C++ has `const_cast`: because old immutable C data structures are represented like in Java, and modern C++ type safe code needs to interoperate with it.",0.26666666666666666,C++
11fg0q7,japd34q,"Meanwhile, C did not get `const` until C89/C90, after C++ got it, leading to function signatures which do not use it even when not mutating, and being the reason why C++ has `const_cast`: because old immutable C data structures are represented like in Java, and modern C++ type safe code needs to interoperate with it.",0.26666666666666666,Java
11fg0q7,jb2xhrn,"In the specific C# example you give, I wouldn't say it's completely arbitrary.",-0.05,C
11fg0q7,jajo3vn,"There's no subtyping in Go at all, so there's no `A <: B` to begin with.",0.0,Go
11fg0q7,janiwbm,"Your ""in/out"" vs. ""reference"" corresponds to passing `T*` vs. `T**` in C (passing a reference to an object vs. passing a reference to a reference — i.e.",0.0,C
11fg0q7,janiwbm,Look at it in C++:      // C's syntax for pointers-to-arrays is awful;     // a type alias will help keep things clear.,-0.45,C++
11fg0q7,janiwbm,Look at it in C++:      // C's syntax for pointers-to-arrays is awful;     // a type alias will help keep things clear.,-0.45,C
11fg0q7,janiwbm,"using int_array = int[];      int_array donkey = { 'D', 'o', 'n', 'k', 'e', 'y' };      void F(int_array* x) {         (*x)[2] = 777;     }      void G1 (int_array* x) {         x = &donkey;     }      void G2 (int_array** x) {         *x = &donkey;     }      int main() {         // the cast is unfortunately necessary         // to fix the broken-by-default treatment         // of arrays which C++ inherited from C.          auto A = (int_array*) new int_array {10,20,30};          F(A);   // A is the same, *A is now [10,20,777]         G1(A);  // A is the same, *A is still [10,20,777]         G2(&A); // A has changed, *A is now ""Donkey""     }  The difference between G1 and G2 becomes clear when your language gives you the vocabulary to distinguish between references and the objects they reference.",-0.012121212121212125,C++
11fg0q7,jalu4zf,IIRC Ada has explicit in / out attributes on parameters,0.0,Ada
11fg0q7,japfynx,"I meant more traditional, imperative and GC'd languages like Java, js, python, C# and so, there's usually not a well supported way of denoting that a parameter won't be modified.",0.20833333333333334,Java
11fg0q7,japfynx,"I meant more traditional, imperative and GC'd languages like Java, js, python, C# and so, there's usually not a well supported way of denoting that a parameter won't be modified.",0.20833333333333334,C
11fg0q7,jajxzjx,I was picturing it like a C++ reference and assuming all out parameters were automatically references,0.0,C++
11fg0q7,jakwh2t,"OP's example is in C#, where `int` s aren't objects (but rather primitives), so your latter question isn't meaningful.",0.25,C
11fg0q7,jakwh2t,"For objects, Python and Java (among others) use the ""call-by-object-reference"" scheme, which is worth googling.",0.3,Python
11fg0q7,jakwh2t,"For objects, Python and Java (among others) use the ""call-by-object-reference"" scheme, which is worth googling.",0.3,Java
11fg0q7,jajzai5,"Both `ref`and `out` in C# are references (pointers in C), `out` is just protected inside the function from being read before written to.",0.0,C
11fg0q7,jajzai5,"IDK if C++ has this feature, i think `const int* x` in C++ is the same as `in int x` in C#.",0.0,C++
11fg0q7,jajzai5,"IDK if C++ has this feature, i think `const int* x` in C++ is the same as `in int x` in C#.",0.0,C
