16dx0oe,,There’s things like Quoka that let you view the output of a line of JavaScript without running the actual JavaScript.,0.0,javascript
16dx0oe,jzs3sz6,I think notebooks also fit this kinda idea  Like Jupiter notebooks with Python or R etc,0.4,python
16dx0oe,jzs3sz6,I think notebooks also fit this kinda idea  Like Jupiter notebooks with Python or R etc,0.4,r
16dx0oe,jzs93n7,"I also have ""hotcoding"": if you change a Charm script then you don't need to say that you want to re-run it, you can go back to the REPL and talk to the script and it'll rebuild.",0.0,go
16dx0oe,jzs3hhe,Forth.,0.0,forth
16dx0oe,jzs3354,Lazy languages like Haskell?,-0.25,haskell
16dx0oe,jzsbrnq,[Quokka](https://quokkajs.com/) does re-evaluate your JavaScript program after the tiniest of changes you make.,0.0,javascript
16dx0oe,jzs39oa,Common Lisp?,-0.3,lisp
16dx0oe,jzsc2wb,"Or by analogy to a more ordinary interpreted lang, like Ruby: it's as though my Rails source and the Rails console were the same thing, and also seamlessly updated on the fly with no need to restart the app.",0.22999999999999998,ruby
16dx0oe,jzsc2wb,"If this is something you are interested in playing with, Clojure's version may be the most accessible.",0.375,clojure
16dx0oe,jzsc2wb,You can set up Clojure + [Calva](https://calva.io/) very easily to do this stuff in VSCode on whatever platform you like.,0.5633333333333334,clojure
16dx0oe,jzsc2wb,"(Or if you prefer Emacs, go grab [CIDER](https://cider.mx/).)",0.0,go
16dx0oe,jzsc2wb,"If you're put off by Clojure's weirdness and would prefer a more classic LISP, Common Lisp did this stuff before Clojure did- go get [SLIME](https://slime.common-lisp.dev/) (for Emacs) or [Alive](https://marketplace.visualstudio.com/items?itemName=rheller.alive) (for VSCode).",0.12222222222222222,clojure
16dx0oe,jzsc2wb,"If you're put off by Clojure's weirdness and would prefer a more classic LISP, Common Lisp did this stuff before Clojure did- go get [SLIME](https://slime.common-lisp.dev/) (for Emacs) or [Alive](https://marketplace.visualstudio.com/items?itemName=rheller.alive) (for VSCode).",0.12222222222222222,lisp
16dx0oe,jzsc2wb,"If you're put off by Clojure's weirdness and would prefer a more classic LISP, Common Lisp did this stuff before Clojure did- go get [SLIME](https://slime.common-lisp.dev/) (for Emacs) or [Alive](https://marketplace.visualstudio.com/items?itemName=rheller.alive) (for VSCode).",0.12222222222222222,go
16dx0oe,jzsg9o1,"i guess the main thing is that the language be fast to evaluate, so the fact that javascript is jit compiled makes it much more amenable to this than many other languages",0.24027777777777778,javascript
16dx0oe,jztl4ys,For example in rust there is [cargo-watch](https://github.com/watchexec/cargo-watch).,0.0,rust
16dx0oe,jztp9h1,Lisp,0.0,lisp
16dx0oe,jztspk6,Erlang does this.,0.0,erlang
16dx0oe,jztkr12,"Forth 100%  It's interpreted, but the REPL is kind of a hybrid of compiler/interpreter where you can hijack the parser to accept different syntax or provide compile-time semantics.",0.3,forth
16ddx70,jztp5b4,Here [you go](https://github.com/mrakgr/The-Spiral-Language#the-spiral-language).,0.0,go
16dca3l,,I have read Ford's paper (I know it's a thesis and not a paper) too --- and now that I have gotten into FuncProg I should really take a look at Ford's original Haskell implementation of PEG.,0.2875,haskell
16dam9e,,"* fin is like a modern C++ that is much simpler, way safer, and already has superb tooling (IDE, debugger, refactoring...).",0.4666666666666666,c++
16dam9e,,* has incredible testing/simulation capabilities (python like).,0.9,python
16dam9e,jzq4zk9,Why do you consider a subset of C# to be the better match for embedded system development than e.g.,0.5,c
16dam9e,jzq4zk9,Ada?,0.0,ada
16dam9e,jzq4zk9,"EDIT: I also tried to find out what you actually use instead of the garbage collector (you said ""no heap or garbage collector required"") and how this fits with the C# philosophy.",0.0,c
16dam9e,jzr2edb,"The pdf title starts “Write Embedded C”, but it seems to be more Embedded C#.",0.5,c
16dam9e,jzr2edb,"I’m working on a language that feels similar to C#, but specialised to a different application domain (casino type slot machine mathematics design) and borrows const, references, and a few other things from C++ and other languages.",-0.09,c
16dam9e,jzr2edb,"I’m working on a language that feels similar to C#, but specialised to a different application domain (casino type slot machine mathematics design) and borrows const, references, and a few other things from C++ and other languages.",-0.09,c++
16dam9e,jzrg5iv,"Ada is cool, but in my experience, C/C++ are by far the most popular embedded systems languages.",0.38749999999999996,ada
16dam9e,jzrg5iv,"Ada is cool, but in my experience, C/C++ are by far the most popular embedded systems languages.",0.38749999999999996,cool
16dam9e,jzrg5iv,"For example, the below snippet is valid C, C++, fin/C#:      float calc_stuff(int a, float b) {         return a * b + get_offset();     }  Fin supports use without heap or GC.",0.0,c
16dam9e,jzrg5iv,"For example, the below snippet is valid C, C++, fin/C#:      float calc_stuff(int a, float b) {         return a * b + get_offset();     }  Fin supports use without heap or GC.",0.0,c++
16dam9e,jzrgcup,"yeah, fin is pretty much C# syntax, but using an embedded C paradigm if that makes sense.",0.225,c
16dam9e,jzpehzo,I assume because writing backends for different C standards is time consuming and mostly unnecessary,-0.2,c
16dam9e,jzp7h03,"If I understand correctly regarding C version, I'd like to target C99 to support older compilers.",0.16666666666666666,c
16dam9e,jzp7h03,I don't want to go all the way back to C89 though.,0.0,go
16dam9e,jzp7h03,We can still have classes and inheritance without the heap (just like C++).,0.0,c++
16dam9e,jzp7h03,Here's the safety stuff:  * non-null references * null analysis for pointers * safer strings (also support c strings) * safer arrays (also support c naked arrays) * error handling approaches * arithmetic overflow * non-blocking assurances * data thread safety * selective safety escapes (for speed) * [video link](https://youtu.be/GMeskZM4wW0?si=9pD_PxQn6qty9vfT&t=63) * [PDF of slides](https://github.com/fin-language/fin/#-pdf-slides) (around slide 21),0.0,c
16dam9e,jztmbql,He wrote all the tools that I take for granted with c#.,0.0,c
16dam9e,jzsbws0,But C# is pretty different from both C and C++.,0.125,c
16dam9e,jzsbws0,But C# is pretty different from both C and C++.,0.125,c++
16dam9e,jzsbws0,You could have used a subset of C++ or any other language with curly braces but decided for C#; thus my question.,-0.125,c++
16dam9e,jzsbws0,You could have used a subset of C++ or any other language with curly braces but decided for C#; thus my question.,-0.125,c
16dam9e,jzsbws0,"the resource-constrained microcontroller based, not the ""PC without screen"" version usually running a Linux) uses C, not C++ (because of the overhead of the latter).",-0.125,c
16dam9e,jzsbws0,"the resource-constrained microcontroller based, not the ""PC without screen"" version usually running a Linux) uses C, not C++ (because of the overhead of the latter).",-0.125,c++
16dam9e,jzsbws0,"For a C embedded developer, C# is not more familiar than Ada.",0.0625,c
16dam9e,jzsbws0,"For a C embedded developer, C# is not more familiar than Ada.",0.0625,ada
16dam9e,jzsbws0,the ones supported by Ada?,0.0,ada
16dam9e,jzs02j1,"If you want to pass by reference it’s like C++ with &, but the ampersand is required at the call site as well.",0.0,c++
16dam9e,jzs02j1,"I didn’t really like having a mix of value and reference types that C#, or problem you talked about with the C++ call signatures.",0.2,c
16dam9e,jzs02j1,"I didn’t really like having a mix of value and reference types that C#, or problem you talked about with the C++ call signatures.",0.2,c++
16dam9e,jzs02j1,I’d like to have Kotlin style smarts casts in the future.,0.0,d
16dam9e,jzs02j1,I’d like to have Kotlin style smarts casts in the future.,0.0,kotlin
16dam9e,jztlsvv,One of the downsides to using C# is that the memory allocations are more verbose.,0.5,c
16dam9e,jztlsvv,I don't personally mind the extra characters as they are easy to read and I don't have to type them :)  [related video snippet](https://www.youtube.com/watch?v=ITn2S3NVuM0&list=PLe6ZYZk0KW45X2rLYI1IYco5774oe3Lmr&index=6&t=474s)  The subset of C# that fin uses is really close to C++.,0.18888888888888888,c
16dam9e,jztlsvv,I don't personally mind the extra characters as they are easy to read and I don't have to type them :)  [related video snippet](https://www.youtube.com/watch?v=ITn2S3NVuM0&list=PLe6ZYZk0KW45X2rLYI1IYco5774oe3Lmr&index=6&t=474s)  The subset of C# that fin uses is really close to C++.,0.18888888888888888,c++
16dam9e,jztlsvv,"Compare the below C++, C# and Ada programs that all do the same thing (AI generated).",0.0,c++
16dam9e,jztlsvv,"Compare the below C++, C# and Ada programs that all do the same thing (AI generated).",0.0,c
16dam9e,jztlsvv,"Compare the below C++, C# and Ada programs that all do the same thing (AI generated).",0.0,ada
16dam9e,jztlsvv,Don't the C++ and C# classes look similar to you?,0.0,c++
16dam9e,jztlsvv,Don't the C++ and C# classes look similar to you?,0.0,c
16dam9e,jztlsvv,"Nothing wrong with Ada, but it uses very different syntax that is less familiar to embedded developers (in general).fin  `C++`      class TemperatureConverter     {     public:     	static double CelsiusToFahrenheit(double celsius)     	{     		return (celsius * 9 / 5) + 32;     	}     };  `fin/C#`      public class TemperatureConverter     {     	public static double CelsiusToFahrenheit(double celsius)     	{     		return (celsius * 9 / 5) + 32;     	}     }  `Ada`      package Temperature_Converter is        function Celsius_To_Fahrenheit(Celsius : Float) return Float;     end Temperature_Converter;          package body Temperature_Converter is        function Celsius_To_Fahrenheit(Celsius : Float) return Float is     	  Fahrenheit : Float;        begin     	  Fahrenheit := (Celsius * 9.0 / 5.0) + 32.0;     	  return Fahrenheit;        end Celsius_To_Fahrenheit;     end Temperature_Converter;  I don't know much about Ada other than it was used for military embedded applications.",-0.004444444444444442,ada
16dam9e,jztlsvv,"Nothing wrong with Ada, but it uses very different syntax that is less familiar to embedded developers (in general).fin  `C++`      class TemperatureConverter     {     public:     	static double CelsiusToFahrenheit(double celsius)     	{     		return (celsius * 9 / 5) + 32;     	}     };  `fin/C#`      public class TemperatureConverter     {     	public static double CelsiusToFahrenheit(double celsius)     	{     		return (celsius * 9 / 5) + 32;     	}     }  `Ada`      package Temperature_Converter is        function Celsius_To_Fahrenheit(Celsius : Float) return Float;     end Temperature_Converter;          package body Temperature_Converter is        function Celsius_To_Fahrenheit(Celsius : Float) return Float is     	  Fahrenheit : Float;        begin     	  Fahrenheit := (Celsius * 9.0 / 5.0) + 32.0;     	  return Fahrenheit;        end Celsius_To_Fahrenheit;     end Temperature_Converter;  I don't know much about Ada other than it was used for military embedded applications.",-0.004444444444444442,c++
16dam9e,jztpqk8,"If I had full syntax control (instead of piggybacking on C#), I would want to do something similar.",0.175,c
16dam9e,jztpqk8,"\>   A key point here is that you cannot perform a theoretical analysis on a game written in C# or Java, you can only perform simulation.",-0.1,c
16dam9e,jztpqk8,"\>   A key point here is that you cannot perform a theoretical analysis on a game written in C# or Java, you can only perform simulation.",-0.1,java
16dam9e,jztpqk8,"I'm already transpiling a smaller subset of C# to C and js in StateSmith ([draw.io](https://draw.io),plantuml to state machines).",0.0,c
16dam9e,jztpqk8,I really do benefit a lot by staying within the C# syntax.,0.2,c
16dam9e,jztpqk8,Even this one tool that shows the AST of highlighted C# code is amazingly helpful: https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/syntax-visualizer?tabs=csharp,0.6000000000000001,c
16dam9e,jzusw65,I didn’t try to follow C# etc syntax exactly as this product was based on an existing one with a much simpler declarative language and is used by non-programmers.,0.225,c
16dam9e,jzusw65,"I had previously tried embedding the products functionality as a C# library, but it was much too difficult to use.",-0.15555555555555556,c
16dam9e,jzusw65,I can see plenty of benefits following C# syntax exactly most other cases.,0.125,c
16dam9e,jzusw65,Why not compile C# code to the target platform (using llvm) and skip the C output?,0.0,c
16dam9e,jzv0qu8,"Also, if I compile to C, I can work with my company's large c code bases.",0.21428571428571427,c
16dam9e,jzv0qu8,Mix and match new fin generated c code with existing c code base.,-0.33181818181818185,c
16dam9e,jzvp7qy,"I’m not sure I’d read past the first video of slides if I were the target audience, which admittedly I’m probably not.",-0.08333333333333333,d
16csl90,,It is in the realm of JavaScript's [chalk](https://github.com/chalk) and Python's [rich](https://github.com/Textualize/rich) but slightly more functional 😉.,0.5,javascript
16csl90,,It is in the realm of JavaScript's [chalk](https://github.com/chalk) and Python's [rich](https://github.com/Textualize/rich) but slightly more functional 😉.,0.5,python
16cs6js,,"I tried writing a parser in C++, then redid it in Rust, then redid it AGAIN in Rust after failing miserably the first time.",-0.375,c++
16cs6js,,"I tried writing a parser in C++, then redid it in Rust, then redid it AGAIN in Rust after failing miserably the first time.",-0.375,rust
16cs6js,,"A few years ago I was a Java programmer who didn’t know *anything* about how computers really worked under the hood, and now I’ve made my own low level programming language that compiles to native machine code.",0.15,java
16cs6js,,"Here’s the example of this feature from the readme:  ``` math :: import ""std/math.capy"";      powers_of_two := comptime {     array := [] i32 { 0, 0, 0 };          array[0] = math.pow(2, 1);     array[1] = math.pow(2, 2);     array[2] = math.pow(2, 3);          // return the array here (like Rust)     array }; ```  The compiler evaluates this by JITing the `comptime { .. }` block as it’s own function, running that function, and storing the bytes of the resulting array into the data segment of the final executable.",0.3,rust
16cs6js,,"In it's current state I was able to implement [a dynamic String type stored on the heap](https://github.com/capy-language/capy/blob/master/examples/string.capy), but there are some important things the language needs before I’d consider it fully usable.",0.225,d
16cs6js,jzmxenz,Arbitrary comptime evaluation seems like such a cool problem to solve.,0.08333333333333333,cool
16cs6js,jzm7y72,Cool!,0.4375,cool
16cs6js,jzoh7wq,"Once I realized that it’d be possible to do what I wanted with JIT, I was actually surprised how easy it was to implement with what I had already written for compilation.",0.17777777777777778,d
16cs6js,jzoiuu6,"The language is pretty C level right now, so it certainly has UB if you try and look for it.",0.25,c
16cs6js,jzs9qoe,We've seen this firsthand in D.,0.0,d
16cs6js,jzn8907,"In (one of the) OG ""compile-time, macro language"", namely Common Lisp, you can do the following:  - Define named, ""global"" macros (using `defmacro`), which *can* perform arbitrary compile-time evaluation.",-0.1,lisp
16cs6js,jzn8907,"As an example, in SBCL's source code (a Common Lisp compiler), here is how some mapping functions are defined simultaneously:  ``` (macrolet ((define-list-map (name accumulate take-car                              return-value-description)              (let ((documentation                      (format nil ""Apply FUNCTION to successive tuples ~                                   of ~A of LIST and MORE-LISTS.~%~                                   Return ~A.""",-0.3,lisp
16cs6js,jzrmyvt,"Capy is written in Rust and uses [cranelift](https://cranelift.dev/) for both JIT compilation and final executable generation, so I'm not sure if it'd fit in my current workflow, but thank you for the suggestion anyways :)",0.13,rust
16cs6js,jzomweb,Imo there's a pretty big difference between Lisp macros and staged compilation.,0.125,lisp
16cs6js,jzpkhh5,`eval-when` basically contains as it's body a list of Lisp code (function- and variable definitions as well as other code) and a specification when to run this Lisp code.,-0.125,lisp
16cm22y,jzkwy2e,One cool feature synergy my language Sonance heavily relies on is non-local returns combined with back-passing.,0.07499999999999998,cool
16cm22y,jzkwy2e,"This lets you do all sorts of cool things, in a similar area to continuations, but in a way that's static and usually zero-cost.",0.15,cool
16cm22y,jzkwy2e,"Non-local returns is being able to have control flow escape certain lambdas, such as returning from the containing function from inside a `map`, `find`, or something (Ruby has this, and a few others).",0.12857142857142856,ruby
16cm22y,jzkwy2e,"They work really well together and allow you to get into all sorts of cool things, such as easily creating custom control flow structures without any macros or meta programming.",0.24583333333333335,cool
16cm22y,jzlmvrk,"### Background  Scheme has the ability to evaluate code in particular environments (some specially named ones, or environments created from modules), but the environments are *second-class*, so this may only be set up prior to runtime.",0.13095238095238096,scheme
16cm22y,jzlmvrk,"Scheme gets around this by making `define` a *special-form*, also known as a *second-class citizen*.",0.0,scheme
16cm22y,jzlmvrk,There are limitations in Scheme as to where `define` may be used - it is not a general expression.,-0.02500000000000001,scheme
16cm22y,jzlmvrk,"In fact, all of the operatives that follow are standard library features and not language features, which makes them all first-class (unlike their Scheme equivalents, which are second-class).",0.0,scheme
16cm22y,jzlmvrk,"($let ((symb expr))         (foo symb))  So far, nothing you can't really do in Scheme (except pass `$define!`, `$set` and `$let` around as variables or use them anywhere).",0.175,scheme
16cm22y,jzkvtpw,Lua has tables that basically act like hashtables for strings (technically any object).,0.0,lua
16cm22y,jzkvtpw,":  ```lua _G[""hello""] = function() print(""hello"") end  hello() ```  The fact that tables are used for nearly everything gives the language a very consistent and intuitive feel.",0.21250000000000002,lua
16cm22y,jzmghl1,"Laziness and side effects  And by ""cool"" I mean ""incredibly stupid""",-0.25416666666666665,cool
16cm22y,jzl3gig,You construct objects and functions by typing them in as you go.,0.0,go
16cm22y,jzmoul5,fexprs are also the secret sauce behind R's Tidyverse.,-0.4,r
16cm22y,jzmoul5,"Tidy evaluation (""[hygienic fexprs](https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf)"") takes a different approach, but was only made possible by the artifact of R inheriting fexprs from pre-Scheme Lisp!",0.15,r
16cm22y,jzmoul5,"Tidy evaluation (""[hygienic fexprs](https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf)"") takes a different approach, but was only made possible by the artifact of R inheriting fexprs from pre-Scheme Lisp!",0.15,lisp
16cm22y,jzllswl,"Sonance does it very similarly to Ruby, in that non-local returns can only be done from ""blocks"", which are a special type of closure that can't be stored anywhere.",0.11904761904761905,ruby
16clv69,,"Example: nodeJS and python are executable files and both of them have ""print"" functions no mater if I use it or not.",0.0,python
16clv69,,"**Some components are ""low-level""** \- implemented in language of implementation (go), other are ""hight level"" - composition of other components.",-0.125,go
16clv69,,There's a compiler with static type system that translates source code into low-level representation and to go code (via go text templates).,0.5,go
16clv69,,"So there's a runtime (simple engine that works over go's runtime) that runs those ""low-level"" components (go functions) and connects ports together.",0.0,go
16clv69,,It's a go reusable go package.,0.0,go
16clv69,,\---     Now let's go to the questions:     1.,0.0,go
16clv69,,I don't see a problem depending on go compiler.,0.0,go
16clv69,,"But I see multiple advantages like - it's simpler than use LLVM, go is perfect choice for FPB-like language  3.",0.5,go
16clv69,,"\---     Maybe some of the options (compiler, interpreter) could lead to interop with go or wasm?",0.0,go
16clv69,jzl6l3q,"Example: nodeJS and python are executable files and both of them have ""print"" functions no mater if I use it or not.",0.0,python
16cigsw,jztig15,I think the Erlang creator said Strand was even too parallel.,0.0,erlang
16cbcxd,,"* Go on using them for set literals, it'll make the math students happy.",0.8,go
16cbcxd,jzic08h,"In Scala, a list of statements with an optional final expression encased in {}s is an expression itself, which evaluates to the result of the final expression, or Unit if there is none.",0.0,scala
16cbcxd,jzic33i,"Why not use braces for them in addition to sets, like python does?",0.0,python
16cbcxd,jzmfwhy,I was briefly inspired by APL.,0.0,apl
16cbcxd,jzql7ho,"add3ToNum = {% + 3}  // add3ToNum(5) == 8     add2Nums = {%1 + %2}  // add2Nums(6, 8) == 14  (inspired by [Clojure function literals](https://clojure.org/guides/higher_order_functions#_function_literals))",0.5,clojure
16cbcxd,jzrrfgi,"Can you do something like JavaScript split:     `VOWELS = ""a e i o u"".split("" "");`",0.0,javascript
16cbcxd,jziwmul,One of my favorite Scala features that I wish other languages had.,0.1875,scala
16cbcxd,jzivcqn,"Elixir, for example, uses `{}` for tuples.",0.0,elixir
16cbcxd,jzsjph9,"I do but as `map {""a""::""A"", ""b""::""B"", ""c""::""C""}` just means the same as `map ""a""::""A"", ""b""::""B"", ""c""::""C""` ,there's no reason why anyone would prefer the former syntax.",0.0,c
16cbcxd,jziyhcs,"Lisp: `(progn expr1 expr2)`  Scheme: `(begin expr1 expr2)`  Clojure: `(do expr1 expr2)`  C: `(expr1, expr2)` [In some contexts]",0.0,lisp
16cbcxd,jziyhcs,"Lisp: `(progn expr1 expr2)`  Scheme: `(begin expr1 expr2)`  Clojure: `(do expr1 expr2)`  C: `(expr1, expr2)` [In some contexts]",0.0,scheme
16cbcxd,jziyhcs,"Lisp: `(progn expr1 expr2)`  Scheme: `(begin expr1 expr2)`  Clojure: `(do expr1 expr2)`  C: `(expr1, expr2)` [In some contexts]",0.0,clojure
16cbcxd,jziyhcs,"Lisp: `(progn expr1 expr2)`  Scheme: `(begin expr1 expr2)`  Clojure: `(do expr1 expr2)`  C: `(expr1, expr2)` [In some contexts]",0.0,c
16cbcxd,jziycap,"Because Erlang does too, and probably for that reason",0.0,erlang
16cbcxd,jzj2v9d,"Rust: `{ stmt; stmtOrExpr }`  Javascript lets you introduce arbitrary blocks for scoping purposes, but those blocks do not constitute an expression.",-0.1,rust
16cbcxd,jzj2v9d,"Rust: `{ stmt; stmtOrExpr }`  Javascript lets you introduce arbitrary blocks for scoping purposes, but those blocks do not constitute an expression.",-0.1,javascript
16cbcxd,jzka8f7,GNU C: `foo = ({ ... });` [statement expression](https://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/Statement-Exprs.html),-0.75,c
16cbcxd,jzl0hni,Seems like a cool feature,0.35,cool
16cbcxd,jzox1pa,The C code generated by my compiler uses it extensively.,0.0,c
16c9v0g,jzi9lo8,"Personally I much prefer equivalence graphs (egraphs, see Rust's eggs library https://docs.rs/egg/).",0.2,rust
16c9v0g,jzi9lo8,"They have the same rewriting benefits of inets but preserve the graph as they write, allowing you to check for contradictions (and therefore inconsistent rewrite rules) as you go.",0.0,go
16btfcg,,I just come across [this](https://www.youtube.com/watch?v=PhRFLKtJcSs) talk by someone involved with C# and was wondering if there are talks like this about other modern commonly used languages that explain the general design or some specific features of the language?,-0.03499999999999999,c
16btfcg,jzg61wl,[Simplicity is Complicated](https://youtu.be/rFejpH_tAHM) by Rob Pike (one of the creators of Go).,0.0,go
16btfcg,jzg0i4l,"Lex Fridman had a great talk with Chris Lattner, who made LLVM, Clang, and Swift.",0.8,swift
16btfcg,jzh5wvn,There's a bunch of talks about Ruby internals on the [Ruby Kaigi channel](https://youtube.com/@rubykaigi4884?si=vDqwDdUkt9TKrb2q).,0.0,ruby
16btfcg,jzhy6g4,https://dl.acm.org/toc/pacmpl/2020/4/HOPL  I know that searching for the Clojure one gets you the actual HOPL presentation.,0.0,clojure
16btfcg,jziyl1c,The host himself was very involved with Elm and is making his own language (Roc) so there are bits and pieces of language design in most episodes.,0.43333333333333335,elm
16btfcg,jziyl1c,* [Zig Hot Code Reloading](https://podcasts.apple.com/us/podcast/linking-binary-hot-code-loading-with-jakub-konka/id1602572955?i=1000612922247)  * [Speeding Up Rust's Compiler](https://podcasts.apple.com/us/podcast/speeding-up-rusts-compiler/id1602572955?i=1000604278780) (Former Rust Core Team)  * [Swift API Design](https://podcasts.apple.com/us/podcast/swift-and-unicode-api-design-with-rob-napier/id1602572955?i=1000598231422)  * [Static Types in Elixir](https://podcasts.apple.com/us/podcast/static-types-in-elixir-with-jos%C3%A9-valim/id1602572955?i=1000584470458) (creator of elixir)  * [Popularity of Languages](https://podcasts.apple.com/us/podcast/non-mainstream-programming-with-gabriella-gonzalez/id1602572955?i=1000566616444) (creator of Dhall)  * [Open Source Discussion](https://podcasts.apple.com/us/podcast/open-source-with-zig-creator-andrew-kelley/id1602572955?i=1000554066581) (Zig creator)   The Signals and Threads podcast also has a few good episodes on language internals.,0.20833333333333334,rust
16btfcg,jziyl1c,* [Zig Hot Code Reloading](https://podcasts.apple.com/us/podcast/linking-binary-hot-code-loading-with-jakub-konka/id1602572955?i=1000612922247)  * [Speeding Up Rust's Compiler](https://podcasts.apple.com/us/podcast/speeding-up-rusts-compiler/id1602572955?i=1000604278780) (Former Rust Core Team)  * [Swift API Design](https://podcasts.apple.com/us/podcast/swift-and-unicode-api-design-with-rob-napier/id1602572955?i=1000598231422)  * [Static Types in Elixir](https://podcasts.apple.com/us/podcast/static-types-in-elixir-with-jos%C3%A9-valim/id1602572955?i=1000584470458) (creator of elixir)  * [Popularity of Languages](https://podcasts.apple.com/us/podcast/non-mainstream-programming-with-gabriella-gonzalez/id1602572955?i=1000566616444) (creator of Dhall)  * [Open Source Discussion](https://podcasts.apple.com/us/podcast/open-source-with-zig-creator-andrew-kelley/id1602572955?i=1000554066581) (Zig creator)   The Signals and Threads podcast also has a few good episodes on language internals.,0.20833333333333334,swift
16btfcg,jziyl1c,* [Zig Hot Code Reloading](https://podcasts.apple.com/us/podcast/linking-binary-hot-code-loading-with-jakub-konka/id1602572955?i=1000612922247)  * [Speeding Up Rust's Compiler](https://podcasts.apple.com/us/podcast/speeding-up-rusts-compiler/id1602572955?i=1000604278780) (Former Rust Core Team)  * [Swift API Design](https://podcasts.apple.com/us/podcast/swift-and-unicode-api-design-with-rob-napier/id1602572955?i=1000598231422)  * [Static Types in Elixir](https://podcasts.apple.com/us/podcast/static-types-in-elixir-with-jos%C3%A9-valim/id1602572955?i=1000584470458) (creator of elixir)  * [Popularity of Languages](https://podcasts.apple.com/us/podcast/non-mainstream-programming-with-gabriella-gonzalez/id1602572955?i=1000566616444) (creator of Dhall)  * [Open Source Discussion](https://podcasts.apple.com/us/podcast/open-source-with-zig-creator-andrew-kelley/id1602572955?i=1000554066581) (Zig creator)   The Signals and Threads podcast also has a few good episodes on language internals.,0.20833333333333334,elixir
16btfcg,jzu4ofo,Here's an interview with C# and Typescript designer Anders Hejlsberg: https://www.youtube.com/watch?v=6udlQakSXZY,0.0,c
16btfcg,jzu4ofo,Here's an interview with C# and Typescript designer Anders Hejlsberg: https://www.youtube.com/watch?v=6udlQakSXZY,0.0,typescript
16bt12w,,"So the past few weeks I've been working on a new command-line text processor called LyraScript, written almost entirely in Lua.",-0.07840909090909091,lua
16bt12w,,"But then I started optimizing the record parser and even porting the split function into C via LuaJIT's FFI, and the results have been phenomenal.",0.5,c
16bt12w,,"Even pattern matching in LyraScript consistently surpasses Lua's builtin string.match(), sometimes by a significant margin according to my benchmarking tests.",0.3125,lua
16bt12w,,"Here are the stats for the equivalent implementations in vanilla Lua, Python, Perl, and Gawk:  |Language|Command|Execution Time| |:-|:-|:-| | LyraScript 0.9 | luv lyra.lua -P logins2.lua |28.35 seconds | | LuaJIT 2.1.0 | luajit logins.lua |43.65 seconds| | Python 2.6.6 | python logins.py |55.19 seconds | | Perl 5.10.1 | perl logins.pl |44.49 seconds | | Gawk 3.1.7 | awk -f logins2.awk |380.45 seconds |  Of course my goal is not (and never will be) to replace awk or sed.",0.0,lua
16bt12w,,"Here are the stats for the equivalent implementations in vanilla Lua, Python, Perl, and Gawk:  |Language|Command|Execution Time| |:-|:-|:-| | LyraScript 0.9 | luv lyra.lua -P logins2.lua |28.35 seconds | | LuaJIT 2.1.0 | luajit logins.lua |43.65 seconds| | Python 2.6.6 | python logins.py |55.19 seconds | | Perl 5.10.1 | perl logins.pl |44.49 seconds | | Gawk 3.1.7 | awk -f logins2.awk |380.45 seconds |  Of course my goal is not (and never will be) to replace awk or sed.",0.0,python
16bt12w,,"Here are the stats for the equivalent implementations in vanilla Lua, Python, Perl, and Gawk:  |Language|Command|Execution Time| |:-|:-|:-| | LyraScript 0.9 | luv lyra.lua -P logins2.lua |28.35 seconds | | LuaJIT 2.1.0 | luajit logins.lua |43.65 seconds| | Python 2.6.6 | python logins.py |55.19 seconds | | Perl 5.10.1 | perl logins.pl |44.49 seconds | | Gawk 3.1.7 | awk -f logins2.awk |380.45 seconds |  Of course my goal is not (and never will be) to replace awk or sed.",0.0,perl
16bt12w,jzgfh5v,"I don't know if Python 2.6.6 is useful for benchmarks, even Python 2.7 is no longer supported (let alone some 3.x releases).",0.3,python
16bt12w,jzgnh15,"Some time ago, before Perl 6 was renamed to Raku, I benchmarked Perl 6 vs C++ on a simple ""histogram"" task of counting the numbers of each byte value in a file.",0.0,perl
16bt12w,jzgnh15,"Some time ago, before Perl 6 was renamed to Raku, I benchmarked Perl 6 vs C++ on a simple ""histogram"" task of counting the numbers of each byte value in a file.",0.0,c++
16bt12w,jzgnh15,"On a 90M file, the C++ program took 2 seconds.",0.0,c++
16bt12w,jzgnh15,The Perl 6 program took 20 minutes.,0.0,perl
16bt12w,jzgnh15,"Tried it again just now on the Project Gutenberg copy of Treasure Island (pg120-images-3.epub, 79M):  0.26 seconds for the C++ program, 3m38s for the Raku program (Raku version 2023.02, running on an AMD Ryzen 5 5600G).",0.0,c++
16bt12w,jzgnh15,"Here's the Perl 6/Raku code:   `use v6;`   `my int @a; @a[$_]++ for $*IN.slurp-rest(:bin); say @a.join(""\n"");`     Perhaps comparing with C/C++ is unfair.",-0.5,perl
16bt12w,jzgnh15,Python 2?,0.0,python
16bt12w,jzgnh15,Why not Python 3?,0.0,python
16bt12w,jzgnh15,"And Perl 5.10 is over a decade old, current version is 5.38.",0.05,perl
16bt12w,jzml2tc,"As others have mentioned, you might see *different* numbers from a recent Python, but you won't see order-of-magnitude improvements especially if you go with a stock distribution.",0.0,python
16bt12w,jzml2tc,"As others have mentioned, you might see *different* numbers from a recent Python, but you won't see order-of-magnitude improvements especially if you go with a stock distribution.",0.0,go
16bt12w,jzml2tc,"You might try pypy if you want a speed race, but since Python efforts are mainly general-purpose, you'll probably blow past even that in anything that's heavy on your thing's forte.",-0.09444444444444444,python
16bt12w,jzqh9z7,Also test ruby please.,0.0,ruby
16bt12w,jzflqom,"And although perl is a more powerful alternative awk, its syntax is even less straightforward and cumbersome than awk, so that can take weeks to learn and master.",0.2520833333333333,perl
16bt12w,jzflqom,Lua in contrast is easy enough for most people to pick up in the matter of an hour or less thanks to it being modelled after Modula.,0.19333333333333336,lua
16bt12w,jzgj7xo,I'll be sure to repeat those benchmarks using latest stable release of Python.,0.5,python
16bt12w,jzsnfty,I repeated the benchmarks on Centos 7 with newer versions of Python and Perl.,0.0,python
16bt12w,jzsnfty,I repeated the benchmarks on Centos 7 with newer versions of Python and Perl.,0.0,perl
16bt12w,jzsnfty,Lyra 0.9a:   `luv lyra.lua -P logins2.lua took 41.47 seconds`  LuaJit 2.1.0b:   `luajit logins.lua took 53.90 seconds`  Python 2.7.5:   `python logins.py took 77.29 seconds`  Perl 5.16.3:   `perl logins.pl took 59.66 seconds`  Python 3.6.8:   `python3 logins.py took 72.12 seconds`  Python 2.7.18:   `/usr/local/bin/python2.7 logins.py took 77.66 seconds`  Perl 5.30.0:   `/usr/local/bin/perl logins.pl took 48.59 seconds`,0.0,python
16bt12w,jzsnfty,Lyra 0.9a:   `luv lyra.lua -P logins2.lua took 41.47 seconds`  LuaJit 2.1.0b:   `luajit logins.lua took 53.90 seconds`  Python 2.7.5:   `python logins.py took 77.29 seconds`  Perl 5.16.3:   `perl logins.pl took 59.66 seconds`  Python 3.6.8:   `python3 logins.py took 72.12 seconds`  Python 2.7.18:   `/usr/local/bin/python2.7 logins.py took 77.66 seconds`  Perl 5.30.0:   `/usr/local/bin/perl logins.pl took 48.59 seconds`,0.0,perl
16bt12w,jzj3mv3,"Those are some very interesting results, and certainly not what I would have expected from Perl 6 given that it was almost a full rewrite of the interpreter.",0.19821428571428573,perl
16bt12w,jzj3mv3,Or if it does then full credit would go to LuaJIT.,0.35,go
16bt12w,jzj3mv3,Even the newest server only has Perl 5.16 and Python 2.7.5 installed.,0.0,perl
16bt12w,jzj3mv3,Even the newest server only has Perl 5.16 and Python 2.7.5 installed.,0.0,python
16bt12w,jzj3mv3,"I don't really use Perl or Python for much of anything, so that's why I've never upgraded.",0.2,perl
16bt12w,jzj3mv3,"I don't really use Perl or Python for much of anything, so that's why I've never upgraded.",0.2,python
16bt12w,jzj3mv3,"I only decided to benchmark the custom pattern matching function last weekend, and I happened to use Perl and Python for sake of comparison.",0.0,perl
16bt12w,jzj3mv3,"I only decided to benchmark the custom pattern matching function last weekend, and I happened to use Perl and Python for sake of comparison.",0.0,python
16bt12w,jzj3mv3,"Given that LyraScript has potential, I'll definitely be upgrading to Perl 5.38 and Python 3, because I'm very curious whether they yield better results.",0.0925,perl
16bt12w,jzj3mv3,"Given that LyraScript has potential, I'll definitely be upgrading to Perl 5.38 and Python 3, because I'm very curious whether they yield better results.",0.0925,python
16bt12w,jzhq23u,"This is seriously cool, you should do an experience report writeup on using Lua to implement a language.",0.35,cool
16bt12w,jzhq23u,"This is seriously cool, you should do an experience report writeup on using Lua to implement a language.",0.35,lua
16bt12w,jzhq23u,"Python 3.12 should show a nice performance gain over 2.6.6, please do keep the 2.6.6 result around tho.",0.6,python
16bqvv3,,"Generally I try not to invent anything too unique for  https://www.oilshell.org/ , mostly basing it on established idioms  However there are some obvious use case for lazy args:      assert(42 == f(x))   # I want to write this, AND have a good error message     self.assertEquals(42, f(x))   # not this, like Python  And not this      if (42 != f(x)) { t.fail() }  # I think this is Go style  So the error will be something like:      Expected: f(x) to be 42     But got: -99  You can't print the f(x) without lazy evaluation.",0.15,python
16bqvv3,,"Generally I try not to invent anything too unique for  https://www.oilshell.org/ , mostly basing it on established idioms  However there are some obvious use case for lazy args:      assert(42 == f(x))   # I want to write this, AND have a good error message     self.assertEquals(42, f(x))   # not this, like Python  And not this      if (42 != f(x)) { t.fail() }  # I think this is Go style  So the error will be something like:      Expected: f(x) to be 42     But got: -99  You can't print the f(x) without lazy evaluation.",0.15,go
16bqvv3,jzexpa9,"You can do this in several languages (Python, Lua, etc.)",0.0,python
16bqvv3,jzexpa9,"You can do this in several languages (Python, Lua, etc.)",0.0,lua
16bqvv3,jzexpa9,For static languages there's stuff like `#[track_caller]` in Rust.,0.5,rust
16bqvv3,jzexpa9,"Or you could go the macro route, e.g.",0.0,go
16bqvv3,jzexpa9,Rust has `assert!,0.0,rust
16bqvv3,jzexpa9,"If something is going to mess around with evaluation order, it _should_ be apparent at the call site (like Rust's macros, or your `^[]` syntax).",-0.06249999999999999,rust
16bqvv3,jzexpa9,"The Python version is also ok since the evaluation is normal, it's just using the caller info to get additional metadata for printing.",0.325,python
16bqvv3,jzftosz,C# has this as a feature.,0.0,c
16bqvv3,jzftosz,"In C# you can define a function as `void Foo(Expression<Func<int, int>> expr) { ... }` and when you pass a lambda (and if needs to be a lambda), the compiler instead passes an expression tree that you can compile JIT and run, or that you can analyze or even modify like any expression tree at runtime, or even print.",0.0,c
16bqvv3,jzftosz,"Scala has ""by name parameters"", which are denoted as `def foo(arg: => int) = ...`, basically a lambda without parenthesis.",0.0,scala
16bqvv3,jzg3xqr,"Common Lisp:      CL-USER 45 > (defmacro assert1 (value equal form)                    (let ((result-sym (gensym ""result"")))                      `(let ((,result-sym ,form))                         (unless (,equal ,value ,result-sym)                           (error ""Expected: ~a to be ~a~%But got: ~a~%"" ',form ,value ,result-sym))                         ,result-sym)))     ASSERT1      CL-USER 46 > (defun foo (bar) (- bar 42))     FOO      CL-USER 47 > (let ((x -57))                    (assert1 42 = (foo x)))      Error: Expected: (FOO X) to be 42     But got: -99        1 (abort) Return to top loop level 0.",-0.1875,lisp
16bqvv3,jzg3xqr,Type :b for backtrace or :c <option number> to proceed.,0.0,c
16bqvv3,jzmdb63,"Based on your description, I'd normally expect that kind of thing to be addressed with ""quotation"" (as in LISP and ML (especially when actually used as a metalanguage in something like LCF)) instead of ""lazy evaluation"" because quotation gives you a way of accessing syntax itself as a value whereas lazy evaluation doesn't normally give any special access to syntax.",0.09464285714285714,lisp
16bqvv3,jzmdb63,It sounds like R blurs or ignores this distinction but I think that that's fairly unusual.,0.2,r
16bqvv3,jzmdb63,"For fine-grained control of lazy evaluation in a dynamic language, you could look at `delay` and `force` in Scheme.",-0.125,scheme
16bqvv3,jzf4886,"Hm  The other use cases I have for lazy Eval are  awk-like  or R-like filters      cat myfile.tsv | pretend-awk 'age > 50 { echo $record }'  In this case, `age` is not really a variable in the interpreter -- it's a column of the TSV file  R libraries use lazy evaluation in the same way, like in dplr      mytable %>% filter(age > 50)  As opposed to      mytable %>% filter(record$age > 50)   # this is more of an eager style, but not idiomatic   So yeah it's interesting to distinguish assert() vs. these other use cases.",0.018750000000000003,r
16bqvv3,jzh1ltc,"Oh very interesting, yeah we have an `Expr` type as well, and I was thinking of using that rather than `lazy`  C# does have a ton of features!",0.16875,c
16bqvv3,jzh1h5i,Though interestingly Python and JS both lack them,0.5,python
16bqvv3,jzg9zog,Just to add a bit about Rust macros.,0.0,rust
16bqvv3,jzg9zog,"(sqr(3), 9);  Would output the following when executed:      Expected: sqr(3) == 9     Received: 6 and 9  Now, whether you want to go the macro route or not, is of course a totally different question.",-0.03333333333333333,go
16bqvv3,jzg9zog,"However, since Rust was already mentioned, then I wanted to provide an example, of how it would look in Rust.",0.0,rust
16bqvv3,jzf4few,"Also I'll note that R doesn't make any distinction at the call site, which is arguably confusing, but most people seem to use it fine in practice  They kinda don't notice it's lazy ...",0.09166666666666667,r
16bqvv3,jzhu71p,"If I remember correctly, expressions were introduced to allow programmers to write type safe SQL In C# that's translated directly to proper server SQL queries - expressions are only translated and never actually run in C#.",0.125,c
16bqvv3,jzhu71p,"Basically whenever Microsoft wants to introduce a feature in one of their frameworks that doesn't quite work yet, C# gets a new feature.",0.16818181818181818,c
16bqvv3,jzhxiuz,"(nim for example has a universal syntax to solve this problem, but python doesn't).",0.0,python
16bqvv3,jzhxiuz,"For example in python, those two situations require very different byte code, so it couldn't depend on just the type of the caller, there would need to be a syntactic distinction.",0.0,python
16bqvv3,jzh1t2f,"Looks like lots of languages can do assertions with Macros  Python, JavaScript, and Go can't  But Rust, Nim, and Common Lisp can  And C# has some reflection features.",-0.3,python
16bqvv3,jzh1t2f,"Looks like lots of languages can do assertions with Macros  Python, JavaScript, and Go can't  But Rust, Nim, and Common Lisp can  And C# has some reflection features.",-0.3,javascript
16bqvv3,jzh1t2f,"Looks like lots of languages can do assertions with Macros  Python, JavaScript, and Go can't  But Rust, Nim, and Common Lisp can  And C# has some reflection features.",-0.3,go
16bqvv3,jzh1t2f,"Looks like lots of languages can do assertions with Macros  Python, JavaScript, and Go can't  But Rust, Nim, and Common Lisp can  And C# has some reflection features.",-0.3,rust
16bqvv3,jzh1t2f,"Looks like lots of languages can do assertions with Macros  Python, JavaScript, and Go can't  But Rust, Nim, and Common Lisp can  And C# has some reflection features.",-0.3,lisp
16bqvv3,jzh1t2f,"Looks like lots of languages can do assertions with Macros  Python, JavaScript, and Go can't  But Rust, Nim, and Common Lisp can  And C# has some reflection features.",-0.3,c
16bqvv3,jzjnrcd,Hm interesting ... Yeah I've been watching some videos with Hejlsberg and TypeScript.,0.5,typescript
16bqvv3,jzjnrcd,"TypeScript is impressive, but very ""maximalist""  C# seems similarly ""maximalist""  I guess similar to C++ -- for better or worse, the bar to add features is fairly low!",0.1857142857142857,typescript
16bqvv3,jzjnrcd,"TypeScript is impressive, but very ""maximalist""  C# seems similarly ""maximalist""  I guess similar to C++ -- for better or worse, the bar to add features is fairly low!",0.1857142857142857,c
16bqvv3,jzjnrcd,"TypeScript is impressive, but very ""maximalist""  C# seems similarly ""maximalist""  I guess similar to C++ -- for better or worse, the bar to add features is fairly low!",0.1857142857142857,c++
16bqvv3,jzjo62p,"You should look into Scala, it's the exact opposite.",0.125,scala
16bqvv3,jzjo62p,"Scala can do as complex things as C++, abstraction-wise.",-0.3,scala
16bqvv3,jzjo62p,"Scala can do as complex things as C++, abstraction-wise.",-0.3,c++
16bqvv3,jzjus9c,"Well, the main reason I use C++ is to manage memory, to do things like stack allocate value types.",0.16666666666666666,c++
16bqvv3,jzjus9c,"I learned how important that is by writing interpreters :-)  Seems like Scala can't have language control like that, because the JVM doesn't?",0.45,scala
16bqvv3,jzjus9c,I know Project Vala has been in the works for a long time  ---  So ironically C# wins there again ... pretty sure they've had value types for a long time.,0.19,c
16bqvv3,jzjus9c,"So each *type* in C# is either a class or struct, a reference or value?",0.0,c
16bqvv3,jzjus9c,"In C++ those things are orthogonal -- you can have a pointer to a struct, or copy the struct by value.",0.0,c++
16bqvv3,jzjus9c,I only took a quick look at C# but that seemed odd.,0.05555555555555555,c
16bqvv3,jzjus9c,"Although maybe it works out fine in practice  I think Go and C# are the main languages with value types and garbage collection, and I guess Swift.",0.2916666666666667,go
16bqvv3,jzjus9c,"Although maybe it works out fine in practice  I think Go and C# are the main languages with value types and garbage collection, and I guess Swift.",0.2916666666666667,c
16bqvv3,jzjus9c,"Although maybe it works out fine in practice  I think Go and C# are the main languages with value types and garbage collection, and I guess Swift.",0.2916666666666667,swift
16bqvv3,jzjxaig,There's scala native.,0.0,scala
16bqvv3,jzjxaig,And yeah C# has some odd quirks.,-0.16666666666666666,c
16bqvv3,jzjxaig,"But its runtime behavior is a lot more predictable than C++ overall, apparently (hearsay).",0.0875,c++
16bqvv3,jzjxaig,C# got a lot of features recently that allow you to work with value types on a level that's basically on par with C++.,0.0,c
16bqvv3,jzjxaig,C# got a lot of features recently that allow you to work with value types on a level that's basically on par with C++.,0.0,c++
16bqvv3,jzjxaig,"And when in doubt you can always literally write C code, with all the pointer arithmetic you need.",0.0,c
16bj33k,jzdjkel,"Mentioned Ada, but didn't go further [1C](https://web.archive.org/web/20200914235620/https://dwheeler.com/steelman/steelman.htm)?",0.0,ada
16bj33k,jzdjkel,"Mentioned Ada, but didn't go further [1C](https://web.archive.org/web/20200914235620/https://dwheeler.com/steelman/steelman.htm)?",0.0,go
16bj33k,jzenl8n,I can also achieve all that communication with the features available in C or Java.,0.4,c
16bj33k,jzenl8n,I can also achieve all that communication with the features available in C or Java.,0.4,java
16bj33k,jzenl8n,"On the other hand, even in Ada, or OCaml for that matter, you can entirely avoid the communication if you just work with basic types like integer and string.",-0.041666666666666664,ada
16bj33k,jzenl8n,"In practice, programmers don't generally wrap up their ints and strings in more specific types, at least not in C and Java.",0.06250000000000001,c
16bj33k,jzenl8n,"In practice, programmers don't generally wrap up their ints and strings in more specific types, at least not in C and Java.",0.06250000000000001,java
16anryg,jz8i654,"In Rust `self` can be `Self`, `&Self`, `&mut Self`, `Box<Self>`, `Rc<Self>`, etc.",0.0,rust
16anryg,jzb6w76,"Other reason to go with explicit self that was so far not mentioned is if it is possible to have two selves in the same scope - let's say, inside an instance function, you define a nested struct that itself has instance functions, and from those functions you see the scope of the enclosing function, like one can do in Java.",-0.006249999999999999,go
16anryg,jzb6w76,"Other reason to go with explicit self that was so far not mentioned is if it is possible to have two selves in the same scope - let's say, inside an instance function, you define a nested struct that itself has instance functions, and from those functions you see the scope of the enclosing function, like one can do in Java.",-0.006249999999999999,java
16anryg,jz8fwl2,"Rust uses explicit, it makes possible to add modifiers, like *mut* or *&* (reference)*.",0.0,rust
16anryg,jzb8lwv,"Do what Java does with `this`: Omit it by default, but permit it in case you need to attach annotations to it.",0.0,java
16anryg,jzb8lwv,"Alternatively, there’s C++’s colo(u)rf(o)ul habit of sticking `const`, `volatile`, and rvalue/lvalueness qualifiers to `this` (which should have had a reference type from the start, oops) after the function’s argument list, `int(const T *, S &)`↔`int (T::)(S &) const`.",0.0,c++
16anryg,jzdng4h,"I was motivated by [extension methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods) in C# where the ""self"" parameter is explicit but new methods can be defined out of the scope of the type declaration and still use object chaining (aka fluent) syntax.",0.13636363636363635,c
16anryg,jzhyci4,I'm partial to the Ruby approach: Use a sigil to denote object fields.,-0.1,ruby
16anryg,jz9d0mz,"Are they coming from Python, where *self* is explicit?",0.0,python
16anryg,jz9d0mz,"Or Java, where *this* is implicit?",0.0,java
16anryg,jzqg6tr,I hate that in python and there is no reason for it.,-0.8,python
16anryg,jz8crqb,Probably because of Python influence...,0.0,python
16anryg,jz8h6gc,But that's probably not a good idea :D .,0.325,d
16anryg,jz8gk29,"I don't know Rust, but I will check how it uses explicit self.",0.0,rust
16anryg,jz8zv20,"In Go, structs have methods but they are not classes, even though they can be composed.",0.0,go
16anryg,jz8dsho,What you’re suggesting is what Python did as a clever (at the time) hack to add OO.,0.16666666666666666,python
16anryg,jz9t4yq,"Self::myfunc could be a static method, but in Rust it’s really a thin layer of syntactic sugar.",0.04999999999999999,rust
16anryg,jz8hr7f,"Anyway, if you have such questions, Rust always gives a good answer.",0.35,rust
16anryg,jz914dw,"Go methods are not tied to structs, they are declared separately",0.0,go
16anryg,jz8hcet,I don't think that modern language should go with subtyping polimorphism and should instead focus on  parametric and row polymorphism.,0.2,go
16anryg,jz8ibxb,"Well, python has good reasons to have `self` as an explicit first argument.",0.475,python
16anryg,jzb00w0,"Rust has methods with no inheritance and they are either for  * namespacing (don't be so quick to dismiss, it's useful) * implementing traits, a more powerful form of abstract inheritance (you can implement ""static"" methods too)",0.38666666666666666,rust
16anryg,jz8fwjf,Of course renaming the first parameter into Me like i do it in python methods.,0.25,python
16anryg,jz8g8ks,You can do it in Python?,0.0,python
16anryg,jz8g8ks,:D I didn't know that.,1.0,d
16anryg,jz8hu7u,"Oh, if you aren't aware of that, I would strongly recommend looking into the python object model to understand what methods actually are in python.",0.22777777777777777,python
16anryg,jz8hu7u,"Descriptors, `__get__`, `__set_name__`, `staticmethod`, `classmethod` and metaclasses are all things you should understand if you want to be inspired by python's classes.",0.0,python
16anryg,jz8veq4,"For example, monomorphisation is a common source of code bloat in Rust, that might become explosive if functions are polymorphic over several arguments.",-0.15,rust
16anryg,jz8veq4,"Say, you have a type of form (I try to translate it into C++ syntax which I'm quite rusty at)       template class HFT <a> {      a left;      HFT <HFT <a>> * right;     }  Monomorphisation here will fail and, for example, Rust explicitly forbids this kind of types.",0.09642857142857142,c++
16anryg,jz8veq4,"Say, you have a type of form (I try to translate it into C++ syntax which I'm quite rusty at)       template class HFT <a> {      a left;      HFT <HFT <a>> * right;     }  Monomorphisation here will fail and, for example, Rust explicitly forbids this kind of types.",0.09642857142857142,rust
16anryg,jz8veq4,"But sometimes they are convinient, like when writing finger trees, and they are perfectly OK for Haskell.",0.5,haskell
16anryg,jzcmqam,"A common way to avoid infinite unfolding with generics/templates is with *F-bounded polymorphism*, or in C++ terminology, CRTP - the *curiously recurring template pattern*.",-0.2,c++
16anryg,jzcmqam,"template <typename a, typename Self>     class AbstractHFT {         a left;         AbstractHFT<a, Self> * right;     };      template <typename a>     class HFT : public AbstractHFT<a, HFT<a>> {         a left;         AbstractHFT<a, HFT<a>> * right;     };  If desired, the `Self` type argument can also be parameterized by a type (a *template template* in C++), which corresponds to a HKT, as in:      template <typename A, template <typename> Self>     class AbstractHFT {         a left;         Self<Self<a>> * right;     };      template <typename a>     class HFT : public AbstractHFT<a, HFT> {         a left;         HFT<HFT<a>> * right;     };  The latter approach is not possible with generics in C# though, as far as I'm aware.",0.10663265306122449,c++
16anryg,jzcmqam,"template <typename a, typename Self>     class AbstractHFT {         a left;         AbstractHFT<a, Self> * right;     };      template <typename a>     class HFT : public AbstractHFT<a, HFT<a>> {         a left;         AbstractHFT<a, HFT<a>> * right;     };  If desired, the `Self` type argument can also be parameterized by a type (a *template template* in C++), which corresponds to a HKT, as in:      template <typename A, template <typename> Self>     class AbstractHFT {         a left;         Self<Self<a>> * right;     };      template <typename a>     class HFT : public AbstractHFT<a, HFT> {         a left;         HFT<HFT<a>> * right;     };  The latter approach is not possible with generics in C# though, as far as I'm aware.",0.10663265306122449,c
16anryg,jzcmqam,"Another potential approach is to have a template method in a template type (or generic method in generic type, which is also possible with C#'s generics).",0.0,c
16anryg,jzcmqam,"template <typename a>     class HFT {         a get_left();              template <typename b> requires convertible_to<b, HFT<a>>         HFT<b> * get_right();     }  My C++ is also a bit rusty.",0.0,c++
16an2gx,,"The biggest project I've worked on so far was a start to a software renderer using the SDL library (Vortex offers C interop out of the box, so adding new libraries for the sake of testing/project building isn't too hard).",0.01117424242424242,c
16an2gx,jzdiwd6,"For Inko:  - [A program to control my HVAC system](https://github.com/yorickpeterse/openflow) - [A Markdown parser/converter](https://github.com/yorickpeterse/inko-markdown) (part of [this larger effort](https://github.com/inko-lang/inko/issues/597)) - [A library for generating XML and HTML](https://github.com/yorickpeterse/inko-builder), part of the same effort  All were quite helpful in finding bugs/stress testing the language, with the first one being the most helpful due to being the most complex.",0.009375000000000001,html
16ajy9g,,[https://youtube.com/watch?v=gV7jhTMYkKc&si=e7HpfuPoLsLHqHOP](https://youtube.com/watch?v=gV7jhTMYkKc&si=e7HpfuPoLsLHqHOP)  A very wise C++ programmer reinvents Ada.,0.9099999999999999,c++
16ajy9g,,[https://youtube.com/watch?v=gV7jhTMYkKc&si=e7HpfuPoLsLHqHOP](https://youtube.com/watch?v=gV7jhTMYkKc&si=e7HpfuPoLsLHqHOP)  A very wise C++ programmer reinvents Ada.,0.9099999999999999,ada
16ajy9g,,":-)  (Okay, maybe not entirely fair, but using distinct, incompatible specific integer subtypes just reminded me of Ada.)",0.19,ada
16ajy9g,,"In C, one style for adding flags like to his print function would be just one enum:  In Pascal (and Ada?)",0.0,c
16ajy9g,,"In C, one style for adding flags like to his print function would be just one enum:  In Pascal (and Ada?)",0.0,pascal
16ajy9g,,"In C, one style for adding flags like to his print function would be just one enum:  In Pascal (and Ada?)",0.0,ada
16ajy9g,,"For example in C, you tend to pass strings around as char pointers without being specific about it being a zero-terminated string, as that is just the accepted convention.",0.0,c
16ajy9g,,But you can have nominal type compatibility in C with structs.,0.0,c
16ajy9g,,"For historic reasons, C got `long` from Algol68, and there has always been some confusion about how ~~bit~~ big certain int sizes are, with people (and many new languages) tending to prefer the pragmatic int16, int24, int64, uint16, uint32, uint64 or some similar naming convention.",0.11437847866419294,c
16ajy9g,,"Pascal descendant languages, such as Ada, use the explicit range approach instead, in addition to encouraging making new subrange types and making the types tighter that way.",0.06818181818181818,pascal
16ajy9g,,"Pascal descendant languages, such as Ada, use the explicit range approach instead, in addition to encouraging making new subrange types and making the types tighter that way.",0.06818181818181818,ada
16ajy9g,jzcvlbb,"You're not wrong about Ada and it reminds me of something I recently read:  >During the design of the software system, the developer must select types that best model the data in the system and that are appropriate for the algorithms to be used.",0.4375,ada
16ajy9g,jzcvlbb,"If a program is written with every variable declared as Integer, Float or Character, it will not be taking advantage of the capabilities of Ada.",0.0,ada
16ajy9g,jzepist,"People have [proposed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4172.htm) named arguments for C++, but it never got traction.",0.0,c++
16ajy9g,jzepist,"In part, because C++ has function overloading, which greatly complicates figuring out which values would be bound to which parameter of which function.",0.8,c++
16ajy9g,jzepist,"As a hacky workaround, in C and C++, struct initializers can use named fields in a way that's pretty similar to how keyword arguments work in other languages.",0.041666666666666664,c
16ajy9g,jzepist,"As a hacky workaround, in C and C++, struct initializers can use named fields in a way that's pretty similar to how keyword arguments work in other languages.",0.041666666666666664,c++
16ajy9g,jzepist,"So you could do something like this:      typedef struct {         const char *name;         bool baz, qux;     } foo_args_t;     #define foo(...) _foo((foo_args_t){__VA_ARGS__})     void _foo(foo_args_t args) {         printf(""I got %s %d %d\n"", args.name, args.baz, args.qux);     }      // kwargs-like syntax (absent fields default to zero)     foo(""MyName"", .baz=true);     foo(.name=""Bob"", .qux=true);",0.0,d
16ajy9g,jzobkfd,Lanuages like Pascal and especially Ada tend to go for more strict data representations; whereas C (and maybe also derivatives) tend to be more loose.,0.23076923076923078,pascal
16ajy9g,jzobkfd,Lanuages like Pascal and especially Ada tend to go for more strict data representations; whereas C (and maybe also derivatives) tend to be more loose.,0.23076923076923078,ada
16ajy9g,jzobkfd,Lanuages like Pascal and especially Ada tend to go for more strict data representations; whereas C (and maybe also derivatives) tend to be more loose.,0.23076923076923078,go
16ajy9g,jzobkfd,Lanuages like Pascal and especially Ada tend to go for more strict data representations; whereas C (and maybe also derivatives) tend to be more loose.,0.23076923076923078,c
16ajy9g,jzobkfd,Looseness become a problem in C in particular when you want to design library code for general use: this often involves losing the type completely and dealing with void pointers.,0.10555555555555556,c
16ajy9g,jzobkfd,"In Pascal you could declare a FILE OF <some type>, in C, you just pass an address and a size to fread and fwrite, which is not inherently safe.",0.5,pascal
16ajy9g,jzobkfd,"In Pascal you could declare a FILE OF <some type>, in C, you just pass an address and a size to fread and fwrite, which is not inherently safe.",0.5,c
16ajy9g,jzobkfd,"It works if you do it right, but if you make a mistake, it may go wrong in the strangest ways.",-0.10714285714285715,go
16ajy9g,jzobkfd,"I also find the distinction in for example HTML (and XML), Which is the right way: <B> and <I> tags, <STRONG> and <EM> tags - or just a <span> with some CSS class setting the font style to bold or italic?",0.30952380952380953,html
16ajy9g,jzcx1g6,"Generics cover some things, interfaces (as in Go) cover others.",0.0,go
16ajy9g,jzoqpbg,"I suppose C++ would let you do that with templates, but I don't know if anybody would do that.",0.0,c++
16ajy9g,jzorqrg,"As a funny coincidence, there is a discussion on r/C_Programming just now, which shows how the looseness of C's fread can lead to confusion for novice C programmers...",0.25,c
16ajfsq,,First off I apologize if this sounds crass and does not go with the FLOSS ideals that mot you guys posses.,0.25,go
16ajfsq,,"The story is, I read a book called 'Crafting Interpreters' which mentioned ""JavaScript transpilers"" in its epilogue and I was not really aware of 'transpilers' so to speak and they sound like finite-state transducers --- I have tried and failed my friend at making a browser extension with JS and that is the extent of my attempts at doing web dev.",-0.075,javascript
16ajfsq,,"If I make a highly general and unspecific gig, like, say ""I will make your shell scripts"", then I better do it for negative a hundred dollars and pay people to hire me!",0.05833333333333335,shell
16ajfsq,,"Now if say, I make a gig called ""I will make shell scripts with my custom meta-programming recipes"" then it will definitely alienate a lot of people because most people don't view 'code generation' and 'meta programming' (if they truly comprehend it, that is) as something 'smart', they would think I am freaking lazy for generating inline code with ePerl, GPP and m4!",0.10044642857142858,shell
16ajfsq,,"Nobody's unique, and as that massive C told me a few years back ""just because you are different that does not mean you are unique"" and the C was right, you ain't unique because you are different, you're a freakin' freak of the freak show.",0.13669642857142858,c
16ajfsq,jz7pwyb,"> money is in web, and money is not in my pocket  If this is the route you want to go.",0.0,go
16ajfsq,jz7pwyb,React + TypeScript = High probability of getting a web job.,0.16,typescript
16ajfsq,jz7w5em,"Otherwise, and you won't like it; Go into a different branch of CS.",0.0,go
16ajfsq,jz9vof6,"JavaScript transpilers are just compilers that target JavaScript as a platform (e.g., for running code in the browser, or for using a better language in projects that rely on JS-based environment).",0.5,javascript
16ajfsq,jzpjbpo,"but wanna use Delphi, and found a way to bring a Delphi utility that runs on a floppy disk - I have created my own ORMs which is an interesting application of the ideas of PLs, now that I know better!",0.5750000000000001,delphi
16ajfsq,jzpjbpo,"- I inject Python scripts into Delphi .exes to personalize logic - I have used tech/languages that are/were more ""niche"" and this allows me to get jobs without fighting against bazillions of JS developers (Delphi, F#, PostgreSQL, Rust, ...)   And more to the point, working for fun at https://tablam.org landed me a job working on https://spacetimedb.com, where I'm doing the `vm, sql translation/validation, type checker, query optimizer` and other stuff.",0.29375,python
16ajfsq,jzpjbpo,"- I inject Python scripts into Delphi .exes to personalize logic - I have used tech/languages that are/were more ""niche"" and this allows me to get jobs without fighting against bazillions of JS developers (Delphi, F#, PostgreSQL, Rust, ...)   And more to the point, working for fun at https://tablam.org landed me a job working on https://spacetimedb.com, where I'm doing the `vm, sql translation/validation, type checker, query optimizer` and other stuff.",0.29375,delphi
16ajfsq,jzpjbpo,"- I inject Python scripts into Delphi .exes to personalize logic - I have used tech/languages that are/were more ""niche"" and this allows me to get jobs without fighting against bazillions of JS developers (Delphi, F#, PostgreSQL, Rust, ...)   And more to the point, working for fun at https://tablam.org landed me a job working on https://spacetimedb.com, where I'm doing the `vm, sql translation/validation, type checker, query optimizer` and other stuff.",0.29375,rust
16ajfsq,jz7wswr,"There is a saying in English that goes ""If Mohammad does not go to the mountain, the mountain comes to Mohammad"" --- and funnily enough, it is my birthname (although because it is an Arabic name and I take pride in being ethnically Iranic and Persian, I go by Chubak, only my family knows me by this name) --- so let the mountain come to me, or rather, pile up sandbuckets on top of sandbuckets to make my own mountain as I climb on top of it.",0.26666666666666666,go
16ajfsq,jz7wswr,For example:  \+ mlsh -> an ML-based shell!,-0.3125,shell
16ajfsq,jz7wswr,"With the ability to not only run natively under Windows and UNIX, but also, transduce between PowerShell and Bash!",0.0,bash
16ajfsq,jz944yg,"Not so many people can manage memory in C and at the same time, know LambdaCalc.",0.25,c
16ajfsq,jz944yg,Not so many people know how to code both in Aarch64 and x86-64 Assembly WITHIN MY PRICE RANGE AND MY CLASS!,0.625,assembly
16ajfsq,jz944yg,Go on Fiverr right now and you will see people offering their services in various frameworks.,0.14285714285714285,go
16ajfsq,jz944yg,"Neither of us were really keen on being a pawn in Natanyaho and Khemenei's 1e-23D Chess, so we decided not to go through with the deal.",0.2,go
16ajfsq,jzh2sch,I have chosen to go by the latter.,0.0,go
16a1hgd,jz6kjak,More direct link: [https://www.youtube.com/watch?v=fSqE-HSh\_NU](https://www.youtube.com/watch?v=fSqE-HSh_NU)  Haskell is one of extremely few lazy languages.,-0.12000000000000002,haskell
16a1hgd,jz6kjak,There's nothing half-assed about Haskell's evaluation strategy.,0.0,haskell
16a1hgd,jz6kjak,What's great about a language *like* Haskell is that you can treat the code as having *denotational* semantics and let the computer figure out suitable operational steps.,0.675,haskell
16a1hgd,jz6kjak,"We're delegating a bunch of clerical details to *the machine* and of course in the beginning that's going to be a source of inefficiency, but remember Fortran.",0.0,fortran
16a1hgd,jz71t2z,"It's very easy to, say, write C code in a way that such analysis would fail, and compiler would produce suboptimal results despite programmer's best intent.",0.26583333333333337,c
16a1hgd,jz71t2z,"Haskell is a great language, yet, it's not that difficult to accidentally write some Haskell code for which the strictness analysis would fail.",-0.06666666666666665,haskell
16a1hgd,jz71t2z,"Doesn't it look like the lazyness advocates too often ignore the fact that ""Haskell performance engineering"" work still requires dealing with non-ideal code and non-ideal compilers in a non-trivial way?",0.0,haskell
16a1hgd,jz99hy0,> What's great about a language *like* Haskell is that you can treat the code as having *denotational semantics* and let the computer figure out suitable operational steps.,0.675,haskell
16a1hgd,jz99hy0,"For what it's worth, Haskell by default has it *worse* in terms of denotational semantics, because it allows bottom computations to live anywhere in your data structures and because it makes inductive types not necessarily well-founded (they could be infinite), preventing inductive reasoning.",0.00909090909090908,haskell
16a1hgd,jz9anvi,"Yes, the Haskell community has a long history of assuming that the compiler will optimize everything based on simplistic single-module experiments which completely fail to account for the fact that these optimizations don't really work across modules.",-0.21250000000000002,haskell
16a1hgd,jzlgfdb,"> Doesn't it look like the lazyness advocates too often ignore the fact that ""Haskell performance engineering"" work still requires dealing with non-ideal code and non-ideal compilers in a non-trivial way?",0.0,haskell
16a1hgd,jzlgfdb,There are radically different takes on strict/eager vs lazy evaluation that don't suffer from the problems Haskell's take introduces and GHC then struggles to mitigate.,-0.125,haskell
16a1hgd,jzlgfdb,So it suffers *none* of the optimization pitfalls Haskell introduces.,-0.6,haskell
16a1hgd,jz6fjj2,"And, separately, I (and others) get a lot of mileage out of laziness in Haskell, even when I'm not doing anything parallel.",0.0,haskell
16a1hgd,jzmwsdz,I don't think that optimizations in GHC are really a pitfall of Haskell.,0.2,haskell
16a1hgd,jzmwsdz,"My criticism was not about Haskell as a language, but rather about people overselling potential capabilities of a practical Haskell compiler to optimize lazy code.",-0.125,haskell
16a1hgd,jzvqv1k,"Haskell and GHC are *explicitly distinguished* in my comment, not ""mixed""!)",0.0,haskell
16a1hgd,jzvqv1k,> I don't think that optimizations in GHC are really a pitfall of Haskell.,0.2,haskell
16a1hgd,jzvqv1k,> My criticism was ... about people overselling potential capabilities of a practical Haskell compiler to optimize lazy code.,-0.125,haskell
16a1hgd,jzvqv1k,it was an important complement to Haskell becoming a wider successor to Miranda.,0.42500000000000004,haskell
16a1hgd,jzvqv1k,"Rakudo, a Raku implementation, which has an analogous status to GHC viz Haskell, and Rakudo's backends, *do* incorporate ongoing optimization work (16 years worth so far), but none of it is relevant to *laziness*.",0.26666666666666666,haskell
169v3dn,,"I took a look at the books ""Advanced Design and Implementation of Virtual Machines"" by Xiao Feng and ""Inside the Python Virtual Machine"" by a fella called Obi Ike-Nwsou.",0.4,python
169v3dn,,I then pulled all the Python VM ISA from [this webpage](https://unpyc.sourceforge.net/Opcodes.html) and I think this ISA should handle most tasks right?,0.39285714285714285,python
169v3dn,,"My C files are all meta-progg'd --- for example, so far, I have this:  ``` #!/usr/bin/eperl <<< opcodes.ls #!/usr/bin/gpp --include ""jit.gpp""  #include <libgccjit.h> #include <stdlib.h> #include <stdint.h>   // this ePerl block saves opcodes in a dictianry <: chomp(@opcodes = <STDIN>); %OPCODES = (); $code = 0x1;         foreach $opcode (@opcodes) {                 %OPCODES{$opcode} = $code++;         }         _ :>  // this ePerl block prints all the JIT types as jit_<type>_t // https://gcc.gnu.org/onlinedocs/jit/topics/objects.html <: @types = qw/ object location type struct field function block rvalue lvalue param ca se /; foreach $type (@types) {         printf(""typedef gcc_jit_%s jit_%s_t;\n"", $type  ); } :>   ~ ```  So as I said, any opinion is appreciated.",0.12125,c
169v3dn,jz46uae,"I'd add that if OP is doing a stack VM, looking at the JVM ""assembly"" won't hurt",0.0,assembly
169v3dn,jz4bnov,"I could yet add another opcode, NULL, wherein I push a C (void\*(0)) or the macro NULL on top of the stack.",0.5,c
169v3dn,jz4bnov,This can be used for Python's None value.,0.0,python
169v3dn,jz4bnov,"Speaking of Python, do you recommend using PEG for a Python parser?",0.0,python
169v3dn,jz4bnov,The LL(1) nature of Python's grammar calls for a recursive-descent parser and I am not too keen on using YACC/Bison for it.,0.0,python
169v3dn,jz4bnov,The only RDP-stlye parser on the FLOSS parker is PEG (I would be using LEG if I would wanna go through with using PEG --- LEG is an extension of PEG and you can download a LEG parser generator just by installing the C 'peg' program off a package manager like Aptitude).,0.0,go
169v3dn,jz4bnov,The only RDP-stlye parser on the FLOSS parker is PEG (I would be using LEG if I would wanna go through with using PEG --- LEG is an extension of PEG and you can download a LEG parser generator just by installing the C 'peg' program off a package manager like Aptitude).,0.0,c
169v3dn,jz55l6r,Python ISA had it.,0.0,python
169v3dn,jz4dm71,In my extensions to Python I will make the VM load all the syscalls that sys/syscall.h has to offer dynamically.,0.0,python
169v3dn,jz4dm71,Windows has like 500-odd system calls which you have to go through hell to access.,0.0,go
169v3dn,jz4dm71,I am not sure how I would go about adding Windows system calls.,-0.25,go
169v3dn,jz4dm71,For example a C frontend.,0.0,c
169v3dn,jz4dm71,"PCC has a separate frontend for C, I believe.",0.0,c
169v3dn,jz4dm71,There are some issues with a C interpreter though.,0.0,c
169v3dn,jz4dm71,A VM by design is high-level and C is an extremely low-level language.,-0.125,c
169v3dn,jz4dm71,"So I will probably end up adding a ""Creole C"" frontend.",0.0,c
169v3dn,jz4dm71,"Just so you know, there is this C compiler that has a psuedo-interpret option.",0.0,c
169v3dn,jz4dm71,It's called TCC --- or Tiny C Compler.,0.0,c
169v3dn,jz57yau,Python has this inconsistency?,0.0,python
169v3dn,jz6d87c,> I am not sure how I would go about adding Windows system calls.,-0.25,go
169mk1s,,"Idea one from me: ""procedural texture generation""  I found one cool idea on the net... adding ""procedural texture generation"".",0.175,cool
169mk1s,,So I added that as a background for my IDE :) Looks cool!,0.46875,cool
169mk1s,,|int|         s     ||      r     p     |int|  bartholemew     ||      i     e     ||      n     d            No idea if that is even a fun idea... or how the compiler would see this haha.,0.25,r
169mk1s,,|int|         s     ||      r     p     |int|  bartholemew     ||      i     e     ||      n     d            No idea if that is even a fun idea... or how the compiler would see this haha.,0.25,d
169mk1s,jz59xff,"Each variable is stored under a ""symbol"", which looks like this: ```lisp :mySymbol :anotherSymbol/hd3728sa ``` Any valid set of characters without a space or quotation mark, and starting with a colon becomes a symbol.",0.0,lisp
169mk1s,jz59xff,"This means to store a value in a local variable under the symbol `:x`, you can do: ```lisp (store :x <value>) ``` This is great.",0.4,lisp
169mk1s,jz59xff,"```lisp (store :<unknown value> 10) ``` Well, this is where the `symbol` command comes in handy.",0.6,lisp
169mk1s,jz59xff,"```lisp (store (symbol ""myName"") 10)   ``` What this does is: - Generate a symbol  - Store 10 in it's value under local variables.",0.0,lisp
169mk1s,jz59xff,"Because each command can handle symbols differently, this is possible: ```lisp ;; local store (store :x 10) ;; global store (globals.store :x 10) ;; load local (load :x) ;; load global (globals.load :x) ``` This can even be applied to functions!",0.0,lisp
169mk1s,jz59xff,```lisp (function :myFunction (   ;; do stuff.. )) ``` The `:myFunction` is also a symbol.,0.0,lisp
169mk1s,jz59xff,"Here's one possible way of calling randomly from a set of functions: ```lisp (call (symbol (tostring (randomInt 1 3))))  (function :1 (   (console.log ""Function 1 was called!"")",-0.3125,lisp
169mk1s,jzbkdjf,"And it executed by highlighting the current instruction being evaluated (which would then go left, or right, or up, or down).",0.03253968253968253,go
169mk1s,jzhj8ne,"This looks kinda like Lua's `_G[""myName""] = ""value""`",0.0,lua
169mk1s,jzbfgld,It’s written in Kotlin!,0.0,kotlin
1693k8n,jz0gliq,See section 14 here: https://homepages.inf.ed.ac.uk/wadler/papers/orwell/orwell2.pdf Orwell was one of the precursor languages to Haskell during the proliferation period of various competing lazy functional languages in the 80s.,-0.125,haskell
1693k8n,jz0gliq,"The other language that I can think of is the case statement of Ada, which is described here: https://learn.adacore.com/courses/intro-to-ada/chapters/imperative_language.html#imperative-language-case-statement Ada does not have algebraic data types afaik, and the case statement is restricted to integer and enum types, but it allows ranges and checks that no two cases are overlapping, and fails to compile if it detects overlapping cases.",-0.3125,ada
1693k8n,jz0gliq,"Personally, I think it would be very cool for a language to pursue this direction again in detail.",0.22749999999999998,cool
1690zrr,,"In C memory allocation is a regular function call (`malloc`), which returns `NULL` pointer on failure.",-0.15833333333333335,c
1690zrr,,"However, C has no principled error handling mechanism.",0.0,c
1690zrr,,"While C++ let's you do whatever you want too, the idiomatic approach is to report errors by throwing exceptions, and indeed memory allocation failure is reported by throwing `std::bad_alloc` exception.",-0.3166666666666667,c++
1690zrr,,"Rust has clean non-exception-based error handling via `Result<T, E>` however it doesn't report memory allocation failures this way.",0.3666666666666667,rust
1690zrr,,"In principle, there is nothing which prevents Rust from doing it, aside from the fact that this would lead to a clunky interfaces where almost everything returns `Result`  where the only possible error it can contain is the memory allocation failure.",-0.10555555555555557,rust
1690zrr,,So most Rust code (including standard library) assumes memory allocation cannot fail.,0.0,rust
1690zrr,jyyvhz8,"It would be entirely possible to implement exceptions without the C++ issues as a syntactic sugar on top of result-types, basically just having hidden return types that can only be accessed via `catch` or a similar construct (in fact, Herb Sutter [proposed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf) this for C++).",0.06666666666666668,c++
1690zrr,jyyusgz,Rust does have memory allocation which returns a Result as part of the nightly/experimental allocator API.,0.0,rust
1690zrr,jyzdc4d,"For example, conditions (as in the common lisp condition system) bear some semblance to exceptions, but also some marked differences; one can imagine making a condition handler for an out-of-memory condition which frees up some cached data and then retries the allocation, for instance, whereas this would not be very practical with plain exceptions.",-0.05357142857142856,lisp
1690zrr,jz0zm61,"If, OTOH, you just want to be able to recover from failure of specific allocations you know might be problematic, Rust has methods like `Vec::try_reserve` to handle those cases.",0.061111111111111095,rust
1690zrr,jz02nja,You're not quite right about the C++ model here.,0.2857142857142857,c++
1690zrr,jz17w97,"A lot of managed languages actually have this capability today via weak/shadow references including Java, JavaScript, and especially Racket.",0.0,java
1690zrr,jz17w97,"A lot of managed languages actually have this capability today via weak/shadow references including Java, JavaScript, and especially Racket.",0.0,javascript
1690zrr,jyzw4mi,"Functions with error returns have an easy, well defined C ABI representation making them useful when people want FFI *to* C3.",0.3666666666666667,c
1690zrr,jz50pn5,One approach used by the Boehm GC and other allocator libraries for C and C++ is to let the user provide a an out-of-memory (OOM) handler function that will be called when allocation failure occurs and return whatever value it provides (if any).,-0.22083333333333335,c
1690zrr,jz50pn5,One approach used by the Boehm GC and other allocator libraries for C and C++ is to let the user provide a an out-of-memory (OOM) handler function that will be called when allocation failure occurs and return whatever value it provides (if any).,-0.22083333333333335,c++
1690zrr,jz50pn5,"The C version is pretty verbose, but you could improve that using macros:      CUSTOM_OOM_BEHAVIOR {         value = compute_result();     } ON_OOM {         value = NULL;     } END_OOM     return value;",0.25,c
1690zrr,jyz69ma,Assuming I got a cool 1 mil on the condition that I added it... it wouldn't be hard to add.,0.029166666666666646,cool
1690zrr,jyz51n1,> It would be entirely possible to implement exceptions without the C++ issues as a syntactic sugar on top of result-types  Sure.,0.3333333333333333,c++
1690zrr,jyz51n1,"Rust's `?`) a good thing, since it makes otherwise hidden control flow explicit.",0.26666666666666666,rust
1690zrr,jyz3li2,"However, since `Box::new` isn't going anywhere and has existed for far longer, most Rust code is written against `Box::new`, rather than `Box::try_new`.",0.3,rust
1690zrr,jyz5jzd,"Yeah, I feel like you’d have to write a new Rust dialect with a new “standard” library built on core and alloc to achieve this.",0.0909090909090909,d
1690zrr,jyz5jzd,"Yeah, I feel like you’d have to write a new Rust dialect with a new “standard” library built on core and alloc to achieve this.",0.0909090909090909,rust
1690zrr,jyz5jzd,"Which is akin to what they’re doing to get Rust in the Linux kernel, but I wouldn’t recommend it generally.",0.05000000000000002,rust
1690zrr,jz1bvay,"Certainly not the easiest, but not like C++ where something like this would have no unified syntax.",-0.10714285714285714,c++
1690zrr,jyzsv2l,"There are some notable exceptions, like writing code for the Linux kernel (this was one of Torvald’s main issues with Rust iirc).",0.3333333333333333,rust
1690zrr,jzg5zkk,"In Common Lisp conditions, the stack is not unwound.",-0.3,lisp
1690zrr,jzg5zkk,"Let's say we have a stack overflow error in LispWorks, a Common Lisp implementation:      CL-USER 49 > (defun foo (n) (if (zerop n) 1 (+ 1 (foo (1- n)))))     FOO      CL-USER 50 > (foo 1000000)      Stack overflow (stack size 17997).",-0.3,lisp
1690zrr,jzg5zkk,Type :b for backtrace or :c <option number> to proceed.,0.0,c
1690zrr,jzg5zkk,On a Lisp Machine one could for example exceed virtual memory.,0.0,lisp
168yh7q,,"Hi all,  There's a series of short videos (currently 4) on laziness in Haskell.",0.0,haskell
168yh7q,,Highly recommended for all PLDI'rs interested in seeing from the eyes of Haskell.,0.20500000000000002,haskell
1686ysr,jyvzcvf,"This is exactly equivalent to python's generators, using `def __call__(self, x=None): return self.send(x)` (Python doesn't need both `.send` and `.__next__` calls).",0.25,python
1686ysr,jyvzcvf,"So yes, it should be enough, but there are reasons why python separated out the features.",0.0,python
1686ysr,jyv6bdb,Python's first official async implementation was all generators before it was given official syntax.,0.25,python
167oefv,,"moddable in this case meaning being able to modify the behavior of existing code through injection rather than straight up overwriting it  i know it's pretty possible to do with java, and i recently got into modding Payday 2 where i encountered lua modding outside of an embedded context for the first time (Payday 2 is almost entirely written in luajit) and was amazed how much and how easily i could change things through simple injection  there are however still issues, if you want to modify how a part of a function works for instance, you need to overwrite the whole function, which only one mod can do at a time, meaning inter-mod compatibility issues  that got me wondering: what's the most moddable programming language?",0.18222222222222223,java
167oefv,,"moddable in this case meaning being able to modify the behavior of existing code through injection rather than straight up overwriting it  i know it's pretty possible to do with java, and i recently got into modding Payday 2 where i encountered lua modding outside of an embedded context for the first time (Payday 2 is almost entirely written in luajit) and was amazed how much and how easily i could change things through simple injection  there are however still issues, if you want to modify how a part of a function works for instance, you need to overwrite the whole function, which only one mod can do at a time, meaning inter-mod compatibility issues  that got me wondering: what's the most moddable programming language?",0.18222222222222223,lua
167oefv,jyu88je,I think Forth.,0.0,forth
167oefv,jyva39m,Assembly.,0.0,assembly
167oefv,jyva39m,> java  Java does not let you do any of that.,0.0,java
167oefv,jyva39m,Especially since everything in Lisp is an AST.,0.0,lisp
167oefv,jyva39m,"(defn foo []         (println ""h""))     (defn main []         (do             (set-instr ""Ü"" (get-child 1 (get-child 1 foo)))             (foo))) ;prints funny German face     ;some Lisp I wrote one day  Also there are people who just invoke (if not embed) GCC in their programme and use it in JIT mode to modify things.",0.13888888888888887,lisp
167oefv,jywr5qj,Lisp and assembly.,0.0,lisp
167oefv,jywr5qj,Lisp and assembly.,0.0,assembly
167oefv,jywr5qj,Assembly lets you do anything the CPU allows.,0.0,assembly
167oefv,jywr5qj,"On Lisp, you have hygienic macros.",0.0,lisp
167oefv,jywr5qj,And domain-specific languages are normal in the Lisp world.,0.15,lisp
167oefv,jz0dp2x,"FixScript also has other features suitable for game scripting (such as backward and forward compatibility, minimal standard library, time limits, good interoperability with C, JIT).",0.08928571428571429,c
167oefv,jyx8zi1,Lisp is one of the more moddable.,0.5,lisp
167oefv,jyx8zi1,This carries over to Common Lisp.,-0.3,lisp
167oefv,jyx8zi1,"There are a few reasons for it:  * there is a global symbol table, global function calls go through this symbol table by default.",-0.06666666666666667,go
167oefv,jyx8zi1,"This goes back to the mid 60s  * by default Common Lisp has a source interpreter and/or incremental compiler via the functions EVAL and COMPILE  * by default Common Lisp can load code at runtime via the function LOAD  * CLOS (the Common Lisp Object System) comes with open classes, before/after/around extensions, changeable class hierarchies, and on optional meta-object protocol to change the OOP implementation itself  It's not uncommon that a Common Lisp program might be compiled once for end users, delivered to the end user and then get tiny little loadable patches, which change/add/replace functionality of a running program.",-0.17875,lisp
167oefv,jyx8zi1,"Let's check an example in CLOS, the Common Lisp Object System.",-0.3,lisp
167oefv,jyxw5cs,I know it's not as cool as the LISPs for metaprogramming but it's quite a nice language!,0.55,cool
167oefv,jz1qmyg,"I haven't ever tried, but my bet is on Ruby.",0.0,ruby
167oefv,jz1qmyg,"At one job a person suggested we should switch to Ruby because it was so cool, you could change out the whole system and standard functions while the code was running.",0.18333333333333335,ruby
167oefv,jz1qmyg,"At one job a person suggested we should switch to Ruby because it was so cool, you could change out the whole system and standard functions while the code was running.",0.18333333333333335,cool
167oefv,jyxwznn,C# has very good modding tools and a lot of communities for modding games,0.9099999999999999,c
167oefv,jyu6zdj,"Lisp and various derivatives, definitely.",0.0,lisp
167oefv,jyu6zdj,"Javascript of course, particularly if `eval` isn't disabled.",-0.016666666666666677,javascript
167oefv,jyu6zdj,"Perl, because running and doing flips with your eyes closed while juggling multiple pairs of scissors is fun for the whole family.",0.1,perl
167oefv,jyu6zdj,Ruby is another one to put on the list.,0.0,ruby
167oefv,jyu6zdj,A lot of Ruby libs (like Rails) are based on the concept.,0.0,ruby
167oefv,jyu6zdj,"Python, to some extent.",0.0,python
167oefv,jyuzwjo,Check out Luca Saiu's [epsilon]( https://blog.ageinghacker.net/posts/17/) for an example of a highly moddable lisp.,0.16,lisp
167oefv,jyxz0g0,"Forth is definitely a language creation toolkit and has a very raw and punk/DIY flavor, but it's usually not very ""moddable"" in the sense the OP is talking about.",-0.13333333333333333,forth
167oefv,jywbieu,"just to clarify  >which only one mod can do at a time  the reason why only one mod can do it at a time is because overwriting functions is a destructive operation, it's sort of like this  ```lua -- original.lua  function a(a,b)    local c    -- whole bunch of code    return c end  -- injection.lua  -- overwrites a function a(a,b)    local c    -- whole bunch of mostly the same but different in a few things code    return c end  -- if another mod overwrites the function again, neither the original definition nor the first overwrite will do anything, which will cause all sorts of evil ```",0.019117647058823527,lua
167oefv,jywbieu,"just to clarify  >which only one mod can do at a time  the reason why only one mod can do it at a time is because overwriting functions is a destructive operation, it's sort of like this  ```lua -- original.lua  function a(a,b)    local c    -- whole bunch of code    return c end  -- injection.lua  -- overwrites a function a(a,b)    local c    -- whole bunch of mostly the same but different in a few things code    return c end  -- if another mod overwrites the function again, neither the original definition nor the first overwrite will do anything, which will cause all sorts of evil ```",0.019117647058823527,c
167oefv,jyxxhbx,So Lisp and the other Lisp?,-0.125,lisp
167oefv,jzbsidb,"In whether Smalltalk or Common Lisp you can modify the behavior of a compiled program, as there really doesn't exist something like a compiled program, rather, only an image with the  copied codes from the STD exists (or core image, you can call it).",-0.033333333333333326,lisp
167oefv,jz1dlpw,Don’t forget about Lisp.,0.0,lisp
167zsiv,,"def call_function(args:, globals:)       new_context = Dictionary.new(globals[:context].raw.dup)  where I used to do      def call_function(args:, globals:)       new_context = globals[:context].dup  And even before that I used to do      def call_function(args:, globals:)       new_context = globals[:context].deep_dup  My language is implemented in Ruby and the context is a Code::Object::Dictionary  Any help?",0.5,ruby
167vd73,,Does such tool exist for C?,0.0,c
167vd73,jyszytw,"My favorite is [Lemon](https://compiler-dept.github.io/lemon/), which is very user friendly, generates good clean C code, and acknowledges modern concerns like threading (versus `yacc`).",0.3902777777777778,c
166s79c,jym9s12,g : a->b  h : c->d  x : a&c  f : (b|d) -> e,-0.75,d
166s79c,jym9s12,g : a->b  h : c->d  x : a&c  f : (b|d) -> e,-0.75,c
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,go
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,rust
166rij5,jynj02a,"I'm not trying to innovate with the language, I'm borrowing from Go, Rust, Kotlin, etc but trying to keep the language very minimal.",-0.13,kotlin
166rij5,jynj02a,I'm implementing this in Rust.,0.0,rust
166rij5,jymmzcj,"My toy* language:  * compiles to C  * based off C with modern features and tooling  * methods, generics, algebraic types, first class functions,    iterators, traits, built in strings  * null safety and intuitive error handling based off rust (Option, Result, ?",0.225,c
166rij5,jymmzcj,"My toy* language:  * compiles to C  * based off C with modern features and tooling  * methods, generics, algebraic types, first class functions,    iterators, traits, built in strings  * null safety and intuitive error handling based off rust (Option, Result, ?",0.225,rust
166rij5,jymmzcj,"operator, etc)  * tunable GC system, might also implement smart pointers, raw pointers available  * cut out as much UB as possible  * easy c library imports and bindings  thats my main goal, I have other ideas I would like to implement like pattern matching, lambdas, and closures but I can do without plus the implementation to C might not be straight forward.",0.13231456043956044,c
166rij5,jymmzcj,"From my research, it seems C is a bad backend unless there is a very close relationship to C. Methods are fine, iterators I think I have figured out, generics would be the most difficult but doable.",-0.01666666666666663,c
166rij5,jymmzcj,If anyone has any experience with C as a backend or any input on some possible pitfalls Id really like to hear.,0.1,c
166rij5,jymmzcj,One reason I want to compile to C is for easy bindings and to easily get the language from working to usable.,0.43333333333333335,c
166rij5,jyn42bu,"The C way is to just leave it to the user: a memory allocation IS a value in the form of a pointer, and you're responsible for fulfilling the promise of freeing it at some point.",0.2,c
166rij5,jyn42bu,"Python has the ""with"" clause which is nice but doesn't allow for interleaving things (A was created before B but we'd like to free it first) or returning the resource from a function or something.",0.4166666666666667,python
166rij5,jylrwqk,A C compiler.,0.0,c
166rij5,jylrwqk,"I know, boring, but implementing it really made me appreciate compiler developers and I am learning a lot more about C, Rust (the language I am building it in) and low level programming.",-0.07500000000000001,c
166rij5,jylrwqk,"I know, boring, but implementing it really made me appreciate compiler developers and I am learning a lot more about C, Rust (the language I am building it in) and low level programming.",-0.07500000000000001,rust
166rij5,jylrwqk,After finishing this I am pretty sure I'll go build my own programming language though!,0.5,go
166rij5,jylw825,The next step was deciding how to go from there.,0.0,go
166rij5,jylw825,"Once I figure that out, I can go on to actually writing an evaluator and start running Beech code, but there's a lot to think about.",0.0,go
166rij5,jzry16x,"I haven't posted in a long time, but back in June I wrote a blog post about how making Python faster is not as easy as just slapping types on: https://bernsteinbear.com/blog/typed-python/  Don't worry.",0.1277777777777778,python
166rij5,jylu520,Saw a video explaining why function types in rust are tied to implementation.,0.0,rust
166rij5,jz3kkku,Unlike 'C' union elements are not named but must all have distinct types.,0.3,c
166rij5,jzpwcb5,The goal is to automate your character with JavaScript.,0.0,javascript
166nxvv,jynqcpk,"and then they go and help the aforementioned Sisyphus with his stone, only to slip, fall and try again, _ad infinitum_.",0.0,go
166f9gj,jyjdm4r,"* It had lvalue vs rvalue distinction * Conditional expressions `true -> E2, E3` means E2, `false -> E2, E3` means E3 * `E0 rep n` means E0 repeated n times `E0, E0, ... E0` * If Commands (but without else branch): `if E do C`, `unless E do C` * Test Commands: (just like if-then-else) `test E then C or C`, `test E ifso C ifnot C` * It already had a number of undefined behaviours * Let declarations: `let may be used to declare a set of mutually recursive functions and routines` * `There is no need for type declarations in the language, since the type of every variable is already known`",-0.26666666666666666,c
166er7n,,"So there's precondition/postcondition system like in Ada to help, and I guess you can also use proofs to ensure some specific operations can preserve good shape.",0.35,ada
166er7n,jyjsnd9,"Theory-wise, you should go all the way back to the Halting Problem, Rice's theorem, and then look at refinement and dependent types.",0.0,go
166er7n,jyjhs0g,"Side note: Common Lisp has these, and they are used in practice by some programmers.",-0.3,lisp
166er7n,jyjhs0g,";; evenp is common lisp's ""isEven"" predicate     (deftype even-number ()       '(satisfies evenp))      (defun foo (x)       (declare (type even-number x))       (+ x 3))",-0.3,lisp
166er7n,jyjxu27,My first introduction to such a system was [Clojure spec](https://clojure.org/guides/spec).,0.125,clojure
166er7n,jyjxu27,"While it is very powerful, it: 1. checks entirely at runtime 2. is not Clojure's primary type system  IMO the best way to use it is to enable checking at dev / testing time, and then only enable checking the inputs / outputs of the system (eg HTTP request / response JSON) at runtime (which you are probably already doing).",0.358,clojure
166er7n,jyjxu27,"IMO if a serious language was to be made employing predicates as the primary typing mechanism, it should: 1. check as much statically as possible, and assert the rest at runtime (java does this for array bounds checking for example, unlike dependently typed languages that can check bounds at compile time) 2. have a good polymorphism story (Clojure has Java classes + interfaces and its own types, records, protocols, multimethods, etc.)",0.2611111111111111,java
166er7n,jyjxu27,"IMO if a serious language was to be made employing predicates as the primary typing mechanism, it should: 1. check as much statically as possible, and assert the rest at runtime (java does this for array bounds checking for example, unlike dependently typed languages that can check bounds at compile time) 2. have a good polymorphism story (Clojure has Java classes + interfaces and its own types, records, protocols, multimethods, etc.)",0.2611111111111111,clojure
166er7n,jyp3hgd,"So... hum... a decade or so ago, [Rust had Typestate](https://stackoverflow.com/a/10319250/147192) which was specifically about ""tagging"" types with predicates.",0.0,rust
166er7n,jyq1qvq,Interesting that you mention Ada.,0.5,ada
166er7n,jyq1qvq,I think the Spark Ada version can do what you want since the proofs are part of the source code.,0.0,ada
166er7n,jys75o8,"See: https://simon.peytonjones.org/verse-calculus/  SPJ is a major creator of GHC (Haskell), seems he hit major limitations with ""functional"" paradigm by Haskell, and going ""functional-logic"" by Verse.",0.0625,haskell
166er7n,jyjmwiz,and Flux which adds liquid types to Rust \[[video](https://www.youtube.com/watch?v=k-izcFCHN2o)\],0.0,rust
166er7n,jz3gdsp,Wasn't SPJ a prime author of the [`-XUndecidableInstances` extension of GHC](https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/glasgow_exts.html#instance-termination-rules) (the only Haskell compiler of note)?,0.0,haskell
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,c++
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,c
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,java
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,rust
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,scala
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,swift
166er7n,jylivmw,"A non-exhaustive list from https://3fx.ch/typing-is-hard.html: - C++ - C# - F#  - Java - Ocaml - Rust - Scala - Swift - TypeScript - Zig  In practice I would just let the type check system to hang, user should be aware of this problem and try to fix it.",0.25,typescript
166er7n,jz3jgli,"I don't see Haskell type classes doing ""logic"" styles, quoting the 2nd last page of:  https://simon.peytonjones.org/assets/pdfs/haskell-exchange-22.pdf  > * In Verse, a “type” is simply a function > * that fails on values outside the type > * and succeeds on values inside the type > * So int is the identity function on integers, and fails otherwise > * isEven (which succeeds on even numbers and fails otherwise) is a type > * array int succeeds on arrays, all of whose elements are integers... > hmm, scratch head... ‘array’ is simply ‘map’!",0.054545454545454536,haskell
166er7n,jz3jgli,"∃𝑝, 𝑞. 𝑥 = 𝑝, 𝑞 ; 𝑝 < 𝑞 is the type of pairs whose first component is > smaller than the second > * The Verifier rejects programs that might go wrong.",-0.0625,go
166er7n,jz3jgli,"I'm feeling those functions run statically at compile-time, participating in type-checking, while type-class (or other type-level constructs in Haskell) don't run that way.",-0.125,haskell
166er7n,jz3u1gu,":)  > I'm feeling those functions run statically at compile-time, participating in type-checking  Well yes, but ""The Verifier rejects programs that might go wrong.",0.0,go
166er7n,jz3u1gu,"Not the TypeScript way but another way, hopefully better, or at least educational.)",0.15,typescript
166er7n,jz3u1gu,> type-class (or other type-level constructs in Haskell) don't run that way.,-0.125,haskell
166er7n,jz3u1gu,"So he's having a go with functions, without decidable static typing, but with decid**ed** static typing for as many cases as he et al can pull off.",0.5,go
166er7n,jyl5inq,"I mean, Typescript actually does that, but when you get to that point your codebase becomes unusable.",-0.15625,typescript
166er7n,jyku6r2,Rust is a great example.,0.8,rust
166er7n,jykuruc,"look at C++ polymorphism, you CAN do anything with it, but mostly people do pretty standard things that work well and quickly.",0.2708333333333333,c++
166er7n,jyrzgwa,"Common LISP has predicate types, for example.",-0.3,lisp
1660uus,jyj006b,It's called union type in [crystal](https://crystal-lang.org/reference/1.9/syntax_and_semantics/union_types.html) and [typescript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types).,0.0,crystal
1660uus,jyj006b,It's called union type in [crystal](https://crystal-lang.org/reference/1.9/syntax_and_semantics/union_types.html) and [typescript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types).,0.0,typescript
1660uus,jyjatia,I'm not asking about the union type (I'm aware of that from Haskell).,0.25,haskell
1660uus,jzrv22y,It's just a lot easier to explain by showing it as a source transformation than by explaining 300 lines of C that exist in the context of a larger program.,0.0,c
1660uus,jzsbidi,"No of course I wouldn't expect you to explain 300 lines of C, or even describe the transformation in terms of the AST ... but something like ""and the AST for this gets transformed into the equivalent of this"" instead of ""it gets transformed into this"" would have made it more clear (to me)!",0.3125,c
1660uus,jyj60fk,"I made a mistake, because I have been writing C all day.",0.0,c
1660uus,jyj60fk,"Contrast this with ignoring that you don't understand how even C can infer the type of a division result, and lashing out at people.",0.0,c
165w7sp,,"It is also my understanding that Typescript takes a different approach, making types truly a set of values in the mathematical sense of a set.",0.0,typescript
165w7sp,,"While there may be a unique smallest set of values that describes the type of a term, TypeScript lets you do things like union arbitrary types, define types containing literal values, and use [conditional types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) (which essentially lets you check if a type is a subset of another type), which makes them feel much more like sets than type theory's types.",0.19375,typescript
165w7sp,,Or am I just misunderstanding something about type theory and/or Typescript?,0.0,typescript
165w7sp,jygn361,"But, TypeScript is not type theory either way and you shouldn’t expect it to have much to do with type theory.",0.2,typescript
165w7sp,jygn361,"It’s pretty easy to make TypeScript accept an ill-typed program, even without using “obviously” unsound features like casts or `any`.",0.22777777777777777,typescript
165w7sp,jygspmy,Certain type theorists will go on and on about how types are not sets.,0.21428571428571427,go
165w7sp,jygi530,"TypeScript's types are not sets of values, because the type of an expression depends more on its provenance than its actual shape (especially because TypeScript is highly unsound).",0.165,typescript
165w7sp,jygi530,"TypeScript's type language does have set-like operators like union and intersection, but that doesn't make them sets.",0.0,typescript
165w7sp,jygi530,"TypeScript has subtyping and uses it generously, which is part of the reason why a single value can be given so many different types.",0.14285714285714288,typescript
165w7sp,jygi530,"----   Defining the language of ""types"" in TypeScript is actually pretty complicated, but for individual features, it's relatively straightforward:  TypeScript's rules type judgement rules include things that look like  * If you know that `e: A` and `e: B`, then you can conclude `e: A & B`  * If you know that `e: A & B`, then you can conclude `e: A` and `e: B`.",0.03125,typescript
165w7sp,jyghzos,"Check out the work done on [mlstruct](https://lptk.github.io/files/%5Bv6.2%5D%20mlstruct.pdf) / mlscript, it sort of formalizes and fixes typescript’s system, using a Boolean algebra.",0.0,typescript
165w7sp,jyghzos,"The thing that typescript has is called subtyping, and it expresses this mainly with union and intersection types.",0.16666666666666666,typescript
165w7sp,jyghzos,"Typescript might have some additional stuff that’s beyond subtyping and sort of reasoning about types in a hacky way, I can’t really comment on.",0.2,typescript
165w7sp,jygsqyx,"Agree with u/benjaminhodgson: TypeScript is a tool, not a theory.",0.0,typescript
165w7sp,jygsqyx,"And yes, JavaScript has a strong type system, in the sense that you won't crash the browser.",0.4333333333333333,javascript
165w7sp,jyoe7ct,"Still, TypeScript treats types as a judgement, so it indeed works as a type theory.",0.0,typescript
165w7sp,jyjd5mu,"We're already working on various ways of incorporating more of the popular TS ""typeticool"" techniques, such as adding overloading (with some limitations), first-class polymorphism, and doing type inference for conditional types (which were already [described on a sound declarative system] (https://popl22.sigplan.org/details/POPL-2022-popl-research-papers/37/Type-Level-Programming-with-Match-Types) in Scala's match types ) into a sound type system with great type inference (MLscript, which is in very early development stages).",0.35375,scala
165rh24,jyoxk6t,That's the behavior you would get from C:      #if FOO     int *a = bar();     #else     double a = bar();     #endif     if (false && a < 1.0) { ... },-0.20000000000000004,c
165ku1s,,"For example, in C++ you can say `const thread_local auto& x = ...`.",0.0,c++
165ku1s,jyfkfc3,"They are declared similar to C# (and other languages), with a type, then the name ``` MyClass a = MyClass.new() ``` But there are also modifiers that can be placed after the type and prefixing the name as so ``` str* fruits = [] int _privateItem ``` The asterisk after a type means it's a collection (list) and the underscore at the start of the name means that it is private.",-0.041666666666666664,c
165ku1s,jyf6hoy,"You will notice that there's no `public` keyword, this is by design so that all the public stuff has to go at the top.",0.16666666666666666,go
165ku1s,jyhcwt4,"```let [variable] [type] = [value]```  In my language, types are prefixed with `:`, similar to symbols in Ruby:  E.g.",0.0,ruby
165ku1s,jyne0vy,";  At first i wanted to go with C-like syntax of: `type ident`, but i changed my mind.",0.25,go
165ku1s,jyidbba,"In Fortran: PROGRAM TEST IMPLICIT NONE INTEGER :: TESTINT INTEGER, PARAMETER :: CONSTINT And so on :)",0.5,fortran
165ku1s,jymtzq2,"'=' Expr ```  ``` static: compile time evaluation, like zig comptime or nim static (usable as expression block as well as variable modifier) static var: C style static variable let: immutable var: mutable ```  Just using static is a shorthand for ``` pub?",0.5,c
165ku1s,jyp4gfn,"In my experience with dynamic languages like Python, I have found that it is _extremely_ rare to have bugs caused by assignment to variables that were intended to be immutable (apart from confusion caused by Python not having a separate syntax for declaring new variables).",0.14545454545454545,python
165ku1s,jyfgew6,I prefer a minimal approach like in Go (the concise variable declaration i.e).,0.0,go
165ku1s,jyeq6mr,C++ is a disaster.,0.0,c++
165ku1s,jyeq6mr,"& is actually part of the type, does c++ not know how to infer addresses?",0.0,c++
165ku1s,jyfqz57,"Mine is somewhat influenced by Rust but does not use a `let` keyword          x = 42; // ""Simple variable""             // Single assignment with type inference.",-0.03571428571428571,rust
165ku1s,jz6mveg,"Functions are also treated like all other values, so they're declared similarly to JavaScript's arrow functions and don't use their own keyword, but I borrowed Haskell's function signatures.",0.15833333333333333,javascript
165ku1s,jz6mveg,"Functions are also treated like all other values, so they're declared similarly to JavaScript's arrow functions and don't use their own keyword, but I borrowed Haskell's function signatures.",0.15833333333333333,haskell
165ku1s,jyetjzk,For example the `c` in something like `(a b) => {let c = a + b}`?,0.0,c
165ku1s,jyoa4ql,"In Scala, block is an expression - it can both declare local variables (or just have any declaration/statement in it), and yield a value:      val foo = {         val x = 42         val y = 1337         x * y     }  Similar is the `let ... in ...` expression in the ML family of languages.",0.0,scala
165ku1s,jyoa4ql,"Also, IIRC, there is GCC-specific extension for C language.",0.0,c
165ku1s,jyh18w5,"It is not inferable, since without the keyword it would be inferred as static if in global/namespace scope or local (""automatic"" duration in C++ standardese) if in a function.",0.25,c++
165ku1s,jyh18w5,> does C++ not know how to infer addresses?,0.0,c++
165ku1s,jyiho9t,C++ was designed by a committee a long time ago and we have learned a great deal about OOLs since then.,0.375,c++
165ku1s,jyiho9t,"Of course, much of that learning was because of C++.",0.2,c++
165ku1s,jyguqfl,It’s kinda like how Rust works - it’s just that there’s no `let` keyword and type inference is represented using the Almighty Walrus `:=`.,0.0,rust
165ku1s,jyf5bod,"Though `@pub` will likely be replaced by `@private`, and `@final`/`@open`/`@override` will probably go away by the general demise of inheritance.",0.016666666666666673,go
165ku1s,jyjvslc,"This means that for `x: a`, then `y: (a → b) → c` and the `use`'s expression type is `c`.",-0.75,c
165ku1s,jyp61t0,"But in my shell, I have aliases named: aliases, functions, variables, and exports.",0.0,shell
165ku1s,jyk5jev,It's kinda like Haskell's `>>=` operator.,0.0,haskell
165ku1s,jyiktf2,"The original commenter mentioned Rust as an inspiration, as an example they call it [""const eval""](https://doc.rust-lang.org/reference/const_eval.html) for anything that's calculated at compile time, not just individual variables (function calls, match expressions, etc.).",0.1875,rust
165ku1s,jyiktf2,"Note that Rust's comptime evaluation is less powerful than Zig's but in the context of this conversation it's the same - an indication by the programmer that something **must** be done at compile time otherwise error, rather than leaving it up to the compiler to decide.",0.044444444444444446,rust
165ku1s,jyo639w,It may be used similarly as `<-` notation from Haskell and Scala.,0.0,haskell
165ku1s,jyo639w,It may be used similarly as `<-` notation from Haskell and Scala.,0.0,scala
165ku1s,jyo639w,"Except this one is not tied to single interface/function: in Scala it's fixed to desugaring to`flatMap`,  and in Haskell to `bind`/`>>=`.",0.01428571428571429,scala
165ku1s,jyo639w,"Except this one is not tied to single interface/function: in Scala it's fixed to desugaring to`flatMap`,  and in Haskell to `bind`/`>>=`.",0.01428571428571429,haskell
165co33,jydbex4,"FYI you can simplify the fish for loop to get rid of the semicolons:      for i in (seq 1 10)         echo $i     end  One of the best things about fish is that it does a great job of smoothly automatically updating indentation and intelligently interpreting the enter key as you go about writing things like loops in your prompt, and the same syntax works just as well in scripts.",0.5,go
165co33,jydbex4,"> Cons: As it says on the tin, it's a shell for the 90s.",0.0,shell
165co33,jydbex4,"Excellent autocomplete and syntax highlighting out of the box, proper XDG base path specification support, excellent configurability via a GUI, the ability to easily modify environment variables and have them immediately reflected across all shells with no rc file fiddling needed, and the ability to source bash scripts using bass.",0.24722222222222223,bash
165co33,jydbex4,"Fish is still updating itself to stay relevant in the modern age as well, with the current rewrite from C++ to Rust and the planned future upgrades for migrating from `wchar_t` to UTF-8 and incorporating more concurrency.",0.22000000000000003,c++
165co33,jydbex4,"Fish is still updating itself to stay relevant in the modern age as well, with the current rewrite from C++ to Rust and the planned future upgrades for migrating from `wchar_t` to UTF-8 and incorporating more concurrency.",0.22000000000000003,rust
165co33,jyenk2z,"But I would call it a ""closed world"" philosophy, and historically shell is for universal glue in ""open world"" systems.",-0.025,shell
165co33,jyenk2z,"bash is extremely inconsistent and pretty ugly, but it's extremely powerful.",-0.06874999999999999,bash
165co33,jyenk2z,"- get rid of ridiculous POSIX shell error handling, word splitting, string operations, etc.",-0.3333333333333333,shell
165co33,jyeg040,"Sorry to anyone that does like this, we probably just have different tastes  I might like to try it as a portable scripting language more than an interactive shell, but I'd really only be interested if it became as ubiquitous and portable as bash.",0.05,shell
165co33,jyeg040,"Sorry to anyone that does like this, we probably just have different tastes  I might like to try it as a portable scripting language more than an interactive shell, but I'd really only be interested if it became as ubiquitous and portable as bash.",0.05,bash
165co33,jydhtnk,"The main reason I didn't like nu, and some other utilities shell utilities written in Rust is the ""fancy"" graphics.",0.02083333333333333,shell
165co33,jydhtnk,"The main reason I didn't like nu, and some other utilities shell utilities written in Rust is the ""fancy"" graphics.",0.02083333333333333,rust
165co33,jygt1wv,I am really glad that more people are trying to improve the state of shell scripting.,0.5,shell
165co33,jygt1wv,For me I much prefer a more minimal shell that primarily promotes using external commands and standard pipes.,0.16666666666666666,shell
165co33,jygt1wv,"Sure, unstructured binary or text piped data is a more clunky in many ways, but the main advantage is that your shell doesn't have to be a do-everything environment, and it is OK to use external tools.",0.36111111111111116,shell
165co33,jygt1wv,"My current shell is Fish, and I generally like its approach.",0.02500000000000001,shell
165co33,jygt1wv,I may never finish it but my pet project language is naturally more close to what I prefer -- basically a Fish-like shell but with different syntax and more expression-oriented semantics.,0.3333333333333333,shell
165co33,jydgy4c,(I havent read the documentation  yet) also if it can be the only shell in the system tho I dont know if it can run bash.,0.0,shell
165co33,jydgy4c,(I havent read the documentation  yet) also if it can be the only shell in the system tho I dont know if it can run bash.,0.0,bash
165co33,jyeiw9l,"Yeah the colons are weird there, I've never seen or written fish (or bash or zsh) scripts with semicolons at the end of lines even though it's valid",-0.5,bash
165co33,jygtirc,"Agreed on most of these points; I don't think a ""closed world"" shell could ever become a replacement as a default shell or general-purpose enough to eliminate the need for other shells.",0.06875,shell
165co33,jyhkbch,"My experience with having to do something specific random in Powershell on Windows a few times is that non-basic commands were rather verbose in their naming, which makes *more* sense for a language than an interactive shell (or maybe interactive shell that you rarely use, which would fit Windows tbh)",0.08333333333333333,shell
165co33,jygwzb0,> I am really glad that more people are trying to improve the state of shell scripting.,0.5,shell
165co33,jygwzb0,"I've seen a number of projects try to take on shell scripting, but often fall short because they focus on making the language more consistent, or better at being a general-purpose language, at the expense of being less ergonomic for one-liners that glue together outputs from other programs.",0.1597222222222222,shell
165co33,jygwzb0,"It also helps that learning Bash makes it easy to pick up Zsh, Tsh, Csh, Ash, etc.",0.43333333333333335,bash
165co33,jyf8is4,"Perl has a lot of these little offbeat things, and it very much appealed to my eclectic sensibilities as a kid.",-0.1425,perl
165co33,jyf8is4,"For example, consider another Bash-ism: in `case`, patterns can be set off from blocks by a right parenthesis—this means you can’t naïvely scan Bash source under the assumption of balanced brackets.",0.2857142857142857,bash
165co33,jydhtla,"Worth noting, you can set something like nushell as your interactive shell for your user, but then still write all your scripts in bash.",0.3,shell
165co33,jydhtla,"Worth noting, you can set something like nushell as your interactive shell for your user, but then still write all your scripts in bash.",0.3,bash
165co33,jykl2p6,IMO this design preserves the usefulness of shell.,0.0,shell
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,python
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,c++
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,rust
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,lisp
165co33,jykl2p6,"The way to see that is that Python, C++, Rust, Lisp, Forth have vastly different models of what functions and data are.",0.0,forth
165co33,jykxakq,"Maybe we need easier-to-use tools like awk and sed that can be used from any shell, not a shell that has easier-to-use versions built-in.",0.0,shell
165co33,jyme2ye,I agree but to be honest perl was that tool.,0.6,perl
165co33,jyme2ye,Ruby too I guess.,0.0,ruby
165co33,jyg3lx5,I'd rather replace fi/esac/etc with end      if a then b else c end,0.0,c
1654vrs,,"My schools' class forces the use of Java programming language, and I absolutely hated it.",-0.9,java
1654vrs,,"So, over the course of a little less than a month, I wrote my own programming language, in Rust (objectively best programming language), using [pest](https://pest.rs), to be as similar to Rust as possible, but compiling to Java.",0.2076388888888889,rust
1654vrs,,"So, over the course of a little less than a month, I wrote my own programming language, in Rust (objectively best programming language), using [pest](https://pest.rs), to be as similar to Rust as possible, but compiling to Java.",0.2076388888888889,java
1654vrs,,"- Enums use classes instead of the builtin `enum` thing in Java, I just didn't feel like using them - Some generated builtins, (i.e.",0.0,java
1654vrs,jyfseyo,Had to make a 2nd comment because I missed this in my first read-through.`Rust (objectively best programming language)`  That's a big statement.,0.3125,rust
1654vrs,jygzfgl,"It's a sledgehammer to crack a nut, you could just ... write Java?",0.0,java
1654vrs,jygiz9l,"Things like borrowing and ownership, and async/await are not yet implemented, partly because I have absolutely no clue how to do it in java.",-0.1,java
1654vrs,jygm4ki,He’s likely unaware of languages that are better in each of the domains Rust is strong in.,0.23333333333333334,rust
1654vrs,jygkvj1,"Rust is the best programming language because of its focus on 100% memory safety, 0-cost abstractions, ownership and borrowing...",1.0,rust
1654vrs,jygkvj1,"I can feel comfortable that when I write code in rust, it won't do anything completely unexpected.",0.25,rust
1654vrs,jygkvj1,It's amazing not having to go to stack overflow or whatever 90% of the time when something goes wrong.,0.050000000000000044,go
1654vrs,jygkvj1,Tbh most of the stuff I removed in this language was the stuff I love most about rust.,0.5,rust
1654vrs,jygkvj1,"Efficiency, low level memory management, functions in generic struct/impls only being allowed when the generic had a certain trait... All missing from here because java does not have these features.",0.0023809523809523773,java
1654vrs,jyd9fre,"That defeats the entire purpose for me -- to *not* use java, ever.",0.0,java
1654vrs,jyfv366,"We should not ""low-key"" bash fellow language designers/implementers..   Of course it **can** be a learning experience for yourself, but the question stands from me to you: Should it be?",0.0,bash
1654vrs,jymfluu,"I want to finish traits (= abstract classes), make `sometype[]` equal a java array and define a `vec!",0.0,java
1654vrs,jypmhb9,Borrowing and ownership in Rust are actually just compiler-level constructs; they don't exist after the code is compiled.,0.0,rust
1654vrs,jypmhb9,"Something similar to async/await is in the works for a future version of Java, but at the moment it's not easy to translate directly to Java without a lot of legwork.",-0.029166666666666667,java
1654vrs,jypmhb9,You could look at how Kotlin does it.,0.0,kotlin
1654vrs,jygpqel,That may be so but rust is the best balance between the three.,1.0,rust
1654vrs,jygpqel,"I think c is the best for efficiency, but there is no memory safety.",1.0,c
1654vrs,jygpqel,"C++ has some memory safety, but it's super complicated.",-0.08333333333333334,c++
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,c++
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,python
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,javascript
1654vrs,jyh716h,"I've been a professional software engineer for 10 years and coding for fun long before that, have lots of experience with C++, Python, Javascript, Java, etc.",0.11666666666666668,java
1654vrs,jyh716h,and I still think that Rust is by far the best language for the majority of use cases.,0.55,rust
1654vrs,jygz2vs,"\> Rust is the best programming language because of its focus on 100% memory safety, 0-cost abstractions, ownership and borrowing...",1.0,rust
1654vrs,jyd9vbl,What parts of Rust does Jasmine handle?,0.0,rust
1654vrs,jyn4vwv,"Thank you, this helps me understand how people use Rust for implementing programming languages.",0.0,rust
1654vrs,jyqsuwo,Go is better for a few things even if Rust might be slightly faster runtime.,0.044444444444444446,go
1654vrs,jyqsuwo,Go is better for a few things even if Rust might be slightly faster runtime.,0.044444444444444446,rust
1654vrs,jyqsuwo,"For learning/onboarding, Go is by far.. exponentially better than anything out there.",0.3,go
1654vrs,jyqsuwo,"The binary on all platforms (like rust, zig, etc).. is fantastic.",0.4,rust
1654vrs,jyqsuwo,"I'd use Rust or my new fav, Zig, for anything else.",0.13636363636363635,rust
1654vrs,jyzb373,> I still think that Rust is by far the best language for the majority of use cases.,0.55,rust
1654vrs,jyzb373,Rust is a systems programming language.,0.0,rust
1654vrs,jyzb373,It's good at many of the things C and C++ are good at.,0.6333333333333333,c
1654vrs,jyzb373,It's good at many of the things C and C++ are good at.,0.6333333333333333,c++
1654vrs,jyzb373,"It's not the best language for:  - Shell scripting (bash, zsh, fish, etc.)",1.0,shell
1654vrs,jyzb373,"It's not the best language for:  - Shell scripting (bash, zsh, fish, etc.)",1.0,bash
1654vrs,jyzb373,"- Scientific programming (python, R, matlab, fortran, APL, etc.)",0.0,python
1654vrs,jyzb373,"- Scientific programming (python, R, matlab, fortran, APL, etc.)",0.0,r
1654vrs,jyzb373,"- Scientific programming (python, R, matlab, fortran, APL, etc.)",0.0,matlab
1654vrs,jyzb373,"- Scientific programming (python, R, matlab, fortran, APL, etc.)",0.0,fortran
1654vrs,jyzb373,"- Scientific programming (python, R, matlab, fortran, APL, etc.)",0.0,apl
1654vrs,jyzb373,"- Data visualization (matlab, python, javascript, etc.)",0.0,matlab
1654vrs,jyzb373,"- Data visualization (matlab, python, javascript, etc.)",0.0,python
1654vrs,jyzb373,"- Data visualization (matlab, python, javascript, etc.)",0.0,javascript
1654vrs,jyzb373,"- Backend web development (python, ruby, elixir, etc.)",0.0,python
1654vrs,jyzb373,"- Backend web development (python, ruby, elixir, etc.)",0.0,ruby
1654vrs,jyzb373,"- Backend web development (python, ruby, elixir, etc.)",0.0,elixir
1654vrs,jyzb373,"- Frontend web development (javascript, typescript, etc.)",0.0,javascript
1654vrs,jyzb373,"- Frontend web development (javascript, typescript, etc.)",0.0,typescript
1654vrs,jyzb373,"- Game scripting (lua, C#, javascript, C++, etc.)",-0.4,lua
1654vrs,jyzb373,"- Game scripting (lua, C#, javascript, C++, etc.)",-0.4,c
1654vrs,jyzb373,"- Game scripting (lua, C#, javascript, C++, etc.)",-0.4,javascript
1654vrs,jyzb373,"- Game scripting (lua, C#, javascript, C++, etc.)",-0.4,c++
1654vrs,jyzb373,"- Learning programming (python, scheme, C, etc.)",0.0,python
1654vrs,jyzb373,"- Learning programming (python, scheme, C, etc.)",0.0,scheme
1654vrs,jyzb373,"- Learning programming (python, scheme, C, etc.)",0.0,c
1654vrs,jyzb373,"- Embeddable scripting (lua, lisp, javascript, etc.)",0.0,lua
1654vrs,jyzb373,"- Embeddable scripting (lua, lisp, javascript, etc.)",0.0,lisp
1654vrs,jyzb373,"- Embeddable scripting (lua, lisp, javascript, etc.)",0.0,javascript
1654vrs,jyzb373,"- Pattern matching and string manipulation (perl, sed, awk, etc.)",0.0,perl
1654vrs,jyzb373,"- High reliability distributed systems (erlang) - Provable correctness (coq, ada) - Database querying (SQL)  It's possible to do most or all of these things in Rust, but it's not ""by far the best language"" for these use cases.",0.352,erlang
1654vrs,jyzb373,"- High reliability distributed systems (erlang) - Provable correctness (coq, ada) - Database querying (SQL)  It's possible to do most or all of these things in Rust, but it's not ""by far the best language"" for these use cases.",0.352,ada
1654vrs,jyzb373,"- High reliability distributed systems (erlang) - Provable correctness (coq, ada) - Database querying (SQL)  It's possible to do most or all of these things in Rust, but it's not ""by far the best language"" for these use cases.",0.352,rust
1654vrs,jyzb373,Rust certainly doesn't have the same level of ecosystem support as the most popular languages in these domains.,0.32857142857142857,rust
1654vrs,jydat5i,"As java does not have low level memory management, I was unable to implement borrowing.",-0.25,java
1654vrs,jyn5vnq,"I'm not the person to ask here, idk any best practices, and I've only been using rust for a few months.",0.26666666666666666,rust
1654vrs,jyqxfn5,"If you like Go, you're going to love [IntercalScript](https://github.com/Storyyeller/IntercalScript).",0.5,go
1654vrs,jyqxfn5,"The problem with Go is that it achieves ""simplicity"" by deferring all the work from the compiler to the human and forcing them to write low level repetitive code by hand.",-0.08333333333333333,go
1654vrs,jyqxfn5,"Also, while Go may be ""simple"", it still has a lot of unforced design errors and dumb gotchas and the like.",-0.1875,go
1654vrs,jydce9u,You can still have it gc’ed but have the same semantics as rust.,0.0,rust
1654vrs,jydf7ef,How would you propose I create a reference/pointer/borrow to an object explicitly in java?,0.0,java
1654vrs,jygl63m,There is no way that it would run in the expected way in java.,-0.1,java
1654vrs,jygl63m,"If, in writing code, I made a borrow, there would be no way for me to translate that into Java code.",0.0,java
1654vrs,jyglr7n,I think you’re missing the point…  It will run in Java with GC.,-0.2,java
164ox4k,jyc9m4z,Python has [xeger](https://pypi.org/project/rstr/) but being able to reverse a whole grammar would be very convenient too.,0.3,python
164k73n,jy96lkk,"When Spring (Java) was XML based, all your config was in one spot, now with annotations/decorators, it's all over the codebase.",0.0,java
164k73n,jyckftc,"Python needs decorator syntax, because `def` is a statement instead of an expression there, so higher-order functions those wrapping other function definitions somehow, have to be called with special syntax.",0.11607142857142858,python
164k73n,jyckftc,"In my PL `$` is a low-precedence, right-associative, infix operator, works like that in Haskell, i.e.",0.0,haskell
164k73n,jyckftc,"`(***apk)` there is roughly `(*args, **kwargs)` as in Python.",-0.1,python
164k73n,jycedsv,"In Java, they're called annotations.",0.0,java
164k73n,jycvw4u,But if it is actually a tag that you can check if it is in certain object and with that generate code from a function that you wrote (not the compiler for you) then is ok. Basically Java tags,0.2380952380952381,java
163g4nf,,"Hi everyone,  So I am writing a nil-checker (my keyword is called nil, but its the same as C++'s null).",0.0,c++
163g4nf,,I know kotlin has some null-inferencing ability.,0.0,kotlin
163g4nf,,"Does kotlin go further than mine, though?",0.0,kotlin
163g4nf,,"Does kotlin go further than mine, though?",0.0,go
163g4nf,,Any idea how this stacks up against kotlin's null-checker?,0.0,kotlin
163g4nf,,is kotlin doing the same?,0.0,kotlin
163g4nf,,What about swift?,0.0,swift
163g4nf,jy2kvtw,"definitely an interesting idea from an analysis perspective, and does remind me of my limited exposure to kotlin for sure.",0.30952380952380953,kotlin
163g4nf,jy2kvtw,"but, I'd generally prefer a more explicit syntactic approach (like swift's if-let) over this truthiness-based null test.",0.275,swift
163g4nf,jy2kvtw,"all of that said, I don't want my contrasting opinion to sound like negativity toward your project -- it's always cool to see/discuss what cool stuff people are working on, and it's definitely an interesting idea regardless :)",0.42000000000000004,cool
163g4nf,jy6tcdv,rust's new [let-else](https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html) is also very nice for keeping control flow relatively linear.,0.3054545454545455,rust
163g4nf,jy44k68,"Xcode's is SLOOWWW.... taking minutes on only 500k of C++... mine will run in 0.01 second, and also make the language neater to write.",0.0,c++
163g4nf,jy42jgf,"Well, what I said was that the analysis required by your language implementation to produce those compiler errors sounds difficult enough to get right that if it was me I don’t know if I’d ever feel fully confident in it",0.07142857142857142,d
163g4nf,jy2oki5,"If you want to compete fast+expressive, I don't think you can beat rust which uses Option<T>",0.0,rust
163g4nf,jy6ttww,"See rust's ""null pointer optimization""  [https://doc.rust-lang.org/std/option/#representation](https://doc.rust-lang.org/std/option/#representation)  https://stackoverflow.com/a/46557737/3805484",0.0,rust
163g4nf,jy7xjws,"Yeah, I don't have a strong preference, I also think your style of flow typing is pretty cool.",0.3444444444444444,cool
162x1wp,jxzwvmb,"This looks super cool, I realized it's actually 4 years old though (2019!).",0.20208333333333334,cool
162x1wp,jy09fdt,Damn that’s cool asf,0.35,cool
162drv9,,I believe Rust has something similar with `std::option` and match statements.,0.0,rust
162drv9,jxytgkf,[Scala Option](https://www.scala-lang.org/api/2.13.3/scala/Option.html),0.0,scala
162drv9,jxzbsem,"I see two things here:  - First-class support for `null` is common in a few languages, including Ceylon with its [`if(exists)`](http://web.archive.org/web/20211129235401/https://ceylon-lang.org/documentation/1.3/tour/basics/#dealing_with_objects_that_aren_t_there), Zig with its [`orelse`](https://ziglang.org/documentation/master/#Optionals), or [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator) and [PHP](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce) with the `?",-0.25,c
162drv9,jxzbsem,"I see two things here:  - First-class support for `null` is common in a few languages, including Ceylon with its [`if(exists)`](http://web.archive.org/web/20211129235401/https://ceylon-lang.org/documentation/1.3/tour/basics/#dealing_with_objects_that_aren_t_there), Zig with its [`orelse`](https://ziglang.org/documentation/master/#Optionals), or [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator) and [PHP](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce) with the `?",-0.25,php
162drv9,jxzbsem,It is popular in several OOP languages like Kotlin or Ceylon as it allows to downcast class references.,0.3,kotlin
162drv9,jxzbsem,"TypeScript is similarly notable for encoding ECMAScript's many dynamic type checks in a static, AOT-checked, type system using [a range of narrowing checks](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) including `x instanceof y`, `""x"" in y` and `x.hasOwnProperty(y)` among others.",0.375,typescript
162drv9,jxzrdf1,"If used where a block is expected, Raku groups and binds arguments on the left of the `->` to parameters on the right, and calls the lambda/block as many times as appropriate:      for 4, 3, 2, 1 -> a, b { print a } # 42  ⁴ You have to write more verbose syntax if you want to deal with ""some"" or ""none"" tags of optionals:      Int:D  # `:D` is a ""type smiley"".",0.38367346938775515,d
162drv9,jxzrdf1,`Int:D` means some `Int`.,0.0,d
162drv9,jy1c90w,"I recommend implement something like rust's [if-let](https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html), as it's a more general version of what you said, but it requires you to implement pattern matching though.",0.275,rust
162drv9,jxzhanh,"So some of what you're thinking about overlaps with [Void Safety](https://www.eiffel.org/doc/eiffel/Void-safety-_Background%2C_definition%2C_and_tools)  Eiffel has the following, which might be of interest:  ```eiffel if attached x as l_x then   l_x.f (a) end ``` Kind regards, M ✌",0.3,eiffel
162drv9,jy9td21,rust has if-let and let-else for handling enums I cases where you only care about one variant.,0.0,rust
162clva,,I have started looking over some open source VMs like lua trying to get an idea for how they are implemented.,0.0,lua
162clva,jxxa19u,"(3) ""C"" switch-case or similar Pascal case-of instructions can sometimes be replaced into a small array of instructions.",-0.125,c
162clva,jxxa19u,"(3) ""C"" switch-case or similar Pascal case-of instructions can sometimes be replaced into a small array of instructions.",-0.125,pascal
162clva,jxxt1gb,"Maybe you will find [A deep dive into dispatching techniques - Jonathan Müller - Meeting C++ 2022](https://youtu.be/P4BUvMmdTMU?si=VXcgAIPgsrs646lT) interesting, and/ or [Building the fastest Lua interpreter..",0.25,c++
162clva,jxxt1gb,"Maybe you will find [A deep dive into dispatching techniques - Jonathan Müller - Meeting C++ 2022](https://youtu.be/P4BUvMmdTMU?si=VXcgAIPgsrs646lT) interesting, and/ or [Building the fastest Lua interpreter..",0.25,lua
162clva,jxxt1gb,Lua is considered to be fast and somewhere on Reddit Lua's author discussed tricks he used unfortunately I can't find it right now.,-0.004761904761904763,lua
162clva,jxxt1gb,Edit: found the [Lua stuff](https://www.reddit.com/r/programming/comments/badl2/luajit_2_beta_3_is_out_support_both_x32_x64/c0lrus0/),0.0,lua
162clva,jxxel81,I currently go source -> lexer -> parser -> AST -> optimizer -> compiler -> bytecode -> VM.,0.0,go
162clva,jxxel81,"I can go from script to bytecode in around 50 milliseconds and the runtime is measured in 10s of minutes, so wasting a few extra cycles on optimization is well worth it in most cases.",0.15,go
162clva,jxxel81,This lets me push common routines into the C++ code instead of having it in the scripting language.,-0.3,c++
162clva,jxxel81,I’m writing in C++ and not making any use of inline assembly at the moment.,0.0,c++
162clva,jxxel81,I’m writing in C++ and not making any use of inline assembly at the moment.,0.0,assembly
162clva,jxx9qrs,I’d like to push the overall optimization phase further still because I’m sure I’m missing some things.,0.075,d
162clva,jxxbuvs,Our other languages would be C++ or Python.,-0.125,c++
162clva,jxxbuvs,Our other languages would be C++ or Python.,-0.125,python
162clva,jxxbuvs,"C++ destroys my language for performance, up to 100x faster.",0.0,c++
162clva,jxxbuvs,Python is 5-10x slower.,0.0,python
162clva,jxxbuvs,The C++ code is very difficult to write in comparison to my DSL or else it would be the obvious answer.,-0.325,c++
162clva,jxxbuvs,Comparable C++ is hundreds of lines long and considerably harder to debug.,-0.07500000000000001,c++
162clva,jxxbuvs,The Python code solves some of that.,0.0,python
162clva,jxxbuvs,"It is easier to write than the C++, but still more difficult than the DSL.",0.0,c++
162clva,jxy53us,"I've recently picked up the Lua code and started reading over it to find things they have done, but it's a bit of searching for a needle in a haystack.",0.0,lua
162clva,jxwr2qz,Cool.,0.35,cool
162clva,jxxf7l9,(1) Your VM bytecode is equivalent to assembly.,0.0,assembly
162clva,jxxg758,"I’d like to extend it to a full debugger, but that’s for another day.",0.35,d
162clva,jxynzhz,"All of the loading of the data is handled in C++, completely outside of the script itself (IOW, the script doesn’t contain any code to open a file or read from it).",0.0,c++
162clva,jxynzhz,We have some very robust C++ libraries to handle this.,0.2,c++
162clva,jxynzhz,Javascript comparison depends on the runtime being used.,0.0,javascript
162clva,jxynzhz,"C++ destroys all of the above, including my scripts.",0.0,c++
162clva,jxynzhz,"A script is almost surely using more memory compared to a comparable program in C++, although there are some tricks I use in the VM that shrink usage compared to naïve C++.",0.5,c++
162clva,jxwvs2o,"Now because of my host language being Python the only *practical* gains right now come from when native code drops the GIL, but *in theory* this lets me work out the details of message-passing concurrency in a safe and productive environment.",0.2619047619047619,python
162clva,jxyc46l,"Consider a = b + c  A stack-based implementation is:       ; load b     LOAD, R0    b     push R0             ; macro to push R0 onto the software stack      ; load c     LOAD, R0    c     push R0             ; macro to push R0 onto the software stack      ; add b and c     pop R0              ; macro to the software stack into R0     pop R1              ; macro to the software stack into R1     ADD R0, R1     push R0             ; macro to push R0 onto the software stack      ; store a     pop R0              ; macro to the software stack into R0     STORE, R0   a   And here is the same thing but with the top of the stack in registers.",0.25,c
162clva,jxyc46l,"; load b     LOAD, R0    b      ; load c     LOAD, R1    c      ; add b and c     ADD R0, R1      ; store a     STORE, R0   a  Note that the second implementation is almost the same as a register VM.",0.0,c
162clva,jxwzrrv,My host language is C++.,0.0,c++
162clva,jxwzrrv,"The people using the language right now are fairly proficient at SQL and can do some simple python or bash scripting, but they don’t do much else.",0.29642857142857143,python
162clva,jxwzrrv,"The people using the language right now are fairly proficient at SQL and can do some simple python or bash scripting, but they don’t do much else.",0.29642857142857143,bash
162clva,jxwzrrv,I’m faster than gawk but considerably slower than lua5 (lua has an interesting white paper with some of their design decisions if you haven’t seen it).,0.19999999999999998,lua
162clva,jxwzrrv,Comparison to javascript depends heavily on the runtime being used.,-0.2,javascript
162clva,jy00va2,> You said elsewhere Python (I assume CPython) was 5-10 times slower; that was running the data application?,0.0,python
162clva,jy00va2,"I have a C++ library that loads the data for Python, but it is still substantially slower due to the way it has to work with Python.",-0.125,c++
162clva,jy00va2,"I have a C++ library that loads the data for Python, but it is still substantially slower due to the way it has to work with Python.",-0.125,python
162clva,jy00va2,"All numbers are in seconds (smaller is better):      python2    32.401     Perl5      27.976     gawk5      23.700  (1)     reddofPL   21.486  <- I'm here     python3    15.705     lua5        4.403  (2)     c++         0.677  Honestly, I think this thread has diverged from what I was really wanting.",0.325,c++
162clva,jy00va2,"Obviously I'll never get ""C++ fast"".",0.1,c++
162clva,jy00va2,"Where I can go to learn the tricks of the trade that are well known to someone doing this full time, but that someone new may never figure out on their own.",0.3621212121212121,go
162clva,jxy410w,"For the shorter job, you would have your answer before someone was able to finish a C++ version of the program.",0.5,c++
162c9z2,,Languages like C++ has implicit conversions.,0.0,c++
162c9z2,,"This is very close to (but not the same as, at least in C++) ""whenever type B can be used, type A can **also** be used"".",-0.033333333333333326,c++
162c9z2,,Languages like C++ does not **chain** implicit conversions.,0.0,c++
162c9z2,,This means A -> B and B -> C does not mean A -> C. 2.,0.15625,c
162c9z2,jxwsuva,"For any types `A`, `B`, `C`, if `A <: B` and `B <: C`, then `A <: C` and `i{A,C} = i{B,C} .",0.0,c
162c9z2,jxxdiu9,**  A common compiler like C will perform several implicit conversions.,-0.15,c
162c9z2,jxxdiu9,"Usually in C integers alike variables are converted into the specific integer byte, even if they where another 8, 16, 32 bits types and integer is 64 bits.",-0.125,c
162c9z2,jy89ain,"In my language Y, the only implicit conversions I'm allowing are the conversion between literals of basic type limited to not allow conversions that would lose information, which makes it so I don't have to write stuff like `1.0f` from C (I can just put a `1`), and a few conversions between sizes of basic types mainly for stuff like multiplying two 4-byte naturals and storing the result in another 4-byte natural, instead of an 8-byte one, which I think should be fine since it's less drastic than implicitly converting floats to integers or something like that.",0.027248677248677248,c
162c9z2,jyh1mwr,"For example, in Java, `int` is a subtype of `long` (per [JLS sec.",-0.07500000000000001,java
162c9z2,jysoban,"Continuing with Java, `short` is a subtype of `int` and coercion takes place on the language-level (e.g., [JLS sec.",-0.05,java
16225sf,jxz8chb,"That, or it's C, and it will overwrite memory or, worse, read out the user's password.",-0.4,c
16225sf,jxw8pav,Some other things a program can do while passing the type checker  - start extremely slowly - render text that users can't read - solve a problem that nobody cares about - crash every friday at 5pm when people on-call want to go home - upload the contents of the user's hard disk to the Internet - Run a turing-complete interpreter on user-supplied data  The last thing has happened several times.,-0.14333333333333337,go
16225sf,jxv7jei,"In the Erlang community, they have a motto, ""let it crash"".",0.0,erlang
16225sf,jxyz5vm,"Scripts on one hand don't need them at all, you run them, you throw them in the trash and go about your day.",0.0,go
16225sf,jxwi2nv,"That's yet another thing one can accommodate in the type system - by using lifetimes, as featured by Rust, the bounds of a permission can be represented in the type system.",0.0,rust
16225sf,jxznqne,"> That, or it's C, and it will overwrite memory or, worse, read out the user's password.",-0.4,c
16225sf,jxwhrsh,"- An effects system, such as Koka's algebraic effects or Haskell's monads, prevents access to systems without a direct chain of approval to the entry point; functions can no longer independently execute IO, including network access.",0.03333333333333333,haskell
16225sf,jxzr1i1,"When writing this kind of code in C++, D or a similar language, I'd `debug assert(mid < len);`.",0.3,c++
16225sf,jxzr1i1,"When writing this kind of code in C++, D or a similar language, I'd `debug assert(mid < len);`.",0.3,d
16225sf,jxwybc0,Though I’d point out these (by definition and by intention) reduce the number of programs that may be written.,0.0,d
16225sf,jxz22lf,Otherwise Python wouldn’t be as popular as it is.,0.6,python
16225sf,jy0aus0,"No, Python has staying power but isn't really ""trending"" in the same way.",0.1,python
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,rust
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,scala
16225sf,jy0aus0,"Rust is gaining popularity, for example, as are Scala and even Java is seeing renewed interest with its later additions.",0.0,java
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,python
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,javascript
16225sf,jy0aus0,"You also see in the Python community a marked interest in static typing through demand for improvements in mypy/black/etc, and in the JavaScript community through Typescript.",0.3,typescript
1621mpb,,TLDR: Here's the repo - [https://github.com/liam-ilan/crumb](https://github.com/liam-ilan/crumb) :D  Hi all!,1.0,d
1621mpb,,"I started learning C this summer, and figured that the best way to learn would be to implement my own garbage-collected, dynamically typed, functional programming language in C ;D  The language utilizes a super terse syntax definition...",0.5458333333333334,c
1621mpb,,"I started learning C this summer, and figured that the best way to learn would be to implement my own garbage-collected, dynamically typed, functional programming language in C ;D  The language utilizes a super terse syntax definition...",0.5458333333333334,d
1621mpb,,"If you build anything cool with it, send it to the comments, it would be awesome to see what can be done with Crumb :D",0.7833333333333333,cool
1621mpb,,"If you build anything cool with it, send it to the comments, it would be awesome to see what can be done with Crumb :D",0.7833333333333333,d
1621mpb,jxw0ih7,Cool project.,0.35,cool
1621mpb,jxvt028,Very cool.,0.45499999999999996,cool
1621mpb,jxwv2l5,Have you considered something like Rust where the last statement in a block is the return value?,0.0,rust
1621mpb,jxuwy6w,So you already knew some other language than C ?,-0.125,c
1621mpb,jy4869s,In your examples you end up with the same problem as lisp: shitloads of superfluous punctuation compared to a more traditional approach.,0.16666666666666666,lisp
1621mpb,jxvzvia,"The source code for the Game of Life demo can be found here: [https://github.com/liam-ilan/crumb/blob/main/examples/game-of-life.crumb](https://github.com/liam-ilan/crumb/blob/main/examples/game-of-life.crumb) :D  Graphics are done just through print and escape codes... Every time I need to re-render, I just use the `\e[H` escape code to return to the top left of the terminal, and then print a string containing the rendered screen again...",0.07000000000000002,d
1621mpb,jxvzvia,"When it comes to matrices, it's just lists inside lists :D I have a render function that gets in a matrix, and returns the corresponding string to print :D  One of the nice things about Crumb is that lists are always pass-by-value, so it's harder to accidently mutate the matrix while you traverse it...  Crumb doesn't have any special graphics functions...",0.5714285714285714,d
1621mpb,jxvzvia,"If anyone wants to build a Crumb TUI library, go for it 😅",0.2,go
1621mpb,jyn9uuw,it's very cool and reading through the source code as a C beginner myself it's really concise and well written in my opinion,0.27749999999999997,cool
1621mpb,jyn9uuw,it's very cool and reading through the source code as a C beginner myself it's really concise and well written in my opinion,0.27749999999999997,c
1621mpb,jxwkm2t,Cool.,0.35,cool
161zt0r,jxwc148,The author (William Byrd) also has some really cool talks on YouTube.,0.35,cool
161zt0r,jxwc148,"I would also recommend checking out Lambda Prolog (There's a book Programming with Higher-Order logic), and some languages like Mercury and Curry.",0.0,prolog
161xxel,jxuid3e,Pretty much the only reason C++ has `auto` is that it was an already reserved keyword from C that wasn't used very much.,0.1775,c++
161xxel,jxuid3e,Pretty much the only reason C++ has `auto` is that it was an already reserved keyword from C that wasn't used very much.,0.1775,c
161xxel,jy37y14,dart has something similer,0.0,dart
161xxel,jxuubjk,"C++ also inherited it from D, which used it for two decades and was proposed for inclusion.",0.0,c++
161xxel,jxuubjk,"C++ also inherited it from D, which used it for two decades and was proposed for inclusion.",0.0,d
161xxel,jxuubjk,"`if constexpr` is another feature they took from D, but decided to invent a new keyword for and to make it worse.",-0.13181818181818183,d
161xxel,jxxzqlz,`var` in C#,0.0,c
161xxel,jxvlftx,How can D have used `auto` for two decades before C++ adopted the keyword for type inference if D has been around since 2001 and `auto` for that purpose came out with C++11?,0.0,d
161xxel,jxvlftx,How can D have used `auto` for two decades before C++ adopted the keyword for type inference if D has been around since 2001 and `auto` for that purpose came out with C++11?,0.0,c++
161xxel,jxy439q,"It isn't, and that's why I also dislike `var` in C#.",0.0,c
161xxel,jxy439q,"But I do like Rust's `let`, because it actually carries semantic meaning.",0.0,rust
161xxel,jxvmnmm,It used it for one decade before C++.,0.0,c++
161xxel,jxy49md,It's not like C++ or C# can just flip their syntax on a whim,0.0,c++
161xxel,jxy49md,It's not like C++ or C# can just flip their syntax on a whim,0.0,c
161wg53,,"So from all that, it seems that a possible implementation could go like this:  1.",0.0,go
161wg53,,Go back to 1 (repeat).,0.0,go
161wg53,,"I know that Prolog is more like SLD Resolution and Horn clauses—I understand the difference, just trying to compare it to something.",0.5,prolog
161ke75,,Here is a 469 line Forth compiler implemented in Forth:  https://github.com/kragen/stoneknifeforth/blob/master/tinyboot1.tbf1  Here is a 301 line BF interpreter implemented in BF:  https://github.com/canoon/bfbf/blob/master/bf.bf  (I actually don't know which  Scheme-in-Scheme is canonical.,0.0,forth
161ke75,,"I guess you can argue a bit about this, because almost all of them will all have a garbage collector in C.   Here's a tiny one, but it's not implemented in itself: https://www.piumarta.com/software/lysp/  )  ---  I thought the answer might be C4: C in 4 Functions  https://github.com/rswier/c4  BUT there is no type checker.",0.0,c
161ke75,,"It is a bytecode interpreter for C, not a compiler.",0.0,c
161ke75,,Some variant of Pascal maybe?,0.0,pascal
161ke75,jxsi44y,"Most likely Pascal, and in particular I'd look closely at the UCSD variant.",0.2222222222222222,pascal
161ke75,jxsi44y,The compiler is itself written in UCSD Pascal.,0.0,pascal
161ke75,jxsi5hz,I wouldn't be surprised if APL beats either of those.,0.1,apl
161ke75,jxstc9h,"I think this is just an interpreter without typing, but as a curiosity, [Sectorlisp](https://github.com/jart/sectorlisp) is very cool project.",0.45499999999999996,cool
161ke75,jxum4v8,"On top of that there also are inline function definitions (more like Forth words than procedures really), with nesting and recursion.",0.39999999999999997,forth
161ke75,jxud4wi,I'm working on something similar in TypeScript and I would like to compare (although it's a bunch of work TBH)  The type checker is 118 lines:  https://github.com/andrejbauer/plzoo/blob/master/src/minihaskell/type_check.ml  However I do think the parsing is the more annoying part.,-0.10000000000000002,typescript
161ke75,jxud4wi,"You either  1. use haskell syntax 2. invent your own syntax, but then it's harder to bootstrap, as you have to write the same thing in 2 languages.",0.16666666666666666,haskell
161ke75,jxud4wi,I am not sure how close the mini Haskell syntax is to Haskell.,-0.25,haskell
161ke75,jxss3k3,What's an example of an APL implemented in itself?,0.0,apl
161ke75,jxss3k3,I thought most of them were implemented in C or another low level language.,0.25,c
161ke75,jxsrv1h,I do not know forth.,0.0,forth
161ke75,jxsrv1h,"You can make a passable apl in _fairly_ little code, but I don't think you can beat the classic metacircular lisp evaluator.",-0.010416666666666671,apl
161ke75,jxsrv1h,"You can make a passable apl in _fairly_ little code, but I don't think you can beat the classic metacircular lisp evaluator.",-0.010416666666666671,lisp
161ke75,jxtu2nt,"So that's actually what I started hacking on, which motivated this question :)  A fairly minimal typed-lambda-calculus-like language, although it also has integers and bool and so forth  Though even with integers and bools, it will be hard to be self-hosting, because you need a parser  I mean I could take some cues from C4, which writes a parser with only `int` and `char`  But yeah I wonder where all the other minimal self-hosting typed lambda calculus languages are :)  I would like to look at them",0.007870370370370368,forth
161ke75,jxsv17e,It means you have to go make it.,0.0,go
161ke75,jxswcj4,Co-dfns is a dialect of APL written in itself.,0.0,apl
161ke75,jxt4p0i,"A traditional Forth reader is pretty much trivial—grab a string of nonspace characters, check if they parse as a number, or refer to a defined name (“word”), and either compile or interpret the result according to the current mode.",0.1125,forth
161ke75,jxt4p0i,"APL can express parsers very compactly for grammars that vectorise well, but ironically, APL itself is kind of hard to do that with.",0.16944444444444443,apl
161ke75,jxt9lwv,"As far as APL goes, Aaron Hsu wrote a parallel APL compiler ~~in 17 lines of APL~~ (*edit:* incorrect, see reply below), [which this sub discussed a few years ago](https://old.reddit.com/r/ProgrammingLanguages/comments/k258ez/a_gpucpu_hosted_compiler_written_in_17_lines_of/).",-0.03333333333333333,apl
161ke75,jxt9lwv,"But that does not include the APL run-time, which is still written in C/C++, so it feels like a bit of a cheat to call it a *complete* compiler (it's still really impressive)  EDIT: I just noticed you were also commenting in that discussion so let's just say I'm posting this for people reading along ;)",0.45,apl
161ke75,jxuqjv2,Co-dfns isn't '17 lines of apl'.,0.0,apl
161ke75,jxuqjv2,One particular interesting component of co-dfns is 17 lines of apl.,0.3333333333333333,apl
16198e7,jxqlwi7,You may want to check out the stack-based Forth programming language.,0.0,forth
16198e7,jxqlwi7,"Like your opcodes, Forth primitives get their arguments from the stack and return values to the stack.",0.0,forth
16198e7,jxqlwi7,"For that reason, Forth provides several stack manipulation “words” like DUP, ROT, OVER, and PICK.",0.0,forth
16198e7,jxs1vp0,"Forth or Factor will help you get real comfy with stack based programming, although it might be a hefty investment",0.2,forth
16198e7,jxzc1vw,"Go ahead and add that link to your original post, if you can edit it.",0.375,go
1612opy,jxsf77y,"Now that I've done that, I might go back to procrastination mode :P",0.375,go
1612opy,jxupxdx,It's a common technique when implementing a FORTH.,-0.3,forth
160m27p,jxnlwc5,* C was designed to write Unix in.,0.0,c
160m27p,jxnlwc5,* Lua was designed to meet the business needs of the Brazilian national electricity company.,0.0,lua
160m27p,jxnlwc5,* Javascript was designed to write interactive webpages.,0.0,javascript
160m27p,jxnlwc5,"* PHP, despite its flaws, succeeded because the author had something so definite in mind that he called his language **P**ersonal **H**ome **P**age.",0.0,php
160m27p,jxnlwc5,"* Go has been called ""a domain-specific language for writing servers"".",0.0,go
160m27p,jxnlwc5,* Rust is a systems language.,0.0,rust
160m27p,jxnpkt7,"You could go on /r/Shoes and ask if we really need all these kinds of shoes and you would find similarly impassioned responses explaining the importance of many types of shoes, similar to responses you will find here in regard to programming languages.",0.175,go
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,assembly
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,c
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,c++
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,java
160m27p,jxo0o8e,"The point of all programming languages is to build an abstraction over assembly, whether directly - C, C++ and other compiled languages - or indirectly - via a virtual machine such as Java, Python, ... .",-0.008333333333333331,python
160m27p,jxo0o8e,"So, all programming languages produce assembly at some point of their lives, and that is done via an interface the human interacts with: the syntax.",0.0,assembly
160m27p,jxo0o8e,You could really - theoretically  - generate the same assembly with any programming language out there.,0.0,assembly
160m27p,jxo0o8e,"Since the target language is always one - assembly, why bother having multiple source languages after all?",0.0,assembly
160m27p,jxo0o8e,"Why rewriting the same usual algorithms and data structures again and again for every new language out there, if the final target will always be one - assembly?",-0.02840909090909091,assembly
160m27p,jxp7vta,"It is far easier to make a new language to learn about this stuff than trying to target common languages like C and C++, C# etc...",-0.02121212121212121,c
160m27p,jxp7vta,"It is far easier to make a new language to learn about this stuff than trying to target common languages like C and C++, C# etc...",-0.02121212121212121,c++
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,c++
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,c
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,javascript
160m27p,jxp7vta,"2) Need for new language to decrease development time & cost: compare between C++ which was a huge step from C, to C#, Javascript, Python...  3) One is not enough, because C is great for making low level stuff like kernels, OS, interpreters etc... but it is really restricted if you want to do simple things, so there is a need for higher level languages",0.22329545454545455,python
160m27p,jxnil6p,"Not to mention some people just like to think different ways, and it's really hard to program with mutation if you're in Haskell or something.",-0.14583333333333334,haskell
160m27p,jxnil6p,In the same vein it's hard to program functionally in C.,-0.14583333333333334,c
160m27p,jxsj99r,"If you're feeling brave, go look up some information on it.",0.8,go
160m27p,jxpdgfl,Then you can switch to Rust like mode if you want that level of performance (technically better than Rust performance).,0.5,rust
160hdhl,,"It's kind of like `lex` and `yacc`, but I think it's cleaner -- the library is written in C (ie.",0.6,c
160hdhl,,"I've coded up a simple AST-walking lisp interpreter using the library, which I think is neat.",0.0,lisp
160hdhl,jxqbj9k,"I've currently tested it out using lisp's bnf, but I need to try out a few other bnfs to make sure it works.",0.04375,lisp
160hdhl,jxqbj9k,The lisp parser uses right-left parsing.,0.0,lisp
160aa15,jxllcqh,That’s pretty cool.,0.3,cool
160aa15,jxo43qa,Wow this is really cool.,0.22499999999999998,cool
160a70g,jxmqf23,"It was missing a lot of stuff, but it was actually usable, mostly because I could just throw actual C code in the middle of the program when there was something I couldn't do, with the help of some scripts I was also able to reference variables from zimbu itself.",0.13333333333333333,c
1608s3v,jxndsht,](https://en.wikipedia.org/wiki/Fuzzy_set) It seems like there's not much to go off -- the buildup to Houdini doesn't actually describe the system!,-0.05,go
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,c
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,c++
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,java
1608s3v,jxlwzb9,"As examples of industrial compilers that use SSA, we can cite GCC and Clang/LLVM, the two main compilers for C and C++, along with the compiler for the HotSpot VM for Java and V8 VM for JavaScript.",0.16666666666666666,javascript
15zxwjj,jxkxgdr,> Assignments using store go left to left; but the ones done using%4 = ... for example go right to left?,0.07142857142857142,go
15zxwjj,jxkxgdr,"> Your store example uses two operands both using ptr %x, so the same rank for both, used to implement C code where LHS and RHS have different ranks.",-0.26666666666666666,c
15zxwjj,jxlg3uk,"The only language I can think of that combines this with parsing is Lua, pretty much every other language out there separates this into distinct phases.",0.125,lua
15zobnr,,"Since I am using the Haskell recursion-schemes anyway, I am able to use either Cofree or a Functor product with Fix to inject extra information for every node.",0.25,haskell
15zobnr,jxshcrd,"I can only speak about my C++ implementation, which basically had a struct called Node, and within it had a bunch of different structs like FunctionNode, ObjectNode, ListNode, ForLoopNode etc.",0.0,c++
15z5kwb,jxgk16h,"But you wouldn't just go around substituting other sets with ones that have bijections, would you?",-0.125,go
15z5kwb,jxfbob5,I'm a big fan of that safe navigation syntax where you can use `_` where you want the value from the previous step to go:  ``` currentOrderId ?,0.11111111111111112,go
15z5kwb,jxs5h7m,"For example, a type like Rust's Option<T> can itself be generalized as Result<T, ()>, meaning bool could be generalized as Result<(), ()>.",0.0,rust
15z5kwb,jxgwpr1,"But if we compare this, for example, Rust code:  ``` fn main() {    let i: Option<()> = Some(());    i .map(|x| print!",0.20833333333333331,rust
15z5kwb,jxgwpr1,"(""Nope"")); } ```  with this C++ code:  ``` auto i = true; i ?",0.35,c++
15z5kwb,jxgwpr1,"Rust chosen first approach, Argentum chosen second.",0.125,rust
15z5kwb,jxtj23n,"No one prevents you from creating user-defined classes and go down the path of `result` analysis:  ``` class Result(R, E) {    ok = ?R;    err = ?E; } ```  Argentum on the other hand will go another way: passing error handlers as lambdas:  ``` fn parseInt(from String, onBadFormat(), onOverflow()) int {    ... ?",0.07314814814814814,go
15z5kwb,jxtj23n,"No one prevents you from creating user-defined classes and go down the path of `result` analysis:  ``` class Result(R, E) {    ok = ?R;    err = ?E; } ```  Argentum on the other hand will go another way: passing error handlers as lambdas:  ``` fn parseInt(from String, onBadFormat(), onOverflow()) int {    ... ?",0.07314814814814814,r
15z5kwb,jxfoq1i,"operator is equivalent to map in many languages, compare with the type of haskell's fmap.",0.5,haskell
15z5kwb,jxfoq1i,"```0 if [] else 1``` in python, which I'd consider moderately error prone.",0.0,python
15z5kwb,jxfoq1i,"In short, a lot of languages have the same capabilities (Rust and Haskell could trivially reproduce this) and decided not to do it.",0.0,rust
15z5kwb,jxfoq1i,"In short, a lot of languages have the same capabilities (Rust and Haskell could trivially reproduce this) and decided not to do it.",0.0,haskell
15z5kwb,jxfvg57,Also the `:` operator is called `fromMaybe` in Haskell.,0.0,haskell
15z5kwb,jxfvg57,"In Rust, the `?` operator is `Option::map`, the `:` operator is `Option::or_else`, and the combination of the two is `Option::map_or_else`.",0.0,rust
15z5kwb,jxg4lvw,"}  can be implemented in, say, Rust as:      fn to_message(number: Option<i32>) -> String {         number                 .map(|n| format!",0.0,rust
15z5kwb,jxg4lvw,I should borrow Rust approach?,0.0,rust
15y88kx,jxnax8q,Very cool.,0.45499999999999996,cool
15y4cfv,jxbz3gu,Ruby also does this.,0.0,ruby
15y4cfv,jxc09du,"I do quite close to this for `{ }`, with the exception of the semicolon (It's basically `begin` from Scheme with an alternative syntax).",0.0,scheme
15y4cfv,jxdfsk5,"The C [comma operator](https://en.wikipedia.org/wiki/Comma_operator) is similar to this: evaluate from left to right, discard each result except the last.",0.07142857142857142,c
15y4cfv,jxew9t3,See Python.,0.0,python
15xqv3w,jxcx0sb,"So, I think adding optional freedom would nice (like Rust's unsafe keyword but using types).",0.6,rust
15xqv3w,jxdo2um,"So far, nothing out of the ordinary - Scheme behaves this way.",-0.075,scheme
15xqv3w,jy3xstq,"my ($a, $b, $c) = 42, 99;     say $c = $a - $b; # -57  `42` and `99` are literal `Int`s.",0.0,c
15xqv3w,jy3xstq,And `$c` ends up being assigned an `Int`.,0.0,c
15xqv3w,jy3xstq,"Now add an explicit `Int` constraint:      my Int ($a, $b, $c) = 42, 99;     say $c = $a - $b; # -57  This has exactly the same outcome.",0.125,c
15xqv3w,jy3xstq,"So this:      my Int ($a, $b, $c) = 42, 99, 0;     say $c = $a - $b; # -57     sub gimme-a-string (Str $foo) {}     gimme-a-string $c; #   Never displays `-57` because it's a *compile time* failure:      SORRY!",-0.4708333333333333,c
15xqv3w,jy3xstq,"Calling gimme-a-string(Int) will never work with declared signature (Str $foo)  If I now remove the `Int` the code displays `-57` and then stops with a *run time* failure:      Type check failed in binding to parameter '$foo'; expected Str but got Int (-57)  Now let's switch to a (still boxed) *unsigned* integer:      my UInt ($a, $b, $c) = 42, 99, 0;     say $c = $a - $b; # Type check failed in assignment to $c; expected UInt but got Int (-57)  This *run* time failure is not necessarily fatal:      my UInt ($a, $b, $c) = 42, 99, 0;     try $c = $a - $b;     say $c; # 0  (No catch handling is specified, but a `try` defaults to keeping going if semantics are defined to allow that for some exception, and in this case it can.)",-0.2619047619047619,c
15xqv3w,jy3xstq,"my ($a, $b, $c) = 42, 99;     try $c = $a - $b;     say $c; # -57  And finally, for this section, behavior would be different again if we switched to an *unboxed native* unsigned integer:      my uint ($a, $b, $c) = 42, 99, 0;     $c = $a - $b;     say $c; # 18446744073709551559  That's because the semantics for native numbers is to overflow, without raising an exception.",0.0,c
15xmg2b,jx8yx6p,A big result of oracle v Google over java and Android was (correctly) finding that APIs/interfaces can't be copyrighted.,0.0,java
15xmg2b,jx79jpn,Like macros and shell at the same time.,0.0,shell
15xmg2b,jx79jpn,"I think he believes he will go to hell if he does not answer emails, he told me something flippant like 'it does not contribute to the free software word'.",0.4,go
15xmg2b,jx79jpn,"Throw some Guile and Python in, source in both Java and C. Would be fun.",0.3,python
15xmg2b,jx79jpn,"Throw some Guile and Python in, source in both Java and C. Would be fun.",0.3,java
15xgt8b,,• adores its shared mutable state • embraces radical complexity • has a brick wall for interop with C.,0.0,c
15xgt8b,jx74ln8,This is pretty close to just C++ isn't it?,0.25,c++
15xgt8b,jx6oe02,#### **Lesson 6: Exception Handling - Embracing the Unexpected** When things go wrong (and they will): ```fiasco try {     riskyBusiness(); } unpredictablyCatch (chaos e) {     throw surpriseParty(e); } ``` Because who doesn't love a good surprise?,0.19999999999999998,go
15xgt8b,jx79qy5,But without C interop.,0.0,c
15xgt8b,jx6y28u,Not as good as C tbh (a truly perfect programming language),0.85,c
15xgt8b,jx91xk4,I've seen your profile and you r just trying to bring people down.,-0.15555555555555559,r
15xgt8b,jx8hiks,Because birds are lame and single letters are cool and I'm divorced and my children won't talk to me,-0.07380952380952381,cool
15xgt8b,jx9afhu,Because birds are lame and single letters are cool and I'm divorced and my children won't talk to me,-0.07380952380952381,cool
15xgt8b,jx92fzu,yeah that's quite cool lol.,0.575,cool
15xgt8b,jx9aym4,"I c now, thanks for the explanation",0.2,c
15xcm53,,"So, things go on bit by bit, and I'm slowly approaching the production version, hoping to be finally used by hobby programmers researching and fastly prototyping custom formal systems.",0.06666666666666667,go
15x8bal,jx52y0o,"A lot of languages just use the logical operators for this, for example in Julia [https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation](https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation)  Additionally, you seem to have a concept of falsy and truthy, which has its dangers.",0.25,julia
15x8bal,jx53j7i,That's pretty cool!,0.34375,cool
15x8bal,jx8yvyk,"_ = None      (:) :: Option a -> Lazy a -> a     (Some x) : _ = x     None : x = (force x)  With language support you could auto-lazy the RHS of both operators, or you wouldn't even need to do that in a lazy by default language like Haskell, though we can already express the same things in a slightly different way with `maybe`.",-0.125,haskell
15x8bal,jx5i5gf,Let's compare the two a bit...  Syntax wise:      // Ternary operator     v = c ?,0.7,c
15x8bal,jx5i5gf,"a : b;          // If/else expression     v = if c { a } else { b };  You're obviously right, the ternary operator is *way* shorter, but let's look at a relatively simple example you might see in the real world: parsing a hex digit!",0.3214285714285714,c
15x8bal,jx5i5gf,// Ternary operator     v = c <= '9' ?,0.0,c
15x8bal,jx5i5gf,"c - '0' : c - 'A' + 10;          // If/else expression     v = if c <= '9' { c - '0' } else { c - 'A' + 10 };  You end up saving 10 characters using the more terse C-style ternary operator, but it's honestly very messy to me.",-0.17,c
15x8bal,jx5i5gf,"This gets exponentially worse the more complex it becomes:  Let's assume we *don't* know whether or not `char` is an upper hexadecimal digit, and that we should return `-1` if it is *not*:      v = c >= '0' && c <= '9'         ?",-0.05,c
15x8bal,jx5i5gf,c - '0'          : c >= 'A' && c <= 'F'             ?,-0.75,c
15x8bal,jx5i5gf,c - 'A' + 10             : -1;  Aaaand... line noise.,0.0,c
15x8bal,jx5i5gf,"v = if c >= '0' && c <= '9' {         c - '0'     } else if c >= 'A' && c <= 'F' {         c - 'A' + 10     } else {         -1     };   Sure, it's more verbose (two extra lines, although one is only the ending `};` delimiters), but honestly - give me verbosity any day over the mess above.",0.20357142857142857,c
15x8bal,jx5i5gf,"Another thing to consider is that, to express a sequence of `n` conditions (`c[0]..c[n-1]`) and their associated values `v[0]..v[n-1]`, you will eventually need `n` levels of indentation for `v[n-1]`!",0.0,c
15x8bal,jx6xnmm,In my language the syntax for if expressions is `if a: b else c` so it's not particularly verbose to use that instead of a ternary operator.,0.3333333333333333,c
15x8bal,jx9gc5l,">v = if c >= '0' && c <= '9' {c - '0'} else if c >= 'A' && c <= 'F' {c - 'A' + 10} else {-1};  If you wish using block expression, in Argentum this will be pretty much the same:  ``` v = c >= '0' && c <= '9' ?",0.15,c
15x8bal,jx9gc5l,{    c - '0' } : c >= 'A' && c <= 'F' ?,-0.75,c
15x8bal,jx9gc5l,{    c - 'A' + 10 } : {    -1 }; ```  Details are here: [argentum\_has\_no\_statements\_only\_expressions](https://www.reddit.com/r/ArgentumLanguage/comments/15y2oql/argentum_has_no_statements_only_expressions/),-0.75,c
15x8bal,jx8l4e6,v = c >= '0' && c <= '9' ?,0.0,c
15x8bal,jx8l4e6,c - '0' :         c >= 'A' && c <= 'F' ?,-0.75,c
15x8bal,jx8l4e6,c - 'A' + 10 :         -1;  It is analogous to a switch/case.,0.0,c
15x8bal,jx5lhbh,"In Argentum it is:      range = (from, to, handler) {         c >= from && c <= to ?",-0.75,c
15x8bal,jx5lhbh,"handler()     };     v = range('0', '9', c - '0') ||         range('a', 'f', c - 'a' + 10) ||         range('A', 'F', c - 'A' + 10) : -1;  But it uses lambdas and operator `||`, so I should write about them first.",0.25,c
15x8bal,jx5myqp,"Most languages actually have more terse way to express the logic I'm trying to capture, for example in Rust the same can simply be done with:      v = match c {         b'0'..=b'9' => c - b'0',         b'A'..=b'F' => c - b'A' + 10,         _ => 255,     } as i8;  You can ignore the `b'...'` prefix, the sentinel `255` instead of `-1`, and the `as i8`; these just have to do with Rust's `char` type being different from the signed bytes I used in my example above.",0.14285714285714285,rust
15x8bal,jx5myqp,"Most languages actually have more terse way to express the logic I'm trying to capture, for example in Rust the same can simply be done with:      v = match c {         b'0'..=b'9' => c - b'0',         b'A'..=b'F' => c - b'A' + 10,         _ => 255,     } as i8;  You can ignore the `b'...'` prefix, the sentinel `255` instead of `-1`, and the `as i8`; these just have to do with Rust's `char` type being different from the signed bytes I used in my example above.",0.14285714285714285,c
15x8bal,jx5myqp,"A more idiomatic Rust example would be:      let v = match c {         '0'..='9' => Some(c as u32 - '0' as u32),         'A'..='F' => Some(c as u32 - 'A' as u32 + 10),         _ => None,     };  But this isn't quite the same as my original example semantically since it does things like encoding errors in the type system, uses 32-bit unsigned ints instead of 8-bit signed ints, and only work on previously validated Unicode scalar values.",0.14166666666666666,rust
15x8bal,jx5myqp,"A more idiomatic Rust example would be:      let v = match c {         '0'..='9' => Some(c as u32 - '0' as u32),         'A'..='F' => Some(c as u32 - 'A' as u32 + 10),         _ => None,     };  But this isn't quite the same as my original example semantically since it does things like encoding errors in the type system, uses 32-bit unsigned ints instead of 8-bit signed ints, and only work on previously validated Unicode scalar values.",0.14166666666666666,c
15x8bal,jx5myqp,"Edit: This isn't relevant to anything, but in trying to figure out a nicer way to do this in C++ rather than with `if` statements, I accidentally did this:      v = 0;     switch (c) {         case 'F': ++v;         case 'E': ++v;         case 'D': ++v;         case 'C': ++v;         case 'B': ++v;         case 'A': ++v;         case '9': ++v;         case '8': ++v;         case '7': ++v;         case '6': ++v;         case '5': ++v;         case '4': ++v;         case '3': ++v;         case '2': ++v;         case '1': ++v;         case '0': break;         default: v = -1;     }  ***ಠ╭╮ಠ***",0.4,c++
15x8bal,jx5myqp,"Edit: This isn't relevant to anything, but in trying to figure out a nicer way to do this in C++ rather than with `if` statements, I accidentally did this:      v = 0;     switch (c) {         case 'F': ++v;         case 'E': ++v;         case 'D': ++v;         case 'C': ++v;         case 'B': ++v;         case 'A': ++v;         case '9': ++v;         case '8': ++v;         case '7': ++v;         case '6': ++v;         case '5': ++v;         case '4': ++v;         case '3': ++v;         case '2': ++v;         case '1': ++v;         case '0': break;         default: v = -1;     }  ***ಠ╭╮ಠ***",0.4,c
15ww9sh,jx375ro,"Thus I suggest just return unit(like in rust), unless you have a good reason for doing otherwise.",0.7,rust
15ww9sh,jx41vwu,a = b = c = x + y;,0.0,c
15ww9sh,jx54vnj,"Someone would learn this once and go on with their life after that  Implementations of map types often do exactly this, where `map.set(k, v)` will return whatever the previous value of `map.get(k)` would have been.",0.04166666666666667,go
15ww9sh,jxcfl7i,"(a, b) = (b, c)  Should be able to work in linear types.",-0.125,c
15ww9sh,jx4rz7r,"In Rust, you have to use convoluted workarounds like `mem::swap(&mut a, &mut b)` instead.",0.0,rust
15ww9sh,jx86fpl,"Like in perl, none of the weird operators are hard to understand, but how about code golfs?",-0.39583333333333337,perl
15ww9sh,jx86fpl,"``` $ perl -le 'for (1..100) {print(""FizzBuzz""), next if not $_%15; \  print(""Buzz""), next if not $_%5; print(""Fizz""), next if not $_%3; prin +t}'; ```",0.0,perl
15ww9sh,jxcguy4,"> I think destructuring assignments should be able to affect control flow...  Not sure if this is what you mean, but in Rust control flow constructs come in two flavors: one that accepts booleans (ex.",-0.020833333333333332,rust
15wdiqh,jx0akqq,"**  Some tips:  You could dive in, into several projects, code and documentation, like Modula and Ada.",0.0,ada
15wdiqh,jx0akqq,"Java, C# and similar V.M.",0.0,java
15wdiqh,jx0akqq,"Java, C# and similar V.M.",0.0,c
15wdiqh,jx0akqq,Pascal branch of P.L.,0.0,pascal
15wdiqh,jx0akqq,Java and C++ uses classes definitions as modules.,0.0,java
15wdiqh,jx0akqq,Java and C++ uses classes definitions as modules.,0.0,c++
15wdiqh,jx0akqq,**  C++ and Java mix both.,0.0,c++
15wdiqh,jx0akqq,**  C++ and Java mix both.,0.0,java
15wdiqh,jx0akqq,Delphi doesn't.,0.0,delphi
15wdiqh,jx0akqq,"**  Pascal call them ""unit (s)"".",0.0,pascal
15wdiqh,jx0akqq,"**  Java ""package (s)"" sometimes does this.",0.0,java
15wdiqh,jx0akqq,"There's an special single main folder module as the ""global"" namespace in C++.",0.11309523809523808,c++
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,delphi
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,c++
15wdiqh,jx0akqq,"In terms of implementation, a special file can be used to store and install a folder module, this is what a Delphi ""package"" or a C++ ""assembly"" does.",0.35714285714285715,assembly
15wdiqh,jx0akqq,"C++ ""namespace"" does not have this directly.",0.1,c++
15wdiqh,jx0akqq,Delphi does.,0.0,delphi
15wdiqh,jx0akqq,Java and C++ emulate this using a class and a static constructor and a static destructor.,0.5,java
15wdiqh,jx0akqq,Java and C++ emulate this using a class and a static constructor and a static destructor.,0.5,c++
15wdiqh,jx0akqq,"A lot of programers, in C and C++, emulate this by explicitly declaring and calling some functions.",0.0,c
15wdiqh,jx0akqq,"A lot of programers, in C and C++, emulate this by explicitly declaring and calling some functions.",0.0,c++
15wdiqh,jx0akqq,This is emulated in Java and C# with static fields and static methods.,0.5,java
15wdiqh,jx0akqq,This is emulated in Java and C# with static fields and static methods.,0.5,c
15wdiqh,jx0akqq,"A ""only one mandatory file per (file) module"" approach is better, like Delphi / Turbo Pascal.",0.25,delphi
15wdiqh,jx0akqq,"A ""only one mandatory file per (file) module"" approach is better, like Delphi / Turbo Pascal.",0.25,pascal
15wdiqh,jx0akqq,"C++ allows not using a namespace at all, or using anonymous namespaces, or using several same level namespaces in one single file.",-0.023809523809523808,c++
15wdiqh,jx0akqq,"C++ uses anonymous namespaces, it works, but not recommended.",0.0,c++
15wdiqh,jx0akqq,"Modula, Ada also splits ""interface"" and ""implementation"" sections.",0.0,ada
15wdiqh,jx0akqq,Delphi and FreePascal approach works better.,0.5,delphi
15wdiqh,jx0akqq,"**  This works similar to *.obj or *.o files and *.h, *.hpp files generated by C or C++ compilers.",0.0,c
15wdiqh,jx0akqq,"**  This works similar to *.obj or *.o files and *.h, *.hpp files generated by C or C++ compilers.",0.0,c++
15wdiqh,jx0akqq,Delphi and FreePascal and TurboPascal had this for years.,0.0,delphi
15wdiqh,jxewkby,"* Phase management - you'd like to separate code that is used for metaprogramming or compile-time processing from code used at run time, allowing compile-time dependencies to be avoided when compiling the final binary (see Racket for an example of a language that does this)  * Blame boundaries for run-time errors - when a run-time error occurs, you'd like to identify which party violated its contracts in order to give an error message that indicates where to go to fix the bug.",0.0,go
15wdiqh,jx1p0d5,"In a sense, classes serve as poor mans modules in Java and C#.",-0.4,java
15wdiqh,jx1p0d5,"In a sense, classes serve as poor mans modules in Java and C#.",-0.4,c
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,pascal
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,java
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,perl
15wdiqh,jx19kyc,"But for inspiration, I'd direct you to  * UCSD-Pascal units * what Borland did with that for Turbo Pascal * Java's two different mechanisms: class-path and (new-style) modules * Perl, and in particular CPAN, the Comprehensive Perl Archive Network * Python, which allows you to replace the built-in module system dynamically * Modula-2, which was designed with modularity in mind.",0.08888888888888889,python
15wdiqh,jx5fasi,"Then, a very basic implementation is illuminated in [https://xavierleroy.org/publi/modular-modules-appendix/](https://xavierleroy.org/publi/modular-modules-appendix/) \- it covers both a system for ""mini ML"" and ""mini C"" (by use of modules to abstract over details, hence ""modular modules"").",0.0,c
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,go
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,rust
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,c
15wdiqh,jx0v0zw,"something like a cross between Go, Rust, ML, C (yes it has good parts, see discussions), Swift , .... :)",0.39999999999999997,swift
15wdiqh,jx15ogi,"Oh hey, we meet again :D  Good point about Modula...I guess I could peer into freepascal too.",0.85,d
15wdiqh,jxbyyzb,"I have been meaning to check out D more closely, extra motivation now :)",0.3333333333333333,d
15wdiqh,jx3ds7u,Delphi / FreePascal and C# were highly productive and organized.,0.16,delphi
15wdiqh,jx3ds7u,Delphi / FreePascal and C# were highly productive and organized.,0.16,c
15wdiqh,jx3ds7u,BTW The same guy that lead the C# project was one of the Delphi developers.,0.0,c
15wdiqh,jx3ds7u,BTW The same guy that lead the C# project was one of the Delphi developers.,0.0,delphi
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,java
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,c++
15wdiqh,jx3ds7u,"Java or C++ or PHP with namespaces works, but it has a lesser ""expressivity"" in terms of modular organization.",0.0,php
15wdiqh,jx3ds7u,Java didn't allow this.,0.0,java
15wdiqh,jx3ds7u,"But, in C# or FreePascal, I can have a ""Toolbars"" module with those classes.",0.0,c
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,php
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,c
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,java
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,c++
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,delphi
15wdiqh,jx3cfbv,"After working with several P.L., like PHP, KñJS, C#, Java,C++, this approach, commonly used by Delphi / Turbo Pascal / FreePascal seemed more practical.",0.06666666666666667,pascal
15wdiqh,jx31loy,"There is a special main or root folder like the ""global"" namespace of C++.",0.17460317460317462,c++
15wdiqh,jx31loy,"That single module per file would be similar to a Java class declaration, but can contain types, variables, classes or types declarations, functions.",-0.03571428571428571,java
15wdiqh,jx2url0,"https://faultlore.com/blah/swift-abi/ - Swift is a language for an OS, so they prioritized a dynamic ABI component, similar to what Windows COM solved -- dynamic  modules at bigger a scale larger than static modules   ABIs are basically the dynamic part (not compiled together) part of a static module system (compiled together)  ----  Matklad has been thinking about modules a lot too, some good observations:  https://lobste.rs/s/vx8hbs/rust_module_system_encourages_poor  https://lobste.rs/s/47amaq/rust_i_wanted_had_no_future#c_vj5c1c  https://matklad.github.io/2023/03/28/rust-is-a-scalable-language.html  ---  If you're interested in dynamic composition of components written in static languages, I'd also look at plugin systems for big apps ... almost all apps grow them -- the browser, Word, Excel, Photoshop, Maya, etc.",0.18846153846153849,swift
15wdiqh,jy2fhvu,"For instance, functions in C are not first-class, but they are first-class in JavaScript.",0.0,c
15wdiqh,jy2fhvu,"For instance, functions in C are not first-class, but they are first-class in JavaScript.",0.0,javascript
15wdiqh,jy2fhvu,"There are no C expressions that denote functions, even if they might denote the memory address of a function.",0.0,c
15wdiqh,jy2fhvu,"Similarly, memory locations are first-class in C, but not in JavaScript.",0.0,c
15wdiqh,jy2fhvu,"Similarly, memory locations are first-class in C, but not in JavaScript.",0.0,javascript
15wdiqh,jy2fhvu,"Scala's path-dependent types, type members, and traits are also a way of doing these things, and Scala's object system is an ML-style module system if you know which angle to look at it from.",0.0,scala
15w9zef,,"I have a kind of outdated website here [http://jeebox.org](http://jeebox.org) and you can compile it in C++ via my github at [http://gamblevore.org](http://gamblevore.org) and see some docs here [http://docs.gamblevore.org/Message.md](http://docs.gamblevore.org/Message.md)  My github has many projects within it, one is to create the libJeebox.dll (or .so or .dylib).",0.2333333333333333,c++
15w9zef,,"It will create a lib and some C++ header code, and C header code too.",0.0,c++
15w9zef,,"It will create a lib and some C++ header code, and C header code too.",0.0,c
15w9zef,,* libJeebox works but what if you are writing a compiler in another language that doesn't work with C APIs?,0.0,c
15w9zef,,In fact I've designed jeebox so that you can validate and access your code in the same go.,0.0,go
15w9zef,,Not sure where to go with that.,-0.25,go
15w9zef,jx0pxas,"If we have an expression `a op1 b op2 c`, is it parsed as `(a op1 b) op2 c` or `a op1 (b op2 c)`, since both could be a valid parse.",0.0,c
15w9zef,jx0u7jj,"The code that uses jeebox has to re-order the tree :)  `a+b+c+d` gives this tree:      rel          thg ""a""         opp ""+""         rel              thg ""b""             opp ""+""             rel                  thg ""c""                 opp ""+""                 thg ""d""  As for non-operator syntax... it has precedence.",0.5,c
15w9zef,jx0u7jj,"The code that uses jeebox has to re-order the tree :)  `a+b+c+d` gives this tree:      rel          thg ""a""         opp ""+""         rel              thg ""b""             opp ""+""             rel                  thg ""c""                 opp ""+""                 thg ""d""  As for non-operator syntax... it has precedence.",0.5,d
15w9zef,jx1l59l,"Still cool, but it skews performance stats if you leave so much to later passes as you're doing a lot less early on.",0.07083333333333333,cool
15w0gic,jwyvlh3,"I would parse as a non-empty linked list, since to resolve the symbols you generally need to go from left to right in sequence.",0.11190476190476191,go
15w0gic,jwzr6hh,"EXPRESSION      a.b.c  AST      DotNode(         instance: DotNode(             instace: Identifier(""a""),             member: ""b""         ),         member: ""c""     )  STACK IR      LoadName ""a""     LoadAttr ""b""     LoadAttr ""c""",0.0,c
15w0gic,jwzd0i5,"So a.b.c creates a list of [""a"", ""b"", ""c""].",0.0,c
15w0gic,jwzwws7,"Using Rust as an example, you'd end up with something like this:      struct GetField { receiver: Expression, name: String }     enum Expression { GetField(Box<GetField>), ... }  If you want a chain of fields to result in a single AST node, you'd need something like this instead:      struct FieldChain { receiver: Expression, names: Vec<String> }  That way you'd end up with something like this:      (field ""attr1"" ""attr2"" (identifier ""value""))",-0.4107142857142857,rust
15w0gic,jx04i98,I would invert that AST so that `c` is in the innermost node and `a` in the outer one.,0.0,c
15w0gic,jx04i98,"You generally can't resolve `c` until you have resolved `b`, and can't resolve `b` unless you know `a`.",0.05000000000000002,c
15w0gic,jx0dc7o,"I think the approach I proposed is used in imperative languages, examples of languages I knew to use the same approach are c/c++ (gcc, clang), python, javascript, rust, c#, zig and others",0.0,python
15w0gic,jx0dc7o,"I think the approach I proposed is used in imperative languages, examples of languages I knew to use the same approach are c/c++ (gcc, clang), python, javascript, rust, c#, zig and others",0.0,javascript
15w0gic,jx0dc7o,"I think the approach I proposed is used in imperative languages, examples of languages I knew to use the same approach are c/c++ (gcc, clang), python, javascript, rust, c#, zig and others",0.0,rust
15w0gic,jx0dc7o,"I think the approach I proposed is used in imperative languages, examples of languages I knew to use the same approach are c/c++ (gcc, clang), python, javascript, rust, c#, zig and others",0.0,c
15vmmet,,"The quote :  ""I’ve programmed systems in many different languages; from assembler to Java.",0.25,java
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,fortran
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,cobol
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,c
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,pascal
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,c++
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,java
15vmmet,,"I’ve written applications in Fortran, COBOL, PL/1, C, Pascal, C++, Java, Lua, Smalltalk, Logo, and dozens of other languages.",-0.125,lua
15vmmet,,"I’ve used stack based languages like Forth, and logic based languages like Prolog.""",0.0,forth
15vmmet,,"I’ve used stack based languages like Forth, and logic based languages like Prolog.""",0.0,prolog
15vmmet,jwvywf3,"For examples, see most assembly languages, as well as most forths.",0.5,assembly
15vmmet,jwvzdo2,"I'm not sure specifically what he's referring to, but something like assembly is 'typeless'\*.",-0.25,assembly
15vmmet,jww6tts,"They aren't the only typeless languages, BCPL, BLISS, Forth, TCL and Bourne shell are typeless languages.",0.0,forth
15vmmet,jww6tts,"They aren't the only typeless languages, BCPL, BLISS, Forth, TCL and Bourne shell are typeless languages.",0.0,tcl
15vmmet,jww6tts,"They aren't the only typeless languages, BCPL, BLISS, Forth, TCL and Bourne shell are typeless languages.",0.0,shell
15vmmet,jww6tts,"""System languages"" need some typeless aspects to do what they are designed to do, hopefully those features are well controlled (that's not always the case, for instance C++ having evolved from C which itself can be considered as adding static types to BCPL have aspects which are justifiable only by its root in an untyped language).",0.25,c++
15vmmet,jww6tts,"""System languages"" need some typeless aspects to do what they are designed to do, hopefully those features are well controlled (that's not always the case, for instance C++ having evolved from C which itself can be considered as adding static types to BCPL have aspects which are justifiable only by its root in an untyped language).",0.25,c
15vmmet,jww6tts,"Static languages tend to acquire dynamic aspect (see the addition of object systems to C, Pascal, ML).",0.25,c
15vmmet,jww6tts,"Static languages tend to acquire dynamic aspect (see the addition of object systems to C, Pascal, ML).",0.25,pascal
15vmmet,jww6tts,"Dynamic languages also can acquire static aspects (see Typescript for Javascript, the type annotation of Python).",0.25,typescript
15vmmet,jww6tts,"Dynamic languages also can acquire static aspects (see Typescript for Javascript, the type annotation of Python).",0.25,javascript
15vmmet,jww6tts,"Dynamic languages also can acquire static aspects (see Typescript for Javascript, the type annotation of Python).",0.25,python
15vmmet,jww6tts,Byte  for assembly language.,0.0,assembly
15vmmet,jww6tts,"Word for older assembly language, BLISS, BCPL, Forth.",0.16666666666666666,assembly
15vmmet,jww6tts,"Word for older assembly language, BLISS, BCPL, Forth.",0.16666666666666666,forth
15vmmet,jww6tts,"Strings for TCL, shell and Make.",0.0,tcl
15vmmet,jww6tts,"Strings for TCL, shell and Make.",0.0,shell
15vmmet,jwwccqi,Typically shell languages,-0.16666666666666666,shell
15vmmet,jwwyvaz,"You should try Forth  Also I think you're mistaking ""memory layout"" for ""type"" and these are different aspects of computing systems",0.0,forth
15vmmet,jwwcmuu,Assembly (on most platforms) is a typeless language.,0.5,assembly
15vmmet,jwwcmuu,Forth is an interesting programming language because it has this very same property.,0.25,forth
15vmmet,jwwcmuu,Forth is a very simple virtual machine you can build for yourself in just a few hundred lines of assembly code.,-0.1,forth
15vmmet,jwwcmuu,Forth is a very simple virtual machine you can build for yourself in just a few hundred lines of assembly code.,-0.1,assembly
15vmmet,jwwcmuu,"It is significantly nicer than Assembly, without being meaningfully limited in scope and power, compared.",0.1517857142857143,assembly
15vmmet,jwxmzll,"According to wikipedia, the following are typeless languages:  * AutoHotkey * B * BCPL * Bliss * Forth * MUMPS (M) * Rexx",0.0,forth
15vmmet,jwvysqe,"I don't know much about clojure, but I did lisp for a while.",0.2,clojure
15vmmet,jwvysqe,"I don't know much about clojure, but I did lisp for a while.",0.2,lisp
15vmmet,jwvysqe,Clojure is probably a combination of the first 2.,0.25,clojure
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,java
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,c
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,rust
15vmmet,jwxju0x,"There can be types at runtime (JS, Java) or not (C, Rust), and there can be types at compile time (Rust) or not (Assembly)  Where there are no types at runtime, the behaviour of how to process this particular 2 contiguos bytes (for example) is embedded into the binary code.",0.16666666666666666,assembly
15vmmet,jxd4gnp,"Looking at Ada, it doesn’t have an Integer type.",0.0,ada
15vmmet,jz402cu,"See for example B which is a typeless language (and gave us nice things in C like the fact that arrays decay into pointer and pointer arithmetic, which are actually source compatibility hacks, and the fact that quite some C functions take int rather them char).",0.3,c
15vmmet,jww2gzi,"Depends on the assembly flavor, some don’t allow moving values between the alu and fp freely.",0.4,assembly
15vmmet,jww5ctx,"Interesting, yeah he does mention assembly later in the article so that could be it.",0.25,assembly
15vmmet,jww0mj2,"Yeah, I was going to say not even assembly is typeless - bits, bytes and words are the types.",0.0,assembly
15vmmet,jwwr8bh,"And of course, JavaScript comes to mind, unbidden, like a mosquito on the patio.",0.0,javascript
15vmmet,jwz6wzl,"Then I think you can *make* any language produce at least *runtime* type errors, for example you can create a JavaScript function that throws an error when it gets passed a non-integer-number, and you can make any typed language ignore some sort of type errors – in the sense that you can pass a non-e-mail-address to a function that expects an e-mail-address or a value in inches to a function that expects centimeters.",-0.3,javascript
15vmmet,jwz6wzl,"Javascript is generally thought to have no integers, but some interpreters use C-like integer representations anyway for speed and efficiency.",0.05000000000000002,javascript
15vmmet,jwz6wzl,Python can't prevent you from only using strings to represent numbers.,0.0,python
15vmmet,jwz6wzl,"Different thought:  In C, an `unsigned char` is used to represent a number between 0 and 255.",0.0,c
15vmmet,jwwzt43,"(in Forth there is no syntax distinction between ASCII 'A', an integer 97, a pointer to the 97th word of memory, etc.",0.0,forth
15vmmet,jx06f4d,I’ve been a Clojure programmer for a decade and his Clojure articles are rubbish.,0.0,clojure
15vmmet,jx06f4d,His published Clojure code is horrible.,-1.0,clojure
15vmmet,jx06f4d,"Sorry for the harsh words, but I’d not recommend any of his body of work to someone I was teaching.",-0.35,d
15vmmet,jww6afi,"Yeah those all just sound like descriptions of dynamic types.. also clojure isn't what he's describing as typeless, clojure is dynamically typed, the only mention of typeless is the quote that I had in my post.",0.13333333333333333,clojure
15vmmet,jx4spnp,But there is still the question of do you process using floating point math vs integer math.. that has to be encoded into the assembly somehow.,0.0,assembly
15vmmet,jx18sxt,You may have heard of it -- they called it `C`.),0.0,c
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,c
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,c++
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,haskell
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,lisp
15vmmet,jx18sxt,"(A few years later our best dev had switched to writing mostly C and C++ and I recall exploring many other PLs such as Miranda, the PL that led to Haskell, and other MLs, and Metacomco's Lisp -- Metacomco was the vendor of our BCPL; they wrote their Lisp implementation in BCPL -- and smalltalk like products such as Smalltalk/V and Whitewater's Actor, and BETA, Eiffel, Linda, and on and on.",0.17222222222222222,eiffel
15vmmet,jwz8n75,"For example, an i8 in Rust contains all integers from -127 to +128.",0.0,rust
15vbuyi,jwuwgs2,"So yeah, here are some facts about established programming languages:   Java does what you do.",0.0,java
15vbuyi,jwuwgs2,Scala works around the JVM limitation by introducing a compiler feature similar to C++ templates but much more limited.,0.14285714285714288,scala
15vbuyi,jwuwgs2,Scala works around the JVM limitation by introducing a compiler feature similar to C++ templates but much more limited.,0.14285714285714288,c++
15vbuyi,jwuwgs2,"In C#, generic type information is tracked at runtime.",0.0,c
15vbuyi,jwuwgs2,"Put in any other type and it's a T** if you're thinking in C (where the last layer is the pointer to the list which holds the array, since a list is a reference type).",-0.0625,c
15vbuyi,jwuwgs2,C++ obviously has templates.,0.0,c++
15vbuyi,jwuwgs2,"Similar to C#, but much more powerful.",0.26666666666666666,c
15vbuyi,jwuwgs2,"C has macros for this, which leads to all sorts of awful hacks to have generic collections.",-0.5,c
15vbuyi,jwupjpn,"A normal vector implementation looks like this (I'm using C++ because it gives low-level control):      template <class T> class vector {       T* data;       std::size_t len;       std::size_t cap; // you could have the invariant that len == cap, but then you can't over-allocate     public:       vector(): data(nullptr), len(0), cap(0) {} // don't allocate for an empty vector       vector(vector<T> const& other): data(std::malloc(other.len)), len(other.len), cap(other.len) {         std::memcpy(data, other.data, len);       }       ~vector() {         for (std::size_t i = 0; i < len; ++i) {           (data + i)->~T(); // call destructors on the data         }         std::free(data);       }       void reserve(std::size_t new_cap) {         if (cap < new_cap) {           data = std::realloc(data, new_cap);           cap = new_cap;         }       }       // these are the mutable accessors, constant ones are basically the same       T& operator[](std::size_t idx) {         // maybe add a bounds check         return data[idx];       }       T& first() {         return *data;       }       T& last() {         return data[len - 1];       }       void push_back(T val) {         if (len + 1 >= cap) {           switch (cap) {             case 0: reserve(1); break;             case 1: reserve(4); break; // skip from 1 to 4 because that's better in most cases             default: reserve(cap * 2); break; // double capacity to over-allocate           }         }         ++len;         last() = std::move(val);       }       // depending on your language, you might want to implement emplace_back, it's not too complicated       void pop_back() {         if (len) {           --len;           (data + len)->~T(); // call the destructor of the last element         }       }     };  This is a simplified implementation of C++'s `std::vector`.",0.048214285714285716,c++
15vbuyi,jwxplc8,"The capacity can be part of the static type, as in C++ `array<t, 255>`.",0.5,c++
15vbuyi,jwxplc8,However this will require your language to support something similar to C++ template specialization.,0.0,c++
15vbuyi,jwuqt3o,How low do you go?,0.0,go
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,go
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,rust
15uwmsd,,"Some languages like Go, Rust use `:` in their struct initialization syntax:      Foo {         bar: 10     }  while others use `=` such as C#.",0.0,c
15uwmsd,,"Swift uses `:` for passing arguments to named parameters (`foo(a: 10)`), why not `=`?",0.0,swift
15uwmsd,jwsq4yg,Ruby also uses `:` for passing named parameters.,0.0,ruby
15uwmsd,jwsq4yg,"And in Ruby's particular case, it makes a lot of sense.",0.16666666666666666,ruby
15uwmsd,jwsq4yg,"Now Ruby has real named arguments, so the ""turn it into a hash argument"" rule only kicks in on old-style functions that don't take any named parameters.",0.1,ruby
15uwmsd,jwskpy9,"In the C family of languages, assignment is an expression, so `a = b = c` is legal, and as a result, the `=` operator is a poor choice for named arguments.",-0.1,c
15uwmsd,jwskpy9,"The `=` assignments as expressions also leads to a few classes of common bugs in C family languages, so it's hard to defend in a new language, although it's easy to understand in an old languages with an enormous legacy codebase.",-0.017424242424242432,c
15uwmsd,jwu12xp,"IIrc, C# also use ':' for passing named arguments.",0.0,c
15uwmsd,jwtku1p,"To be fair to the designer of FORTRAN (John Backus, I guess), he didn't ""overload"" =, as FORTRAN originally used .EQ.",0.5375,fortran
15uwmsd,jwtku1p,"(Looking at [https://en.wikipedia.org/wiki/BCD\_(character\_encoding)#Fortran\_character\_set](https://en.wikipedia.org/wiki/BCD_(character_encoding)#Fortran_character_set), if they modified the character set to fit FORTRAN anyway, of course one could wonder why they designed a character set with ""="" instead of, for example ""←"".)",0.4,fortran
15uwmsd,jwtku1p,"Anyway, C making a ""virtue"" out of it (I believe Ritchie or someone else used the argument that assignment was more frequent than comparison for equality) and picking ""=="" for equality, at a time when ASCII was used, well *that* should not have happened.",0.3,c
15uwmsd,jwtku1p,"However, there is also ""←"", which I believe *was* considered for use as assignment in the publishing variant of Algol 60.",0.0,algol
15uwmsd,jwtku1p,"𝐩𝐫𝐨𝐜 foo(a int, b string, d point)     ...     foo(b: ""bar"", 117, (0, 0))          𝐩𝐫𝐨𝐜 dist (a, b 𝐩𝐨𝐢𝐧𝐭 | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞 | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞) 𝐫𝐞𝐚𝐥:     𝐛𝐞𝐠𝐢𝐧         𝐢𝐟 defined(b) 𝐭𝐡𝐞𝐧 𝐫𝐞𝐭𝐮𝐫𝐧 sqrt(a.x·b.x+a.y·b.y)         𝐞𝐥𝐬𝐞 defined(l) 𝐭𝐡𝐞𝐧 ...         𝐞𝐥𝐬𝐞 defined(c) 𝐭𝐡𝐞𝐧 ...         𝐟𝐢     𝐞𝐧𝐝     ...     d1 ← dist(a: p1, b: p2)     d2 ← dist(l: line(p2,p3), p1)  or      𝐩𝐫𝐨𝐜 dist (a, b 𝐩𝐨𝐢𝐧𝐭 | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞 | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞) 𝐫𝐞𝐚𝐥:     (defined(b): sqrt(a.x·b.x+a.y·b.y)     |defined(l): (l.a ≠ 0 ∨ l.b ≠ 0:                         abs(l.a·a.x+l.b·a.y+l.c)/sqrt(l.a²+l.b²)                  | l.a = 0: abs(l.b·a.y+l.c)/abs(b)                  | l.b = 0: abs(l.a·a.x+l.c)/abs(a))     |defined(c): (𝐥𝐞𝐭 r = c.radius, cp = c.center;                   𝐥𝐞𝐭 d = dist(a, cp);                   (d < r: r-d | d > r: d-r | d = r: 0)))  or as type matching:      𝐩𝐫𝐨𝐜 dist         𝐜𝐚𝐬𝐞 a, b 𝐩𝐨𝐢𝐧𝐭: sqrt(a.x·b.x+a.y·b.y)         | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞:             (l.a ≠ 0 ∨ l.b ≠ 0:                 abs(l.a·a.x+l.b·a.y+l.c)/sqrt(l.a²+l.b²)             | l.a = 0: abs(l.b·a.y+l.c)/abs(b)             | l.b = 0: abs(l.a·a.x+l.c)/abs(a))         | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞)𝐫𝐞𝐚𝐥: abs(dist(a, cp)-c.radius)         𝐞𝐬𝐚𝐜    all seem readable to me, even if they overload "":"" quite a bit.",-0.75,d
15uwmsd,jwtku1p,"𝐩𝐫𝐨𝐜 foo(a int, b string, d point)     ...     foo(b: ""bar"", 117, (0, 0))          𝐩𝐫𝐨𝐜 dist (a, b 𝐩𝐨𝐢𝐧𝐭 | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞 | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞) 𝐫𝐞𝐚𝐥:     𝐛𝐞𝐠𝐢𝐧         𝐢𝐟 defined(b) 𝐭𝐡𝐞𝐧 𝐫𝐞𝐭𝐮𝐫𝐧 sqrt(a.x·b.x+a.y·b.y)         𝐞𝐥𝐬𝐞 defined(l) 𝐭𝐡𝐞𝐧 ...         𝐞𝐥𝐬𝐞 defined(c) 𝐭𝐡𝐞𝐧 ...         𝐟𝐢     𝐞𝐧𝐝     ...     d1 ← dist(a: p1, b: p2)     d2 ← dist(l: line(p2,p3), p1)  or      𝐩𝐫𝐨𝐜 dist (a, b 𝐩𝐨𝐢𝐧𝐭 | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞 | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞) 𝐫𝐞𝐚𝐥:     (defined(b): sqrt(a.x·b.x+a.y·b.y)     |defined(l): (l.a ≠ 0 ∨ l.b ≠ 0:                         abs(l.a·a.x+l.b·a.y+l.c)/sqrt(l.a²+l.b²)                  | l.a = 0: abs(l.b·a.y+l.c)/abs(b)                  | l.b = 0: abs(l.a·a.x+l.c)/abs(a))     |defined(c): (𝐥𝐞𝐭 r = c.radius, cp = c.center;                   𝐥𝐞𝐭 d = dist(a, cp);                   (d < r: r-d | d > r: d-r | d = r: 0)))  or as type matching:      𝐩𝐫𝐨𝐜 dist         𝐜𝐚𝐬𝐞 a, b 𝐩𝐨𝐢𝐧𝐭: sqrt(a.x·b.x+a.y·b.y)         | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞:             (l.a ≠ 0 ∨ l.b ≠ 0:                 abs(l.a·a.x+l.b·a.y+l.c)/sqrt(l.a²+l.b²)             | l.a = 0: abs(l.b·a.y+l.c)/abs(b)             | l.b = 0: abs(l.a·a.x+l.c)/abs(a))         | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞)𝐫𝐞𝐚𝐥: abs(dist(a, cp)-c.radius)         𝐞𝐬𝐚𝐜    all seem readable to me, even if they overload "":"" quite a bit.",-0.75,c
15uwmsd,jwtku1p,"𝐩𝐫𝐨𝐜 foo(a int, b string, d point)     ...     foo(b: ""bar"", 117, (0, 0))          𝐩𝐫𝐨𝐜 dist (a, b 𝐩𝐨𝐢𝐧𝐭 | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞 | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞) 𝐫𝐞𝐚𝐥:     𝐛𝐞𝐠𝐢𝐧         𝐢𝐟 defined(b) 𝐭𝐡𝐞𝐧 𝐫𝐞𝐭𝐮𝐫𝐧 sqrt(a.x·b.x+a.y·b.y)         𝐞𝐥𝐬𝐞 defined(l) 𝐭𝐡𝐞𝐧 ...         𝐞𝐥𝐬𝐞 defined(c) 𝐭𝐡𝐞𝐧 ...         𝐟𝐢     𝐞𝐧𝐝     ...     d1 ← dist(a: p1, b: p2)     d2 ← dist(l: line(p2,p3), p1)  or      𝐩𝐫𝐨𝐜 dist (a, b 𝐩𝐨𝐢𝐧𝐭 | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞 | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞) 𝐫𝐞𝐚𝐥:     (defined(b): sqrt(a.x·b.x+a.y·b.y)     |defined(l): (l.a ≠ 0 ∨ l.b ≠ 0:                         abs(l.a·a.x+l.b·a.y+l.c)/sqrt(l.a²+l.b²)                  | l.a = 0: abs(l.b·a.y+l.c)/abs(b)                  | l.b = 0: abs(l.a·a.x+l.c)/abs(a))     |defined(c): (𝐥𝐞𝐭 r = c.radius, cp = c.center;                   𝐥𝐞𝐭 d = dist(a, cp);                   (d < r: r-d | d > r: d-r | d = r: 0)))  or as type matching:      𝐩𝐫𝐨𝐜 dist         𝐜𝐚𝐬𝐞 a, b 𝐩𝐨𝐢𝐧𝐭: sqrt(a.x·b.x+a.y·b.y)         | a 𝐩𝐨𝐢𝐧𝐭, l 𝐥𝐢𝐧𝐞:             (l.a ≠ 0 ∨ l.b ≠ 0:                 abs(l.a·a.x+l.b·a.y+l.c)/sqrt(l.a²+l.b²)             | l.a = 0: abs(l.b·a.y+l.c)/abs(b)             | l.b = 0: abs(l.a·a.x+l.c)/abs(a))         | a 𝐩𝐨𝐢𝐧𝐭, c 𝐜𝐢𝐫𝐜𝐥𝐞)𝐫𝐞𝐚𝐥: abs(dist(a, cp)-c.radius)         𝐞𝐬𝐚𝐜    all seem readable to me, even if they overload "":"" quite a bit.",-0.75,r
15uwmsd,jwtnqv4,Python semi-recently added `:=` for assignment expression.,0.0,python
15uwmsd,jwv9yus,"As far as features go, it has not been used much, which is probably a good sign.",0.3333333333333333,go
15uwmsd,jx0g70f,Like in Prolog or Ting.,0.0,prolog
15uwmsd,jwx7u86,"When talking about constants we use symbols to represent numbers whose value we don't know (so we say  `c` but replace it with the value we calculate when we do, as a number, when talking about `G` we don't know the precise value of the constant and only have a good enough approximation) or those we can't represent, only approximate (irrational numbers, *I* etc).",0.1,c
15uwmsd,jwx7u86,"In languages like LISP, PROLOG or APL which build off math directly you don't have this issue (APL uniquely because assignment is considered).",0.2375,lisp
15uwmsd,jwx7u86,"In languages like LISP, PROLOG or APL which build off math directly you don't have this issue (APL uniquely because assignment is considered).",0.2375,prolog
15uwmsd,jwx7u86,"In languages like LISP, PROLOG or APL which build off math directly you don't have this issue (APL uniquely because assignment is considered).",0.2375,apl
15uwmsd,jx8xl8u,"Languages from the 70ies managed to get this right, Rust somehow regressed on that.",0.2857142857142857,rust
15uwmsd,jwvn0ee,"The is a possibly well-known blog from a few years ago, that describes a ""mystery language"", comparing it with Go, and concluding they are nearly feature-equal, and then revealing the language to be Algol 68, which was defined in 1968 (and revised, mostly to give it a more format semantic definition, in 1974.)",0.18,go
15uwmsd,jwvn0ee,"The is a possibly well-known blog from a few years ago, that describes a ""mystery language"", comparing it with Go, and concluding they are nearly feature-equal, and then revealing the language to be Algol 68, which was defined in 1968 (and revised, mostly to give it a more format semantic definition, in 1974.)",0.18,algol
15uwmsd,jwvqfuw,"If the typical reaction to apl is any indication, modern coders are irrationally frightened by symbols that don't exist on their chromebook keyboard.",0.016666666666666677,apl
15uwmsd,jwvqfuw,"But there's also a universal ""C"" locale that you can place universal symbols for things in, like `==()`.",-0.25,c
15uwmsd,jwvqfuw,"In addition to improving accessibility, it also allows for one to program in easy or hard mode, and get carried away with using apl style squiggles if you're feeling terse and full names of formulas (I call functions formulas) if you're feeling verbose.",0.1638888888888889,apl
15uwmsd,jwxxb25,Let me go further: it runs directly counter to their own professed guiding principle.,0.2333333333333333,go
15uwmsd,jxe2c58,"This often happens to comments mentioning Rust, but that's not my loss; I remember the things I write pretty well.",0.25,rust
15uwmsd,jx1j6st,"You may recall that HTML used SGML entities for character names; again, iirc, some Danish standards people were very annoyed that the name for our letter Æ/æ was demoted to be a ""ligature"": Aelig/aelig.",-0.52,html
15uwmsd,jx1j6st,"I understand that part of Unicode's early ""mission statement"" was also to reconcile many kinds of code pages that had been in use, so fx ""℃"" exists as a codepoint (U+2103), even if the degree symbol ""°"" existed in Latin1, and we will typically write ""degrees Celsius"" as ""°C"" (two codepoints: °: U+00B0 and C: U+0043.)",0.14444444444444446,c
15uwmsd,jx1j6st,"When the Algol language was designed, it was deliberately designed so that the letters constituting keywords and letters constituting identifiers were considered different: in typeset text this was achieved with boldface or underlined keywords.",0.0,algol
15uwmsd,jx1j6st,"With Algol 68, van Wijngaarden took this to another level, with userdefined modes (types) also using bold letters.",0.3333333333333333,algol
15uwmsd,jx1j6st,"This is why we got the infamous lexer problem in C, when typedefs were added to the language!",-0.625,c
15uwmsd,jx1j6st,"At least the have added the ""⏨"" subscript, originally designed by the Algol 60 committee I believe, for scientific number notation (1.2⏨3 being 1.2·10³ or in most languages 1.2E3 or 1.2e3.)",0.19166666666666665,algol
15uwmsd,jx1j6st,"Using different styles as distinct symbols, in addition to solving the C lexer problem with types, also could solve the problem the C standards committee is having when needing to introduce new keywords at this point in C's lifecycle.",0.14545454545454545,c
15uq630,jwr13cg,"Haskell supports this (as well as embedded DSLs) through ""quasi quotes"" – blocks which are parsed with some custom parser, rather than by the main compiler.",0.16666666666666666,haskell
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,c
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,c++
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,r
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,javascript
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,java
15uq630,jwr13cg,"Libraries exist which allow C, C++, C#, R, JavaScript, Java and many other languages to be embedded into Haskell programs.",0.1875,haskell
15uq630,jwr13cg,"When done well, the downsides are few (some extra complexity in the build process), and I find it a very convenient way of testing and running C and C++ code.",0.0,c
15uq630,jwr13cg,"When done well, the downsides are few (some extra complexity in the build process), and I find it a very convenient way of testing and running C and C++ code.",0.0,c++
15uq630,jwqz0ba,Rust does this via proc macros.,0.0,rust
15uq630,jwqz0ba,"Right now I am aware of C, lisp, html, sql, latex and (for some cursed reason) gnu cobol.",0.26785714285714285,c
15uq630,jwqz0ba,"Right now I am aware of C, lisp, html, sql, latex and (for some cursed reason) gnu cobol.",0.26785714285714285,lisp
15uq630,jwqz0ba,"Right now I am aware of C, lisp, html, sql, latex and (for some cursed reason) gnu cobol.",0.26785714285714285,html
15uq630,jwqz0ba,"Right now I am aware of C, lisp, html, sql, latex and (for some cursed reason) gnu cobol.",0.26785714285714285,cobol
15uq630,jwr5ajj,"In Perl, this isn't a *language* feature, strictly speaking, but there's [a collection of modules](https://metacpan.org/pod/Inline) called `Inline` that let you embed code in other languages, well, inline.",-0.125,perl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,c
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,perl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,c++
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,assembly
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,python
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,tcl
15uq630,jwr5ajj,"The best supported is C, because Perl itself has a very mature C API, but there's also [support](https://metacpan.org/dist/Inline/view/lib/Inline/Support.pod) for C++ and assembly, and even for a few dynamic languages like Python, Tcl or Java (why anyone would want that, however, eludes me).",0.23249999999999998,java
15uq630,jwsee3q,"The usual suspects get mentioned (Haskell's quasiquoting, Racket) but also some others.",-0.25,haskell
15uq630,jwsee3q,** Since around 2000 Perl devs have been able to import foreign PL modules and/or embed foreign PL code via [`Inline`s](https://metacpan.org/search?size=500&q=inline) that embed *existing* implementations of foreign PLs into Perl programs.,0.03125,perl
15uq630,jwsee3q,"Stefan Seifert, the author of several Perl `Inline`s brought the same tech to Raku, and has since taken it to new levels.",0.04545454545454545,perl
15uq630,jwtn6ib,Common Lisp is one.,-0.3,lisp
15uq630,jwrq5h8,"Although it mostly is in the form of strings, there are many DB systems that provide a processor to allow embedding SQL into C programs (and other languages), including PostgreSQL ECPG.",0.2916666666666667,c
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,html
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,javascript
15uq630,jwrq5h8,"And although HTML is perhaps not eligible to be called a ""programming"" language, mixing it (and JavaScript) with things like PHP, JSP, ASP, etc has been common for many years.",0.1,php
15uq630,jwrq5h8,"Embedding for example a C snippet in a Pascal program is probably not very useful, for that the languages are not sufficiently dissimilar.",-0.11538461538461536,c
15uq630,jwrq5h8,"Embedding for example a C snippet in a Pascal program is probably not very useful, for that the languages are not sufficiently dissimilar.",-0.11538461538461536,pascal
15uq630,jwrq5h8,Then of course there is C embedding in C++ to some degree.,0.0,c
15uq630,jwrq5h8,Then of course there is C embedding in C++ to some degree.,0.0,c++
15uq630,jwrq5h8,And asm sections in both C and C++ programs.,0.0,c
15uq630,jwrq5h8,And asm sections in both C and C++ programs.,0.0,c++
15uq630,jwrq5h8,"Finally, applications that use extension languages like ECMAScript or Lua will probably also include some code, but again this is most likely in the form of strings.",0.16666666666666666,lua
15uq630,jwrq5h8,"Finally Perl has had support for various language extensions and embedding for decades, ranging from C (using XS) to ""Latin"".",0.0,perl
15uq630,jwrq5h8,"Finally Perl has had support for various language extensions and embedding for decades, ranging from C (using XS) to ""Latin"".",0.0,c
15uq630,jwrq5h8,"How many and to what extent they are actually used (except that C for obvious reasons is used for integrating Perl with C-based libraries), I don't know.",0.16666666666666666,c
15uq630,jwrq5h8,"How many and to what extent they are actually used (except that C for obvious reasons is used for integrating Perl with C-based libraries), I don't know.",0.16666666666666666,perl
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,c
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,perl
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,c++
15uq630,jwrq5h8,"There seems to be also a module C::Blocks on CPAN which integrates tcc with perl (so C code is compile on-the-fly, I guess), and of course Perl can also be embedded in C (and C++) programs as an extension language like Lua and ECMAScript.",0.0,lua
15uq630,jwrq5h8,"Historically, it has also been common to integrate - at the function level - with subroutines written in FORTRAN.",-0.15,fortran
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,pascal
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,fortran
15uq630,jwrq5h8,"Some Pascal compilers used a procedure declaration followed by the keyword **fortran** (or just **extern**) iirc, and I believe C also used to have a fortran keyword?",0.25,c
15uq630,jwrq5h8,"Lexer (.lex) definition files for (f)lex, and grammar (.y) files for yacc/Bison could also be considered DSLs with embedded C code.",0.0,c
15uq630,jwto0dk,"Perl is a multi-syntax language: It has regular code, POD, regex, strings, and here-documents.",0.0,perl
15uq630,jwsfkbi,Other examples React and C# linq,-0.125,c
15uq630,jxfktx1,"Other people already mentioned web front-end languages like HTML/JS/CSS, plus backend languages like PHP, ASP, etc.",-0.125,php
15uq630,jxfktx1,One thing I think is interesting about these examples is that they work sort of inside-out compared to things like regex in perl or rust macro languages.,0.5,perl
15uq630,jxfktx1,One thing I think is interesting about these examples is that they work sort of inside-out compared to things like regex in perl or rust macro languages.,0.5,rust
15uq630,jxfktx1,"For example, if you open a large HTML file and jump to the middle of the file, the syntax highlighting needs to know whether it's inside a `<script>` tag or not, which requires scanning the entire file from the start to properly answer.",0.04285714285714286,html
15uq630,jxfktx1,"HTML/PHP solve this problem by using delimiters that aren't valid code in the embedded language (`</script>` is not valid JS, and `?>` is not valid PHP).",0.0,php
15uq630,jxfktx1,Perl regex solves the problem by providing a wide range of ways to quote regexes so you can always find a delimiter that isn't used in your pattern.,-0.1,perl
15uq630,jwsjscy,Examples: C# / .NET -- _most_ of the other languages on the CLR are basically just C# with a little syntactic sugar.,0.0625,c
15uq630,jwtbvvh,Ruby on Rails does that - to the point that it becomes a nightmare to work with it - every single DSl has its own complexities and peculiarities to the point that it feels like working in different languages.,0.1761904761904762,ruby
15uq630,jwtuqu8,To some degree Rust's proc macros fit the definition.,0.4,rust
15uq630,jwvm6hv,"For example, in Rust, expressions that appear inside the vec!",0.0,rust
15uq630,jwuuenh,is it like html+js+css or c++assembler or rust+unsafe rust,0.0,rust
15uq630,jx0gj93,Homoicon languages like LISP also can manipulate code in the macro system.,0.0,lisp
15uq630,jx0gj93,FORTH can change the input stream reader.,0.0,forth
15uq630,jx0gj93,"Also, Factor--a more extensive threading, point-free language than FORTH--can switch the input reader.",0.25,forth
15uq630,jx0gj93,"At the time, I was also programming C and Fortran on the other Crays (running Unix).",-0.125,c
15uq630,jx0gj93,"At the time, I was also programming C and Fortran on the other Crays (running Unix).",-0.125,fortran
15uq630,jwtv0ex,maybe script/style tags in HTML?,0.0,html
15uq630,jwwxucn,It can go further than just a variable.,0.0,go
15uq630,jwrr2lj,And other Scheme and LISP variants are also often used as embedded extension languages - emacs probably being the best known example.,0.4375,scheme
15uq630,jwrr2lj,And other Scheme and LISP variants are also often used as embedded extension languages - emacs probably being the best known example.,0.4375,lisp
15uq630,jwrr2lj,"To what degree that actually includes code embedded directly in the C code, I do not know.",0.05,c
15uq630,jwtmzby,"There are in practice many times when you *could* go through the rigmarole of integrating SQL CRUD statements into your code, but it's tedious and formulaic.",0.0,go
15uq630,jwt7dwl,;D !<,0.3125,d
15uq630,jwuylx7,"Rust's proc macro system is pretty amazing, it allows for the embedding of other DSLs with proper syntax checking, strong typing guarantees, and escape hatches to compute runtime values through rust.",0.2316666666666667,rust
15uejj0,,"Hi, I just made this language in C++, with an interpreter and C++ transpiler, and also a web app to use it.",0.0,c++
15uejj0,jwqrszy,You should look at COBOL.,0.0,cobol
15uejj0,jwtdls5,If your goal is to be more accessible than python you probably shouldn't need to download a C++ and ES compiler before you can use the language.,0.4375,python
15uejj0,jwtdls5,If your goal is to be more accessible than python you probably shouldn't need to download a C++ and ES compiler before you can use the language.,0.4375,c++
15uejj0,jwr5o34,The organization of your code (all in header files) makes it look like you don't know how to write idiomatic C++.,0.0,c++
15uejj0,jwr5o34,I see that your C++ transpiler dumps `using namespace std` into the generated code.,0.0,c++
15uejj0,jwr9xau,"Also, the code is not meant to be compiled, just one command that builds the web assembly file, so I chose to not use make/cmake, but instead just put that single command in the readme.",-0.07142857142857142,assembly
15uae4o,,"hello,  &#x200B;  I have some experience building small compilers, nothing professional or anything but I have only written compilers in common lisp.",-0.11249999999999999,lisp
15uae4o,,&#x200B;  i want to build a compiler using c++ or java in an object oriented style so i can learn oo.,0.0,c++
15uae4o,,&#x200B;  i want to build a compiler using c++ or java in an object oriented style so i can learn oo.,0.0,java
15uae4o,jwpl5if,Have a look for Modern Compiler Implementation in Java by Andrew Appel.,0.2,java
15uae4o,jwpl5if,"E: there's a version of the book using C++ too, take your pick.",0.0,c++
15uae4o,jwos6zr,"And Microsoft's Dotnet engineers seem to agree, with the new open source Roslyn C# compiler being fully functional and immutable.",0.06818181818181818,c
15uae4o,jwolch1,"Common lisp is a far nicer language for oo than c++ and java, so I would recommend to use it instead, since you are already familiar with it.",0.05833333333333334,lisp
15uae4o,jwolch1,"Common lisp is a far nicer language for oo than c++ and java, so I would recommend to use it instead, since you are already familiar with it.",0.05833333333333334,c++
15uae4o,jwolch1,"Common lisp is a far nicer language for oo than c++ and java, so I would recommend to use it instead, since you are already familiar with it.",0.05833333333333334,java
15uae4o,jwpx2yk,I can think of some references you might appreciate:  * [Object Oriented Programming in Common Lisp](https://en.wikipedia.org/wiki/Object-Oriented_Programming_in_Common_Lisp) - I enjoyed this book; especially the example at the end about implementing a range of different kinds of IO streams.,0.05,lisp
15uae4o,jwpx2yk,I remember it being a more compelling illustration of OO than the C++ examples I was used to reading at the time.,0.4,c++
15uae4o,jwpx2yk,* [Lisp in Small Pieces](https://pages.lip6.fr/Christian.Queinnec/WWW/LiSP.html) - It has a chapter towards the end about organizing a compiler in an object oriented style.,-0.25,lisp
15uae4o,jwq2zfd,First question: How well do you know C++ or Java?,0.25,c++
15uae4o,jwq2zfd,First question: How well do you know C++ or Java?,0.25,java
15uae4o,jwolatx,"Compiler *C = new JavaCompilerClass();     ...     C->assignSource(""c:\test\helloworld.java"");     C->Compile();     ...     free C();      class JavaCompilerClass : CompilerClass     {        ...        ...     } ;          class CompilerClass     {        ...        ASTClass* AST;        SymbolTableClass* SymbolTable;        ...        LexerClass* Lexer;        ParserClass* Parser;        ...     } ;         Just my two cryptocurrency coins contribution...",0.2681818181818182,c
15uae4o,jwpoyrq,"came to suggest Appel's book, he also made variants in C and ML for comparison",0.0,c
15uae4o,jx6zrki,"Quite a long time ago - the only language the students had in common was Java, which was the reason for choosing it.",-0.11666666666666665,java
15uae4o,jwoxxd1,"You'd have a very large function that takes a user input and the current total UI state, and returns a new UI state (see the Elm language).",0.10373376623376623,elm
15uae4o,jwoxxd1,Just compare ready-to-go React widgets to what Elm offers.,0.1,elm
15uae4o,jx760u3,"While it's not about compilers as such, Crafting Interpreters by Nystrom is a very well written book that covers many of the same phases a compiler has to go through, and it's free online: https://craftinginterpreters.com/contents.html",0.22000000000000003,go
15uae4o,jx779z0,">Crafting Interpreters by Nystrom is a very well written book  Ah yes, I loved going through creating Lox with C#, it was quite fun.",0.39999999999999997,c
15uae4o,jx779z0,"Though, C# is very slow to start up.",-0.39000000000000007,c
15tzhae,, I'm trying to develop my own Minimal LISP Like.,0.25,lisp
15tzhae,jwne1cl,Ideally you’d also support tail call optimization but unfortunately many languages drop the ball on that.,0.7,d
15tzhae,jwoisr8,"If it's a LISP, recursion.",0.0,lisp
15tzhae,jwpo3kc,For reference: the D reference compiler lowers foreach and while to for loops.,0.0,d
15ty5ei,jwuv24z,"Most notably, the basic usecase of iterating over an array -- which in C is done by just incrementing a pointer -- seems like it could suffer quite a bit of overhead if the iterator was implemented as a wholly separate stack.",0.3333333333333333,c
15ty5ei,jwuv24z,"I do remember Graydon Hoare mentioning that it is possible to implement internal iteration efficiently by slicing off part of the stack to serve as the iterator's own stack -- which is efficient if a small upper bound can be determined -- then bouncing back and forth between the regular programming stack and the iterator's sub-stack with direct jumps rather than function calls... but it's not clear that a compiler could optimize that out to pointer increments, nevermind an even more complex protocol.",0.054545454545454536,forth
15tw2nd,jwnmiqz,"Better still, write the compiler in Python, and take over a supercomputer, there's work to be done!",0.625,python
15tw2nd,jwvnqn8,If you look at the source of https://bolinlang.com/multigen.py you should get a valid python script.,0.0,python
15tw2nd,jwvnqn8,I put it in /tmp and wrote `python3 multigen.py c 500000 6` (I have 6 cores).,0.0,c
15tw2nd,jwvnqn8,"Alternatively you can copy paste a bunch of SQLite files and have a process compile each of them and get an estimate that way   Funny thing is a single clang process is faster than go...  	#!/bin/bash 	#FLAGS=""-g -fsanitize=address"" 	FLAGS=""-g"" 	for i in {0..5} 	do 	    clang $FLAGS -c ""file$i.c"" & 	    declare ""proc$i=$!""",0.06919642857142858,go
15tw2nd,jwofcsu,"I was not the one who asked oil shell what his problem is and I wasn't the one upset about what someone else meant to say (I have no idea what that deleted comment said)  In fact it didn't matter to me how he interpreted my reply, I specifically wanted to know what people have tried and what their result was",0.0,shell
15tvi20,,I used to love LISP back in my college days.,0.25,lisp
15tvi20,,I am working on LISP interpreter in JS with a clean UX to run LISP commands (and see the results immediately).,0.3666666666666667,lisp
15tp88l,jwlnqwg,"Ones like gcc on my machine, for an easy-to-compile language like C, might manage 10-20K lines per second, slower if optimising.",0.0,c
15tp88l,jwlnqwg,Tiny C might do 500-1000K lines per second.,0.0,c
15tp88l,jwkyum2,"There's not much to go on here, so I'll ask: why do you even have to recompile everything?",-0.1,go
15tp88l,jwkyum2,"Take C, C++, C#: you can compile a unit of code to a dynamically linked library (.dll, .so).",0.0,c
15tp88l,jwkyum2,"Take C, C++, C#: you can compile a unit of code to a dynamically linked library (.dll, .so).",0.0,c++
15tp88l,jwkyum2,Or you could look into how Rust works.,0.0,rust
15tp88l,jwkyum2,"- rust always compiles from source, but has some smart caching going on.",0.21428571428571427,rust
15tp88l,jwojs8n,In C / C++ this is sort of simulated with *.obj and *.h files.,0.0,c
15tp88l,jwojs8n,In C / C++ this is sort of simulated with *.obj and *.h files.,0.0,c++
15tp88l,jwojs8n,In Java this is done with *.class files.,0.0,java
15tp88l,jwojs8n,"Delphi has been doing this for decades, with it's own intermediate code files.",0.6,delphi
15tp88l,jwp6yef,My language is very fast... Cos  I like making things go fast.,0.23,go
15tp88l,jwp6yef,"Profiling is going to be the first approach normally suggested, but I've never needed it cos I enjoy making things go fast.",0.25,go
15tp88l,jx8sgzf,"In another comment, it appears you are using C++'s `std::map` which is notoriously slow.",-0.30000000000000004,c++
15tp88l,jwmsqxi,"but for 1M lines, here's the compile time output:  ```         Project main v1.0.0 [executable + optimized]        Finished build target(s) in 35057ms      Generating Generating output at `.sn/bin/main`  ```  (I should change it to display seconds instead of ms, sorry)  edit: 1M lines + the stdlib (println, String, Vector, Iterator, Iter, Exception, c stdlib, core macros, the code I showed, etc...)",-0.16666666666666669,c
15tp88l,jwn88sf,"I would take a look at speeding the compiler up rather than doing any incremental compilation, which can be a nightmare & very error prone  For reference, [TCC](https://www.bellard.org/tcc/) was compiling 1 mil lines per sec of C on a 2.4ghz pentium 4, which is a single core 32-bit cpu that *doesn't* have any of the nice simd instructions  Given that any cpu you have today is *at least* 10x faster than this, you'd better be doing *at least* 350x more semantic analysis than C to make it worth it!",0.15595238095238095,c
15tkpyo,,I wrote a primitive Lisp parser in OCaml [https://github.com/BranislavLazic/yaran](https://github.com/BranislavLazic/yaran).,0.0,lisp
15t0pad,jwhbpgk,"As part of the 'interface' (called instance arguments in Agda; similar to typeclasses in Haskell) you can declare a proposition that must hold for any instances, and instances must define a machine-checkable proof of this proposition for the given type.",0.0,haskell
15t0pad,jwhm2gq,```  We need to make dependent types more accessible so more people can learn about all this cool stuff.,0.43125,cool
15t0pad,jwie757,C# has (or had) this functionality with Code Contracts.,0.0,c
15t0pad,jwos6vx,"C++ can do it: [https://godbolt.org/z/4P98obn55](https://godbolt.org/z/4P98obn55)      #include <concepts>          template<typename T>     concept IAdder = requires {         { T::add(int{}, int{}) }->std::integral;         requires (T::add(5, 9) == 14);     };          struct SimpleAdder {         static constexpr auto add(auto x, auto y) { return x + y; }     };          struct FakeAdder {         static constexpr auto add(auto x, auto y) { return 9; }     };          auto main()->int {         static_assert(IAdder<SimpleAdder>);         static_assert(!IAdder<FakeAdder>);     }",0.08333333333333333,c++
15t0pad,jwhp9zt,>We need to make dependent types more accessible so more people can learn about all this cool stuff.,0.43125,cool
15t0pad,jwhp9zt,At least when I first learned it (Idris 1) it felt like a very natural extension of Haskell.,0.026666666666666672,haskell
15t0pad,jwhsow4,"C# or Java) so it's whatever the target language compilation is, with a small overhead.",-0.25,c
15t0pad,jwhsow4,"C# or Java) so it's whatever the target language compilation is, with a small overhead.",-0.25,java
15s4uea,jwdnwoi,"It may be as simple as emmitting a SVG or a PNG, or drawing in a HTML Canvas.",0.0,html
15s4uea,jwdnwoi,"Start scribling things around, maybe you want to draw a triangle, you may write something like: `define A, B, C to be points; Draw a line from A to B, B to C and A to C`, well, english has no good structure to parse and this is very verbose, so you may try and insert some keywords, and a few rules like ""uppercase letters are always points"" to make it more concise: `def A, B, C; Line A B; Line B C; Line A C`, and from there you continue this process of trying things, defining grammar, changing grammar, until you arrive at something you're happy with.",0.15,c
15s4uea,jwfqtz0,"&#x200B;  I first went with LLVM, but i had to learn the tool, which is very time consuming, and I also had to learn C++, which again, is very time consuming.",0.21666666666666667,c++
15s4uea,jwfqtz0,"So I chose to implement it in python because it's the language i know most, and can be faster with.",0.5,python
15s4uea,jwcdl3g,"I think future languages will support things that are currently done in libraries or functions today, like we are already seeing for example with goroutines in Go.",0.0,go
15s4uea,jwcdl3g,"in C#, we can’t set any priority to control which tasks should be performed first.",0.25,c
15s4uea,jwp99c0,"If I hate painting, I could go for models that are prepainted (very few), or again, just leave them unpainted.",-0.53,go
15s4uea,jwp99c0,"Go ahead, make something weird, nobody will probably ever use it.",-0.5,go
15s4uea,jwee04r,"If the trend continues, in 50 years we'll be programming in assembly again.",0.0,assembly
15s4uea,jwhokwj,"My forte was assembly code on the 64-bit DEC Alpha RISC processor, which was the fastest CPU in the world at the time.",0.0,assembly
15s4uea,jwmoslg,"Though there is a discontinuity between the Lisp level and the lower-level implementation language, their implementations can share most of the code.",0.5,lisp
15s4uea,jwpkfsb,"This is borne of abundant experience with build systems for different platforms, where escaped escaped quotes of escapes for different kinds of languages and OS shell strings, drove me absolutely nuts!",0.2125,shell
15s4uea,jwpkfsb,"However postfix concatenative languages, like Forth, are another competing influence in my thinking.",0.0,forth
15s4uea,jwpkfsb,I need to look at how stdio is actually implemented in various C libraries.,0.0,c
15s4uea,jwpkfsb,"Riding on top of C, is not necessarily the direction I want to take.",0.25,c
15s4uea,jwrkluf,[https://piumarta.com/software/maru/](https://piumarta.com/software/maru/)   [https://github.com/attila-lendvai/maru](https://github.com/attila-lendvai/maru)  You probably would want to bootstrap a compiled Lisp.,0.0,lisp
15s4uea,jwrkluf,No C required.,0.0,c
15s4uea,jwrkluf,"It's a much more complex system, but the Yale T system (a Scheme dialect) was implemented entirely in its own language, save for a tiny assembler stub to initialize.",0.16,scheme
15s4uea,jwrkluf,"Scheme-48 runs on a VM that is implemented in PreScheme, an embedded language that is compiled into C, but you could go direct to machine code.",0.1,c
15s4uea,jwrkluf,"Scheme-48 runs on a VM that is implemented in PreScheme, an embedded language that is compiled into C, but you could go direct to machine code.",0.1,go
15s4uea,jwrkluf,"[https://mumble.net/\~jar/tproject/](https://mumble.net/~jar/tproject/)  [https://www.s48.org/](https://www.s48.org/)  From your remarks about Forth and concatenative languages, however, it may be that you are going for something substantially simpler, and a self-compiling compiled Lisp exceeds your complexity budget.",0.0,forth
15s4uea,jwrkluf,"[https://mumble.net/\~jar/tproject/](https://mumble.net/~jar/tproject/)  [https://www.s48.org/](https://www.s48.org/)  From your remarks about Forth and concatenative languages, however, it may be that you are going for something substantially simpler, and a self-compiling compiled Lisp exceeds your complexity budget.",0.0,lisp
15s4mez,jwgwvod,"On the other hand, if you want to go down the pure-functional rabbit hole, #4 looks promising.",-0.02685185185185185,go
15s4mez,jwpcuih,"In Algol 68 you *do* put a **proc** at the ""mode"" position of the definition, but the body (which would also be an anonymous function when used as an argument in an expression) is simply ( <*parameter list*\> )*<result type> : <closed\_clause> ,* where a closed clause is typically some parenthesised expression, including what other languages would call a statement block using **begin** ... **end**.",-0.09791666666666667,algol
15s4mez,jwpcuih,"Algol 68 is slightly ""inconsistent"" perhaps, in that a proc mode (or proc type) is written as for example **proc**(**int**)**int**.",-0.16666666666666666,algol
15s4mez,jwpcuih,":-)  In the somewhat weird language I am designing right now, I currently use a 𝐩𝐫𝐨𝐜 keyword next to the parameter list; but that is because I expect to use the C preprocessor (with 𝐩𝐫𝐨𝐜 being a macro) to ""compile"" the language to C, and I need to pass the parameters to a macro for manipulation.",0.05714285714285714,c
15s0ox6,,"For example, in the following Haskell code the well-formedness of expressions is ensured at compile time:      data Term a =         IntLit :: Int -> Term Int         BoolLit :: Bool -> Term Bool         Add :: Term Int -> Term Int -> Term Int         Equal :: Term x -> Term x -> Term Bool      -- Bool to bool comparison is fine.",0.1388888888888889,haskell
15s0ox6,jwewou4,"Sidenote: the very first code sample (in TypeScript) seems messed up: SerializerOf vs. TypeName, StringSerializer vs. ""string"".",0.325,typescript
15s0ox6,jwewou4,"type message =       | Add_one: int -> message       | Print_string: string -> message      type queue_element =       | Element: message -> queue_element      let rpc (q: queue_element Queue.t): unit =       match Queue.pop q with       | Element (Add_one i) ->         Printf.printf ""Added one to %d to produce %d\n"" i (i + 1)       | Element (Print_string s) ->         print_endline s      let () =       let q: queue_element Queue.t = Queue.create () in       Queue.push (Element (Add_one 3)) q;       Queue.push (Element (Print_string ""foo"")) q;       rpc q; (* Prints “Added one to 3 to produce 4”*)       rpc q  (* Prints “foo” *)  The last example is basically ""evaluating AST"" again.",0.16666666666666666,d
15s0ox6,jwf9aiy,data T :: * -> * where       T1 :: Int -> T Bool       T2 :: T a          test (T1 n) _ = n > 0     test T2     r = r  Trying to infer a type for `test` would either need to guess and pick one arbitrarily (at the risk of being wrong) or bail out and require the programmer to specify a type signature (which is what GHC does).,-0.3,r
15s0ox6,jwf82kw,String -> Term a  or written in a way that is valid Haskell today      data SomeTerm where         MkSomeTerm :: Term a -> SomeTerm          parse :: String -> SomeTerm,0.0,haskell
15s0ox6,jwlz9z2,T c → (b | a) → b`.,0.0,c
15s0ox6,jwbz60i,Term a -> r) -> r,0.0,r
15s0ox6,jwmqqo5,"Haskell might not have this problem, as it has GADTs and type-directed compilation.",0.0,haskell
15s0ox6,jwc8xyf,There is no such facilities in vanilla Haskell.,0.0,haskell
15s0ox6,jwn1cby,"As far as I understand, Haskell's GADTs are just like OCaml's in this regard.",0.1,haskell
15s0ox6,jwn1cby,What's close to mapping types is type families in Haskell.,0.0,haskell
15ryfsq,jwcmhcu,Really cool stuff!,0.4375,cool
15ryfsq,jwcohca,"The main motive would be a language that was ""kinder"" than C...  That being said if I had to make some guesses:  - labelled jumps / gotos, if statements for control flow.",0.16666666666666666,c
15rxlp0,jwb2hy1,I would argue that a transpiler is indeed often understood in that pointless manner (I once gave a talk about compiling Modelica to an ML derivative and got a remark that this wouldn't be a true compiler as I didn't target assembly.,0.04999999999999999,assembly
15rxlp0,jwbximp,"Of course, the point is moot when you're transpiling to C (or Rust?",0.0,c
15rxlp0,jwbximp,"Of course, the point is moot when you're transpiling to C (or Rust?",0.0,rust
15rxlp0,jwbki71,"I think the misunderstanding came from overloaded use of the word ""compiler"" to refer to all-in-one packages like gcc that (can) do compilation, assembly, linking, etc.",0.0,assembly
15rxlp0,jwbbt11,"Transpiler is a useless word invented\* by people who felt it dishonest to call their creation a compiler, because our collective misunderstanding of the word ""compiler"" is informally centered around the traditional notion of a batch Fortran or C compiler.",-0.26666666666666666,fortran
15rxlp0,jwbbt11,"Transpiler is a useless word invented\* by people who felt it dishonest to call their creation a compiler, because our collective misunderstanding of the word ""compiler"" is informally centered around the traditional notion of a batch Fortran or C compiler.",-0.26666666666666666,c
15rxlp0,jwbramt,I've written compilers that target JS and I've written compilers that target ARM assembly.,0.0,assembly
15rxlp0,jwbdvv7,This is especially true if both the source and the target for a transpiler are C style languages.,0.7,c
15rxlp0,jwdzulb,"I make transpilers for languages that are similar to C, so I can take advantage of the mature optimizations of C compilers that I couldn't hope to match.",0.05,c
15rxlp0,jwdlj8v,"Your average programmer (who had one compiler class, if that, years ago and then forgot everything in it as soon as it was over) says ""compiler"" to mean ""I run this program, it takes in source code and spits out something I can execute"", while they say ""transpiler"" to mean ""I run this program, it takes in source code and spits out some other source code I could inspect and mix in with other source code before having to compile again""  Which is a valuable distinction when you're trying to, say, justify using $HotNewLanguage to your team, or seeing if you can still use a certain library you need to use without having to worry about mangling and linking (or worse, figuring out some way to have 2 processes talk to each other), or seeing if you can use that language in $CertainHardware which uses a funky architecture and only has a proprietary C compiler.",-0.1484126984126984,c
15rxlp0,jwdlj8v,The JS dev who's been told to use Babel or the fresh graduate who has to use some JVM language that transpiles to Java are just working a different level and care more about the differences as they see it.,0.26666666666666666,java
15rxlp0,jwcoppz,"So if I built something and I say “I transpile to C”, then I am highlight that there is a trade off I’ve made, that might be interesting.",0.5,c
15rxlp0,jwbussy,Assembly is definitely a programming language and we would still say you are compiling C even if you emit assembly instead of an executable.,0.0,assembly
15rxlp0,jwbussy,Assembly is definitely a programming language and we would still say you are compiling C even if you emit assembly instead of an executable.,0.0,c
15rxlp0,jwch2qt,"When C was first introduced, it was considered high level.",0.20500000000000002,c
15rxlp0,jwg5uh4,"Hell, sometimes the categories change based on context — Nim is a transpiler in the sense that it targets a (relatively) high-level programming language, but it's also not a transpiler in the sense that C is just an IR that will immediately be compiled to machine code.",0.0,c
15rxlp0,jwg5uh4,"So with transpilers, we can go through a bunch of different examples and ask whether they really are transpilers (as in this article) and find that no, nothing is _really_ a transpiler.",0.13333333333333333,go
15rxlp0,jwg5uh4,"We can even use this to form distinctions — both Js_of_ocaml and Rescript attempt to convert Ocaml (or at least, Ocaml-like code) into Javascript, but one of them has human readability as a direct goal.",-0.06666666666666667,javascript
15rxlp0,jwfbemg,"btw: transpilers to C are usually called compiler, as this C is portable assembler enough.",-0.125,c
15rxlp0,jwcleep,Do you consider a distinction between Java bytecode and Java source code to be valuable?,0.0,java
15rxlp0,jwbwqwr,My machine cannot run assembly or link into it.,0.0,assembly
15rxlp0,jwbwqwr,That's a world of a difference  (And yes there are things like Forth or the Symbolics Lisp Machines that blur this line too)  I really don't care what businesses or marketing care about.,0.2,forth
15rxlp0,jwbwqwr,That's a world of a difference  (And yes there are things like Forth or the Symbolics Lisp Machines that blur this line too)  I really don't care what businesses or marketing care about.,0.2,lisp
15rxlp0,jwcrj2d,"for Android, Java to JVM bytecode to DEX to machine code) and also some interpreting going on for JS in the browser, but the vast majority of activity on your device was machine instructions from actually-compiled code.",0.0,java
15rxlp0,jwbvc8i,_(Compare any ISA to Java bytecode from the JVM spec if you don't have experience in this area.,0.0,java
15rxlp0,jwbvc8i,)_ Targeting an intermediate representation or assembly is much closer to targeting source code.,0.2,assembly
15rxlp0,jwbrvi5,"Like if the target is C, then you get the full optimization facilities of an industrial strength C compiler, whereas if the target is asm you get (basically) nothing.",0.35,c
15rxlp0,jwd7f0r,I think a compiler that compiles to C would be considered a transpiler by most people.,0.5,c
15rxlp0,jwcmmqk,"Yes, of course, but that doesn't make Java bytecode machine code.",0.0,java
15rxlp0,jwceq7f,"So `cc1`, the program `gcc` uses to compile C is not a compiler?",0.0,c
15rxlp0,jwceq7f,"Oh, and `gas`, the program `gcc` uses to convert the assembly outputted by `cc1` into elf files also is a transpiler by your definition.",0.0,assembly
15rxlp0,jweufm5,> Symbolics Lisp Machines that blur this line too  They still have assembly.,0.0,lisp
15rxlp0,jweufm5,> Symbolics Lisp Machines that blur this line too  They still have assembly.,0.0,assembly
15rxlp0,jws8ld7,I'm not sure why this got downvoted... Do people not know the distinction between assembly (text source code for an assembler) and machine code (binary instructions that a CPU can interpret)?,-0.25,assembly
15rxlp0,jwcswrf,"Like x86-64 can be one final target, but C broadens that to dozens of architectures (ignoring portability concerns).",0.0,c
15rxlp0,jwehn98,Languages like C and Rust are both high and low level languages depending on context.,0.08,c
15rxlp0,jwehn98,Languages like C and Rust are both high and low level languages depending on context.,0.08,rust
15rxlp0,jwehn98,It also presents the question of what happens if I generate C then run gcc under the hood.,0.0,c
15rxlp0,jwehn98,Is C just another IR at that point?,0.0,c
15rxlp0,jwgarff,"/u/reini_urban was [just arguing](https://www.reddit.com/r/ProgrammingLanguages/comments/15rxlp0/comment/jwfbemg/?utm_source=share&utm_medium=web2x&context=3):  > btw: transpilers to C are usually called compiler, as this C is portable assembler enough.",0.08333333333333333,c
15rxlp0,jweitbq,"People still write loads of assembly too, especially for small 8-bit MCUs where a compiler simply is too much overhead ;)  But I see your point, in the compiling to C case, I'd argue the whole thing boxed together thing with gcc is a compiler.",0.06666666666666667,assembly
15rxlp0,jweitbq,"People still write loads of assembly too, especially for small 8-bit MCUs where a compiler simply is too much overhead ;)  But I see your point, in the compiling to C case, I'd argue the whole thing boxed together thing with gcc is a compiler.",0.06666666666666667,c
15rxlp0,jwoelia,> C and Rust are both high and low level languages depending on context  Your classification mentality makes this sound so complicated but it's really just relative.,0.04333333333333334,c
15rxlp0,jwoelia,> C and Rust are both high and low level languages depending on context  Your classification mentality makes this sound so complicated but it's really just relative.,0.04333333333333334,rust
15rxlp0,jwoelia,In the early home computing world C was considered a middle-ground of abstraction between writing in an assembly language and writing in something like BASIC.,0.05,c
15rxlp0,jwoelia,In the early home computing world C was considered a middle-ground of abstraction between writing in an assembly language and writing in something like BASIC.,0.05,assembly
15rxlp0,jwfm5on,"gcc assembly output without named stack variables and with globally numbered labels is hardly human readable, but I guess everything is relative, you can read hex machine code to if you are determined enough :)",0.1,assembly
15rxlp0,jwgc4k5,"Apparently you didn't get the message the first time, so you can come back in 7 days when you've had time to cool off.",0.16249999999999998,cool
15rxlp0,jwfqyg4,"Again, pointing to CoffeeScript as an example (or TypeScript, for that matter).",0.0,typescript
15rxlp0,jwfqyg4,Examples of the first definition would be CoffeeScript and TypeScript.,0.25,typescript
15rxlp0,jwfq0oy,"The kids these days, so soft and sheltered, I cannot possibly imagine why would someone not be able to understand the machine generated assembly for a 100k line C program.",0.19999999999999998,assembly
15rxlp0,jwfq0oy,"The kids these days, so soft and sheltered, I cannot possibly imagine why would someone not be able to understand the machine generated assembly for a 100k line C program.",0.19999999999999998,c
15rxlp0,jwfq0oy,"I guess it wouldn't be ""technically incorrect"" to call gcc a transpiler to assembly, but idk, ultimately it doesn't matter.",0.0,assembly
15rsd77,,"(Elixir, F# will treat middle part as  `(upper() + """"B)(""a"")`).",0.0,elixir
15rsd77,jwagx4q,"Shell scripting seems to be the obvious example, though I'm not quite getting how your example works.",0.0,shell
15rsd77,jwb6kob,This C++ proposals explores a bunch of possibilities: https://wg21.link/p2672r0,0.0,c++
15rsd77,jwbxxp7,"> `|` op has a lower precedence   > Elixir, F# will treat middle part as `(upper() + """"B)(""a"")`  That it has lower precedence than `+` is why it's parsed this way.",0.0,elixir
15rsd77,jwbgg8a,"This could be interpreted as   *""a"" | upper() | +(""B"") | lower()*  Like in lisp, + is just  a name.",0.0,lisp
15rsd77,jwc3sae,"`(+ ""B"")` like Haskell or `(_ + ""B"")`, `(\x -> x + ""B"")`, `&(&1 + ""B"")` in some other languages.",-0.125,haskell
15r4qj3,jw9wgj5,"One of the first RPython languages, a Prolog, was already implemented as an AST interpreter.",0.25,prolog
15r4qj3,jwd85ez,"https://medium.com/@maiavictor/the-abstract-calculus-fe8c46bcf39c  They sure are equivalent, but the problem is that I can't really produce an efficient implementation with assembly.",0.35,assembly
15r1cgs,,"*TLDR: What do you like and dislike about sh/bash/zsh, and are there any interesting ideas or features you'd like to have in a shell language?",0.5,shell
15r1cgs,,*  **Motivation**  I am creating a new shell scripting language that does **not** conform to the POSIX standard.,0.06818181818181818,shell
15r1cgs,,As of now I don't have a clear direction for where I want it to go.,0.10000000000000002,go
15r1cgs,,What I know is this: the POSIX shell is quite nice!,0.75,shell
15r1cgs,,"I think this is partly due to some jankyness in the POSIX standard, and partly due to the fact the POSIX shell is not a general purpose scripting language.",-0.06875,shell
15r1cgs,,I often find myself grabbing for awk or python for arithmetic and more general purpose scripting that I wish I could just do directly in the shell.,0.21666666666666667,python
15r1cgs,,I often find myself grabbing for awk or python for arithmetic and more general purpose scripting that I wish I could just do directly in the shell.,0.21666666666666667,shell
15r1cgs,,I am not trying to replace awk or python.,0.0,python
15r1cgs,,I am trying to create a language that has all the ergonomic and flexible shell idioms we love while also being able to do more general purpose scripting.,0.3875,shell
15r1cgs,,A shell language with broader capabilities.,0.0,shell
15r1cgs,,"""`  *Looping, if-else and python inspired first class list*  `var names = [""Alice"", ""Bob"", ""Callum""]`  `loop name in $names {`  `if $name == ""Callum"" {`  `echo ""Hello, enemy""`  `} else {`  `echo ""Hello, friend""`  `}`  `}`  &#x200B;  &#x200B;  &#x200B;",0.25,python
15r1cgs,,"""`  *Looping, if-else and python inspired first class list*  `var names = [""Alice"", ""Bob"", ""Callum""]`  `loop name in $names {`  `if $name == ""Callum"" {`  `echo ""Hello, enemy""`  `} else {`  `echo ""Hello, friend""`  `}`  `}`  &#x200B;  &#x200B;  &#x200B;",0.25,alice
15r1cgs,jw6pzzg,"I have *thoroughly* learned all the junk in Bash, but it’s always a wearying distraction from whatever my main task is.",0.16666666666666666,bash
15r1cgs,jw7z89v,Do away with the idea that command-line utilities must emit a stream of text: Make them emit structured data which the shell interprets into structured variables.,0.0,shell
15r1cgs,jwareyj,I think the most important thing for a shell scripting language is to understand what problem it's meant to solve and what the most common actions are.,0.27499999999999997,shell
15r1cgs,jwareyj,"In my view, a shell scripting language is a language that is focused on three primary things:  - Running other programs (including passing command-line arguments).",0.1375,shell
15r1cgs,jwareyj,"It's a strength, not a weakness, that you can easily use tools like `awk` to do things that are difficult in pure shell script.",0.049206349206349205,shell
15r1cgs,jwareyj,"Bash and zsh and sh are sort of like giraffes: they're evolutionarily optimized for this one weird set of tasks, which makes them look very different from every other language and makes them kinda bad at things outside their target domain.",-0.26499999999999996,bash
15r1cgs,jwareyj,"However, many of the posix shell alternatives I've seen tend to try to be more consistent, general langauges, with the result that they're worse at the things that posix shells are really good at.",0.26666666666666666,shell
15r1cgs,jwareyj,"The idiomatic shell way of doing this is `foo ""$args""` vs `foo $args`.",0.0,shell
15r1cgs,jwareyj,"- Pattern matching: the standard way of doing pattern matching on variables is to either do `if echo ""$var"" | grep -q ""pattern""; ...` or `if expr ""$var"" : ""regex"" >/dev/null; ...` These are both really awkward, verbose, and high overhead for something that could be as simple as perl's `if $var =~ /pat/ ...`.",-0.10999999999999999,perl
15r1cgs,jwareyj,It would be handy if there were string literals that could use arbitrary delimiters like `/../` or `|..|` or `[==[..]==]` to make it easy to do stuff like pass shell commands as arguments without getting [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome)  - Shell functions should _really_ have locally scoped variables.,0.2722222222222222,shell
15r1cgs,jwbhpx5,"Bash needs a return statement to be easy to return with values from functions, also json as a built in type with support.",0.43333333333333335,bash
15r1cgs,jxt89jt,More structured or user-definable data types for shell variables would also be useful.,0.4,shell
15r1cgs,jxt89jt,"If you want to try something a bit different there have been previous attempts at a  ""visual shell"" with embedded graphing/split screen operations etc but operating in  a CLI environment.",-0.05555555555555555,shell
15r1cgs,jw6tw0s,Everything in the shell is text.,0.0,shell
15r1cgs,jwajbql,> Do away with the idea that command-line utilities must emit a stream of text: Make them emit structured data which the shell interprets into structured variables.,0.0,shell
15r1cgs,jw9dvxp,But I am not sure how this would play out in the shell.,-0.25,shell
15r1cgs,jwakbvm,This makes it substantially more annoying to use common shell commands.,-0.20000000000000004,shell
15r1cgs,jwakbvm,Shell scripts are not the same domain as Rust.,0.0,shell
15r1cgs,jwakbvm,Shell scripts are not the same domain as Rust.,0.0,rust
15r1cgs,jw8zwye,":-)  Ha, well  it's a fun design exercise, with some immediate gratification, so I say go for it   Though like all languages, it quickly becomes apparent how much work it is!",0.2866666666666667,go
15r1cgs,jw8zwye,"Then you might want to join forces with us to help finish Oils :)  Definitely check out the other projects on  https://github.com/oilshell/oil/wiki/Alternative-Shells  Including the YSH design - https://www.oilshell.org/release/latest/doc/ysh-tour.html  (I need to replace all the ""Oil"" with YSH, [I renamed the project](https://www.oilshell.org/blog/2023/03/rename.html) earlier this year )  It is quite interesting how many of the alternative shell designs have converged on something Python-ish or JavaScript-ish.",0.22916666666666666,shell
15r1cgs,jw8zwye,Everybody agrees that  this is where shell should go.,0.0,shell
15r1cgs,jw8zwye,Everybody agrees that  this is where shell should go.,0.0,go
15r1cgs,jw8zwye,"As many people here know, Oils is the ONLY project that's doing as a compatible upgrade of POSIX shell / bash, so that makes it extra extra lots of work .... :)",0.2,shell
15r1cgs,jw8zwye,"As many people here know, Oils is the ONLY project that's doing as a compatible upgrade of POSIX shell / bash, so that makes it extra extra lots of work .... :)",0.2,bash
15qxqf9,jw67ipx,so anyway the cool part are the subscripts and primes.,0.35,cool
15qxqf9,jw7ue4v,"But I'll have a go, starting with examples from *standard* Raku, and closing with language mods (Raku is a modifiable PL).",0.0,go
15qxqf9,jw7ue4v,So folk who like Python's lax attitude toward identifiers can just write stuff like `foo = 42`.,0.0,python
15qxqf9,jw716v0,[APL](https://en.wikipedia.org/wiki/APL_(programming_language)) enters the chat,0.0,apl
15qxqf9,jw68iei,"It's required for interoperability with weird C libraries, but also great for implementing languages since you are not restricted to only Zig allowed values.",0.10000000000000002,c
15qxqf9,jw62wgv,Identifiers in Julia can end with '!'.,0.0,julia
15qxqf9,jw62wgv,I think it's cool because it is a way of reminding the programmer that a value contained in such variables are mutable and treat them with caution or in the case of functions to denote them as impure / as having side-effects.,0.175,cool
15qxqf9,jw8d1x0,End a case-construction with `esac` because ALGOL.,0.0,algol
15qxqf9,jwe91tn,&#x200B;  This maybe look rather conventional at first glance ... but then consider that this is plain C code compiled with the ordinary gcc compiler!,-0.10491071428571427,c
15qxqf9,jwtdgww,I stole the nullary operator from c# `??`.,0.0,c
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,pascal
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,c
15qxqf9,jw6grji,"Some of them are as operators like ""and"", ""or"" in SQL or Pascal or ""new"" and ""sizeof"" in C / C++.",0.13636363636363635,c++
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,c
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,c++
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,javascript
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,pascal
15qxqf9,jw6grji,"Some of them are reserved identifiers or predefined identifiers like the ""main"" in C / C++ / Java/ C#, or ""this"" in JavaScript or C++, or ""create"" and ""destroy"" in Object Pascal and Delphi.",-0.016666666666666677,delphi
15qxqf9,jw70ex9,"Scanner in Kotlin:      const val ctquote: String   = ""'""     const val ctquote2: String  = """" + 34.toChar()     const val ctivar: String    = ""#""     const val ctdef: String     = ""==""     const val ctddot: String    = ""..""     const val ctcomment: String = ""//""     const val ctcomp: String    = ""°""     const val ctcombine: String = ""Combine""     const val cterror: String   = ""Error""     const val ctact: String     = ""Act""     const val cttrue: String    = ""true"" // ?",0.35,kotlin
15qxqf9,jw7n5qm,Yeah after I read all that I'ma go with two ASCII letters normalized to upper case.,0.0,go
15qxqf9,jw60eso,"This is also allowed in a lot of the ML family, including Haskell and OCaml",0.0,haskell
15qxqf9,jw8por4,So ... really doubling down on Perl then?,0.022222222222222213,perl
15qxqf9,jw8vk32,; # 120  The above shows one simple way to specify strings as tokens that are matched using the Longest Token Matching scheme I summarized in my comment above.,0.0,scheme
15qxqf9,jwfbbf8,"Hm, this is in many ways as beautiful as I would expect from something descended from Perl, and also as godawful ugly as something descended from Perl.",0.2166666666666667,perl
15qxqf9,jw90l6p,"APL, as I recall, has lots of strange characters, but tokenizing them is easy - just treat each oddball character as a token.",0.19166666666666668,apl
15qxqf9,jw9sxfe,Similar to C#,0.0,c
15qxqf9,jw62gwv,This is cool.,0.35,cool
15qxqf9,jw8calp,Ruby too.,0.0,ruby
15qxqf9,jw63gz7,This is cool and the most interesting answer so far.,0.36250000000000004,cool
15qxqf9,jw73zvf,"Some C examples:  * `for` is a reserved word, but if the next character is `m`, now you've go the identifier `form`.",0.0,c
15qxqf9,jw73zvf,"Some C examples:  * `for` is a reserved word, but if the next character is `m`, now you've go the identifier `form`.",0.0,go
15qxqf9,jw73zvf,I suspect the *actual* answer is that early Fortran's had this restriction to work around [Fortran's other absolutely crazy rules around whitespace and keyword lexing](https://stackoverflow.com/a/5793730/9457).,-0.15625,fortran
15qxqf9,jwfl498,I go with `/[_[:alpha:]][_[:alnum:]]+/` because it makes writing tokenizers easier.,0.0,go
15qxqf9,jw67439,Ruby too,0.0,ruby
15qxqf9,jw5xz3h,Elixir  I also like the !,0.0,elixir
15qxqf9,jw8m019,Julia can use `!` so I think maybe `?` too.,0.0,julia
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,ruby
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,scheme
15qxqf9,jw99whs,"Ruby, Scheme and Clojure, that I know of.",0.0,clojure
15qxqf9,jw99whs,"The problem is it clashes with the nullability/safe navigation/null coalescing syntax in C# and TypeScript, which is also neat.",0.0,c
15qxqf9,jw99whs,"The problem is it clashes with the nullability/safe navigation/null coalescing syntax in C# and TypeScript, which is also neat.",0.0,typescript
15qxqf9,jw946ad,"To bring this into sharp focus, compare and contrast Raku with both Perl and another old PL that *did* double down on what it thought was a good design that turns out not to be:  * **Unicode** Basic string functions in Python 3 *corrupt* Unicode strings.",0.002777777777777768,perl
15qxqf9,jw946ad,"To bring this into sharp focus, compare and contrast Raku with both Perl and another old PL that *did* double down on what it thought was a good design that turns out not to be:  * **Unicode** Basic string functions in Python 3 *corrupt* Unicode strings.",0.002777777777777768,python
15qxqf9,jw946ad,"India is one of the largest nations on earth yet the Python code `'झंडा 🇮🇳'[::-1]`, which reverses a string containing the Hindi word for ""flag"" alongside India's flag, turns their flag into Nicaragua's, and the Indian characters into gibberish!",0.0,python
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,go
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,perl
15qxqf9,jw946ad,"Raku's take on Unicode was carefully designed from the get go with the result it is decades ahead of most other PLs, including both Perl and Python.",0.09166666666666667,python
15qxqf9,jw946ad,* **Backward compatibility** Python 3 can't use Python 2 modules.,0.0,python
15qxqf9,jw946ad,And Python 3 modules.,0.0,python
15qxqf9,jw946ad,"Plus Perl modules, including XS ones.",0.0,perl
15qxqf9,jw946ad,"* **Concurrency** Python 3 has finally gotten an accepted PEP to remove its GIL, with a hoped for time frame of about 5 years if it isn't backed out, a first tentative step in the long road to sensible concurrency solutions.",0.06666666666666667,python
15qxqf9,jw946ad,"Perl's status is similarly behind the times, but also with plans to catch up.",-0.4,perl
15qxqf9,jw946ad,"You *may* have been talking about Raku's parsing approach, syntax, and extensibility ""doubling down"" on Perl.",-0.15555555555555559,perl
15qxqf9,jw946ad,Perl's parsing approach was LALR.,0.0,perl
15qxqf9,jw946ad,Perl's syntax was a mishmash.,0.0,perl
15qxqf9,jw946ad,Perl's extensibility was ad hoc.,0.0,perl
15qxqf9,jw9fxz0,"Scheme, Racket and Common Lisp here treat `x'` as that the quote begins shorthand for `quote` of another form.",-0.3,scheme
15qxqf9,jw9fxz0,"Scheme, Racket and Common Lisp here treat `x'` as that the quote begins shorthand for `quote` of another form.",-0.3,lisp
15qxqf9,jw99xy2,Perl is doubling down on being terse and powerful and completely unreadable.,0.08148148148148147,perl
15qxqf9,jw99xy2,"My own language reads a lot like pseudocode, or Python, and my variable and function names are verbose, because that's what suits me.",0.6,python
15qxqf9,jw99xy2,"For me, that example of Raku is like an example of APL or indeed any time I have to do a regex.",0.0,apl
15qxqf9,jzbik6j,b : c; ```  We differentiate by requiring white space before the `?` in the ternary expression.,-0.375,c
15qxqf9,jwhtvgv,It works fine in Clojure.,0.4166666666666667,clojure
15qxqf9,jwcpesw,"> What I mean is for example         déjà-vu»⚛++    > Perl is doubling down on being terse and powerful and completely unreadable  Perl might, but Raku isn't.",-0.01701388888888889,perl
15qxqf9,jwcpesw,"(In particular, it has nothing to do with the semantics, with mutable variables, and so forth.",0.16666666666666666,forth
15qxqf9,jx4da1x,But it's probably the max number of symbols I'll allow in my code to go without a whitespace or ASCII character lol),0.8,go
15qcea4,jw4vwsc,as done in TypeScript).,0.0,typescript
15qcea4,jw4uapv,I'm just wondering why people use this notation and not predicate logic or prolog code or something.,0.0,prolog
15qcea4,jw4vr03,And it makes sense for logic to have other symbols that don’t require computability - otherwise we’d never be able to talk about things like infinity.,0.1875,d
15qcea4,jw53wec,"I like predicate logic notation, and all I do when reading type logic is translate it to predicate logic as I go.",0.0,go
15qblhm,jw367vc,"Zig is the most promising alternative-to-C I've ever seen, as they stick to C's philosophy, fix a lot of traps and solve one of it's biggest issue: tooling.",0.35,c
15qblhm,jw367vc,I hope Andrew's work will go big!,0.0,go
15q5877,jw23e09,Ruby can be used to do all of that too.,0.0,ruby
15q5877,jw4hti8,Except nutshell is really a shell.,0.2,shell
15q5877,jw2b8wq,"Json is cool, but wait, yaml toml as well?",0.35,cool
15q5877,jw507q7,So cool!,0.4375,cool
15q2zbv,,"For instance, `if(a[4] == 0) { ... }`, where `a` is a byte array, becomes:      b = a + 4     c = *b     d = c == 0     if(d) {         ...     }  Since the above is possible with just `cmp [eax + 4], 0` I now have three redundant virtual registers which are to be caught by the register allocator, and which are going to interfere with many other registers.",0.15416666666666667,c
15q2zbv,,"For instance, `if(a[4] == 0) { ... }`, where `a` is a byte array, becomes:      b = a + 4     c = *b     d = c == 0     if(d) {         ...     }  Since the above is possible with just `cmp [eax + 4], 0` I now have three redundant virtual registers which are to be caught by the register allocator, and which are going to interfere with many other registers.",0.15416666666666667,d
15q2zbv,,"Introduce a prepass that would mark some virtual registers (`b`, `c`, `d` in the example) as *colorless*, so as to have them be ignored by the register allocator  Considering most literature says to perform register allocation *after* instruction selection, most might say the first solution is more natural.",0.37,c
15q2zbv,,"Introduce a prepass that would mark some virtual registers (`b`, `c`, `d` in the example) as *colorless*, so as to have them be ignored by the register allocator  Considering most literature says to perform register allocation *after* instruction selection, most might say the first solution is more natural.",0.37,d
15q2zbv,jw28djl,"Sorting this back into an expression tree you should be able to tile `d = *(a+4) == 0` to get your CMP [],0 instruction  M ✌️",0.25,d
15q2ljm,jw0mdp0,While it is about Lisp I think the thoughts expressed concern any language.,0.0,lisp
15q2ljm,jw0mdp0,"I found it quite inspiring in general, not just particularly about Lisp.",0.2388888888888889,lisp
15pj2tx,jvz68c4,"``` a: {   b: @  // At points the relative closest key   c: @@ // At, At points to the second relative closest key } ```  So from what I understand, @ basically converts the indetifier name to a string key?",-0.10714285714285714,c
15pj2tx,jvz68c4,"For example both ""a"" and ""c"" are the closest key to ""b"" but in your example there is some logic for choosing ""a"".",0.0,c
15pj2tx,jvz68c4,"From this perspective the @@ on ""c"" does make sense   ``` c: {   d: 1   e: ^.d  // Up points to the relative closest scope   f: ^^.a // Up, Up points to the second relative closest scope } ```  If ""\^.d"" produces 1 and ""\^\^.a"" produces the struct/table ""a"" which was defined earlier then what's the difference in just writing ``` c: {   d: 1   e: d   f: a } ```  The \^ operator doesn't make much sense to me  ``` x: [10, 20, @, 40, @@] // At points to the current index y: [10, 20, ^.0]       // Up points to the relative closest scope z: [10, 20, ^.",-0.29583333333333334,c
15pj2tx,jvz68c4,"From this perspective the @@ on ""c"" does make sense   ``` c: {   d: 1   e: ^.d  // Up points to the relative closest scope   f: ^^.a // Up, Up points to the second relative closest scope } ```  If ""\^.d"" produces 1 and ""\^\^.a"" produces the struct/table ""a"" which was defined earlier then what's the difference in just writing ``` c: {   d: 1   e: d   f: a } ```  The \^ operator doesn't make much sense to me  ``` x: [10, 20, @, 40, @@] // At points to the current index y: [10, 20, ^.0]       // Up points to the relative closest scope z: [10, 20, ^.",-0.29583333333333334,d
15pj2tx,jw3kknr,"I cannot (currently) go up in the structure, although I can represent the relative selector as a ""value"" and pass it as a parameter.",0.0,go
15pfiig,jvz1x38,Do C people even know anything about successful language design?,0.75,c
15pfiig,jvz1x38,"C was successful, but that's mostly because of Unix, not on its own merits.",0.6166666666666667,c
15pfiig,jwqqiic,"Even so, he is not flawless, and as I mentioned in a recent comment somewhere, I believe his paper/article *Why Pascal is not my favorit programming language* unfairly hurt Pascal and also Pascal-derived languages quite a lot, this being one of several factors that helped C in out-competing Pascal and conquering the world around the end of the 1980es.",-0.25,pascal
15pfiig,jwqqiic,"Even so, he is not flawless, and as I mentioned in a recent comment somewhere, I believe his paper/article *Why Pascal is not my favorit programming language* unfairly hurt Pascal and also Pascal-derived languages quite a lot, this being one of several factors that helped C in out-competing Pascal and conquering the world around the end of the 1980es.",-0.25,c
15pfiig,jwqqiic,"(Other things being for example Ron Cain's Small-C, GNU and GCC, and the close bonds between C and Unix, including the BSD distributions.",-0.125,c
15pfiig,jwqqiic,([https://en.wikipedia.org/wiki/Ratfor](https://en.wikipedia.org/wiki/Ratfor) \- Ratfor was a C-like FORTRAN variant implemented as a preprocessor/transpiler.,0.0,fortran
15pfiig,jwqqiic,"Ratfor was used in BWK's book *Software Tools*, and the Pascal article was written after rewriting the book for Pascal: *Software Tools In Pascal*.)",0.0,pascal
15pfiig,jvz5uht,Isn’t the success of Unix partly because of C as well?,0.3,c
15pfiig,jw0tzwj,I think you have to judge the design of C within the context in which it came into being and was originally used.,0.375,c
15pfiig,jw0tzwj,"Many languages designed to solve many of the same problems were invented before and after C, and yet C won the day.",0.3333333333333333,c
15pfiig,jw0tzwj,"It's true that the history of C and Unix are intimately intertwined, but I don't think the success of C is explained completely by the fact that it was used in Unix (and vice versa).",0.23750000000000002,c
15pfiig,jw0y3qo,I'm sure C was successful for it's own merits.,0.6166666666666667,c
15pfiig,jw0y3qo,Back then everything was in assembly and it wasn't hard to mix assembly with C and you can easily imagine what assembly your compiler would produce with the C code,0.04722222222222222,assembly
15pfiig,jw0y3qo,Back then everything was in assembly and it wasn't hard to mix assembly with C and you can easily imagine what assembly your compiler would produce with the C code,0.04722222222222222,c
15pfiig,jw1mwb3,"/s  ""C people"" most likely know more about computer science than most who would resort to calling them ""C people.""",0.375,c
15pfiig,jvzuk7t,"Sure, and although I like C, my opinion is that unix's success due to C was more because of timing.",0.29375,c
15pfiig,jw0eu97,"The shortcomings of C are obvious to most, you don't need to be an expert.",0.25,c
15pfiig,jw0eu97,"C emerged around 1972, I started developing my own systems language around 1982, and right now the latest version is still going strong.",0.45476190476190476,c
15pfiig,jw0eu97,"I can spend all day telling you all the things that C did badly, sometimes laughably so.",-0.5999999999999999,c
15pfiig,jw0eu97,"But of course, my own private language is not used by anybody, while C runs half the world.",0.14444444444444446,c
15pfiig,jw0eu97,So you can certainlly call C 'successful'.,0.75,c
15pfiig,jvzumz9,"Yes, but it was also way more portable to other hardware platforms because of C so had more opportunity to grow.",0.2916666666666667,c
15ouf0b,,"I am a full time Typescript developer and some senior at my workplace wrote some predicate functions for everyone to use, such as:  `isEmpty(string): boolean`  `isNullish(any): boolean`   The problem with then is that they don't read like English because the predicate is before the subject.",0.04583333333333333,typescript
15ouf0b,,Dart:  `if (string is!,0.0,dart
15ouf0b,,"empty) return null`  Kotlin:  `if (string !is empty) return null`  Perhaps we can also support negation before the predicate function like so:  `if (string is !empty) return null`   And if the predicate takes additional arguments, the subject must be the first argument, and the syntax would work like so:  `function longerThan(string, length): boolean { ... }`  `if (string is longerThan(5)) return null`   I think it's not a complicated syntax sugar to implement in a language but it helpes readability.",-0.002777777777777768,kotlin
15ouf0b,,"I am not really writing a programming language, it's just a cool idea that I want to share with my fellow language nerds :P  What do you guys think?",0.3333333333333333,cool
15ouf0b,jvu038d,But fair warning: The logical conclusion of that pursuit is COBOL.,0.475,cobol
15ouf0b,jvu038d,"And oh yes, the bank is still running COBOL on mainframes after oh these many moons.",0.5,cobol
15ouf0b,jvveqay,"For example, the Java `instanceof` syntax (very similar to the above) is horrid, and requires all sorts of extra parenthesis for no good reason.",-0.0875,java
15ouf0b,jvu96xn,I like the Scheme convention of using a ?,0.0,scheme
15ouf0b,jvx1tzm,"In my toy language I'm taking this concept to the very extreme  In this language, predicates have a subject, and 0 ,1 or more arguments (multiple arguments are actually passed as a tuple, but I digress)      if a is even then ...      if b is factor_of 3 then ...     if c is between (2 5) then ...  multiple subjects can be chained with `and` or `or`      if a or b or c is even then ....      # if(is_even(b) || is_even(a) || is_even(c)){...}      if a and b and c are odd then ...     # if(is_odd(a) && is_odd(b) && is_odd(c)){...}      #note: mixing `and` and `or` in the sequence is not allowed, as it makes things way too confusing imo   You can also chain multiple predicates      if a is odd or is > 4 then ...     # if(is_odd(a) || a > 4){...}  And you can also chain multiple arguments on a single predicate      if a is between (1 3) or (x 7) then ...     #if(1<a<3 || x<a<7){...}  And you can also use these all together!",-0.04598214285714285,c
15ouf0b,jvu9u1o,"If you look at Rust syntax where the outer parenthesis is optional, it will look more readable.",0.5,rust
15ouf0b,jvulb0x,"To go one step further, you could allow using a predicate as a refinement type (i.e.",0.0,go
15ouf0b,jvtxb7f,I was just thinking about Dart and Kotlin cuz I am a mobile dev haha.,0.2,dart
15ouf0b,jvtxb7f,I was just thinking about Dart and Kotlin cuz I am a mobile dev haha.,0.2,kotlin
15ouf0b,jvuj5op,"Ruby too `""string"".empty?`.",0.0,ruby
15ouf0b,jvv3x7q,"I'm aware of Perl and Ruby, and in both you can have an `else` block if you want, although it is discouraged by some as being difficult to read.",-0.125,perl
15ouf0b,jvv3x7q,"I'm aware of Perl and Ruby, and in both you can have an `else` block if you want, although it is discouraged by some as being difficult to read.",-0.125,ruby
15ouf0b,jvwbb5u,"Well, back when I began reading about programming, COBOL was still a very common thing - ""ordinary"" programmers would typically use it in banks, businesses big enough to have an EDP-department (no IT back then!",-0.11523809523809524,cobol
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,cobol
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,fortran
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,apl
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,pascal
15ouf0b,jvwbb5u,"The local public library had very few books on computers in the very early 80es, and fewer about programming and programming languages (so few in fact, that I think I could easily list them all: there was a COBOL book, a FORTRAN book, surprisingly enough also an Algol-W book, an APL book written by a Danish author in 1980, and by 1984 they had maybe a couple of Pascal books, and an Ada book around 1985.)",0.014761904761904763,ada
15ouf0b,jvwbb5u,"In a way it reminds me most of C enums used as bit masks combined with for example integers, to represent flags or states of an object.",0.5,c
15ouf0b,jvwbb5u,"What I like about the COBOL level 88 ""condition names"", is that even though you use something like an enum, you don't need to make an explicit comparison.",0.0,cobol
15ouf0b,jvxm8nu,"And I think you've pretty much affirmed that ""special syntax for predicates"" is a COBOL idea.",0.26904761904761904,cobol
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,cobol
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,python
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,php
15ouf0b,jvxm8nu,"TBH my exposure to COBOL amounts to my employer has these annual mandatory multiple-guess festivals they call ""secure coding warrior"" wherein if you pick Python they assume you use Jango Fett all day long, and if you pick PHP they test you in Go instead.",0.17500000000000002,go
15ouf0b,jvxm8nu,At least with COBOL it's not unfamiliar web frameworks and magical metaprogramming.,0.1,cobol
15oi4b4,jvs087k,"in haskell, you can use `→` instead of `->` or `∷` instead of `::` afaik).",0.0,haskell
15oi4b4,jvuae69,"(Other uses exist of course, but you’d probably want some sort of counterpart ∙ [bullet operator, which looks exactly like dot op ⋅, middle dot ·, and hyphenation point ‧ in many fonts and to græybeards, and like bullet • in most others—Unicode can be *bad* for things like this] or ∗⋆⋄, and there’s ⊶⊷ for relational predicates.)",0.07083333333333336,d
15oi4b4,jvuae69,"real\_taylodl is right; ∈ is probably the closest operator—stylized epsilon for “element of”—to what you want, and it’d make sense for `instanceof` also if you go with the set metaphor for types.",0.2857142857142857,d
15oi4b4,jvuae69,"real\_taylodl is right; ∈ is probably the closest operator—stylized epsilon for “element of”—to what you want, and it’d make sense for `instanceof` also if you go with the set metaphor for types.",0.2857142857142857,go
15oi4b4,jvsg5ik,"But apparently you want your language to look like APL since you don't like keywords, so ...",0.05,apl
15oi4b4,jvua1k5,"https://www.postgresql.org/docs/15/functions-geometry.html  Ruby just has methods [1,2,3].include?",0.0,ruby
15oi4b4,jzlp3z4,ASCII is the way to go if most of your language is ASCII to begin with.,0.5,go
15oi4b4,jvyvdbn,Julia does this,0.0,julia
15oi4b4,jvsiqta,APL.,0.0,apl
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,lisp
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,haskell
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,rust
15o64p8,jvs85dx,"Pattern matching goes back to the 1980's with languages like SML and Common Lisp, and is ubiquitous in languages with powerful type systems with sum types, like Haskell, Rust, and Swift.",0.0,swift
15o64p8,jvr73jn,You might want to take a look at [Ruby's switch expression](https://www.rubyguides.com/2015/10/ruby-case/) (and the `===` method too).,0.0,ruby
15o64p8,jvtpjxe,"clojure already have this implemented as macros, see [condp](https://clojuredocs.org/clojure.core/condp)",0.0,clojure
15o64p8,jvyvjr5,C# has a similar feature.,0.0,c
15o64p8,jvq6rrs,"But if you’re trying to build something that others will use, then I’d humbly suggest that this experiment should be hidden in the waste bin.",-0.18888888888888888,d
15o64p8,jvqaz1f,Why don't you go for pattern matching?,0.0,go
15o64p8,jvsd4qv,"The discussion here is not about rediscovering pattern matching, the language already has it, but it about keep syntax the same like c in default cases and make it fixable with minimal amount of change for example not like  ``` n switch {     > 1 : .....     < 2: .....     _: ..... } ```",-0.05,c
15o64p8,jvqlt6c,This is how match in rust works.,0.0,rust
15o64p8,jvseryg,C# and Rust both have a take on this in each their own way.,0.6,c
15o64p8,jvseryg,C# and Rust both have a take on this in each their own way.,0.6,rust
15o64p8,jvseryg,Rust is hard-line keyword-first but omits parentheses.,0.0,rust
15o64p8,jvseryg,C# has the `<expression> switch { <cases> }` structure taken from Scala.,0.0,c
15o64p8,jvseryg,C# has the `<expression> switch { <cases> }` structure taken from Scala.,0.0,scala
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,rust
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,ruby
15o64p8,jvseryg,"What you _should_ do, is to eliminate the distinction between statements and expressions, like Rust (and Ruby, and Algol.)",0.0,algol
15o4pr5,,"Here I rewrite a few constructs from a C like language using these 7 controls (exit is used to indicate exiting out of ladder (similar to break), fallthrough is used to indicate exiting out of current block and continuing (similar to continue)):      1.",-0.05,c
15o4pr5,jvpuj9u,"Also yes, it requires function scoped variables like python.",0.0,python
15o4pr5,jvpuj9u,"Otherwise you can't access variables in `if` block from `then if` block, which would have been possible in corresponding C style code shown above.",0.0,c
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,lisp
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,javascript
15o4pr5,jvsa4o7,"And unless you write Lisp or JavaScript, you don't like code that looks like this:  >     if cond1 { >         stmt1; >         if cond2 { >         stmt2; >         stmt3... >     }} elif cond3 { >         stmt4... >     }   Instead of adding ad-hoc constructs to decrease nesting, I am considering adding another form of block `do a; b; c` that extends as far as possible.",0.19999999999999998,c
15o4pr5,jvsa4o7,">     if cond1 { >         stmt1; >         if cond2 do >         stmt2; >         stmt3... >     } elif cond3 { >         stmt4... >     }  Another construct for reducing nesting subsumed by this idea is Rust's `let else` (just use a `do` in the last, happy branch of pattern matching).",0.4,rust
15o4pr5,jvtz1w0,(viz: PHP and the ternary `?`/`:` operator.),0.0,php
15o4pr5,jvtz1w0,The *goto fail* bug was basically a clerical error in a hand-rolled version of `if-also` done in C with `goto` and labels.,-0.5,c
15o4pr5,jvr79oj,"This was your main example, summarised:      if primary {         prelude         if not secondary {            exit to next elif test [AIUI]         }         main code          } elif next_primary {  Using `and` it would look like this, if preludes can go inside expressions (this is in my syntax, and corresponds to the non-`and` version given below):      if primary and (println ""prelude""; secondary) then         println ""main code""     elsif next_primary then         println ""next main code""  Your post the mentions the need for fallthrough, and suggests `thif`, but then the examples that follow use brace syntax, and do not use `thif` or even `elif`, so I couldn't follow them.",0.13166666666666665,go
15o4pr5,jvqnmj1,First I didn't think about it as my language has python like function scoped variables (though you can end a variables lifetime sooner similar to `del` but more simple).,0.1875,python
15o4pr5,jvreiap,Most families taking after C stop at about this point.,0.5,c
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,c
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,c++
15o4pr5,jvreiap,"For example, in C (or C++, Java, etc) it doesn't really make sense to say the following: ``` int some_var = if (condition) { 1 } else { 2 } ``` because the if *statement* is not an expression.",0.1,java
15o4pr5,jvreiap,"Contrast this to Rust (or most functional languages) -- the above does make sense, because `if` is an *expression*.",0.25,rust
15o4pr5,jvreiap,"Additionally, this lets you do things like the following (Rust syntax): ``` let some_var = {     let temp = produce_temp_value();     let another = temp.do_thing();     another + 3 }; ``` Helpful for correct scoping of temporary values without having uninitialized variables.",0.0,rust
15o4pr5,jvreiap,[The Rust Book](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html#statements-and-expressions) has some more explanation.,0.5,rust
15o4pr5,jvs2m57,"Rewriting that example using `thif` would be ``` if primary:     prelude thif secondary:     main code elif nextprimary:     next main code ``` I mentioned fallthrough because, if you convert this into C style code, it would be something like ``` if primary:     prelude     if not secondary:         # <fall> or <continue> or <skip> or whatever that makes the control to go back searching for next match in ladder (which is not present in C or any major languages that I know of)     main code elif nextprimary:     next main code ```  Sorry if my explanation is unclear again :|",0.05861111111111113,c
15o4pr5,jvs2m57,"Rewriting that example using `thif` would be ``` if primary:     prelude thif secondary:     main code elif nextprimary:     next main code ``` I mentioned fallthrough because, if you convert this into C style code, it would be something like ``` if primary:     prelude     if not secondary:         # <fall> or <continue> or <skip> or whatever that makes the control to go back searching for next match in ladder (which is not present in C or any major languages that I know of)     main code elif nextprimary:     next main code ```  Sorry if my explanation is unclear again :|",0.05861111111111113,go
15o4pr5,jvsp3xp,The above version using Python style is the same.,0.0,python
15o42wx,,where at global scope use can precede declaration) that also uses the template syntax that C++ and many other languages use?,0.125,c++
15o42wx,,I know C++ compilers resolve this issue be maintaining a table of all template declarations and when a template name appears `<` is parsed as an opening bracket for template parameters.,0.0,c++
15o42wx,,It appears other languages for example swift have solved this issue because they support both order independent declarations and the generic syntax.,-0.041666666666666664,swift
15o42wx,jvrgnex,"You could forbid chained comparisons (forcing users to write `a < b && b > c` or `(a < b) > c`,depending on what they want.",0.0,c
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,rust
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,c++
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,c
15o42wx,jvzqt1o,"**Do it like Rust**  Rust uses angled brackets for familiarity for users coming from other mainstream languages (C++, C#, Java), however its developers were keen on trying to retain as LL(1) a grammar as possible.",-0.0625,java
15o42wx,jvzqt1o,"So, in Rust:   - In a _type_ context, angled brackets are just used as is: `Generic<Parameter>`.",0.0,rust
15o42wx,jvzqt1o,I would recommend -- if you want to stick to angled brackets -- to do it like Rust.,0.0,rust
15o42wx,jvzqt1o,"Not only because you'll get your order free parsing, but also because Rust users will already be familiar with it.",0.25833333333333336,rust
15o42wx,jvr7n0s,"In my language transpiled to C++ I handle it in a pre-parse step (I use a peg that doesn't require a separate lexer but I preprocess for indent checking and a few other things):  Roughly, upon encountering balanced `<` and `>,` check if either a `(` `{` or `[` follows the closing `>`.",-0.1416666666666667,c++
15o42wx,jvr7n0s,I'd consider banning compound comparisons as suggested in another comment (they don't chain like python in c++ anyway) but it would complicate the parser at the moment.,0.0,python
15o42wx,jvr7n0s,I'd consider banning compound comparisons as suggested in another comment (they don't chain like python in c++ anyway) but it would complicate the parser at the moment.,0.0,c++
15o42wx,jvr7n0s,"Also, `1 < 2 > (0)` is an error unlike in C++ (`1 < 2 > 0` is fine).",0.4166666666666667,c++
15o42wx,jvr7n0s,"On the upside, this parses both     `value = 1 + number_of_bits<number >> 1>::value // fine in c++03, fails c++11`  and  `value = 1 + number_of_bits<(number >> 1)>::value // fine any std`     https://stackoverflow.com/questions/31447039/valid-c03-template-code-wont-compile-in-c11  (I want to de-emphasize the use of < and > in C++ anyway partly by going crazy with CTAD but I still want the < and > syntax mainly for interfacing with 3rd-party code)",-0.01999999999999999,c++
15o42wx,jvsjd2l,How is `a < b && b > c` not ambiguous?,0.0,c
15o42wx,jvsjd2l,"Considering the example `a < b && b > (c)`, this could either be ""`a` is less than `b` and `b` is greater than `(c)`"" or it could be ""call function template `a` with boolean template parameter `b && b` and argument `c`"".",0.16666666666666669,c
15o42wx,jw157dm,It's a bit frustrating though that this problem is apparently so hard that even the Rust people decided to introduce different syntax to simplify parsing.,-0.23055555555555554,rust
15o42wx,jvsogaf,"only allowing sufficiently strong expressions within `<>`, which would demand parentheses in the case of `a<(b && b)>(c)`).",0.21666666666666665,c
15o42wx,jvsogaf,"In particular, pay attention to the precedence of comma: `(a<b,c,d>(e))` could turn out to be a tuple of `(bool, smth, bool)` if it's too low.",0.08333333333333333,c
15o42wx,jvsogaf,"In particular, pay attention to the precedence of comma: `(a<b,c,d>(e))` could turn out to be a tuple of `(bool, smth, bool)` if it's too low.",0.08333333333333333,d
15o1wxa,jvq562g,"For OCaml at least the tagged scheme gives a very regular layout to the vast majority of heap memory, and the garbage-collection code is a very hot simple loop (with a few branches for the less-common and more complex cases that are predicted well).",0.0031250000000000028,scheme
15o1wxa,jvr37qx,"If you are monomorphising already, it's probably not too much extra work to go mostly (or completely) stackless.",0.05,go
15o1wxa,jvr37qx,"Most of the current async/await strategies work this way already (rust, c#, js), with GHC being an outlier.",0.25,rust
15o1wxa,jvr37qx,"Most of the current async/await strategies work this way already (rust, c#, js), with GHC being an outlier.",0.25,c
15o1wxa,jvr37qx,"Aside from that, this is probably the most efficient strategy, although it colors the functions based on whether they might yield to another green thread (local data must go into heap object) vs cannot yield (that data can remain on the regular stack).",0.075,go
15o1wxa,jvvjep6,"By the way, if you are interested in garbage collectors, as you seem to be, they are just implementing a new garbage collector for sbcl (a Common Lisp compiler).",0.02878787878787879,lisp
15o1wxa,jvqg7j5,"As far as I know, there is no non-sweep-time overhead to the Boehm GC, other than the normal overhead of allocating memory (and I think Boehm's `GC_malloc` runs faster than the C stdlib `malloc`).",0.041666666666666664,c
15o1wxa,jvqg7j5,"In fact, you can take a large C program and replace `malloc` with `GC_malloc` (and delete calls to `free`) and it will compile and run with no differences to the generated machine code besides which function is being called (and the lack of `free`s).",0.30714285714285716,c
15o1wxa,jynxm3j,"Look at [SGCL](https://github.com/pebal/sgcl), it's real-time GC for C++ without pauses, locks and tags.",0.0,c++
15o1wxa,jvyd8lz,"Cliff (who wrote the Hotspot JIT compiler for Java) now runs the Coffee Compiler Club ([https://www.youtube.com/@compilers]), is working (with me :-) on building the [Ecstasy](https://github.com/xtclang/xvm) back-end, and in his spare time is designing/building a low level language with global type inference called [AA](https://github.com/cliffclick/aa).",0.16666666666666666,java
15o1wxa,jvvr44u,"All spilling decisions are made by codegen, the same way as in a plain C backend, without any consideration for relocation.",-0.10714285714285714,c
15o1wxa,jvvr44u,"1  fun foo(x : Int, y : Int) : Int     2    let z = x + y     3    return z     4     5  fun bar(a : Int, b : Int) : Int     6    let c = a + b     7    let d = foo(a, b)     8    let e = c + d     9    return e  Assume that `bar` calls `foo` and at line (2) we get a heap overflow and a GC call.",0.3,c
15o1wxa,jvvr44u,"1  fun foo(x : Int, y : Int) : Int     2    let z = x + y     3    return z     4     5  fun bar(a : Int, b : Int) : Int     6    let c = a + b     7    let d = foo(a, b)     8    let e = c + d     9    return e  Assume that `bar` calls `foo` and at line (2) we get a heap overflow and a GC call.",0.3,d
15o1wxa,jvvr44u,"Using ""zero-cost GC"":  - When `foo` is called, `c` is in a callee-preserved register.",0.0,c
15o1wxa,jvvr44u,"- At the (7) statepoint, we learn that `c` was in some register when `foo` was called.",0.0,c
15o1wxa,jvvr44u,We also know from the (2) statepoint that `c` is still in that register because `foo` didn't spill it.,0.0,c
15o1wxa,jvvr44u,"Hence, we relocate `c` in the register.",0.0,c
15o1wxa,jvvr44u,"Using whatever precise GC is possible using LLVM, to my current knowledge:  - When `foo` is called, `c` must be on the stack.",0.13333333333333333,c
15o1wxa,jvvr44u,"- At the (7) statepoint, the StackMap tells us that `c` is in a stack location, so we relocate it there.",0.0,c
15o1wxa,jvwfzec,"I have gone ahead and converted your example to LLVM IR the way a frontend could emit it: ```llvmir  declare ptr addrspace(1) @add(ptr addrspace(1) %x, ptr addrspace(1) %y) ""gc-leaf-function""  define ptr addrspace(1) @foo(ptr addrspace(1) %x, ptr addrspace(1) %y) #1 gc ""coreclr"" {   %z = call ptr addrspace(1) @add(ptr addrspace(1) %x, ptr addrspace(1) %y)   ret ptr addrspace(1) %z }  define ptr addrspace(1) @bar(ptr addrspace(1) %a, ptr addrspace(1) %b) local_unnamed_addr #0 gc ""coreclr"" {     %c = call ptr addrspace(1) @add(ptr addrspace(1) %a, ptr addrspace(1) %b)     %d = call ptr addrspace(1) @foo(ptr addrspace(1) %a, ptr addrspace(1) %b)     %e = call ptr addrspace(1) @add(ptr addrspace(1) %c, ptr addrspace(1) %d)     ret ptr addrspace(1) %e }  attributes #1 = {noinline} ``` with the only exception of marking `foo` as `noinline` to observe exactly the behaviour that you want.",0.125,c
15o1wxa,jvwfzec,"I have gone ahead and converted your example to LLVM IR the way a frontend could emit it: ```llvmir  declare ptr addrspace(1) @add(ptr addrspace(1) %x, ptr addrspace(1) %y) ""gc-leaf-function""  define ptr addrspace(1) @foo(ptr addrspace(1) %x, ptr addrspace(1) %y) #1 gc ""coreclr"" {   %z = call ptr addrspace(1) @add(ptr addrspace(1) %x, ptr addrspace(1) %y)   ret ptr addrspace(1) %z }  define ptr addrspace(1) @bar(ptr addrspace(1) %a, ptr addrspace(1) %b) local_unnamed_addr #0 gc ""coreclr"" {     %c = call ptr addrspace(1) @add(ptr addrspace(1) %a, ptr addrspace(1) %b)     %d = call ptr addrspace(1) @foo(ptr addrspace(1) %a, ptr addrspace(1) %b)     %e = call ptr addrspace(1) @add(ptr addrspace(1) %c, ptr addrspace(1) %d)     ret ptr addrspace(1) %e }  attributes #1 = {noinline} ``` with the only exception of marking `foo` as `noinline` to observe exactly the behaviour that you want.",0.125,d
15o1wxa,jvwfzec,"Taking this output IR and putting it through LLC with the previously mentioned options gets us the following assembly: ``` bar:                                    # @bar         push    r15         push    r14         push    rbx         mov     rbx, rsi         mov     r14, rdi         call    add@PLT         mov     r15, rax         mov     rdi, r14         mov     rsi, rbx         call    foo@PLT         mov     rdi, r15         mov     rsi, rax         pop     rbx         pop     r14         pop     r15         jmp     add@PLT                         # TAILCALL ``` https://godbolt.org/z/1Yh8xhn3T As you can see there are no stack spills.",-0.08333333333333333,assembly
15o1wxa,jvwfzec,"In fact, this assembly is exactly equal as if we never used a GC: ``` bar:                                    # @bar         push    r15         push    r14         push    rbx         mov     rbx, rsi         mov     r14, rdi         call    add@PLT         mov     r15, rax         mov     rdi, r14         mov     rsi, rbx         call    foo@PLT         mov     rdi, r15         mov     rsi, rax         pop     rbx         pop     r14         pop     r15         jmp     add@PLT                         # TAILCALL ``` https://godbolt.org/z/oMjjs6TWd  I believe this fits your definition of ""zero-cost GC"".",0.0,assembly
15o1wxa,jvwfzec,"These are the DWARF register numbers corresponding to `%rbx`, `%r14` and `%r15` [0] and corresponding to the variables `a`, `b` and `c` in your example respectively.",0.0,c
15o1wxa,jvwfzec,"> When foo is called, c must be on the stack.",0.0,c
15o1wxa,jvwfzec,"Infact, LLVM IR has no concept of a stack allocation (in the sense of mandating stack allocation in the output assembly) or registers and whether a value is on the stack or in the register is an implementation detail (and quality aspect) of the backend compiling LLVM IR to the target assembly.",0.0,assembly
15o1wxa,jw2embt,I thought you were talking about a different scheme.,0.0,scheme
15o1wxa,jw2embt,"In the alternate scheme, you replace a branch with a dummy load (ignoring the result) from an address which is null iff the branch should have been taken, and otherwise goes to an arbitrary accessible location.",0.09166666666666667,scheme
15o1r70,jvqhypo,"I'd prefer attribution go to Alan Kay, who gets credit for Smalltalk: https://www.quora.com/What-is-the-story-behind-Alan-Kay-s-adage-Simple-things-should-be-simple-complex-things-should-be-possible/answer/Alan-Kay-11?ch=10&share=7a78ffce&srid=88EK",0.0,go
15o1r70,jvr5o8o,"It's true, I'm not a fan of Perl ...",0.35,perl
15o1r70,jvuezri,"Now the point of this is that someone can declare for example:      languages          Forth  Forth is just an example, there's no particular use-case.",-0.08333333333333333,forth
15o1r70,jvuezri,"But anyone who wanted to could, and then the `---` constructor will do the same things but with type `Forth`.",0.0,forth
15o1r70,jvuezri,"So then can then overload `get` to interact with something that actually knows Forth, and start writing stuff like      x = 2     y = 3     get result from Forth --- x y +     post result to Output() // prints 5  A more realistic use-case is that people may want to talk to non-SQL databases.",0.2222222222222222,forth
15o0042,jvvo31d,Slides are *definitely* the way to go on this -- at least for getting a casual understanding of what problem this solves.,-0.26666666666666666,go
15njznz,jvmeu53,"Liquid Haskell is an example of a tool for adding refinement-type annotations to Haskell code, which you might like to look at for ideas.",0.0,haskell
15njznz,jvmeu53,Ada also has integer range types like this.,0.0,ada
15njznz,jvnb8em,"In Ada, these constraints are called subtype predicates :  http://www.ada-auth.org/standards/12rat/html/Rat12-2-5.html",0.0,ada
15njznz,jvqmh36,"(maybe not, that's just off top)  Edit: i saw below that ada has subtype predicates which is exactly that.",0.375,ada
15njznz,jvmxlxr,"The below is a syntax I'm working on:  ``` val :: String where str -> str.length in (5 to 10) myString = ""abcdefg""  # constraints are prohibited in type annotations val myOtherString :: String = ""xyzabc"" ```  The first line is a type signature similar to the ones you'll find in Haskell and the like.",0.125,haskell
15njznz,jvqbvo1,I use it in C# all the time for model validation.,0.0,c
15njznz,jvqsv8e,Refinement types are very cool.,0.45499999999999996,cool
15njznz,jvqsv8e,Side note 2: Saline's refinement type's syntax is inspired from Liquid Haskell (which has been mentioned in another comment) with little tweaks to make it (in my opinion) more logical.,0.1875,haskell
15njznz,jwlcsfj,"I know people have explored similar ideas for stack languages (I think Christopher Diggins for Cat, Daniel Ehrenberg for Factor, and maybe Anton Ertl for Forth) but I don’t have good references offhand, and I don’t think anyone’s gotten very far with it, but I’d be interested to try using a system like that.",0.27,forth
15njznz,jwlcsfj,"I know people have explored similar ideas for stack languages (I think Christopher Diggins for Cat, Daniel Ehrenberg for Factor, and maybe Anton Ertl for Forth) but I don’t have good references offhand, and I don’t think anyone’s gotten very far with it, but I’d be interested to try using a system like that.",0.27,d
15njznz,jwlcsfj,"c` = `a b c | a c b | b a c | …`, or recursion.",0.0,c
15nj1xx,,"As I mentioned in my comment, I sometimes would like to use a function defined by a table as a function argument, but I don't know of any languages that would actually allow this, certainly JavaScript doesn't.",0.10714285714285714,javascript
15nj1xx,jvm9cy7,"She had a background in mathematics and apparently no qualms to prefer 'call' over 'apply'  In JavaScript functions can be called directly (of course) and also by their `call()` and `apply()` methods, whose semantics differ slightly.",-0.030555555555555548,javascript
15nj1xx,jvmbki3,"[Calling a function seems to be an artefact from Fortran, but I'm not sure.",-0.25,fortran
15nj1xx,jvok55j,"In languages where functions are or may be lazy, like Haskell or Mathematica, people do call it a “function call” less often, I would say.",-0.20833333333333331,haskell
15nj1xx,jvpjpk0,"Fortran orignally distinglished between functions (which returned a value and could appear in expressions), which did mimic functions like ""sin(x)"" and could appear in expressions and subroutines (which returned nothing but could change their byref parameters).",0.0,fortran
15nj1xx,jvop64b,"In functional languages, like Haskell, functions really are functions in the mathematical sense.",0.1,haskell
15nj1xx,jvop64b,"In fact, in lazy functional languages like Haskell, there is no guarantee that the code will be executed even once; if the result isn’t needed it won’t be invoked and if only parts of the result are needed only those parts of function will be executed.",-0.08333333333333333,haskell
15nj1xx,jvop64b,"Even traditional procedures (like print) are, thanks to the magic of monads, genuine functions in Haskell.",0.275,haskell
15nj1xx,jvpog0q,"What I mean is that, in one sense it is probably true, but in that sense it would also be true of procedural languages, as it is definitely possible to implement mathematical functions in them: for example a variable **var** *f*: **array**\[1..*n*, 1..*m*\] of 1..*k* in Pascal can represent *any* mathematical function f(i,j) of two natural variables i <= n, j <= m, to the subset of the natural numbers less than k. (I don't think you were the person who recently insisted in a comments section, that integers in programming languages weren't integers, otherwise this conversation would be rather pointless and futile.)",0.015530303030303026,pascal
15nj1xx,jvpog0q,"So in this sense, again, Pascal (or procedural languages in general) does not ""truly"" model mathematical functions, but then I have my doubts that Haskell and other functional languages can rightfully claim to do so.",-0.024999999999999994,pascal
15nj1xx,jvpog0q,"So in this sense, again, Pascal (or procedural languages in general) does not ""truly"" model mathematical functions, but then I have my doubts that Haskell and other functional languages can rightfully claim to do so.",-0.024999999999999994,haskell
15nj1xx,jvroeoj,"Algol 60 originally used the word **procedure** (Algol 68 cutting it down to **proc**), but when NIklaus Wirth designed Pascal based on his Algol W dialect, he chose to differentiate by using the keyword **function**.",-0.032638888888888884,algol
15nj1xx,jvroeoj,"Algol 60 originally used the word **procedure** (Algol 68 cutting it down to **proc**), but when NIklaus Wirth designed Pascal based on his Algol W dialect, he chose to differentiate by using the keyword **function**.",-0.032638888888888884,pascal
15nj1xx,jvroeoj,"Interestingly, Ada retains the **function** keyword from Pascal, without requiring absence of side effects.",0.24375,ada
15nj1xx,jvroeoj,"Interestingly, Ada retains the **function** keyword from Pascal, without requiring absence of side effects.",0.24375,pascal
15nj1xx,jvqagyk,If I write down a Haskell function defining the fibonacci or factorial function(!),-0.07777777777777779,haskell
15nj1xx,jvzpgvu,Languages like Haskell have laws like  > map f .,0.0,haskell
15nj1xx,jvrtvt6,"One way to boil down the issue is to ask the question: is it necessary to have a ""real functional programming language, like Haskell"", to do functional programming?",0.014814814814814808,haskell
15nj1xx,jvv5yf6,"Even if you go totally your own way and define your own ABI and paradigm for using commonly available CPUs, you're probably going to need a Foreign Function Interface sometime.",0.29500000000000004,go
15nj1xx,jvv5yf6,Wanna interface with C or some kind of ASM?,0.6,c
15nj1xx,jvzek60,"When block structure was invented with Algol, several methods were invented to manage the relation between block instances and names in local and enclosing scopes, even under recursion: Static Link and Display were the two most important I believe.",0.27999999999999997,algol
15nj1xx,jvzek60,"Then C, being low level and simple, just disallowed nested ""functions"", reducing the problem to global variables and variables in nested blocks that always belong to the same activation.",0.0,c
15nj1xx,jvzek60,"And now we have architectures that can't support the GNU C ""nested functions"" extension, because it uses an implementation technique that creates problems with function pointers.",0.0,c
15nj1xx,jvzek60,"And the ""new old-school"" people, who just adopted the word ""function"" because the language they are using descends from C and has inherited C's term, for something that used to be called subroutine, routine, procedure, or (in Ada for example) sub-program.",0.13636363636363635,c
15nj1xx,jvzek60,"And the ""new old-school"" people, who just adopted the word ""function"" because the language they are using descends from C and has inherited C's term, for something that used to be called subroutine, routine, procedure, or (in Ada for example) sub-program.",0.13636363636363635,ada
15nj1xx,jvzwrts,"I didn't bother to go check on that, but I know on Intel / AMD architecture it's a ""call"" and there are machine instructions for such.",0.0,go
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,rust
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,go
15ngmni,,"In addition, through KCL Rust, Go, and Python multilingual SDKs, the configuration can be automatically managed and executed.",0.0,python
15n31u1,,I guess there's some backlash against things like Python's `async` / `await` stuff.,0.0,python
15n31u1,,Not that concurrent coroutines aren't cool; just that decorating them as such is contagious in a manner similar to checked exceptions.,0.11666666666666665,cool
15n31u1,,"Shells (as in bash, csh, etc) allow you to take a perfectly-ordinary ""synchronous"" program and put it in the background.",0.0,bash
15n31u1,,"](https://en.wikipedia.org/wiki/The_Sneetches_and_Other_Stories) And in fact the *What color...* author seems to agree, highlighting *Go* as a good example.",0.7,go
15n31u1,,Does that `go` keyword have the semantics we really want?,0.2,go
15n31u1,,"On the surface, it seems that `go foo(bar, baz)` is effectively a *command*, saying ""execute `foo(bar, baz)` asynchronously"".",0.6,go
15n31u1,,"Basically, I'm looking for precedent on this idea: What if we split `go` in half?",-0.16666666666666666,go
15n31u1,,"Suppose we redefine `go` to make an *unstarted promise* out of its right-argument, and then just consider *executing* a promise as *starting* that promise.",0.0,go
15n31u1,,Then `go` is no longer a *command keyword* but instead an *expression operator* that happens to interact with function-calls.,0.0,go
15n31u1,jvm4rdl,"If `go f(x)` is supposed to mean ""execute `f(x)` later,"" then how is it at all different from `λ().",-0.10416666666666667,go
15n31u1,jvm4rdl,"val async-handle = handler {         await(initiate) → initiate( resume )     }  allowing for      fun wait(d: duration) {         await(fn(cb) {             set-timeout(cb, d.milliseconds)         })     }      fun main {         println(""Hello "")         wait(2.seconds)         println(""World!"")",0.26944444444444443,d
15n31u1,jvjz80j,"You can pretty easily model Promises with channels [https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec](https://levelup.gitconnected.com/use-go-channels-as-promises-and-async-await-ee62d93078ec)  As far as I know, Erlang has a similar model where everything is sent as messages to specific addresses instead.",0.15666666666666668,erlang
15n31u1,jvk58ke,With this view `go foo()` is just a statement to start `foo()` in a new user-mode thread.,0.13636363636363635,go
15n31u1,jvk58ke,"So `go` is basically a command that creates a new thread and immediately starts it, whereas IIUC what you're proposing, let's call it `newgo`, is a function to create a thread but not start it yet.",0.13636363636363635,go
15n31u1,jvk58ke,"I don't see this as an interesting difference, you can easily simulate either one with the other:  `define newgo(func) => go func`  `define go(func) => (newgo func)()`  As a disclaimer, I'm not super familiar with go but I know inter-thread communication is done with channels generally, not simply joining on a thread, but the general principles should still be similar...",0.13333333333333333,go
15n31u1,jw1315g,"I am eliminating it in my language and adopting a structured concurrency approach (see [Notes on structured concurrency, or: Go statement considered harmful](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)).",0.0,go
15n31u1,jw1315g,"Basically, doing something like Go's green threads, but instead of the `go` keyword as done in Go, I have async scopes.",-0.2,go
15n31u1,jw1315g,"Inside an async scope, you can use `go` and `do` to create a promise from any expression.",0.0,go
15n31u1,jvkebho,"In many languages (including Go, as you mention), either by language definition or by convention, you never really have to choose between multiple threading runtimes, so there's not really a need for async.",0.07500000000000001,go
15n31u1,jvm3o28,I'd recommend taking a look at [Lua's Coroutines](http://lua-users.org/wiki/CoroutinesTutorial).,0.0,lua
15n31u1,jvm3o28,"Lua's solution to this problem is to allow creating a coroutine with `co = coroutine.create(fn)` and then hand off control to the coroutine by calling `coroutine.resume(co, args...)`.",0.0,lua
15n31u1,jvm3o28,"All of this is accomplished using regular functions, there is no syntactic element for `async` or `go`, there are just ordinary functions (implemented in C), which stash local execution state and hand off control to a different execution state until control returns with a return value.",-0.009999999999999998,go
15n31u1,jvm3o28,"All of this is accomplished using regular functions, there is no syntactic element for `async` or `go`, there are just ordinary functions (implemented in C), which stash local execution state and hand off control to a different execution state until control returns with a return value.",-0.009999999999999998,c
15n31u1,jvm3o28,"Lua's model uses single-threaded cooperative concurrency, but there are third-party libraries like [LuaThread](https://hserg.github.io/luathread-website/examples.html) that add support for pthreads with a similar level of simplicity in API design and without language extensions.",0.0,lua
15n31u1,jvo0qpu,">Basically, I'm looking for precedent on this idea: What if we split go in half?",-0.16666666666666666,go
15n31u1,jvo0qpu,"Suppose we redefine go to make an unstarted promise out of its right-argument, and then just consider executing a promise as starting that promise.",0.0,go
15n31u1,jvo0qpu,Then go is no longer a command keyword but instead an expression operator that happens to interact with function-calls.,0.0,go
15n31u1,jvo0qpu,"When you invoke a method that exists within a different `service` (equivalent to an Erlang ""process""), the result is a future, and the invocation is asynchronous.",0.0,erlang
15n31u1,jvm1mmx,"In the case of C# and Kotlin, it's because the built-in thread types are too heavyweight to scale, so async/await allows a large number of ""tasks"" to be multiplexed onto a smaller number of real threads.",0.13809523809523808,c
15n31u1,jvm1mmx,"In the case of C# and Kotlin, it's because the built-in thread types are too heavyweight to scale, so async/await allows a large number of ""tasks"" to be multiplexed onto a smaller number of real threads.",0.13809523809523808,kotlin
15n31u1,jvm1mmx,"I can't say why Python adopted it, but presumably for similar reasons to JS.",0.0,python
15n31u1,jvm1mmx,"Languages like Erlang and Go adopted a different model from the start, with comparatively lighter-weight threads (i.e.",0.0,erlang
15n31u1,jvm1mmx,"Languages like Erlang and Go adopted a different model from the start, with comparatively lighter-weight threads (i.e.",0.0,go
15n31u1,jvm1mmx,"Java's taking an interesting approach - they're switching the built-in thread concept from something always backed by an OS-level thread to something that *can* be backed by an OS-level thread, but can also be a lightweight thread.",0.5,java
15n31u1,jvm1mmx,"In the rules of Go, `quux` can certainly call `foo` synchronously.",0.21428571428571427,go
15n31u1,jvm1mmx,"But the intent behind the `go` keyword is that functions are not different, and you can call any function either synchronously or asynchronously.",-0.2,go
15n31u1,jvm1mmx,"> Basically, I'm looking for precedent on this idea: What if we split go in half?",-0.16666666666666666,go
15n31u1,jvm1mmx,"Suppose we redefine go to make an unstarted promise out of its right-argument, and then just consider executing a promise as starting that promise.",0.0,go
15n31u1,jvm1mmx,Then go is no longer a command keyword but instead an expression operator that happens to interact with function-calls.,0.0,go
15n31u1,jvm1mmx,"Alternatively, could you achieve the same thing by wrapping the `go` expression inside a lambda?",0.0,go
15n31u1,jvkeohg,"In Kotlin, all functions are synchronous.",0.0,kotlin
15n31u1,jvl3sgh,"Erlang uses a particular interpretation of the Actor model, which is asynchronous with unbounded mailbox size.",0.16666666666666666,erlang
15n31u1,jvl3sgh,"This is somewhat but not completely analogous to Go's take on CSP, which is synchronous with bounded channel size.",-0.05,go
15n31u1,jvl3sgh,"Erlang provides something akin to that with `gen_server:call`, although it also enforces deadlines whereas Go's channels can easily deadlock.",0.43333333333333335,erlang
15n31u1,jvl3sgh,"Erlang provides something akin to that with `gen_server:call`, although it also enforces deadlines whereas Go's channels can easily deadlock.",0.43333333333333335,go
15n31u1,jvl3sgh,"However, Erlang can also express asynchronous patterns which aren't possible with Go channels.",0.0,erlang
15n31u1,jvl3sgh,"However, Erlang can also express asynchronous patterns which aren't possible with Go channels.",0.0,go
15n31u1,jvl3sgh,Personally I prefer the Erlang model although I do find the unbounded mailbox size something of a footgun.,0.0,erlang
15n31u1,jvl3sgh,"(Distributed Erlang opts for the latter when network buffers are full, FWIW)",0.175,erlang
15n31u1,jvlujez,"Think about how it works in JavaScript for example; instead of the old idiom of passing callbacks to perform at some point in the future, we pass the current continuation.",0.03333333333333333,javascript
15n31u1,jvlujez,"And because this is JavaScript we're not talking about multiple JavaScript threads, we're really talking about 0 or 1 JavaScript threads.",0.1,javascript
15n31u1,jvnwpac,And it seems Go provides a single standard scheduler implementation (despite not having those particular keywords).,0.031746031746031744,go
15n31u1,jvnwpac,"I don't see the `go` keyword as being *semantically* tied to whichever scheduler Go currently sports; just as a way of saying ""go do this in a separate thread of control"" which up to Rob Pike to solve.",0.0,go
15n31u1,jvo4cqq,"And now that I think of it, perhaps I'm looking for `go`\-that-is-like-lambda.",0.0,go
15n31u1,jvo4cqq,The most annoying thing about Python generators is/was how difficult they are to compose.,-0.26666666666666666,python
15n31u1,jvp6sor,"> I don't see the `go` keyword as being semantically tied to whichever scheduler Go currently sports; just as a way of saying ""go do this in a separate thread of control"" which up to Rob Pike to solve.",0.0,go
15n31u1,jvp6sor,"I think your point is that Go's scheduler can be thought of as some global compile-time constant, which could be set to something else.",0.0,go
15n31u1,jvs4n7x,"Nah, I don't know about go specifically but, there are a million ways to achieve the same---or similar---in a lang with threads.",0.0,go
15n31u1,jvv96eh,"Virtual threads in Java work like that, for instance.",0.0,java
15n31u1,jvxbc2x,"> Virtual threads in Java work like that, for instance.",0.0,java
15mqi66,,"If not, and I doubt it doesn't, is this appliable to C++?",0.0,c++
15mqi66,,"PS: The parser I wrote (for C only) correctly parsed raylib.h and cimgui.h (so the failing case may be rare, but not sure about this)",0.016666666666666663,c
15mqi66,jvl2nwz,"Because it might just look like this:      A B;  I also support out-of-order declarations (not for C), and what I have to do is tentatively assume that with two successive identifiers like `A B`, the first is a type `A` to be subsequently defined.",0.125,c
15mqi66,jvl2nwz,"(Better in my syntax is to write `var A B`, which is also possible, or even `var B:A`, but if parsing existing C, you don't have that option.)",0.25,c
15mqi66,jvlnwb2,(with l.3 commented/uncommented) ```c int main() {     //int A;     A*B; } typedef int A; ```,0.16666666666666666,c
15mqi66,jw7g2na,C grammar is ambiguous without the lexer hack.,0.0,c
15mqi66,jw7g2na,"IOW, order-free parsing of C is not feasible in the general case.",0.05000000000000002,c
15mqi66,jvhyh2c,"It means type specifier, if you search for the C syntax nbf and look at `specifier :=` you understand better.",0.5,c
15mqi66,jvl4um0,in c the global scope is always a list of declarations so the first identifier is always a type right?,0.17857142857142858,c
15mqi66,jvlr8ce,As I already mentioned this is a lazy parser so local scopes are parsed using the classical lexer hack used by major c compilers (in other words it behaves just like all normal c compilers).,-0.027083333333333334,c
15mqi66,jvlr8ce,"but, you can replicate the same example globally      // int A;     A*B;          typedef int A;  so here `a*b` can only be a declaration and uncommenting l.3 will be error in both this compiler and normal c compilers.",0.0375,c
15mqi66,jvl8hyh,"In C, new type identifiers that can start a declaration by themselves (so don't need `struct` or `enum`) I think are only introduced by `typedef`.",0.06818181818181818,c
15mqi66,jvl8hyh,"But there is an ambiguity: if this new C syntax now allows out-of-order declarations, is the first `A` that visible from the outer scope, or is it intended to be the one defined later?",0.12878787878787878,c
15mqi66,jvl8hyh,Your idea sounds intriguing; perhaps just go with it and see how well it works.,0.30000000000000004,go
15mqi66,jvn0790,"ahhh ahahha, well that's a big problem in c++ code.",0.0,c++
15mqi66,jvlb2mb,"blocks are not a thing in global scope, they can exist in local scope only, and local scope is just parsed like a normal c compiler because there you can use a lexer hack (search in wikipedia) so fortunately this is not a problem.",0.09166666666666667,c
15mqi66,jvlb2mb,"about the `const A typedef B` is parsed correctly as well just because typedef is a type qualifier (or something) and is exactly like writing `const` (look at the c bnfs, which I followed at the 100%, except for the typedef-name, which I recognize using this trick and not the classical lexer hack used by major compilers, which doesn't allow out of order decls)  thanks for the reply, my question also was, if this works correctly with C will it work for C++ as well?",0.128125,c
15mqi66,jvlb2mb,"about the `const A typedef B` is parsed correctly as well just because typedef is a type qualifier (or something) and is exactly like writing `const` (look at the c bnfs, which I followed at the 100%, except for the typedef-name, which I recognize using this trick and not the classical lexer hack used by major compilers, which doesn't allow out of order decls)  thanks for the reply, my question also was, if this works correctly with C will it work for C++ as well?",0.128125,c++
15mqi66,jvlb2mb,"since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,c++
15mqi66,jvlb2mb,"since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,c
15mqi66,jvlb2mb,however the huge set of syntax feature C++ has more than C scares me,0.45000000000000007,c++
15mqi66,jvlb2mb,however the huge set of syntax feature C++ has more than C scares me,0.45000000000000007,c
15mqi66,jvm0tag,">since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,c++
15mqi66,jvm0tag,">since C++ is way more verbose than C maybe this thing of considering an identifier a typedef-name based on how many other type specifiers are already collected may not work, but if surprisingly it worked, wouldnt this be very interesting?",0.445,c
15mqi66,jvm0tag,"The first large C project I wrote, I used a thin syntax wrapper.",0.021428571428571425,c
15mqi66,jvm0tag,"It wrote out the proper C file `prog.c`, `prog.cl` containing declararations for local functions, and `prog.cx` for exported ones.",0.0,c
15mqi66,jvm0tag,"(As for C++, I doubt you will get far with that.",0.1,c++
15mqi66,jvr04ey,"thanks, this context free parser would be very hard to integrate in existing compilers imo, it would require to rewrite the front end, but for c++ compilers the frontend also works as symbol table which may be used in the following compilation steps.",0.055208333333333345,c++
15mqi66,jvr04ey,"this is just an idea recycled from an old project, it may work in c++ as well and if i have time and desire I will personally try to write a context free parser for c/c++ and open source it so that who wants can implement the backend.",0.13999999999999999,c++
15mqi66,jvmcil3,"Sorry, I don't know any C++ at all.",-0.5,c++
15mqi66,jvmcil3,Tweaked versions of both C and C++?,0.0,c
15mqi66,jvmcil3,Tweaked versions of both C and C++?,0.0,c++
15mqi66,jvmcil3,Or a new language that looks like C and/or C++?,0.13636363636363635,c
15mqi66,jvmcil3,Or a new language that looks like C and/or C++?,0.13636363636363635,c++
15mqi66,jvmf3ag,just a context-free parser for c++ (the previous c compiler was a c99 compiler with meta programming and other small features)  both able to process existing code.,-0.010416666666666657,c++
15mqi66,jvmf3ag,just a context-free parser for c++ (the previous c compiler was a c99 compiler with meta programming and other small features)  both able to process existing code.,-0.010416666666666657,c
15mqarm,jvi1o6y,"Maybe [Rebol](http://www.rebol.com/) and [Red](https://www.red-lang.org/) are interesting for you (they don't just replace {} with [] though, they are more like lisp).",0.5,lisp
15mqarm,jvi62k3,You'd be surprised how easy it is to get used to typing these when programming in languages descended from C.,0.26666666666666666,c
15mqarm,jvi4h9f,[REBOL](https://rebol.com/) is derived from Lisp and Logo and uses square brackets for blocks  [Red](https://red-lang.org/) is derived from REBOL and uses square brackets for blocks.,0.0,lisp
15mqarm,jvi4h9f,"[Tcl](https://en.wikipedia.org/wiki/Tcl) uses square brackets for command substitution, executing commands inside.",0.0,tcl
15mqarm,jvj1sck,My language has the convention that:  * Ordered groups of things (most compound statements; list and vector literals) go in square brackets.,0.5,go
15mqarm,jvj1sck,"Also lambdas/procs * Unordered groups of things (blocks of mutually-recursive definitions; map and set literals) go in curly brackets * Parentheses are still used for grouping function arguments, as well as overriding operator precedence.",0.0,go
15mqarm,jvke74y,"I *think* my syntax allows round brackets to be used for most things:      (a, b, c)           # a list     (a; b; c)           # a block     (a | b | c)         # if-then-else  Usually however the last two use keyword delimiters.",-0.13999999999999999,c
15mqarm,jvke74y,"Square brackets are used for indexing: `A[i]`, set: `[1..10, 13]` and dict: `[a:b, c:d]` constructors.",0.0,c
15mqarm,jvke74y,"Square brackets are used for indexing: `A[i]`, set: `[1..10, 13]` and dict: `[a:b, c:d]` constructors.",0.0,d
15mqarm,jvke74y,"I do very little with curly brackets, currently only for dict lookups: `D{k}`, other uses are up for grabs.",-0.12291666666666667,d
15mqarm,jvke74y,At one point they were used for block comments (following Pascal).,0.0,pascal
15mqarm,jvioscb,And in that situation I would go with familiarity over “what’s right”,0.2857142857142857,go
15mqarm,jvhy0o9,"Following this line of thought, isn't indentation-based syntax (like in Python) just as good, as it requires no brackets at all?",0.35,python
15mqarm,jvkhx64,"Objective-C used square brackets for method invocation and ""people"" hated it.",-0.9,objective-c
15mqarm,jvkhx64,"Its almost the solely reason why Swift was invented, so no they can write `hello.to(world);` sigh.",0.0,swift
15mqarm,jvkue4i,Scala 3 got rid of curly braces by introducing alternative syntax based on indentation.,0.0,scala
15mqarm,jvkue4i,With appropriate compiler validation to avoid the pitfalls known from python and other languages that also don't have curly braces.,0.1875,python
15mqarm,jvi41go,"Yep  Tcl also uses square brackets and might be the most popular language with the convention  Also my language dt went for square brackets, but in my case the design decision was more about avoiding collision with what shells will ""preprocess"" with (...) and {...} globbing and expansion semantics -- square brackets also have semantics there too, but are less likely to collide",0.2866666666666667,tcl
15mqarm,jvjwhci,"On the contrary, Python in particular uses brackets every now and then for grouping multi-line code.",0.16666666666666666,python
15mqarm,jvmivix,"Haskell also allows both styles, but Haskell has had that from the start, and most people use the off-side rule unless they're doing something like writing a short do-block on one line.",0.25,haskell
15mqarm,jvmivix,"I feel like ""allowing both styles"" is harmful if people don't just standardize on one style (as has happened in Haskell.)",0.0,haskell
15mqarm,jvmivix,"Scala simply can't do that because of its history - it started with curly brackets only, and as of Scala 3, the language designer is recommending that everyone should use the off-side rule instead.",0.0,scala
15mqarm,jvmivix,"The result is that both styles will be common, and Scala basically looks like 2 different languages now.",-0.15,scala
15mqarm,jvmivix,That's why he thought it was important enough to add it to Scala 3.,0.2,scala
15mqarm,jvoazlx,Haskell uses parentheses for these.,0.0,haskell
15mqarm,jvoazlx,"Importantly, `[-1]` is a valid lambda, while Haskell's `(-1)` is just a negative number.",0.05000000000000002,haskell
15mqarm,jvoazlx,"Lambdas can have pattern-matching with multiple alternatives:      area = [       Square[s]: s * s       Rectangle[w, h]: w * h       Circle[r]: pi * r ^ 2     ]  A case expression is the same syntax, but with `case a:` before the square-bracket block.",-0.08333333333333333,r
15mqarm,jvqt1p8,So I will go with familiarity for that question and focus on more impactful things (where unfamiliarly solutions can lead to new insights),0.3181818181818182,go
15mqarm,jvrc7jr,Wait what Haskell styles are you talking about?,0.0,haskell
15mqarm,jvr082h,"Also, square brackets go back to at least 1967 as they were used in Logo.",-0.15,go
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,swift
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,kotlin
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,scala
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,crystal
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,python
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,julia
15mnp7h,,"Languages analyzed: Swift, Kotlin, Scala, OCaml, Crystal, Python, Julia, C#  ### Named parameters  #### When defining a function, is it possible to opt out of named parameters?",0.0,c
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,julia
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,swift
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,python
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,scala
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,kotlin
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,crystal
15mnp7h,,"- Yes, named parameters are opt-in     - OCaml, Julia   - Yes, named parameters can be opted-out from     - Swift, Python   - No, all parameters are named parameters     - Scala, Kotlin, Crystal, C#  #### Is there a restriction on where named params can occur in the parameter list?",0.0,c
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,swift
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,julia
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,crystal
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,python
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,kotlin
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,scala
15mnp7h,,"- No     - Swift, OCaml   - Must appear after positional params     - Julia, Crystal (for named-only params), Python (for named-only params)   - n/a     - Kotlin, Scala, C#  #### When calling a function, is it mandatory to use the named parameters?",0.0,c
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,swift
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,julia
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,kotlin
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,scala
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,c
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,crystal
15mnp7h,,"`f(1, 2)` vs `f(x = 1, y = 2)`    - Yes     - Swift, Julia     - OCaml (in spirit) - names are required for partial function application, but not required if all params are supplied at once (but this still gives a compiler warning)   - No     - Kotlin, Scala, C#   - Sometimes (language has named-only params)     - Crystal, Python  #### (If it isn't mandatory to used the named params at call-site) Can you provide a param by position-only after a named param, when the param order is kept the same as the definition site?",-0.05,python
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,swift
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,julia
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,kotlin
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,scala
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,c
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,crystal
15mnp7h,,"`f(x = 1, 2)`    - n/a     - Swift, Julia     - OCaml (compiler interprets this as partial application, which requires the name)   - Yes     - Kotlin, Scala, C#   - No     - Crystal, Python  #### Can named parameters be called in a different order than the definition site?",-0.05,python
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,swift
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,scala
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,kotlin
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,julia
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,crystal
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,python
15mnp7h,,"`f(y = 2, x = 1)`    - No     - Swift   - Yes     - OCaml, Scala, Kotlin, Julia, Crystal, Python, C#  #### Can a child class re-name the named params of a parent's method via overriding?",0.0,c
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,scala
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,c
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,kotlin
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,python
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,swift
15mnp7h,,"- Yes (The child's static type determines which param names are valid)     - Scala, C#     - Kotlin (though the compiler at least gives a warning)     - Python (but replace ""static"" with ""dynamic"")   - No     - Swift - param names are part of the method name itself, so different param names do not constitute a valid override   - It's complicated     - Crystal - calling the method using a positional param or with the child's param name invokes the child's implementation.",0.033333333333333326,crystal
15mnp7h,,"Calling it with the parent's param name invokes the parent's implementation, essentially bypassing the ""override"" altogether   - n/a     - Julia, OCaml  ### Optional/default parameters  #### When declaring an optional param, are there restrictions on where it can be in the overall parameter list?",0.0,julia
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,kotlin
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,scala
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,swift
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,python
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,crystal
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,c
15mnp7h,,"- No (at call-site, params after an optional param must be named):     - Kotlin, Scala, Swift   - Optional params must be at the end of the param list:     - Python, Crystal, C#, Julia   - Optional params must NOT be at the end of the param list:     - OCaml (due to function call syntax being whitespace, not parentheses)  #### Are earlier parameters in scope for the default of an optional param?",-0.0625,julia
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,kotlin
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,crystal
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,julia
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,scala
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,python
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,swift
15mnp7h,,"`function f(x: Int, y: Int = x)`    - Yes:     - Kotlin, OCaml, Crystal, Julia   - Somewhat:     - Scala - methods can take multiple parameter lists; defaults can only refer to params in earlier lists, not their own list   - No:     - Python, Swift     - C# (default values can only be constants or values known to the compiler at compile-time)  #### For statically-typed languages, if an optional param is of a generic type, can its default value be of a concrete type?",0.10714285714285714,c
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,scala
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,crystal
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,swift
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,kotlin
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,c
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,python
15mnp7h,,"`function <T> f(x: T = 1)`    - Yes:     - Scala, Crystal   - Sometimes:     - Swift - only if there are no other params influencing the inference of the generic type, e.g., `func f<T>(x: T, y: T = 1)` is disallowed   - No:     - OCaml, Kotlin, C#   - n/a:     - Python, Julia  #### Does an optional parameter have to be a named parameter?",0.020833333333333332,julia
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,swift
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,julia
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,python
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,kotlin
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,scala
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,c
15mnp7h,,"- Yes:     - OCaml   - No:     - Swift, Julia, Python   - n/a (all parameters are named parameters):     - Kotlin, Scala, C#, Crystal",0.0,crystal
15mnp7h,jvkb1rx,"I'm thinking of something like this (types omitted):      fun example a=1 b=2 c d e...  which might be called as:      example b=3 4 5 6 7     //    a=1     //      b=3     //        c=4     //          d=5     //            e=[6, 7]",0.3,c
15mnp7h,jvkb1rx,"I'm thinking of something like this (types omitted):      fun example a=1 b=2 c d e...  which might be called as:      example b=3 4 5 6 7     //    a=1     //      b=3     //        c=4     //          d=5     //            e=[6, 7]",0.3,d
15mnp7h,jvqysk4,"SML doesn't have named parameters, but I can pass a record and I don't need to define its type beforehand:  ``` > fun f {a:int, b:int, c: string} = (a + b, c); val f = fn: {a: int, b: int, c: string} -> int * string > f {a=1, b=2, c=""""}; val it = (3, """"): int * string > f {b=1, a=2, c=""""}; val it = (3, """"): int * string ```",-0.54,c
15mnp7h,jvisokl,"Swift and Crystal also have this, but I don't know of any others.",0.0,swift
15mnp7h,jvisokl,"Swift and Crystal also have this, but I don't know of any others.",0.0,crystal
15mnp7h,jvlj3c4,"For example, in R, argument resolution is even more complex than this (they even allow partial name matching and ... arguments) and it's really complex and can lead to some unexpected footguns",-0.019999999999999997,r
15mnp7h,jvlit1d,"If you take defaults into account, things get really complicated and messy:      func baz(a:Int, b=0, c:Int, d=0) ...     // Left to right order:     baz(1, 2)    // a=1, b=2, c=[Missing], d=0     baz(1, 2, 3) // a=1, b=2, c=3, d=0      // Populating required args before optional args:     baz(1, 2)    // a=1, b=0, c=2, d=0     baz(1, 2, 3) // a=1, b=3 (?!",-0.08571428571428572,c
15m88y4,jvfzrg1,"Generally, the algorithm looks like this:  * Go through every function with a matching name * Check if the provided arguments are legal for that function * If there are zero matches, it's a compiler error (no such function) * If there is exactly one match, then you use that function * If there is more than one match, then you pick ""the most specific"" of that set of matches  For example, [here's how to implement the rules specified by Java](https://github.com/oracle/coherence/blob/212681af0cf9b637e0630250f39e829d5b27e0b6/prj/coherence-core/src/main/java/com/tangosol/dev/compiler/java/InvocationExpression.java#L292).",0.21428571428571427,go
15m88y4,jvfzrg1,"Generally, the algorithm looks like this:  * Go through every function with a matching name * Check if the provided arguments are legal for that function * If there are zero matches, it's a compiler error (no such function) * If there is exactly one match, then you use that function * If there is more than one match, then you pick ""the most specific"" of that set of matches  For example, [here's how to implement the rules specified by Java](https://github.com/oracle/coherence/blob/212681af0cf9b637e0630250f39e829d5b27e0b6/prj/coherence-core/src/main/java/com/tangosol/dev/compiler/java/InvocationExpression.java#L292).",0.21428571428571427,java
15m77p7,,For example python has a type Path in pathlib to represent path that takes a string in constructor and implement different operations on Path whereas Go has a lib that is directly manipulating strings.,0.05,python
15m77p7,,For example python has a type Path in pathlib to represent path that takes a string in constructor and implement different operations on Path whereas Go has a lib that is directly manipulating strings.,0.05,go
15m77p7,,"Looking at how popular and well known python is, I can only see go doing differently to try to do better, yet every time I think about it I can’t really understand.",0.26,python
15m77p7,,"Looking at how popular and well known python is, I can only see go doing differently to try to do better, yet every time I think about it I can’t really understand.",0.26,go
15m77p7,jvewpyv,"Python's `Path` overloads the `/` operator so you can write `path1 / path2 / 'foo.jpg'` instead of `pjoin(path1, path2, 'foo.jpg')`, and it'll do the right thing -- unlike `path1 + '/' + path2 + '/foo.jpg'`.",0.2857142857142857,python
15m77p7,jvewpyv,"Actually, in some languages, you could go even further and in a program or a library that copies files between machines, you could have types like `LocalPath` and `RemotePath`, and a function `copy(lp : LocalPath, rp : RemotePath)`, which will make it hard to mix up which paths are relevant for the local machine and which parts are valid remotely, as the compiler will complain otherwise.",0.0013888888888888885,go
15m77p7,jvesgpt,"Python had a library manipulating string paths forever, the `Path` class is a fairly recent introduction.",0.0,python
15m77p7,jvfrtw7,"You and other developers write many functions that take and return `string`s (Widgets), and much code that includes lines like `let widget: string = ...` and so forth.",0.19166666666666665,forth
15m77p7,jvfssus,"Even in dynamic languages like Python, you will either have your IDE point out obvious errors, or you'll at least get better runtime errors when you have a type mismatch instead of a wrongly formatted string.",-0.06,python
15m77p7,jvo7nou,"https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride  It goes on for a while, but it explains nicely why go's use of string is less a case of trying to do better and more a case of sloppy API design.",0.2033333333333333,go
15m77p7,jvewieq,"(Go, Zig, Pharo, many Lisps, AWK, C, etc) Then no, do not introduce abstractions for something that can already be expressed.",0.5,go
15m77p7,jvewieq,"(Go, Zig, Pharo, many Lisps, AWK, C, etc) Then no, do not introduce abstractions for something that can already be expressed.",0.5,c
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,python
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,rust
15m77p7,jvewieq,"(Python, Rust, Java, etc) Then yeah absolutely introduce a new object  There's a whole middle ground between those, and I'd say making good design choices is a skill that takes years of experience and deliberate practice to grow.",0.24727272727272726,java
15m77p7,jvetq22,"The first case is a ""plain alias"" ( Pascal example ):      type         path = string;  But, this allows to use the new type to be used as a the original.",0.1367694805194805,pascal
15m77p7,jvetq22,"C and Pascal allows to hide the new type:      type        path = forward class;  Another way is to use it indirectly thru a generic pointer:      type        path = pointer;  And, there are several type constructors ( don't confuse with O.O.",0.04545454545454545,c
15m77p7,jvetq22,"C and Pascal allows to hide the new type:      type        path = forward class;  Another way is to use it indirectly thru a generic pointer:      type        path = pointer;  And, there are several type constructors ( don't confuse with O.O.",0.04545454545454545,pascal
15m77p7,jvesz99,That’s not how Python works.,0.0,python
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,rust
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,haskell
15m77p7,jvmcioh,"IMHO you get the best of both words in a language like Rust or Haskell that supports opaque type aliases, but that wouldn't make sense in a language like Python.",1.0,python
15m77p7,jvf3fsh,"A little twist concerning type definitions: some languages, including C and even some Pascal-derivatives, differentiate between type *aliases* and type *names*.",-0.1875,c
15m77p7,jvgpk89,"**  Free Pascal does this, but it's a little ambiguous.",0.10625000000000001,pascal
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,pascal
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,python
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,c
15m77p7,jvgpk89,"**Although, I used a Pascal alike syntax, these ideas are intended for any other P.L., such as Python, C, Haskell...**",-0.0625,haskell
15m77p7,jvicg3r,"For the boxing part: Scala and Roc have opaque types, and C# has value types that incur no additional allocation.",0.0,scala
15m77p7,jvicg3r,"For the boxing part: Scala and Roc have opaque types, and C# has value types that incur no additional allocation.",0.0,c
15m77p7,jvicg3r,"It's like in C++: if you want to reference a value via an interface or base type, you gotta use pointers.",-0.8,c++
15m77p7,jvmc24h,"That's usually the best you can do unless you're using a language that allows arbitrary code execution at compile time, such as by using macros in Common Lisp or proc macros in Rust.",0.07,lisp
15m77p7,jvmc24h,"That's usually the best you can do unless you're using a language that allows arbitrary code execution at compile time, such as by using macros in Common Lisp or proc macros in Rust.",0.07,rust
15m77p7,jvkpaes,"JS for very small projects because it's absurdly hackable, and Scala for larger projects as a personal preference.",-0.20625,scala
15lilq6,,"One thing that comes to mind is, perhaps we can use a single-pass assembler to achieve PIC/PIE code through hard-coding the offsets to ELF/PE reloc table as we go.",0.0,go
15lilq6,,"I actually thank the Bejesus to everyone who [uploaded](https://freecomputerbooks.com/langAssemblyBooks.html) this seminal work because the scheme I was coming up with was basically some Rabin-Karp-like heuristic where I would hash all the 900+ odd mnemonics of x86-64 and then what I would have done is some sort of LL(k) parsing wherein every ident ending at "":"" would define a label, and every three-address-style code would be first lexed using C's regex.h library, and if, for example, ""\\w+\\s+\\%\\w+\\s\\%\\w+"" passed the lexical test, I would hash the leading \\w+ and then use a conditional branch for the opcode (ModR/M and the such and so).",0.020833333333333336,scheme
15lilq6,,"I actually thank the Bejesus to everyone who [uploaded](https://freecomputerbooks.com/langAssemblyBooks.html) this seminal work because the scheme I was coming up with was basically some Rabin-Karp-like heuristic where I would hash all the 900+ odd mnemonics of x86-64 and then what I would have done is some sort of LL(k) parsing wherein every ident ending at "":"" would define a label, and every three-address-style code would be first lexed using C's regex.h library, and if, for example, ""\\w+\\s+\\%\\w+\\s\\%\\w+"" passed the lexical test, I would hash the leading \\w+ and then use a conditional branch for the opcode (ModR/M and the such and so).",0.020833333333333336,c
15l4y21,,So I have three proposals and I'd like your help picking one:**1) mut params**  Like C#'s ref or Swift's inout.,0.0,c
15l4y21,,So I have three proposals and I'd like your help picking one:**1) mut params**  Like C#'s ref or Swift's inout.,0.0,swift
15l4y21,,Probably will go with another idea.. but not ready to share just yet.,-0.1,go
15l4y21,jvdyg5x,"I get it; every functional programming guru loves Agda, Haskell, and Emacs, but to have it so reliant on Emacs is absolutely absurd.",-0.5,haskell
15l4y21,jv9xr5e,"But it's no where near widely adopted(Sorry I didn't provide a better term than ""go far"").",0.15,go
15ktb2o,jv7nvec,"Cool idea, I'm actually working on something similar: a system where each function can be of different versions + there is a mechanism to update versions automatically (and highlight failures).",0.0875,cool
15ktb2o,jvgs6ol,"In general, I do agree that supporting multiple versions of a single dependency is necessary; and I love that Rust supports it.",0.12142857142857144,rust
15ktb2o,jv7ucp4,"Perl also supports backwards and forwards compatibility through language versions, though in a much more dynamic language.",0.25,perl
15ktb2o,jv9cixn,Isn't this what perl has been doing for a long time?,-0.05,perl
15ktb2o,jv9sgqa,I believe Go modules provide support for multiple major versions of a package to co-exist in an application.,0.03125,go
15ktb2o,jv8918q,"Raku, Perl 7, and JVM bytecode have ideas like this.",0.0,perl
15ktb2o,jv8918q,"There are some very adjacent ideas like Python and importing from `__future__`  But I haven't read the paper yet, I'm very interested in it!",0.2020833333333333,python
15ktb2o,jvaxt57,Perl has long had a version literal form that uses that format.,-0.05,perl
15ktb2o,jvaxt57,"Did you mean more flexible and less sophisticated than the approach/system in Go, Raku or VL?",0.13020833333333334,go
15ktb2o,jvbqehi,> There are some very adjacent ideas like Python and importing `from __future__`.,0.1,python
15ktb2o,jvbqehi,Python's `from __future__` is about *language* versions.,0.0,python
15ktb2o,jvbqehi,"It's a relatively simple thing, enabling one or more features planned for inclusion in a later (probably next) version of Python.",0.125,python
15ktb2o,jvbqehi,This is like `from __future__` in Python.,0.0,python
15ktb2o,jvemszq,I wasn't actually aware Go supported using different minor versions at the same time!,0.05,go
15ktb2o,jvemszq,">Did you mean more flexible and less sophisticated than the approach/system in Go, Raku or VL?",0.13020833333333334,go
15ktb2o,jvemszq,In comparison to the approach Go takes.,0.0,go
15kmsjl,jv935uv,"// Nice     struct Person {         string  Name         string  Email         int     Age     }      // Yuck     type person struct {         name std::string;         email std::string;         age int;     };  Also, the example with C's `int* x, y;` is misleading because the problem with C's syntax is the *grouping* of `int (*x), (y);`, not the fact that `int` comes before `x`.",0.6,c
15kmsjl,jv935uv,"It would definitely have been better if C grouped variable declarations as `(int*) (x), (y);` instead.",0.25,c
15kmsjl,jv809sr,The language used has an example (Go language) is inconsistent or verbose.,0.0,go
15kmsjl,jv809sr,"If the name is more important and has to come first, the rule should be followed for classes and functions as well, but Go uses the syntax `func bar()` and `type Foo struct{}`.",0.3833333333333333,go
15kmsjl,jvemuzw,"C doesn't do type grouping though, it does type _qualifiers_",0.0,c
15kmsjl,jve039d,I too am a type-endian and I did go with `x <type> = y`.,0.0,go
15kmsjl,jv6uvz3,My reasoning is that type is much more important than name so it should go first.,0.3833333333333333,go
15kmsjl,jvakueo,"You can think of pointer declaration in C as a destructuring declaration `int *t` means `*t` is an `int`, therefore `t` is a pointer.",0.0,c
15kmsjl,jv837sz,"Or you can be Haskell, where exponentiation is `^`, `**`, or `^^`, depending on precisely what types you want!",0.5,haskell
15kmsjl,jv6m2n7,[Rust RFC with examples](https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html),0.0,rust
15kmsjl,jva9ucr,Many languages that heavily relies on type inference can go further out on that limb because an IDE will be able to tell the programmer exactly what is being inferred.,0.21000000000000002,go
15kmsjl,jv9y0i1,"syntax is very IDE friendly because when you write `name.`,  the IDE can immediately help you to suggest all public members of that object, whereas in C for  example, the IDE cannot easily give you a list of functions that work on a particular data object.",0.23500000000000001,c
15kmsjl,jv9nwm4,"Like in Rust:      Struct { x: a, y: b } = bar(); Struct { x, y } = Struct { x: 5, y: 6 };  Or consider a language where Point has been defined as a 2-tuple:      Point (x,y) = triangle.A    // defining x and y",0.75,rust
15kmsjl,jv72f1g,"There are languages (like Go) that put the name first and don't use any punctuation to separate the type, but I find declarations easier to read with some kind of separator.",0.425,go
15kmsjl,jva40hx,"Well, that is a wart of Haskell that can’t express one concept via single operator, right?",0.10714285714285714,haskell
15kmsjl,jvazf8d,"I mean it originates with go, the language that deems anything hard to implement in the compiler ""unnecessary"".",-0.3347222222222223,go
15kmsjl,jvhduhy,"Meanwhile PHP:      function repeat(string $str, int $n): string  which I guess can be read as in English.",0.0,php
15kmsjl,jvc5izy,"There's not a good way to resolve this kind of trade-off within the programming language itself, so Haskell asks the user to make the choice instead.",0.125,haskell
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,pascal
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,ada
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,haskell
15kmsjl,jve1nth,"Pascal, Ada, ML, Haskell, Scala, and Nim would like a word.",0.0,scala
15k8zhf,,So one of the weird yet useful(kind of) features of Clojure is that it allows you to call a map even if it's not a function.,-0.5,clojure
15k8zhf,,We have this feature in Python as well.,0.0,python
15k8zhf,,I'm curious: how useful is this in a functional statically typed language like Haskell?,0.09999999999999999,haskell
15k8zhf,,So python's `__call__` and c++'s operator `()` reload all counts.,0.0,python
15k8zhf,,So python's `__call__` and c++'s operator `()` reload all counts.,0.0,c++
15k8zhf,jv4hv5x,"In C++ you can overload `operator()` on a class; objects of such classes are officially called ""callable objects"".",0.0,c++
15k8zhf,jv4hv5x,"When you think it down to assembly level, it simply doesn't really make sense to say ""call a non-function"".",0.014814814814814808,assembly
15k8zhf,jv4ggjg,>We have this feature in Python as well.,0.0,python
15k8zhf,jv4cs1z,I think you misunderstand Clojure.,0.0,clojure
15k8zhf,jv7jf7e,I have not seen this executed outside of a lisp where I thought it was a good decision for the language.,0.35,lisp
15k8zhf,jv89ld3,"It's a cool idea, and I like that it enables thinking of a Map as a (possibly mutable, possibly partial) function.",0.08333333333333333,cool
15k8zhf,jv89ld3,"Python ```python myDict = {0:""zero"", 1:""one"", 2:""two""} numberToName = myDict.get print(numberToName(1)) # prints 1 ```  but not e.g.",0.0,python
15k8zhf,jv89ld3,"JavaScript: ```js const myMap = new Map(Object.entries({0:""zero"", 1:""one"", 2:""two""})) const numberToName = myMap.get console.log(numberToName(1)) # TypeError since `this` is not defined  const correctNumberToName = myMap.get.bind(myMap) console.log(correctNumberToName(1)) ```  I would also be very careful to specify the semantic choices here, including: 1.",0.0031818181818181746,javascript
15k8zhf,jv48qm1,In Haskell map/fmap is a function that takes a function and another argument as inputs and outputs data with a similar structure.,0.0,haskell
15k8zhf,jv6z2jx,"This is technically true in Javascript, too.",0.35,javascript
15k8zhf,jv6z2jx,"Some languages (ruby, Visual Basic .NET) even have the opposite being true.",0.0875,ruby
15k8zhf,jv6z2jx,"Saying the name of a function is enough to call that function (without parameters), and that is also true in LISP, Haskell, and some other languages too.",0.075,lisp
15k8zhf,jv6z2jx,"Saying the name of a function is enough to call that function (without parameters), and that is also true in LISP, Haskell, and some other languages too.",0.075,haskell
15k8zhf,jv6z2jx,"(In fact, in LISP, a function is exactly the same as just the first item in a list, so technically you do it all the time in Common LISP)  As stated, I suppose Haskell has the same thing.",0.03333333333333333,lisp
15k8zhf,jv6z2jx,"(In fact, in LISP, a function is exactly the same as just the first item in a list, so technically you do it all the time in Common LISP)  As stated, I suppose Haskell has the same thing.",0.03333333333333333,haskell
15k8zhf,jv6z2jx,"I would call that ""turning an object into a function"", a la Javascript.",0.0,javascript
15k8zhf,jv9a1or,So python's \_\_call\_\_ and c++'s operator () reload all counts.,0.0,python
15k8zhf,jv9a1or,So python's \_\_call\_\_ and c++'s operator () reload all counts.,0.0,c++
15k8zhf,jv4nhvp,In clojure it's mostly a sugar.,0.5,clojure
15k8zhf,jv63nky,"In Clojure, maps are a first-class data type, alongside lists and vectors (another Clojure-specific data type).",0.0,clojure
15k8zhf,jv4db6n,"In Clojure, the application `(m k)` where `m` is a Map is effectively `lookup k m` in Haskell.",0.6,clojure
15k8zhf,jv4db6n,"In Clojure, the application `(m k)` where `m` is a Map is effectively `lookup k m` in Haskell.",0.6,haskell
15k8zhf,jv4db6n,"Interestingly, this coercion does not make sense in Haskell because `(->)` is a concrete type constructor provably not equal to anything starting with `Map`.",0.1625,haskell
15k8zhf,jv7pafd,I disagree with your description of how things work in Lisp.,0.0,lisp
15k8zhf,jv7pafd,"It's easy to illustrate the difference in a Lisp-1 language like Scheme (or Clojure):      (define (hello-world)       (display ""hello world"")       (newline))          (define (call-twice f)       (f) (f))          (call-twice hello-world)  This last line mentions a 0-argument function without calling it.",-0.10555555555555556,scheme
15k8zhf,jv7pafd,"It's easy to illustrate the difference in a Lisp-1 language like Scheme (or Clojure):      (define (hello-world)       (display ""hello world"")       (newline))          (define (call-twice f)       (f) (f))          (call-twice hello-world)  This last line mentions a 0-argument function without calling it.",-0.10555555555555556,clojure
15k8zhf,jv7pafd,"Inside call-twice, that function is called twice, so the output is:      hello world     hello world  I also wouldn't describe Haskell as calling a function by mentioning it, because nothing is executed; a zero-argument function is the same thing as a constant.",0.0,haskell
15k8zhf,jv4vyf8,Quite a big part of lisp is that data structures can be represented by lists and functions alone.,0.0,lisp
15k8zhf,jv4vyf8,Even if Clojure’s implementation has map as a keyword instead of a function (which I’m not sure is true) then it makes sense to make it mirror the syntax of every other lisp data structure.,-0.00833333333333334,clojure
15k8zhf,jv4vyf8,Even if Clojure’s implementation has map as a keyword instead of a function (which I’m not sure is true) then it makes sense to make it mirror the syntax of every other lisp data structure.,-0.00833333333333334,lisp
15k8zhf,jv5s9zn,The real question would be why is Clojure handling map functions differently?,0.1,clojure
15k8zhf,jvbiu8h,I admit my description was a bit poor about LISP.,-0.4,lisp
15k8zhf,jvbiu8h,">I also wouldn't describe Haskell as calling a function by mentioning it, because nothing is executed; a zero-argument function is the same thing as a constant.",0.0,haskell
15k8zhf,jvbiu8h,"But if we go that route, all Haskell really does is manipulate lists by continually expanding them.",0.2,go
15k8zhf,jvbiu8h,"But if we go that route, all Haskell really does is manipulate lists by continually expanding them.",0.2,haskell
15k8zhf,jvbiu8h,That's true of LISP as well.,0.35,lisp
15k8zhf,jvbiu8h,"(Technically a Cons cell)  But in terms of the initial question, ""calling a function"" means something different in Haskell.",0.0,haskell
15k8zhf,jvbiu8h,"Using the definition of sequence manipulations (which is an oversimplification, in truth), _everything_ in Haskell is a function.",0.0,haskell
15k8zhf,jv4oite,Probably it's just people are not used to the terms used in clojure.,0.0,clojure
15k79uw,,"Hello, I'm trying to design a haskell like functional language.",0.0,haskell
15k79uw,jv4hj8o,"This includes Haskell, and there have been [multiple attempts](https://hackage.haskell.org/packages/#cat:Prelude) to provide an alternative prelude based on knowledge learned since Haskell's standard prelude shipped.",0.0,haskell
15k79uw,jv4hj8o,"Another example is D, which originally shipped with quite a poor standard library and an alternative, Tango gained popularity.",-0.00833333333333334,d
15k79uw,jv4hj8o,"You should be able to leverage these directly from your language without having to use an FFI to a C intrinsics library, and without expecting the compiler to do auto-vectorization magic.",0.3666666666666667,c
15k79uw,jv4hj8o,"For numerics, I would recommend looking at the numerical tower of Scheme.",0.0,scheme
15k79uw,jv4hj8o,[Kawa](https://www.gnu.org/software/kawa/Numerical-types.html) Scheme has a good implementation.,0.7,scheme
15k79uw,jv5x5fj,I wrote about some [specific typeclasses and their issues](https://soc.me/languages/equality-and-identity-part1) in popular languages a while ago (a later chapter talks about Haskell).,0.19999999999999998,haskell
15k79uw,jv5fs0m,>Kawa Scheme has a good implementation.,0.7,scheme
15jpmxe,jv1ezjb,"I feel like this is a well reasoned, but incomplete take on ocaml vs rust.",0.0,rust
15jpmxe,jv1ezjb,"(It mentions the ecosystem being a weakness on the ocaml side, but it doesn't talk about rust's ecosystem.)",0.0,rust
15jpmxe,jv1q19f,"The Rust version of CPS conversion is misusing `RefCell`; the equivalent of `'t ref` is `&RefCell<T>`, not `RefCell<T>`.",0.0,rust
15jpmxe,jv1q19f,"The latter is just a `T`, by value, which means the Rust implementation is passing a `u32` around by value and never actually incrementing it.",0.0,rust
15jpmxe,jv1q19f,"---  All-in-all, Rust is definitely more verbose - but I think it's a shame to not use the one big correctness-checker that Rust has which is missing from OCaml, which is the borrow checker.",0.09999999999999999,rust
15jpmxe,jv1gael,"For me personally the biggest issue in Rust has been performance, which might be surprising, because the usual meme is to rewrite things in Rust for speed.",0.15,rust
15jpmxe,jv1gael,What I've seen in Rust is lacking a lot both in convenience and performance.,0.0,rust
15jpmxe,jv1mahu,"As it is, it reads like it's going to be a critique of this subreddit, but the actual content is about comparing Rust and OCaml as language implementation platforms",0.0,rust
15jpmxe,jv6i9j1,The biggest change is the handling of recursion since I don't have recursive definitions and had to encode it into a function (`go`) that takes itself as an argument.,0.0,go
15jpmxe,jv1int0,"Most of the times, you do not need to implement the whole thing; e.g., if you generate C code, you just need to represent only the constructions you use, not the whole C language.",0.22499999999999998,c
15jpmxe,jv1spim,"For every additional safety guarantee it may confer you in corner cases (mostly low level imperative code), just using immutable data structures, mostly functional code, and advanced types (like GADTs, which BTW are a correctness checking system that's totally missing in Rust) instead is likely to take you much further towards formal correctness, with much less effort.",0.07619047619047618,rust
15jpmxe,jvgr89t,Seeing all those allocations in the Rust code made me cringe :x,0.0,rust
15jpmxe,jv1lnyg,"If you want to write the next C++ that would be a massive undertaking, especially without institutional support.",0.0,c++
15jpmxe,jvbkyqk,"Sure, but that doesn't apply to rust.",0.5,rust
15jpmxe,jv1w7bk,"---  I'm not saying those other features aren't great; I really wish Rust had something like GADTs, but we should all try to learn from what each language does best.",0.46875,rust
15jpmxe,jv2mm34,"In Rust, options are:  - Use Rc.",0.0,rust
15jpmxe,jv2mm34,"Koka has one of the most heavily optimized pure reference counting implementations, and I would be surprised if Rust Rc was faster than Koka.",0.15357142857142855,rust
15jpmxe,jv2mm34,"Moreover, Rust arenas are not as fast as heap allocation in OCaml/GHC, or other mature bump-pointer'd languages, because those compilers specifically optimize allocations on the machine code level and Rust doesn't.",0.05833333333333334,rust
15jpmxe,jv2mm34,- Use a garbage collector in Rust.,0.0,rust
15jpmxe,jv4rf1z,"> Moreover, Rust arenas are not as fast as heap allocation in OCaml/GHC, or other mature bump-pointer'd languages, because those compilers specifically optimize allocations on the machine code level and Rust doesn't.",0.05833333333333334,rust
15jpmxe,jv4rf1z,You can implement a bump allocating arena in Rust just fine.,0.4166666666666667,rust
15jpmxe,jv4rf1z,"The only difference between GHC's bump allocator will be that GHC stores the allocation and limit pointers in registers, in Rust you'll have to load them from a heap address.",0.0,rust
15jpmxe,jv4rf1z,"I have a compiler project in Rust (in progress, not yet released) where I used to use bump allocating arenas/pools for different kinds of objects.",0.0,rust
15jpmxe,jv5cpd3,"Cool, looking forward to reading it.",0.35,cool
15jnq1p,,"Risor is a new language that compiles to bytecode and runs in a lightweight virtual machine, all written in Go.",0.13636363636363635,go
15jnq1p,,The syntax feels like a blend of Go and Python.,0.0,go
15jnq1p,,The syntax feels like a blend of Go and Python.,0.0,python
15jnq1p,,It interoperates with Go types and leverages the Go standard library functions so Go programmers will feel right at home.,0.14285714285714285,go
15jnq1p,,"Looking ahead, the more interesting aspects of the project are that Go libraries like the [AWS SDK and others are compiled-in](https://risor.io/examples/aws) to the Risor CLI.",0.5,go
15jnq1p,jv5dstk,"Functions are objects so you could do this if you wanted:  ``` >>> join := strings.join >>> to_upper := strings.to_upper >>> [""foo"", ""bar""] | join("" "") | to_upper ""FOO BAR"" ```  There are also string methods available, e.g:  ``` >>> ""|"".join([""a"", ""b"", ""c""]).to_upper() ""A|B|C"" ```",0.4,c
15jnq1p,jv7p7ho,Do you have an import or include statement like javascript or python?,0.0,javascript
15jnq1p,jv7p7ho,Do you have an import or include statement like javascript or python?,0.0,python
15jnq1p,jv9l8u0,Even go which is a language famed for it's straightjacketing of programmers let's you do this.,0.0,go
15jn1gv,,I work in a large Python codebase.,0.21428571428571427,python
15jn1gv,jv0vprs,"Well, Python does haven an `Optional[T]` type annotation, which is an alias for the union `T | None`.",0.0,python
15jn1gv,jv0vzn0,"Python has type annotations, and its type system includes 'Any' and 'Optional[T]' (which is 'T | None').",0.0,python
15jn1gv,jv0y1bi,"custom Singletons to represent the absent of a value) is actually quite common in Python if a parameter should accept `None`, but it's absent should be treated differently again (the stdlib does that in quite a few places).",-0.125,python
15jn1gv,jv0y1bi,The better solution is to use Python with type hints and static type checkers.,0.5,python
15jn1gv,jv40kk2,"For example, consider this Python code:      if randomChance():        flag = True          print(flag)  The print() may raise an error because \`flag\` is not guaranteed to be assigned.",0.35,python
15jn1gv,jv40kk2,"Now unlike Python, statically typed languages usually have block scope, but let's assume we keep Python style scope.",-0.25,python
15jn1gv,jv40kk2,"We may implement a type system where uncertain variable assignments are automatically of a nullable type:      if randomChance():        flag = True          # at this point, flag is of type `Bool?`, because the assignment is uncertain     # so we are *forced* by the compiler to do this:          if flag is not None:        print(flag)  In a language like C# with block scope, we would be forced to do it like this:      bool flag; // or `var flag = false;`          if (randomChance()) {        flag = true;     }          ...",-0.06000000000000003,c
15jn1gv,jv40kk2,So this is an example how you could keep writing Python style code while still having the safety of forced null checks.,-0.30000000000000004,python
15jn1gv,jv9e8sw,And Python can only tell you the latter.,0.0,python
15jn1gv,jv9e8sw,"I also work in a large Python code-base for the day-job, and I can tell you that I've gotten a reputation for sprinkling assertions in lots of places.",0.21428571428571427,python
15jn1gv,jv9e8sw,"This tends to catch problems a lot closer to their source, which conveniently makes me go faster.",0.0,go
15jn1gv,jv9e8sw,A strong type system says that a well-typed program cannot go wrong (i.e.,-0.033333333333333354,go
15jn1gv,jv9e8sw,"crash, etc) but at some point either you make compromises or you go full dependently-typed kool-aid monster.",0.35,go
15jn1gv,jv9e8sw,I will say that frustration with Python is part of the motivation behind my language.,-0.4,python
15jn1gv,jv3c50d,"If I remember correctly python doesn't type check, so annotation is just a way to make it clear to programmers and IDE what types should be available right?",0.2619047619047619,python
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,java
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,c
15jn1gv,jv19h2y,"Java, C#, Python, and Golang had all started with an overly simplistic static type system and have suffered as a result.",0.0,python
15jn1gv,jv4o692,This is how you end up with type systems like C or pre-generics Go.,0.0,c
15jn1gv,jv4o692,This is how you end up with type systems like C or pre-generics Go.,0.0,go
15jn1gv,jv4o692,"I think it's useful to look at TypeScript in this context, since it tries to provide static types that can actually express typical JavaScript patterns.",0.10666666666666666,typescript
15jn1gv,jv4o692,"I think it's useful to look at TypeScript in this context, since it tries to provide static types that can actually express typical JavaScript patterns.",0.10666666666666666,javascript
15jn1gv,jv4o692,"This might even be enough for a scripting language (think Perl 4, Bash, …).",0.0,perl
15jn1gv,jv4o692,"This might even be enough for a scripting language (think Perl 4, Bash, …).",0.0,bash
15jn1gv,jv4mn8w,"This is similar to how TypeScript works, especially when JSDoc type annotations are used so that no compilation step is necessary before execution.",0.0,typescript
15jn1gv,jv3m6a1,"My point is that it's completely trivial in the world of dynamic languages and expected within the realm of normal Python programs, to the point of making the limited system you suggested kind of useless.",0.025510204081632657,python
15jn1gv,jv3uu88,C# is gradually typed FYI.,0.0,c
15jn1gv,jv4m7il,One of the very nice features of C# `dynamic` is that crossing the dynamic–static boundary is safe.,0.4266666666666667,c
15jn1gv,jv4m7il,"In Python or Typescript the type annotations are just annotations, and have little or no interaction with runtime behaviour.",-0.1875,python
15jn1gv,jv4m7il,"In Python or Typescript the type annotations are just annotations, and have little or no interaction with runtime behaviour.",-0.1875,typescript
15jn1gv,jv4m7il,"In contrast, C# would do a checked cast at the point of the assignment, possibly raising an exception.",0.0,c
15jn1gv,jv801vd,> One of the very nice features of C# dynamic is that crossing the dynamic–static boundary is safe.,0.4266666666666667,c
15jn1gv,jv801vd,"> In Python or Typescript ... You can assign an int to a str variable by going through an Any type, and the language allows that.",0.0,python
15jn1gv,jv801vd,"> In Python or Typescript ... You can assign an int to a str variable by going through an Any type, and the language allows that.",0.0,typescript
15jn1gv,jv801vd,"In contrast, C# would do a checked cast at the point of the assignment, possibly raising an exception.",0.0,c
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,python
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,typescript
15jn1gv,jv801vd,"(""Calling old(Str) will never work with declared signature (Int $age)"")  Unlike PL's like Python and TypeScript, the static typing aspects of Raku's gradual typing was and have remained safe from the get go, rather than having an ultimately unsafe gradual typing system retrofitted atop an older PL.",0.2916666666666667,go
15jn1gv,jv801vd,Aiui early C# assumed fairly tight explicit static typing would be the norm for devs who used it.,0.14047619047619048,c
15jn1gv,jv9p69k,"Very good point about Raku – whereas most popular gradually typed PLs had a static type system grafted onto an existing dynamic language, a couple of PLs like Julia and Raku were *designed* with gradual typing in mind, which helps with actually achieving safety.",0.4183333333333333,julia
15jn1gv,jv9p69k,"I perceive it as a design failure that the TypeScript compiler can transpile without typechecking, but it's understandable due to performance constraints.",-0.22083333333333335,typescript
15jn1gv,jv9p69k,Even the Deno runtime with its built-in TS support doesn't typecheck by default…  I think C#'s `dynamic` must also be seen in the context of the .NET Common Language Runtime.,-0.15,c
15jn1gv,jv9p69k,"And once that functionality is implemented in the CLR, it makes sense to expose it in the C# language for interoperability purposes, even though it would be rare to use this feature.",0.3,c
15jjcyv,jv0vi15,LISP did that as homoiconic representation of code.,0.0,lisp
15jjcyv,jv23d02,"There're lot of use cases of indirection, just mention one: *vtable* (see C++ virtual methods).",0.0,c++
15j19pa,juzewfr,Feels like Bram is reinventing some parts of Lisp.,0.0,lisp
15j19pa,juxloj6,Nowadays I’d also push back on the compile/build time distinction (should be seamless).,0.05,d
15j19pa,juxufxd,"It encourages ad-hoc build systems and customization and built time injections are recipes for technical debt (see Java’s build system problem, there’s a billion ways to run it with gradlew, maven, etccc)",0.0,java
15i92a9,juu9eff,(Nim is explicitly inspired by Pascal afaik) It also raises a runtime exception when using incorrect fields.,0.0,pascal
15i92a9,jutgnlz,"You could still have `obj.field` with sum types   This is how Oils does it with [Zephyr ASDL](https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL) --  sum  types, but no pattern matching (because neither Python or C++ support it, at least the versions we use).",-0.3,python
15i92a9,jutgnlz,"You could still have `obj.field` with sum types   This is how Oils does it with [Zephyr ASDL](https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL) --  sum  types, but no pattern matching (because neither Python or C++ support it, at least the versions we use).",-0.3,c++
15i92a9,jutgnlz,"The pattern is  1. a switch statement on the runtime tag 1. a static cast to the subtype 1. obj.field access, which you say you wanted   There are some syntactic hacks in Python (because it doesn't have switch, but C++ does!",0.625,python
15i92a9,jutgnlz,"The pattern is  1. a switch statement on the runtime tag 1. a static cast to the subtype 1. obj.field access, which you say you wanted   There are some syntactic hacks in Python (because it doesn't have switch, but C++ does!",0.625,c++
15i92a9,jutgnlz,It's very similar but I like switch/case here  I actually think sum types go very well with imperative languages!,0.08333333333333333,go
15i92a9,juv0ers,I think Clojure also embraces that point of view.,0.0,clojure
15i92a9,juvevq5,"Long story short, I ended up with a very similar system to typescript's anonymous structural records and untagged unions along with a kind of smooshed together construct which does both conditional branching and pattern matching at the same time.",0.10999999999999999,typescript
15i92a9,juw5nwn,"So:      rec Weapon       var name String       var bonus Int     case MeleeWeapon       var damage Int     case RangedWeapon       var minRange Int       var maxRange Int     end  is, AIUI, roughly equivalent to the following using ordinary structs and unions, using C syntax as most are familiar with that:      typedef long long Int;  // 64-bit int          typedef struct {         Int tag;            // discriminating tag         char* name;         Int bonus;         union {             Int damage;             struct {                 Int minRange;                 Int maxRange;             };         };     } Weapon;  I chose a 64-bit `Int` to avoid alignment and padding issues.",0.06071428571428572,c
15i92a9,juw5nwn,"Then that line might be equivalent to this C:      enum {MeleePeapon, RangedWeapon};   // assumed global; see below          if (weapon.tag == RangeWeapon &&  With accesses to the variant parts such as `x = weapon.damage` further guarded like this:      x = (weapon.tag == MeleeWeapon ?",-0.06999999999999999,c
15i92a9,jusznyy,"For example:  ``` rust enum HasCommonFields {   Rectangle(height, widht),   Squate(height),   }  impl HasCommonFields {    fn height() //needs boilerplate } ```  But doing a projection:  ``` rust enum Shape {   Rectangle(height, widht),   Square(height),   }  let shape = Shape::...  shape.height //free to access directly, this is `SELECT height`  //But the others need matching match shape {   Rectangle => shape.with   Square } ```",0.0,rust
15i92a9,juyst1r,"Plus various variants of good old LISP S-expressions, including Ron Rivest's Canonical S-Exp format.",0.26666666666666666,lisp
15i92a9,jv77pzb,"I often get issues with the analogous ""when"" statements in Kotlin, because to check for a type I need to add the ""is"" modifier"".",0.0,kotlin
15i92a9,juyu9sv,"Some Pascals and Ada have the sort of variant record feature I describe here, but as far as I know, languages that have a thing they call ""sum type"" don't have case-independent fields on it.",0.1,ada
15i92a9,juzzh44,"In Haskell and ML you can duplicate a member over every case to make it *total*, whilst also having *partial* members.",-0.05,haskell
15i92a9,juvco8i,"UFCS definitely makes the whole thing go down easier, even if I still don't love what feels like leaving type safety on the table.",0.1361111111111111,go
15i92a9,juvh0b3,This is the same behavior as Haskell.,0.0,haskell
15i92a9,juvh0b3,"Record fields in Haskell behave like plain functions, so you can call a partial field on a value which is of a case which does not contain this field - the compiler will not complain because they're the correct *type*.",-0.15714285714285714,haskell
15i92a9,juwwj3n,And Ada [also has them](https://learn.adacore.com/courses/intro-to-ada/chapters/more_about_records.html#variant-records).,0.0,ada
15i92a9,juwwj3n,"It is not a ""dead end"" feature, the C descendents are just very good at ignoring useful features for decades.",0.4366666666666667,c
15i92a9,juwwj3n,"But just look outside of the C world, and there are treasures everywhere (yes, ML is not the only source of good things).",0.2333333333333333,c
15i92a9,jutqo5e,"The type relationship is the same  (Multiple inheritance also turns into something Rust doesn't have --  variants as first class types, without wrapping)  Why do you say subtyping adds a lot of complexity?",0.08333333333333333,rust
15i92a9,juvpkog,A potential fix for this in Haskell is to replace the sum type with a GADT and separate the record fields into their own types.,0.3,haskell
15i92a9,juud6j1,Stuff like:      var x = c ?,0.0,c
15hwgbo,,Currently there are working iterators for:   * Array * Tuple * String * Number Range (like in Python)  # Problem  I'm not sure how to handle situations in which new keys are added or removed from the map.,-0.03787878787878788,python
15hwgbo,,"For now the Litan map uses std::map from the C++ standard library as an underlying container, which has some problems with iterator invalidation.",0.0,c++
15hwgbo,,"(1, A)     [VM-Error] Unhandled exception: Invalidated map iterator  # Options  There are a few other options I thought about:  * Just accept UB from C++ (Not an option) * No map iterators (Not an option) * Just stop iteration and exit loop (Very soft error handling and hard to find error.",-0.12166666666666667,c++
15hwgbo,,"I don't like that) * The current behavior (I think python does it similarly, if I remember correctly) * Another custom map implementation to remove the problem (A backup plan for now)  # Questions  1.",0.0,python
15hwgbo,jurjpb8,"C++ solves this problem via the `erase` function on the map; it doesn't work with range-based for loops like the ones you are implementing here, because it requires updating the iterator directly.",0.1,c++
15hwgbo,jur6vfq,I quite like the way Java's concurrent collections (e.g.,0.0,java
15hwgbo,jur6vfq,"Another trick from Java's iterators is that you can remove the last returned element through the Iterator interface instead of on the Collection, and this allows you to continue iterating safely.",0.25,java
15hwgbo,jusjj3h,"If your backing language is C++, then consider `std::unordered_map` (hash map), and think about the behavior:   - Should insertion or removal cause an exception?",0.0,c++
15hwgbo,jusjj3h,"---  On another note, C++ doesn't make the distinction, but it's actually pretty important: there's a difference between an _iterator_ and a _cursor_.",0.325,c++
15hwgbo,jusjj3h,"The Rust library offers _some_ cursors for a few collections [see, for example, `LinkedList`](https://doc.rust-lang.org/std/collections/linked_list/struct.Cursor.html).",-0.05,rust
15hwgbo,jusjj3h,"On the other hand, a cursor is more heavy-weight, but offers more freedom: the user gets to choose where to go -- for example, in a tree, the user chooses to go up/down left/down right -- and can modify the collection (erase, notably) _and_ continue browsing.",0.29345238095238096,go
15hwgbo,jushte0,"You're in good hands: Java behaves similarly, and throws a `ConcurrentModificationException` in such a case.",0.2333333333333333,java
15hwgbo,juymb3h,This is what C++ does with \`erase\` as someone else was pointing out.,0.0,c++
15hwgbo,jv1xrgk,No:     Use immutable data structure like clojure ```,0.0,clojure
15hwgbo,juqtyhy,C++'s std::map has no way to get n-th pair without starting from the begin again and again which would result in O(n\^2) time complexity for the for loop in case of a map.,0.0,c++
15hwgbo,jutefzx,I actually think this is the way to go.,0.0,go
15hwgbo,jutefzx,---  Regarding the Rust cursors.,0.0,rust
15hwgbo,jutefzx,I'm not really familiar with Rust and will need do some reading about that topic.,-0.1875,rust
15hwgbo,juqz268,"Of course, this is all under the assumption of single threading…  Btw Java also throws an exception if the collection was modified.",-0.07142857142857142,java
15hwgbo,juvrrg9,"You can think of a Rust Cursor as a wrapper around a pointer to an element -- quite like C++ forward/bidirectional/random iterators -- really, where each cursor is specialized for the container type it can ""browse"".",0.2,rust
15hwgbo,juvrrg9,"You can think of a Rust Cursor as a wrapper around a pointer to an element -- quite like C++ forward/bidirectional/random iterators -- really, where each cursor is specialized for the container type it can ""browse"".",0.2,c++
15hi5ro,,"(It simply makes sense to have those in a logic language and-honestly, Prolog sucks.",-0.15,prolog
15hi5ro,,"For comparison, look at how many fine prints you got to read to even use the Prolog _forall_.",0.45833333333333337,prolog
15hi5ro,,I think SML is cool too and its design is good I guess.,0.5249999999999999,cool
15hi5ro,jup7xdz,"You can do this more generally in Python with the `all` and `any` built-in functions in conjunction with generator expressions (to ensure that we don't compute more `odd`s than necessary):      >>> def odd(x): return x % 2 == 1     ...      >>> all(odd(x) for x in range(1, 6))     False     >>> any(odd(x) for x in range(1, 6))     True  There's also an interesting idea in probabilistic programming, where `some` corresponds to rejection sampling.",0.21428571428571427,python
15hi5ro,juqqd8x,"Prolog:      for(_, []) :- true.",0.35,prolog
15hi5ro,juuksao,"Like Java's `findAny`, then?",0.0,java
15hi5ro,juqln1n,"Maybe `for` plays a special role in ***logical languages***, like Prolog.",0.3035714285714286,prolog
15hi5ro,juqln1n,"Would you ever want to print *""some""* element of a collection and how would you do that in C#?",0.0,c
15hi5ro,juqln1n,In Haskell it's called `find`.,0.0,haskell
15hi5ro,jut7wjw,"Python) that seemingly has _all_, _filter_ and _for_ in multiple forms (and syntaxes); there is perhaps some design points gained.",0.0,python
15hi5ro,jutihui,Disclaimer: my language doesn't claim to _supersede_ Prolog.,0.0,prolog
15hi5ro,jutihui,"However, this is not meant to imply it's _impossible_ to make something similar in Prolog.",-0.3333333333333333,prolog
15hi5ro,jutihui,Edit: this may be a good opportunity to mention [NU-Prolog](https://prnt.sc/xwdAyuqcYfGj) (from NU-Prolog manual) as an attempt to add _some/all_ as a construct in LP languages in a different way than how Prolog does it.,0.35,prolog
15hi5ro,juveswd,"In Ruby, for example, all iteration is done via methods taking blocks, and syntactic looping constructs while exist, are almost never used.",0.0,ruby
15hi5ro,juveswd,"And in Rust, `for x in i {...}` is 90% pure sugar for `i.for_each(|x| {...})`.",0.21428571428571427,rust
15gz8rb,,I'm considering creating a compiler for a high-level programming language and wonder if Go would be a good fit for writing it.,0.55,go
15gz8rb,,"I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,haskell
15gz8rb,,"I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,rust
15gz8rb,,"Go wasn't that frequently mentioned, although, from what I know, if the language is compiled rather than interpreted, the choice of a programming language shouldn't matter as long as the compiler's target is native code.",0.025,go
15gz8rb,,"I know Go is self-hosted and, therefore, written in itself.",0.0,go
15gz8rb,,My language would have a GC: Would Go already having a GC complicate development?,0.0,go
15gz8rb,,"If so, would Rust be a good option?",0.7,rust
15gz8rb,,"In addition, I know Rust, for example, has tools for building languages, such as `inkwell` (LLVM bindings) and `cranelift`.",0.0,rust
15gz8rb,,"To my knowledge, Go has no such tools.",0.0,go
15gz8rb,junesc0,"Ive built interpreters in Go before, i didnt realize how unergonomic it was until I built the same interpreter in OCaml which has algebraic data types and pattern matching.",0.0,go
15gz8rb,junesc0,"I would look into a language like that I.e rust, oCaml, haskell, etc etc",0.0,rust
15gz8rb,junesc0,"I would look into a language like that I.e rust, oCaml, haskell, etc etc",0.0,haskell
15gz8rb,jum3hqn,"There's a book _just_ about writing a compiler in Go (also, AFAIK, Go is self-hosted)  https://compilerbook.com/  So, take your conclusions",0.0,go
15gz8rb,jumd0pb,"I write compilers in Go, it's a decent language for that, but you will miss a stronger type system and sum types.",0.16666666666666666,go
15gz8rb,jumd0pb,"I program most things from scratch, so i don't miss the lack of interop between say, Go and LLVM.",0.5,go
15gz8rb,jumd0pb,"But you can always generate .llir files and ask LLVM to compile it for you, i do something similar by generating assembly files and asking FASM to assemble it for me.",0.0,assembly
15gz8rb,jumd0pb,"Go's GC is rarely a problem for a short lived program like a compiler, unless you plan to compile millions of lines of code, i think GCed languages work wonderfully.",0.43333333333333335,go
15gz8rb,jumd0pb,"Besides, Go's profiling tool offsets most downsides of using GC, after a while, you program knowing exactly what you shouldn't do and performance stops being a problem.",0.375,go
15gz8rb,jum4ax2,>I'm considering creating a compiler for a high-level programming language and wonder if Go would be a good fit for writing it.,0.55,go
15gz8rb,jum4ax2,"If you know Go, then Go will be a good fit for writing a compiler and/or interpreter in.",0.55,go
15gz8rb,jum4ax2,>My language would have a GC: Would Go already having a GC complicate development?,0.0,go
15gz8rb,jum4ax2,>would Rust be a good option?,0.7,rust
15gz8rb,jum4ax2,"If you know Rust, then Rust will be a good fit for writing a compiler and/or interpreter in.",0.55,rust
15gz8rb,jum4ax2,">I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,haskell
15gz8rb,jum4ax2,">I have looked around similar posts on this subreddit and saw various languages mentioned (e.g., OCaml, Haskell, Rust, C/C++, etc.).",0.0,rust
15gz8rb,jum4ax2,Go wasn't that frequently mentioned  This is true.,0.22499999999999998,go
15gz8rb,jum4ax2,"But languages are fads, and Rust is the current fad.",0.0,rust
15gz8rb,jumd0n3,"As someone who’s writing a compiler in Go, I don’t recommend it if you can avoid it.",0.0,go
15gz8rb,jumtnoa,You might also be interested in [this post from last week](https://www.reddit.com/r/ProgrammingLanguages/comments/15a4z4c/is_go_a_good_target_language/) about using Go as a compilation *target*.,0.125,go
15gz8rb,juoozn3,I found C# quite pleasant to use.,0.7333333333333333,c
15gz8rb,jume12c,"Go doesn't have them,  so I wouldn't write any compiler in Go.",0.0,go
15gz8rb,jume12c,Rust on the other hand is extremely well suited to compiler development.,-0.125,rust
15gz8rb,jume12c,"Since you can also do concurrency in Rust, and it will also be safer, I don't think Go has any advantage over it in a compiler context.",0.0,rust
15gz8rb,jume12c,"Since you can also do concurrency in Rust, and it will also be safer, I don't think Go has any advantage over it in a compiler context.",0.0,go
15gz8rb,jumln2j,"I'm curious why you ask about Go specifically, is it because it's a language you like and/or already know?",-0.1,go
15gz8rb,jumln2j,"> In addition, I know Rust, for example, has tools for building languages, such as inkwell (LLVM bindings) and cranelift.",0.0,rust
15gz8rb,jumln2j,"To my knowledge, Go has no such tools.",0.0,go
15gz8rb,jumln2j,"Another possibility, if the main thing is that you **want** to use Go, is that your compiler translates your new language into Go code, and then invokes the Go compiler.",0.1515151515151515,go
15gz8rb,jumuscu,Learning rust or ml or Haskell would be a project of its own.,0.6,rust
15gz8rb,jumuscu,Learning rust or ml or Haskell would be a project of its own.,0.6,haskell
15gz8rb,juomyh9,C interop might be difficult if you write it in go.,-0.5,c
15gz8rb,juomyh9,C interop might be difficult if you write it in go.,-0.5,go
15gz8rb,jumeokp,"Depending on how much work your compiler needs to do, having it in go could be a detriment since go’s optimizer isn’t great.",0.5,go
15gz8rb,jumt4ly,"It doesn't really matter, the language is just the tool that helps you make cool stuff.",0.275,cool
15gz8rb,jupnnvt,"Very good, although I would prefer Rust, if I don't want to struggle with C/C++.",0.9099999999999999,rust
15gz8rb,jupnnvt,"Although there are more good options, but Rust is a delight for everything, when I use it.",0.6,rust
15gz8rb,jus65e8,"I did write a lisp compiler in C.  So if you are already good at Go, just use it.",0.7,lisp
15gz8rb,jus65e8,"I did write a lisp compiler in C.  So if you are already good at Go, just use it.",0.7,go
15gz8rb,jv0fhjo,I wrote a C-like language in Go a couple years ago [https://github.com/0x2ac/myc](https://github.com/0x2ac/myc).,0.0,go
15gz8rb,jv0fhjo,It uses llir to generate the text format and needs a system C compiler.,0.0,c
15gz8rb,jv0fhjo,It wasn't too bad of an experience but there are some Go-like quirks to do that you have to deal with and the compilers/interpreters I've written later in Rust have been a much nicer experience.,-0.1666666666666666,rust
15gz8rb,juqnoj9,Using `iota` as a replacement for enums didn't help with Go's lack of ADTs?,0.0,go
15gz8rb,jvclgl6,"Rust has the Plex library too, which can let you define grammar in a macro and basically skip you to code gen",0.0,rust
15gz8rb,jumjzex,I just think it's relevant to OP's question in the sense that there may not be as many resources for Go in respect to what they're trying to accomplish.,0.45,go
15gz8rb,jumjzex,"However as you noted, Go itself is self-hosted so the codebase is a resource, but not quite the same as a book.",0.0,go
15gz8rb,juvsm1t,> Go is self-hosted  For any* language the drive to self-host is high because presumably the author loves the language and wants to only write in it / check how a large project in it feels like.,0.14357142857142857,go
15gz8rb,jumpcbq,"Fads are a factor but there are strong arguments for OCaml - it has a powerful type system and pattern matching, and Haskell is even better since it has continuations so you don't have to convert the source to CPS to implement certain structures (although you could use coroutines for most cases and Go does offer those).",0.3895238095238095,haskell
15gz8rb,jumpcbq,"Fads are a factor but there are strong arguments for OCaml - it has a powerful type system and pattern matching, and Haskell is even better since it has continuations so you don't have to convert the source to CPS to implement certain structures (although you could use coroutines for most cases and Go does offer those).",0.3895238095238095,go
15gz8rb,jumep90,"CPython uses GC, and many other high level features, but the implementation language is C, which has pretty much nothing.",0.197,c
15gz8rb,jummrjx,"Yeah, I saw some people have mentioned that those two things are quite useful for making compilers, and Go doesn't have them.",0.3,go
15gz8rb,juoogh0,How do you handle algebraic data types for ASTs in Rust?,0.0,rust
15gz8rb,juoogh0,"I haven't used Rust much, but when I wrote an interpreter in it, I made an enum for the AST nodes, but found it quite annoying to add new fields.",-0.15454545454545457,rust
15gz8rb,jumnn0k,The main reason I'd like to use Go if it's a good option is that I already mostly know it.,0.45555555555555555,go
15gz8rb,jumnn0k,"However, some commenters have already pointed out that Go may not be the best language because it doesn't have pattern matching and algebraic data types.",1.0,go
15gz8rb,jumnn0k,Rust has both.,0.0,rust
15gz8rb,jumnn0k,"I also like Rust, but I only know the basics, so I'd have to learn it, which isn't much of a problem since I'd like to learn it at some point.",0.1,rust
15gz8rb,juqq0uv,"Go has `cgo` package, which allows C interop.",0.0,go
15gz8rb,juqq0uv,"Go has `cgo` package, which allows C interop.",0.0,c
15gz8rb,juqasoi,go has generics,0.0,go
15gz8rb,juqo0pb,"I may be misunderstanding your comment, but I wasn't planning on compiling to Go.",0.0,go
15gz8rb,jv0tw2a,Did you already know Rust when you first wrote a compiler in it?,0.25,rust
15gz8rb,jv0tw2a,"If not, did learning Rust get in the way of writing the compiler?",0.0,rust
15gz8rb,juon1mv,I believe OCaml should be a much more pleasant and flexible host language than Haskell for this use case.,0.6166666666666667,haskell
15gz8rb,jumkvwe,"> CPython uses GC, and many other high level features  Yeah, features that the devs had to write from scratch, because as you point out, C does not offer much.",0.18375000000000002,c
15gz8rb,jumkvwe,"I think the point being made here was that it would be *easier* to write an interpreter in a language like Go, because you wouldn't have to worry about things like GC -- it just works.",0.0,go
15gz8rb,juowj0g,"That’s the most natural representation of an AST, and that’s how all Rust based compilers that I know of do it too.",0.3,rust
15gz8rb,juozck2,">However, some commenters have already pointed out that Go may not be the best language because it doesn't have pattern matching and algebraic data types  Those will be the people who like to use pattern matching and algebraic data types in their compilers.",1.0,go
15gz8rb,juozck2,"Creating a tree might have been tricky in 1970s Fortran or BASIC, but pretty much any language now can manage it easily.",0.22083333333333333,fortran
15gz8rb,junfl9l,"if you are going to learn a new language specifically to develop your compiler in, I would recommend ocaml above rust.",0.06818181818181818,rust
15gz8rb,junfl9l,"rust has extremely powerful mechanisms for low level control and zero-cost abstractions, but a compiler won't really need that, and you pay some cost in ergonomics",0.16666666666666666,rust
15gz8rb,juon1k1,Try Crystal.,0.0,crystal
15gz8rb,jv1b4y3,"I learnt rust a year after that I think, even when you learn rust you can keep working on your go stuff.",0.0,rust
15gz8rb,jv1b4y3,"I learnt rust a year after that I think, even when you learn rust you can keep working on your go stuff.",0.0,go
15gz8rb,juqepzm,"Yeah, I agree that Haskell can be tough.",-0.3888888888888889,haskell
15gz8rb,juo2yb9,Imagine for example writing a Python interpreter in Go.,0.0,python
15gz8rb,juo2yb9,Imagine for example writing a Python interpreter in Go.,0.0,go
15gz8rb,juo2yb9,"This Python may have a specially designed set of data structures to represent Python objects, which might accommodate memory management by reference counting, say.",0.35714285714285715,python
15gz8rb,juo2yb9,"Now Go apparently has its own GC, but how is that going to fit into what's going on in the Python bytecode execution?",0.35000000000000003,go
15gz8rb,juo2yb9,"Now Go apparently has its own GC, but how is that going to fit into what's going on in the Python bytecode execution?",0.35000000000000003,python
15gz8rb,juo2yb9,"Maybe Python relies on immutability to simplify data sharing, while Go data structures are immutable (I've no idea if they are).",0.0,python
15gz8rb,juo2yb9,"Maybe Python relies on immutability to simplify data sharing, while Go data structures are immutable (I've no idea if they are).",0.0,go
15gz8rb,juqkrck,"Haven't done Rust must lately so I might be confused, but I think it was the fact that I had to modify the patterns to accommodate the new fields in the first place.",-0.0784090909090909,rust
15gz8rb,juqkrck,In C# I could just do the pattern matching (eg.,0.0,c
15gz8rb,juqkrck,"In Rust I would need to change all the Expr::Binary(_, _ ,_ ,_) and such.",0.0,rust
15gz8rb,juqkrck,Seems like the Rust compiler has a struct (Expr) that has some common fields and then a field with an instance of an enum.,-0.3,rust
15gz8rb,junpnl2,"I'm curious: I've seen mostly-functional languages, specifically Haskell and OCaml, recommended for PL implementation.",-0.1,haskell
15gz8rb,juqmjrd,It was finally added in Go 1.18.,0.0,go
15gz8rb,juqn2ol,"I want to write a whole new language, including the GC and other such features, but Go already has many of those.",0.14227272727272727,go
15gz8rb,juqn2ol,"I was concerned Go already having those features would mess with my implementation of them for my language, although from what I understand, since I'm writing a compiler that targets machine code (or LLVM IR, which then compiles to machine code), that shouldn't be a problem.",-0.175,go
15gz8rb,juqn2ol,"However, I probably won't use Go and will turn to something like Rust based on what the commenters have said.",0.0,go
15gz8rb,juqn2ol,"However, I probably won't use Go and will turn to something like Rust based on what the commenters have said.",0.0,rust
15gz8rb,jusm0t6,I like Go generics.,0.0,go
15gz8rb,juto5r1,I'm not very experienced with Go.,-0.3076923076923077,go
15gz8rb,juto5r1,"I've really only built one larger web app with it and am working on another, also in Go.",0.0,go
15gz8rb,juujd74,Going crazy with them a la Java or C# just isn’t done.,-0.6,java
15gz8rb,juujd74,Going crazy with them a la Java or C# just isn’t done.,-0.6,c
15gh2sl,jujkvta,"So, the ""modern"" way is to make a lossless parser:  https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/syntax.md  The main takeaway is that your first AST is not ""abstract"" but a ""Concrete Syntax Tree (CST)"" that has all the information that will be fed to other stages like:  * CST -> AST (as usual) * CST -> FormatAST * CST -> LintAST * CST -> DocAST  One example of such animal is https://crates.io/crates/rowan  But a simple way can be done letting the lexer to record all the code, and have a ""Trivia"" branch where you collect the stuff that is likely to be discarded but useful for things like doc generators:  ```rust  struct Loc {   code: String //a CST has a exact view of the source code, so here could be ""1 ""   line, row, file, etc... }  struct Comment {   Comment(Loc)   DocCode(Cst) }  enum Trivia {   Spaces(Loc),   Comment(Vec<Comment>),// A comment can be made of several lines interceded by doc codes or other stuff... }  enum Cst {   Int(i32, Loc),   //What you need but likely discard   Trivia(Trivia), } ```",0.058333333333333334,rust
15gh2sl,juk00n2,"For instance Python doc comments are legitimate statements in the language, and you can read them programmatically by accessing `my_function.__doc__` for example.",0.0,python
15g4cst,juiz410,"Can you go into more detail about the distinction between INPUT, CHAIN and OUTPUT stages?",0.5,go
15g4cst,jujf87b,"&#x200B;  >Can you go into more detail about the distinction between INPUT, CHAIN and OUTPUT stages?",0.5,go
15g0v0c,jug93os,I personally think this is the whole point after ruby & perl's [TMTOWTDI](https://wiki.c2.com/?ThereIsMoreThanOneWayToDoIt) philosophy.,0.1,ruby
15g0v0c,jug93os,I personally think this is the whole point after ruby & perl's [TMTOWTDI](https://wiki.c2.com/?ThereIsMoreThanOneWayToDoIt) philosophy.,0.1,perl
15g0v0c,juh8vy3,"Checkout how functions are defined in OCaml or Haskell, there is one way that is  ``` f arg1 arg2 = <exp> ```  which looks just like function application you would write later and it is sugar for  ``` f = \arg1 arg2 -> <exp> ```  I'm showing haskell here, OCaml has some similar stuff",0.0,haskell
15g0v0c,juhxx9r,"let x = x  In Lua `local function f` desugars to `local f; f=function` instead of `local f = function`, precisely for this reason.",0.1,lua
15g0v0c,juglmxk,"This is a thing in Javascript as well, where some people like to do ```js const add = (a, b) => {     return a + b; } ```  In a previous language of mine (Currant), this is a thing as well, the only way to define a function is by using a closure: ``` add: fun = (a: f32, b: f32) -> f32 {     -> a + b; }; ```  I don't think it's a bad thing, it will probably make the language simpler and more consistent.",-0.1645833333333333,javascript
15g0v0c,jui2i0s,I also have syntax sugar so that  `let a b = c` means exactly `let a = (b => c)`.,-0.25,c
15g0v0c,juic212,I'm going to go a different way than either of your proposals.,0.0,go
15g0v0c,juic212,"So I'd prefer:      let a = 3     let b = 4     fn hypot(a:i32, b:i32) => i32 sqrt(a*a + b*b)     let c = hypot(a,b)  you can then also define and assign in one go:       let calc = fn (a:i32, b:i32) => i32 sqrt(a*a + b*b)  BTW, I'm not thrilled that in some places I know that something is an i32 because it's a:i32 but in other places it's a prefix (i32 {a+b})",-0.2125,c
15g0v0c,juic212,"So I'd prefer:      let a = 3     let b = 4     fn hypot(a:i32, b:i32) => i32 sqrt(a*a + b*b)     let c = hypot(a,b)  you can then also define and assign in one go:       let calc = fn (a:i32, b:i32) => i32 sqrt(a*a + b*b)  BTW, I'm not thrilled that in some places I know that something is an i32 because it's a:i32 but in other places it's a prefix (i32 {a+b})",-0.2125,go
15g0v0c,jujm0uj,"Like I had a `Stmt::Fn` for `let a = (b: string) => {}` and an `Expr::Fn` for `(c: i32, d: i32) => { c + d }`.",-0.75,c
15g0v0c,jujm0uj,"Like I had a `Stmt::Fn` for `let a = (b: string) => {}` and an `Expr::Fn` for `(c: i32, d: i32) => { c + d }`.",-0.75,d
15g0v0c,juhe26k,F# uses  ``` let name x y = x + y ```  it is the same as  ``` let name = fun x -> fun y -> x + y ```  you have the same in JavaScript.,0.15,javascript
15g0v0c,jujsfjh,For example one could say in Scala :  val inc = (number: Int) => number + 1   But for a total beginner programmer would that above line really be easy to know what's going on?,-0.07916666666666666,scala
15g0v0c,jujsfjh,"Now how about this one from Elm:   fn add x y = x+y   It's true there's more likely an easier way to do this in Scala but I hope you can see that Scala puts more of an emphasis on conciseness and being approachable to experts, while something like elm's syntax was meant to lower the barrier for entry for beginner/expert programmers alike",0.3375,elm
15g0v0c,jujsfjh,"Now how about this one from Elm:   fn add x y = x+y   It's true there's more likely an easier way to do this in Scala but I hope you can see that Scala puts more of an emphasis on conciseness and being approachable to experts, while something like elm's syntax was meant to lower the barrier for entry for beginner/expert programmers alike",0.3375,scala
15g0v0c,jugcsvq,Lisp isn't consistent though.,0.25,lisp
15g0v0c,jugcsvq,"(defun f (args) body)  Is syntax sugar for      (define f (lambda (args) body))  Similar for scheme, where it is sugared to:      (define (f args) body)",-0.375,scheme
15g0v0c,jug9te1,But Lisp ugly :(,-0.725,lisp
15g0v0c,jujzwrv,"That's why I like PHP over C/C++ due ""function"" keyword makes it readable...",-0.125,php
15g0v0c,jugvtrj,"Indeed, this is perfectly normal in JavaScript, btw in your example your subnet even need the brackets `const add = (a, b) => a + b`",-0.3,javascript
15g0v0c,juib0pb,"But I believe Javascript attempts to work around this by inferring and using the variable name in the stack trace, anyway.",0.0,javascript
15g0v0c,juhkrv6,"I'm not a fan of the ""let"" approach (it always felt very artificial), but it's a minor detail in the overall scheme of things, no pun intended.",-0.27666666666666667,scheme
15g0v0c,juggdx8,"Seeing as all that sugar could be (and often is) delivered by in language macro facilities, Lisp kinda has it both ways by design.",0.0,lisp
15g0v0c,juj13zm,You only needs 9 primitives to bootstrap a lisp.,0.0,lisp
15g0v0c,juj13zm,"It's true that most industrial adopted lisp use a tons of syntax macros, but most of them aren't built-in at the compiler level.",0.45,lisp
15g0v0c,jugv9lr,Pretty sure there's no defun in scheme though.,0.375,scheme
15g0v0c,juga6rm,"Beginners will have no trouble classifying Haskell, Rust, OCaml as ugly, just because the syntax is not close to everyday math.",-0.26666666666666666,haskell
15g0v0c,juga6rm,"Beginners will have no trouble classifying Haskell, Rust, OCaml as ugly, just because the syntax is not close to everyday math.",-0.26666666666666666,rust
15g0v0c,juiz8dt,what you do is the way javascript does closures that close over the this object of the declaring scope: const name = followed by a lambda literal,0.0,javascript
15g0v0c,jugaswn,The only language I know myself which makes closures explicit was C++.,0.0,c++
15g0v0c,jukch3u,"Haskell gets away without using `let` declarations, and having `let` expressions instead.",0.0,haskell
15g0v0c,juglr7r,"No reference language, I just didn't particularly like how move closures work in Rust.",0.16666666666666666,rust
15g0v0c,jul1bau,It's weird seeing `cond` instead of `if` as the conditional primitive (Unless it was a different thing in the early days of lisp than it is now).,-0.13333333333333333,lisp
15fwhvm,jufslck,"This is something that I don't fully understand, but the two concpets seem distinct in LR(1)-but-non-LALR(1) grammars:  ``` S = a E c S = a F d S = b E d S = b F c E = e F = e ```  As far as I understand, this is not LALR(1) because when we read ""a e"", (at the top of the parser stack) we're in a merged LR(0) state ""E = e .",0.3,c
15fwhvm,jufslck,"This is something that I don't fully understand, but the two concpets seem distinct in LR(1)-but-non-LALR(1) grammars:  ``` S = a E c S = a F d S = b E d S = b F c E = e F = e ```  As far as I understand, this is not LALR(1) because when we read ""a e"", (at the top of the parser stack) we're in a merged LR(0) state ""E = e .",0.3,d
15fwhvm,jufslck,"E c"" | ""b .",0.0,c
15fwhvm,jufslck,"F c"" and ""a .",0.0,c
15fwhvm,jufslck,"F d"" | ""b .",0.0,d
15fwhvm,jufslck,"E d"" )  (example from https://en.m.wikipedia.org/wiki/LALR_parser#Relation_to_other_parsers)  Thank you for letting me know that I don't understand things perfectly.",1.0,d
15fs9pu,,"(By that I mean I don't have to learn the language itself before learning anything else, like in Haskell).",-0.3125,haskell
15fs9pu,,EDIT: here's an non-exhaustive list of candidates  - Haskell - OCaml - Agda - [Hackket](https://github.com/lexi-lambda/hackett) - [Klister](https://github.com/gelisam/klister) - [Typer](https://gitlab.com/monnier/typer),0.0,haskell
15fs9pu,jv74rt4,"See https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html and this phd thesis: [Scalable Metaprogramming in Scala 3](https://infoscience.epfl.ch/record/299370)  This is more or less the state of the art, it improves over MetaOCaml in several ways.",-0.10416666666666666,scala
15fs9pu,jufs113,Interested to see if there's cool research into this though.,0.3,cool
15fs9pu,jugq22y,Like from lisp?,0.0,lisp
15fp4hw,juga1ix,For example: With [Zigler](https://github.com/E-xyza/zigler) you mix high level Elixir code and low-level Zig code seamlessly:,0.13,elixir
15fp4hw,juhz7i9,"In haskell this is solved with a combination of `StateT`, `ExceptT` and other monad transformers with lens/optics handling state updates.",-0.125,haskell
15fp4hw,jvfvxnl,"I well architectured program is a program with a pure core and an impure shell, so a language that distinguishes pure from impure does help in practice.",0.21428571428571427,shell
15fp4hw,jvfvxnl,"I know Haskell already does that but if I do not want a purely functional lazily evaluated language, I don't see many alternatives.",0.15476190476190477,haskell
15fo0dk,juel0xh,"Newlines aren’t special in that regard - you can imagine rewinding to some other herald symbol (eg go to the nearest `(` if you’re a Lisp, and design your string literals around that).",0.11607142857142858,go
15fo0dk,juel0xh,"Newlines aren’t special in that regard - you can imagine rewinding to some other herald symbol (eg go to the nearest `(` if you’re a Lisp, and design your string literals around that).",0.11607142857142858,lisp
15fo0dk,juetse1,"Super cool read, never thought about making a language IDE friendly (and its connections to compilation itself) before  I’d be really interested in the full post about IDE friendly languages :)",0.3619047619047619,cool
15fo0dk,juetse1,"Super cool read, never thought about making a language IDE friendly (and its connections to compilation itself) before  I’d be really interested in the full post about IDE friendly languages :)",0.3619047619047619,d
15fluxd,,"* Totally protected from memory leaks (unlike Java, Rust etc.)",0.0,java
15fluxd,,"* Totally protected from memory leaks (unlike Java, Rust etc.)",0.0,rust
15fluxd,jug27yw,"You have some very bold statements (""no memory leaks unlike Java, Rust"") in your description that make me suspicious.",0.43333333333333335,java
15fluxd,jug27yw,"You have some very bold statements (""no memory leaks unlike Java, Rust"") in your description that make me suspicious.",0.43333333333333335,rust
15fluxd,juvf2sm,"Rust actually used to have sigils for smart pointer types, but decided to ditch them for readability and consistency reasons.",0.10714285714285714,rust
15fluxd,jugrpqo,I started with making a C++ smart pointer library ([https://github.com/karol11/ltm](https://github.com/karol11/ltm)) that introduces the same semantics.,0.10714285714285714,c++
15fluxd,juh2h8i,"Rust, on the other hand, is a systems-level language.",-0.125,rust
15fluxd,juwnpfn,"In Rust - smart pointers are not built-in, they a the part of runtime library, and they are numerous.",0.10714285714285714,rust
15fluxd,juwnpfn,"In contrast Argentum smart pointers are limited by UML, built-in, and deeply integrated in the compiler, same as  Rust &-reference or !-macro sigils.",0.03571428571428571,rust
15fluxd,jv1ftl8,"BTW there are other demos - that show handling of the graph data structures with loops, file IO, text parsing/formatting and FFI-interop with C.",-0.125,c
15fluxd,jumu09v,Maybe it would help me to better understand Argentum's model if you could provide common code in other languages (I'm Java dev) and how they would be written in Argentum.,0.025000000000000005,java
15fluxd,jund84j,"```Rust // Define classes class Document {    accounts = Array(Account);    transactions = Array(Transaction); } class Account {    id = 0;    name = """";    init(i int, n String) this { id:=i; name:=n }    toString() { ""{}/       {id}-{name}    ""} } class Transaction {    from = &Account;    to = &Account;    // or accounts = WeakArray(Account);    amount=int;    description = """";    ... }  // Create object doc = Document; doc.accounts.add(Account.init(1, ""Cookies"")); doc.accounts.add(Account.init(2, ""Gold"")); doc.transactions.add(Transaction.init(     &doc.accounts[0],     &doc.accounts[1],     200,     ""Sold""));  // Prints: // Transaction // from 1-Cookies // to 2-Gold // amount: 200 // reason: Sold doc.transactions.each((t){    log(""{}/        Transaction        from: {t.from ?",-0.75,rust
15fluxd,jur4r0t,"In Java application you can delete account, and this account will be still visible to transactions but not presented in the document `accounts` registry.",0.0,java
15fluxd,jur4r0t,"While in Java this checking is a multiline statement just to evade null pointers,  but if you want to protect your code from accessing the accounts that was removed from registry,  you need additional flags and checks.",0.0,java
15fluxd,jurljcs,The problem I see is that Argentum's code needs to cover the edge case in each piece of code while in Java I just can remove the transaction and that's it.,0.0,java
15fgh6b,judv71d,"In fact, in Haskell, every module does directly correspond to a compilation unit.",0.1,haskell
15fgh6b,juef2z1,"> JavaScript notably lacked modules, and that was so painful they now have [multiple](https://requirejs.org/) [competing](https://github.com/amdjs/amdjs-api/blob/master/AMD.md) [modules](https://en.wikipedia.org/wiki/CommonJS).",-0.09999999999999998,javascript
15fgh6b,juef2z1,"It's funny, there's a 4th that you didn't link that's the actual, official module system :) The 2015 edition added the [standard module system](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) (called ""JavaScript modules"" or ""ES Modules"").",0.1875,javascript
15fgh6b,jugq0o3,"There's an old thread on erlang mailing lists on ""Why do we need modules at all?""",0.1,erlang
15fgh6b,juhuaw8,It feels like JavaScript and Python are out of place in the table.,0.0,javascript
15fgh6b,juhuaw8,It feels like JavaScript and Python are out of place in the table.,0.0,python
15fgh6b,juhuaw8,Unix shell is like the Internet in this sense!,0.0,shell
15fgh6b,judpts0,"BTW Good Article, but forgot to mention ""Modula"", from the Pascal branch of P.L.",0.7,pascal
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,pascal
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,ada
15fgh6b,judpts0,":  https://en.wikipedia.org/wiki/Modula https://en.wikipedia.org/wiki/Modula-2  Modern versions of Pascal, like Ada, Delphi, Object Pascal and FreePascal, also supports modules with a different name like ""units"" or ""packages"".",0.1,delphi
15fgh6b,juggfji,That is the approach that languages like Zig or Lua take and I absolutely love it (i.e.,0.5,lua
15fgh6b,juif795,exactly what happened with C++ templates.,0.25,c++
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,c++
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,haskell
15fgh6b,juif795,"In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc.",0.36,rust
15fgh6b,jud9x3m,"Since modules are objects in Python, is it enough to consider than they can be nested?",0.0,python
15fgh6b,juowe0b,"I'm surprised to see Haskell listed under nesting, because module system in Haskell is extremely flat.",0.037500000000000006,haskell
15fgh6b,juhop5h,"We could if we wanted to just create namespaces or aliases arbitrarily after the fact, like typescript does.",-0.1,typescript
15fgh6b,juhop5h,"In Java, for example, you might need to have a (pre-compiled) dependency available during compilation for interface checking, but that doesn't stop you from arbitrarily composing a classpath from which implementations are loaded at runtime, replacing anything you like down to individual classes.",0.036111111111111115,java
15fgh6b,juhop5h,"(BTW, java also has a thing called modules over and above packages [https://www.oracle.com/se/corporate/features/understanding-java-9-modules.html](https://www.oracle.com/se/corporate/features/understanding-java-9-modules.html) )  If we look more from a level of modular logic, the signature of a module is a much more exciting idea than a namespace.",0.325,java
15fgh6b,juhop5h,Interfaces in Go work like this.,0.0,go
15fgh6b,juk62fw,It feels like JavaScript and Python are out of place in the table.,0.0,javascript
15fgh6b,juk62fw,It feels like JavaScript and Python are out of place in the table.,0.0,python
15fgh6b,juk62fw,"I included javascript and python to highlight that we call their thing a module as well, despite how different it is from all the other modules.",-0.0625,javascript
15fgh6b,juk62fw,"I included javascript and python to highlight that we call their thing a module as well, despite how different it is from all the other modules.",-0.0625,python
15fgh6b,judf088,For example rust allows me to define a submodule with a crate private interface and then re-export a subset of that interface as public from the parent module.,0.0,rust
15fgh6b,judf088,Python doesn't have the same language level features for working with nested modules.,0.0,python
15fgh6b,judf088,But by no means would I consider someone wrong for saying python supports nested modules.,-0.5,python
15fgh6b,jupf1vn,That being said haskell is no longer a flat module system (necessarily)!,-0.0125,haskell
15fgh6b,jupf1vn,Backpack has been implemented and can be used in haskell today to do mixin modules,0.0,haskell
15fgh6b,jueaegm,"Last time I tried, it was honestly quite clunky - much more so than doing this in Scala, which naturally unifies OOP and module systems, making the latter just as easy to use as the former.",0.23333333333333336,scala
15fgh6b,juj1vej,Cool!,0.4375,cool
15fgh6b,jumdhw1,"- static methods and properties, - static arrays, - static array sizes (as in C), - static types, - static self types, - static dispatch and linking, - static virtual methods and properties, - static variables, - static visibility and storage class, - static classes, - static classes (the other static ones), static local functions and static lambdas, - static statements (the D ones), - static effects (I made that one up), - static initialisation blocks, - static constructors and shared static constructors, - `using static`, - `static import`, - static columns,  and probably more.",0.455,c
15fgh6b,jumdhw1,"- static methods and properties, - static arrays, - static array sizes (as in C), - static types, - static self types, - static dispatch and linking, - static virtual methods and properties, - static variables, - static visibility and storage class, - static classes, - static classes (the other static ones), static local functions and static lambdas, - static statements (the D ones), - static effects (I made that one up), - static initialisation blocks, - static constructors and shared static constructors, - `using static`, - `static import`, - static columns,  and probably more.",0.455,d
15ewmuk,,"Despite Python's GIL, a bit of threading does *subjectively* seem to [speed up turtle-graphics significantly](https://github.com/kjosib/sophie/blob/main/sophie/adapters/turtle_adapter.py).",0.0,python
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,ada
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,c
15ewevk,juahxai,I've been working on a tool that generates Ada bindings for C and C++ headers.,0.0,c++
15ewevk,juahxai,"A couple years ago I wrote an [Ada binding](https://github.com/csb6/libtcod-ada) to libtcod, a library used for making rougelike games, and it took a lot of manual effort to get the bindings working so I decided to work on a tool to make it easier.",0.0,ada
15ewevk,jub9ky6,I got a tip about namespaced properties in Datomic and that seems to fit well with how I use modules (with a restriction like Go where the module/file name must be used as a prefix on imported symbols).,0.4,go
15ewevk,jud44b3,"I am currently working on a gcc backend and binutil target for a custom ISA, which means learning a lot about these highly generic tools and the mess that is programming in C.",-0.05833333333333333,c
15ewevk,jv479rt,"I  * I started over with my previous Python implementation (which had just a lexer) * I wrote a new on-demand lexer, replacing the old one which used lots of horrible regular expressions.",-0.18606060606060607,python
15ewevk,jv479rt,"* I wrote a parser, which currently creates a custom Python object, but the structure isn't set in stone, yet.",0.0,python
15ewevk,jvg2b7l,"I'm thinking of starting a project which translates programs written in C, into my own systems language.",0.3,c
15ewevk,jvg2b7l,"But it will be difficult: C is lower level, quirky, and chaotic in what it allows in many places.",0.0,c
15ewevk,jvg2b7l,"I already have a product that can take C source code and turn it into my syntax, but that is purely for visualisation; I can't compile and run it, as too many details have to be changed or need attention.",0.35714285714285715,c
15ewevk,jvg2b7l,"having to cast every intermediate result down from `i64` to `i32`), that it would better to leave the code as C.",0.17222222222222222,c
15ewevk,juapglh,"The metaphor is message-passing similar to Erlang or Pony, but it turns out that pervasive codata poses some extra challenges.",0.0,erlang
15ewevk,juapglh,"Also, maybe it's time to learn C#, even if only as a compilation target.",0.0,c
15ewevk,jucg51w,"If time allows, I'd like to make the compilation chain a bit more realistic by going to a more assembly like syntax, although this is a bit out of scope with regards to the paper.",0.38888888888888884,assembly
15ewevk,jud9buj,"And deciding whether to compile to Javascript, WASM, or JVM...",0.0,javascript
15ewevk,juw212y,Currently dissecting Kotlin type system then perhaps C#’s,0.0,kotlin
15ewevk,juw212y,Currently dissecting Kotlin type system then perhaps C#’s,0.0,c
15ewevk,juvc7xi,I'm working on transpiling my programming language into JavaScript so that it can run in the browser.,0.0,javascript
15ewevk,juvc7xi,The problem is that the nature of Nutt is much more dynamic than that of JavaScript.,0.25,javascript
15ewevk,jv59jz4,## Typed functional TS/JS  Last month I started working on a new functional programming language for the TypeScript world.,0.06818181818181818,typescript
15ewevk,jv59jz4,"Basically, what could TypeScript be if it wasn't strictly a superset of JavaScript, and instead was more like statically typed functional JS?",0.5,typescript
15ewevk,jv59jz4,"Basically, what could TypeScript be if it wasn't strictly a superset of JavaScript, and instead was more like statically typed functional JS?",0.5,javascript
15ewevk,jv59jz4,"Now I'm on the long and hairy journey of figuring out how the type system will work, particularly with regards to enabling full/native interop with existing TypeScript code.",0.05833333333333333,typescript
15ewevk,jv59jz4,"* Type system and syntax is basically the same as TS where possible  Now I'm getting into the weeds, I'm starting to realise I have to go through a huge amount of work to re-implement most of TypeScript's type system for a language that's almost just syntax sugar on top of TS.",0.23333333333333336,go
15ewevk,jv59jz4,"* Type system and syntax is basically the same as TS where possible  Now I'm getting into the weeds, I'm starting to realise I have to go through a huge amount of work to re-implement most of TypeScript's type system for a language that's almost just syntax sugar on top of TS.",0.23333333333333336,typescript
15ewevk,jv59jz4,"I remember when I first learning Elm, and you could do something basic like `type UserStatus = Regular | Visitor` ... it took me way too long to understand that `Regular` and `Visitor` _are not references_ - you're making them up!",0.04,elm
15ewevk,jv59jz4,"It only worked for a small slither of the total syntax, but was cool to watch.",0.024999999999999994,cool
15ewevk,jvcf6rj,Working through a number of things for [dt](https://dt.plumbing) -- it's a concatenative programming language implemented in Zig that's meant for use in a shell context.,0.0,shell
15ewevk,jxwi5aq,I imagine using shell scripts and something like ninja to create systems from collections of such programs.,0.0,shell
15ewevk,jwhntg9,"Actually I had three projects associated with C that I'm dropping:  * A C subset compiler (that one was also used to convert C APIs into my syntax) * The C visualiser which I'd started to hone into a more workable conversion tool * A backend for my systems language which targetted C source code  Dealing with C, a language I detest, *and* dealing with its diehards, was becoming too much.",0.2875,c
15ewevk,jv8aunn,I think where I'm at right now is \_not\_ trying to reimplement all of TypeScript's advanced type features but instead just maintain interop with all TS by integrating tsc into my compiler.,0.34285714285714286,typescript
15ewevk,jv8aunn,"Part of me wants to pivot this language into ""Smaller Rust™"" and just go straight to WASM 🤷‍♂️",0.13333333333333333,go
15ewevk,jvd7fx5,"At least on the frontend, you need multiple build steps for jsx, typescript, tailwind, etc.",-0.15,typescript
15enrue,,"I was just working on prototyping a stack based language in python, and while I love the idea of a stack based language, I always disliked the fact that they're not very intuitive to read if you haven't seen postfix before.",0.06666666666666667,python
15enrue,juasupq,"https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E#:\~:text=1980%E5%B9%B4%E4%BB%A3%E3%81%AB%E9%96%8B%E7%99%BA%E3%81%8C%E5%A7%8B%E3%82%81%E3%82%89%E3%82%8C%E3%81%9F%E3%80%8EMind%E3%80%8F%E3%81%AF%E3%80%81%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E8%AA%9E%E9%A0%86%E3%81%A8%E3%81%AE%E9%A1%9E%E4%BC%BC%E3%81%8C%E6%8C%87%E6%91%98%5B5%5D%E3%81%95%E3%82%8C%E3%82%8B%E9%80%86%E3%83%9D%E3%83%BC%E3%83%A9%E3%83%B3%E3%83%89%E8%A8%98%E6%B3%95%E3%81%AEForth%E3%82%92%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%81%97%E3%81%A6%E3%80%81%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AB%E8%BF%91%E3%81%84%E8%A8%98%E8%BF%B0%E3%82%92%E5%8F%AF%E8%83%BD%E3%81%A8%E3%81%97%E3%81%9F%E3%80%82  >1980年代に開発が始められた『Mind』は、日本語の語順との類似が指摘される逆ポーランド記法のForthをベースとして、日本語に近い記述を可能とした。    Translated: >""Mind,"" whose development began in the 1980s, is based on Forth, a reverse Polish notation system that has been noted for its similarity to Japanese word order.",0.25,forth
15enrue,ju9zlpq,"German kind of has a similar thing where the first verb goes in the second position, then the rest go to the end in order of decreasing relevance - sort of like bracketing.",0.16999999999999998,go
15enrue,jue69ax,"For example, in a stack-based language you might clarify which terms are functions and which are arguments by accepting both the postfix-only form `a b c f d g h i j k` and the mixed form `a f(b, c) g(d) h k(i, j)`, much like the so-called “universal function call syntax” in OOP-ish notation.",0.06666666666666667,c
15enrue,jue69ax,"For example, in a stack-based language you might clarify which terms are functions and which are arguments by accepting both the postfix-only form `a b c f d g h i j k` and the mixed form `a f(b, c) g(d) h k(i, j)`, much like the so-called “universal function call syntax” in OOP-ish notation.",0.06666666666666667,d
15enrue,ju97sli,"Interesting, seems like a German language COBOL kind of thing to me",0.3666666666666667,cobol
15enrue,ju98d93,"I do not know COBOL, so I cannot answer your question.",0.0,cobol
15enrue,jugmpwn,"The similarity to COBOL is so great, you really need to research into it.",0.5,cobol
15enrue,jugmpwn,"And perhaps also understand why, just as COBOL is in reality nothing whatsoever ""like"" English, so your language is not like German, although superficially, it might seem so.",0.0,cobol
15enrue,jugmxwa,"The Name Idea is cool though, although DDP already is kinda fine.",0.3833333333333333,cool
15enrue,jub6v8p,"Unfortunately, natural language is inherently ambiguous, so to avoid these eventualities you have to go to great lengths to be very specific in your demands and leave no ambiguities in your prompts.",0.3,go
15enrue,jugs0vq,That was more or less the idea of COBOL: that its similarity to English would make it easier to read (and write).,0.11111111111111112,cobol
15enrue,jugsgse,"We made it for fun, and it has become a cool project for me to work on.",0.32499999999999996,cool
15enrue,jugsgse,"Like you said, COBOL tries to be easier to read by being similar to english.",-0.03333333333333333,cobol
15enrue,junkozj,"Also, COBOL was more successful for its time than is often credited",0.625,cobol
15enrue,juj5i2a,"Even if you know neither Latin nor Perl, I think you might get something out of reading about Lingua::Romana::Perligata, Damian Conway's Perl module to allow programming in a Latin ""dialect"" of Perl.",0.0,perl
15ekzuh,,Here's how the [code looks like](https://pastebin.com/xPzia7wp) in my parser written in C.  Cool!,0.4375,cool
15ekzuh,,"However, Clox does not implement an AST, it emits byte code on the fly, so there are limitations on what you can do since you can't really go back to fix things.",0.4,go
15ekzuh,juoh9kt,"So ""(2+3×(4+5), (a; f(x))"" would be split into""(2+3×«a», «b»)"", «a»=""(4+5)"", «b»==""(a; f «c»)"", and «c»=""(x)"".",0.0,c
15ebelq,,"I am working on my own lexer/parser generator (2-in-one, like C's PEG) and I was wondering if I should do PEG and Packrat or EBNF or even ABNF.",0.6,c
15ebelq,junia71,But you see I am making my blog except I am making my own roff-based macro suite to generate the HTML.,0.6,html
15ebelq,junia71,"I define an static array as such:  \`\`\`  static macro\_t MACROS\[\] = {     (macro\_t){.duplet = ""bl"", .produce = ""b"", .prodlen = 1},  }  \`\`\`  And so on and so forth, so ASCII 46 will be the trigger UNLESS escaped, and I will parse it as such, so \`.bl ""mamma mia""\` will become \`<b>mamma mia</b>\` and so on and so forth.",0.25,forth
15dx5jq,ju4klfv,Drawing 10k triangles one at a time in C is also not going to be fast.,0.2,c
15dx5jq,ju5vo3s,"I had a case like this where I couldn't figure out why my code was running several times slower than equivalent C code, and when I profiled it, it turned out to be an issue caused by calling a function to create array slices in an inner loop (something like `for i, x in xs do for y in xs[(i+1)..] do...`).",0.0,c
15dx5jq,ju5c7m1,Python is too slow for rendering real-time 3d graphics as well - would you consider it a failed language?,-0.4,python
15dx5jq,ju5c7m1,"In fact, speed beyond a certain is almost needless if your language has some way of doing FFI, because then you can just write performance-critical libraries in C or Rust or whatever while keeping the API in your language, like what NumPy does.",-0.14285714285714285,c
15dx5jq,ju5c7m1,"In fact, speed beyond a certain is almost needless if your language has some way of doing FFI, because then you can just write performance-critical libraries in C or Rust or whatever while keeping the API in your language, like what NumPy does.",-0.14285714285714285,rust
15dx5jq,ju6a9uv,Looks like javascript?,0.0,javascript
15dx5jq,jv395pw,One important issue might be the C FFI.,0.4,c
15dx5jq,jv395pw,"It seems that calling a C function, which calls into the module's `call_function` will run a lot of string comparisons.",0.0,c
15dx5jq,ju4lkec,"The first time I implemented inlining in a compiler, it was really cool to see how some totally-naïve heuristic like “inline if <10 instructions” made programs run ~90% faster.",0.3,cool
15dx5jq,ju8k3n7,"The issue isn't in the implementation language (C++), it's my language.",0.0,c++
15dx5jq,ju6ozju,"If you still need more speed after that, you can indeed go with more complex backends, but do be aware of the diminishing returns.",0.2375,go
15dx5jq,ju9b6km,Software renderers are slow in C as well when comparing to a GPU,-0.30000000000000004,c
15dx5jq,jubrniu,How does anyone go about creating profiling tools?,0.0,go
15dx5jq,jufc6th,"In a language like C++, instrumentation also has the downside that you need to mark up your code to collect the profiling information, but if you're building your own language, that isn't a concern as you can simply add it automatically (or build it into your VM if you're using an interpreted/JITed language).",0.3,c++
15dx5jq,jufc6th,"I've been looking at [Tracy](https://github.com/wolfpld/tracy) for my C++ game engine (and potentially my hobby language), but I've also used [microprofile](https://github.com/jonasmr/microprofile) in the past and had a great experience with it.",0.037500000000000006,c++
15dq3dp,,"Support's q-expressions {1 2 3} (inspired by build-your-own-lisp's lisp dialect), and special forms.",0.35714285714285715,lisp
15dq3dp,,Provides a mediocre REPL and ability to execute standalone lisp code using a command.,-0.5,lisp
15dq3dp,ju5mgb2,"Is it like python?, does it have types like C?.",0.0,python
15dq3dp,ju5mgb2,"Is it like python?, does it have types like C?.",0.0,c
15dq3dp,ju5mgb2,"I don't really know lisp, but I love program language development.",0.35,lisp
15dq3dp,ju633vi,it looks like python and have C/Rust like types.,0.0,python
15dq3dp,ju6cutd,"So 'defer del a', releases the memory at the end of the function?, it's all so cool, I love it, I think I'm in love already, the documentation looks great, although the name is a bit weird, I would call it 'Kind', 'kind-lang', just kidding.",0.37500000000000006,cool
15dp204,ju3gcpi,"It looks a bit ugly but I think the C++ way of saying ""operator+"" (for example) has it's merits, for this reason",-0.7,c++
15dmp16,," Rust, C++?",0.0,rust
15dmp16,," Rust, C++?",0.0,c++
15dmp16,,Anything but C  Which has the the best library or framework for making languages like llvm,1.0,c
15dmp16,ju3ll4q,Multiple comments have mentioned Rust.,0.0,rust
15dmp16,ju3ll4q,Rust is a fantastic programming language.,0.4,rust
15dmp16,ju3ll4q,"Rust sells itself as a language for lower-level/backend/memory-conscious/high-performance problem spaces, none of which are directly relevant to PL implementation.",0.4,rust
15dmp16,ju3ll4q,"In principle, Rust isn't the right choice, because it doesn't even sell itself as a good choice for this space.",0.4928571428571428,rust
15dmp16,ju3ll4q,"My experience has been that for all the advantages Rust has in this space, its parent OCaml is the better choice without paying the costs of Rust that aren't relevant to programming language implementation.",0.45,rust
15dmp16,ju3ll4q,"OCaml has many/all of the capabilities that make Rust pleasant for writing a compiler, and few/none of the irrelevant challenges that make Rust unpleasant for the same.",-0.10416666666666666,rust
15dmp16,ju3ll4q,"With Rust, at first I fought the borrow checker, but then learned in an almost Stockholm Syndrome-y sort of way to describe my datastructures/algorithms in unnatural ways to avoid these problems.",0.25,rust
15dmp16,ju3ll4q,With C++ I miss pattern-matching and spend a lot of time typing boilerplate.,-0.1,c++
15dmp16,ju3ll4q,"C# was fairly pleasant to work with, but still lacks certain capabilities and in general is more boilerplate to describe certain algorithms than in a more appropriate language.",0.3264880952380952,c
15dmp16,ju3ll4q,"C, or any particularly-low-level language is a wildly inappropriate choice in general, if your goal is the actual implementation of the target language.",0.05000000000000001,c
15dmp16,ju3ll4q,"Choosing C gives yourself a personal challenge, can be fun, and done well can end up with a notably high-performance compiler, but at the cost of easily 10x implementation effort on a project that often spans years to begin with.",0.30833333333333335,c
15dmp16,ju3ll4q,"D is very pleasant to work with as a ""C-family"" language and for me was by far the best among C/C++/C#, with the advantages that make those languages nice, and few of the disadvantages.",0.49066666666666664,d
15dmp16,ju3ll4q,"It's still missing the single most important feature, sumtypes and pattern matching, but like C++ et al that can (must be) worked around.",0.15714285714285714,c++
15dmp16,ju3ll4q,"If you were to insist on using a C-family language (C/C++/C#/Java/etc), I was strongly recommend reaching for D first.",0.3416666666666667,d
15dmp16,ju3ll4q,"More notes on OCaml:  * OCaml is a production-ready language that produces (relatively) high-performance executables, is battle-tested, and has a reasonably pleasant ecosystem (Rust's is better, C++ barely has one).",0.3566666666666667,rust
15dmp16,ju3ll4q,"More notes on OCaml:  * OCaml is a production-ready language that produces (relatively) high-performance executables, is battle-tested, and has a reasonably pleasant ecosystem (Rust's is better, C++ barely has one).",0.3566666666666667,c++
15dmp16,ju3ll4q,"* Haskell, Standard ML, and other functional languages share much of the advantages of OCaml, but suffer from a ""purity problem"" that OCaml lacks.",0.025000000000000005,haskell
15dmp16,ju3ll4q,"C to your will is satisfying in its own right, i.e., PL implementation in this case being an ""excuse"" for exercises/algo implementation in general.",0.27714285714285714,c
15dmp16,ju2ugtm,"I've made a couple languages and what I've found is that if you're making an interpreted language then anything like c++, rust, golang, c# (anything that compiles down to an .exe file) is good.",0.2722222222222222,c++
15dmp16,ju2ugtm,"I've made a couple languages and what I've found is that if you're making an interpreted language then anything like c++, rust, golang, c# (anything that compiles down to an .exe file) is good.",0.2722222222222222,rust
15dmp16,ju2ugtm,"I've made a couple languages and what I've found is that if you're making an interpreted language then anything like c++, rust, golang, c# (anything that compiles down to an .exe file) is good.",0.2722222222222222,c
15dmp16,ju2ugtm,"If you're making a compiled language then it doesn't matter as much as your choice of target language that you're going to compile to (C, assembly, LVM), it especially doesn't matter if you're planning to make a self-compiling compiler (like golang)",0.1,c
15dmp16,ju2ugtm,"If you're making a compiled language then it doesn't matter as much as your choice of target language that you're going to compile to (C, assembly, LVM), it especially doesn't matter if you're planning to make a self-compiling compiler (like golang)",0.1,assembly
15dmp16,ju2vj0s,"So yeah, C++ or Rust I guess.",0.0,c++
15dmp16,ju2vj0s,"So yeah, C++ or Rust I guess.",0.0,rust
15dmp16,ju2vj0s,"In terms of portability, JavaScript and C# are good transpiler targets.",0.7,javascript
15dmp16,ju2vj0s,"In terms of portability, JavaScript and C# are good transpiler targets.",0.7,c
15dmp16,ju2tker,Haskell or Ocaml.,0.0,haskell
15dmp16,ju2v27y,"Rust is great, like C but with modern tooling, pattern matching and a much more elegant type system.",0.5,rust
15dmp16,ju2v27y,"Rust is great, like C but with modern tooling, pattern matching and a much more elegant type system.",0.5,c
15dmp16,ju2v27y,You could use cranelift (similar to llvm) or use inkwell which is a rust friendly wrapper around llvm.,0.1875,rust
15dmp16,ju2v27y,"My experiences writing a language in rust have been excellent, although I will admit the borrow checker can be frustrating at times in the beginning.",0.3,rust
15dmp16,ju2sybw,C++ or C for this.,0.0,c++
15dmp16,ju2sybw,C++ or C for this.,0.0,c
15dmp16,ju2sybw,"Seamless C interop  With these goals, I only really have one option: C.   So personally I think it depends on your goals with the language!",0.07500000000000001,c
15dmp16,ju3t3bb,Rust,0.0,rust
15dmp16,ju323sv,I prototype my langs exclusively in python and love it and will continue doing so.,0.5,python
15dmp16,ju37kce,"It's not a viable option for every language type, like esoteric or shell languages, and takes a lot longer, but it's still a powerful technique.",0.3,shell
15dmp16,ju37kce,"And, as sample programs go, compilers/interpreters have surprisingly few language dependencies: you need only strings, lists, and control flow.",-0.1,go
15dmp16,ju3s0c0,">Rust, C++ ?",0.0,rust
15dmp16,ju3s0c0,">Rust, C++ ?",0.0,c++
15dmp16,ju3s0c0,"But it depends on the proposed language too: if you use ones like OCaml or Haskell, they have facilities to quickly create mini-me versions of themselves.",0.3333333333333333,haskell
15dmp16,ju3s0c0,"Think however about how any of those tools would handle a language like a custom assembler, or even your hated C language (its preprocessing language is a peach to implement).",-0.9,c
15dmp16,ju302re,"Chez scheme, racket, Common Lisp (back).",-0.15,scheme
15dmp16,ju302re,"Chez scheme, racket, Common Lisp (back).",-0.15,lisp
15dmp16,ju302re,Ocaml and Haskell are great too.,0.8,haskell
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,rust
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,haskell
15dmp16,ju3910m,"So the top contenders are drumroll please  Zig, Ocaml, Rust, Haskell, Racket, and Go  I’m kinda overwhelmed so I guess if you HAD to choose one and one only for the ENTIRE lang which would it be?",0.16666666666666666,go
15dmp16,ju2q324,C,0.0,c
15dmp16,ju3rgta,that is Functional like Lisp or supports regular expressions or has Regular Expressions libraries like JavaScript.,0.0,lisp
15dmp16,ju3rgta,that is Functional like Lisp or supports regular expressions or has Regular Expressions libraries like JavaScript.,0.0,javascript
15dmp16,ju3rgta,"The second, is to implement a lexer and a parser like C, C++ compilers does.",0.0,c
15dmp16,ju3rgta,"The second, is to implement a lexer and a parser like C, C++ compilers does.",0.0,c++
15dmp16,ju6cgd9,"Then compile a parser to the source language of choice, write some glue code then: (0) interpret the parsed ast, (1) generate code in some high-level lang w/ garbage collection (OCaml, Python, etc.",-0.75,python
15dmp16,ju6cgd9,"), (2) in C/C++, (3) use backend tools (w/ opt) such as LLVM or [cranelift](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/README.md) or (4) to assembly via nasm.",0.0,assembly
15dmp16,ju31tvy,Rust enums are great to represent an AST.,0.8,rust
15dmp16,ju31tvy,"I usually do something like this:  ```Rust enum Toplevel {     Struct {         name: String,         fields: Vec<Parameter>,     }     Function {         name: String,         parameters: Vec<Parameter>         body: Vec<Expression>,     } }  struct Parameter {     name: String,     ty: Type, }  enum Expression {     Block(Vec<Expression>),     FunctionCall {         name: String,         parameters: Vec<Expression>,     }     Assignment(String, Box<Expression>), } ```  Rust has frameworks for LLVM, native and some more unique ones, I didn't get anything useful working with any of them.",0.23125,rust
15dmp16,ju31tvy,"Alternatively you could use the rust exclusive cranelift, an alternative to LLVM used my wasmer.",0.0,rust
15dmp16,ju34r5x,"Of those listed, I think Rust is the best.",1.0,rust
15dmp16,ju34r5x,"It is seemingly more difficult, but really it’s just that memory management is hard and Rust doesn’t let you manage it poorly (by poor I mean with potential access violations).",-0.11488095238095239,rust
15dmp16,ju34r5x,"For languages beyond those, I’d recommend Racket.",0.0,d
15dmp16,ju34tyk,"If you’re making an interpreter and you care at all about performance, you’ll want to use a performance-oriented language like Rust.",0.0,rust
15dmp16,ju34tyk,Haskell and OCaml are good choices.,0.7,haskell
15dmp16,ju34tyk,"Rust can work here, but the overhead of learning Rust’s idiosyncrasies is probably not worth it.",-0.15,rust
15dmp16,ju9fzbr,C has been a great non-nonsense language for me to write my compiler in.,0.8,c
15dmp16,ju9fzbr,I personally don’t think the added abstractions of even C++ was helpful (which I previous experience writing compiler code in).,-0.08333333333333333,c++
15dmp16,juj9c07,"Common Lisp, using Metaobject Protocol.",-0.3,lisp
15dmp16,juptgea,"I think having match expressions and algebraic types helps A LOT in creating compilers, so I'd choose Rust if I were implementing a VM or transpiler.",0.0,rust
15dmp16,juptgea,"However, libraries for using LLVM are a bit limited compared to C and C++.",-0.07142857142857142,c
15dmp16,juptgea,"However, libraries for using LLVM are a bit limited compared to C and C++.",-0.07142857142857142,c++
15dmp16,ju4k11g,"Since you mention C#, I wonder if you've tried F#.",0.0,c
15dmp16,ju6obaj,">Haskell, Standard ML, and other functional languages share much of the advantages of OCaml, but suffer from a ""purity problem"" that OCaml lacks.",0.025000000000000005,haskell
15dmp16,ju6obaj,"I would like to add that the absence of mathematical jargon definitely makes OCaml more approachable, which alone may be a compelling enough reason to use OCaml over Haskell.",0.13125,haskell
15dmp16,ju2vkzs,If I were to use rust (most likely) would crane lift or inkwell be better  features and ease of use wise,0.425,rust
15dmp16,ju3afsx,>Compile time function execution  Could you explain how C helps compile-time execution?,0.0,c
15dmp16,ju3afsx,(Because this is not a feature of C itself.),0.0,c
15dmp16,ju5nut3,I cant think of anything about ocaml or Haskell that would make mini me languages particularly easy for a compiler - can you please elaborate?,0.4666666666666667,haskell
15dmp16,ju3aw5a,If you are wanting to get something going quickly with quite a bit of resources I'd go with Racket.,0.3333333333333333,go
15dmp16,ju3j5q4,"Racket, Ocaml or Haskell.",0.0,haskell
15dmp16,ju3mn6u,"For comparing, I can only comment on languages I've used:  * Go doesn't provide enough PL-implementation-relevant power to make it a serious contender.",-0.1111111111111111,go
15dmp16,ju3mn6u,"* Rust is a good choice in the context of worse choices (C, etc), but is not a good choice in the context of better choices (most functional languages, etc).",0.19,rust
15dmp16,ju3mn6u,"* Rust is a good choice in the context of worse choices (C, etc), but is not a good choice in the context of better choices (most functional languages, etc).",0.19,c
15dmp16,ju3mn6u,"* Haskell is a great choice in the context of worse choices (Rust, etc), but is not a good choice in the context of better choices (OCaml).",0.1375,haskell
15dmp16,ju3mn6u,"* Haskell is a great choice in the context of worse choices (Rust, etc), but is not a good choice in the context of better choices (OCaml).",0.1375,rust
15dmp16,ju3mn6u,"OCaml is a productivity-first functional language with all of the expressive power you need for PL implementation, none of the irrelevant challenges you'd be faced with RE Rust et al, and overall gets recommended frequently by the people who use it for PL implementation for a reason.",0.1,rust
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,assembly
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,cobol
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,c
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,c++
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,java
15dmp16,ju5g06y,"I've built compilers and code gen tools in assembly, COBOL, C, C++, Java, BASIC (🤮), and I think I even did some hacky code gen work in Pascal 30+ years ago.",0.0,pascal
15dmp16,ju5g06y,"Frankly, Ruby and Perl are huge in this field (not that I would choose either), proving that flexibility sometimes trumps good design.",0.55,ruby
15dmp16,ju5g06y,"Frankly, Ruby and Perl are huge in this field (not that I would choose either), proving that flexibility sometimes trumps good design.",0.55,perl
15dmp16,ju6nw0w,"Parsing is certainly easiest in Haskell, and if you're making a simple interpreter then that might be a worthwhile factor",0.2380952380952381,haskell
15dmp16,ju3ejji,"> If you’re making an interpreter and you care at all about performance, you’ll want to use a performance-oriented language like Rust.",0.0,rust
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,go
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,haskell
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,lisp
15dmp16,ju3ejji,"I think if you're writing an interpreter, it makes a lot of sense to use a language that either has a built-in garbage collector (like Go, Haskell, Lisp, Java, etc.)",0.0,java
15dmp16,ju3ejji,or has easy integration with a production-quality GC like the [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) (which has C and C++ bindings).,0.43333333333333335,c
15dmp16,ju3ejji,or has easy integration with a production-quality GC like the [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) (which has C and C++ bindings).,0.43333333333333335,c++
15dmp16,ju3ejji,I don't think Rust's memory management model is very conducive to running as an interpreter for languages with dynamic memory allocation.,0.1,rust
15dmp16,ju4ow7t,:D,1.0,d
15dmp16,ju3f2yv,It's actually more due to the fact that I want seamless C imports with no FFI.,0.15833333333333333,c
15dmp16,ju3f2yv,I could do this if I transpile down to C with any language.,-0.15555555555555559,c
15dmp16,ju3f2yv,"However since I allow CTFE on native C functions too, it's much easier for my VM to dynamically call dynamic library code with C than a language with an FFI to C.  So I wouldn't say it helps with CTFE but if I want seamless C and CTFE at the same time, my options seem limited to C or C++.",0.04571428571428572,c
15dmp16,ju3f2yv,"However since I allow CTFE on native C functions too, it's much easier for my VM to dynamically call dynamic library code with C than a language with an FFI to C.  So I wouldn't say it helps with CTFE but if I want seamless C and CTFE at the same time, my options seem limited to C or C++.",0.04571428571428572,c++
15dmp16,ju4y86w,What do you think makes OCaml a better choice than Haskell?,0.5,haskell
15dmp16,ju7w0nx,"If you're already proficient with Haskell, OCaml doesn't have any additional advantage.",0.0,haskell
15dmp16,ju7w0nx,"Haskell introduces concepts that aren't immediately useful for being time-zero productive, that are also varying degrees of famously difficult to grok.",-0.1,haskell
15dmp16,ju7w0nx,"I'd rephrase my thought as:  * For someone who is already proficient in Haskell and/or OCaml, they can both be equally good choices.",0.7,haskell
15dmp16,ju9fge9,"I'm intimately familiar with Haskell but I can certainly imagine Haskell's enforced purity, category theoretic jargon and laziness by default being additional hurdles to those new to the language.",0.2418831168831169,haskell
15cxb1a,,I plan to go to LR(k) once I have an efficient LALR(k) parser.,0.0,go
15cxb1a,ju4804u,*I have absolutely not* wrapped my brain around the complexities (so I don't know off-hand how to design that program) but I suspect that's the direction you'll go.,-0.1,go
15cxb1a,jtzatjr,"Of course, non-deterministic methods might be necessary for some languages such as C++, but I hope to avoid them and only use them as a last resort for disambiguating actual ambiguities and not just inadequate states that can be fixed with deterministic techniques.",0.016666666666666666,c++
15cxb1a,ju2r9ur,"There are 2 other books that give it a go, but, in my opinion, the one by Dick is the best.",0.4375,go
15cxb1a,ju4meuo,"I plan to make the max k that the parser should go to user-definable, but I would prefer to have my parser generator find a minimal lookahead required and not just fixed-size lookaheads for everything.",-0.1,go
15cnhsc,,"I'm a 3rd year CS student, and next semester I'd like to write a research paper (it'd be my first) related to rust, static analysis or programming languages, or even all of them to some degree.",0.15,rust
15cnhsc,jtx9z61,"With the 3 topics you suggested I would consider looking into things like behavioral types in Rust, such as typestates and session types.",0.0,rust
15cnhsc,jtxca05,I'd rather go for something easier for now.,0.0,go
15cnhsc,jtxca05,"I'll look more into behavioral types and formal verification, although I'll likely not go for the latter for my first paper, as my math is a bit rusty, no pun intended.",0.1875,go
15caifs,,"here's the introduction in that repo:  # Introduction Tungstyn is an interpreted scripting language, primarily inspired by LISP, ECMAScript, and Lua.",0.4,lisp
15caifs,,"here's the introduction in that repo:  # Introduction Tungstyn is an interpreted scripting language, primarily inspired by LISP, ECMAScript, and Lua.",0.4,lua
15caifs,,"If you've ever programmed in LISP before, this should be familiar.",0.375,lisp
15caifs,jty7i5p,"very cool, i love it :)",0.48500000000000004,cool
15caifs,ju6knwo,"Reminds me of [Tcl](https://wiki.tcl-lang.org/page/Dodekalogue), what with prefx notation, square brackets and explicit $variables.",0.0,tcl
15caifs,ju6knwo,"Might want to take a look at that, its minimal syntax makes for some cool metaprogramming.",0.12499999999999999,cool
15caifs,jtvhemv,I can get how it could be a little confusing but shell languages do it so I think it's reasonable to do.,-0.09583333333333333,shell
15caifs,jtvkhxj,I'll go do that.,0.0,go
15caifs,jtvkhxj,such is C ¯\\\_(ツ)_/¯,0.0,c
15c4q04,,"*     Looking at this, it uses the rust compiler codegen capabilities to target NVVM, which allows you to write host code on rust for CUDA.",0.0,rust
15c4q04,,"However, this project is tied to a compiler for rust from 2021.",0.0,rust
15c4q04,,"If the rust compiler gets updated, this project needs maintenance.",0.0,rust
15c4q04,,Where you don't need to have constant maintenance against the rust compiler?,0.0,rust
15c4q04,jtwi0w9,"At this point, Rust is quite widely deployed and it's unlikely there will be any backward-incompatible changes to the language like there has been in the past.",-0.2833333333333333,rust
15c4q04,jtwi0w9,There are even people attempting to get an ISO standard rust.,0.0,rust
15c4q04,jtwi0w9,So it will not be necessary to update this project with trivial changes to the Rust compiler.,0.0,rust
15c4q04,jtwi0w9,It can freeze the version of Rust it forked from.,0.0,rust
15c4q04,jtwi0w9,"But if there's future Rust versions, say Rust V4 or Rust V5, then it will probably still be simpler to track the main Rust compiler to update this project to support future Rust versions, rather than maintaining a completely separate compiler.",0.06666666666666667,rust
15c4q04,jty9xda,"Well, speaking from experience, I am tied to a specific compiler of rust in 2021.",0.0,rust
15c4q04,jty9xda,"When the rust compiler makes changes to its internals, this also has to follow suit.",0.0,rust
15by6a3,ju41h4j,And why not write it in Pascal?,0.0,pascal
15by6a3,jucld4i,"Pascal is a bit closer to my Oberon+ language than Go and I consider it much leaner than the huge implementations with complex multi-layer build processes we usually see from Google, and the Go code, in contrast to FP, depends on a garbage collector.",0.012500000000000025,pascal
15by6a3,jucld4i,"Pascal is a bit closer to my Oberon+ language than Go and I consider it much leaner than the huge implementations with complex multi-layer build processes we usually see from Google, and the Go code, in contrast to FP, depends on a garbage collector.",0.012500000000000025,go
15by6a3,jucld4i,"I actually had a look at the internals of V8, Dart and Go over the years; re-using a simplified version of V8 would be interesting, but - in contrast to JVM or e.g.",0.25,dart
15by6a3,jucld4i,"I actually had a look at the internals of V8, Dart and Go over the years; re-using a simplified version of V8 would be interesting, but - in contrast to JVM or e.g.",0.25,go
15bufdn,jtsrujy,"The SIMULA language was offically published to the IFIP in 1962 (""An Extension of ALGOL to the Description of Discrete Event Networks"") - but Ive not been able to find any copy of this paper (If anyone has a copy, please let me know!)",0.625,algol
15bufdn,ju6x8pe,"UNIVAC 1107 computer's ALGOL compiler (developed at CASE University in Cleveland), and was finished in December 1964.",0.1,algol
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,c++
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,algol
15bufdn,ju46giq,"I'd try contacting Paul McJones, https://mcjones.org/dustydecks/archives/2004/07/04/2/, https://mas.to/@pmcjones  He's known for his work on programming languages history at the Computer History Museum's Software Preservation Group, https://www.softwarepreservation.org/projects/lang  Some examples (which seems like exactly the kind of research you're looking for with Simula I):  C++ Historical Sources Archive, https://mcjones.org/dustydecks/archives/2007/06/11/61/  ALGOL 68: Implementation and more, https://mcjones.org/dustydecks/archives/2013/08/24/662/  In Search of the Original Fortran Compiler, https://mcjones.org/dustydecks/archives/2017/07/14/968/",0.34500000000000003,fortran
15b5tr7,jtoirwf,bash.,0.0,bash
15b5tr7,jtots69,[COBOL on Wheelchair](https://web.archive.org/web/20160415075723/azac.pl/cobol-on-wheelchair/) is a thing.,0.0,cobol
15b5tr7,jtots69,So are the [Bash](https://github.com/dzove855/Bash-web-server) [web](https://yoctu.github.io/yosh/) [frameworks](https://github.com/nerdgeneration/www.sh/blob/master/code/www.sh).,0.0,bash
15b5tr7,jtots69,"And so, C code too?",0.0,c
15b5tr7,jtots69,"Also, PHP.",0.0,php
15b1rxq,jtnyt3v,Rust compiles closures by converting them to `struct` with fields of the variables that were captured.,0.0,rust
15b1rxq,jto8duv,"Rust, C++?",0.0,rust
15b1rxq,jto8duv,"Rust, C++?",0.0,c++
15b1rxq,jtogiet,Common Lisp?,-0.3,lisp
15b1rxq,jtoj7qp,The better question is how to implement a GC’d language in LLVM because GC makes lambdas much easier to work with.,0.35,d
15b1rxq,jtoj7qp,A lambda is isomorphic to a virtual method (AKA C++ and even C with certain patterns).,0.21428571428571427,c++
15b1rxq,jtoj7qp,A lambda is isomorphic to a virtual method (AKA C++ and even C with certain patterns).,0.21428571428571427,c
15b1rxq,jtoj7qp,"A lambda type in C could be defined something like this:  ``` struct BasicLambda { int (*func)(int arg1, void* context); void* context; }; ```",0.0,c
15b1rxq,jtogcni,"I think Crystal programming based on LLVM has lambda, they're termed as Proc.",0.0,crystal
15b1rxq,jtogcni,Edit: [Link to Crystal Proc documentation](https://crystal-lang.org/reference/latest/syntax_and_semantics/literals/proc.html),-0.75,crystal
15b1rxq,jtqgtir,"GHC Haskell can compile to both llvm and its native codegen, and it has much more lambdas (and closures) than most other languages.",0.2916666666666667,haskell
15b1rxq,jtqgtir,"Seriously, Haskell is very serious about optimizing lambdas, because they are used a lot in typical programs.",-0.31111111111111106,haskell
15b1rxq,jtrlxns,"If variables can be mutated, _all_ uses of mutable variables (including those outside closures) must go through an indirection, so that a use can observe mutations caused by another use.",0.0,go
15b1rxq,jtow2pn,"If you’re compiling AOT you could raise the lambda to top level and just have it as a function, I’ve not worked with llvm much but this is how I’ve done it previously and afaik schemes that compile to C also do it this way",0.17777777777777778,c
15b1rxq,jtoxczl,"Llvm is not like Java or .Net CLR, is a low level VM.",0.0,java
15b1rxq,jtoxczl,Check how C++ and C# implemented lambdas ...,0.0,c++
15b1rxq,jtoxczl,Check how C++ and C# implemented lambdas ...,0.0,c
15b1rxq,jtpubuy,"clang itself supports C lambdas ([""blocks""](https://en.wikipedia.org/wiki/Blocks_(C_language_extension\))) as an extension: https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/CGBlocks.cpp",0.0,c
15b1rxq,jtocnhs,I'm not good at rust but how can y represent both a type and a closure in rust?,-0.35,rust
15b1rxq,jtroems,How does Rust compile functions that can take either a function or a closure as an argument?,0.0,rust
15b1rxq,jtofubq,"First of all, I already have my own IR that then compiles to c, llvm, js, etc.",0.425,c
15b1rxq,jtoizov,"For example, JavaScript named functions (not lambda) are closures.",0.0,javascript
15b1rxq,jtt2cof,This `impl Trait` example is roughly syntax sugar for:       fn foo<F: Fn()>(f: F) { ... }  and Rust compiles generic functions via monomorphization.,-0.05,rust
15b1rxq,jtpeomo,"In dynamically scoped lisp, for instance lambda expressions are famously *not* implemented with closures.",-0.25,lisp
15b1rxq,jtou4ee,"I don't think Rust closures contain a function pointer; rather, they implement the `Fn`/`FnMut`/`FnOnce` traits which have the associated function `call`.",0.0,rust
15b1rxq,jtpen6y,But I certainly am no expert in Javascript.,-0.10714285714285714,javascript
15b1rxq,jtq8las,"JavaScript functions are always closures, irrespective of being named or anonymous.",0.0,javascript
15b1rxq,jtq8las,"For example:      function outer(param) {         function inner() {             // closes over ""param""             console.log(param)         }         return inner     }  See also: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures  > In JavaScript, closures are created every time a function is created, at function creation time.",0.0,javascript
15b1rxq,jtomu1h,"If you need to expand to plain-old-functions, a common way is to have the object reference become the first argument of the function, so it would become (in C):      void __lambda_f(__closure_f * __c, int x);  The return type would be a function pointer of the type:      void (*__f)(__closure_f *, int);",-0.024999999999999994,c
15b1rxq,jtp4hlh,"If you’re specifically interested in return types - the Rust approach is to use traits (interfaces) for the closure types, which describe what the thing does rather than what the thing is (closures do not have a concrete identifiable type for a few reasons).",0.075,rust
15b1rxq,jtp4hlh,"When not using `dyn` (so, the normal case) Rust’s compiler does something called “monomorphization” where it replaces trait-based generics with the real function, meaning there’s no runtime vtable or overhead - yay, equivalent performance to writing the thing by hand!",0.2,rust
15b1rxq,jtp4hlh,"The monomorph topic goes beyond closures, and is discussed here https://rustc-dev-guide.rust-lang.org/backend/monomorph.html  Summary: Rust never lets you give a concrete type to a closure, instead you use a generic that describes what it _does_ rather than what it _is_, and the compiler expands it for you.",0.07500000000000001,rust
15b1rxq,jtp4hlh,"I’d recommend reading up on how Rust does it even if you aren’t familiar with the language, because it has some of the best documentation out there for this very very complex process.",0.3283333333333333,d
15b1rxq,jtp4hlh,"I’d recommend reading up on how Rust does it even if you aren’t familiar with the language, because it has some of the best documentation out there for this very very complex process.",0.3283333333333333,rust
15b1rxq,jtoyejk,Closures/anonymous functions in C++ and Rust are implemented by generating a unique type for every closure.,0.375,c++
15b1rxq,jtoyejk,Closures/anonymous functions in C++ and Rust are implemented by generating a unique type for every closure.,0.375,rust
15b1rxq,jtoyejk,"As you mention, the Fn traits in Rust are used to constrain what the arguments and return types of these unique closure types are.",0.375,rust
15b1rxq,jtoyejk,In C++ there is no way to write the actual type of a closure in the language.,0.0,c++
15b1rxq,jtoyejk,This is why you see the use of auto frequently when using closures in C++.,0.1,c++
15b1rxq,jtoyejk,The C++ std::function wrapper works a bit differently: it uses heap allocation and type erasure to store the closure.,0.0,c++
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,c++
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,c
15b1rxq,jtoyejk,"There are a few other features of modern C++: closures that capture no variables can be casted to a C style function pointer, and C++ concepts can be used to constrain argument types (but not the return type) in a very similar way to Rust's traits.",-0.03125,rust
15b1rxq,jtomblq,"I think Rust, Zig and Nim are three examples of this being done right.",0.2857142857142857,rust
15b1rxq,jtooi1g,Is your VM like a VirtualBox VM or a Java RE VM?,0.0,java
15b1rxq,jtrhdf6,"There are some minor differences between “ordinary” JavaScript functions and arrow functions, the biggest being how `this` is bound.",-0.15,javascript
15b1rxq,jtsw26d,"> JavaScript functions are always closures  Unless they do not capture anything from the outer scope, right?",0.2857142857142857,javascript
15b1rxq,jtt8n5f,"For JavaScript specifically, it's a dynamically typed language so there's no ahead-of-time process to determine which variables are local vs. free (captured from enclosing scope) so functions are always going to have an associated environment.",0.2,javascript
15b1rxq,jtou80x,"I implement them using the C preprocessor, with one or more macros per instruction which emit the assembled bytes into an array.",0.5,c
15b1rxq,jtou80x,"(This requires other macros like `BEGIN_X86_ASM()` and `END_X86_ASM()` to surround blocks of assembly, which is a bit ugly but bearable).",-0.4125,assembly
15b1rxq,jtou80x,"I chose to do this rather than use gcc's built in assembly because the assembly generated by `asm {}` is ""second-class"".",0.0,assembly
15b0517,,One of the reason people like Ruby is that it's fairly readable.,0.7,ruby
15b0517,,"I know it first appear in lisp, but I'm specifically asking this in ruby's context because the 2 language does look very different.",0.125,lisp
15b0517,,"I know it first appear in lisp, but I'm specifically asking this in ruby's context because the 2 language does look very different.",0.125,ruby
15b0517,jtnpl9q,Racket carried forward the Lisp tradition and allows almost any symbol (except braces) to appear almost anywhere within an identifier.,0.0,lisp
15b0517,jtnpl9q,The other comment mentions using `?` and `!` for optional handling (as is done in Swift).,-0.15625,swift
15b0517,jtnun9l,The Racket and Clojure tradition of using ?,0.0,clojure
15b0517,jtnun9l,"Elixir's use of % and of => for example, to do key/values is annoying.",-0.8,elixir
15b0517,jto7bqb,People coming from Ruby will probably like it.,0.0,ruby
15b0517,jtolq9b,"Elixir uses this convention, and it makes code delightfully readable.",1.0,elixir
15b0517,jtorfdo,That way it'd keep the Lisp/Ruby tradition and not clash with C#/JavaScript conventions entirely.,0.0,c
15b0517,jtosohn,"> I know it first appear in lisp, but I'm specifically asking this in ruby's context because the 2 language does look very different.",0.125,lisp
15b0517,jtosohn,"> I know it first appear in lisp, but I'm specifically asking this in ruby's context because the 2 language does look very different.",0.125,ruby
15b0517,jtosohn,Ruby is a lisp derivative.,0.0,ruby
15b0517,jtosohn,Ruby is a lisp derivative.,0.0,lisp
15b0517,jtosohn,"[Here's a quote from the creator, Matz:](https://web.archive.org/web/20181027195101/blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642)  > Ruby is a language designed in the following steps: > >  * take a simple lisp language (like one prior to CL).",0.125,ruby
15b0517,jtosohn,"[Here's a quote from the creator, Matz:](https://web.archive.org/web/20181027195101/blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/179642)  > Ruby is a language designed in the following steps: > >  * take a simple lisp language (like one prior to CL).",0.125,lisp
15b0517,jtosohn,>  * add functionality found in Perl (in OO way).,0.0,perl
15b0517,jtosohn,"> >So, Ruby was a Lisp originally, in theory.",0.375,ruby
15b0517,jtosohn,"> >So, Ruby was a Lisp originally, in theory.",0.375,lisp
15b0517,jtosohn,;-)  So it's not hard to see how a lot of lisp ideas (like Symbols as a language construct) and idioms got brought over into Ruby.,0.19791666666666669,lisp
15b0517,jtosohn,;-)  So it's not hard to see how a lot of lisp ideas (like Symbols as a language construct) and idioms got brought over into Ruby.,0.19791666666666669,ruby
15b0517,jtq9uoi,"Although I like Scheme, I dislike the use of dedicated predicates for types as opposed to a generic operator for testing types.",0.0,scheme
15b0517,ju2h6fk,"i think it's a cool idea, idk if it's really more ""readable"", but if i had to bet i'd say it helps.",0.425,cool
15b0517,ju2h6fk,"So seeing them in identifier names can draw attention to the possibilty they mean something specific, which i believe is why it's used in ruby to ""mark"" predicates, or side effects.",-0.15625,ruby
15b0517,ju2h6fk,"seeing how the ruby community manages to relatively systematically use it correctly, i would say it's not gonna be a problem, and overall a net positif in term of readability.",0.0,ruby
15b0517,jto4ni3,the ternary operator can be defined as `_?_:_` where the underscores say where the parameters go.,0.0,go
15b0517,jtopr3k,Ruby uses & for safe navigation.,0.5,ruby
15b0517,jtv6okw,Ruby was designed in Japan so the question mark was more natural for them.,0.3,ruby
15b0517,jtorydh,Ruby does suport ternaries with that syntax and it's not too bad.,-0.6999999999999998,ruby
15b0517,jtshdbp,"But Scheme also marks mutating functions with a suffix `!`, which suggests an interrobang for predicates which also mutate.",0.0,scheme
15b0517,jtwfshj,"I looked at it from the perspective of Scheme, which uses the `predicate?` convention and comes with dozens of built-in predicates, but most of them are simple type tests, and IMO, the absence of `is` in Scheme is a drawback.",0.1625,scheme
15at643,,Prolog in [Charm](https://github.com/tim-hardcastle/Charm) they could do it without any help from me.,0.0,prolog
15at643,,"Note also that I already have embedded Go, so by using that people can perfectly well define their own extensions to the IO system — e.g.",0.8,go
15at643,,"if Go has a library for talking to knitting machines, then a power user can whip up a library using embedded Go that implements a command with signature `post (pattern KnittingPattern) to (machine KnittingMachine)`.",0.0,go
15at643,,But it is essential to the person who wants to embed Prolog in the same sort of way.,0.06666666666666667,prolog
15at643,,"And as with the IO commands, since you can already embed Go, you can do what you like with this.",0.0,go
15at643,,"If you *want* to embed Python into Charm, then you are a very sick person, but since Go can call Python you can do that.",-0.9285714285714286,python
15at643,,"If you *want* to embed Python into Charm, then you are a very sick person, but since Go can call Python you can do that.",-0.9285714285714286,go
15at643,jtp223m,"There's also [Quasiquotation in Haskell](https://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf), where you might be able to write a quasiquoter to look like:      [sql|         SELECT ID, NAME, SALARY          FROM CUSTOMERS         WHERE SALARY > $threshold$     |]  I believe Raku also supports embedding languages, and parts of the language itself is implemented using its facilities for embedding.",-0.125,haskell
15at643,jtp223m,"Of these approaches I think the Wyvern's best solves the embedding problem, as whitespace sensitivity resolves ambiguity issues without the need for syntax directed editing (eg, [Language Boxes](https://soft-dev.org/pubs/pdf/diekmann_tratt__parsing_composed_grammars_with_language_boxes.pdf)), or special, per-language delimiters, whereas Nemerle and Haskell can still have ambiguity issues in the embeddings, and I'm not familiar enough with Raku to determine whether or not it can resolve all ambiguity issues.",0.2924107142857143,haskell
15at643,jtpda2i,"You need to define a new DSL for every language pair, and it does not address the potential for nested embeddings (Eg, Prolog in SQL in Charm).",0.06818181818181818,prolog
15at643,jttmuzh,"Most of the time it's the C ABI, so there *is*, kind of, a standard way to interact between languages - via C.  But aside from that, if you have a base language, you can implement any embedded language in its types, or interpret it in the base language.",-0.1,c
15aie5u,jtmavec,It looks like this       # Source location for errors     loc =        Missing  # equivalent of runtime.NO_SPID     | Token %Token       # Very common case: argv arrays need original location     | ArgWord %CompoundWord     | WordPart(word_part p)   https://www.oilshell.org/release/0.17.0/source-code.wwz/frontend/syntax.asdl   And then it translates to both typed Python and typed C++.,-0.0716666666666667,python
15aie5u,jtmavec,It looks like this       # Source location for errors     loc =        Missing  # equivalent of runtime.NO_SPID     | Token %Token       # Very common case: argv arrays need original location     | ArgWord %CompoundWord     | WordPart(word_part p)   https://www.oilshell.org/release/0.17.0/source-code.wwz/frontend/syntax.asdl   And then it translates to both typed Python and typed C++.,-0.0716666666666667,c++
15aie5u,jtmavec,"So the nice thing is that the C++ lets you see the memory layout directly, and it has evolved over the years.",0.35,c++
15aie5u,jtmavec,I believe people hit this problem over and over again and Rust -- variants aren't types by themselves.,0.0,rust
15af770,,What are your thoughts on using Zig's C compiler as a backend?,0.0,c
15af770,,Let the codegen just spit plain C and let zig c take cover.,-0.21428571428571427,c
15af770,jtllxnb,"But note here that you are not tied it just by picking the zig c compiler - you can, if you want, later just use - say - Clang as the compiler.",0.0,c
15af770,jtllxnb,And there are some platforms that only have ANSI C compilers.,0.0,c
15af770,jtllxnb,You could target those if you make your C output conservative enough!,0.0,c
15af770,jtki01y,C is a great target used by lots of languages!,1.0,c
15af770,jtki01y,And rather than limiting yourself to Zig you can use whichever C compiler is most suitable for the task as hand.,0.525,c
15af770,jtkjk9k,Is there some reason to use Zig's C compiler specifically?,0.0,c
15af770,jtkjk9k,"You're targeting C, you can use any C compiler",0.0,c
15af770,jtl0aho,"If you plan to use zig compiler as backend, I would advise to target pure Zig instead of C compiled by zig.",0.21428571428571427,c
15af770,jts973w,"I switched to using Zig CC for all my new and main C projects, including libsodium.",0.1515151515151515,c
15af770,jts973w,The fact that the C library gets optimized with the same options as the rest of the app is also a good way to get either smaller or faster code than with a generic package of the C library.,0.175,c
15af770,jts973w,I also use `cargo-zigbuild` to build packages for Rust projects.,0.0,rust
15af770,ju6c07m,:( I had planned adding support for gcc/clang/msvc etc as well (did not get to do it yet)      (generated code should still compile with other C compilers),-0.4375,c
15af770,jtnbo64,"If you're going to target C, then what you do have is a big choice of compilers.",0.0,c
15af770,jtkozgt,"Another major plus is that you can use zig itself, which is for many cases better than straight C (C for FFI only IMHO).",0.2525,c
15af770,jtkkz43,"EDIT:i read the comment of consoleTVs, i let my comment becouse i feel is also interesting  im lost im think this was about zig of using c as intermediate languages instead of llvm, odin have similar idea because they can activate all optimisation who are design for c and c++, and llvm is really complex to optimize and is moving target, especially for small programming language who aren't in the radar and constalty break making harder to update to the last version, also some systems don have support for llvm targets, especially embedded.",-0.01875,c
15af770,jtkkz43,"EDIT:i read the comment of consoleTVs, i let my comment becouse i feel is also interesting  im lost im think this was about zig of using c as intermediate languages instead of llvm, odin have similar idea because they can activate all optimisation who are design for c and c++, and llvm is really complex to optimize and is moving target, especially for small programming language who aren't in the radar and constalty break making harder to update to the last version, also some systems don have support for llvm targets, especially embedded.",-0.01875,c++
15af770,jtlkqyb,What could go wrong??,-0.5,go
15af770,jtmgxmo,"Also, dropping LLVM doesn't mean Zig can't compile C. C can be easily transpiled to Zig so I don't see the issue here.",0.060416666666666674,c
15af770,jtkxsx9,There are lots of languages that can compile to C or C++!,0.0,c
15af770,jtkxsx9,There are lots of languages that can compile to C or C++!,0.0,c++
15af770,jtkxsx9,Haskell and Erlang used to be able to too.,0.5,haskell
15af770,jtkxsx9,Haskell and Erlang used to be able to too.,0.5,erlang
15af770,jtn4gi6,I was pointing out that you can take advantages of the strengths of other C compilers too.,-0.125,c
15af770,jtlr715,Allso a subset of F* compiles to C.,0.0,c
15af770,jtn5jqa,The C compilers all implement the same API so languages that compile to C can make use of the $CC environment variable to permit the programmer to select the compiler of their choice.,0.0,c
15af770,jtnj95f,"I assure you, I fully understand the advantages of Zig's C compiler.",0.0,c
15af770,jtnj95f,It is [one of its advertised strengths](https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html) that it implements the standard C compiler API and so can be swapped in-and-out with other C compilers without any additional work.,-0.0625,c
15af770,jtnj95f,"This means that you can, for free, take advantage of the best of all the C compilers and use whichever is best for the problem at hand.",0.7999999999999999,c
15af770,jtnj95f,Zig is not a universally superior C compiler.,-0.35,c
15af770,jtnj95f,There are many C compilers and they can excel in many different ways.,0.3333333333333333,c
15af770,jtnj95f,Targeting standard C rather than a non-standard Zig subset has many advantages and no disadvantage.,0.25,c
15a9pzh,jtjflkm,"In Lua this would look like this:  ```lua local function loop()     if condition then         return -- ""break""     end     return loop() -- fallthrough tail call end ```  The obvious alternative to a `break` is a `goto` (which can also be achieved using an early `return` inside a function), but that isn't any cleaner.",0.03333333333333333,lua
15a9pzh,jtmwaaf,"The example by /u/till-one in [Effekt](https://effekt-lang.org/):      effect Break[A](): A      def forRange(lower: Int, upper: Int) { body: Int => Unit / Break } = {       def loop(i: Int): Unit / Break = {         if(i <= upper) {           body(i);           loop(i + 1)         }       };       try {         loop(lower)       } with Break[A] { () }     }      def f(a: Boolean, b: Boolean) = {       forRange(1, 5) { i =>         if(a) { do Break() };         println(""A"")         forRange(1, 6) { j =>           if(b) { do Break() };           println(""B"")         }       };       forRange(1, 7) { i =>         if(i == 5 && a) { do Break() };         println(""C"")       }     }      def main() = {       f(true, true)     }  Breaking out of a loop, just like early return, is non-local control flow and therefore effectful.",0.12333333333333332,c
15a9pzh,jtmwaaf,We go on to define a custom loop `forRange` which takes a lower and an upper bound and a loop body.,0.0,go
15a9pzh,jtl1k6r,"Ada has `exit when`, which combines the typical if-break into a single statement.",-0.11904761904761904,ada
15a9pzh,jtl1k6r,For example: ```ada loop    Error := Target_Position - Current_Position;    exit when abs Error < 1.0;    Move ((if Error > 0.0 then 1 else -1)); end loop; ```  Reference: http://www.ada-auth.org/standards/22aarm/html/AA-5-7.html   Rationale: http://archive.adaic.com/standards/83rat/html/ratl-03-12.html#3.12,0.0,ada
15a9pzh,jtwmpzo,Nemerle has this cool label feature that even lets you return a value ``` a: while(cond) {     if(thing != otherThing) a();     ... }  def foo = a: foreach(v in values) {     if(value > 5) a(value); } ```,0.4375,cool
15a9pzh,jtk3osn,Here is a mainstream language: JavaScript.,0.0,javascript
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,haskell
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,python
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,c
15a9pzh,ju3k9bh,"[Haskell](https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:takeWhile), [Python](https://docs.python.org/3/library/itertools.html#itertools.takewhile), [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.takewhile?view=net-7.0), [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html)).",0.0,kotlin
15a9pzh,ju7f1mq,Continuations in Scheme can be used to create all sorts of control-flow operators including `break`.,0.0,scheme
15a9pzh,ju7f1mq,"I recently wrote Racket versions of Common Lisp `block`, `return` and `return-from` using them, for example, to make imperative style loops easier to work with.",-0.15,lisp
15a9pzh,jua250z,"The canonical primary source on this line of thinking is [Structured Programming with Go To statements, by Donald Knuth](https://pic.plover.com/knuth-GOTO.pdf).",0.4,go
15a9pzh,jtqa8za,"In C implementation of breaks you could do setjmp/longjmp, regardless of what the statement is.",0.0,c
15a9pzh,jtllkju,"In this case, the use of `goto` (which Lua has recently acquired - a good move as most languages are doing away with it), can trivially take the place of `break`, without turning all of my code upside down.",0.26111111111111107,lua
15a9pzh,jtnow7j,Same with Scala.,0.0,scala
15a9pzh,jtk256z,"In nested loops I even want a more powerful break/continue (in PHP you can do `break 2` to break out of 2 loops for example, other languages provide labels).",0.225,php
15a9pzh,jtkrmq7,"In Lua, this would look like this:  ```lua (function()     while loopcond do         if breakcond then return end         ...     end end)() ```  which of course in general isn't particularly beautiful (though something similar is sometimes used to emulate `continue` in Lua 5.1 which doesn't have `goto`, but that's more of a hack).",0.35,lua
15a9pzh,jtkrmq7,"Sometimes an early `return` is cleaner though if you have something to return; the prime example is checking whether a table contains a value:  ```lua function contains(t, v)     for _, tv in pairs(t) do         if tv == v then return true end     end     return false end ```",0.016666666666666625,lua
15a9pzh,jtm2odi,"Eh, it's rather clunky in Lua, but in more FP-centric languages (Ocaml, Haskell etc) 3 local tail-recursive functions is probably how you'd do it.",0.25,lua
15a9pzh,jtm2odi,"Eh, it's rather clunky in Lua, but in more FP-centric languages (Ocaml, Haskell etc) 3 local tail-recursive functions is probably how you'd do it.",0.25,haskell
15a9pzh,jtn3dyo,"That said, when you're writing idiomatic, imperative Lua, of course use `break`.",0.0,lua
15a9pzh,jtvusfw,I took the fannkuch example and wrote it in very basic Scheme: [here](https://www.jdoodle.com/ia/Ku8).,-0.375,scheme
15a9pzh,jtvusfw,I translated from a [C version](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-3.html) I found because I find C more familiar than Lua and it was already organized in a way that didn't require `break`.,0.4375,c
15a9pzh,jtvusfw,I translated from a [C version](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-3.html) I found because I find C more familiar than Lua and it was already organized in a way that didn't require `break`.,0.4375,lua
15a9pzh,jtn6tuy,"Here's a [real example](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-lua-1.html) in Lua, which has `break` in two separate loops, both of them nested inside an enclosing loop.",0.2,lua
15a9pzh,jtn6tuy,"(I think only one of my dozen, Algol 68, didn't have a form of `break`, but it did have `goto`)  >This \[functional style\] generally makes it easier to follow the control flow.",0.02500000000000001,algol
15a9pzh,jtn6tuy,`break` is basically a `goto` and can be implemented as the one machine instruction `jmp`; I usually go for simple!,-0.125,go
15a9pzh,jtxu3zh,That Scheme looks surprisingly good when laid out like that.,0.7,scheme
15a9pzh,jtxu3zh,"But then, so does the original C!",0.46875,c
15a9pzh,jtxu3zh,"While C does have `for`\-loops, sort of, they're still a lot of work, and the first two examples in your link are also non-idiomatic: I had trouble recognising what they did.",0.024999999999999994,c
15a9pzh,jtxu3zh,(BTW the non-`break` C version ran 10-50% slower than the `break` version - just saying.),0.0,c
15a9pzh,jty3tkn,Scheme - especially when you use such a minimal canonical subset like I did - is a language that doesn't place concision at an especially high priority.,0.055,scheme
15a9pzh,jty3tkn,Just compare `c[i]++` with `(vector-set!,0.0,c
15a9pzh,jty3tkn,c i (+ (vector-ref c i) 1))` for another obvious example of that.,0.0,c
15a9pzh,jty3tkn,Scheme code written by Scheme experts to get work done - rather than Scheme code written by a C programmer for demonstration - tends to be more concise because people build tools within the language to help keep the code shorter.,0.3,scheme
15a9pzh,jty3tkn,Scheme code written by Scheme experts to get work done - rather than Scheme code written by a C programmer for demonstration - tends to be more concise because people build tools within the language to help keep the code shorter.,0.3,c
15a9pzh,jty3tkn,I wouldn't have written the C code that way and I refactored it a bit in C before I tried translating to Scheme.,0.0,c
15a9pzh,jty3tkn,I wouldn't have written the C code that way and I refactored it a bit in C before I tried translating to Scheme.,0.0,scheme
15a9pzh,jty3tkn,Are you saying that Scheme doesn't have loops as a feature?,0.0,scheme
15a9pzh,jty3tkn,"In a language like Scheme - setting aside continuations, which I intentionally left out of my language - you can get a better idea about control flow just by looking at the shape of the code and the initial keywords.",0.16666666666666666,scheme
15a9pzh,jty3tkn,"If I find some time, I might go through the exercise of starting from the Lua code to see how that goes.",0.0,go
15a9pzh,jty3tkn,"If I find some time, I might go through the exercise of starting from the Lua code to see how that goes.",0.0,lua
15a9pzh,jtzitc0,I took some time to look at the Lua code a bit and I realized that eliminating the `break` statements in that code is really trivial to do.,0.2,lua
15a9pzh,jtzitc0,"while (A) {         if (B) {             C;             break;         }         D;     }      ; Added X and Y for the loop state variables and updates, which are implicit above.",0.0,c
15a9pzh,jtzitc0,"while (A) {         if (B) {             C;             break;         }         D;     }      ; Added X and Y for the loop state variables and updates, which are implicit above.",0.0,d
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,c
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,d
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,go
15a9pzh,jtzitc0,(let continue (X)         (cond             (A                 (cond (B C) (else D (continue Y))))))  I'm not going to go through and translate the whole program to Scheme.,0.2,scheme
15a4z4c,,"Go has GC, so prototyping language can do whatever they want without caring about memleak 2.",0.0,go
15a4z4c,jtj7w87,"Funny you mention that, I started targeting Go last week, and was surprised I couldn't find anyone else doing it.",0.11666666666666665,go
15a4z4c,jtj7w87,Rust is definitely more meticulous about these things.,0.5,rust
15a4z4c,jtizkys,"It's probably a decent idea, I mean the points that you listed in favour of Go make sense and seem valid.",-0.07291666666666667,go
15a4z4c,jtizkys,"If so you probably have to mess with CGo, and as the gophers say: [""CGo is not Go""](https://dave.cheney.net/2016/01/18/cgo-is-not-go) 2.",-0.4625,go
15a4z4c,jtizkys,Does the Go runtime support everything you need and/or are you willing to build that (ex.,0.25,go
15a4z4c,jtizkys,"Obviously if you are building a new language rather than just using Go, there must be something it doesn't have that you want.",0.06818181818181818,go
15a4z4c,jtizkys,The Go compiler is oddly strict about some things but not others.,-0.16666666666666666,go
15a4z4c,jtimu6p,"> Go has GC, so prototyping language can do whatever they want without caring about memleak  That isn't exactly true.",0.35,go
15a4z4c,jtimopj,"However, if you have a specific goal in mind for your language(like adding a type system to an already existing dynamic language(TypeScript-style), or to be used instead of another language in a certain niche (like JavaScript in webdev, Elm-style), then you need to make choices based on that goal/niche.",0.07142857142857142,javascript
15a4z4c,jtinneo,Go is also a pretty simple language so you’re not going to get bogged down in trying to do fancy syntax tricks or messing around with language features.,-0.0263888888888889,go
15a4z4c,jtixdrn,If you want what Go provides then sure.,0.5,go
15a4z4c,jtixdrn,"I think the biggest issue is that GC and the various runtime magic Go uses makes it hard to support in webassembly, which makes it hard to provide online demos.",-0.020833333333333343,go
15a4z4c,jtixdrn,You might want to consider targeting JS instead of or in addition to Go in order to make it easy to provide in-browser demos.,0.43333333333333335,go
15a4z4c,jtm5jgi,"I need to write a new backend in Go to replace my treewalker, so it's this route or a VM.",0.13636363636363635,go
15a4z4c,jtjb88l,"If you want a target language that is not C, Rust is probably the best replacement.",1.0,c
15a4z4c,jtjb88l,"If you want a target language that is not C, Rust is probably the best replacement.",1.0,rust
15a4z4c,jtjb88l,"That gets you easy ffi to the C abi, more supported architectures, and, potentially, support for embedded devices.",0.3111111111111111,c
15a4z4c,jtjb88l,"Go has some fun footguns you will inherit, like their slice invalidation and “default values” which cause a lot of issues.",0.3,go
15a4z4c,jtizalo,">runtime magic Go uses makes it hard to support in webassembly  Go is one of the easier languages to compile to WASM, second only to Rust.",0.05208333333333333,go
15a4z4c,jtizalo,">runtime magic Go uses makes it hard to support in webassembly  Go is one of the easier languages to compile to WASM, second only to Rust.",0.05208333333333333,rust
15a4z4c,jtkqen4,"I really want to see a successful case of someone compiling a non-Rust-like language to Rust, because it sounds like a nightmare to me.",0.475,rust
15a4z4c,jtkqen4,"And since OP is interested in simply borrowing Go's GC, they're probably interested in supporting programs that are worst-case for Rust codegen.",0.1875,go
15a4z4c,jtkqen4,"And since OP is interested in simply borrowing Go's GC, they're probably interested in supporting programs that are worst-case for Rust codegen.",0.1875,rust
15a4z4c,jtkqen4,"And to be clear, I'm a Rust enthusiast so I'd love to be proven wrong, but it really doesn't seem like the right use case.",0.11714285714285713,rust
15a4z4c,jtm9nd2,Compilation speed for rust is a no go for me.,0.0,rust
15a4z4c,jtm9nd2,Compilation speed for rust is a no go for me.,0.0,go
15a4z4c,jtm9nd2,"If I want C ABI, why not just use C?",0.0,c
15a4z4c,jtjw9ut,"Imo, a proper ownership model with RAII is really all you need for memory management - especially if your language is more strict about object lifetimes then eg C++.",0.175,c++
15a4z4c,jtjp9ck,"WASM applications for the web benefit from having super tiny sizes, and having to generate code for the Go runtime is not great in that regard.",-0.022222222222222237,go
15a4z4c,jtm6xbn,"> I really want to see a successful case of someone compiling a non-Rust-like language to Rust  That's pretty much what procedural macros are for, and there are lots of examples of proc-macro based custom DSLs.",0.35,rust
15a4z4c,jtm6xbn,"I've also personally worked with Rust code-generation based on a custom SQL DSL (and yes it deals with lifetimes), and I'm sure there are plenty other examples.",0.125,rust
15a4z4c,jtm6xbn,"Not saying that Rust is a good call, but I also don't think it's as bad as you say.",5.551115123125783e-17,rust
15a4z4c,jtm0bdy,AFAIK TinyGo doesn't support all of Go's features and is thus not really a fair comparison.,-0.35,go
15a4z4c,jtm0bdy,It seems like Go might not currently be a good fit for that.,0.025000000000000022,go
15a4z4c,jtm0ozf,Does it really need to support all of Go’s features as a compilation target?,0.2,go
15a4z4c,jtm276x,"There’s also Go Assembly, but it might be too low level, and it might not solve the size problem, as the size is almost certainly caused by the linked in stdlib.",0.10714285714285714,go
15a4z4c,jtm276x,"There’s also Go Assembly, but it might be too low level, and it might not solve the size problem, as the size is almost certainly caused by the linked in stdlib.",0.10714285714285714,assembly
15a4z4c,jtm33x2,"I have expressed no opinion on Go as a compiler target per se, I just gave my opinion about Go and WASM in general.",0.05000000000000002,go
15a4z4c,jtm33x2,I don't really see what targeting Go gives you in that situation.,0.2,go
15a4z4c,jtm4iws,"Go assembly, WebAssembly and ""real"" assembly are different things and don't operate on the same level at all.",0.06666666666666667,go
15a4z4c,jtm4iws,"Go assembly, WebAssembly and ""real"" assembly are different things and don't operate on the same level at all.",0.06666666666666667,assembly
15a4z4c,jtm4iws,"In any case it certainly wouldn't solve any bundle size problems as that has to do with Go as a language and its features, not with how it's assembled.",0.21428571428571427,go
159srd8,,[Flark Playground](https://flark.vercel.app)  I use flexbox everywhere in html.,0.0,html
159srd8,jti5zay,"Personally I prefer https://github.com/weavejester/hiccup, but maybe that's because I'm from the lisp tribe and I am based, but the way you integrate code seamlessly with data is very elegant.",0.25,lisp
159b6sn,,EDIT: just realized that haskell have both NAN and INF included in the language.,0.0,haskell
159b6sn,jtg1e56,"So no matter what the option are either: don't think about it, or go deep into understanding what the issue is.",0.0,go
159b6sn,jtg8w5g,"Java’s `int`/`char` types and C/++’s unsigned integral types) is of far more practical use than any infinity would be, and this behavior can be used for tricks like single-comparison bounds checks (𝑥−𝑎 ≤ᵤ 𝑏−𝑎 ↔ 𝑥∈{[𝑎, 𝑏]}).",0.3,java
159b6sn,jtebawk,"Although it's for floating point, I think the concept is cool.",0.35,cool
159b6sn,jthnvsg,"There is interval arithmetic, and some languages and compilers support it (at least one Fortran compiler had vendor-specific interval arithmetic language extension).",-0.3,fortran
159b6sn,jten3tw,"`(get-real-exact-bounds r)` returns a pair of exact real numbers `(a b)`, where `a <= r`, and  `r <= b`.",0.225,r
159b6sn,jten3tw,"`(get-real-exact-primary r)` returns an exact real number `x` where `a <= x <= b`, where `x` is as close to `r` as possible.",0.15,r
159b6sn,jten3tw,"`(get-real-internal-bounds r)` returns a pair of *inexact* real numbers `(c d)`, where `c` and `d` are encoded with the same internal encoding as `r`, and  `c <= r <= d`.",0.06666666666666667,r
159b6sn,jten3tw,"`(get-real-internal-bounds r)` returns a pair of *inexact* real numbers `(c d)`, where `c` and `d` are encoded with the same internal encoding as `r`, and  `c <= r <= d`.",0.06666666666666667,c
159b6sn,jten3tw,"`(get-real-internal-bounds r)` returns a pair of *inexact* real numbers `(c d)`, where `c` and `d` are encoded with the same internal encoding as `r`, and  `c <= r <= d`.",0.06666666666666667,d
159b6sn,jten3tw,"`(get-real-internal-primary r)` returns an *inexact* real number `y` where `c <= y <= d`, which uses the same internal encoding as `r`.",0.06666666666666667,r
159b6sn,jten3tw,"`(get-real-internal-primary r)` returns an *inexact* real number `y` where `c <= y <= d`, which uses the same internal encoding as `r`.",0.06666666666666667,c
159b6sn,jten3tw,"`(get-real-internal-primary r)` returns an *inexact* real number `y` where `c <= y <= d`, which uses the same internal encoding as `r`.",0.06666666666666667,d
159b6sn,jten3tw,If the value `y` is equal to `r` the number is *robust*.,0.0,r
159b6sn,jteu5yn,"In Lua, they go as far as using the name `math.huge` for the floating point infinity value to emphasize that it just represents a quantity that is too big to fit in a float and not necessarily a singular value representing all infinities.",0.125,lua
159b6sn,jteu5yn,"In Lua, they go as far as using the name `math.huge` for the floating point infinity value to emphasize that it just represents a quantity that is too big to fit in a float and not necessarily a singular value representing all infinities.",0.125,go
159b6sn,jtht25o,In COBOL you got to choose rounding strategy.,0.0,cobol
159b6sn,jtkuqhf,In lazy languages (like haskell) it can sometimes make sense to include infinity in the type of naturals.,-0.25,haskell
159b6sn,jtkuqhf,In fact the usual inductive definition (`data Nat = Zero | Succ Nat`) already includes infinity (in haskell) by `inf = Succ inf`.,-0.25,haskell
159b6sn,jtkuqhf,(Because haskell makes no distinction between data and codata and these natural numbers are in fact the conatural numbers).,0.1,haskell
159b6sn,jtomw9o,Cool!,0.4375,cool
159b6sn,jtomw9o,So instead you extend the arithmetical expressions as far as they'll go.,0.1,go
159b6sn,jtomw9o,"Letting `a`,`b`,`c`,`d` be integers, define:  * Addition: `frac(a,b) + frac(c,d) = frac(a*d + b*c, b*d)` * Multiplication: `frac(a,b) * frac(c,d) = frac(a*c, b*d)` * Division: `frac(a,b) / frac(c,d) = frac(a*d, b*c)` * Equality\[-ish\]: `eq(frac(a,b), frac(c,d)) = eq(a*d, b*c)`  There's no problem letting `p=0` (infinity) or `p=q=0` (NaN) in `frac(p,q)`.",0.0,c
159b6sn,jtomw9o,"Letting `a`,`b`,`c`,`d` be integers, define:  * Addition: `frac(a,b) + frac(c,d) = frac(a*d + b*c, b*d)` * Multiplication: `frac(a,b) * frac(c,d) = frac(a*c, b*d)` * Division: `frac(a,b) / frac(c,d) = frac(a*d, b*c)` * Equality\[-ish\]: `eq(frac(a,b), frac(c,d)) = eq(a*d, b*c)`  There's no problem letting `p=0` (infinity) or `p=q=0` (NaN) in `frac(p,q)`.",0.0,d
159b6sn,jtebss1,"I know, rust does ~~this~~what you said.",0.0,rust
159b6sn,jti7c5a,"In Elm, 1 / 0 = 0.",0.0,elm
159b6sn,jtjj30f,"On some chips, normalised floats can go through a hardware fast path while denormals fall back to a slower microcode implementation.",0.1,go
159b6sn,juc1201,"The numbers my Pascal compiler could represent in an integer type variable was the integer range -32767..32767, not a lot.",0.0,pascal
1597agi,,The best resource that I found so far is Lua source code (and different Lua implementations) or write ups about it.,0.3666666666666667,lua
1597agi,,"Lua with high interoperability with C in mind, looks rather clunky and I believe dedicated implementation may be much better in terms of performance and cleanness.",0.33,lua
1597agi,,"Lua with high interoperability with C in mind, looks rather clunky and I believe dedicated implementation may be much better in terms of performance and cleanness.",0.33,c
1597agi,jtenpy3,"I've been researching this recently, so I've got a few good resources:  - [Green Threads Explained](https://c9x.me/articles/gthreads/intro.html) - [Coroutines in Less than 20 Lines of Standard C](https://dotat.at/@/2010-01-22-coroutines-in-less-than-20-lines-of-standard-c.html) - [libaco, a fast coroutine library](https://github.com/hnes/libaco) - [ Implementing Co, a Small Language With Coroutines](https://abhinavsarkar.net/posts/implementing-co-1/)  Lua's coroutine implementation is really great and it inspired both of the C implementations I linked, but it's pretty tightly coupled to the language/VM so it's not easy to understand how it works from reading the source code.",-0.0009157509157509189,c
1597agi,jtenpy3,"I've been researching this recently, so I've got a few good resources:  - [Green Threads Explained](https://c9x.me/articles/gthreads/intro.html) - [Coroutines in Less than 20 Lines of Standard C](https://dotat.at/@/2010-01-22-coroutines-in-less-than-20-lines-of-standard-c.html) - [libaco, a fast coroutine library](https://github.com/hnes/libaco) - [ Implementing Co, a Small Language With Coroutines](https://abhinavsarkar.net/posts/implementing-co-1/)  Lua's coroutine implementation is really great and it inspired both of the C implementations I linked, but it's pretty tightly coupled to the language/VM so it's not easy to understand how it works from reading the source code.",-0.0009157509157509189,lua
1597agi,jtenpy3,"If you spend some time working with Lua coroutines, I think you'll find it's a really elegant solution to the [What Color Is Your Function?",0.5,lua
1597agi,jtg9mrp,"You might want to look at implementation strategies for (single shot) delimited continuations or, more recently, effect handlers, for example in Chez Scheme or OCaml 5.These are effectively a different perspective on the same feature.",0.08571428571428572,scheme
1597agi,jtg9mrp,Just be careful around resource acquisition if you want to go down that route.,-0.1277777777777778,go
1597agi,jte3p89,"This was written long before Python implemented `async`, and has efficient low level coroutine switching (in assembler) for x86, x86_64, arm, arm64, ppc_osx (that dates it!)",-0.025,python
1597agi,jtfb8nr,"C# has generators which are compiled to state machines, and can be used as coroutines (e.g.",0.0,c
1597agi,jtfb8nr,You can use sharplab.io to see how they are lowered to simple C# code before compilation.,0.0,c
1597agi,jtfb8nr,"Not sure whether that satisfies your definition of coroutines, but it's been battle-tested in huge systems for many years at this point, and the C# compiler is open source.",0.16250000000000003,c
1597agi,jtixemv,This article has a good x86 assembly snippet for a [fast swapcontext](https://rethinkdb.com/blog/making-coroutines-fast/) with some discussion of why the one provided by uncontext.h in glibc is slow.,0.19999999999999996,assembly
1597agi,jtoxdw3,"The code is well commented, written in C and has proper coroutine implementation (stackful).",0.0,c
1597agi,jtt7af9,"I'm not expert but I played with Protothreads in C, but that's not really proper coroutines.",0.0,c
1597agi,jtt7af9,I also have some assembly I poorly ported from Marce's blog post which is down unfortunately  [https://github.com/samsquire/assembly/blob/main/coroutines.S](https://github.com/samsquire/assembly/blob/main/coroutines.S)  [https://blog.dziban.net/coroutines/](https://blog.dziban.net/coroutines/) (down at the moment due to SSL error),-0.26722222222222225,assembly
1597agi,jtfkwp8,"Reddit must be reading my mind somehow because I was literally pacing around my room thinking about how to implement coroutines in my language written in C just before logging into Reddit to take a break, seeing this post and then this comment lol.",0.8,c
1597agi,jtgalr6,"Lua's coroutines are only ""colorless"" in the sense that there is no compiler yelling at you for using a function in the wrong context, but that just moves the error to runtime, which is arguably *worse*.",-0.3,lua
1597agi,jtgbn9l,"That is a very different system from Lua's, which are stackful.",0.0,lua
1597agi,jtgbn9l,"But yeah, C#/Roslyn would be a good place to look for an implementation of stackless coroutines",0.7,c
1597agi,jthfpg6,I think you're perhaps not understanding how Lua's coroutines work ([explainer](https://www.lua.org/pil/9.1.html)).,0.0,lua
1597agi,jthfpg6,"Here's an example with Lua:      function map(fn, values)         local result = {}         for i,x in ipairs(values) do             result[i] = fn(x)         end         return result     end      -- Same whether `foo` yields or not:     result = map(foo, blah)  Versus Python:      def map(fn, values):         return [fn(x) for x in values]      # If `foo` isn't async, we can do this:     result = map(foo, blah)      # But if it is async, we gotta define an async version:     async def map_async(async_fn, values):         return [await async_fn(x) for x in values]      # And be sure to await the call:     result = await map_async(foo, blah)  I think if you spend an appreciable amount of time working with Lua's coroutines, you'll find it's a breath of fresh air and much more pleasant to work with.",0.33888888888888885,lua
1597agi,jthfpg6,"Here's an example with Lua:      function map(fn, values)         local result = {}         for i,x in ipairs(values) do             result[i] = fn(x)         end         return result     end      -- Same whether `foo` yields or not:     result = map(foo, blah)  Versus Python:      def map(fn, values):         return [fn(x) for x in values]      # If `foo` isn't async, we can do this:     result = map(foo, blah)      # But if it is async, we gotta define an async version:     async def map_async(async_fn, values):         return [await async_fn(x) for x in values]      # And be sure to await the call:     result = await map_async(foo, blah)  I think if you spend an appreciable amount of time working with Lua's coroutines, you'll find it's a breath of fresh air and much more pleasant to work with.",0.33888888888888885,python
1597agi,jtgvtwk,"I've been reading through chapter 9 of the book on lua.org and from what I understand, the main difference is that Lua coroutines allow yielding from deeper within the callstack.",0.16666666666666666,lua
1597agi,jtgvtwk,Whereas in C# (or python) all yields need to be in the generator function itself.,0.0,c
1597agi,jtgvtwk,Whereas in C# (or python) all yields need to be in the generator function itself.,0.0,python
15950o0,jte21wd,Is the lecture you're referring to the one on Go's metaprogramming?,0.0,go
15950o0,jthc5ev,"Using setjmp/longjmp you can make the common path through the loop as tight as possible (at least, as tight as is possible in C without guaranteed Tailcalls).",-0.1595238095238095,c
15950o0,jtma6ty,"https://research.swtch.com/coro  > For example, Rob Pike's 2011 talk “Lexical Scanning in Go” presents the original lexer and parser for the text/template package.",0.375,go
15950o0,jtma6ty,"I guess you had to use a state machine since it's in C, not Go.",0.0,c
15950o0,jtma6ty,"I guess you had to use a state machine since it's in C, not Go.",0.0,go
15950o0,jtma6ty,But to be honest I don't see the similarity between this C code and what's in the video (as I remember watching it many years ago).,0.55,c
15950o0,jtjr4yh,"> Using setjmp/longjmp you can make the common path through the loop as tight as possible (at least, as tight as is possible in C without guaranteed Tailcalls).",-0.1595238095238095,c
15950o0,jtjr4yh,"The loop/switch compiles down to just a single jump instruction with no need to do the function call song and dance and no conditional checks at all:      while (1) {         switch (state) {         case INIT:             // do whatever             state = VALIDATE;             break;         case VALIDATE:             // do whatever             state = TERMINATE;             break;         case ERROR: return LexFailure;         case TERMINATE: return LexSuccess;         }     }  Your suggestion of using setjmp/longjump is good for something like a recursive descent parser though, where you want to immediately stop parsing and go to error handling code from deep within a call tree.",0.11825396825396824,go
15950o0,jtnm4ud,"You can have Goroutines in C too, I guess a light-weight call to clone3 would do it.",0.0,c
15950o0,jths30d,"This is in general quite dangerous as raw C doesn't have stack unwinding, so you need to be quite careful that you don't skip any de-initialization that was supposed to happen (e.g.",-0.22019230769230766,c
15950o0,jths30d,But for specific low-level problems it does something you can't do in C otherwise: 'goto' a location outside of the current function.,0.0,c
15950o0,jtjtvu9,I think both C and C++ would benefit from a `[[tailcall]]` attribute you could apply to a return statement that explicitly enables tail calling -- losing the debugging property of the stack trace in exchange for the guaranteed reclamation of the stack space used by the current function.,0.0,c
15950o0,jtjtvu9,I think both C and C++ would benefit from a `[[tailcall]]` attribute you could apply to a return statement that explicitly enables tail calling -- losing the debugging property of the stack trace in exchange for the guaranteed reclamation of the stack space used by the current function.,0.0,c++
15950o0,jtk7w6u,"You _can_ do stack unwinding in safe C, by manually maintaining a singly-linked list of destructors stored on stack frames, and iterating over it before `longjmp`ing.",0.5,c
1592mvm,jtdbv12,"If you’re interested in a typed Prolog and term rewriting, you should definitely check out [λ-Prolog](https://www.lix.polytechnique.fr/~dale/lProlog/).",0.125,prolog
1592mvm,jtdyvnc,IMO it's sort of a shame that most Prolog alternatives aren't too popular.,0.55,prolog
1592mvm,jtdyvnc,"People already mentioned lambda prolog and Mercury; I think the former uses an HM type system, and the second has you annotate predicates.",0.0,prolog
1592mvm,jth9z0t,"There's [lambda prolog](https://en.wikipedia.org/wiki/%CE%9BProlog) but I like [Shen](https://shenlanguage.org/)'s approach in implementing a type system in prolog itself, basically as a DSL.",0.0,prolog
1592mvm,jth9z0t,"Ideally, I would like to see something like [this framework](https://github.com/kyledewey/typed-prolog) greatly improved and ship with prolog as a standard library and optional integrated type system.",0.5666666666666668,prolog
1592mvm,jtd0z0r,"Sometimes, it's worth it just for fun, so go for it.",0.3,go
1592mvm,jte5308,"that you want to use as a template, and later try to emulate Prolog declarations, maybe using some collection.",0.0,prolog
1592mvm,jtfbqxx,Prolog is so cool.,0.35,prolog
1592mvm,jtfbqxx,Prolog is so cool.,0.35,cool
1592mvm,jtu9gdb,It's like Prolog on steroids built into a statically typed functional language.,0.0,prolog
1592mvm,jtp7hah,"I must shamefully admit that I have never used Prolog, but I know there is a Danish company - Prolog Development Center - that has been developing and selling a Prolog system since back in the 80es.",-0.05,prolog
1592mvm,jtp7hah,"It of course commercial, and has even been marketed by Borland as Turbo Prolog, also as PDC Prolog and now apparently Visual Prolog.",0.0,prolog
1592mvm,jtp7hah,"If I remember correctly what I read about it many years ago, it is indeed a Prolog version with a type system, and I would think it is a static type system.",0.5,prolog
1592mvm,jtvn5tq,At least from the examples given on the website it's weaker than prolog.,-0.3,prolog
1592mvm,jtvn5tq,"In prolog logic is first class, because you represent everything with logic relation.",0.25,prolog
1592cw0,,"Basically CppFront is what I mean, its transpiler doesn't perform any semantic analysis (AFAIK) over code but just translate a new syntax in the corresponding C++, this allows the transpiler to insert useful stuff in the transpiled version, like const-by-default or order independent for function declarations.",0.030965909090909086,c++
1592cw0,,"My personal opinion is not formed at all because I usually firstly need to use something because making a personal consideration of it, but generally I don't like the idea of having errors from clang/gcc over a c++ source code (which is never 1:1 with cpp2) when compiling cpp2.",0.07500000000000001,c++
1592cw0,jteq75t,"I've spent a lot of time programming in [Moonscript](https://moonscript.org/), which cross-compiles into Lua.",-0.1,lua
1592cw0,jteq75t,"Moonscript was inspired by Coffescript, which was a similar project for javascript.",0.0,javascript
1592cw0,jteq75t,I really like using Moonscript because it smooths over some of the clunky parts of Lua (e.g.,0.2,lua
1592cw0,jtd30b9,"It kinda limits what you can do in your syntax sugar, but if your target language is C++ *and* your source language is supposed to be roughly the same size/power/complexity, there is only so much you can do.",0.025,c++
1592cw0,jte7327,"**  The original ""C with Objects"" transpiler that turned ""Plain C"" into ""C++"" compiler, is an example of that.",0.08035714285714286,c
1592cw0,jte7327,"**  The original ""C with Objects"" transpiler that turned ""Plain C"" into ""C++"" compiler, is an example of that.",0.08035714285714286,c++
1592cw0,jte7327,"interface where they can be executed as a Library function, instead of a command line or shell program, but I ignore if GNU C or LLVM does.",0.0,shell
1592cw0,jte7327,"interface where they can be executed as a Library function, instead of a command line or shell program, but I ignore if GNU C or LLVM does.",0.0,c
1592cw0,jtds5j5,"What if every language had a lisp core, and the language syntax module would be a separate module which can be replaced by your own one and configured",0.6,lisp
1592cw0,jtgs7wq,I think that's what makes CPP2 or Cppfront so much better than say something like elixir or something else that just compiles straight to an underlying language but it really is just syntax sugar for not wanting to program in the underlying target language directly.,0.24999999999999997,elixir
1592cw0,jtgs7wq,"But if along with the syntax sugar it compiles for example to a safer, easier to debug and use subset of a language ( man I wish there was a C language version of Cppfront) then yes I would definitely appreciate something like that.",0.0,c
1592cw0,jtetw47,What's about targetting a c++ like language in your opinion?,0.0,c++
1592cw0,jthh2b8,"Lua (and Javascript) are both very simple languages, so they work well as a set of primitives that you can build other language constructs out of (e.g.",-0.0625,lua
1592cw0,jthh2b8,"Lua (and Javascript) are both very simple languages, so they work well as a set of primitives that you can build other language constructs out of (e.g.",-0.0625,javascript
1592cw0,jthh2b8,It's not hard to build a language that is a superset of Lua or Javascript.,0.14583333333333334,lua
1592cw0,jthh2b8,It's not hard to build a language that is a superset of Lua or Javascript.,0.14583333333333334,javascript
1592cw0,jthh2b8,"When it comes to C++, it's such an enormously complex language that I think it would be difficult to write a sugar language isn't just transpiling to a very narrow subset of C++.",-0.265,c++
1592cw0,jte2h8e,"""class"" takes a name, inheritance list, members list), and that's what lisp is.",0.0,lisp
158iyza,,I have read dozens of articles and posts praising LISP and how it gives you supernatural abilities.,0.16666666666666666,lisp
158iyza,,Many people claim that languages of the LISP family make you incredibly productive.,0.7,lisp
158iyza,,"Are myths around LISP slightly exaggerated, or am a missing important points that make this family of languages as good as some people claim?",0.1,lisp
158iyza,,Is the significance of LISP nowadays mostly historical?,0.0,lisp
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,lisp
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,typescript
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,rust
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,haskell
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,python
158iyza,,"For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,c
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,lisp
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,scheme
158iyza,,"I also wonder if the answer to my question is different between the most common dialects: Common Lisp, Scheme, Clojure.",-0.024999999999999994,clojure
158iyza,jtb7bpb,"I put Lisp in the same category as Pink Floyd and ""Zen and the Art of Motorcyle Maintenance"".",-0.05,lisp
158iyza,jtb7bpb,"If you stumble onto Lisp in your 30s after a decade of interest in programming languages where you've absorbed most of its ideas piecemeal, it will not blow your socks off.",0.25,lisp
158iyza,jtb7bpb,"But if you're 18 and thought you were hot shit because you wrote a 1,000 line Pascal program, your first shot of Lisp could be very mind-expanding.",0.125,pascal
158iyza,jtb7bpb,"But if you're 18 and thought you were hot shit because you wrote a 1,000 line Pascal program, your first shot of Lisp could be very mind-expanding.",0.125,lisp
158iyza,jtatbfg,"The [Coalton programming language](https://github.com/coalton-lang/coalton) is a strongly, statically, strictly typed programming language with eager evaluation (a la ML) and type classes (a la Haskell).",0.4333333333333333,haskell
158iyza,jtatbfg,"Its implementation—an optimizing compiler—is ""just"" a Lisp macro, which makes it a DSL that one can use within or adjacent to Common Lisp.",-0.3,lisp
158iyza,jtatbfg,Has Lisp historically (and sometimes anachronistically) been hyped up beyond rationality?,0.0,lisp
158iyza,jtadp04,"put another way, what would you say to someone who said, ""i'm used to c, which makes writing higher-order functions hard.",-0.2916666666666667,c
158iyza,jtb7mjl,"I think, and others who I know and talk to and work with, unfortunately only for fun at the moment, in the lisp/scheme world agree with me (and you read the sentiment online often), is that when you are lucky enough to have a career where you can do fulltime Common Lisp or, even better, where you go in and out of lisp to other languages and then back, that you keep wondering, with greater and greater confusion, why everyone is making their life so hard and often quite painful.",0.05972222222222221,lisp
158iyza,jtb7mjl,"I think, and others who I know and talk to and work with, unfortunately only for fun at the moment, in the lisp/scheme world agree with me (and you read the sentiment online often), is that when you are lucky enough to have a career where you can do fulltime Common Lisp or, even better, where you go in and out of lisp to other languages and then back, that you keep wondering, with greater and greater confusion, why everyone is making their life so hard and often quite painful.",0.05972222222222221,go
158iyza,jtb7mjl,"I go in and out of lisp unfortunately, but having had 3 years of fulltime c# and, worse, typescript (the language is fine, but omfg the ecosystem), I now wonder daily if this is worth my time and life when I could also be programming CL instead.",-0.03666666666666667,go
158iyza,jtb7mjl,"I go in and out of lisp unfortunately, but having had 3 years of fulltime c# and, worse, typescript (the language is fine, but omfg the ecosystem), I now wonder daily if this is worth my time and life when I could also be programming CL instead.",-0.03666666666666667,lisp
158iyza,jtb7mjl,"I go in and out of lisp unfortunately, but having had 3 years of fulltime c# and, worse, typescript (the language is fine, but omfg the ecosystem), I now wonder daily if this is worth my time and life when I could also be programming CL instead.",-0.03666666666666667,c
158iyza,jtb7mjl,"I go in and out of lisp unfortunately, but having had 3 years of fulltime c# and, worse, typescript (the language is fine, but omfg the ecosystem), I now wonder daily if this is worth my time and life when I could also be programming CL instead.",-0.03666666666666667,typescript
158iyza,jtb7mjl,"Besides the libraries (which are mostly total crap anyway and so I find myself really often fixing trivial bugs in the npms I download or discard them altogether, far less so in c#), ‘almost native’ web support and the enormous community, I cannot find love for TS and definitely not js.",-0.020833333333333343,c
158iyza,jtb7mjl,"I have been programming for over 30 years, starting with basic and I like programming languages for being programming languages (I don’t care what is the best tool for the job ; i like a language or I don’t or I have to use it because of the job) and I keep coming back to Common Lisp as the winner.",0.13999999999999999,lisp
158iyza,jtb7mjl,"Many people I know have this, none of them can use it for their job, but would drop 50% pay to work with it fulltime, as would I. I did clojure for 1 year fulltime and CL for 1.5 year in the same company; it’s hard going back to scratching hieroglyphs in a cave wall after that (although I don’t really like clojure compared to cl).",0.08166666666666667,clojure
158iyza,jtb7mjl,"But, for a company, a huge risk: you cannot find lisp programmers ; they are just too rare.",0.35000000000000003,lisp
158iyza,jtb7mjl,"Also because of those macros and other things that make lisp a super tool: it is very hard to jump into a large project that is basically a bunch of DSLs put together, all designed around the problem and it’s implementation.",0.01086309523809522,lisp
158iyza,jtb0zdt,"If you can stick through the few boring bits (the course was aimed at engineers at MIT so most examples have to do with engineer-y things like modeling electrical circuits etc), then I think it'll leave you with a sense of awe and an understanding of why people make the claims they make about Lisp.",-0.2333333333333333,lisp
158iyza,jtb0zdt,"EDIT: It's not a course on Lisp, it's a course on the essence of what we call ""Computer Science"" (the very beginning of the very first lecture talks about how CS is not really a good term for this).",0.05833333333333335,lisp
158iyza,jti9ptd,"If OOP is pragmatic like Windows, and FP is elegant like Mac, then Lisp is more like Linux where _everything_ is hackable and you're free to do anything.",0.4666666666666666,lisp
158iyza,jti9ptd,"I seriously believe we have still only just dipped our toes into what Lisp can actually do, and there are more techniques left to discover",0.03333333333333334,lisp
158iyza,jtaimo4,"Some languages do a good job of replicating the lisp repl experience, others not so much, or not at all.",0.44999999999999996,lisp
158iyza,jtaimo4,"Since most lisp dialects are dynamically typed functional languages, you can quickly build abstractions which allow for a wide array of functionality with relatively minimal code.",0.15833333333333333,lisp
158iyza,jtaimo4,With macros you can build powerful DSLs with minimal code which desugar directly into lisp code.,0.09999999999999999,lisp
158iyza,jtarnpd,"Common Lisp is similar to Chinual Lisp, is vast, and not really a strictly functional language.",-0.1,lisp
158iyza,jtarnpd,"Scheme is minimalistic and strongly functional, and very pure and beautiful, but not terribly useful for complex applications (Racket is a expanded version that's better suited for that).",0.26865079365079364,scheme
158iyza,jtarnpd,"Clojure is also strongly functional, but introduces other data types such as vectors, has interop with Java and includes constructs specially designed for concurrency.",0.1663690476190476,clojure
158iyza,jtarnpd,"Clojure is also strongly functional, but introduces other data types such as vectors, has interop with Java and includes constructs specially designed for concurrency.",0.1663690476190476,java
158iyza,jtc1o5a,"Programming in Lisp is like programming directly in an abstract syntax tree that can modify itself, with all the wonder and horror this entails.",0.1,lisp
158iyza,jtav0ds,"From what I can gather, Lisp is truly magical:  * It can be both compiled and interpreted (or both at the same time) * It can be both statically and dynamically typed * It can be both imperative and functional * Code can be data, and data can be code * It can be implemented entirely in itself starting from a minimal version that can be described in one page, right up to Clisp that needs 1000 pages  It can do everything, and there is nothing it can't do.",0.11428571428571428,lisp
158iyza,jtcqjd8,"advantages that are no longer unique to Lisp), and it also depends on your use case.",0.375,lisp
158iyza,jtcqjd8,"Personally, I find statically typed functional languages (ML, Haskell, etc.)",0.0,haskell
158iyza,jtcqjd8,a lot more powerful and mind-blowing than lisp.,0.4,lisp
158iyza,jtcf3l7,"I've done a few hobby projects in Common Lisp, and to me, the magic of Lisp is not entirely the macros.",0.0,lisp
158iyza,jtcf3l7,"Macros are a part of that, and a part of the reason it's easier to build those tools in Lisp than in other languages, but it's not the whole thing.",0.037500000000000006,lisp
158iyza,jtcf3l7,"It's fairly trivial in Common Lisp to write games while they are running, deploy a stubbed out webserver and remotely live-code it into existence, debug and modify a Kafka processor while it is mid-stream and running in the test Kubernetes cluster, and so on.",0.09999999999999998,lisp
158iyza,jtcf3l7,All with the safety harness of the condition-capturing REPL and pervasive data inspector in Common Lisp REPLs.,-0.3,lisp
158iyza,jtcf3l7,"Macros help by reducing boilerplate and helping humans to reason about the program, but it's not entirely the reason people are devoted to Lisp.",-0.05,lisp
158iyza,jtad7q9,"If the pros of LISP really outweighed the cons, it would be more widely used to create software...",0.19999999999999998,lisp
158iyza,jtad7q9,"In short, people don't care that you can do X or Y with LISP because the use case for X and Y isn't that critical.",0.0,lisp
158iyza,jtrab9n,And ... way to go!,0.0,go
158iyza,jtrab9n,The proper language to break your brain on is FORTH.,0.0,forth
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,lisp
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,fortran
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,cobol
158iyza,jtrab9n,"LISP, FORTRAN, COBOL, and ALGOL are all contemporaries.",0.0,algol
158iyza,jtrab9n,"Of those, the language with the greatest staying power has been COBOL, and by a country mile.",1.0,cobol
158iyza,jtrab9n,COBOL systems have been running continuously under maintenance for approximately since computers had transistors.,-0.4,cobol
158iyza,jtrab9n,You don't write `makeCall(makeIdentifier...etc.etc.` because lisp does not have function-call *syntax*.,0.0,lisp
158iyza,jtrab9n,Lisp absolutely has syntax.,0.2,lisp
158iyza,jtrab9n,What makes Lisp interesting is the semantics.,0.5,lisp
158iyza,jtrab9n,"For a long time PL researchers tried experimenting with extensible syntax as we know the term ""syntax"" from languages like BASIC and Perl.",-0.025,perl
158iyza,jtrab9n,But there is `define-syntax` in scheme?,0.0,scheme
158iyza,jtrab9n,"Therefore, to your question about why macros are such a big deal, I think it is because the *elemental core* of LISP (eval/apply) has a paucity of semantics *and so did every other language* for the first 50 years of Lisp's existence.",0.03125,lisp
158iyza,jtrab9n,That is why I think it's disingenuous to call Lisp a superpower.,0.0,lisp
158iyza,jtbgz75,I like the Lisp family a lot.,0.0,lisp
158iyza,jtbgz75,But the real answer imo is that it was 30 years ago when Lisp was super awesome compared to mainstream alternatives.,0.5111111111111111,lisp
158iyza,jtbgz75,"(Yes, there were other forward-looking alternatives like SML and Prolog, and I liked them too.",0.2375,prolog
158iyza,jtbgz75,But Lisp was more generally practical.),0.275,lisp
158iyza,jtbugo6,*[I just noticed that there isn't a lisp in this set.,0.0,lisp
158iyza,jtbugo6,"I suspect that Lisp would do well here in terms of text size, but not so much less in terms of constructs e.g.",-0.16666666666666666,lisp
158iyza,jtbugo6,It's telling or surprising that no one chose a lisp.,0.7,lisp
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,rust
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,haskell
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,c++
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,python
158iyza,jtbugo6,"]*  The best article I've found that compared the expressiveness of languages is this article [""Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml""](https://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/).",0.5,scala
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,rust
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,haskell
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,c++
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,python
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,assembly
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,scala
158iyza,jtbugo6,"Rust (baseline) 1.0x -- smaller using hand-written lexer and recursive descent parsing, mutation using visitor  Haskell 1.3x -- NFA -> DFA lexer generator, LR parser -> AST, full tree rewrites  C++ 1.4x -- LR parser and tree rewriter, lack of sum types and pattern matching, header files (subjectively estimated compile times similar to Rust baseline)  Python 0.5x -- most extra features, LR parser, dynamic typing just set new fields on AST, introspect fields via __dict__, metaprogramming with eval code snippits  Rust (another team) 3x -- DFA lexer and LALR(1) parser, fully typed parse tree instead string-based, TryFrom vs Result, boolean field/constraints and return type multiplication factor, data structure for assembly instructions  Scala 0.7x -- use provided cmdline LR table generator, Python script translated scraped Java grammar from web page.",0.1409090909090909,java
158iyza,jtbugo6,"(compared to Rust baseline somewhat more expressive with more syntactic sugar and no borrow-checker to make happy)  OCaml 1.15x -- LR parser generator and tree rewriting for parsing, as well as a regex->NFA->DFA conversions for lexing.",0.65,rust
158iyza,jtbugo6,(Rust and OCaml seem similarly expressive except that OCaml needs interface files and Rust doesn’t.),0.8,rust
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,lisp
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,typescript
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,rust
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,haskell
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,python
158iyza,jtcpyue,"> For context, I am mentally comparing LISP with other languages I have the most experience with: TypeScript, Rust, Haskell, Python, C#.",0.09166666666666667,c
158iyza,jtcpyue,In order to understand the praise of the power of LISP you need to understand the context in which this praise was given.,0.0,lisp
158iyza,jtcpyue,LISP started the GC approach.,0.0,lisp
158iyza,jtcpyue,"So, when you think about what LISP brought to the scene, imagine a world without automated memory management.",0.0,lisp
158iyza,jtcpyue,"Sure, if you have Haskell experience, these things do not seam like a big deal in comparison BUT, coming from an imperative world... the transition is quite different.",0.16666666666666666,haskell
158iyza,jtcpyue,LISP is great at making languages that solve problems.,0.8,lisp
158iyza,jtcpyue,Lisp is an insanely small target.,-0.25,lisp
158iyza,jtcpyue,"In short, LISP is a **garbage collected**, **dynamic**, **functional** programming language and if you search for what was the first of any of those 3 you will get the same answer: LISP.",0.0625,lisp
158iyza,jtcuzrq,"The things i miss most from Clojure when working in other languages: 1. live REPL 2. data-orientation (flexible data structures with good equality semantics) 3. sane but flexible scoping rules (both lexical and dynamic binding)  But the primary problem with Clojure (and other Lisps) is its small, fragmented community and the lack of backing by a top company like MS/Meta/Google/etc.",0.19292929292929292,clojure
158iyza,jtcuzrq,"I wish clojure.spec or typed clojure had the same kind of support as TS, but i think that’s going to remain a wish for the foreseeable future.",0.19999999999999998,clojure
158iyza,jtai9iv,"I also have had little practice with it, but I assume LISP is appreciated kind of like the Turing Machine is.",0.2041666666666667,lisp
158iyza,jtchfyt,Ruby is basically a modern lisp.,0.2,ruby
158iyza,jtchfyt,Ruby is basically a modern lisp.,0.2,lisp
158iyza,jtchfyt,More accurately it's a child born of a union between lisp and smalltalk.,0.45000000000000007,lisp
158iyza,jtd9q02,"To me, the magic of lisp is homoiconicity.",0.5,lisp
158iyza,jtd9q02,"This semantic flexibility is doubly present in a lisp like Clojure, whose implementation is partially realized as a _host language library_ (which people don’t often realize).",-0.05,lisp
158iyza,jtd9q02,"This semantic flexibility is doubly present in a lisp like Clojure, whose implementation is partially realized as a _host language library_ (which people don’t often realize).",-0.05,clojure
158iyza,jtd9q02,"Thus you get to _apply_ the tool of homoiconic s-expressions to the JVM, Node/browser, Dart, native, etc.",0.0,dart
158iyza,jtdjjoq,The importance of lisp has diminished a bit now that other languages have adopted some its most important features.,0.25833333333333336,lisp
158iyza,jtdjjoq,Remember that lisp was a trailblazer on garbage collection for production systems!,0.0,lisp
158iyza,jtdjjoq,"Besides that, lisp was one of the few languages emphasizing first class functions while everyone else was drowning in OO idioms.",0.024999999999999994,lisp
158iyza,jtdjjoq,"Some other ""obviously correct"" things from lisp that are pretty common these days are strong dynamic typing and expression based syntax.",0.04305555555555555,lisp
158iyza,jtdjjoq,There are still other things languages could learn from lisp.,-0.125,lisp
158iyza,jtchxup,I  think Lisp should *always* blow your socks off.,0.0,lisp
158iyza,jtchxup,"The [metacircular evaluator](https://www.youtube.com/watch?v=OyfBQmvr2Hc) in and of itself is mind blowing, then the next step is [Destroy some New Buildings](https://lobste.rs/s/yj31ty/collapsing_towers_interpreters)  Yet Rich Hickey is probably [late fifties, early 60s](https://www.reddit.com/r/Clojure/comments/833xur/just_curious_how_old_is_rich_hickey/)  and didn't start playing with Common Lisp until his mid 40s?",-0.023579545454545454,lisp
158iyza,jtchxup,He then made Common Lisp 2.0 for the JVM creating Clojure.,-0.3,lisp
158iyza,jtchxup,He then made Common Lisp 2.0 for the JVM creating Clojure.,-0.3,clojure
158iyza,jtchxup,Lisp is fractally profound and can rediscovered at any age.,0.08333333333333333,lisp
158iyza,jtaen2g,"Some of these downsides (like macros being inherently second-class and not existing at runtime) probably do not exist in LISP, but some still apply.",0.0,lisp
158iyza,jtaen2g,"I would indeed be interested in seeing examples of freely using macros in LISP to achieve great results, be it conciseness, clarity of code, or something else.",0.4833333333333334,lisp
158iyza,jtqs6qf,But FORTH is ... well ... Something else entirely.,0.0,forth
158iyza,jtb3xyp,> Continuations are typically available  Not outside Scheme.,0.2,scheme
158iyza,jtauhf2,"Of course, this syntax itself must be documented (something many macro writers do a bad job of), and its meaning (i.e., semantics) must also be explained, but beyond that, its implementation should be as concerning as how a Fortran compiler might optimize away a sequence of additions and multiplications as SIMD instructions.",-0.09999999999999992,fortran
158iyza,jten12s,"In case anyone else was wondering ... ""Chinual Lisp"" is not a typo, and apparently refers to Lisp Machine Lisp: [https://en.wikipedia.org/wiki/Lisp\_Machine\_Lisp](https://en.wikipedia.org/wiki/Lisp_Machine_Lisp)",-0.35,lisp
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,lisp
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,forth
158iyza,jtffzgj,">  Lisp and Forth are the only two semi-popular languages where it's been meaningfully done  Prolog also seems (never tried that, or Forth for that matter) to be in a similar place when it comes to this.",0.16666666666666666,prolog
158iyza,jtb4zls,"(The language is named Common Lisp or CL, I believe we've had this exact discussion before anyway.)",-0.024999999999999994,lisp
158iyza,jtxbd9n,"The main drawback of Lisp is the repulsive syntax, which is only really good if people seriously want some kind of metaprogramming, reflection, logical artificial intelligence.",0.11190476190476191,lisp
158iyza,jtxbd9n,"Maybe there was potential (eg Planner, 3-Lisp) but Lisp stopped developing in that direction very early on (even regressed a bit since McCarthy's days) and what it offers is not useful enough for most people to accept a syntax they don't like.",0.09666666666666668,lisp
158iyza,jtckffl,"You can of course programmatically manipulate program structure of programs in non-homoiconic languages, like Python or Java or even C/C++ too.",0.0,python
158iyza,jtckffl,"You can of course programmatically manipulate program structure of programs in non-homoiconic languages, like Python or Java or even C/C++ too.",0.0,java
158iyza,jtckffl,But it is easier in a homoiconic language like Lisp since you can treat program tokens as first class citizens and don't need to manipulate them via string processing routines and regexes or some specialized API.,0.25,lisp
158iyza,jtctcol,"SML, Haskell, OCaml, ...  Prolog would also be a popular choice for such tasks.",0.3,haskell
158iyza,jtctcol,"SML, Haskell, OCaml, ...  Prolog would also be a popular choice for such tasks.",0.3,prolog
158iyza,jtctcol,"Elixir is also a very capable language, so it should not be a surprise that it handles such a simple task very well.",0.115,elixir
158iyza,jtctcol,Elixir has macros.,0.0,elixir
158iyza,jtctcol,The difference to Lisp is that Lisp code is written in its data syntax and that macros in Lisp are relatively unrestricted.,0.0,lisp
158iyza,jtctcol,"See https://elixir-lang.org/getting-started/meta/macros.html   In the Elixir example we have the macro named macro_unless in a module:       defmodule Unless do        defmacro macro_unless(clause, do: expression) do         quote do           if(!unquote(clause), do: unquote(expression))         end       end      end  In Lisp I would define it interactively in an editor+repl or the repl directly:      CL-USER 1 > (defmacro unless1 (clause &body body)                   `(if (not ,clause)                        (progn                          ,@body)))     UNLESS1       $ iex macros.exs      iex> require Unless     iex> Unless.macro_unless true, do: IO.puts ""this should never be printed""     nil   What does the Elixir macro transform the expression to?",0.22499999999999998,elixir
158iyza,jtctcol,"See https://elixir-lang.org/getting-started/meta/macros.html   In the Elixir example we have the macro named macro_unless in a module:       defmodule Unless do        defmacro macro_unless(clause, do: expression) do         quote do           if(!unquote(clause), do: unquote(expression))         end       end      end  In Lisp I would define it interactively in an editor+repl or the repl directly:      CL-USER 1 > (defmacro unless1 (clause &body body)                   `(if (not ,clause)                        (progn                          ,@body)))     UNLESS1       $ iex macros.exs      iex> require Unless     iex> Unless.macro_unless true, do: IO.puts ""this should never be printed""     nil   What does the Elixir macro transform the expression to?",0.22499999999999998,lisp
158iyza,jtctcol,"In Lisp we can macroexpand the expression, too:      CL-USER 2 > (macroexpand-1                  '(unless1 true                     (print ""this should never be printed"")))      (IF (NOT TRUE)         (PROGN (PRINT ""this should never be printed"")))  The result looks like normal Lisp source code and like Lisp data, at the same time.",0.08124999999999999,lisp
158iyza,jtctcol,"CL-USER 3 > (eval *)     NIL  We could also create the source code with the usual Lisp operators for list manipulation:      CL-USER 8 > (defmacro unless1 (clause &body body)                   (list 'if (list 'not clause)                         (cons 'progn body)))     UNLESS1      CL-USER 9 > (macroexpand-1                  '(unless1 true                     (print ""this should never be printed"")))      (IF (NOT TRUE) (PROGN (PRINT ""this should never be printed"")))  There is a certain look and feel to this way of programming programs.",0.07785714285714285,lisp
158iyza,jtctcol,"Treating code as data, without changing the representation, is a part of what makes Lisp special.",0.35714285714285715,lisp
158iyza,jtctcol,"Lisp does not have the nice surface syntax of Elixir, but then it also does not have the complex code representation.",0.15,lisp
158iyza,jtctcol,"Lisp does not have the nice surface syntax of Elixir, but then it also does not have the complex code representation.",0.15,elixir
158iyza,jtctcol,"Depends, but it is something which makes Lisp different.",0.0,lisp
158iyza,jtdc2uo,"I've read SICP, and tried out LISP on several occasions, and while using Emacs with LISP seems great, I just cbf learning a keyboard based editor and trying to learn any LISP is agony.",0.4,lisp
158iyza,jtdc2uo,"Haskell was actually pretty easy to pick up, learn you a Haskell is super approachable.",0.33888888888888885,haskell
158iyza,jtdc2uo,"I tried to read Paul Graham's ""On LISP"" because while I think he's a fuckwit, I've heard that this book is a great resource to understand the brilliance of LISP, and it was just impossible to grasp!",-0.016666666666666607,lisp
158iyza,jtdc2uo,That wouldn't be a problem if every other resource about LISP wasn't several decades old and written by academics.,-0.008333333333333331,lisp
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,lisp
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,haskell
158iyza,jtdc2uo,"I really want to try LISP one day, but it's amazing that everyone talks about how hard Haskell is, but no-one talks about how difficult LISP is (in comparison, at least)  I should probably try Clojure.",-0.058333333333333334,clojure
158iyza,jv9rvlo,"In Python, the way modules work makes it impossible to reliably patch a module once it's been loaded.",-0.6666666666666666,python
158iyza,jv9rvlo,"In JavaScript, modules are hermetically sealed, so you have zero visibility into them from the REPL, so you can't change them.",0.0,javascript
158iyza,jv9rvlo,"And all of these languages have stack-unwinding exceptions, meaning that even if you can patch definitions at runtime (like you can in Ruby), you can't do Lisp-style interactive programming because the debugger can't be launched until after the stack unwinds.",0.0,ruby
158iyza,jv9rvlo,"Decades have passed in which all new programming languages just copy C++'s exception mechanism, or reject it and implement C-style error handling instead.",0.13636363636363635,c++
158iyza,jtb066o,">If the pros of LISP really outweighed the cons, it would be more widely used to create software...",0.19999999999999998,lisp
158iyza,jtcuj21,"Document processing software, big data analytics, urban transportation planning systems, cloud backup service providers, AI, Google…  (cool read, 2014: pgloader switching from Python to CL https://tapoueh.org/blog/2014/05/why-is-pgloader-so-much-faster/)  ping /u/smthamazing for the ""mostly historical?""",0.0875,cool
158iyza,jtcuj21,"Document processing software, big data analytics, urban transportation planning systems, cloud backup service providers, AI, Google…  (cool read, 2014: pgloader switching from Python to CL https://tapoueh.org/blog/2014/05/why-is-pgloader-so-much-faster/)  ping /u/smthamazing for the ""mostly historical?""",0.0875,python
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,lisp
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,rust
158iyza,jtcscy1,"Here's an article series that I like: https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html he revises the old paper and compares the same program written in Common Lisp, Rust and Java.",-0.06666666666666667,java
158iyza,jtcscy1,"So, the CL version was beating (in speed) the Rust version.",0.0,rust
158iyza,jtcscy1,"Of course, he wasn't writing the most efficient Rust code.",0.5,rust
158iyza,jtcscy1,"The Rust community came to give a hand, sent PRs on his repository, they had lengthy discussions, they tried different approaches, and ultimately they got a very fast Rust program (that's in the follow-up article).",0.08666666666666667,rust
158iyza,jtcscy1,"So even if the final Rust version beats it, 1) they run in the same ballpark (SBCL produces very fast code and is often at the top of the benchmarks, a little slower than C or sometimes beating it), 2) this says a lot about a developer's efficiency IMO (and we didn't even talk about workflows and the CL productivity: very short write-compile-test cycles, interactive debugging etc).",0.09541666666666666,rust
158iyza,jtcscy1,"So even if the final Rust version beats it, 1) they run in the same ballpark (SBCL produces very fast code and is often at the top of the benchmarks, a little slower than C or sometimes beating it), 2) this says a lot about a developer's efficiency IMO (and we didn't even talk about workflows and the CL productivity: very short write-compile-test cycles, interactive debugging etc).",0.09541666666666666,c
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,lisp
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,c
158iyza,jtcscy1,This article compares Lisp macros with C and Perl: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html,0.0,perl
158iyza,jtcs2ez,An unmodern lisp.,0.0,lisp
158iyza,jtcs2ez,ruby misses too many good lisp features to call itself a lisp.,0.6,ruby
158iyza,jtcs2ez,ruby misses too many good lisp features to call itself a lisp.,0.6,lisp
158iyza,jtcs2ez,can you dump a running ruby to an exe?,0.0,ruby
158iyza,jtcs2ez,can you write a ruby object system with unevaluated arguments in pure ruby?,0.21428571428571427,ruby
158iyza,jtcs2ez,"can you debug into a running ruby server, find the bug, patch it, dump it, continue?",0.0,ruby
158iyza,jtcs2ez,can you do proper arithmetic with ruby?,0.0,ruby
158iyza,jtcs2ez,"it does bigint promotion like lisp, but no rationals nor bigfloats.",0.0,lisp
158iyza,jtcs2ez,half a lisp  also ruby has tons of syntax and operator precedence rules.,-0.16666666666666666,lisp
158iyza,jtcs2ez,half a lisp  also ruby has tons of syntax and operator precedence rules.,-0.16666666666666666,ruby
158iyza,jtcs2ez,lisp has none,0.0,lisp
158iyza,jv9xtgd,"The best way to explain the power of macros is by comparing them with React, which, due to JavaScript's lack of macros, requires its own compiler.",0.4916666666666667,javascript
158iyza,jv9xtgd,"If browsers ran Common Lisp instead of JavaScript, React would've used read macros instead of needing a separate compiler.",-0.3,lisp
158iyza,jv9xtgd,"If browsers ran Common Lisp instead of JavaScript, React would've used read macros instead of needing a separate compiler.",-0.3,javascript
158iyza,jte091q,"Lisp also pioneered OO, including Flavors (which originated ""mixins"") and CLOS.",0.0,lisp
158iyza,jtcx993,In Lisp it is relatively simple to extend the language incrementally.,0.0,lisp
158iyza,jtcx993,In this case this is Lisp with added macros and the target language is also Lisp.,0.0,lisp
158iyza,jtcx993,"> I would indeed be interested in seeing examples of freely using macros in LISP to achieve great results, be it conciseness, clarity of code, or something else.",0.4833333333333334,lisp
158iyza,jtcx993,"See for example the SBCL (an implementation of Common Lisp, mostly in Common Lisp) compiler itself.",-0.3,lisp
158iyza,jtaj124,"> I am used to the notion of macros being either a substitute for missing language features  in the lisp world, we often think that a lot of niche language features are duct tape over the absence of a robust macro system.",-0.10625000000000001,lisp
158iyza,jtaj124,"in fact, good lisp practice is to define macros using the ""call-with"" pattern, where you define a higher-order function to implement the behavior you want, and then define a macro which simply invokes that higher-order function with some lambdas as arguments.",0.35,lisp
158iyza,jtaj124,"my main point of reference for a more popular language with a macro system is rust, so i'll compare to that:  - rust (proc) macros have to do a horrible dance of parsing and then re-serializing their inputs and outputs, which is needlessly inefficient.",-0.046666666666666676,rust
158iyza,jtaj124,lisp macros accept and return data structures that the compiler can understand directly.,0.1,lisp
158iyza,jtaj124,"- rust (proc) macros have to be compiled separately as their own compilation unit, and then linked and dynamically loaded by the compiler.",0.6,rust
158iyza,jtaj124,lisp macros are either interpreted or jit compiled within the same compilation unit as their usages.,0.0,lisp
158iyza,jtaj124,- rust has very poor support for incremental compilation; rustc basically has to recompile your whole crate every time anything changes.,-0.16,rust
158iyza,jtaj124,"common lisp compilers can recompile a single top-level definition, be it a function, class or variable, which takes approximately no time.",-0.05714285714285714,lisp
158iyza,jtaj124,"> I would indeed be interested in seeing examples of freely using macros in LISP to achieve great results, be it conciseness, clarity of code, or something else.",0.4833333333333334,lisp
158iyza,jtaj124,"i don't really have any publicly-available common lisp code to show you that i think uses macros in a nice way, unfortunately.",0.0,lisp
158iyza,jtaj124,"despite my ragging on rust, i think their standard library has a lot of great examples of good uses of macros that improve things a lot: it's a bunch of things that need syntax other than the default, but for one reason or another should not be language features.",0.34375,rust
158iyza,jtaj124,"[a, b, c]` macro is a great example: instead of making `Vec` a ""magic type"" in order to allow users to write literals, a vec ""literal"" is a macro invocation.",0.65,c
158iyza,jtcx4lo,Many of the stated advantages of Lisp have nothing to do with macros.,0.5,lisp
158iyza,ju8i0wq,"I don't know if you can be effective with Lisp without using macros, but in other languages the meta programming stuff like reflection and eval can often be avoided or relegated to libraries that do stuff like (de)serialization for you  Also lol I totally get that.",0.31875,lisp
158iyza,ju8i0wq,"I can stand it for like maybe a month or two and then I've gotta take a break for my own well-being, otherwise I get grouchy  (Edit: also yes, Forth is different)",0.3,forth
158iyza,jtdctf5,"Common Lisp supports and extensively uses dynamic scoping, it just has to be explicitly requested for a given variable.",-0.09999999999999999,lisp
158iyza,juhiupj,"""Chinual"" means ""lisp maCHIne manNUAL"".",0.0,lisp
158iyza,juhiupj,"so  ""chinual lisp"" stands for ""Lisp machine manual lisp"".",0.0,lisp
158iyza,juhiupj,"I never heard such abbreviation for ""Lisp machine lisp"".",0.0,lisp
158iyza,jtxsdjb,"I remember using a thin syntax wrapper around C, for the first substantial program I wrote in it, to take care of some of the rough edges.",-0.08333333333333333,c
158iyza,jtxsdjb,"For Lisp, a project I played with once let me write code in a universal syntax of my choice, which was then translated to a range of languages.",0.0,lisp
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,python
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,lua
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,c
158iyza,jtxsdjb,"I experimented with Python, Lua, C and Lisp targets.",0.0,lisp
158iyza,jtxsdjb,"So for a `Fibonacci` benchmark in that syntax, it produced this Lisp source which runs under CLisp:      ; Lisp source output          (defun start ()       (format t ""~a"" (fib 36))       (format t ""~%"")     )          (defun fib (n)       (if (< n 2)           (return-from fib n)           (return-from fib (+ (fib (- n 1)) (fib (- n 2))))       )     )          (start)  But there was a problem: my universal syntax didn't have its own semantics and capabilities, those still belonged to the target language.",0.3,lisp
158iyza,jtxsdjb,"Most languages, their syntax is also their identity: you can tell if you're coding in Python or in Lisp.",0.5,python
158iyza,jtxsdjb,"Most languages, their syntax is also their identity: you can tell if you're coding in Python or in Lisp.",0.5,lisp
158iyza,jtxsdjb,"Still, if I'd somehow got a job where I had to produce Lisp code, I would probably use such a conversion tool.",0.0,lisp
158iyza,jte21bu,"> I tried to read Paul Graham's ""On LISP"" because while I think he's a fuckwit  As much as I agree with Graham being overrated, name calling isn't welcomed, so please don't.",0.2,lisp
158iyza,jtdb0dg,"I get that some stuff demands quite a lot (like Haskell, which is brilliant but also, y'know, Haskell) but some of them are pretty easy to pick up.",0.5277777777777778,haskell
158iyza,jtdb0dg,"This isn't entirely worthless to be fair, some people aren't smart enough or don't care enough to go through that, and that's perfectly reasonable.",0.05238095238095236,go
158iyza,jtciqbr,Like Sun pouring $500m into PR and marketing for Java.,0.0,java
158iyza,jtddgid,>can you dump a running ruby to an exe?,0.0,ruby
158iyza,jtddgid,It's an interpreted language but there are compilers for it like artichoke ruby.,0.0,ruby
158iyza,jtddgid,">can you debug into a running ruby server, find the bug, patch it, dump it, continue?",0.0,ruby
158iyza,jtddgid,>can you do proper arithmetic with ruby?,0.0,ruby
158iyza,jtddgid,"it does bigint promotion like lisp, but no rationals nor bigfloats  I don't know if anybody has coded them yet but it wouldn't surprise me if they did.",0.0,lisp
158iyza,jtddgid,>also ruby has tons of syntax and operator precedence rules.,0.0,ruby
158iyza,jtddgid,lisp has none  Cool.,0.35,lisp
158iyza,jtddgid,lisp has none  Cool.,0.35,cool
158iyza,jtddgid,That's one of the reasons why lisp isn't popular.,0.6,lisp
158iyza,jtam7mp,"Cl-ppcre is touted to run faster than c implementation of perl regular expressions due to it s use of macros, especially compiler macros.",-0.041666666666666664,c
158iyza,jtam7mp,"Cl-ppcre is touted to run faster than c implementation of perl regular expressions due to it s use of macros, especially compiler macros.",-0.041666666666666664,perl
158iyza,jtam7mp,Object oriented programming was first prototyped in lisp.,0.25,lisp
158iyza,jtam7mp,One of the ahah moments that comes from learning lisp is that there really is no syntax.,-0.1,lisp
158iyza,jtam7mp,"In fact, one of the examples of CL-PPCRE is that regular expressions themselves can be written in a lisp form, that is then used to generate the pattern matching engines.",0.0,lisp
158iyza,jtam7mp,"Common lisp was used to develop coalton for strict type checking, for instance",-0.3,lisp
158iyza,jup79g5,Forth is like HaikuOS.,0.0,forth
158iyza,jtk9oq4,It means you need to learn lisp to understand it :).,0.5,lisp
158iyza,jtk9oq4,In lisp(s) a symbolic expression either an atomic expression or a list.,0.0,lisp
158iyza,jtk9oq4,If you just present it so to the lisp interpreter it will try to evaluate it as a special form called defun which will define a function for later use (sort of function declaration and definition in other languages).,0.05803571428571429,lisp
158iyza,jtk9oq4,"If you quote it, it is just code (data):      '(defun yey ()        (if (< 2 3) (message ""yey"")))  For example you can ask for the first element of the list:      (first '(defun yey ()               (if (< 2 3) (message ""yey""))))  => defun  Of you can ask for nth element of the list:       (nth 3 '(defun yey ()               (if (< 2 3) (message ""yey""))))  => (if (< 2 3) (message ""yey""))  You can also eval that 3 element as any code:      (eval (nth 3 '(defun yey ()                (if (< 2 3) (message ""yey"")))))  => ""yey""  Now imagine setting up a code and evaluating it in some other language like C++ or Python.",-0.4107142857142857,c++
158iyza,jtk9oq4,"If you quote it, it is just code (data):      '(defun yey ()        (if (< 2 3) (message ""yey"")))  For example you can ask for the first element of the list:      (first '(defun yey ()               (if (< 2 3) (message ""yey""))))  => defun  Of you can ask for nth element of the list:       (nth 3 '(defun yey ()               (if (< 2 3) (message ""yey""))))  => (if (< 2 3) (message ""yey""))  You can also eval that 3 element as any code:      (eval (nth 3 '(defun yey ()                (if (< 2 3) (message ""yey"")))))  => ""yey""  Now imagine setting up a code and evaluating it in some other language like C++ or Python.",-0.4107142857142857,python
158iyza,jtk9oq4,"Since the object and printed representation are almost 1:1 (there are some unprintable objects), you can work with lists as stored in the lisp machines internal datastructures.",0.0,lisp
158iyza,jtk9oq4,"Indexing in Emacs Lisp is as in C, from 0, 1, ... N-length, and (cadr list) is same as (nth 1 list), I have jused that one just because it would look more ugly with (nth 1 (nth 2 ...)).",-0.06666666666666665,lisp
158iyza,jtk9oq4,"Indexing in Emacs Lisp is as in C, from 0, 1, ... N-length, and (cadr list) is same as (nth 1 list), I have jused that one just because it would look more ugly with (nth 1 (nth 2 ...)).",-0.06666666666666665,c
158iyza,jtk9oq4,"Anyway, it is a very contrived and toy example, but try to rewrite it in Python or C++, and you will see a difference in code you use for the manipulation (program you write) and code you manipulate since there will be lots of string manipulations.",-0.65,python
158iyza,jtk9oq4,"Anyway, it is a very contrived and toy example, but try to rewrite it in Python or C++, and you will see a difference in code you use for the manipulation (program you write) and code you manipulate since there will be lots of string manipulations.",-0.65,c++
158iyza,jtk9oq4,In Lisp the system does it for you (more or less) so you can write your programs as the code you manipulate is actually live program code.,0.15656565656565657,lisp
158iyza,jtk9oq4,But look at JS or Python and how they write code they send back into the interpreter.,0.0,python
158iyza,jtk9oq4,Compare to Lisp and property lists.,0.0,lisp
158iyza,jtk9oq4,"Due to implementation of JS they of course can't do that, but if JS was a Lisp ...  > Any reasonable language infrastructure would manipulate program representations through ASTs  Would it?",0.037500000000000006,lisp
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,python
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,c
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,c++
158iyza,jtk9oq4,"Is JS, Python, C, C++, Java etc ""reasonable"".",0.2,java
158iyza,jtk9oq4,Do you have access to the AST of your program when you type your programs in C++ or Java normally?,0.15,c++
158iyza,jtk9oq4,Do you have access to the AST of your program when you type your programs in C++ or Java normally?,0.15,java
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,java
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,lisp
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,c
158iyza,jtk9oq4,"Java reflection is relatively close to Lisp due to its runtime, but it does not create an AST of your program at runtime, nor does Lisp, nor compiled languages like C or C++, unless you are a compiler writer and writing a compiler to translate code from one representation into another.",-0.0625,c++
158iyza,jtmkm1x,"In my view, Lisp only slightly increases the effective range of action from non-Lisp languages, but those differences put together bring you from something like 90% coverage on the best non-Lisp languages (e.g.",0.30666666666666664,lisp
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,haskell
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,ruby
158iyza,jtmkm1x,"Haskell, possibly Ruby & Elixir (I don't know them well enough to say), etc) to **100%** coverage.",0.0,elixir
158iyza,jtmkm1x,"Lisp languages may be less popular due to the initial work to familiarize yourself with the syntax (and many historical factors as well), but they have technical advantages that to my knowledge have only been matched by languages others consider to be Lisps or Lisp-equivalents (including the same gripes about too little syntax and universal open/close markers (usually parentheses))  &#x200B;  *The original draft of this post was a bit of a ramble elaborating on the above, kept here because I don't want to waste all that writing:*  &#x200B;  Most languages (and in truth most computing frameworks, period) try to make the \[default\] user interface (or developer interface, if you prefer; developers are the users of languages, after all!)",0.0982843137254902,lisp
158iyza,jtmkm1x,"I'm unfamiliar with Elixir, but from your and lispm's examples here it seems to fit the same mold.",0.2,elixir
158iyza,jtmkm1x,"Facilities like C's macro system (horrible though it is), or Elixir's apparently-better macro system extend this space to contain all possible language features; but the areas that aren't covered by the core language tend to have different usability characteristics, making them much slower to develop.",-0.2,c
158iyza,jtmkm1x,"Facilities like C's macro system (horrible though it is), or Elixir's apparently-better macro system extend this space to contain all possible language features; but the areas that aren't covered by the core language tend to have different usability characteristics, making them much slower to develop.",-0.2,elixir
158iyza,jtmkm1x,"&#x200B;  Lisp languages don't exactly fit the above pattern, because their first priority is to make the conceptual core of the language as simple as possible.",0.13,lisp
158iyza,jtmkm1x,Common Lisp also adds *some* focus on the user (i.e.,-0.3,lisp
158iyza,jtmkm1x,"developer) interface, Scheme barely focused on anything but simplicity in its formative years and is now trying to make up for that mistake, and Racket is bound by some limits of Scheme but is otherwise excellent.",0.525,scheme
158iyza,jtmkm1x,"But one important implication of Lisp's generality is the language-oriented programming paradigm, the ability to design toolkits that make arbitrary areas of possibility-space easier to navigate.",0.15000000000000002,lisp
158iyza,jtmkm1x,*And* you still maintain the significant difficulty-reduction Lisp provides for tasks which *nobody* has written a framework for.,0.375,lisp
158iyza,jtmkm1x,"(Note: In practice, only toy libraries like with-c-syntax bother to paper over S-expressions, since making use of Lisp's unique benefits requires the relationship between homoiconicity and macros, a relationship which would be covered up by complex syntax.",0.025000000000000005,lisp
158iyza,jtmkm1x,"It's reasonably easy to do (especially compared to most other languages), and has to some extent already been done, but if you're familiar with Lisp you likely won't want to do it)  There's also no artificial, language-induced constraints on where your packages can be used.",0.2119047619047619,lisp
158iyza,jtmkm1x,"You don't have to arbitrarily divide your users into ""Users"" and ""Developers""; any development work you do advances the entire system of ""people using Lisp software"".",-0.05,lisp
158iyza,jtmkm1x,"&#x200B;  All the above points are, as far as I know, unique to Lisp languages.",0.15833333333333333,lisp
158iyza,jtmkm1x,"Even lispm's Elixir example, though far more attractive than the other mainstream languages I've had the misfortune to become skilled at, sets a distinct format which macros have to follow, and which seems both less readable and more inconvenient to write than your example of ordinary Elixir code.",0.15583333333333332,elixir
158iyza,jtmkm1x,I agree that it takes some time to familiarize yourself with Lisp syntax.,0.0,lisp
158iyza,jtmkm1x,"And I can appreciate the benefits of creating libraries that make writing *most* code easier, rather than *all* code (I've actually been designing such an abstraction layer for Common Lisp, though work is too busy to have gotten it to the implementation stage yet).",0.06000000000000001,lisp
158iyza,jtmkm1x,"To me, that's far more unpalatable than any of Lisp's weaknesses.",0.3,lisp
158iyza,jthujoj,">I love parentheses (but highly prefer Scheme and Racket over Common Lisp), but the ""power"" of Common Lisp is overstated.",0.015000000000000013,scheme
158iyza,jthujoj,">I love parentheses (but highly prefer Scheme and Racket over Common Lisp), but the ""power"" of Common Lisp is overstated.",0.015000000000000013,lisp
158iyza,jthujoj,I vastly prefer Common Lisp over Scheme&Racket.,-0.15,lisp
158iyza,jthujoj,I vastly prefer Common Lisp over Scheme&Racket.,-0.15,scheme
158iyza,jthujoj,Not really in Lisp.,-0.1,lisp
158iyza,jthujoj,"In Lisp the rules are more like: if one needs a linguistic abstraction, write a macro.",0.3,lisp
158iyza,jthujoj,"Btw., the numbers of top-level macros in my Lisp Machine (an emulator running on my MacBook Pro)  world (the running Lisp image, which is an operating system) is 6955.",0.0,lisp
158iyza,jte5z6q,The IDE (oh god the light theme) was really cool!,0.41875,cool
158iyza,jtdk0bh,">I get that some stuff demands quite a lot (like Haskell, which is brilliant but also, y'know, Haskell)  I don't think that they demand a lot (at least not to be productive), but they usually *do* demand that you learn *some* new way of thinking about things.",0.12159090909090911,haskell
158iyza,jtdk0bh,"That's why Haskell seems so alien to people - ""How am I supposed to do anything if I can't mutate a variable?"".",-0.25,haskell
158iyza,jv9xg7p,>It's an interpreted language but there are compilers for it like artichoke ruby.,0.0,ruby
158iyza,jv9xg7p,"Copy the executable to another machine that doesn't have Artichoke, Rust, or anything else installed.",0.0,rust
158iyza,jv9xg7p,"Run the executable file and get into a new REPL (when you save a Lisp image, it comes with the REPL and the compiler).",0.13636363636363635,lisp
158iyza,jv9xg7p,">> can you debug into a running ruby server, find the bug, patch it, dump it, continue?",0.0,ruby
158iyza,jv9xg7p,"You can only ""debug into a running ruby server"" by adding a line somewhere in the source code that says something like `binding.pry`, and then restarting the server (Rails will do the restarting for you if it detects the file update).",0.0,ruby
158iyza,jv9xg7p,"Since this is Ruby we're talking about, this was probably a Web server, so you have to re-run the HTTP request that originally caused the error, probably twice (once to reproduce the error and get into the debugger, and again once you've reloaded the corrected server).",0.375,ruby
158iyza,jv9xg7p,"If the server was written in Lisp, the debugger would come up automatically when the error is signalled.",0.0,lisp
158iyza,jv9xg7p,"The program stops on the expression that is equivalent to Ruby's `raise` statement, before the error is actually thrown.",0.0,ruby
158iyza,jv9xg7p,Can Ruby do *that?,0.0,ruby
158iyza,jv9xg7p,"While it has *some* of the required functionality (unlike Python, it *can* patch definitions in memory), it's missing the ability to handle exceptions *before* unwinding the stack (the Lisp debugger is just an exception handler), and its debugger lacks the ability to re-run stack frames, so it does you no good to be able to dynamically patch a definition.",-0.01666666666666668,python
158iyza,jv9xg7p,"While it has *some* of the required functionality (unlike Python, it *can* patch definitions in memory), it's missing the ability to handle exceptions *before* unwinding the stack (the Lisp debugger is just an exception handler), and its debugger lacks the ability to re-run stack frames, so it does you no good to be able to dynamically patch a definition.",-0.01666666666666668,lisp
158iyza,jtb4ffr,"> Cl-ppcre is touted to run faster than c implementation of perl regular expressions due to it s use of macros  cl-ppcre uses a chain of closures, though it may generate that chain of closures at load-time.",-0.0625,c
158iyza,jtb4ffr,"> Cl-ppcre is touted to run faster than c implementation of perl regular expressions due to it s use of macros  cl-ppcre uses a chain of closures, though it may generate that chain of closures at load-time.",-0.0625,perl
158iyza,jv1fe8e,But you can also load Forth as an OS and bypass all ideas of kernels and syscalls and file systems and desktop environments and everything,0.0,forth
158iyza,jtdxq8p,"Well, that and the fact that 40% or tutorials start with category theory, 30% say ""you don't need maths for Haskell!""",0.0,haskell
158iyza,jtdxq8p,"I agree that the actual concepts behind programming in Haskell are not just easy to understand, but they're also much more simple than the alternatives.",0.10666666666666666,haskell
158iyza,jtdxq8p,"I like Haskell and the ideas which created it, but the documentation is often super confusing and relies heavily on the consumer of the API knowing all the buzzwords (Monad, monad transformer, monoid, etc.).",-0.05555555555555556,haskell
158iyza,jv9zc5f,Well I guess the fact that lisp can do all that and is so much more powerful than ruby probably explains why it's used more widely than ruby and so many more companies are reliant on it for their business.,0.3666666666666667,lisp
158iyza,jv9zc5f,Well I guess the fact that lisp can do all that and is so much more powerful than ruby probably explains why it's used more widely than ruby and so many more companies are reliant on it for their business.,0.3666666666666667,ruby
158iyza,jtego1t,As a learning resource it seems cool for certain people but without a passing familiarity with macros in Racket I didn't find it that compelling.,0.2880952380952381,cool
158iyza,jte27gz,">I like Haskell and the ideas which created it, but the documentation is often super confusing and relies heavily on the consumer of the API knowing all the buzzwords (Monad, monad transformer, monoid, etc.).",-0.05555555555555556,haskell
158iyza,jte27gz,"It's not much harder to understand what a monoid is than to understand inheritance for example, and I was taught that in my second-ever lecture on C++.",0.05,c++
158iyza,jte27gz,"And I'm fully supportive of that reluctance when all you care about is to write a couple Python scripts to scrape a website or whatever, but when this is your profession and you care about writing good quality software then that's a very different story and it practically becomes your duty to spend some time working these concepts.",0.39999999999999997,python
158iyza,jte3oah,"We're fully on the same page, but people aren't starting on Haskell, and even if they were it's still not very accessible compared to say, Elm.",-0.04807692307692307,haskell
158iyza,jte3oah,"We're fully on the same page, but people aren't starting on Haskell, and even if they were it's still not very accessible compared to say, Elm.",-0.04807692307692307,elm
158iyza,jte3oah,"It just seems like ""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify.",-0.2916666666666667,go
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,go
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,haskell
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,lisp
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,java
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,javascript
158iyza,jteca32,">""you need to go through a phase where you feel like you know nothing about programming before hello world"" is hard to justify  I think that traditional languages arguably make writing a hello world harder than both Haskell and Lisp, here's why:  When I first started learning programming in university (but as part of a music degree, so no other CS experience at all), in a short period of time I was introduced to programming through (in this order): Max/MSP, Processing (a simplified Java), JavaScript, C++, and I taught myself some (Emacs) Lisp and Haskell for a project.",-0.013194444444444453,c++
158iyza,jteca32,"Then, in C++, you have the infamous:      #include <iostream>     int main() {        std::cout << ""Hello world!\n"";       return 0;     }  If you've never seen code in this format before, you have to mentally parse the following syntax/semantic objects (accompanied with their fancy terminologi):  1. the `#include` (compiler directives) 2. the `<iostream>` (header files) 3. the `int main()` (type declaration, function arguments) 4. the `{...}` (scope) 5. the `std::cout` (namespaced qualifiers) 6. the `<<` (stream operator) 7. the `\n` (line break character sequence) 8. the `;` (expression terminator) 9. the `return 0` (return statement, which at first made me think ""what does it mean to return in my code, why am I returning a seemingly random number, and to whom?"")",-0.10364583333333334,c++
158iyza,jteca32,"I won't even bother breaking down Java's:      public class HelloWorld     {       public static void main(String[] args)         {           System.out.println(""Hello world!",0.11736111111111111,java
158iyza,jteca32,""");         }     }  Here's hello world in Haskell and Lisp, for comparison:      // Haskell     main = putStrLn ""Hello world!""",0.20833333333333331,haskell
158iyza,jteca32,""");         }     }  Here's hello world in Haskell and Lisp, for comparison:      // Haskell     main = putStrLn ""Hello world!""",0.20833333333333331,lisp
158iyza,jteca32,"// Lisp     (print ""Hello world!"")",0.0,lisp
158iyza,jteca32,And yet these languages build up on theory that's widely considered much more esoteric than that of C++ or Java.,0.2,c++
158iyza,jteca32,And yet these languages build up on theory that's widely considered much more esoteric than that of C++ or Java.,0.2,java
158iyza,jteca32,"I'm not saying that this makes them beginner-friendly languages (your first \~100 Haskell compiler errors can be cryptic gibberish, and Lisp's `car` and `cdr` historic baggage is confusing and unattractive, to put it mildly), but out of the three I think it's clear which one makes it easier to get your feet wet as a complete beginner.",0.054761904761904755,haskell
158iyza,jteca32,"I'm not saying that this makes them beginner-friendly languages (your first \~100 Haskell compiler errors can be cryptic gibberish, and Lisp's `car` and `cdr` historic baggage is confusing and unattractive, to put it mildly), but out of the three I think it's clear which one makes it easier to get your feet wet as a complete beginner.",0.054761904761904755,lisp
158iyza,jteemhx,But a course that's brain dead enough to get you started with programming on C++ or Java isn't going to be better at teaching you any amount of input beyond hello world.,0.09999999999999999,c++
158iyza,jteemhx,But a course that's brain dead enough to get you started with programming on C++ or Java isn't going to be better at teaching you any amount of input beyond hello world.,0.09999999999999999,java
158iyza,jteemhx,If you're throwing lisp into the mix then why not python?,0.0,lisp
158iyza,jteemhx,If you're throwing lisp into the mix then why not python?,0.0,python
158iyza,jteemhx,"``` print(""Hello World"") ``` Seems more straight forward than Haskell to me.",0.35,haskell
158iyza,jteemhx,"Mainly though, I agree with you- what I was trying to say is that Haskell is easy and much simpler (well, GHC is a massive complex project with language extensions yadda yadda but you get my point) but very *very* few people are learning Haskell as their first language.",0.06999999999999999,haskell
158exhb,,"Alas, Vale's compiler is still written in Scala which doesn't have linear types, so I had a bug.",-0.4,scala
158exhb,jt9yg02,"""I did X but forgot to do Y"" - I'm also getting warned by this by elm-review - a linter for the Elm language - and specifically its set of NoUnused rules.",0.0,elm
158exhb,jtlkp67,For example in C++ the compiler guarantees your destructors get called and therein you release everything you acquired.,0.0,c++
158exhb,jtbrw4p,"There's a talk on it that compares Idris and Scala: https://www.youtube.com/watch?v=fV2no1Rkzdw  I take example from them to here:  ``` testFile : FileIO () testFile = catch (   do open ""testFile"" Read     str <- readFile    putStrLn (show str)    ls <- Count :- get    close    putStrLn (show ls))  (\err => putStrLn (""Handled: "" ++ show err)) ```  In this example, if you remove the ""close"" line, the program simplely won't compile.",0.0,scala
158exhb,jtesizv,"There are implementation of session types in Rust, which only has support for affine types (not fully linear).",0.0,rust
158exhb,jta81gk,This scheme gets the benefits of linear types and mutable aliasing at the same time.,0.0,scheme
158exhb,jtakh26,It's Haskell :)  Isn't your example about forgetting to do Y?,0.5,haskell
158exhb,jtakh26,If we go back to the original problem - doing X but forgetting to do Y - the point is you make it so you _cannot_ do X without evidence that you've done Y.,0.1875,go
158exhb,jtaq6ii,"That explains it, I never learned Haskell ;) Definitely my achilles heel.",0.125,haskell
158exhb,jtaq6ii,"If the user only exposes one way to consume X's result (specifically, the operation Y) then the compiler makes sure we can never forget to do Y.  I heard that LiquidHaskell has linear types, so the difference between Haskell and LiquidHaskell might have a better answer for you than I can give.",0.3333333333333333,haskell
157dru3,,"Up to this point, I basically have a first draft done in typescript, so if you have questions about the feasibility of that graph system itself, I can try to answer them.",0.25,typescript
157dlmc,,"I don't see this to be a thing in major languages, but in my language, this is possible: (note that `=` is pattern matching, will succeed only if LHS = RHS) ``` a = [5, 6] [1, 2, 3, 4, 5, 6, 7, 8] = [1, 2 .. [3, 4] .. a, 7, 8] [1, 2, 3, 4, 5, 6, 7, 8] = [.. [1, 2, 3, 4], 5, 6, 7, 8] ``` The idea behind this is just Lisp's `splice-unquote`.",-0.21749999999999997,lisp
157dlmc,jt58f8n,"Or you could copy Python's prefix-star and get `[1,2,3,4,*a,7,8]` which I think Guido got right.",0.2857142857142857,python
157dlmc,jt458vw,"Answer on my own:  Elixir's `|` seems fine, I expect binary operation to be rarely used in my language to might as well use `bor` or something else.",0.4388888888888889,elixir
157dlmc,jt88p82,`tcl` uses a `{*}` prefix for list splicing.,0.0,tcl
157dlmc,jt8viqx,"For this I'd use a flatten function, like in good ol' PHP.",0.7,php
157dlmc,jt835jd,"I use `...` for varargs in my language just as in Lua, so I can't do it.",0.0,lua
157dlmc,jteir19,"Just like some people prefer ruby where there's more than 1 way to do the samething, and some people prefer lua, where the syntax is minimal.",0.2,ruby
157dlmc,jteir19,"Just like some people prefer ruby where there's more than 1 way to do the samething, and some people prefer lua, where the syntax is minimal.",0.2,lua
157dlmc,jtofuci,Weird Haskell.,-0.5,haskell
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,perl
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,ruby
157dlmc,jtofuci,"I call it Platinum, because Perl, Ruby, and Crystal, even though there is no relation between them whatsoever.",0.0,crystal
157dlmc,jtfjebf,Rust serves as a good reminder of that failure.,0.19166666666666662,rust
157dlmc,jt8agqw,Please consult lua.,0.0,lua
157dlmc,jt8agqw,"it refers to `varargs` itself  Programmers write this: ``` fn hello(a, b, c ...)    [_ ...] = ... # drop first element   print(...) end ```  It gets expanded to: ``` fn hello(a, b, c .. varargs)    [_ .. varargs] = varargs   print(varargs) end ```  It's just a little syntax sugar, but I think it makes the program more readable.",0.1875,c
157dlmc,jtoo9ct,"We can also go TypeScript-style and require all subtypes to be comparable, or to be wrapped in a wrapper type that is.",0.0,go
157dlmc,jtpbg3p,"And you use the same union type syntax as languages like TypeScript and Scala 3, where it is _not_ discriminated.",0.0,typescript
157dlmc,jtpbg3p,"And you use the same union type syntax as languages like TypeScript and Scala 3, where it is _not_ discriminated.",0.0,scala
157dlmc,jtpbg3p,"You should try to implement your ideas, even in a simple interpreter, to see how these things would go.",0.0,go
157dlmc,jtpfzgy,TypeScript's unions are not tagged.,0.0,typescript
157dlmc,jtpfzgy,"> TypeScript and Scala 3, where it is not discriminated.",0.0,typescript
157dlmc,jtpfzgy,"> TypeScript and Scala 3, where it is not discriminated.",0.0,scala
157dlmc,jtpfzgy,"It means if `a | b` is not a tagged union, then you must discriminate yourself either by using intersected properties of the subtypes, as in TypeScript, or a by making it a dependent type on some external state, as do C-style anonymous unions.",0.0,typescript
157dlmc,jtpfzgy,The type variables being scoped address this issue by not requiring type specialisation rules as are present in C++ templates.,0.0,c++
157dlmc,jtpfzgy,"That said, this is a purely syntactic issue, which C++ solves exactly in the same way the code I posted does.",0.15476190476190477,c++
157dlmc,jtpfzgy,"I have a compiler that translates this code      f: (Int | String) -> Int     f (x: Int) = x     f (s: String) = s.length  into Assembly code roughly equivalent to this:      Int f₀(Int x) { return x; }     Int f₁(String s) { return length(s); }     Int f(Union<Int, String> x)     {         if(x.is<Int>()) {             return f₀(x.as<Int>());         }         else {             return f₁(x.as<String>());         }     }  This follows the System V ABI for AMD64, and all three routines are callable from C/C++ compilers adhering to it.",-0.425,assembly
157dlmc,jtpfzgy,GCC outputs the same code when I write the code in C++.,0.0,c++
157dlmc,jtprgj3,"But then you're not really designing a ""weird Haskell"" as you stated above, since many important Haskell things will no longer be possible, such as polymorphic recursion (used to traverse nested data types) and GADTs, to name just a couple.",0.042857142857142864,haskell
157dlmc,jtprgj3,"(I would assume so, since you keep referring to Java and C++ overloading, which both include subtyping-based overloading.)",0.0,java
157dlmc,jtprgj3,"(I would assume so, since you keep referring to Java and C++ overloading, which both include subtyping-based overloading.)",0.0,c++
157dlmc,jtqzw76,"> you're not really designing a ""weird Haskell""     Oh I was describing the syntax/pseudocode I use, rather than what I'm actually doing in my free time.",-0.04999999999999999,haskell
157dlmc,jtqzw76,"So Row-Polymorphism is how it does it, as well as `a <: (a | b)`, `(a -> b & c -> d) <: ((a | c) -> (b | d))`, `42 <: (42 | 69)`, etc..  > translate `f(e)`  Record subtyping is done by generating (temporary, on the stack) and passing vtables with perfect hashes around.",-0.3125,c
157dlmc,jtqzw76,"So Row-Polymorphism is how it does it, as well as `a <: (a | b)`, `(a -> b & c -> d) <: ((a | c) -> (b | d))`, `42 <: (42 | 69)`, etc..  > translate `f(e)`  Record subtyping is done by generating (temporary, on the stack) and passing vtables with perfect hashes around.",-0.3125,d
157dlmc,jtqzw76,"Iterable a = linear trait         //""trait"" means ""effect""         next: (ref p: StateRef a) -> Maybe a => State p         end      impl handler Iterable (List 'a) with         //""impl""icit         next r = resumethunk             match get r with                 | x :: xs -> put r xs; Some x                 | Empty -> None         end  So any function calling `next` is monomorphised.",-0.16999999999999998,r
1576cdw,jt3v8aj,"This is the Mutability XOR Aliasing issue raised by Rust, which it addresses via its Borrowing restrictions (preventing mutation), and that Val addresses via its ""subscripts"" (preventing aliasing).",0.0,rust
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,haskell
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,python
1576cdw,jt4w3oe,"Haskell / Python / JavaScript are [generally] memory-safe too but beyond the scope of this article, since they accomplish this by taking away some control over memory).",0.05000000000000002,javascript
1576cdw,jt4w3oe,"I think it would probably be possible to combine something like Rust's alias analysis for mutable pointers with `fip` functions, so you'd have an opt-in borrow checker that you need to enable whenever you wanted mutable pointers into your data structures (where you'd initially need to acquire a uniqueness guarantee, probably by inspecting the reference counts).",0.0,rust
1576cdw,jt4a20l,Are you saying that rust solves this problem?,0.0,rust
1576cdw,jt4a20l,Because looking it up it seems that union field access in Rust is indeed unsafe.,0.0,rust
1576cdw,jt4ssug,"""Unions or equivalent"" includes tagged unions (like Rust's enums).",0.0,rust
1576cdw,jt4ssug,"Rust stops us from doing this because of ""aliasable XOR mutable"":      error[E0506]: cannot assign to `changeable` because it is borrowed       --> src/lib.rs:17:5        |     9  |     let ptr: &&str = match &changeable {        |                            ----------- `changeable` is borrowed here     ...     17 |     changeable = PointerOrInt::SomeInt(12345);        |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `changeable` is assigned to here but it was already borrowed     18 |          19 |     println!",0.0,rust
1576cdw,jt9rjij,"That is, not just a machine type^1 , but a more complex contraption with object header, etc...  ^1 _Not a Lisp machine type, an x86 or ARM machine type._",0.1,lisp
1576cdw,jt59cso,"Oh, you're talking about rust's *enums*.",0.0,rust
1576cdw,jt59cso,"FWIW Rust absolutely does have untagged unions, for C interoperability.",0.2,rust
1576cdw,jt59cso,"FWIW Rust absolutely does have untagged unions, for C interoperability.",0.2,c
1576cdw,jtagowv,"> not just a machine type^1 , but a more complex contraption with object header, etc...  A union, just like a lisp or smalltalk object, is an object with a discriminator, followed by some discriminated data.",0.1,lisp
1576cdw,jtefdau,"That is, given the following code:      union int_or_pointer { int i; void* p; };      int main() {         union int_or_pointer u;         u.i = 42;          int* i = &u.i;          u.p = &u;          *i = 33;          union int_or_pointer* w = u.p;         printf(""%d"", w->i);     }  There's no way, from the point of view of `i`, to realize that the ""parent"" union has changed to a different type.",0.05555555555555555,d
1576cdw,jtefdau,"This is what borrow-checking (Rust) or subscripts (Val) ""solve"", and I don't see how partial read barriers can solve that.",-0.1,rust
1576cdw,jtjhvio,"- Or the escape of the interior pointer, which is what Rust's borrow checking does.",0.0,rust
1576cdw,jtrpfm7,"There is certainly no problem, under this scheme, with getting a pointer to a structure which embeds a union by value.",-0.10714285714285714,scheme
156wrxx,,"E.g., languages like Swift, Haskell, Agda, etc.",0.0,swift
156wrxx,,"E.g., languages like Swift, Haskell, Agda, etc.",0.0,haskell
156wrxx,jt1z53v,At least in Haskell you don't define an operator compared to another one.,-0.3,haskell
156wrxx,jt1z53v,"In something like C# and C++ you can only override existing operators, so that follows their existing precedences.",0.0,c
156wrxx,jt1z53v,"In something like C# and C++ you can only override existing operators, so that follows their existing precedences.",0.0,c++
156wrxx,jt34k06,"Haskell will require that you disambiguate the operator by giving its fully qualified name - for example, `A.??`.",0.0,haskell
156wrxx,jt259zp,As compared to languages like Python or Scala where operators are methods (magic or otherwise) that get called on their left-hand side.,0.5,python
156wrxx,jt259zp,As compared to languages like Python or Scala where operators are methods (magic or otherwise) that get called on their left-hand side.,0.5,scala
156wrxx,jt3yckn,c` might mean?,-0.3125,c
156wrxx,jt2gtdj,"Scala actually does have varying precedence for custom operators, but that precedence is determined by the first character of the operator.",0.125,scala
156wrxx,jt95o3k,"Java pretty much killed it off, and quickly too.",0.12777777777777777,java
156v4mf,,"Consider variable declaration in C vs Python:  C: int age = 21;  Python: age = 21  I don't understand why static types can't be an option for otherwise dynamically typed languages, especially given the capability of type inference, it seems like a small difficulty to allow the programmer to specify a type for their variables in a language that uses dynamic typing.",0.0625,c
156v4mf,,"Consider variable declaration in C vs Python:  C: int age = 21;  Python: age = 21  I don't understand why static types can't be an option for otherwise dynamically typed languages, especially given the capability of type inference, it seems like a small difficulty to allow the programmer to specify a type for their variables in a language that uses dynamic typing.",0.0625,python
156v4mf,jt1mau8,"I'm very interested in following this post, but it's an odd question to ask without even mentioning python type hints, or more importantly: Typescript.",0.21166666666666667,python
156v4mf,jt1mau8,"I'm very interested in following this post, but it's an odd question to ask without even mentioning python type hints, or more importantly: Typescript.",0.21166666666666667,typescript
156v4mf,jt1ltke,"I’ll let others address the nuances around static/dynamic typing as a philosophy and simply point out that Common Lisp supports type specifications, but doesn’t require them.",-0.15,lisp
156v4mf,jt1oq23,"The part about static vs dynamic typing has already been addressed, but I'll point out that in terms of providing or omitting the type, Python has optional type annotations (`a: int = 2`), while C++ allows types to be inferred (`auto a = 2`), and so is the case for most other languages I know",0.21875,python
156v4mf,jt1oq23,"The part about static vs dynamic typing has already been addressed, but I'll point out that in terms of providing or omitting the type, Python has optional type annotations (`a: int = 2`), while C++ allows types to be inferred (`auto a = 2`), and so is the case for most other languages I know",0.21875,c++
156v4mf,jt6h98l,"Just a bit of reference, dlang, also known as D, allows you to not worry types by having an auto keyword.",0.0,d
156v4mf,jt1og7k,"See Hindley/Milner for the most common base  Hybrid strategies exist, like in JVM bytecode all ""objects"" are dynamic at runtime, but the Java compiler enforces type safety at compile time.",-0.15000000000000002,java
156v4mf,jt1og7k,"JRuby)  (Edit: for the purposes of the OP, which I think is more about type _inference_ than static/dynamic typing, and to not put Java into the very-verbose bucket it was born in... Java also keeps getting more and more inference powers.",0.5,java
156v4mf,jt1og7k,"Who knows how far they'll go, but Java's proven strategy is to leverage the ""last mover"" advantage and make decisions with a lot of experts and prior existing work)",0.03333333333333333,go
156v4mf,jt1og7k,"Who knows how far they'll go, but Java's proven strategy is to leverage the ""last mover"" advantage and make decisions with a lot of experts and prior existing work)",0.03333333333333333,java
156v4mf,jt1povu,"Python type hints look weird to me, compared to C/C++, and typescript is fully statically typed, so the type can't be omitted, correct?",-0.5,python
156v4mf,jt1povu,"Python type hints look weird to me, compared to C/C++, and typescript is fully statically typed, so the type can't be omitted, correct?",-0.5,typescript
156v4mf,jt1q52y,">Common Lisp supports type specifications, but doesn’t require them.",0.0,lisp
156v4mf,jt32nav,"Jvm is not that dynamic at runtime like python, ruby or javascript though.",0.0,python
156v4mf,jt32nav,"Jvm is not that dynamic at runtime like python, ruby or javascript though.",0.0,ruby
156v4mf,jt32nav,"Jvm is not that dynamic at runtime like python, ruby or javascript though.",0.0,javascript
156v4mf,jt1r0to,"Typescript has a configuration file so some people like to require types in their codebase, but they aren't required.",0.0,typescript
156v4mf,jt1r0to,All Javascript is valid typescript.,0.0,javascript
156v4mf,jt1r0to,All Javascript is valid typescript.,0.0,typescript
156v4mf,jt1r0to,This makes typescript basically exactly what you're asking for in your post.,0.25,typescript
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,python
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,c
156v4mf,jt1uktq,"> type hints look weird to me, com     Indeed, Python type hints may initially look strange if you're coming from statically typed languages like C or C++.",-0.18333333333333335,c++
156v4mf,jt1uktq,"This is because Python is dynamically typed by default, and type hinting is a feature that was introduced to help make Python code more understandable and easier to debug.",0.5,python
156v4mf,jt1uktq,"In Python, type hints are optional, which means they don't change how the code runs, but they do provide a way for tools and IDEs to give better support for Python development.",0.5,python
156v4mf,jt1uktq,"As for TypeScript, it is indeed a statically typed superset of JavaScript.",0.0,typescript
156v4mf,jt1uktq,"As for TypeScript, it is indeed a statically typed superset of JavaScript.",0.0,javascript
156v4mf,jt1uktq,"So in TypeScript, types can't be omitted in the sense that any variable or function you declare will have a type, whether explicitly declared by you or inferred by TypeScript.",0.0,typescript
156v4mf,jt1uktq,"However, TypeScript does allow a degree of flexibility with types using the ""any"" type when you need it.",0.0,typescript
156v4mf,jt1uktq,"Although it's generally recommended to avoid using ""any"" as much as possible to benefit from TypeScript's type checking features.",0.02500000000000001,typescript
156v4mf,jt2174l,"For Python, Mypy, PyRight, PyType, and Pyre all do this exact thing",0.25,python
156v4mf,jt36eae,"> Jvm is not that dynamic at runtime like python, ruby or javascript though.",0.0,python
156v4mf,jt36eae,"> Jvm is not that dynamic at runtime like python, ruby or javascript though.",0.0,ruby
156v4mf,jt36eae,"> Jvm is not that dynamic at runtime like python, ruby or javascript though.",0.0,javascript
156v4mf,jt36eae,"There are other fun ones out there too -- I think Groovy counts, but Clojure does not.",0.0875,groovy
156v4mf,jt36eae,"There are other fun ones out there too -- I think Groovy counts, but Clojure does not.",0.0875,clojure
156v4mf,jt36eae,"I'll assert that getting a `ClassCastException` _at runtime_ is just as dynamic as getting a fatal `TypeError` _at runtime_ in Python or Ruby for `1 + ""hello""`.",0.0,python
156v4mf,jt36eae,"I'll assert that getting a `ClassCastException` _at runtime_ is just as dynamic as getting a fatal `TypeError` _at runtime_ in Python or Ruby for `1 + ""hello""`.",0.0,ruby
156v4mf,jt36eae,"Beyond that, I don't know how you'd get _more_ dynamic than `invokedynamic` without just being as untyped as Forth.",0.25,forth
156v4mf,jt3ie8f,"It sounds like saying C is as dynamic as python because CPython is written in C.  I mean you can make it as ""dynamic"" as those languages but pay the price of complexity.",-0.10416666666666667,c
156v4mf,jt3ie8f,"It sounds like saying C is as dynamic as python because CPython is written in C.  I mean you can make it as ""dynamic"" as those languages but pay the price of complexity.",-0.10416666666666667,python
156v4mf,jt3ie8f,I think I might have leaned a bit too much on java instead of jvm.,0.2,java
156szm0,,I've been looking at different langs such as C that use variadic arguments but I find it extremely unsafe and not really that practical.,-0.05625,c
156szm0,jt1fzf5,"Java, Golang, and Python all treat varargs as syntatic sugar for an array/slice/tuple.",0.0,java
156szm0,jt1fzf5,"Java, Golang, and Python all treat varargs as syntatic sugar for an array/slice/tuple.",0.0,python
156szm0,jt1csaa,Languages like C# and JS just turn the variadic part into an array.,0.0,c
156szm0,jt1csaa,"In case of C# that happens at compile time, decompiled code will show the construction of an array.",0.0,c
156szm0,jt19jhm,"Object Pascal / Delphi sort of handles this, similar to a list of single dimension array, where you can get the type or number of items.",-0.03571428571428571,pascal
156szm0,jt19jhm,"Object Pascal / Delphi sort of handles this, similar to a list of single dimension array, where you can get the type or number of items.",-0.03571428571428571,delphi
156szm0,jt19jhm,"In a C alike syntax it would be:       void printf        ( items[ ] )      {        int Count = count(items);        typeinfo T = typeof(items[0]);        if ( T = string )           ...;      }      ...     printf(""Hello World"", 5, FALSE, NULL );  This approach may require some Run Time Type Information...",-0.4000000000000001,c
156szm0,jt4a4gl,"In C, because the language is severely feature-poor, we have printf (and not a lot else) that uses it for convenient string formatting (and is full of security holes to boot!)",0.4375,c
156szm0,jt4a4gl,"Here's a list of things that people use variadics for:  - Nicer syntax for passing a list as an argument - Implicit builder patterns - Compensating for the lack of first-class tuple types - Compensating for the lack of generics over function types  Rust has something that strongly resembles printf, but in fact it is a macro that abstracts a builder pattern.",0.4333333333333333,rust
156szm0,jt4a4gl,"I code a lot of Rust, and I have never missed not having variadic functions.",0.0,rust
156szm0,jt2566x,"The version is C can have arguments of any mixed types, but the types are not specified and the compiler cannot check them when calling such functions.",0.0,c
156szm0,jt2566x,"I've not implemented them myself (other than when implementing C), but I did have a design for variadic parameters that looked like this:      proc F(int a, b, c ...) =  Parameters `a b c` would all have type `int`, but the ellipsis denotes that `c` represents a set of 0 or more variadic parameters, each of type `int`.",0.1875,c
156szm0,jt2566x,Note there is no comma between `c` and `...`; here the variadic set is named (`c`) and typed (`int`).,0.0,c
156szm0,jt2566x,"Inside the callee `F`, they are accessed just like a slice:      for x in c do         println x         # print all the variadics     end  So you could say this is just syntactic sugar for slices.",0.0,c
156szm0,jt26s39,"Basically, imagine how Python does it, then apply it to a static subroutine in Assembly.",0.5,python
156szm0,jt26s39,"Basically, imagine how Python does it, then apply it to a static subroutine in Assembly.",0.5,assembly
156szm0,jt26s39,"For example, in Python, we demure the beginning of out varargs with `*arg`.",0.0,python
156szm0,jt26s39,Make sure to add something like `argc` in your Assembly code too.,0.5,assembly
156szm0,jt2vcww,"For example, these both print ""age: 100"":      [(STDIO.printf ""%s: %d"") <- ""age"" <- 100]      ((STDIO.vprintf ""%s: %d"") [""age"" & 100 & 'nil])  In the first case, I use `STDIO.printf` to compute a curried function from the format string and in the second case, I compute a function that takes a data structure with the needed substitutions.",-0.16666666666666666,d
156szm0,jt8mhlz,"For languages with tuples/unions you can desugar the last few arguments to create a tuple, like Typescript.",-0.1,typescript
156szm0,jt8mhlz,"const map: Map<string, int> = makeMap(1000,   ""a"", 1,   ""b"", 2,   ""c"", 3 ); ```  Imagine the `...nextPart` is special syntax for forwarding all the remaining arguments to the overloaded `nextPart` function.",0.35714285714285715,c
156szm0,jt1ccd9,"C# requires you to type the array, or use the base `object` type.",-0.8,c
156szm0,jtdhpzn,Rust is a prime example of no-varargs going horribly wrong.,-0.5,rust
156szm0,jt3ef3q,That's because varargs introduce ambiguity when there's partial application involved as in Haskell.,-0.1,haskell
156szm0,jtdou09,"Okay, besides printf — which rust has, type-safe and all, through a macro — what's the best use of varargs?",0.75,rust
156szm0,jt275uu,They only serve as a footgun on C style string formatting.,0.0,c
156szm0,jt3nc5l,As seen in Rust.,0.0,rust
156szm0,jtdtd1q,Varargs would remove ~80% of macro uses in Rust code in the wild.,0.1,rust
156szm0,jt2mvwc,"Your options are an untyped language (fair enough), or a typed language with untyped variadics (what C does), or a dependently-typed language (where the type of your variadics would be something like `[(t:Type), t]`).",0.35,c
156szm0,jt5ugih,in C# `new [] { ... }` can become pretty bulky.,0.19318181818181818,c
156szm0,jtdybgc,"80% of Rust macro uses are derive macros, so no, that is simply untrue.",0.0,rust
156szm0,jtfj6yq,60% of Rust macro uses is `vec!`.,0.0,rust
156szm0,jtg65l9,"Every single time a Rust type has a `#[derive(...)]` annotation, that's a macro invocation for each type derived.",-0.07142857142857142,rust
156szm0,jtg65l9,That makes up the vast majority of Rust macro usage.,0.0,rust
156szm0,jtg65l9,"As for `vec!`, it will intrigue you to know that this macro is in fact merely a first-class citizen among a group of very similar forms of syntactic sugar:  C# 10 has some interesting syntactic sugar that rewrites initializer lists into repeated applications of `ICollection<T>.Add`, and C++ has it's own entire thing of dark magic.",0.1357142857142857,c
156szm0,jtg65l9,"As for `vec!`, it will intrigue you to know that this macro is in fact merely a first-class citizen among a group of very similar forms of syntactic sugar:  C# 10 has some interesting syntactic sugar that rewrites initializer lists into repeated applications of `ICollection<T>.Add`, and C++ has it's own entire thing of dark magic.",0.1357142857142857,c++
156szm0,jtg65l9,"Go has direct syntax, as does D. As far as I can tell, Java does use its vararg feature, sure, but that is far from the norm.",0.19999999999999998,go
156szm0,jtg65l9,"Go has direct syntax, as does D. As far as I can tell, Java does use its vararg feature, sure, but that is far from the norm.",0.19999999999999998,java
156szm0,jtg65l9,"So, apart from `println!` and friends which ""use macros to emulate varargs"", and that fact that varargs are really just a poor man's macros, what _other_ Rust macros do you know of that emulate varargs?",-0.10833333333333334,rust
156szm0,jt3r6xc,It's an experiment in how much static checking one can do in a language that has no explicit types (think classless Python).,0.5,python
156szm0,jt9l373,"C has had dynamic typing since its inception, and C++ has had statically typed heterogeneous lists since 3.0 in 1991.",0.0,c
156szm0,jt9l373,"C has had dynamic typing since its inception, and C++ has had statically typed heterogeneous lists since 3.0 in 1991.",0.0,c++
156ng13,jt225wp,"The meaning most of us give it today rather corresponds to the concepts introduced with Simula 67 and continued with Smalltalk-76/80, C++ and Java, to name a few.",0.15,c++
156ng13,jt225wp,"The meaning most of us give it today rather corresponds to the concepts introduced with Simula 67 and continued with Smalltalk-76/80, C++ and Java, to name a few.",0.15,java
156ng13,jtl3xra,This is the paper that eventually led to try/catch and checked exceptions in Java.,0.0,java
156ng13,jt1hzel,InProceedings of the international conference on APL: part 1 1979 May 30 (p. 340).,0.0,apl
156ng13,jt1hzel,"we have   ""Three different paths in the development of generic-concept languages have been followed by APL, Algol 68, and **object-oriented** languages such as SIMULA 67 and Smalltalk.""",0.0,apl
156ng13,jt1hzel,"we have   ""Three different paths in the development of generic-concept languages have been followed by APL, Algol 68, and **object-oriented** languages such as SIMULA 67 and Smalltalk.""",0.0,algol
156ng13,jt695k7,"The approach probably first appeared in LISP systems, and notably in Ivan Sutherland's Sketchpad, which has objects and instances.",0.375,lisp
156ng13,jt55y9g,"At the latest since Ingalls' 2020 paper, several people should go over the books.",0.25,go
156ng13,juj4nce,"The treatment in the CACM article isn't as detailed as the one linked here, but the scheme he describes in the earlier paper is definitely more OOP-y than e.g.",0.3,scheme
156ng13,juj4nce,Java.,0.0,java
156ng13,jt6fr5c,"That's the first language supporting OOP, Sketchpad was much earlier - 1963, and used objects (masters) and instances, and I think there was experimentation with similar techniques in LISP possibly even earlier.",0.08333333333333333,lisp
156ng13,jujg5ju,> the scheme he describes in the earlier paper is definitely more OOP-y than e.g.,0.25,scheme
156ng13,jujg5ju,Java.,0.0,java
156ng13,jt6b7zu,"Whitewater were acquired by Borland for their resource editor, which ended up packaged with Borland C++, and Actor was left to wither.",0.0,c++
156ng13,jto1lx2,Iirc I ended up using VB for the first (and last) time for a few days some time around 2000 because Delphi was playing up.,0.016666666666666663,delphi
156ng13,jto1lx2,I went back to Delphi.,0.0,delphi
156ng13,jto1lx2,"> were acquired by Borland for their resource editor, which ended up packaged with Borland C++  (and Delphi, I presume, not to rub it in about VB... 😁)  > Actor was left to wither.",0.0,c++
156ng13,jto1lx2,"> were acquired by Borland for their resource editor, which ended up packaged with Borland C++  (and Delphi, I presume, not to rub it in about VB... 😁)  > Actor was left to wither.",0.0,delphi
156ng13,jto1lx2,Was it similar to how Erlang doesn't really follow the model or was it worse than that?,-0.06666666666666667,erlang
156ng13,jtpa8x5,"Interestingly, Self pioneered the kind of JIT techniques now used by Java and JavaScript VMs, so we're all benefitting from the pioneers of early OOP still.",0.4000000000000001,java
156ng13,jtpa8x5,"Interestingly, Self pioneered the kind of JIT techniques now used by Java and JavaScript VMs, so we're all benefitting from the pioneers of early OOP still.",0.4000000000000001,javascript
156ng13,jtpa8x5,"Just as Smalltalk bears little relation to later OO languages, Self bears little relation of prototype-based programming as it manifests in JavaScript.",-0.125,javascript
156joln,jszx631,"Dennis M. Ritchie rewrote McIlroy's roff in PDP-11 assembly for Version 1 AT&T UNIX, Joseph F. Ossanna improved roff and renamed it nroff for Version 2 AT&T UNIX, then ported nroff to C as troff, which Brian W. Kernighan released with Version 7 AT&T UNIX.",0.0,assembly
156joln,jszx631,"Dennis M. Ritchie rewrote McIlroy's roff in PDP-11 assembly for Version 1 AT&T UNIX, Joseph F. Ossanna improved roff and renamed it nroff for Version 2 AT&T UNIX, then ported nroff to C as troff, which Brian W. Kernighan released with Version 7 AT&T UNIX.",0.0,c
156joln,jszx631,"In 1989, James Clark re-implemented troff in C++, naming it groff.",0.0,c++
156ggyr,,"If lifetime is not ended manually, lifetime is automatically ended at the end of function as in all C style languages.",0.0,c
156ggyr,jt039p2,"There's really no need to go off inventing strange and novel syntactic constructs, when so many well-known and widely-accepted existing syntactic constructs will suffice.",0.11666666666666665,go
156ggyr,jt057nb,It's kinda like python comprehension lists?,0.0,python
156ggyr,jt0uck1,"Clojure has a similar feature called *transducers*, though they're just a slight simplification on *foldl*.",-0.08333333333333333,clojure
156ggyr,jt361xo,"In Julia, even easier, just prefix function with a '.",0.0,julia
156ggyr,jt07c4a,What else can you suggest instead @ I can think of $ or `  Those @ is equivalent to javascript 'let' or python 'del'.,0.0,javascript
156ggyr,jt07c4a,What else can you suggest instead @ I can think of $ or `  Those @ is equivalent to javascript 'let' or python 'del'.,0.0,python
156ggyr,jt070od,Python comprehension lists follow a specific syntax.,0.0,python
156ggyr,jt1pizs,"[ @x, @y     @temp = x % y     @a = temp * a     @b = temp@ * b ].unzip()  i feel like it's much more needed, because there's a and b, which i guess as variables in that block are collected, but there's temp too, that should be collected too then  &#x200B;  to illustrate, here's a syntax that i think helps on that aspect:  this:      @x = getX()     @y = getY()     @temp = x % y     @a = temp * a     @b = temp@ * b     useAB(a, b)  would become:      @xs = getXs()     @ys = getYs()     @as, @bs = @a, @b foreach @x, @y in zip(xs, ys)     @temp = x % y     @a = temp * a     @b = temp@ * b     endfor     useABs(as, bs)  i'm using a python like syntax because i'm used to it, but it's just to give an idea of a syntax that has all the element i think were missing.",0.15,python
156ggyr,jt09uay,"``` `a = 5 `b = 10 `c = a` + b` ``` Also, it is not mandatory to mark last use of a variable with trailing @.",0.0,c
156bfwc,jsyvd2o,Is implementation supposed to only have a single example or does stuff like the rust match statement not qualify as pattern matching?,-0.03571428571428571,rust
156bfwc,jt07eke,This is really cool.,0.35,cool
156bfwc,jsze94h,Look at the crap of C++ we are in we all understand that.,-0.8,c++
156bfwc,jt0f8ta,>One language I saw here on this sub had a cool feature where blocks become part of the control flow.,0.35,cool
15661oq,,"The commands :  `*` flip a cell  `<` go to the left cell  `>` go to the right   `{A|B}` execute the commands A if the current cell is true, execute the commands B else  `!` terminate the program with NonHaltingError, used for loops  There are no real input output for the moment, I'm still thinking about this problem.",0.12464285714285714,go
15661oq,,"There are other special characters :  `#` comments, similar to python   `""module""` to import a module   `:=` is use to define macros (example after)   `'` inverse the command   `n` execute the command n times   `()` is used to group commands   Macros :  We can define new commands with macros.",0.09212662337662338,python
15661oq,jsysf6g,Try looking into a language called APL.,0.0,apl
15661oq,jsz51ad,That is a super cool idea.,0.3416666666666667,cool
15661oq,jsyu1or,"APL works on matrices, my language is programmed WITH matrices.",0.0,apl
15661oq,jt0jx8i,I'm a little saddened that my idea isn't original but I want to go to the end of implementation.,0.09375,go
155t03q,,"You don't really need a lot of speed when making bootstrap compilers, so why isn't python used more?",0.35,python
155t03q,jsw56s2,"Python only got pattern matching in [3.10](https://peps.python.org/pep-0636/), which eases writing, but it would appear that due to the lack of static typing, there's no compile-time exhaustiveness checking.",0.125,python
155t03q,jszslgj,"I am developing [Cwerg](http://cwerg.org), a new C-like language, primarily in Python.",0.2681818181818182,python
155t03q,jszslgj,"The idea is to proto-type it in Python and once the design is stable to re-implement it in another more performant language, e.g.",0.5,python
155t03q,jszslgj,C++.,0.0,c++
155t03q,jszslgj,I am actively working on the frontend in Python.,-0.13333333333333333,python
155t03q,jszslgj,Some preliminary observations:     * python execution speed has not been a problem yet.,0.0,python
155t03q,jszslgj,"It is disappointing, though, that there is still no good performance story for Python even if you have no deps to speak of and do not use a lot of the dynamic features of the language * using type annotations is key both for correctness and the IDE support it enables * having two implementations is super valuable, it make them both more deterministic * I cannot imagine developing Cwerg in any other way.",-0.034523809523809526,python
155t03q,jszslgj,The iteration time with Python is just unparalleled.,0.0,python
155t03q,jszslgj,C++ by comparison is painfully slow.,-0.30000000000000004,c++
155t03q,jszslgj,"* I firmly believe, that it would have been slower to develop the compiler in C++ only.",-0.1,c++
155t03q,jsx8v22,"Most compiler passes are naturally recursive, which is something python is extraordinarily bad at (both lacking proper tail calls and having a comically low recursion limit of 1000).",-0.019999999999999973,python
155t03q,jsx8v22,You really don't gain anything other than possibly familiarity by choosing python over most other mainstream-ish languages,0.09,python
155t03q,jsybj7w,"Because you're better off with Haskell, a ML, or a Lisp.",0.5,haskell
155t03q,jsybj7w,"Because you're better off with Haskell, a ML, or a Lisp.",0.5,lisp
155t03q,jswedcw,"As someone said before, compilers use a lot of pattern matching and I did not have in mind that python recently added that.",0.0,python
155t03q,jswedcw,"I also wanted a language that came with a great testing suit and I dont know of python having a command ""test"" that runs all tests in the project or directory, and that would require me to learn a 3rd parry framework.",0.4,python
155t03q,jswedcw,So I went with rust.,0.0,rust
155t03q,jswedcw,I would have gone with java but is too verbose and I wasnt aware of JDK16 up until a week ago.,0.25,java
155t03q,jsz9v4b,Even C's type system is better than nothing.,0.5,c
155t03q,jsxg4am,Because Haskell and similar are pretty much strictly and fairly objectively better for compiler dev.,0.2375,haskell
155t03q,jsxhitb,"I'm writing my bootstrap compiler in C++, but all of my code generation tools so far are written in python.",0.1,c++
155t03q,jsxhitb,"I'm writing my bootstrap compiler in C++, but all of my code generation tools so far are written in python.",0.1,python
155t03q,jswn4sx,PyPy) but generally speaking the performance of python is not really adapted to a tool that will have to do a lot of computation in not so much time.,0.05000000000000001,python
155t03q,jsx3wm4,I did generate Assembly with Python.,0.0,assembly
155t03q,jsx3wm4,I did generate Assembly with Python.,0.0,python
155t03q,jsym6x3,Ruby is better for this kind of stuff anyway.,0.55,ruby
155t03q,jsz18om,"It's funny, y'know, because I could write a compiler much quicker in Python, and it would certainly be less error-prone, than if I wrote it in say, C++.",0.09444444444444444,python
155t03q,jsz18om,"It's funny, y'know, because I could write a compiler much quicker in Python, and it would certainly be less error-prone, than if I wrote it in say, C++.",0.09444444444444444,c++
155t03q,jsz18om,"Maybe I should prototype mine in Python and reïmplement it in C++ when mature...  Also, all the people lamenting Python's pattern-matching, I think this is only half the puzzle.",-0.022222222222222216,python
155t03q,jsz18om,"Maybe I should prototype mine in Python and reïmplement it in C++ when mature...  Also, all the people lamenting Python's pattern-matching, I think this is only half the puzzle.",-0.022222222222222216,c++
155t03q,jsz18om,"A large part of compiler development is text processing, which Python is quite intuitive for...",0.21428571428571427,python
155t03q,jsvwaoc,"I'll go ahead and answer my own question and say that it's probably because a lot of people prefer static typing, but then nobody makes compilers in Java either.",0.55,go
155t03q,jsvwaoc,"I'll go ahead and answer my own question and say that it's probably because a lot of people prefer static typing, but then nobody makes compilers in Java either.",0.55,java
155t03q,jsxtdw8,"It doesn't use a compiler    is an interpreted language, which means the source code of a Python program is converted into bytecode that is then executed by the Python virtual machine",0.0,python
155t03q,jsyx63z,"Speaking as someone whose last few compiler projects were written in Python :P  For a one person project on a toy language it's fine, but I think for more complex compilers with multiple contributors Python doesn't scale as well as other languages do.",0.13020833333333334,python
155t03q,jsyx63z,"Python is easy to write but also easy to make mistakes/introduce bugs that can be tricky to debug in a complex piece of software like a compiler, mitigating those risks requires extra work that you wouldn't need to do in other languages, so unless you have a specific reason to make your compiler in Python usually other languages are better.",0.10208333333333333,python
155t03q,jsz2g9o,"Mainly, because it seems 95% of programming-language hobbyists are also inveterate Haskell or ML fans.",0.16666666666666666,haskell
155t03q,jsz2g9o,"Sure you can do compilers with pattern-matching, but then you can also write a C compiler in C, or a Pascal compiler in Pascal.",0.5,c
155t03q,jsz2g9o,"Sure you can do compilers with pattern-matching, but then you can also write a C compiler in C, or a Pascal compiler in Pascal.",0.5,pascal
155t03q,jsz2g9o,If that's Python (as it is for me) then go right ahead and build your bootstrap therein.,0.2857142857142857,python
155t03q,jsz2g9o,If that's Python (as it is for me) then go right ahead and build your bootstrap therein.,0.2857142857142857,go
155t03q,jsz2g9o,Here's why: Nothing stops big companies from doing big software engineering on Python.,0.0,python
155t03q,jt1665n,I usually use python for demo-development/prototyping or writing a proof of concept,-0.25,python
155t03q,jt9dizp,"I started writing mine in Python, in the end I'll probably switch to like Rust but I find it easier to prototype in Python ([link to my compiler so far](https://github.com/SamG101-Developer/SPP-Compiler-2/tree/master/src)).",0.0,python
155t03q,jt9dizp,"I started writing mine in Python, in the end I'll probably switch to like Rust but I find it easier to prototype in Python ([link to my compiler so far](https://github.com/SamG101-Developer/SPP-Compiler-2/tree/master/src)).",0.0,rust
155t03q,jsz10v8,Python is _not_ a crappy language,0.0,python
155t03q,jsxscnu,Including Python.,0.0,python
155t03q,jsyiqqe,Haskell?,0.0,haskell
155t03q,jswqluy,"> I dont know of python having a command ""test"" that runs all tests in the project or directory, and that would require me to learn a 3rd parry framework.",0.0,python
155t03q,jswqluy,"pytest, while being a 3rd party framework, it perfectly supports the native python unittests, and it's not that complicated to learn, it should take 10min give or take.",0.16666666666666666,python
155t03q,jt5n38k,Ha cool!,0.4375,cool
155t03q,jt5n38k,Oils is using both ASDL and pgen2 with C++ back ends as well.,0.0,c++
155t03q,jt5n38k,"It's been all over the blog, not particularly organized, but I may write up an architecture description later:  https://www.oilshell.org/blog/2022/03/middle-out.html  https://www.oilshell.org/blog/tags.html?tag=ASDL#ASDL  I've indeed found it  useful to borrow metalanguages from Python itself.",0.07222222222222223,python
155t03q,jt5n38k,"Oils is made faster via a translator from statically typed Python to C++ called ""mycpp"".",0.0,python
155t03q,jt5n38k,"Oils is made faster via a translator from statically typed Python to C++ called ""mycpp"".",0.0,c++
155t03q,jt5n38k,There are some cool parts of the runtime that I would like to expose to users eventually.,0.35,cool
155t03q,jt5n38k,It would basically be like if:  - shell was a good language - the C preprocessor and shell were the SAME language (they are kinda  similar if you squint?),0.2333333333333333,shell
155t03q,jt5n38k,It would basically be like if:  - shell was a good language - the C preprocessor and shell were the SAME language (they are kinda  similar if you squint?),0.2333333333333333,c
155t03q,jswbcd3,Java is too verbose.,0.0,java
155t03q,jswbcd3,People typically choose Java only if they want to write a language that targets JVM.,-0.08333333333333333,java
155t03q,jswbfjf,"People absolutely do use Java, many resources like Crafting Interpreters and Modern Compiler Implementation use Java, it was the choice in the course I took and doesn't seem to be uncommon in general.",0.35,java
155t03q,jswbfjf,"I also think that other languages which have a larger focus on modularity, safety, and encapsulation and less of a focus on dynamism are a little bit better suited towards complex projects like compilers, though I'm sure there are plenty of examples of successful complex python projects out there.",0.07453703703703704,python
155t03q,jswbfjf,"Also [Vinegar](https://github.com/catseye/Vinegar) is an example of a proof-of-concept implementation in Python, and [Thun](https://joypy.osdn.io/) is a Joy interpreter written in Python.",0.8,python
155t03q,jt16q5x,"By the way python is actually used for compilerdev, example:  * numba + llvmlite * shivyc * pypy(?)",0.0,python
155t03q,jsz9nfx,"Python's niche is, apparently, gluing together useful code that is *not* written in Python.",0.175,python
155t03q,jsyvgp3,"OCaml is another good option, it has nice FP features but is a bit more flexible than Haskell.",0.6,haskell
155t03q,jsyvgp3,"The initial compiler for Rust was written in OCaml, before it was self-hosted.",0.0,rust
155t03q,jsyydwr,Scala is very cool too.,0.45499999999999996,scala
155t03q,jsyydwr,Scala is very cool too.,0.45499999999999996,cool
155t03q,jsyydwr,The mainstream examples are fastparse or scala parser combinator libraries,0.0,scala
155t03q,jsxi4iv,"> Python has a de-facto standard testing framework, pytest that makes it very simple, and it has a first party stdlib solution unittests, although that is considered too verbose today.",0.08333333333333333,python
155t03q,jsxi4iv,">If you consider rust as an alternative to python in terms of dev speed, then that's a valid choice, but I don't agree with that tradeoff at all.",0.0,rust
155t03q,jsxi4iv,">If you consider rust as an alternative to python in terms of dev speed, then that's a valid choice, but I don't agree with that tradeoff at all.",0.0,python
155t03q,jsxi4iv,On python I have to be very sure to not pass an invalid type to the function or else I get weird behaviours and those are hard to find later,-0.035416666666666666,python
155t03q,jt5zq3z,"Cooperating with Oils would be cool, but I fear it's still quite a distant goal.",0.12499999999999999,cool
155t03q,jt5zq3z,"I do like the ideas, though, (both of putting Bondrewd to good use for metaprogramming in an existing project, and of tighter interactions between the shell and a metaprogramming language), and will absolutely look into them after reaching a sufficient working prototype",0.44999999999999996,shell
155t03q,jswl9uv,You can write Java without it being verbose so long as you throw out getters/setters and just use public fields.,-0.025,java
155t03q,jswjask,Wondering whether it \*is\* possible to target JVM \*without\* wring a compiler in Java?,0.0,java
155t03q,jt1wvox,I can tell you that my first two compilers were written in assembly language; using any sort of HLL was a big step up!,0.125,assembly
155t03q,jsxckk3,"Then:  ``` python -m unittest ```  It will find all `test*.py` files in your project and import them, to finally execute all the test cases it found.",0.0,python
155t03q,jsxckk3,"Though i'd recommend putting them in a `tests/` folder and:  ``` python -m unittest -s tests ```  Still, IMHO, pytest is one of the best test framework there is, in all languages, and it's a shame to not use it.",1.0,python
155t03q,jt7xhx7,"Cool, I checked out the blog posts  I'm excited for your journey :)  IMO the beginning is the most fun part of making a language -- you can explore anything  Now that I've been doing this for over 7 years, I'm still having fun, but I have to resist the urge to go on tangents :)  One thing I find interesting is whether the metaprogramming language is the same as the language, or different  For a compiled language, there are some big tradeoffs there (e.g.",0.30227272727272725,cool
155t03q,jt7xhx7,"Cool, I checked out the blog posts  I'm excited for your journey :)  IMO the beginning is the most fun part of making a language -- you can explore anything  Now that I've been doing this for over 7 years, I'm still having fun, but I have to resist the urge to go on tangents :)  One thing I find interesting is whether the metaprogramming language is the same as the language, or different  For a compiled language, there are some big tradeoffs there (e.g.",0.30227272727272725,go
155t03q,jsx8qxf,One step closer to Kotlin.,0.0,kotlin
155t03q,jsyvlpx,"Relevant to both this thread and your comment, [compiler written in Python targeting JVM](https://yangdanny97.github.io/blog/2021/08/26/chocopy-jvm-backend)",0.4,python
155t03q,jsx1hxb,"Yeah, the Scala compiler is written in Scala and the Kotlin compiler is mostly Kotlin",0.5,scala
155t03q,jsx1hxb,"Yeah, the Scala compiler is written in Scala and the Kotlin compiler is mostly Kotlin",0.5,kotlin
155t03q,jt83vp9,"So instead I chose to do what Python does, requring everything to be defined by the time of first usage.",0.25,python
155t03q,jt83vp9,"Probably, rtime code will also be able to interact with ctime constructs through a specific interface, similar to how Python allows C extension libraries.",0.16666666666666666,python
155t03q,jt83vp9,"Probably, rtime code will also be able to interact with ctime constructs through a specific interface, similar to how Python allows C extension libraries.",0.16666666666666666,c
155t03q,jt83vp9,"I've actually considered just making a Python library to simplify writing programs as compilation scripts, but have decided against it.",0.0,python
155t03q,jt83vp9,"While both Lua and Python are self-implemented (if observed from within the language), the runtime language on top of them would have to be integrated into the same mechanism in order to be sufficiently uniform, and that would make it poorly suited for performance-sensitive runtime evaluation",0.033333333333333326,lua
155t03q,jt83vp9,"While both Lua and Python are self-implemented (if observed from within the language), the runtime language on top of them would have to be integrated into the same mechanism in order to be sufficiently uniform, and that would make it poorly suited for performance-sensitive runtime evaluation",0.033333333333333326,python
155t03q,jt9m28p,Though I'd also say Julia's metaprogramming and compilation model could be related.,0.0,julia
155rqm1,jsy9497,"Minor tip i got from the (very readable but informal) Go specification is, if your language is syntactically heterogeneous, to pick apart grammar productions in bundles that make semantic sense, and for each syntactical term, give a semantical meaning.",0.07500000000000001,go
155rqm1,jswcy3a,You iterated all the way from C to S and transpilong to C++?,0.0,c
155rqm1,jswcy3a,You iterated all the way from C to S and transpilong to C++?,0.0,c++
155rqm1,jswcy3a,It is a bit too much code to go through just to have some feel of what you do.,0.2,go
155rqm1,jswcy3a,"Your code base looks clean, at least on python side, but I haven't look detailed in source so I don't know how good it is.",0.07333333333333332,python
155rqm1,jswcy3a,"I am not sure why do you have so much similarity to C++ in your STL, are you transpiling to C++?",-0.024999999999999994,c++
155rqm1,jsy706y,If you by any chance learn LISP before you found that in their vocab theirs a lot of abbreviations.,0.0,lisp
155rqm1,jsypm4t,"Looks pretty cool, how long have you been working on it?",0.18333333333333332,cool
155rqm1,jsx02vy,i'm going to compile the AST using LLVM (specifically the llvmlite library) and go from there.,0.0,go
155rqm1,jszukxw,"honestly reddit is great for specific articles on bits of language design, also finding blogs of other language designers like Graydon's who's put a couple stuff out there about Rust etc.",0.31875,rust
155rqm1,jsvukq4,"It allows splitting inheritance per base class, like Rust's splitting impls on a struct per trait.",-0.8,rust
155rqm1,jsxkbws,I'd probably go with always mandating `{}` like Rust does.,0.0,go
155rqm1,jsxkbws,I'd probably go with always mandating `{}` like Rust does.,0.0,rust
155cisi,,I have read a handful of books that go into typechecking in languages but most of them skip over the idea of having null in a language.,0.5,go
155cisi,jsty31j,After way to many `NullPointerException`s in Java in the past.,0.125,java
155cisi,jsty31j,[enum `Option`](https://doc.rust-lang.org/std/option/) in Rust.,0.0,rust
155cisi,jsty31j,"For instance in [Kotlin](https://kotlinlang.org/docs/null-safety.html#nullable-types-and-non-null-types), if we have a `val s: String`, then `s` is guaranteed to be a `String`.",0.0,kotlin
155cisi,jsty31j,"TypeScript has [union types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types), which allow a type to be specified like, e.g.",0.0,typescript
155cisi,jsty31j,"function f(x: number | string | null) {         if (typeof x === ""number"") {             console.log(""x is a number"");         } else if (typeof x === ""string"") {             console.log(""x is a string"");         } else {             console.log(""x is null"");         }     }          f(123);     f(""Hello World"");     f(null);  Something similar is possible in Kotlin using [sealed classes](https://kotlinlang.org/docs/sealed-classes.html) and the [`is` operator](https://kotlinlang.org/docs/typecasts.html#is-and-is-operators).",0.0,kotlin
155cisi,jsty31j,"Here's a tiny AST example:      sealed class Expr      class Const(val num: Int) : Expr()     class Add(val lhs: Expr, val rhs: Expr) : Expr()     class Sub(val lhs: Expr, val rhs: Expr) : Expr()      fun eval(expr: Expr): Int =         when (expr) {             is Const -> expr.num             is Add -> eval(expr.lhs) + eval(expr.rhs)             is Sub -> eval(expr.lhs) - eval(expr.rhs)         }       fun main() {         println(eval(Const(1)))         println(eval(Add(Const(1), Sub(Const(4), Const(2)))))     }  Given that `expr` is a `sealed class`, then Kotlin enforces that all classes derived from `Expr` is matched in the [`when` expression](https://kotlinlang.org/docs/control-flow.html#when-expression).",0.19166666666666665,kotlin
155cisi,jstwdge,"In Kotlin, nullable references form a separate type hierarchy (X?).",0.0,kotlin
155cisi,jstwdge,There were also C dialects with non-nullable pointer types.,0.0,c
155cisi,jstunlj,One example of the right way to go is  [https://doc.rust-lang.org/std/option/](https://doc.rust-lang.org/std/option/)  NULL is just a huge mess around that.,0.17023809523809522,go
155cisi,jsu04qy,You can study how Dart or Swift implemented their null-safe types.,0.0,dart
155cisi,jsu04qy,You can study how Dart or Swift implemented their null-safe types.,0.0,swift
155cisi,jsunmvn,"This largely corresponds with how it is done in C, although C doesn't have a dedicated `NULL` literal, it uses `0` (sometimes, `NULL` is defined as `(void*)0`).",0.21428571428571427,c
155cisi,jsunmvn,"I can use `nil` in dynamic code like this:      f := fopen(""file"",""r"")     # call C function via FFI     if f = nil then            # could not open file  If a language does not support the concept of `nil` or `NULL`, and you want to call functions via FFIs like my example, then you will a workaround.",0.0,r
155cisi,jsunmvn,"I can use `nil` in dynamic code like this:      f := fopen(""file"",""r"")     # call C function via FFI     if f = nil then            # could not open file  If a language does not support the concept of `nil` or `NULL`, and you want to call functions via FFIs like my example, then you will a workaround.",0.0,c
155cisi,jsu5nnv,"For example, a byte with null example would support the values of:       0 ... 255 , NULL  The concept of ""null"" did exist before on Lisp, but used ""nil"" instead.",0.0,lisp
155cisi,jsu5nnv,"Before Java retake Lisp usage of null, null was used as the empty value of pointers.",-0.1,java
155cisi,jsu5nnv,"Before Java retake Lisp usage of null, null was used as the empty value of pointers.",-0.1,lisp
155cisi,jsv1mzp,"It's an empty list, an empty tree, and so forth.",-0.1,forth
155cisi,jsv1mzp,"After all, there's literal-list syntax for both terms and types in Haskell.",0.0,haskell
155cisi,jsy60o6,For languages in the C lineage (e.g.,0.0,c
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,c
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,c++
155cisi,jsy60o6,"C, C++, Java), `NULL` is just one possible address that a pointer can hold.",0.0,java
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,c
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,c++
155cisi,jsy60o6,"The troublesome design choice in many languages (C, C++, Java, etc.)",0.5,java
155cisi,jsy60o6,"For languages in the Lisp lineage (dynamically typed, e.g.",0.0,lisp
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,lisp
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,python
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,ruby
155cisi,jsy60o6,"Lisp, Python, Ruby, Javascript), `nil` is a singleton object with its own type, often used to represent an empty list or a missing value.",0.09999999999999999,javascript
155cisi,jsy60o6,"SML, Rust, Haskell), there typically isn't really a notion of NULL, there are only [sum types](https://en.wikipedia.org/wiki/Tagged_union), which represent things that can be one of several possible values.",0.05,rust
155cisi,jsy60o6,"SML, Rust, Haskell), there typically isn't really a notion of NULL, there are only [sum types](https://en.wikipedia.org/wiki/Tagged_union), which represent things that can be one of several possible values.",0.05,haskell
155cisi,jstwsf6,yea subtyping would probably be the way to go but my language is still pretty primitive and my current goal was to try and get a decent number of features to the point where i could bootstrap the language.,0.13888888888888887,go
155cisi,jsur9sh,"In Kotlin, is flow typing used to narrow a `String?` to a `String` after a null check?",-0.2,kotlin
155cisi,jsu2kta,Kotlin uses null to represent optionals.,0.0,kotlin
155cisi,jstydrx,"At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W).",0.25,algol
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,c
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,java
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,ruby
155cisi,jstwc7s,"Its pretty common to have some form of null in a language C#, Java, ruby, python etc.",-0.024999999999999994,python
155cisi,jsutsgq,"> C doesn't have a dedicated NULL literal, it uses 0 (sometimes, NULL is defined as (void*)0).",0.0,c
155cisi,jsusbzs,"In Rust for example, it's defined in the standard library (not in the compiler itself), any user could've defined it.",0.0,rust
155cisi,jsuf6xv,"Which is something that can come up, when iterating, mapping, filtering, and flattening [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html)s and [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html)s in Rust at least.",-0.3,rust
155cisi,jsuuh3m,"Yes, Kotlin features a limited form of flow-sensitive typing and calls it [smart casts](https://kotlinlang.org/spec/type-inference.html#smart-casts).",0.07142857142857142,kotlin
155cisi,jsvz3lq,"In case of Kotlin, decision to have special case type hierarchy for nullable types (and not having union types in the language, although this question was raised regularly in scope of Kotlin/JS and interoperability with TypeScript) was primarily a type inference performance concern.",0.2523809523809524,kotlin
155cisi,jsvz3lq,"In case of Kotlin, decision to have special case type hierarchy for nullable types (and not having union types in the language, although this question was raised regularly in scope of Kotlin/JS and interoperability with TypeScript) was primarily a type inference performance concern.",0.2523809523809524,typescript
155cisi,jsv6plv,Kotlin uses [nullable types](https://en.wikipedia.org/wiki/Nullable_type) which are more like [union types](https://en.wikipedia.org/wiki/Union_type) than [option types](https://en.wikipedia.org/wiki/Option_type).,0.5,kotlin
155cisi,jsv6plv,Nullable types are more convenient to work with in many cases and are more familiar to imperative programmers coming from languages like Java with `null`.,0.46875,java
155cisi,jsuahmn,syntax in Kotlin.,0.0,kotlin
155cisi,jsu7eu1,"No, the type is actually Option<T>, so it's a generic type, you can't pass a variable defined as Option<i32> to a function that takes an Option<bool> even if its value is None  Besides that, rust doesn't let you use the value inside the option without ensuring it's not None",0.0,rust
155cisi,jsuyxll,The mistake was to make nulls implicit like in C or Java.,0.0,c
155cisi,jsuyxll,The mistake was to make nulls implicit like in C or Java.,0.0,java
155cisi,jsuxxdd,"(The code also looked suspiciously like C++, unless C23 also has `auto`, and the name of the file it tries to compile is `main.cpp`.)",-0.1,c++
155cisi,jt1vyjx,Sounds like a rust trait almost,0.0,rust
155cisi,jsuv9df,Kotlin: https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiJmdW4gbGVuKHM6IFN0cmluZz8pOiBJbnQge1xuICAgIHJldHVybiBzLmxlbmd0aFxufSJ9  TypeScript: [https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA](https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA),-0.75,kotlin
155cisi,jsuv9df,Kotlin: https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS45LjAiLCJwbGF0Zm9ybSI6ImphdmEiLCJhcmdzIjoiIiwibm9uZU1hcmtlcnMiOnRydWUsInRoZW1lIjoiaWRlYSIsImNvZGUiOiJmdW4gbGVuKHM6IFN0cmluZz8pOiBJbnQge1xuICAgIHJldHVybiBzLmxlbmd0aFxufSJ9  TypeScript: [https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA](https://www.typescriptlang.org/play?#code/FAYw9gdgzgLgBAGwKYTgXjgCigLjgZRgCcBLCAcwB8IBXBBASj1oFsAjJI9APjigDpkFGAAsgA),-0.75,typescript
155cisi,jsvcb6k,> Kotlin uses nullable types which are more like union types than option types.,0.5,kotlin
155cisi,jsudtqj,syntax in Kotlin.,0.0,kotlin
155cisi,jsudtqj,Similar sugar exists in Rust and possibly other languages as well.,-0.0625,rust
155cisi,jsudtqj,In Kotlin you can define methods on null types.,0.0,kotlin
155cisi,jsu91sy,"Regarding your first point: I'm not sure how this is done in Rust but in other languages I know, None is a valid assignment for Option<T> for all T. In Kotlin, an optional type would be T?",-0.041666666666666664,rust
155cisi,jsu91sy,"Regarding your first point: I'm not sure how this is done in Rust but in other languages I know, None is a valid assignment for Option<T> for all T. In Kotlin, an optional type would be T?",-0.041666666666666664,kotlin
155cisi,jsu91sy,and similarly null is valid for any T. In Scala None is Option[Nothing] with Nothing being the subtype of every type.,0.0,scala
155cisi,jsu91sy,"Regarding the second point, the same can also be done with null, again, like in Kotlin.",0.0,kotlin
155cisi,jsuwgps,"At least in the context of Kotlin (believe me, I have no particular feelings for the language other than that I find it interesting) this is not correct.",-0.002083333333333326,kotlin
155cisi,jsuwgps,In Kotlin you cannot use a value of type T?,0.0,kotlin
155cisi,jsuwgps,You can (again Kotlin) assign null to a variable of an optional type the same as you can assign None to any variable of type Option<T>.,0.0,kotlin
155cisi,jsuwgps,"And well in, say Java, you would have to consider every non-primitive type optional.",0.0,java
155cisi,jsuwgps,But Java just does not have any advanced features when it comes to null.,0.4,java
155cisi,jsuwgps,Basically      // Kotlin     let a: A?,0.0,kotlin
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,rust
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,java
155cisi,jsuwgps,= null     // Rust     let a: Option<A> = None;     // Java     A a = null;  Regardless of the value of B you generally can't do      // Kotlin     let a: A?,0.05000000000000002,kotlin
155cisi,jsuwgps,= ...     a = b     // Rust     let a: Option<A> = ...     let b: Option<B> = ...     a = b     // Java     A a = ...     B b = ...     a = b  But this is hardly interesting.,0.5,rust
155cisi,jsuwgps,= ...     a = b     // Rust     let a: Option<A> = ...     let b: Option<B> = ...     a = b     // Java     A a = ...     B b = ...     a = b  But this is hardly interesting.,0.5,java
155cisi,jsv6nzg,That's really cool!,0.4375,cool
155cisi,jsuskdq,I dislike Rust's use of 'try_thing' being the call that returns the Result.,0.0,rust
155cisi,jsycs7a,JavaScript has this and I gotta say my personal opinion is that having two different nulls is even worse than having null,-0.13333333333333333,javascript
155cisi,jsue3dl,How do you do this in Kotlin?,0.0,kotlin
155cisi,jsue3dl,Rust doesn't any additional syntax for Option.,0.0,rust
155cisi,jsue3dl,As seen in Kotlin's special syntax for nullable types.,0.35714285714285715,kotlin
155cisi,jsuvn1j,"Somewhat related, in Rust I've long wanted a crate-level attribute to disallow potential panics, i.e.",-0.016666666666666666,rust
155cisi,jsv0nxd,"The same programmers wouldve been getting nulls and other UB in C++ though, so in a way, things are a bit better.",0.125,c++
155cisi,jt8agon,"In an interpreted language in which every value is tagged, a union type could have the same semantics as rust enums.",0.0,rust
155cisi,jt8agon,"But in a compiled language or in structural type systems we need special constructs like in rust, or explicit tagging like in typescript.",0.35714285714285715,rust
155cisi,jt8agon,"But in a compiled language or in structural type systems we need special constructs like in rust, or explicit tagging like in typescript.",0.35714285714285715,typescript
154w4v5,jswjazj,I found this takeaway interesting from the practical standpoint (as it implies testing your compiler with multiple fuzzers is the way to go--whereas staying with one fuzzer may not get us very far as it's just going to saturate at some point in one cluster of possible bugs):  > fuzzers find mostly totally different bugs when used to test a compiler  More discussion in this thread: https://mastodon.social/@regehr/110747217322334287,0.23285714285714285,go
154sacf,jsqofsf,The C++ generic algorithms library has both std::for_each (which just visits each element) and std::accumulate (which acts similarly to a fold).,0.0,c++
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,javascript
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,c++
154sacf,jsrshrg,"JavaScript, C++, Rust) use it for a completely different operation on sequences.",0.0,rust
154sacf,jsrshrg,"Also if you're looking for a very general functional looping construct, you may want to implement something like Scheme's [named let](https://weinman.cs.grinnell.edu/courses/CSC151/2014F/readings/named-let-reading.html).",0.06500000000000003,scheme
154sacf,jss14mo,"This is typically called `map` (in Haskell, this is specifically called `fmap`).",-0.16666666666666666,haskell
154sacf,jss14mo,"This is typically called `reduce`, `fold` (in Haskell, this is specifically called `foldl` which has a closely related sister function called `foldr`), `accumulate`, etc.",-0.08333333333333333,haskell
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,javascript
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,rust
154sacf,jss14mo,"This one sometimes shows up as a language construct rather than a function, like JavaScript's `for...of` or Rust and Python's `for` loops, but may also be implemented as a function.",0.0,python
154sacf,jstrbxr,`reduce` comes from APL and it is so named because it uses a function to *reduce* the dimension of the data being processed.,0.0,apl
154sacf,jstrbxr,"That is, say you have a piece of 1 dimensional (an array / list); then this is just the `fold` that we are accustomed to: you get one value out of everything in the list, so you go from 1 dimensional to 0 dimensional.",0.0,go
154sacf,jsqogw9,I'll go against the grain and say I like `ForEach`.,0.0,go
154sacf,jssghrg,This is why I’m in favor of how Ruby supports multiple names for the same method.,0.0,ruby
154sacf,jsriub0,"IMHO, JM2C, YMMV, &c.",0.0,c
154sacf,jsql3dp,To me it sounds like a `mapM_` (in Haskell terminology).,0.0,haskell
154sacf,jsv6eo2,Don't forget `inject` (smalltalk ; ruby),0.0,ruby
154qygu,jsqtuup,"Many prebuilt types like ""i32"" or prebuilt functions like the ""main"" function in C, or the ""and"", ""or"" operators in SQL are examples of ""predefined idents"".",0.3333333333333333,c
154qygu,jsuscbk,"Is the problem is that, for example, `(a: b, c: d) = (e, f)` could mean two things?",-0.10416666666666667,c
154qygu,jsuscbk,"Is the problem is that, for example, `(a: b, c: d) = (e, f)` could mean two things?",-0.10416666666666667,d
154qygu,jsuscbk,"If `b` and `d` are types, it is a declaration of `a: b = e` and `c: d = f`.",0.75,d
154qygu,jsuscbk,"If `b` and `d` are types, it is a declaration of `a: b = e` and `c: d = f`.",0.75,c
154qygu,jsuscbk,"If `b` and `d` are values, it is a pattern match with a record on the left and a tuple on the right.",0.14285714285714285,d
154qygu,jsuk53m,`a : int` as in rust) and hashmap(e.g.,0.0,rust
154qygu,jsuk53m,"`{a: 1, b: 2}` as in elixir).",0.0,elixir
154qygu,jsuy7cy,additionally I want to allow types to be used as value in my language so dispatching on `b` and `d` are not possible.,0.0,d
154qygu,jsuyg3p,"In my imagined language, equal sign is used for pattern matching and they're nesttable so this is also a no go for me",0.0,go
154qygu,jsvq99q,"I probably have no way to tell, because (a: b, c: d) = (e, f) can have 2 meaning as lhs can either be: a record with two field, field a is of value b and field c is of value d; or a tuple with 2 positional field of type b, d, bound to a and b separately.",0.0,c
154qygu,jsvq99q,"I probably have no way to tell, because (a: b, c: d) = (e, f) can have 2 meaning as lhs can either be: a record with two field, field a is of value b and field c is of value d; or a tuple with 2 positional field of type b, d, bound to a and b separately.",0.0,d
154qygu,jswtis5,"Add a keyword (s) :      record (a: b, c:d )  It's not very clear what is the difference between a ""tuple"" and a ""record"", in your P.L., could you be more specific?",0.3028846153846154,c
154qygu,jswtis5,"Add a keyword (s) :      record (a: b, c:d )  It's not very clear what is the difference between a ""tuple"" and a ""record"", in your P.L., could you be more specific?",0.3028846153846154,d
154qqn3,,It's very cool to know that this is possible.,0.22749999999999998,cool
154apa1,jsp4r7q,"However while the two following sentences are true, they do not give a clear view of the domain:   - Go is meant to write servers (any program can be transformed in a server)  - C is meant to write programs (literally what a _programming_ language is meant to do)",0.15,go
154apa1,jsp4r7q,"However while the two following sentences are true, they do not give a clear view of the domain:   - Go is meant to write servers (any program can be transformed in a server)  - C is meant to write programs (literally what a _programming_ language is meant to do)",0.15,c
154apa1,jspsm0i,"There are some basic things you can litmus test like ""can I write a fibonacci"" but as you go along it can be better to think in terms of features instead.",0.25,go
154apa1,jsnyz2b,"Sometimes they are created using intricate Assembly libraries, as some pthreads implementations which have no access to clone\* system calls do.",0.0,assembly
154apa1,jsnyz2b,"Even if that host is the microprogram of the CPU, for example, when you compile C code with -ffreestanding, the host still exists, it's the microprogram.",0.0,c
154apa1,jsntsyp,"Bash can't generate random numbers natively, but some program with that ability is expected.",-0.3,bash
154apa1,jsntixq,Sy many languages have semantic constraints on what structures you can create (see doubly linked lists in safe Rust).,0.3333333333333333,rust
154apa1,jsod3tm,"(a, b)(b,c)(c,a).",0.0,c
1548d01,jspltil,"This is super cool, great job!",0.5611111111111111,cool
1548d01,jspltil,"It would take me a bit of time to dust off my C skills and take a closer look at your code, but I might get to it at some point.",0.0,c
1548d01,jspy5vl,Always glad to see something written in C in these days.,0.5,c
1548d01,jss6c6k,Support for hex and binary literals would be cool aswell,0.35,cool
153zpve,,Is it just a functional programming problem or does something like that happen in java or kotlin too?,0.0,java
153zpve,,Is it just a functional programming problem or does something like that happen in java or kotlin too?,0.0,kotlin
153zpve,jsmwhs1,> Is it just a functional programming problem or does something like that happen in java or kotlin too?,0.0,java
153zpve,jsmwhs1,> Is it just a functional programming problem or does something like that happen in java or kotlin too?,0.0,kotlin
153zpve,jsmwhs1,Maybe you also show the generated assembly code (or whatever the target language of your compiler is).,0.0,assembly
153zpve,jspkhkp,Just look at lambdas in C++: they compile to an instance of an anonymous struct with fields for all captured values and an overloaded call operator.,0.0,c++
153zpve,jsn09wb,"I think the main problem with my understanding was/is that when we learned how to write a compiler (in kotlin) in that course, we used a hashmap and closures instead of substitution.",0.16666666666666666,kotlin
153h7x0,jsjg0u9,"Python PL makes it sweet to write in, but hellish to even write a generator for.",0.35,python
153h7x0,jsodlh5,I'm using Python for my host and some day I would like to generate native code after I get all the semantic kinks ironed out.,0.0,python
153h7x0,jslmlys,"Ah, the reason I chose to implement this in Python was because the Chocopy is a subset of Python.",0.0,python
153h7x0,jslmlys,"Therefore I didn't need to write a parser at all, I just parsed it into the Python AST using the built-in `ast` module and converted that into my own AST.",0.6,python
153h7x0,jslmlys,When people take the class at Berkeley they use Jflex for the parser since the skeleton code for their assignments is in Java.,0.0,java
153h7x0,jskozjj,Do you mean you think Python is a bad language to use for implementing another language?,-0.5062499999999999,python
153h7x0,jskufyt,"I'm not sure how much of a CFG Python grammar is, but it seems very hard to parse by hand at least.",-0.18229166666666669,python
153h7x0,jskufyt,It was in Go but I implemented it in C and it worked just fine.,0.4166666666666667,go
153h7x0,jskufyt,It was in Go but I implemented it in C and it worked just fine.,0.4166666666666667,c
153h7x0,jsl4wko,python is easy to parse with an hand-written parser.,0.43333333333333335,python
153h7x0,jsl4wko,"Nim has a syntax way advanced compared to python, and it's still easy.",0.4166666666666667,python
153h7x0,jsm1xca,I think writing a subset of Python is not going to be that hard.,-0.2916666666666667,python
153bfuu,jsj33j7,Similar to Eiffel?,0.0,eiffel
153bfuu,jsj5266,"However, Eiffel checks preconditions/postconditions at runtime, raising an exception if they’re not met.",0.0,eiffel
153bfuu,jsky0fk,"(As an outsider my impression is that this happens in all these systems, for example Dafny, Why3 and Liquid Haskell, because automated solvers do not scale in many cases, and they become increasingly slow and brittle before they stop working completely.",0.09999999999999998,haskell
153bfuu,jsl7k98,"Oh, cool.",0.35,cool
15369z8,jsjdnt9,"I would look into [SPARK](https://docs.adacore.com/spark2014-docs/html/lrm/), which is a subset of the Ada language that supports formal verification of programs using an automated theorem prover.",0.0,ada
15369z8,jsjdnt9,"Both Ada and SPARK have facilities for safety critical programs, especially real-time embedded systems.",0.0,ada
15369z8,jsia2v4,"Check out Dafny, F*, TLA+, and check out how the seL4 OS was verified, even though it’s written in C: https://www.cs.columbia.edu/~junfeng/09fa-e6998/papers/sel4.pdf.",0.0,c
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,c
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,go
15369z8,jsmbgxs,"Some of the guidelines are specific to C, and in other languages, the compiler will not allow you to ignore return values (Go, Rust, etc.)",-0.0625,rust
15369z8,jsmbgxs,[The Ariane 5 crash](https://en.wikipedia.org/wiki/Ariane_flight_V88) is an example of what can go wrong when you have floating point and integer overflow issues.,-0.5,go
15369z8,jsj0bou,"UserRadioInput = ""North"" | ""West"" | ""South"" | ""East""     static assert (UserRadioInput <: String)          Node1 = { tag: ""Node1"", payload: Int }     Node2 = { tag: ""Node2"", payload: String }     Node = Node1 | Node2     static assert (typeof (Node.tag) = ""Node1"" | ""Node2"")  To go further than Singleton Types are also useful [Refinement Types](https://en.wikipedia.org/wiki/Refinement_type), of which one has its inhabitants described by a predicate.",0.325,go
15369z8,jsj0bou,"As a practical example, where most C code will accept an index in an array as `size_t` which may fail at runtime (or worse: trigger a buffer overrun), the most correct type, whose use can never fail, is `Index (xs: List a) = { i ∈ ℕ₀ | i < |xs| }` (where `ℕ₀` includes 0).",0.06999999999999999,c
15369z8,jsi1owa,"Have you checked ADA, Rust & Zig?",0.0,ada
15369z8,jsi1owa,"Have you checked ADA, Rust & Zig?",0.0,rust
15369z8,jslgj51,You'd probably want to allow programmers to manually assert the complexity of a function where the compiler is unable to deduce it (similar to Rust's `unsafe`).,-0.25,rust
15369z8,jsjn2k9,I second ada and spark.,0.0,ada
15369z8,jslzrgj,"The problem is that for any language compiled to assembly, stack size tends to depend on a _lot_ of variable.",0.0,assembly
15369z8,jsils9p,"You can check for example:  https://www.scattered-thoughts.net/writing/how-safe-is-zig/ https://andrewkelley.me/post/unsafe-zig-safer-than-unsafe-rust.html  I think Rust is the best of the 3, but each one teaches good lessons.",0.85,rust
15369z8,jsils9p,"I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  ```pascal var    Day : Set of 1..31;    Month : Set of 1..12;  ```  and that certainly is very useful to make safe APIs!",0.3608928571428571,delphi
15369z8,jsils9p,"I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  ```pascal var    Day : Set of 1..31;    Month : Set of 1..12;  ```  and that certainly is very useful to make safe APIs!",0.3608928571428571,ada
15369z8,jsils9p,"I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  ```pascal var    Day : Set of 1..31;    Month : Set of 1..12;  ```  and that certainly is very useful to make safe APIs!",0.3608928571428571,pascal
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,c
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,ada
15369z8,jsimijm,I was perplexed because zig was just  a better c in my mind and Ada (being garbage collected if I'm not mistaken) and Rust (dur to borrow checker) eliminated whole lot of bugs where zig was more permissive a la c. I have to give zig another fair trial I guess,0.45999999999999996,rust
15369z8,jslyqx8,"> I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  It's fairly incomplete, unfortunately:   1.",0.15714285714285714,delphi
15369z8,jslyqx8,"> I know more Delphi than ADA, but one single thing that I wonder why nobody else copies is the ability to create a range as a type  It's fairly incomplete, unfortunately:   1.",0.15714285714285714,ada
15369z8,jslyqx8,"In my Rust code, instead, I have library code to create a generic strong type facility with arbitrary invariant validation:      struct Tagged<T, D>(T, PhantomData<fn(D)->D>);      impl<T, D> Tagged<T, D> {         pub fn new(value: T) -> Result<T, D::Error>         where             D: ValidateInvariant<T>,         {             D::validate(&value)?",0.11111111111111109,rust
15369z8,jslyqx8,"In my Rust code, instead, I have library code to create a generic strong type facility with arbitrary invariant validation:      struct Tagged<T, D>(T, PhantomData<fn(D)->D>);      impl<T, D> Tagged<T, D> {         pub fn new(value: T) -> Result<T, D::Error>         where             D: ValidateInvariant<T>,         {             D::validate(&value)?",0.11111111111111109,d
15369z8,jsirk34,I believe this is already present in Rust with `Range` and `RangeInclusive`.,0.0,rust
15369z8,jsirk34,You can write something like: ```rust let range = 1..31; // range.start() = 1 // range.end() = 31 ``` I'm not sure how different are the ranges you mentioned from Rust's.,-0.125,rust
152hv8q,jsg4mxc,"Well, there are dynamically typed functional languages, like Lisp.",0.0,lisp
152hv8q,jsgciv9,Like APL.,0.0,apl
152hv8q,jsgk55e,"Wow, APL is a great beast, I tried few times to learn it.",0.2333333333333333,apl
152hv8q,jsgpg2o,"APL programmers used to send each other one-liners and ask, ""OK, what does this do?""",0.1875,apl
152hv8q,jsgpg2o,APL is probably one of the most difficult languages to learn.,0.0,apl
152hv8q,jstxycf,"But I had an inherent interest in APL's design, so...",0.0,apl
1529hgn,jscsecw,"> if a developer has any idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects  Java’s `URL.equals()` would like a word.",0.16,java
1529hgn,jsczxqu,"It would be so nice to enforce that some C++ callback can’t allocate memory on the heap, take a lock, yield, etc.",0.6,c++
1529hgn,jsczxqu,"I’m not sure if it’s enough to persuade people to use some language over C++, but that doesn’t mean the feature lacks value.",-0.1875,c++
1529hgn,jsd204y,Maybe it's also similar to type checking in the sense that people didn't like static types because most people were familiar with Java or C++ style types which were really limited back then.,0.21726190476190477,java
1529hgn,jsd204y,Maybe it's also similar to type checking in the sense that people didn't like static types because most people were familiar with Java or C++ style types which were really limited back then.,0.21726190476190477,c++
1529hgn,jsd0kx7,"But it's ok, security vulnerabilities are not on every programmers' minds (let's ignore those flashbacks featuring my PHP teacher), so surely there are no other cases of such hippy concepts getting in the way of profit, such as _security_, _correctness_, _data races_, _the VM crashing at runtime because user code tried to log by writing onto nothing_, or the entire idea of ""accessing an object"" through a reference which may be NULL - which Hoare himself calls his Billion Dollar Mistake - which can neither be modelled as an effect nor have any economical cost.",0.19464285714285715,php
1529hgn,jsd0kx7,"In fact, let's go further: a routine, or function, is merely an abstraction over control flow, so let's all just use `goto` and have the IDE figure out what the code actually does.",-0.16666666666666666,go
1529hgn,jsd4d0y,"Think Scala, think Common Lisp quotes.",-0.3,scala
1529hgn,jsd4d0y,"Think Scala, think Common Lisp quotes.",-0.3,lisp
1529hgn,jsd015f,"Moreover, the value that it returns is totally immutable, like all values in Haskell.",0.0,haskell
1529hgn,jsd98n6,"OO languages already have something for this: It's called dependency injection, and the truck-sized hole in DI for Java is the global package scope.",0.0,java
1529hgn,jsdmf1a,I'm kinda persuaded by the bold argument that if a language feature has any merit at all Java would have stolen it by now.,0.3333333333333333,java
1529hgn,jsdfdz1,"I notice that Java in characteristic fashion solved the problem by adding a second sort of `switch` statement which also isn't very good, but at least it doesn't have fallthrough.",0.1358333333333333,java
1529hgn,jscmhh2,"I would argue that async-await has close to zero value, it seems mostly like a magic incantation everywhere in the Typescript code I currently work with.",0.3333333333333333,typescript
1529hgn,jsd443x,"In Haskell, the IO monad isn't actually an 'effect' it is just a description of an effectful computation in a state-monadic/continuation-passing form.",0.0,haskell
1529hgn,jsd443x,"In a hypothetical syntax:  ```haskell main :: IO () main = putStrLn ""Hello, World!""",0.1875,haskell
1529hgn,jsd3b5b,Optimizing C compilers have been moving code around for years which can make code harder to debug.,-0.1,c
1529hgn,jsgznmn,"I think the JavaScript implementation of async/await is a bit confusing for asynchronous error handling, like how `.catch` is used on Promise directly but `try/catch` otherwise.",-0.09999999999999999,javascript
1529hgn,jsgznmn,I think it has value in JavaScript.,0.0,javascript
1529hgn,jsf6vh9,"Among other things, correctness: - if the effect is fallibility through exceptions, you'll want to catch the exception at the call site - if the effect is printing to stdout, you'll simply want to know that it only happens when you want it (think php sites where DB errors just resulted in warnings being scattered between markup.",-0.041666666666666664,php
1529hgn,jsf6vh9,Python's @contextmanager decorator needs a generator function that suspends once,0.0,python
1529hgn,jsg7tx1,"How an Effect System would have helped against such a vulnerability is simple:   - depending on language semantics (type inference), either the compiler or the programmer's IDE (if any) would tell the programmer that `Log.INFO` suddenly had its return type go from `Log` to `Log & Jndi & JvmEval`, at which point they may reevaluate their API design,   - a unit test somewhere, far away, woule fail because the README says the effect is only `Log`, so tests is manually typed with _no_ effects, and now the compiler complains that there is a typed mismatch between those two functions,   - in the failure of all the above, a CVS auditor/reviewer/Torvalds would see a commit with `JvmEval` in it and go scream at the author - because who the hell writes a code evaluator in a logging function?",-0.08958333333333335,go
1529hgn,jsg7tx1,"The language I'm slowly working on in my free time is porting an Effect System to Assembly and binary code, where `mov [rax], rdi` has type `{ in rdi: a, rax: mem a; writes rax }`.",0.04999999999999999,assembly
1529hgn,jsg7tx1,"When using inline assembly, the registers are translated to variables:      f (p: Mem Int) (x: Int): () => MemWrite p =         asm {in rax = p, rdi = x}             mov [rax], rdi             end  Trying to write to memory when the only allowed effect is reading it, is an effect type error.",-0.375,assembly
1529hgn,jsdes2m,I mainly want to forbid cases like this (using Rust in this example):      println!,0.20833333333333331,rust
1529hgn,jsdes2m,"For panics, I meant something like panics in Rust that are basically implemented as a `throw` with `catch_unwind` being a `try/catch`.",0.0,rust
1529hgn,jsktpww,I think that's how C# does it but not completely sure.,-0.25,c
1529hgn,jswrpx1,"Checked exceptions (as implemented in Java) can't be used alongside polymorphism; either a polymorphic function throws no exceptions, rendering it incorrect, or it throws any exception, despite the fact that when used it will only throw a subset.",0.0,java
1529hgn,jswrpx1,"This can be solved via effect polymorphism, but Java lacks that feature.",0.0,java
1529hgn,jsl45n8,"- Not all systems have a single disk (why would you even assume that, and why would you assume the user wouldn't care where your disk writes go?)",-0.07142857142857142,go
1524b7f,jscffe1,Some of the recent work I'm aware of (but this is outside my core area) is Max Bolingbroke's [Cambridge Haskell Supercompiler](https://github.com/batterseapower/chsc).,0.08333333333333333,haskell
1524b7f,jsdkrh1,"Now I claim that you'd never want to write it the second way in source code and furthermore there's no *general* transformation from the one into the other *at the level of the AST,* but once you go to something like three-address code, the transformation is a straightforward application of invariant code motion and/or strength reduction.",0.056249999999999994,go
1520pt9,jsem8fm,I think that was clearest when they presented this Python program:      def g(x):         return         x - 10  And then cited students struggling to predict the exact error as an example of their evidence that they struggled with a transition from functional to imperative programming.,0.25,python
1520pt9,jsem8fm,"Or even more surprisingly, a lot of concern with whether students understand that a function that doesn't explicitly return a value in Python will actually return a `None` that can be assigned to a variable.",0.39999999999999997,python
1520pt9,jsnhneb,The style of Lisp is much better at teaching imo.,0.5,lisp
151nyde,,I call it 'Creole C'.,0.0,c
151nyde,,Or maybe 'Pidgin C'.,0.0,c
151nyde,jscwwpj,"Well with this in mind, I assumed creole C to be just some sort of C with fancy extentions.",0.0,c
151j3gf,jsa7gy9,"The Future of C ...""  C != C++",0.0,c
151j3gf,jsa7gy9,"The Future of C ...""  C != C++",0.0,c++
151j3gf,jsakjul,After c++ committee botched stackful coroutines it is hard to take their opinions seriously,-0.3125,c++
151di9r,js8298v,Since effectively the no-go theorem for type systems is that we cannot have all of the three:  * Well-typed terms don't go wrong (i.e.,0.04999999999999999,go
151di9r,js8298v,terminate) * Ill-typed terms do go wrong (i.e.,-0.5,go
151di9r,jt8tmpz,"The usual guarantee provided by a type system is that ""well-typed programs (terms) don't go wrong"" which means that, if you can prove that a term has a type, then the term is guaranteed to be free from some particular class of bugs.",-0.04583333333333333,go
151di9r,jt8tmpz,"Typically, there are no guarantees for terms that are untypable, they may go wrong or they may be perfectly ok.  For example, if true then 1 else ""foo"" is untypable in most mainstream type systems, although it doesn't suffer from any runtime type error.",0.13666666666666666,go
1516vdp,,Feels really meta and cool.,0.275,cool
1516vdp,js8zzmh,"Once I get this working with structs, function overloads, compile time function arguments I want to make a cool video detailing it.",0.35,cool
1516vdp,js8h8rc,This is sort of what C does.,0.0,c
1516vdp,js8h8rc,"What's cool about this actually is that if I use the CTFE directive in my language on an if condition, I've essentially created a compile time `if` with almost 0 work.",0.11666666666666665,cool
1514w59,js6vhrt,"- context free grammars: good - compiler switches: bad - compiler warnings: bad - follow C ABI: good - built-in doc generator: good - built-in test framework: good - manual memory management: will require more programmer time - multiple pointer types: bad - portability should be easy - builtin UTF-8: good - too many choices: bad - special debug and assert functionality: good - pointless flexibility like both `l` and `L` for large integer literals: bad - user extensibility (operator overloading, custom literals, implicit conversions) relieves pressure on the language - greppable syntax (e. g. for finding casts) - redundancy in syntax: semicolons good - underscores in number literals: good - composability: good - macros: bad, don't work",0.18498964803312637,c
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,c
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,c++
1514w59,js6kk7y,">  > I've designed two programming languages, ABEL and D. I've implemented compilers for them, along with C, C++, Javascript, and D. I've done the tech support for them.",0.0,javascript
1514w59,js7qgo0,Or maybe there are three distinct areas for functionality to go: be built-in to the core language; implemented in user-code via language-building features and added to the standard library; or pure user-code.,0.1714285714285714,go
1514w59,js7qgo0,"So it's OK for `complex` to go in that middle area, but not the last.",0.05,go
1514w59,jsahs8w,"Well, I ended up going back to C, because of several otherwise reasonable limitations of Zig.",0.06666666666666667,c
1514w59,js7ho5j,"C macros, certainly horrible (if you don't use them correctly + easy make parenthesis mistakes especially when you are starting out (nowadays I only do that when I am running on caffeine at 3AM) or redefine syntax).",-0.11333333333333333,c
1514w59,js7ho5j,"But lisp macros, hate being without them.",-0.8,lisp
1514w59,js7353s,">macros: bad, don't work  No macros and you end up with things like babel in javascript and a million other competing build tools.",-0.4124999999999999,javascript
1514w59,js710du,abused  Example of a good macro in C:      #define CAST     CAST(float)(a)/b;  `CAST` is defined an empty string.,0.3,c
1514w59,js7s7yl,"I often use C macros for stuff like `#define FOO(str) assert(foo_api(context, state, str, strlen(str)) != -1)` (passing lots of common arguments, doing validation of the return, etc.",-0.3,c
1514w59,js7s7yl,"), but if I was working in python instead, I would define a local helper function like `def foo(s): assert foo_api(context, state, s, len(s))`.",0.0,python
1514w59,js7s7yl,"Sadly, most languages that go this route add function call overhead that macros don't have.",0.5,go
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,java
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,python
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,ruby
1514w59,js7tdex,"Yep 😄 I tried so many programming languages (Java, C/++, Python, JS, Ruby, C#) but the only language that really sticks with me is Racket.",0.2333333333333333,c
1514w59,js7tdex,"Macros are fun, the syntax is cool and it's functional design makes me less worried that some other variable will be easily modified.",0.15833333333333333,cool
1514w59,js9051y,">  lisp macros, hate being without them  in the video, the speaker said ""I have a sneaky suspicion that the reason lisp has never has become a mainstream language is, because, in order to use it, you have to use the macro system in it.",-0.8,lisp
1514w59,js9051y,"And so everyone creates their own version of lisp, which is incompatible with anyone else's.""",0.6,lisp
1514w59,js7cx9o,"I think Javascript having so many build tools has to do with many things, but a lack of macros isn't one of them.",0.5,javascript
1514w59,jsc9a36,"On the other hand, Rust's doc generator is great.",0.3375,rust
1514w59,jsa7yqs,I did watch it and I think he straw-manned Lisp a little bit.,-0.1875,lisp
1514w59,jsa7yqs,"I'm a hobbyist Common Lisper and, in my experience, macros are not a barrier to any major CL project or the reason Lisp hasn't become ""popular"".",0.12083333333333333,lisp
1514w59,jsa7yqs,"Certainly, if the industry finds things like Java's Lombok acceptable (which is horrifying under the hood), most uses of macros in Common Lisp shouldn't offend anyone.",-0.12142857142857143,java
1514w59,jsa7yqs,"Certainly, if the industry finds things like Java's Lombok acceptable (which is horrifying under the hood), most uses of macros in Common Lisp shouldn't offend anyone.",-0.12142857142857143,lisp
1514w59,jsk1xgv,"If I mouseover a C++ macro in VS Code, it will at least show me what it expands to and ctrl+click mostly works.",0.1,c++
1514w59,jscjhkn,"But taking something that seems like it shouldn’t work, and figuring out how to make it work, is quite simply a good way to build a cool new kind of thing.",0.44659090909090904,cool
1514w59,js7jbvd,Depending on the tools you use javascript can have 5 different compilation steps to support things like jsx or custom rendering frameworks.,0.0,javascript
1514w59,jskvb7o,"while that's true, I don't think anyone would describe mouseover for a c++ macro easy to implement.",0.39166666666666666,c++
1514ibb,js6nmwb,"Not exactly what you asked for, but maybe take a look at  [Uniform Function Call Syntax](https://en.m.wikipedia.org/wiki/Uniform_Function_Call_Syntax)    Taking an example program from the above link:  ```d import std.stdio;  int first(int[] arr) {     return arr[0]; }  int[] addone(int[] arr) {     int[] result;     foreach (value; arr) {         result ~= value + 1;     }     return result; }  void main() {     auto a = [0, 1, 2, 3];      // all the following are correct and equivalent     int b = first(a);     int c = a.first();     int d = a.first;      // chaining     int[] e = a.addone().addone(); } ```",0.010416666666666664,d
1514ibb,js6nmwb,"Not exactly what you asked for, but maybe take a look at  [Uniform Function Call Syntax](https://en.m.wikipedia.org/wiki/Uniform_Function_Call_Syntax)    Taking an example program from the above link:  ```d import std.stdio;  int first(int[] arr) {     return arr[0]; }  int[] addone(int[] arr) {     int[] result;     foreach (value; arr) {         result ~= value + 1;     }     return result; }  void main() {     auto a = [0, 1, 2, 3];      // all the following are correct and equivalent     int b = first(a);     int c = a.first();     int d = a.first;      // chaining     int[] e = a.addone().addone(); } ```",0.010416666666666664,c
1514ibb,js75h2w,"Some time ago I wrote a *generalized uncurry* in Haskell which could eliminate the need for multiple distinct operators like above, at the expense of having to define instances for each product type (though I'm sure this could be automated with TH).",0.2,haskell
1514ibb,js75h2w,"infixl 1 >$      infixr 1 $<     class Uncurry f prod result | f prod -> result where         uncurry :: f -> prod -> result         (>$) = uncurry         ($<) = flip uncurry      instance Uncurry (a -> result) a result where         uncurry f a = f a     instance Uncurry (a -> b -> result) ((a, b)) result where         uncurry f (a, b) = f a b     instance Uncurry (a -> b -> c -> result) ((a, b, c)) result where         uncurry f (a, b, c) = f a b c     instance Uncurry (a -> b -> c -> d -> result) ((a, b, c, d)) result where         uncurry f (a, b, c, d) = f a b c d     ...  One advantage of this uncurry solution is you can use it for any product types, and not only tuples.",0.0,c
1514ibb,js75h2w,"infixl 1 >$      infixr 1 $<     class Uncurry f prod result | f prod -> result where         uncurry :: f -> prod -> result         (>$) = uncurry         ($<) = flip uncurry      instance Uncurry (a -> result) a result where         uncurry f a = f a     instance Uncurry (a -> b -> result) ((a, b)) result where         uncurry f (a, b) = f a b     instance Uncurry (a -> b -> c -> result) ((a, b, c)) result where         uncurry f (a, b, c) = f a b c     instance Uncurry (a -> b -> c -> d -> result) ((a, b, c, d)) result where         uncurry f (a, b, c, d) = f a b c d     ...  One advantage of this uncurry solution is you can use it for any product types, and not only tuples.",0.0,d
1514ibb,js75h2w,"data Point = Point Double Double     instance Uncurry (Double -> Double -> r) Point r where       uncurry f (Point x y) = f x y      data Size = Size Double Double     instance Uncurry (Double -> Double -> r) Size r where       uncurry f (Size w h) = f w h  And its uses can be chained, as in:      drawRectangle >$ point >$ size  Where      drawRectangle :: Double -> Double -> Double -> Double -> Render ()  This is the how arguments are passed in Haskell's Cairo bindings.",0.0,r
1514ibb,js75h2w,"data Point = Point Double Double     instance Uncurry (Double -> Double -> r) Point r where       uncurry f (Point x y) = f x y      data Size = Size Double Double     instance Uncurry (Double -> Double -> r) Size r where       uncurry f (Size w h) = f w h  And its uses can be chained, as in:      drawRectangle >$ point >$ size  Where      drawRectangle :: Double -> Double -> Double -> Double -> Render ()  This is the how arguments are passed in Haskell's Cairo bindings.",0.0,haskell
1514ibb,js8iuou,"But despite what the Haskell hive-mind thinks, in my day job multi-argument functions are the norm, so that cutesy composition operators would not earn their keep.",0.0,haskell
1514ibb,js8iuou,"It's too easy to write f(g(h(x))) or even f(a, g(h(a,b), k(c,d))) and there's just no question.",0.43333333333333335,c
1514ibb,js8iuou,"It's too easy to write f(g(h(x))) or even f(a, g(h(a,b), k(c,d))) and there's just no question.",0.43333333333333335,d
1514ibb,js7gkkc,"There might be alternative ways to go about solving the problem you're having, such as changing the way you type it / what fingers you use, for example I might move my hand and press the keys with my ring finger and index finger.",0.0,go
1514ibb,js7gkkc,"If you really want to replace this operator, most random symbols are OK. For example `|` like in Unix or `&` like in Haskell.",0.175,haskell
1514ibb,js7ooh4,I've played with using `->` so that `a -> b -> c` means `c(b(a)`.,0.0,c
1514ibb,js7ooh4,"I can write `a -> b(c)`, but does that mean `b(a, c)` or `b(c, a)`?",-0.3125,c
1514ibb,jsukosn,"so what it does it bascially allowing this:  ``` f(a, b, c) ``` to be rewritten as:  ``` a.f(b, c) ```  So by choosing the ""primary"" argument with careful, we can have: ``` a.b(c, d).e(f, g) ``` which is effectively the same as piping.",0.225,c
1514ibb,jsukosn,"so what it does it bascially allowing this:  ``` f(a, b, c) ``` to be rewritten as:  ``` a.f(b, c) ```  So by choosing the ""primary"" argument with careful, we can have: ``` a.b(c, d).e(f, g) ``` which is effectively the same as piping.",0.225,d
1514ibb,js7glyj,I used: `value` ``` `` ``` `function1` ``` `` ``` `function2`  Because my PL grammar has infix function call notation like in Haskell: `1` ``` ` ``` plus ``` ` ``` `2`,0.0,haskell
1514ibb,js7joy7,"Haskell uses `.`, but for function composition from left to right.",0.14285714285714285,haskell
1514ibb,js7joy7,"Haskell also has `>>>`, which works like the pipe operator we know.",0.0,haskell
1514ibb,js7joy7,"Clojure has an interesting approach to this using a macro, where you only need to write the arrow once.",0.25,clojure
1514ibb,js7joy7,"Taken from the documentation:      (-> ""a b c d""        .toUpperCase        (.replace ""A"" ""X"")        (.split "" "")        first)  But in general, I'd say `|>` is good enough for most people.",0.125,c
1514ibb,js7joy7,"Taken from the documentation:      (-> ""a b c d""        .toUpperCase        (.replace ""A"" ""X"")        (.split "" "")        first)  But in general, I'd say `|>` is good enough for most people.",0.125,d
1514ibb,jsa7urp,"There are parallels to Unix pipes, and also to concatenative programming in general  I have a project called Z where I was trying to explore something like this space in Java",0.05000000000000002,java
1514ibb,js8ey5c,Then you can reverse (<- or <<) for binding assignment a la Haskell or [LiveScript](http://livescript.net/).,0.0,haskell
1514ibb,jsc97q9,"> But despite what the Haskell hive-mind thinks, in my day job multi-argument functions are the norm, so that cutesy composition operators would not earn their keep.",0.0,haskell
1514ibb,jsc97q9,"So, piped values would go into the first argument that isn't already specified with a keyword.",0.25,go
1514ibb,js8h0kk,"If you have a way to write partial application concisely then you can go with the meaning of `b(a, c)`.",0.0,go
1514ibb,js8h0kk,"If you have a way to write partial application concisely then you can go with the meaning of `b(a, c)`.",0.0,c
1514ibb,js8h0kk,`a -> b c d        ~ b a c d`  `a -> {b c} d.    ~ b c a d`,0.0,c
1514ibb,js8h0kk,`a -> b c d        ~ b a c d`  `a -> {b c} d.    ~ b c a d`,0.0,d
1514ibb,jsuve2z,That's a really cool alternative!,0.4375,cool
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,clojure
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,lisp
1514ibb,js8x161,"The Clojure style works really well for the Lisp family of languages (I (and many others) have ported it to scheme, since it's so nice).",0.4333333333333333,scheme
1514ibb,js8wqnu,It works fine in the shell.,0.4166666666666667,shell
1512nfo,,"Today I tried to search a little for other ""prior art"", and stumbled upon this [page](https://forums.swift.org/t/multiplication-by-juxtaposition/64128), about adding this to Swift.",-0.10416666666666667,swift
1512nfo,,The proposal includes the code needed to implement the feature in Swift.,0.0,swift
1512nfo,,"I don't know Swift, but it seem the author of the proposal saw in necessary to restrict implicit multiplication to having the right operand being parenthesised.",0.14285714285714285,swift
1512nfo,,"The implementation was rather surprising, but - given I don't know Swift - looks both elegant and efficient.",0.6,swift
1512nfo,,"There are languages (in particular functional programming languages, I think) that allow function calls without parenthesised arguments, and these typically use the first as a fixed syntax for function application (in combination with currying), and at least one (Perl) that uses a - shall we call it ""heuristic"" - mix: if the function name is followed by an opening parenthesis, only the parenthesised expression is taken to be its argument, otherwise as many arguments as needed are taken, possibly the rest of the expression.",0.06875,perl
1512nfo,,Or something like that - with Perl you can't always be sure.,0.5,perl
1512nfo,,"If A = B = C, for example ℝ, then it's just a ""plain old"" multiplication, but if A is ℝ and B and C are vector or matrix types, then it is scalar multiplication, and if A is a function type, then it is application of a function B→C, unless B is a function type also, in which case it is function composition.",-0.057142857142857134,c
1512nfo,js6n3dd,"You just take any function `foo: (A, B) -> C` and overload the function application operator for `A` with parameter type `B` as `foo(a, b)`.",-0.75,c
1512nfo,js6n3dd,"The above scheme should immediately satisfy your multiplication and basic function application criteria, though the order of operations will depend solely on the associativity of function application.",0.0,scheme
1512nfo,js6n3dd,"If you don't care about being too general, and just want to compose functions of type `A -> B` and `B -> C` for `A`, `B`, and `C` being fixed types, you can create dummy types for `A -> B` and `B -> C` and overload their function application operators as above.",0.05000000000000001,c
1512nfo,js6n3dd,"For the more general case of `A`, `B`, and `C` being arbitrary, I believe the language needs a higher level of polymorphism than the simple scheme above.",0.11666666666666668,c
1512nfo,js6n3dd,"For the more general case of `A`, `B`, and `C` being arbitrary, I believe the language needs a higher level of polymorphism than the simple scheme above.",0.11666666666666668,scheme
1512nfo,js6zwws,"And if you disambiguate with parenthesises (because TIL people write `sin` without parenthesises), you get `(sin a) (cos b) + (cos a) (sin b)` where all you need is to implement function semantics for those such that `((n : ℝ) : ℝ -> ℝ) = n × _` (there's some typeclass magic you can use to achieve that in Haskell).",0.25,haskell
1512nfo,js779up,"> and at least one (Perl) that uses a - shall we call it ""heuristic"" - mix: if the function name is followed by an opening parenthesis, only the parenthesised expression is taken to be its argument, otherwise as many arguments as needed are taken, possibly the rest of the expression.",0.05,perl
1512nfo,js779up,Or something like that - with Perl you can't always be sure.,0.5,perl
1512nfo,js779up,":-)  Raku, unsurprisingly, does a similar thing to perl.",0.25,perl
1512nfo,js701g6,"It's not as if there isn't a kind of precedent for this, in FORTRAN and maybe PL/1 - and I am at most half joking.",0.31111111111111117,fortran
1512nfo,jsb24d2,"Suppose k and c and reals, and M is a 3×3 matrix.",0.0,c
1512nfo,jsb24d2,A programmer writes k (c M).,0.0,c
1512nfo,jsb24d2,"Respecting the parentheses here would result in 18 multiplications; first the matrix is scaled by c, then by k. It would make sense to optimise this to (kc) M, resulting in just 10 multiplications, even if something else is written in the code.",0.25,c
1512nfo,js7btbm,"The CST will then contain ""juxt"" nodes like:      ""sin a cos b"" →     {kind: ""juxt"", children: [         { kind: ""name"", symbol: ""sin"", type: ""R→R"" },         { kind: ""name"", symbol: ""a"", type: ""R"" },         { kind: ""name"", symbol: ""cos"", type: ""R→R"" },         { kind: ""name"", symbol: ""b"", type: ""R"" } ] }          and ""sin k t"" →     { kind: ""juxt"", children: [         { kind: ""name"", symbol: ""sin"", type: ""R→R"" },         { kind: ""name"", symbol: ""k"", type: ""R"" },         { kind: ""name"", symbol: ""t"", type: ""R"" } ] }  Now suppose we want the rule that ""plain implicit multiplication"" of two values of the same type A, giving a value also of type A, must result in calling the function `mulAAA:A×A→A`.",0.2835164835164835,r
1512nfo,js7hpdi,The fact that juxtaposition was an operator suggested you code have Ruby like power to make DSL’s too.,0.0,ruby
1512nfo,js94eac,"From a first quick glance though, I would say that it looks as if the grammar (which isn't even a CFG, but a PEG grammar) is a bit more complicated than I think any language grammar should be (and I don't even consider the grammar for Algol 68 too complicated.)",0.016666666666666653,algol
1512nfo,js7r3sf,"Given your choice of syntax for your example, I guess you are a Haskell programmer.",0.0,haskell
1512nfo,js7r3sf,"I apologise for never having been able to figure out Haskell (and admittedly, I haven't tried *too* hard), but I am sure that Haskell programmers may have some interesting insights to share on this.",0.3020833333333333,haskell
1512nfo,js7tots,":-) I have used Perl5 quite a lot in the past (ca 1994-20-something - had it not been for Perl5 and MacPerl, I'd probably have chosen Python back then).",0.08333333333333333,python
1512nfo,jsbddc7,"In the scheme I described, `k t` would illegal to begin with; you'd have to write `kt` (and thus eventually `sin kt`) because of the no-space-between-juxtaposed-variables rule.",-0.5,scheme
1512nfo,js9rmlp,"C cheats by having its grammar depend on semantic analysis, because of the `(a)*b` ambiguity.",0.0,c
1512nfo,js9rmlp,"'""'{n} codepoint* '""'{n}` (C#'s and friends shouldn't be too dissimilar I would think, unless they define this rule in plain English), which I guess you can (ab)use to introduce complex states in a parser rule.",-0.1714285714285714,c
1512nfo,js8maxz,`f :: a -> b -> c` is really `f :: a -> (b -> c)` because functions associate to the right.,0.24285714285714285,c
1512nfo,js8maxz,`f :: (a -> b) -> c` is a unary function taking a unary function as its argument.,-0.75,c
1512nfo,jsbxdxu,"Only allowing unspaced juxtaposition of single-letter variables is an interesting idea, and I hope you didn't interpret my comment as a rejection of your scheme in any way, on the contrary, I plan to construct a parser that will allow me to experiment with various schemes, and yours (maybe slightly adapted, like allowing single or even multiple digit superscripts as exponents for example) will be one I'd like to try out.",0.04365079365079366,scheme
1512nfo,jsawn5d,"Absolutely, even a ""puritan"" language like Pascal has to ""cheat"" to distinguish between assignment and procedure call, IIRC.",0.2,pascal
1512nfo,js9ey1u,"Let D = A×B, then its f:D→C.",0.0,d
1512nfo,js9ey1u,":-)  Forgive me for saying this, and it is not personal, but I think that if there is one thing I find annoying with Haskell, it is the way some Haskell users casually present concepts from Haskell as if they are the only ""true"" way to view things, which to me is jarring and reductionistic.",0.008333333333333323,haskell
1512nfo,jsjweab,"I mean I can see at least three different meanings to `x + y / z * w` (PEMDAS with multiplication first, C with division first, and what my mate Benji would expect me to understand and vice-versa with _fraction last_).",-0.018750000000000006,c
1512nfo,js9givt,"Fair point, but Haskell can express both.",0.7,haskell
1512nfo,jsb04qa,"There is a fun thing about partial evaluation, that I discovered when experimenting with Charles Lindsey's proposed (Algol Bulletin AB37.p24, 1974) partial evaluation extension of Algol68 for a RosettaCode example.",0.033333333333333326,algol
1512nfo,jsb04qa,"I suppose this is also a ""problem"" for Haskell, although being side-effect free, maybe not.",0.4,haskell
15128pq,,This syntax is inspired by and similar to that in Haskell.,0.0,haskell
15128pq,,So Haskell function call as such becomes a sequence in my language.,0.0,haskell
15128pq,,Hence ```foo x y``` in Haskell is written as ```foo@ x y``` in my lang.,0.0,haskell
15128pq,,Hence ```foo x (bar y) (baz z)``` in Haskell is written as ```foo@ x bar@ y; bas@ z``` in my lang.,0.0,haskell
15128pq,js6jsav,>Hence foo x (bar y) (baz z) in Haskell is written as foo@ x bar@ y; bas@ z in my lang.,0.0,haskell
15128pq,js7o7da,I was just following Haskell style.,0.0,haskell
15128pq,jsavm2j,"You can choose to use white space for that of course, but then an `if` statement might look like this (note that a typical `if` is `if: c x y`):      if: c         x         y  Assume that `c` is a single expression of arbitrary complexity, and each of `x` and `y` could be a sequence of expressions or statements.",-0.3063492063492063,c
15128pq,jsavm2j,There isn't in a syntax like this either:      (if c x y)  Here parentheses would be used to group complex terms.,-0.525,c
15128pq,jsavm2j,"There is another difference:      if c then x else y     f(c, x, y)  `c` is evaluated in both cases, but in the first, only one of `x` or `y` is evaluated.",0.125,c
15128pq,jsaz762,"In fact languages like C++, which provide short-circuiting for default logical operators, when they are overloaded, there is no short-circuiting because they lack lazy evaluation.",0.0,c++
150yzsb,,"Still, I wanted to share it here with you guys so no one else has to go the same way twice (or at least to already have a place to start with).",-0.15,go
150xbp3,js8qmw7,I would argue that the main reason python won the scripting language  domain was because of it's syntax and significant whitespace (which I hate BTW).,-0.08611111111111114,python
150xbp3,jshcb0f,"For example, in Python, lists, sets, and dicts can't be used as keys in a dict and functions that take lists/sets/dicts as arguments can't use the built-in function memoization mechanisms.",0.0,python
150xbp3,jshcb0f,"One reason I think the Go community demanded generics so vociferously is that the built-in `slice` and `map` types lacked a lot of common functionality, like `sort()`, `reverse()`, `min()`, etc.",-0.3,go
150xbp3,jskjaow,Elixir has both of these and I love it.,0.5,elixir
150xbp3,jsai0x0,fr rust is my current fave language but the syntax is SO noisy.,0.0,rust
150xbp3,jsai0x0,i miss just going `.Variant` and letting the compiler fill in the blank in swift so much.,0.1,swift
150xbp3,jsai0x0,"```rust     match enum_instance {         module::EnumType::VariantA => …,         module::EnumType::VariantB => …,         module::EnumType::VariantC => …,     } ```  i know i can `use module::EnumType::*;` but i don’t wanna bring all variants into scope and pollute the namespace just for that one match expression lol.",0.8,rust
150xbp3,jsai0x0,why can’t i just go `::VariantA => …`.,0.0,go
150xbp3,jsai0x0,"like i’ve said there’s literally *only one* VariantA in the whole entire universe, there’s been *only one* since the big bang and will be *only one* til the end of time and everything that i could have conceivably possibly meant by any means and yet rust insists i type `module::EnumType::VariantA`",0.028571428571428574,rust
150xbp3,jskr3ea,"I kinda agree built-in hash map is a nice to have feature tho, having written a lot of clojure.",0.6,clojure
150xbp3,jscj3nk,"The Swift way of `.Variant` is much better, I fully agree.",0.5,swift
150xbp3,jscj3nk,Rust's requirement for giving the explicit path (or using a local import) just causes line noise for no tangible benefit (at least in my experience).,-0.15,rust
150xbp3,jsb3wr4,```rust let x = {   use mod::Enum::*;   match y {      /* ... */   } }; ```,0.0,rust
150xbp3,jsfzvay,[Higher Kinded Types in Haskell](https://serokell.io/blog/kinds-and-hkts-in-haskell)  [Higher Kinded Types in Scala](https://www.baeldung.com/scala/higher-kinded-types),0.25,haskell
150xbp3,jsfzvay,[Higher Kinded Types in Haskell](https://serokell.io/blog/kinds-and-hkts-in-haskell)  [Higher Kinded Types in Scala](https://www.baeldung.com/scala/higher-kinded-types),0.25,scala
150xbp3,jsfxvq5,"In Haskell, this exact functionality is given by the `Functor` type class:  ```haskell class Functor f where   fmap :: (a -> b) -> (f a -> f b) ```  Which is then used as:  ```haskell showInts :: (Functor f) => f Int -> f String showInts = fmap show ```  Here we say `f` is ""something that looks like a generic collection"".",-0.3125,haskell
150xbp3,jsfxvq5,"It would be like if in C# you could have an interface be specified something like:  ```csharp interface ICollection1 where this<TElem> {   this<TRes> FMap<TRes>(Func<TElem, TRes> f); } ```  whereby the interface `ICollection1` can only be implemented for types that take a generic argument to begin with.",0.0,c
150xbp3,jsfxvq5,"The only two languages I know of that elegantly support higher order generics, is Haskell and Scala.",0.25,haskell
150xbp3,jsfxvq5,"The only two languages I know of that elegantly support higher order generics, is Haskell and Scala.",0.25,scala
150xbp3,jsbdvqx,sure but that introduces a whole other level of nesting and an extra use statement not necessary in swift.,0.11499999999999999,swift
150xbp3,jsbdvqx,do you really think that’s any more meaningfully informative than swift?,0.39999999999999997,swift
150xbp3,jsbdvqx,"notice how, in *this specific* case, swift isn’t hiding any detail from me.",0.0,swift
150xbp3,jsbdvqx,"no, it’s just as transparent as rust’s match except when i say `.Variant` it knows there’s only one Variant that i could have possibly meant with *zero* ambiguity: `EnumType.Variant`.",0.0,rust
150xbp3,jsbdvqx,rust insists i spell it all out entirely either in every match arm or with a use statement.,0.0,rust
150xbp3,jsbdvqx,swift isn’t hiding any control flow.,0.0,swift
150xbp3,jsbdvqx,rust is just plain noisier  edit: idk why i sounded so combative/argumentative in this comment but i meant NO offence and i still LOVE rust!,0.20535714285714285,rust
150xbp3,jshe5zb,I think C++ has that.,0.0,c++
150xbp3,jshgms3,C++ has enough jank that everything is possible but nothing is easy.,0.14444444444444446,c++
150xbp3,jshgms3,Haskell has higher order generics with enough discipline and ergonomics that large parts of the standard library are built around it.,0.11607142857142858,haskell
150xbp3,jsbgh9a,"the thing is if i have ```rust     enum MandelbrotMembership {         NotAfter(usize),         Maybe     } ```  i don’t want the variants to be just freely strewn abt in the namespace uncontextualised (cos `Maybe` what?).",0.4,rust
150xbp3,jsbgh9a,"but is it really too much to ask if i want the compiler to know what i mean in ```rust     match membership {         ::Maybe => 0,         ::NotAfter(n_iterations) => 256 - n_iterations,     } ```  w/out having brought the variants into scope??",0.029166666666666674,rust
150xbp3,jsbikwx,i mean i don’t mean to sound mean (sorry) and we can agree to disagree but rust’s match expressions are just plain noisy without being any more meaningfully informative.,-0.031473214285714285,rust
150xbp3,jsbikwx,"my code doesn’t leave out any important detail other than boilerplate ```rust     match membership {         MandelbrotMembership::NotAfter(count) => …, //      ^^^^^^^^^^^^^^^^^^^^ what else could it be… srsly         MandelbrotMembership::Maybe,     } ```",0.05833333333333334,rust
150xbp3,jsbkeac,really 💀💀💀 i guess i appreciate swift a lil more now.,0.35,swift
150uorm,,"I was just playing around with CPP, making a general macro file called `makaronidefs.h` as I had done prior with [MangoMacs](https://gist.github.com/Chubek/bc96fc7cff2d90cb255ccd973c5ca9e8) but MangoMacs was for Assembly and I wanted something for cross-compiler C. That is besides the point.",0.02500000000000001,assembly
150uorm,,"So I thought to myself, what if I use CPP on Python, I wrote this [shell](https://pastebin.com/6uYJNbe7), I call her Shelly Duval because she's terrified and does not poll for some reason.",0.0,python
150uorm,,"So I thought to myself, what if I use CPP on Python, I wrote this [shell](https://pastebin.com/6uYJNbe7), I call her Shelly Duval because she's terrified and does not poll for some reason.",0.0,shell
150uorm,,I will be writing it in C because I also wanna learn cross-platform systems programming and I have been looking for a hook.,0.0,c
150uorm,js5c29k,Do you mean text preprocessor like the one in C / C++ ?,-0.3125,c
150uorm,js5c29k,Do you mean text preprocessor like the one in C / C++ ?,-0.3125,c++
150uorm,js5c29k,"In the GNU C preprocessor , you need to check the source code directly.",0.1,c
150uorm,js5c29k,"I started a C / C++ preprocessor alike tool, some time ago, used two small grammars, one for the tokens and lexer, another for the syntax rules and parsers.",-0.25,c
150uorm,js5c29k,"I started a C / C++ preprocessor alike tool, some time ago, used two small grammars, one for the tokens and lexer, another for the syntax rules and parsers.",-0.25,c++
150t0im,js5kol5,"Cool, looks useful for typed low-level IRs as well.",0.32499999999999996,cool
150t0im,js8ntw4,">A Very Modal Model of a Modern, Major, General Type System  [https://www.cs.princeton.edu/\~appel/papers/modalmodel.pdf](https://www.cs.princeton.edu/~appel/papers/modalmodel.pdf)  Cool paper.",0.17250000000000001,cool
150ovi7,,"For example, if we say JavaScript is a TC language, that will make the lexer for JS an oracle for `TMjs` right?",0.2857142857142857,javascript
150ovi7,js5b5re,"Since checking whether a string is a member of the language called JavaScript takes more than one step, it's not done by an oracle.",0.5,javascript
150fsjk,js40vnh,Lua developers have invented a technique for version 5.x to capture variables implicitly even with a single-pass compiler.,0.0,lua
150fsjk,js40vnh,"Umka's main design principle is *Explicit is better than implicit*, taken from the Python Zen.",0.3333333333333333,python
150fsjk,js40vnh,"I cannot say I understand how it applies to Python (which is too *implicit* for me), but to Umka it applies quite literally.",0.0,python
150fsjk,jschgnb,"So the main design goal was to have a statically typed language with an interpreter as small as Lua, Squirrel or Wren.",-0.04166666666666667,lua
150er0h,,"An easy way to speed it up is to use an optimising compiler (which for me means transpiling to C and using `gcc-O3`), which might improve things by up to 40%.",0.43333333333333335,c
150er0h,,"For a production compiler, fine, but I also no longer have the C transpiler anyway; I prefer to go it alone.",0.4166666666666667,c
150er0h,,"For a production compiler, fine, but I also no longer have the C transpiler anyway; I prefer to go it alone.",0.4166666666666667,go
150er0h,,(Note that 50% of Tiny C's speed is thanks to being compiled with something better than Tiny C!),0.175,c
150er0h,,"I have two large test inputs, the first is 1M lines of `a:=b+c*d` in one function.",0.23214285714285715,d
150er0h,js6gwhz,"At some point, if you want to go faster, you're going to have to handle multiple bytes at a time, ergo SWAR or SIMD.",0.0,go
150er0h,js6gwhz,"Most notably, I've been wondering whether it would be possible to use SIMD for _classifying_ bytes: identify whitespace, start-of-comment/end-of-line, start-of-string/end-of-string, digits/alphanumeric, control characters... That is, go from an array of bytes to multiple bit-arrays, and then using union/next-set-bit operations to jump forward.",0.25,go
150er0h,js4lhi0,Many languages especially C still seem fixated on 32-bit integers.,0.25,c
150er0h,jsax8kz,"When this compiler *was* optimised, via transpilation to C, performance when building large inputs improved up to 40%.",0.21428571428571427,c
1507h3a,js3hk3w,Do you have any notes on how it compares to similar languages like Lua or Lily?,0.0,lua
1507h3a,js7k5qg,"I really like [Ruby Koans](https://www.rubykoans.com/) as a way to get introduced to a language, so I wrote a similar interactive tutorial for two of my past language projects.",-0.016666666666666663,ruby
1507h3a,js3kcmz,"I haven't benchmarked it against lua specifically - but usability is quite similar, actually eerily so.",0.0,lua
1507h3a,js3kcmz,"I haven't used lua in something like 10 years, but my C API for Toy's interpreter resembles it somewhat, or at least has analogues.",-0.3,lua
1507h3a,js3kcmz,"I haven't used lua in something like 10 years, but my C API for Toy's interpreter resembles it somewhat, or at least has analogues.",-0.3,c
1507h3a,js3kcmz,The major difference is to lua is the presence of two compound structures (arrays and dictionaries) rather than one (tables).,0.0625,lua
1506omu,js1qkjg,Really cool!,0.4375,cool
1504ozy,js3oazn,"Languages like Lisp typically use a reader, and languages like  Forth have a compilation mode that doesn't do anything like parse/lex  (dt, for example, also does not need or want a traditional lexer or parser)  Also this is usually about the early stages of a language, which makes a lot of sense for a new language guide.",-0.03606060606060606,lisp
1504ozy,js3oazn,"Languages like Lisp typically use a reader, and languages like  Forth have a compilation mode that doesn't do anything like parse/lex  (dt, for example, also does not need or want a traditional lexer or parser)  Also this is usually about the early stages of a language, which makes a lot of sense for a new language guide.",-0.03606060606060606,forth
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,python
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,go
1504ozy,js3zuot,"This post was written with general purpose traditional languages in mind resembling Python or Go or C where you would leverage the parser to eventually make language tools like formatters, linters etc.",0.02500000000000001,c
1504ozy,js3zuot,Some languages like forth might be designed to work this way so it can work with resource constrained environments.,0.0,forth
14zwh6r,,"* https://dt.plumbing * User guide: https://dt.plumbing/user-guide/ * Latest stdlib: https://dt.plumbing/stdlib.html * Repository: https://github.com/so-dang-cool/dt  It's a dynamically typed, concatenative scripting language with lots of influences (some listed in the README) and a focus on being a minimal and accessible language in shell environments.",0.25833333333333336,shell
14zwh6r,,"Kind of the area of systems administrators and linux distro maintainers and enthusiasts, where very obfuscated AWK, Perl, Python, and others live, but aiming for a more accessible syntax.",0.3622727272727273,perl
14zwh6r,,"Kind of the area of systems administrators and linux distro maintainers and enthusiasts, where very obfuscated AWK, Perl, Python, and others live, but aiming for a more accessible syntax.",0.3622727272727273,python
14zwh6r,,"Early versions waffled between languages, I settled on Rust for a while, then renamed it and re-implemented in Zig with some improvements to the approach.",0.1,rust
14zoylt,jrz8f99,Haskell uses a newtype keyword.,0.0,haskell
14zoylt,jrz8f99,"In Ada, they are called derived types and are written like: `type Derived is new BaseType;` while type aliases are called subtypes and omit the `new` keyword (e.g.",0.13636363636363635,ada
14zoylt,jrzaohf,"For example, in Rust, structs can be written with named fields, but also as tuple structs, which work really well for types that just wrap a single other type:      // named fields     struct MyNewtype {         wrapped: PredefinedType     }      // tuple struct     struct MyNewType(PredefinedType)  The compiler knows that `MyNewType` is identical to `PredefinedType`, so they optimise the same, but they can't be used the same any more — you can't pass a `MyNewType` to a place that's expecting a `PredefinedType`, and vice versa.",0.08392857142857142,rust
14zoylt,jrz852z,Haskell uses `newtype` which is a zero-cost abstraction.,0.0,haskell
14zoylt,js2azgo,D uses [`Typedef`](https://dlang.org/library/std/typecons/typedef.html).,0.0,d
14zoylt,jsbj2uu,I have called this [strong typing](https://en.wikipedia.org/wiki/Strong_and_weak_typing) but this may just be influence from a old lint program which added strong typing to C++.,0.3222222222222222,c++
14zoylt,jrzma68,In a plain C alike:      struct PointA     {         int X;         int Y;     } ;           struct PointB     {         int X;         int Y;     } ;        Should be considered two different types.,-0.10714285714285714,c
14zoylt,jrznfzl,The wrapper would be cool but I think I will reserve that for generic types if I go that way (i might go with metaprpgramming instead),0.175,cool
14zoylt,jrznfzl,The wrapper would be cool but I think I will reserve that for generic types if I go that way (i might go with metaprpgramming instead),0.175,go
14zoylt,jzk4te3,In Scala 3 such types are called Opaque Types [docs](https://docs.scala-lang.org/scala3/book/types-opaque-types.html).,0.0,scala
14znygr,,"I know about Oberon and Turbo Pascal, which were famous for their fast compilation speed, but I was curious about more current research.",0.22000000000000003,pascal
14znygr,js1rfbr,The DMD compiler for D is pretty fast.,0.225,d
14znygr,js0n7h0,"believe it or not, but SBCL compiler for common lisp",-0.3,lisp
14znygr,jrzcnmw,"Note that Tcc's speed depends in part in being built (as a C application) using `gcc -O3`, or via some optimising compiler.",0.0,c
14znygr,jrzcnmw,Transpiling to C and using `gcc-O3` would give a boost of 30-40%.,0.0,c
14znygr,jrzqcxz,"“Super-fast compilers are looked down upon as toys”  I’d argue go is a counter example, unless go does not go (kneeslap) into the super-fast category",-0.15555555555555559,d
14znygr,jrzqcxz,"“Super-fast compilers are looked down upon as toys”  I’d argue go is a counter example, unless go does not go (kneeslap) into the super-fast category",-0.15555555555555559,go
14znygr,jrzuys5,I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,d
14znygr,jrzuys5,I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,c++
14znygr,jrzilr5,"This is Hapran Xu's proof of concept about creating a multi tier JIT compiler for Lua other than LuaJIT, which is already a work of art.",-0.125,lua
14znygr,jrzilr5,"Haoran Xu has also written two AMAZING blog posts that specify how LJR works: https://sillycross.github.io/2022/11/22/2022-11-22/ - building a lua VM automatically https://sillycross.github.io/2023/05/12/2023-05-12/ - base Copy & Patch Tier 1  Edit: corrected ""it's"" to ""its""",-0.09999999999999998,lua
14znygr,js07ob0,I'd call Go's speed 'healthy'.,0.5,go
14znygr,js07ob0,The tests I did a few years ago (on a slower machine) put Go's lines-per-second rate in the high 5-figures; the faster ones were well into 6 figures.,-0.020000000000000004,go
14znygr,js07ob0,"But sometimes all you want to do is turn a bunch of source code into executable code as quickly as possible, and so long as it does a reasonable job, I don't care,  C is commonly used as a target language, so the code has already been verified; in this case you don't need complex analysis.",-0.09,c
14znygr,jrzxese,> I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,d
14znygr,jrzxese,> I’d love it if there was a C++ compiler that tracked what parts of a header file actually changed and what parts are used by other files (even if it wasn’t fully sound).,0.19375,c++
14znygr,jrzzymg,"Because, even on my machine, which is not that fast, a fast compiler like Tiny C can generate executable code at up to 10MB per second (so 7 minutes doing that would produce a 4GB executable, although it would probably run out of memory long before).",0.07,c
14znygr,jrzzymg,"Regarding C code, people don't mind faster compilers, but from innumerable threads about this in various forums, they are unwilling or unable to move away from mainstream but slow compilers like `gcc`, and switch to `tcc`, which can be 20 times faster than even `gcc-O0`.",-0.26666666666666666,c
14znygr,jrzzymg,"From your comments it sounds like you are using C++, which has various features not conducive to fast compilation.",0.1,c++
14znygr,js1umyf,"The original was created in assembly, and I probably wrote the assembler.",0.375,assembly
14znygr,js1umyf,"It's different from ones like C, in only supporting one target at a time.",0.08333333333333333,c
14znygr,js1umyf,"It can be made to work on ARM and Linux via intermediate C, but I'm pulling support on that.",0.0,c
14znygr,js3t82q,This is super cool.,0.3416666666666667,cool
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,pascal
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,fortran
14znygr,js4ok0x,"Its syntax was inspired mainly by Algol60/68 and Pascal, with a few bits of Fortran and Ada.",-0.016666666666666677,ada
14znygr,js4ok0x,"Wirth actually worked on Algol68, before he left to create Pascal (via Algol W maybe?)",0.0,pascal
14znygr,js4ok0x,"Wirth actually worked on Algol68, before he left to create Pascal (via Algol W maybe?)",0.0,algol
14znygr,js4ok0x,It filled that role far better than Algol68 *or* Pascal!,0.375,pascal
14znygr,juc4cqg,"I mean, they are not terrible: here I compare Clang/LLVM, run via `Zig CC` as that is the only way I can get it to work on Windows, with my compilers, on a 40Kloc C input:      Compiler        Input   Opt  Build Time   Runtime          Zig cc -O0      qc.c    -O0   2 secs      5.8** secs     Zig cc -O3      qc.c    -O3  10           4.6     bcc             qc.c    --    0.18        5.8     mm              qc.m    --    0.1         5.5  `bcc` is my C compiler, which itself is not optimised, and is further handicapped by needing an ASM stage.",0.046875,c
14znygr,js3obdq,Also: C&P is seriously impressive.,1.0,c
14znygr,js3obdq,Using C++ templates and linker relocations to create and specialize these stencils is pretty mind-bending!,0.3125,c++
14znygr,juc5hw7,Llvm does actually do 260 passes by default in Rust.,0.0,rust
14ytm57,,"Basically I'm wondering, for implementing the main libraries of a programming language, if it should go the ""chainable API"" path like D3.js or [Sharp.js](https://blog.logrocket.com/processing-images-sharp-node-js/) (image manipulation), or a more ""declarative state"" sort of system like Terraform.",0.3333333333333333,go
14ytm57,,"And defining a fluid Rust or JS-like chainable API is easy to write and think about I think, but perhaps declarative state is ""better""?",0.3111111111111111,rust
14ytm57,jruog2o,"something that someone might want to do, but no-one will be doing regularly — how would you go about doing this?",0.0,go
14ytm57,jrxspmx,many configuration APIs in TypeScript have fields that can only be specified in tandem or not at all.,0.25,typescript
14ytm57,jrxspmx,"Rust and other affine type systems can do this, but it's difficult and causes a combinatorial explosion of types.",-0.3125,rust
14yacuw,,Consider the expression `k(b + c)`.,0.0,c
14yacuw,,"Does this mean `k` times the quantity `b + c`, or does it mean the function `k` with the argument `b + c`?",-0.3125,c
14yacuw,,"Then `k(b + c)` would always mean the function `k`, and if you wanted it to mean multiplication you would have to use `k*(b + c)`.",-0.3125,c
14yacuw,jrrnoua,"I mean if we're going to do it, lets go all in.",-0.3125,go
14yacuw,jrschae,"I just think it is a pity that even when a language like C allows all letterlike Unicode codepoints in identifiers, the standards committee forgets to add ""×"" and ""·"" as multiplication symbols synonymous to ""\*"", or even better only for multiplication, not pointer dereferencing, which would still be absolutely trivial.",0.15000000000000002,c
14yacuw,jrschae,"The curly braces, for those of us who still remember mathematics before we learned C or Perl or one of the many other languages that overloads them with several meanings, are mainly used for set notation, as set descriptors or set builders.",0.13541666666666666,c
14yacuw,jrschae,"The curly braces, for those of us who still remember mathematics before we learned C or Perl or one of the many other languages that overloads them with several meanings, are mainly used for set notation, as set descriptors or set builders.",0.13541666666666666,perl
14yacuw,jrskxe6,"I.e., this weird syntactic decision on Wolfram’s part was only required because other, weird & I’d argue ill-considered decisions were made first—e.g., adposition for multiply, which *only* makes sense if you’re making a language that matches math syntax, and `[]` for function calls is decidedly not math-syntax-like (and *more unexpectedly non-math-like* than \* or × for multiply).",-0.058333333333333334,d
14yacuw,jrskxe6,"So in general there’s really no reason to require any brackets/parens at the call site, or for this  	x := (a, b, c) 	f x  and `f(a, b, c)` to do different things, or to require different parsing for arglists and tuples.",-0.16,c
14yacuw,jrrvzut,"since argument object is a tuple (optionally with keys), so [a, b, c] is an object constructor for lists, dicts and argument objects (a general keyed sequence container similar to lua table).",0.02500000000000001,c
14yacuw,jrrvzut,"since argument object is a tuple (optionally with keys), so [a, b, c] is an object constructor for lists, dicts and argument objects (a general keyed sequence container similar to lua table).",0.02500000000000001,lua
14yacuw,jrxjq2s,Algol got it right.,0.2857142857142857,algol
14yacuw,jrsfzs8,"If you have `a=b; (*c)[0] = 0` without the semicolon would be parsed as `a = (b(*c)[0] = 0)`, so semicolons become obligatory.",-0.75,c
14yacuw,jrrtngr,Perhaps that f(x)^2 has a different parse precedence than a(b + c)^2?,0.0,c
14yacuw,jsaivgu,"Then k(b + c) would always mean the function k, and if you wanted it to mean multiplication you would have to use k*(b + c).",-0.3125,c
14yacuw,jrrwh18,"That's the bit where he *should* have said --- ""fuck mathematical conventions, I should go with all the other PLs and make `*` explicit"".",-0.17500000000000002,go
14yacuw,jrshzqo,"Regarding `k(b + c)`, I do not view this as a mistake at all.",0.0,c
14yacuw,jruhfzo,"Operator precedence is necessary for infix, otherwise you get “parentheses hell” like in LISP.",0.0,lisp
14yacuw,jrsir8r,"But then, `-d` is also a valid statement (even if its useless), so if you have `a = b ; -d`, it would parse as `a = b - d` without the semicolon.",-0.5,d
14yacuw,jrymn4w,"I must admit I would go more in the direction of `[]` for generics and `()` for function calls (and array indexing), but it's fairly symmetric.",0.6,go
14yacuw,jru8ian,"`f(x)^2` has different precedence to `k(b + c)^2`, the function version having the function with higher precedence `(f(x))^2` and the implicit mult version having the exponentiation with higher precedence `k*((b + c)^2)`.",0.16666666666666666,c
14yacuw,jrsnm0q,"If they really wanted to have a sequence operator, they could have used semi-colon, and followed the rust (and others) convention of the last expression returning as the value for the block.",0.1,rust
14yacuw,jrwvvr6,"But look at c(a+b) = ca + cb = c(a) + c(b), although it feels weird to write c(x) with this meaning.",-0.5,c
14yacuw,jrwvvr6,"Then αβ may mean many different things, depending on A and B. even worse, let's introduce γ of type C and the expressions: (αβ)γ, α(βγ), and αβγ.",-0.1925,c
14yacuw,jrwvvr6,"There actually is precedent for that in programming languages: In Perl, a function can have an unparenthesised comma-separated argument list, but if the first expression after the function name is parentheses, then it is assumed to contain all arguments to the function.",0.125,perl
14yacuw,jrwvvr6,"But this means that interpreting αβγ correctly as (αβ)γ or α(βγ) not only depends on the type of A, B and C, but also of whether the expressions are parentheses or not.",0.0,c
14yacuw,jrx6ck1,"Fortran and Ada use the same syntax for both, although both use round brackets for the purpose.",-0.1,fortran
14yacuw,jrx6ck1,"Fortran and Ada use the same syntax for both, although both use round brackets for the purpose.",-0.1,ada
14yacuw,jrx6ck1,Ada I think specifically wanted to blur the distinction between the two.,0.0,ada
14yacuw,jt6o09q,"Yes, we also have those under the name ""generics"" or Haskell name them type variables.",0.0,haskell
14yacuw,jsapg83,"Haskell treats type parameter application syntactically the same as function application (both with space as the operator char), though it doesn't have syntactic sugar form of array indexing, array element value get is a vanilla infix operator `!`, as in `a !",0.0,haskell
14yacuw,jrxfz6c,"Indexing can go really fancy, e.g.",0.2,go
14yacuw,jru65jt,"The *whole point* for me is to try to deviate as little as possible from traditional notation, so if the semicolons *have* to go (and I actually *like* them between a sequence of expressions), I'd prefer using ""significant whitespace"" hinting.",0.06458333333333334,go
14yacuw,jru65jt,"(And this would not be worse than many other languages' conventions/heuristics for ""semicolon insertion"": JavaScript, Go, ...)",-0.00833333333333334,javascript
14yacuw,jru65jt,"(And this would not be worse than many other languages' conventions/heuristics for ""semicolon insertion"": JavaScript, Go, ...)",-0.00833333333333334,go
14yacuw,jrwy1vm,For example Haskell.,0.0,haskell
14yacuw,jrwy1vm,"Obviously not, otherwise I would be happy with FORTRAN IV, code in all-uppercase, and punch cards.",0.4,fortran
14xy759,,"So far I think [Rust](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html) has the best error messages in the terminal, where it draws red lines using `^` or `~` with arrows and descriptions inline with the code.",0.3666666666666667,rust
14xy759,,It appears Rust drew inspiration from [Elm](https://elm-lang.org/news/compiler-errors-for-humans) for error styles.,0.0,rust
14xy759,,It appears Rust drew inspiration from [Elm](https://elm-lang.org/news/compiler-errors-for-humans) for error styles.,0.0,elm
14xy759,jrq26ho,Maybe Rust has few implementations so it's easy to get those mixed up (unless such things are baked into the language specification; I don't know).,0.058333333333333334,rust
14xy759,jrq26ho,"C on the other hand has loads, of which one of the most interesting is Clang's when running on Windows.",0.2916666666666667,c
14xy759,jrq2tu2,Iirc I heard praises for Elixir or was it Elm?,0.0,elixir
14xy759,jrq2tu2,Iirc I heard praises for Elixir or was it Elm?,0.0,elm
14xy759,jrqdfwq,Coalton drew inspiration from Rust & Elm.,0.0,rust
14xy759,jrqdfwq,Coalton drew inspiration from Rust & Elm.,0.0,elm
14xy759,jrpt5f8,There is also another notable Rust error rendering lib: [ariadne](https://github.com/zesterer/ariadne).,-0.125,rust
14xy759,jrpt5f8,"So you can get the same beautiful error rendering in your own projects :D  Also, just to be clear, `rustc` uses it's own internal lib for error rendering.",0.45000000000000007,d
14xy759,jrssh0z,"Rust's tooling is heavily standardized by the language — compiler (`rustc`), package manager, auto doc generator, formatter, linter, etc, and they are all available with the tool `cargo` that one installs through the typical installation.",0.011111111111111118,rust
14xy759,jrssh0z,"Having multiple implementations of the Rust compiler is generally not sought after as well, so it's accurate to think of `rustc`'s diagnostics as the language's own diagnostics.",0.24375000000000002,rust
14xy759,jrssh0z,"It's also worth noting that since Rust's compilation model is relatively strict, much of the compiler diagnostics are essential feedback, especially while learning the language — hence the UX choices made.",0.1,rust
14xy759,jrqyel7,Probably Elm - its error messages are quite good,0.7,elm
14xy759,jues26t,I wish there were libraries like this for go,0.0,go
14xuna4,jrph9w1,"I don't know about LLVM IR specifically, but I had difficulty converting C# IL to WASM because it used goto statements instead of loops.",0.0,c
14xuna4,jrqsduk,GHC (Haskell) does short cut fusion based on a set of rewrite rules like `map g .,0.0,haskell
14xuna4,js4ktkm,"You may think of LLVM as being at a similar level to C, with perhaps some more detailed information.",0.3,c
14xuna4,jrptkfu,"I am currently experimenting with function inlining in JavaScript, and I'm unsure how to handle multiple returns in a function.",0.0,javascript
14xuna4,js7xcl7,"The Rust compiler has two AST-ish levels, I believe.",0.0,rust
14xouqc,jroi0us,"You only need to do that once  Lets say I have a project divided into modules `a`, `b`, `c`, `d` and the module `e` which contains `main()`.",0.08333333333333333,c
14xouqc,jroi0us,"You only need to do that once  Lets say I have a project divided into modules `a`, `b`, `c`, `d` and the module `e` which contains `main()`.",0.08333333333333333,d
14xouqc,jroi0us,`e` imports `d`.,0.0,d
14xouqc,jroi0us,`d` imports `c`.,0.0,d
14xouqc,jroi0us,`d` imports `c`.,0.0,c
14xouqc,jroi0us,`c` imports `b`.,0.0,c
14xouqc,jroi0us,"* If using DLLs, then I merely have to rebuild `b` alone and the improved implementation of `b` would be immediately available to `c`, `d` and `e` without any further recompilation.",-0.033333333333333326,c
14xouqc,jroi0us,"* If using DLLs, then I merely have to rebuild `b` alone and the improved implementation of `b` would be immediately available to `c`, `d` and `e` without any further recompilation.",-0.033333333333333326,d
14xouqc,jroi0us,"* But with static libs, I'd have to rebuild `c`, `d` and `e` for the newer implementation of `b` to bubble up (which is a problem that I don't think even caching can solve).",0.5,c
14xouqc,jroi0us,"* But with static libs, I'd have to rebuild `c`, `d` and `e` for the newer implementation of `b` to bubble up (which is a problem that I don't think even caching can solve).",0.5,d
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,lisp
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,c
14xms09,,"The syntax is inspired by both Lisp and traditional C style languages, as well as Lua.",0.0,lua
14xms09,,"Thus this is not an issue:      let f1 = function f do         let x = 10         invoke f     end          let f2 = function do         let x = 20         let inner-fn = function do             print x # Will print '20', not '10'         end     end  ('invoke' is a function can be used to call functions taking no arguments)  The interpreter is written in C (C99), and the core interpreter (not counting any libraries) is just around 1k lines of code, and can be embedded by compiling it to a library and including the interpreter.h header.",0.0,c
14xms09,,It is possible both to call Beryl functions from C and C functions from Beryl.,0.0,c
14xms09,jrptjam,That's cool as fuck.,-0.025000000000000022,cool
14xms09,js0e275,I think this is really cool.,0.35,cool
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,typescript
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,haskell
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,rust
14xmlma,,"The most common form of this is generics:      // TypeScript     type Container<T> = { value: T };          // Haskell     data Container a = Container { value :: a }          // Rust     struct Container<T> { value: T };  Other languages achieve the same result by using compile-time metaprogramming to produce new types:      // Zig     fn Container(comptime t: type) type {         return struct { value: t };     }          // C++ (note that this is not a generic, but more like a code generation template)     template<typename T>     class Container { public: T value; }  Intuitively, the first approach seems somewhat more ""principled"" and ""constrained"" to me, but I don't know what this means in practice.",0.14613636363636365,c++
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,c++
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,java
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,c
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,scala
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,kotlin
14xmlma,,"I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages (Java, C#, Scala, Kotlin, TypeScript).",-0.022222222222222237,typescript
14xmlma,jro34g9,This is part of why C++ is famously so slow to compile and leads to such large codesize.,-0.02857142857142859,c++
14xmlma,jro34g9,This is why it can be such a challenge to maintain and use third-party C++ libraries that use a lot of templates.,0.0,c++
14xmlma,jro34g9,This is even worse in C++ because of overloading and [SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error).,-0.4,c++
14xmlma,jro34g9,"In C++, if a call fails (i.e.",-0.5,c++
14xmlma,jro34g9,(I guess that makes C++ templates more like a logic language?),0.5,c++
14xmlma,jro34g9,This is why compile errors from templates in C++ are hell.,0.0,c++
14xmlma,jro34g9,"Java generics were very successful, so many languages since then went down a similar (but not identical) path.",0.3298611111111111,java
14xmlma,jrojr67,Note that GADTs can't work in an approach like C++ templates.,0.0,c++
14xmlma,jrojr67,GADTs _could_ work in Rust if Rust allowed erasing some of the generic types; otherwise it also won't work.,0.0,rust
14xmlma,jrojr67,C++ already supports template template parameters.,0.0,c++
14xmlma,jrotsua,"> I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages  Check out [D](https://dlang.org).",-0.022222222222222237,c++
14xmlma,jrotsua,"> I may be wrong, but I think only C++ has templates, of all strongly typed mainstream languages  Check out [D](https://dlang.org).",-0.022222222222222237,d
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,ruby
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,python
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,php
14xmlma,jrotsua,"It has [Turing-Complete templates](https://dlang.org/spec/template.html) with specialised [`static if`](https://dlang.org/spec/version.html#staticif), [`static foreach`](https://dlang.org/spec/version.html#staticforeach), [`version`](https://dlang.org/spec/version.html#version), and [`debug`](https://dlang.org/spec/version.html#debug) constructs, all as statements and declarations, as well as more general [quasiquoting](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20%28Bawden%29.pdf) expressions and declarations with [`mixin`](https://dlang.org/spec/expression.html#mixin_expressions) (yes, that is the same as Ruby's, Python's or PHP's `eval`, but at compile-time; in fact you can `import()` files at compile-time too and write a compiler in user code that compiles those before `mix`ing the result `in`, all invoked by the D compiler).",0.31,d
14xmlma,jrotsua,"In fact, [Design-By-Introspection](https://www.youtube.com/watch?v=HdzwvY8Mo-w) is a core tenet of D doctrine.",0.0,d
14xmlma,jrotsua,"If I knew more about Lisp, I'd have posted a Lisp metaprogramme that typechecks itself AOT.",0.5,lisp
14xmlma,jrovxh2,"If List<T> is covariant (eg because it’s a read-only data type), and your language has subtyping and variance (like Java or TypeScript), saying a variable has type List<T> means it will hold a List or some subtype of List, each element of which is of type T or a subtype of T.  And the different elements can have different types (heterogeneity).",0.0,java
14xmlma,jrovxh2,"If List<T> is covariant (eg because it’s a read-only data type), and your language has subtyping and variance (like Java or TypeScript), saying a variable has type List<T> means it will hold a List or some subtype of List, each element of which is of type T or a subtype of T.  And the different elements can have different types (heterogeneity).",0.0,typescript
14xmlma,jrpg2cf,There is also the in-development language [Hackett](https://github.com/lexi-lambda/hackett) which uses the approach described in the paper to unify Racket style macros with a Haskell style type system.,0.0,haskell
14xmlma,jro6tff,I think Rust generics are much more like C++ templates than you realise.,0.5,rust
14xmlma,jro6tff,I think Rust generics are much more like C++ templates than you realise.,0.5,c++
14xmlma,jro6tff,"The compiler will generate different instances of Container for each type parameter, just as C++ will.",0.0,c++
14xmlma,jro84cz,"In rust, `Vec` is defined (more or less) like this:  ``` struct Vec<T> {     buf: RawVec<T>,     len: usize, }  // impl Vec ... ```  This is a Generic type that takes a type parameter and uses it to define a struct (the builtin type constructor).",0.11111111111111112,rust
14xmlma,jro84cz,"For custom types Rust - like many others - uses a kind of ""sublanguage"" that is processed during compilation to elaborate the type system.",0.5333333333333333,rust
14xmlma,jro84cz,"On the opposite side, Zig has a novel approach: instead of using a separate syntax to define types, the constructor is an actual Zig function (evaluated at comptime):  ``` fn Vec(comptime T: type) type {     return struct {         buf: []T,         len: usize,          // methods...     }; } ```  While it may seem that we are breaking some kind of academic barrier by executing code to create types, in the end the result is identical to the Rust example: a builtin type constructor (the `struct`) parametrized by a type value.",-0.030000000000000006,rust
14xmlma,jro84cz,"Rust just uses a special syntax to describe it, but it's a comptime computation all the same.",0.17857142857142858,rust
14xmlma,jro84cz,"There are practical differences: by having a more restricted syntax/semantics for the type system (like Rust does) you get the benefit of error messages that are naturally simpler to understand; plus, Rust generics cannot loop forever (afaik).",0.3,rust
14xmlma,jrnteuv,It's more like an arrow (as understood in Haskell).,0.5,haskell
14xmlma,jroimbo,"That Zig in particular does not do it (nor do dynamic C++ templates for that matter), is a detail of that particular implementation.",0.1111111111111111,c++
14xmlma,jroimbo,"Here's a proved correct type argument to a type function in my language:      RefCountable = (a: Type) when (match a with         | b * c -> (b <: RefCountable) and (c <: RefCountable)         | RC b -> False         | _ -> True     )          RC (a: RefCountable) = {| refcount: Natural1;; payload: a |}  Here, `RefCountable` is a refined subtype of `Type`, and `RC`'s `a` is a type argument, which the compiler type-checks ahead-of-time.",-0.2666666666666667,c
14xmlma,jroimbo,"Nowadays with its `concept`s, even C++ supports this.",0.0,c++
14xmlma,jrom2ol,This is not fully true anymore: C++'s `concept`s allow to constrain type arguments.,0.35,c++
14xmlma,jrom2ol,In fact D's entire metaprogramming doctrine relies on CTFE to typecheck type arguments (eg.,0.0,d
14xmlma,jrom2ol,"eg: `Additive = { a ∈ Type | ∀(x ∈ a, y ∈ a): x + y }`   or in C++:      template<typename a>     concept Additive = requires(a x, a y) { x + y; };",0.0,c++
14xmlma,jrocse6,"From a code generation perspective, they're the same, but from a type checking perspective, they're two different ends of a spectrum, with C++ on the now-disfavored ""compile time dynamic typing"" end.",0.0,c++
14xmlma,jrnw0ts,"When I say ""function"", I usually mean ""a mapping that can be represented by a (potentially infinite) table"", like      Input             | Output     --------------------------------------     int32             | { value: int32 }     int64             | { value: int64 }     bool              | { value: bool }     User              | { value: User }     Container<string> | { value: { value: string } } 	(or { value: Container<string> } if we evaluate generics lazily)     ...and so on...  Where inputs are concrete things (in this case types) that go in, and outputs are concrete things (in this case also types) that we get back.",-0.14464285714285716,go
14xmlma,jro9pl3,"Using Rust and Zig as examples: the first models mathematical functions with programming functions and type arrows with generics; Zig, on the other hand, decides that its functions are a good enough model for both mathematical functions and type arrows.",0.13749999999999998,rust
14xmlma,jrosuli,"This is a common issues with C++ templates, for example:      template <typename F, typename... Args>     auto invoke(F fun, Args&&... args) {         auto result = fun(std::forward<Args>(args)...);          return result;     }  This looks perfectly reasonable.",0.06666666666666667,c++
14xmlma,jrohsjr,"Eg:      RefCountable = (a: Type) when (match a with         | b * c -> (b <: RefCountable) and (c <: RefCountable)         | RC b -> False         | _ -> True     )          RC (a: RefCountable) = {| refcount: Natural1;; payload: a |}  Here, `RefCountable` is a type-checked type.",-0.2666666666666667,c
14xmlma,jroi5in,"You don't need Dependent Typing: type constraints, including C++'s concepts, can be modelled after Refinement Types alone, though they of course are less general.",-0.05833333333333332,c++
14xmlma,jropcwi,"You can achieve both in a single language with either a reflective interface and CTFE (as in D, `void f(T)(T x) if(typeid(T).whatever)`), or with types as first-class values, as in      double (x: 'a) if (isAdditive 'a) = x + x  Refinement (or Dependent) Types can achieve the same thing, and simplifies type signatures:      Additive = { a ∈ Type | ∀(x ∈ a, y ∈ a).",-0.023809523809523808,d
14xmlma,jro0mdn,"\*The name ""arrow"" comes from the Category Theory, but the way I use it is a bit more pragmatic, more related to Haskell's typeclass inspired by the mentioned theoretical concept",0.25,haskell
14wxw2c,jrl9nk7,"Rustc and ghc both use it, and swift uses something very similar with their Requirement machine.",0.0,swift
14wxw2c,jrpvwo8,"I don't know about Rust, but GHC has numerous fancy features that require constraints.",0.0,rust
14wxw2c,jrpvwo8,Already in the surface language in GHC Haskell we can write type [equality constraints](https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/equality_constraints.html).,0.0,haskell
14wwl1h,jrkfj7b,The language seems cool.,0.35,cool
14wwl1h,jrldr9n,Nope - It's just a big image for now :D,0.5,d
14wu604,jrm2qqt,"As a very novice person in language design, this was cool to read.",0.275,cool
14wu604,jrn30rp,What is the Scala influence on Vale?,0.0,scala
14wu604,jrjy1bv,"I'm hoping that by combining them with generational references we can finally make our programs as fast as Rust or as flexible as Java or wherever we want in-between (we need a term for this, perhaps gradual optimization?)",0.1,rust
14wu604,jrjy1bv,"I'm hoping that by combining them with generational references we can finally make our programs as fast as Rust or as flexible as Java or wherever we want in-between (we need a term for this, perhaps gradual optimization?)",0.1,java
14wu604,jrn2wlj,your color-coded sidebar/footnotes thing is really cool.,0.35,cool
14wu604,jrp2exs,Vale has a general rule that a function or struct needs to be marked `exported` to be visible to C or the OS.,0.07500000000000001,c
14wu604,jss55ir,Cool!,0.4375,cool
14wu604,jssyug4,"The docs do need a bit of a re-write in places chbut here are the links:  * [Language documentation](https://github.com/SamG101-Developer/SPP-2/tree/master/docs) (ignore src/main BNF file -- not upto date) * [Language Compiler](https://github.com/SamG101-Developer/SPP-Compiler-2) (lexing, parsing works, started on semantic analysis)  the compiler will be re-written in rust, just easier to prototype in python tbh.",0.0,rust
14wu604,jssyug4,"The docs do need a bit of a re-write in places chbut here are the links:  * [Language documentation](https://github.com/SamG101-Developer/SPP-2/tree/master/docs) (ignore src/main BNF file -- not upto date) * [Language Compiler](https://github.com/SamG101-Developer/SPP-Compiler-2) (lexing, parsing works, started on semantic analysis)  the compiler will be re-written in rust, just easier to prototype in python tbh.",0.0,python
14vvgnw,jrf6ewn,"I would argue this makes your automata objects, and thus your language OOP, though in a different sense from Java.",0.0,java
14vvgnw,jrhc2oi,Cell program gets compiled literally into Java or C# code.,0.0,java
14vvgnw,jrhc2oi,Cell program gets compiled literally into Java or C# code.,0.0,c
14vvgnw,jrhc2oi,Are they saying the Java code compiled from Cell is 2-3 times faster and less memory intensive than an “equivalent Java program”?,-0.16666666666666666,java
14vvgnw,jrhc2oi,That simply sound like they are comparing to a terribly written Java program.,-0.3,java
14vvgnw,jrhc2oi,Or are they using the Cell to C++ the compiler?,0.0,c++
14vvgnw,jrhc2oi,Anything is 2-3 times faster and use less memory in C++ compared to Java.,-0.16666666666666666,c++
14vvgnw,jrhc2oi,Anything is 2-3 times faster and use less memory in C++ compared to Java.,-0.16666666666666666,java
14vvgnw,jrf2lg0,Java is faster than c#?,0.0,java
14vvgnw,jrf2lg0,Java is faster than c#?,0.0,c
14vvgnw,jrivdfp,"In this regards, they're more like messages in the actor paradigm (Erlang), but automata are not actors either, because actors have their own thread of execution while automata are ""passive"" entities, just jike objects in OOP.",0.55,erlang
14vvgnw,jrhkjyy,"Assuming the java version is OOP with a lot of pointer chasing and the cell version has a dense cache friendly representation, this could be right.",0.33035714285714285,java
14vvgnw,jrhkjyy,"You could call that a terrible Java implementation, but it might be the Java implementation many developers would write.",-0.25,java
14vvgnw,jrhkjyy,Most Java developers are not thinking about data oriented design and cace locality.,0.5,java
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,c++
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,java
14vvgnw,jrimmwg,"Cell can be compiled to C++, Java and C#.",0.0,c
14vvgnw,jrimmwg,"The performance results shown on the website are for the C++ code generator, which is obviously the fastest of the three.",0.0,c++
14vvgnw,jrimmwg,"But Cell is not a library on top of those language, it's a programming language in its own right, and it could be compiled directly to assembly language or LLVM code, and I would expect it too be even faster in that case.",0.37142857142857144,assembly
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,java
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,c++
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,javascript
14vvgnw,jrimmwg,"If anything were 2-3 times faster and used less memory than Java when compiled to C++ as you say, then any language (Golang, Javascript, Python... or even Java itself) could then be compiled to C++ and outperform Java by a factor of 2 or 3, but that doesn't seem to be the case.",-0.16666666666666666,python
14vvgnw,jrimmwg,"The thing is, the kind of code that even a very good compiler/transpiler would generate when compiling any higher-level language to C++ is not the same as manually written C++ code.",0.5033333333333333,c++
14vvgnw,jrimmwg,"The Java and C# code it's compared to are written in an OOP style, and I think this is stated clearly in the article and the benchmark page.",0.10000000000000002,java
14vvgnw,jrimmwg,"The Java and C# code it's compared to are written in an OOP style, and I think this is stated clearly in the article and the benchmark page.",0.10000000000000002,c
14vvgnw,jrimmwg,"You can certainly squeeze better performance from Java by ditching OOP altogether and using data oriented programming techniques, or the ECS architecture, but that's certainly not the kind of programming style Java was designed around, and it definitely takes an extra effort on the part of the programmer to do so.",0.20119047619047623,java
14vvgnw,jrimmwg,"And note that the title of the post is ""Why functional relational programming is faster than **OOP**"", not ""Why functional relational programming is faster than Java when the latter is used with the lowest-level programming style possible"".",0.0,java
14vvgnw,jrimmwg,"Although I'm not sure the latter is not true, I haven't tried but I don't think Java is the ideal implementation language for data oriented design and the ECS architecture.",0.11875000000000001,java
14vvgnw,jrhcq6s,"C# has some specific advantages in the doesn’t-always-have-to-box area, which Java will match in a year or two with a similar capability.",0.0,c
14vvgnw,jrhcq6s,"C# has some specific advantages in the doesn’t-always-have-to-box area, which Java will match in a year or two with a similar capability.",0.0,java
14vvgnw,jrhcq6s,Otherwise Java tends to be a bit faster with long running applications.,-0.05,java
14vvgnw,jrinedu,"The hand-written Java code used in the comparison is indeed written in an OOP style, but why do you think that's a terrible implementation?",-1.0,java
14vvgnw,jrinedu,Isn't that the natural  thing to do when programming in Java?,0.1,java
14vvgnw,jrinedu,When Java was first released (in 1995) OOP was all the rage and nobody was even talking about data oriented design and the Entity/Component/System architecture.,0.25,java
14vvgnw,jrhlk79,"This looks to have more details:  https://www.cell-lang.net/benchmarks-relational.html  Based on that page, they are comparing to the Cell via C++.",0.5,c++
14vvgnw,jrhlk79,"That said, towards the bottom they have a comparison of Vell embedded in Java to Cell via C++.",0.0,java
14vvgnw,jrhlk79,"That said, towards the bottom they have a comparison of Vell embedded in Java to Cell via C++.",0.0,c++
14vvgnw,jrhlk79,Generally speaking the java version looks to be about 6% slower than the C++ version specifically for the CSV test (though it can be much slower than that for specific examples).,0.08333333333333333,java
14vvgnw,jrhlk79,Generally speaking the java version looks to be about 6% slower than the C++ version specifically for the CSV test (though it can be much slower than that for specific examples).,0.08333333333333333,c++
14vvgnw,jrhlk79,So it still would be a lot faster than their OOP java code.,0.0,java
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,go
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,java
14vvgnw,jripx0m,"On the speed up end, go natively run significantly faster than Java for the “same” code, so does C++, and converting or rewriting Java verbatim to C++ is a standard speed up practice.",0.125,c++
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,scala
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,java
14vvgnw,jripx0m,"Even Databricks rewrite Spark scala (btw, fully functional cousin of Java) to C++ internally to double their speed.",0.0,c++
14vvgnw,jripx0m,The thing that stops you from doing it and the reason people use Java the first place is the platform agnostic property of JVM.,0.25,java
14vvgnw,jripx0m,"Python or JS cannot be easily complied to C++ because they are interpretative; I don’t know any good way it can be done, and if someone manage to create a good compiler many will be using it.",0.5833333333333333,python
14vvgnw,jripx0m,"Python or JS cannot be easily complied to C++ because they are interpretative; I don’t know any good way it can be done, and if someone manage to create a good compiler many will be using it.",0.5833333333333333,c++
14vvgnw,jrosmiv,It seems to matter how the programs are written ;-)  Do the fastest C# programs use hand-written vector instructions?,0.25,c
14vvgnw,jrh45ei,Edit: The Rust Book has a fairly decent quick discussion of the different stances: https://doc.rust-lang.org/book/ch17-01-what-is-oo.html,0.16666666666666666,rust
14vvgnw,jrh4clv,"I recently learned that Erlang evidently doesn't formally comply to the original idea, and was like wait what?",0.20833333333333334,erlang
14vvgnw,jrhnh9s,Being in a language like Java doesn't mean you need to use tons of OOP features.,-0.3125,java
14vvgnw,jrjdj1x,"Was just using the same wording from the poster before me to note why the OOP java version would be ""terrible"".",-0.5,java
14vvgnw,jrip26t,"No, the difference in performance between the generated C++ and Java code is much larger than that.",0.0,c++
14vvgnw,jrip26t,"No, the difference in performance between the generated C++ and Java code is much larger than that.",0.0,java
14vvgnw,jrip26t,Java makes a terrible compilation target for a language like Cell.,-1.0,java
14vvgnw,jrip26t,"The generated Java code is still competitive with hand-written OO Java code, sometimes faster, sometimes slower, but trying to compile Cell into Java (or C#) code in like trying to fit a round peg in a square hole.",0.1,java
14vvgnw,jrip26t,"The generated Java code is still competitive with hand-written OO Java code, sometimes faster, sometimes slower, but trying to compile Cell into Java (or C#) code in like trying to fit a round peg in a square hole.",0.1,c
14vvgnw,jrip26t,The C++ code generator is more recent and has been redesigned from the ground up to achieve better performance.,0.3333333333333333,c++
14vvgnw,jrip26t,At least some of that work could be backported to the Java version.,-0.3,java
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,c++
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,java
14vvgnw,jrndlwg,"In the former case, you compile Cell to C++ (or Java, or C#), and then compile the generated file to produce your executable.",0.0,c
14vvgnw,jrndlwg,"You have to go to that extra step of compiling to an intermediate language, but the end result is the same, you end up with a standalone executable without having to write anything other than Cell code.",-0.041666666666666664,go
14vvgnw,jrndlwg,"As for Go being significantly faster than Java, I just looked at ***The Computer Language Benchmarks Game***, and that doesn't seem to be the case: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html).",-0.25833333333333336,go
14vvgnw,jrndlwg,"As for Go being significantly faster than Java, I just looked at ***The Computer Language Benchmarks Game***, and that doesn't seem to be the case: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go.html).",-0.25833333333333336,java
14vvgnw,jrndlwg,"Go seems to be slightly faster than Java in most (but not all tests), but the difference is really minimal.",0.07777777777777779,go
14vvgnw,jrndlwg,"Go seems to be slightly faster than Java in most (but not all tests), but the difference is really minimal.",0.07777777777777779,java
14vvgnw,jrndlwg,"Although Go seems to have improved lately, the last time I checked (a few years ago) Java was clearly faster, and I've to admit I wasn't aware of Go's improvements.",-0.029999999999999992,go
14vvgnw,jrndlwg,"Although Go seems to have improved lately, the last time I checked (a few years ago) Java was clearly faster, and I've to admit I wasn't aware of Go's improvements.",-0.029999999999999992,java
14vvgnw,jrndlwg,"But now I'm curious, I'm going to rewrite the benchmarks in Go and see what happens.",-0.1,go
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,go
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,c
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,java
14vvgnw,jrndlwg,"And Go seems to be a bit slower than C#, if you take The Computer Language Benchmarks Game results at face value: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-csharpcore.html  As for rewriting  Java code to C++: yes, it does improve performance, no question about that.",-0.4,c++
14vvgnw,jrndlwg,"I'm not aware of a tool that can automatically convert, say, non-trivial Java code into equivalent C++ and produce a significant speedup.",0.125,java
14vvgnw,jrndlwg,"I'm not aware of a tool that can automatically convert, say, non-trivial Java code into equivalent C++ and produce a significant speedup.",0.125,c++
14vvgnw,jrndlwg,"I even tried a couple of native compilers for Java, and they were actually slower than the JVM.",0.0,java
14vvgnw,jrndlwg,"In the Java and C# version of the benchmark I didn't follow the principle of encapsulation religiously, but only because it was irrelevant to what I was interested in, which is performance.",-0.0625,java
14vvgnw,jrndlwg,"In the Java and C# version of the benchmark I didn't follow the principle of encapsulation religiously, but only because it was irrelevant to what I was interested in, which is performance.",-0.0625,c
14vvgnw,jrmbpfx,"Erlang processes really are quite similar, from an intuitive perspective, to actors: They represent a distinct thread of control and communicate by asynchronous messages.",0.16666666666666666,erlang
14vvgnw,jrmbpfx,"First, Erlang apparently has a process registry that lets you look up a PID.",0.15,erlang
14vvgnw,jrmbpfx,"In principle you could simulate a registry with actor messages, but in Erlang it's part of the semantics.",0.0,erlang
14vvgnw,jrmbpfx,"Second, Erlang has selective receive, which lets you process messages in the order you care about them and save the rest for later.",0.0,erlang
14vvgnw,jrmbpfx,"The last difference is that crashing is not one of the three things actors are theoretically allowed to do, which means that Hewitt doesn't define any sort of supervisory tree the way Erlang does.",0.0,erlang
14vvgnw,jrmbpfx,"On that front, Erlang seems superior for at least thinking about robustness in the face of failure.",0.027777777777777752,erlang
14vvgnw,jrhq2gg,Most Java programs are not performance critical and most devs rightfully don’t care about speed when weighed against readability and potential for reuse.,0.25,java
14vvgnw,jrhq2gg,When speed is required though there are many Java programs properly optimized to be fast and have better memory footprint.,0.3,java
14vvgnw,jrhq2gg,Since the compiler here specially optimize for performance when it generates the code and care not about readability it is only fair to compare with another Java program that is also written to optimize for performance.,0.3523809523809524,java
14vvgnw,jrnt3xh,You are for sure right that automatic Java to C++ converter has uneven performance.,0.1952380952380952,java
14vvgnw,jrnt3xh,You are for sure right that automatic Java to C++ converter has uneven performance.,0.1952380952380952,c++
14vvgnw,jrnt3xh,Our own rewrite test on Go was actually even slightly faster than C++ but it could be many factors at play.,0.23333333333333334,go
14vvgnw,jrnt3xh,Our own rewrite test on Go was actually even slightly faster than C++ but it could be many factors at play.,0.23333333333333334,c++
14vvgnw,jrnt3xh,"It was harder to get devs and libraries are insufficient, so we went for C++ anyways.",-0.1,c++
14vvgnw,jrnt3xh,"Maybe I am biased because I looked at Java and scala before and scala tends to be slightly slower, so I had preformed opinion that was hard to change.",-0.22916666666666669,java
14vvgnw,jrnt3xh,"Maybe I am biased because I looked at Java and scala before and scala tends to be slightly slower, so I had preformed opinion that was hard to change.",-0.22916666666666669,scala
14vvgnw,jripulv,That sounds like the first definition the Rust Book discusses.,0.25,rust
14vvgnw,jrhr0h5,"Could lead to better results with less work and more readability (when looking at the cell code, not transpiled java).",0.2777777777777778,java
14vvgnw,jrjm71q,"Both are for reducing cognitive load, and can be used for optimizations, but go about it different ways.",0.0,go
14vvgnw,jrpfs4q,"I'm gonna be honest, I don't think a deep dive into the concept of identity would benefit anyone in the context the rust book is discussing them.",0.3,rust
14vvgnw,jrjmua8,"So no, that's *not OOP*, not the way Simula, Java and C++ see it.",0.0,java
14vvgnw,jrjmua8,"So no, that's *not OOP*, not the way Simula, Java and C++ see it.",0.0,c++
14vvgnw,jrjmua8,It just happened that the benefits of this approach are most obvious to people working in C++ - a language that suffered from the OOP craze badly.,-0.06666666666666661,c++
14vvgnw,jrjttde,"Or if you think OOP is that generalized, that's cool too.",0.35,cool
14vvgnw,jrjpx4s,"Sure if you're learning C, then it makes sense to learn about what's happening in memory, but if you're learning a higher level language of a different paradigm, talking about what happens in the machine may undermine their understanding.",0.25,c
14vvgnw,jrpvp8s,"message passing (hence ""what I called 'objects'""), versus the more common modern C++ take of ADTs.",0.13333333333333333,c++
14vm3kw,,"I have played with Rust, Nim, Zig, Go and saw that none of them use classes (they have their own way to define something similar to an interface though).",0.3,rust
14vm3kw,,"I have played with Rust, Nim, Zig, Go and saw that none of them use classes (they have their own way to define something similar to an interface though).",0.3,go
14vm3kw,jreyzx5,in TypeScript a class can `implements` another class.,0.0,typescript
14vm3kw,jreyzx5,"Rust where any type can implement a trait, in some OOP languages you can't implement interfaces for non-class types - A class is a container for data    - ex.",0.0,rust
14vm3kw,jreyzx5,"""dataclass"" in Python - A class is a mechanism to protect data from other classes (note: **not** other objects.",-0.03125,python
14vm3kw,jrevmsn,"Most of the good parts of object-oriented programming can be accomplished or done better with modules, functions as first-class values, and Rust traits (or, better yet, Haskell type classes).",0.48,rust
14vm3kw,jrevmsn,"Most of the good parts of object-oriented programming can be accomplished or done better with modules, functions as first-class values, and Rust traits (or, better yet, Haskell type classes).",0.48,haskell
14vm3kw,jrevmsn,"If you care about an interface, use an interface (a Rust trait).",0.0,rust
14vm3kw,jrgn3dk,When Java added closures (it sort of had something like it already with anonymous inner classes) different ways of composing stuff together other than inheritance became much more palatable.,0.09375,java
14vm3kw,jrgn3dk,"So my thesis is that closures, dependency injection, design for test, and possibly performance improvements in compilers/run-time for higher order programming may have played a big part on the Java side in the move away from inheritance based abstraction.",0.08333333333333333,java
14vm3kw,jrgn3dk,I think a similar story may be true for C++.,0.175,c++
14vm3kw,jrgn3dk,"Java debuggers are much better now so maybe single stepping would work for less complex scenarios but if it isn't readable like a book, the code isn't as readable as it could be.",-0.009523809523809504,java
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,java
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,c
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,python
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,javascript
14vm3kw,jrqn7d7,"There are a lot of recent, popular languages with classes (and specifically inheritance-based object polymorphism)  Languages like Java, C#, Python, JavaScript*, or Ruby are dominating the ""market share"" of productive tools for the jobs they're doing today, and a lot of the investments in the space are riffs on these languages.",0.3,ruby
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,typescript
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,kotlin
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,scala
14vm3kw,jrqn7d7,"Some young/popular/buzzy OO languages: TypeScript*, Kotlin, Scala, Mojo, Crystal, ...",0.0,crystal
14vm3kw,jrqn7d7,"Swift, too, it's only one year older than Rust.",0.08333333333333333,swift
14vm3kw,jrqn7d7,"Swift, too, it's only one year older than Rust.",0.08333333333333333,rust
14vm3kw,jrncoii,"That will have a headache, (even though my live is Elixir, and Erlang), if that will be pushed to be used everywhere, I would start to hate it as well.",-0.33181818181818185,elixir
14vm3kw,jrncoii,"That will have a headache, (even though my live is Elixir, and Erlang), if that will be pushed to be used everywhere, I would start to hate it as well.",-0.33181818181818185,erlang
14vm3kw,jrf2nx0,Rust has classes.,0.0,rust
14vm3kw,jrf902s,"Decoupling data from logic and java, c++ classes falling out of favour.",0.0,java
14vm3kw,jrf902s,"Decoupling data from logic and java, c++ classes falling out of favour.",0.0,c++
14vm3kw,jricwsa,"When I think about such topics, I always look at how it is with Rust, and I always say: okay, that's the way.",0.25,rust
14vm3kw,jricwsa,"With Rust, you can define *methods* for your *struct*, so it's basic OOP, encapsulation is supported.",0.0,rust
14vm3kw,jrnbhq6,"If you take away inheritance than a Java style class is really just a namespace with polymorphism, and parametric polymorphism (ie generics in arguments or functions) is possible without classes.",0.1,java
14vm3kw,jrgkd6x,In Java Style OOP the only mechanism for reuse and encapsulation is inheritance.,0.0,java
14vm3kw,jrgkd6x,is that Java’s OOP became popular to a large part due to the relatively easy implementation via virtual function tables.,0.2806547619047619,java
14vm3kw,jrhionm,I would argue that go does have classes.,0.0,go
14vm3kw,jrhionm,Go packages even look like classes.,0.0,go
14vm3kw,jrhionm,Your knowledge would be a great help  Do what you want but you can't ignore the fact that the vast majority of code in production today is written either in java or C#.,0.4,java
14vm3kw,jrhionm,Your knowledge would be a great help  Do what you want but you can't ignore the fact that the vast majority of code in production today is written either in java or C#.,0.4,c
14vm3kw,jrg6e5q,"A notable counter-example would be Kotlin, an OOP language presumably made by people who weren't satisfied with Java.",0.5,kotlin
14vm3kw,jrg6e5q,"A notable counter-example would be Kotlin, an OOP language presumably made by people who weren't satisfied with Java.",0.5,java
14vm3kw,jrg6e5q,Although the class-based design of Kotlin is still likely influenced by what is convenient to implement on the JVM.,0.0,kotlin
14vm3kw,jrhwj1w,people who program in C++ are busy endlessly fighting with templates and implicit behavior.,-0.012499999999999997,c++
14vm3kw,jrhzbr2,A class is a Pascal record type with functions glued on … ?,0.0,pascal
14vm3kw,jrfgeoy,It reminds me of JavaScript and similar languages where you are/were required to construct your own classes by hand (an extra boilerplate).,0.125,javascript
14vm3kw,jrf2kjh,I don't think structures as in Rust are the same as classes in Java except data inheritance.,0.0,rust
14vm3kw,jrf2kjh,I don't think structures as in Rust are the same as classes in Java except data inheritance.,0.0,java
14vm3kw,jrf2kjh,"The point of classes is that one is able to tie data and behaviour together, whereas this is the thing Rust is trying to avoid by having strictly separate `struct` and `impl` blocks, which can be located in different files and even crates (through traits).",0.25,rust
14vm3kw,jrewepg,"From the beginning, I was assuming that Rust doesn't implement OOP because of the lack of classes/inheritance (one of the four pillars of OOP).",0.0,rust
14vm3kw,jrewepg,I have read that somewhere on internet when I was trying to do OOP with rust.,0.0,rust
14vm3kw,jrewepg,For instance Rust have struct and Nim has object as product types (there are also tuples) that can implement stateful struct (Nim has also inheritance now that I remember),0.0,rust
14vm3kw,jrf1qlb,"> Rust traits (or, better yet, Haskell type classes).",0.5,rust
14vm3kw,jrf1qlb,"> Rust traits (or, better yet, Haskell type classes).",0.5,haskell
14vm3kw,jrf1qlb,How would Haskell type classes even work in a non-Haskell language?,0.0,haskell
14vm3kw,jrqzti4,"I was happy to know by discussing with other redditors there are still languages that implement classes in the classical way (Like Grace, Swift and Crystal you mentioned).",0.225,swift
14vm3kw,jrqzti4,"I was happy to know by discussing with other redditors there are still languages that implement classes in the classical way (Like Grace, Swift and Crystal you mentioned).",0.225,crystal
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,typescript
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,kotlin
14vm3kw,jrqzti4,"My fear was that languages like TypeScript, kotlin, Scala and Mojo OOP where only built for backward compatilility's sake.",0.0,scala
14vm3kw,jrh0m5g,That's sooo cool!,0.4375,cool
14vm3kw,jrijv8t,We can achieve structural subtyping with union type (maybe with sum types like options in rust ?,0.0,rust
14vm3kw,jrg1bfq,I agree that there are trends (especially for javascript frameworks).,0.0,javascript
14vm3kw,jrh8sjc,> In Java Style OOP the only mechanism for reuse and encapsulation is inheritance.,0.0,java
14vm3kw,jrglmfv,I also think that Java recieve a big boost throught promotions made to organizations (which facilitate it's adoption).,0.0,java
14vm3kw,jrih3g3,I saw that CLOS (Common Lisp Object System) don't follow the classical definition of class/hineritance we see in other OO languages.,-0.14166666666666666,lisp
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,go
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,java
14vm3kw,jriizd3,Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,c
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,java
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,c
14vm3kw,jriizd3,"In Pony, you can define classes in the classical way but can't do inheritance: https://tutorial.ponylang.io/types/classes.html#constructors  There is the Grace language that use class/inheritance faithfully  it's implementation and implications are discussed here: https://pdxscholar.library.pdx.edu/cgi/viewcontent.cgi?article=1180&context=compsci_fac  I agree with you, Java and C# aren't going anywere because there are a huge quantity of code to maintain (like COBOL).",0.20000000000000004,cobol
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,kotlin
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,go
14vm3kw,jriizd3,"But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,rust
14vm3kw,jrgdwf8,"Not just convenient to implement, but also compatible with the Java ecosystem.",0.0,java
14vm3kw,jri19oj,"If it requires inheritance in the Java style, i.e.",0.0,java
14vm3kw,jrfl7du,"In the TypeScript example below, `BThing` is a subtype of `AThing`.",0.0,typescript
14vm3kw,jrf9xra,"No matter where the methods are defined in Rust, the behavior is still tied to the underlying data.",0.0,rust
14vm3kw,jrf9xra,When you write:  ``` dog.bark(); ```  there's no difference between Rust and Java.,0.0,rust
14vm3kw,jrf9xra,When you write:  ``` dog.bark(); ```  there's no difference between Rust and Java.,0.0,java
14vm3kw,jrh5zkf,"""Haskell type classes"" are just type classes as implemented in Haskell.",0.0,haskell
14vm3kw,jrh5zkf,"Type classes can be implemented in other languages such as ML, Scala, or C++20.",-0.0625,scala
14vm3kw,jrh5zkf,Rust traits specifically don't provide higher kinded types.,0.25,rust
14vm3kw,jri21l6,"In Java in particular, pretty much anything you can do with inheritance, you can do with interfaces and delegation.",0.20555555555555557,java
14vm3kw,jrihdbx,There are [many cool and awesome languages](https://github.com/ChessMax/awesome-programming-languages) out there...,0.6166666666666667,cool
14vm3kw,jrngvd0,"I've never heard the term nominal inheritance, so I may be misunderstanding, if you're talking about typescript interfaces then I don't really see how that's different from normal inheritance.",0.11666666666666665,typescript
14vm3kw,jrg3fyc,"The ""Multiparadigm Programming Toolbox"" 🧰🛠️  BTW I started learning programming with line numbered basic and like OOP for a lot of stuff, and now people tell me to go back ?",0.0,go
14vm3kw,jrik91b,"Ad-hoc polymorphism is achieved using methods on generic functions, with methods specialised on all arguments, rather than methods on objects; I can only think of Dylan and Julia being influenced by the generic function model.",0.0,julia
14vm3kw,jrik91b,an abstract class in Java).,0.0,java
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,go
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,java
14vm3kw,jrl2se8,>Go can do OOP but what surprised me is the fact there is no class in the classical way (like Java ans C#).,0.05,c
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,kotlin
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,go
14vm3kw,jrl2se8,"> But new languages like Kotlin, Go, Rust, etc.",0.13636363636363635,rust
14vm3kw,jrl2se8,Will be used for new projects  Kotlin has inheritance so does Go as I pointed out.,0.13636363636363635,kotlin
14vm3kw,jrl2se8,Will be used for new projects  Kotlin has inheritance so does Go as I pointed out.,0.13636363636363635,go
14vm3kw,jrg0lxv,"So if I understand, in Typescript, objects are a kind of product type whose member behave like a union types.",0.6,typescript
14vm3kw,jrg0lxv,I also think that interfaces (for instance traits in rust) can define behavioral super types.,0.3333333333333333,rust
14vm3kw,jrhr59d,"Classes just describe objects, metaclasses describe classes, and so forth up the chain of meta-abstractions.",0.0,forth
14vm3kw,jrgmssd,"> No matter where the methods are defined in Rust, the behavior is still tied to the underlying data.",0.0,rust
14vm3kw,jrgmssd,"In Java, the visibility is tied to the type (class) whereas in Rust the visibility is tied to the module.",0.0,java
14vm3kw,jrgmssd,"In Java, the visibility is tied to the type (class) whereas in Rust the visibility is tied to the module.",0.0,rust
14vm3kw,jrfbjwd,"The dot syntax in Rust is a syntax sugar for the full syntax `T::f` or `<T as I>::f`, where `f` is a function taking `self` as the first argument.",0.3,rust
14vm3kw,jrfbjwd,"In Java, methods are bound to data because you necessarily need an object to call methods upon, unless I'm missing some trick to bypass that.",-0.1,java
14vm3kw,jrfcdll,"There are no ""higher-kinded type classes"" in Haskell; there are higher-kinded types.",0.0,haskell
14vm3kw,jrnkluj,"For instance, in Rust, one trait B can extends an other trait A.",-0.125,rust
14vm3kw,jrgc9k3,"In recent languages, all those 3 concepts are separated (for instance in rust we have struct, traits and generics) and we have the choice to make composition.",0.0,rust
14vm3kw,jrlcrg7,"As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,kotlin
14vm3kw,jrlcrg7,"As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,java
14vm3kw,jrgbss4,"[TypeScript playground link](https://www.typescriptlang.org/play?#code/FAb2wAgh6aIQQCoAsCWA7A5hVBnCAhhLgK4BGALgJ4AOAphAPYBmEAQihppDHAO7I6AJwYc0WHPgIBjaXRoU6AEwA0xRpIScsPavS3jsAXmIUhXXbVHbjp8xIA+EdCQC2ZYeCjMS6aRVRGdBwAOTplJEMAChoCIQJXAC4DLgBKCBAAXy8IABs6CggyG2SxLggTACJBXNzGSsJ8Mp0eWAQhTDc6dEKWCD0GAHJmzEHNdEZCglxcVEx0AjJ8-o1Y+NcC4SZWAYhByK5BgDoeVDCImyjiw1TwbNActpHNIlJKK22UnSg2gWEGA4SPCEWTyRSqdSaEaWfSA2y4MzlJwudyeKC7Z4mBH2bg8Hx+AJBULhJRwmJxBLJOHpLI5fKFa5cUo2CoQap0Wr1RrsGyPOAAeQA0qdzqTLoysLdgNkgA)      // BThing is a subtype of AThing     // where AThing is accepted, so is BThing     type AThing = string | number     type BThing = string  Yes, interfaces can also have a subtype relationship.",0.0,typescript
14vm3kw,jrgbss4,"For example in Java, an interface can `extends` another interface.",0.0,java
14vm3kw,jrgbss4,Rust also has trait subtyping.,0.0,rust
14vm3kw,jris11n,"If you implement something like this in, say, C, you may have come up with an OO design but that does not make C an OO language.",0.0,c
14vm3kw,jrfhu39,Python.,0.0,python
14vm3kw,jrfe9yn,This is exactly how C++ implements class methods.,0.25,c++
14vm3kw,jrfe9yn,Rust isn't doing anything different here.,0.0,rust
14vm3kw,jrfe9yn,What makes Rust different is the ergonomics of `impl` blocks and the flexibility of type classes.,0.0,rust
14vm3kw,jrgcbem,Rust currently doesn’t have this; only a type can implement a trait.,0.0,rust
14vm3kw,jrnoz46,The foundation of Rust is based off of OCaml and it takes all of its best traits.,1.0,rust
14vm3kw,jrnoz46,"I don't love Rust because the slow compilation just makes it really hard to enjoy, if it was faster than I would.",0.07708333333333332,rust
14vm3kw,jrn1jam,In go all you need to do is to have your function accept an interface and when you do that both structs fit that interface and they can be used interchangeably.,0.4,go
14vm3kw,jrn1jam,">As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,kotlin
14vm3kw,jrn1jam,">As you mentioned it, Kotlin can use classical OOP (for interoperability with java and the JVM) but can also work with FP and ADT without the base class functionality.",-0.4,java
14vm3kw,jrn1jam,Only in go.,0.0,go
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,go
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,java
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,c
14vm3kw,jrn1jam,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,ruby
14vm3kw,jrn1jam,Rust doesn't.,0.0,rust
14vm3kw,jrn1jam,>I juste want to avoid being weird if I don't implement classes with classical inheritance  Have you ever programmed in ruby?,-0.25,ruby
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,c++
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,java
14vm3kw,jrfeyl8,"I'm not aware of the C++ stuff however, but the thing is that in Java it's bundled to the object, whereas in Rust, the `self` parameter has the same status as all other parameters.",-0.08333333333333333,rust
14vm3kw,jrfx4wk,"Rust and C++ implement ""objects"" very differently.",0.0,rust
14vm3kw,jrfx4wk,"Rust and C++ implement ""objects"" very differently.",0.0,c++
14vm3kw,jrfx4wk,"Rust determines what function to call at compile time, this is not (necessarily) true for C++.",-0.175,rust
14vm3kw,jrfx4wk,"Rust determines what function to call at compile time, this is not (necessarily) true for C++.",-0.175,c++
14vm3kw,jrfx4wk,C++ has a very different implementation using [vtables](https://en.wikipedia.org/wiki/Virtual_method_table).,0.0,c++
14vm3kw,jrfx4wk,"In simple cases, C++ method call dispatch can be optimized at compiled time, thus resulting in a similar outcome to rust, but this is not the norm.",0.0,c++
14vm3kw,jrfx4wk,"In simple cases, C++ method call dispatch can be optimized at compiled time, thus resulting in a similar outcome to rust, but this is not the norm.",0.0,rust
14vm3kw,jrfzbpr,"It has associated functions (albeit namespaced a bit weirdly, but that's just a C quirk, right?",-0.10714285714285715,c
14vm3kw,jrfzbpr,"Yes, you technically call them as free functions, but that's how Rust and C++ work under the hood, so is there really any semantic difference?",0.20000000000000004,rust
14vm3kw,jrfzbpr,"Yes, you technically call them as free functions, but that's how Rust and C++ work under the hood, so is there really any semantic difference?",0.20000000000000004,c++
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,c
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,rust
14vm3kw,jrfzbpr,"To a certain extent, I would see the difference between C and Rust here as being more superficial than the difference between Rust and Java.",0.35714285714285715,java
14vm3kw,jrgiozk,"At least in the C# implementation of a partial class (part of the issue of all this terminology is there is no mathematical or robust definition of a `class`, so we need to specify which language's interpretation of a `class` we mean).",-0.178125,c
14vm3kw,jrgiozk,A partial class can almost be thought of as a purely syntactic concatenation of two files (almost like a C #include directive).,0.057142857142857134,c
14vm3kw,jrgiozk,"In Rust, visibility/encapsulation is determined by the **module**, not the type.",0.0,rust
14vm3kw,jrgiozk,The same rules of visibility apply to these functions just like any other kind of entity in Rust.,0.15833333333333333,rust
14vm3kw,jrneuzy,I will definitely try ruby one day!,0.0,ruby
14vm3kw,jrneuzy,Classes that come from Java and C# have their own way of working (This is how a learned OOP by the way).,0.6,java
14vm3kw,jrneuzy,Classes that come from Java and C# have their own way of working (This is how a learned OOP by the way).,0.6,c
14vm3kw,jrneuzy,"&#x200B;  In this case, I was talking about new languages (like kotlin) that are used to create new projects against older ones  (like java) that that are mainly used to maintain existing projects.",0.1515151515151515,kotlin
14vm3kw,jrneuzy,"&#x200B;  In this case, I was talking about new languages (like kotlin) that are used to create new projects against older ones  (like java) that that are mainly used to maintain existing projects.",0.1515151515151515,java
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,java
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,c
14vm3kw,jrneuzy,"My point isn't that it doesn't have inheritance but that it allow the user to work without class (in Java or C# you can't ""Hello world"" without a class)  &#x200B;  >Only in go.",0.0,go
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,go
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,java
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,c
14vm3kw,jrneuzy,"Go is object oriented and supports inheritance like Java, C#, Ruby etc does.",0.0,ruby
14vm3kw,jrneuzy,Rust doesn't.,0.0,rust
14vm3kw,jrneuzy,Rust is rigid in this point (I don't know if it's because of safety or to create a sound type system).,0.4,rust
14vm3kw,jrit5f3,OP asked why languages lie Rust don’t have classes.,0.0,rust
14vm3kw,jrfhehb,"But I concede that Rust makes it *easier* to seperate data and impl, and Java makes *conflation* the happy path.",0.8,rust
14vm3kw,jrfhehb,"But I concede that Rust makes it *easier* to seperate data and impl, and Java makes *conflation* the happy path.",0.8,java
14vm3kw,jrilbyx,"Without inheritance, C++ does compile-time dispatch.",0.0,c++
14vm3kw,jrilbyx,"For trait objects (boxed), Rust does runtime dispatch, pretty sure with vtables.",0.375,rust
14vm3kw,jrghbx7,"~~C is fundamentally different from Java & Rust, because it has no private members.",0.0,java
14vm3kw,jrghbx7,"~~C is fundamentally different from Java & Rust, because it has no private members.",0.0,rust
14vm3kw,jrghbx7,"Languages like Haskell not, because of immutability and lack of side effects.",0.0,haskell
14vm3kw,jrghbx7,Rust & Java allow arbitrary side effects and mutation of their associated instance.,-0.1,rust
14vm3kw,jrghbx7,Rust & Java allow arbitrary side effects and mutation of their associated instance.,-0.1,java
14vm3kw,jrhp47u,"I'm not very familiar with Rust, I hoped that comparing to C# would help me understand.",-0.14423076923076922,rust
14vm3kw,jrhp47u,"I'm not very familiar with Rust, I hoped that comparing to C# would help me understand.",-0.14423076923076922,c
14vm3kw,jrnkai4,>Other language can combine tools to mimic it's capabilities but they don't have a single unit that behave exactly as a class (because it seems more beneficial to split it's capabilities for specific use case)  As I pointed out except go which has proper inheritance.,0.13571428571428573,go
14vm3kw,jrflnf1,"Yes, you can perhaps imitate the Rust's behaviour with static methods (modulo syntax), but that wouldn't be in the nature of Java for sure.",0.5,rust
14vm3kw,jrflnf1,"Yes, you can perhaps imitate the Rust's behaviour with static methods (modulo syntax), but that wouldn't be in the nature of Java for sure.",0.5,java
14vm3kw,jrnig92,"Like Rust or Go, methods are defined separately of data structures.",0.0,rust
14vm3kw,jrnig92,"Like Rust or Go, methods are defined separately of data structures.",0.0,go
14vm3kw,jrns1wd,I have visited the official [FAQ for Go](https://go.dev/doc/faq) and they stated that they don't implement type/data inheritance.,0.0,go
14vm3kw,jrnjz4i,"Nim is pretty cool, and I'm a big fan of UFCS.",0.19999999999999998,cool
14vm3kw,jrnjz4i,You can also look at D for another example.,0.0,d
14vm3kw,jrnw34p,I have visited the official FAQ for Go and they stated that they don't implement type/data inheritance.,0.0,go
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,c++
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,javascript
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,rust
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,go
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,scala
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,kotlin
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,julia
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,elixir
14vm3kw,jro13ss,"There are concepts like:  \- Pure functions and idempotence- Side effects- Function composition- Shared state and immutable data  During the last years, we had some languages that have now a better implementation of FP (like C++,  Javascript) and some languages that were meant to do easier FP like Rust, Go, Nim, Scala, Kotlin, Julia, Elixir, Typescript.",0.11607142857142858,typescript
14vm3kw,jro13ss,But it shows that Go use the type embedding (among other methods like traits or mixins or protocols) to mitigate this drawback.,-0.125,go
14vm3kw,jro13ss,TBH I am more in favor of the Go type embedding,0.5,go
14vbyy3,,"Well and good: the model is turtles all the way down, just like Lisp's eval/apply.",0.2722222222222222,lisp
14vbyy3,jrcq0mr,IIRC Cloud Haskell embeds actors in a lazy language.,-0.25,haskell
14vbyy3,jrd0nrv,Cloud Haskell ...,0.0,haskell
14vbyy3,jrd0nrv,"Cloud Haskell decrees that *because Haskell,* messages happen in a monad, which is no surprise.",0.0,haskell
14vbyy3,jrd0nrv,Gymnastics in section 3 deal with Haskell not being anything like Erlang.,0.0,haskell
14vbyy3,jrd0nrv,Gymnastics in section 3 deal with Haskell not being anything like Erlang.,0.0,erlang
14vbyy3,jrg9ge5,"If you evaluate code with the side effect of creating an actor, then you go from a world in which the actor exists N times to a world in which the actor exists N+1 times.",0.0,go
14vbyy3,jrvj8iz,And I'm digging through that as I go.,0.0,go
14vbyy3,jrmnwdd,"It might not be exactly how Haskell implementations work on the inside, but you can think of an entire Haskell program's evaluation as being driven by the *need* for that outside-world resulting from all the I/O actions they perform, in order as determined by their functional dependencies embedded in all that monadic fancy footwork that do-notation desugars into.",0.125,haskell
14vbyy3,jrmnwdd,And Haskell's way of saying that is wrapped up in its relationship with the I/O monad.,0.0,haskell
14va6m9,jrdskmq,And I decided long ago that the best use of my time is to just work on improving Haskell tooling.,0.475,haskell
14va6m9,jre41jj,I would say don't make the same [naming mistake](https://news.ycombinator.com/item?id=9527659) as rust.,0.0,rust
14va6m9,jre41jj,enums in C and many other languages only allow \`[atoms](https://langdev.stackexchange.com/questions/1970/what-is-the-type-and-correct-name-of-a-member-of-an-enumeration/1971#1971)\` to be values with the same underlying simple type.,0.075,c
14va6m9,jre41jj,Having the type representation do both jobs is good but for reasons unknown they chose to name their construct after the less general concept (a C stlye enum) rather than the more general one (a discriminated union).,0.17222222222222225,c
14va6m9,jre41jj,The type representation being (using Haskell like syntax)  data union = typeA | typeB | typeC,0.0,haskell
14va6m9,jrfqag8,I wonder if Swift checks all the boxes...,0.0,swift
14va6m9,jrdnkdj,"I’ve used macros in Lisp-like languages and the preprocesser in C extensively, but felt like it was a feature I could live without, so I left it off the list.",0.04545454545454545,c
14va6m9,jrdnkdj,"This is cool, and it’s fun to take advantage of Lisp’s syntax to do so, but I’ve always felt like code that relies too much on macros becomes difficult to reason about.",0.08749999999999997,cool
14va6m9,jrdnkdj,"This is cool, and it’s fun to take advantage of Lisp’s syntax to do so, but I’ve always felt like code that relies too much on macros becomes difficult to reason about.",0.08749999999999997,lisp
14va6m9,jrdnkdj,"In C, I see the preprocessor as mainly used for performance, debug flagging, higher order programming, and generics.",0.20833333333333331,c
14va6m9,jre5wni,"Enums in C carry tags, but no data.",0.0,c
14va6m9,jre5wni,"Unions in C carry data, but no tags.",0.0,c
14va6m9,jre5wni,"Rust ADTs carry both (or one, or neither).",0.0,rust
14va6m9,jre5wni,"Swift did too, so the small amount of emerging consensus as to what to call ADTs in C-like languages is nice.",0.175,swift
14va6m9,jrgjx3o,"It might, though I’ve never used Swift as I’m outside the Apple development world.",0.0,swift
14va6m9,jre7cjk,"I agree with concensus arguments in general but:  That is a concensus from two languages only - rust and swift  I don't think its even quite true of swift which [has several levels](https://developer.apple.com/documentation/swift/rawrepresentable) \-    enum, rawrepresentation and  optionset but has been criticised for the [same unfortunate naming choice](https://news.ycombinator.com/item?id=16390702)     If you want consensus pick a name from the [wikipedia page](https://en.wikipedia.org/wiki/Tagged_union) which does not even mention enum.",-0.016666666666666663,rust
14va6m9,jre7cjk,"I agree with concensus arguments in general but:  That is a concensus from two languages only - rust and swift  I don't think its even quite true of swift which [has several levels](https://developer.apple.com/documentation/swift/rawrepresentable) \-    enum, rawrepresentation and  optionset but has been criticised for the [same unfortunate naming choice](https://news.ycombinator.com/item?id=16390702)     If you want consensus pick a name from the [wikipedia page](https://en.wikipedia.org/wiki/Tagged_union) which does not even mention enum.",-0.016666666666666663,swift
14v92v5,,And by dead I mean in *this* sense (from Monty Python's Parrot sketch):  >He's not pining!,-0.2953125,python
14v92v5,,"IN MEMORIAM  *Conceived in the spring of 2001 as a fusion of Perl and Python, Parrot, the illegitimate love child of Guido van Rossum and Larry Wall, was born as version 1.0 on 17.",0.5,perl
14v92v5,,"IN MEMORIAM  *Conceived in the spring of 2001 as a fusion of Perl and Python, Parrot, the illegitimate love child of Guido van Rossum and Larry Wall, was born as version 1.0 on 17.",0.5,python
14v92v5,jrcph68,"Imagine a Smalltalk with a good static type system (Griesemer introduced a similar one to Go), a highly optimized VM (Bak and Holze were the wizards behind V8), and an integration with the Web that was never fully realized.",0.19199999999999998,go
14v92v5,jrbpg3p,"The parent of Cobol, and child of assembly language.",0.0,cobol
14v92v5,jrbpg3p,"The parent of Cobol, and child of assembly language.",0.0,assembly
14v92v5,jrgdgdy,"You've heard of Ada, but nobody knows of Babbage.",0.0,ada
14v92v5,jrgdgdy,(Named after collaborators Ada Lovelace and Charles Babbage.),0.0,ada
14v92v5,jrbkpty,HyperCard  ActionScript,0.0,actionscript
14v92v5,jrcqcuy,"Eiffel, Oberon.",0.0,eiffel
14v92v5,jrccdbt,Pascal,0.0,pascal
14v92v5,jrdxe02,Eiffel.,0.0,eiffel
14v92v5,jrdlbs5,"Damn that is sad, sounds like a very cool mix of features.",-0.02250000000000002,cool
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,algol
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,pascal
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,ada
14v92v5,jrizauk,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal, with PLZ/SYS being a tiny simple language even a bit simpler than Pascal (and probably not too hard to recreate a compiler for from scratch - if I only knew the precise spec of the P-code it used), and CHILL being a language with features similar to Ada 83 or early C++.",0.08020833333333333,c++
14v92v5,jrc8bn8,Not sure about ActionScript.,-0.25,actionscript
14v92v5,jrdoys0,> ActionScript  Now you made me sad.,-0.5,actionscript
14v92v5,jrdoys0,"ActionScript was Flash's version of Javascript, based on the same ECMAScript standard, but *better*.",0.16666666666666666,actionscript
14v92v5,jrdoys0,"ActionScript was Flash's version of Javascript, based on the same ECMAScript standard, but *better*.",0.16666666666666666,javascript
14v92v5,jrc5m1y,> ActionScript  RIP - We had some good times,0.7,actionscript
14v92v5,jrdhmul,"Modula-3  I have a habit of picking the wrong horse, and was **so** chuffed to have picked a nice, clean GC'ed language with modules as my next language after C, instead of C++.",0.11666666666666667,c
14v92v5,jrdhmul,"Modula-3  I have a habit of picking the wrong horse, and was **so** chuffed to have picked a nice, clean GC'ed language with modules as my next language after C, instead of C++.",0.11666666666666667,c++
14v92v5,jrfmlnt,Eiffel's last update was a few months ago.,-0.1,eiffel
14v92v5,jrgm745,"I guess that came from MARY, a Norwegian Algol 68-""inspired"" language.",0.0,algol
14v92v5,jrdfy30,"Funny enough, I still use coffeescript because I find it cleaner (and more fun) than typescript.",0.2625,typescript
14v92v5,jrcds5r,Ansi pascal?,0.0,pascal
14v92v5,jrcds5r,"But object pascal versions are still alive, Delphi and other OSS like Free pascal and Lazarus.",0.125,pascal
14v92v5,jrcds5r,"But object pascal versions are still alive, Delphi and other OSS like Free pascal and Lazarus.",0.125,delphi
14v92v5,jrcds5r,And I would not be surprised if Pascal is still used as first language on some places,0.175,pascal
14v92v5,jrhmv4z,"I love OOSC as a book, and found Eiffel: The Language ""interesting"", but the new version was a more complex and less beautiful language.",0.2885281385281385,eiffel
14v92v5,jrhmv4z,"One thing that made me question Meyer's sincerity as a language developer was how in OOSC, he argued passionately that Eiffel had no case statement, because with OOP, it wasn't needed.",-0.05,eiffel
14v92v5,jrhmv4z,"Then in the next Eiffel version a case statement had been added, with no acknowledgement that the previous stance had been wrong.",-0.2222222222222222,eiffel
14v92v5,jrhmv4z,"I just now had a look at the EiffelStudio site, and it would seem that Eiffel is still alive.",0.1,eiffel
14v92v5,jrjebiz,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal,  There were a slew of PL/\* languages around the end of the 70s.",0.4333333333333333,algol
14v92v5,jrjebiz,"I think you might like them, both are strongly influenced by both Algol 68 and Pascal,  There were a slew of PL/\* languages around the end of the 70s.",0.4333333333333333,pascal
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,algol
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,pascal
14v92v5,jrjebiz,"My influences were Algol and Pascal from college, Fortran from work placements, and Algol68 from a book.",0.0,fortran
14v92v5,jrjebiz,"I did later buy a book about C, but I was unimpressed and sold it again (at quite a loss actually).",0.0,c
14v92v5,jrjebiz,"But then Fortran has changed a lot more, and it's still 'Fortran'.)",0.5,fortran
14v92v5,jru11ss,"They used actionscript for the UI on the Sims 4, so they're probably hiring someone to work on that.",0.0,actionscript
14v92v5,jru11ss,"It was a hodge podge of languages: Python for the AI/gameplay scripting, C++ for the game engine, an XML-based in-house GUI editor for creating interactions, and a visual programming tool for animation state machines.",-0.2,python
14v92v5,jru11ss,"It was a hodge podge of languages: Python for the AI/gameplay scripting, C++ for the game engine, an XML-based in-house GUI editor for creating interactions, and a visual programming tool for animation state machines.",-0.2,c++
14v92v5,jreeo2b,What semantics do JavaScript classes have or lack that you find makes them “improper”?,0.0,javascript
14v92v5,jreao66,*Added sigh*  What is it with people thinking that C syntax is clear or stylish?,0.3,c
14v92v5,jrgpfl9,There are a few more obscure algol languages.,0.15,algol
14v92v5,jribhrl,Actually I meant gnu Eiffel/Smart Eiffel projects.,0.0,eiffel
14v92v5,jrkkuyu,"PLZ/SYS was intended as a system programming language, and the idea was that mainstream languages like BASIC, FORTRAN and COBOL would also be developed for this Pcode system, which ran on Zilogs RIO system for Z80, and on ZEUS (Unix) for the Z8000.",0.05,fortran
14v92v5,jrkkuyu,"PLZ/SYS was intended as a system programming language, and the idea was that mainstream languages like BASIC, FORTRAN and COBOL would also be developed for this Pcode system, which ran on Zilogs RIO system for Z80, and on ZEUS (Unix) for the Z8000.",0.05,cobol
14v92v5,jregpyw,"JavaScript didn't have classes back then, only prototype-based inheritance.",0.0,javascript
14v92v5,jregpyw,"Which is powerful, but doesn't lead to a very smooth experience for beginners who were expecting ""Java in the browser"".",0.41000000000000003,java
14v92v5,jritwsx,"But sure, many ""dialects"" and more or less compatible implementations of Algol existed, sometimes named Algol-something, sometimes not.",0.3333333333333333,algol
14v92v5,jritwsx,"based on an Algol-68R-to-C compiler from the RSRE ELLA-project, I believe; and Algol 68 Genie by J. M. van der Veer, which exists in many Linux distro repositiories for very easy installation, although compilation from source is also easy.",0.49888888888888894,algol
14v92v5,jrchvg9,Well then c++ is dead to me.,-0.2,c++
14v92v5,jrj08ah,"Why should they maintain for example CHILL or Eiffel, if there are no users of the languages?",0.0,eiffel
14v92v5,jrjufc7,"Koster: Systematisch programmeren in Algol 68. """,0.0,algol
14v92v5,jrd0n4w,"Ive been developing with Delphi since Delphi 3 and while the IDE and developer experience is (mostly) absolutely phenomenal, the language/compiler itself lacks a lot of features or are implemented in a very annoying way which are handled much more nicely in modern languages.",0.05,delphi
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,delphi
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,c
14v92v5,jrd0n4w,"I love Delphi, but after spending time in modern C# and Rust, it is very clear that the Delphi language has aged a lot.",0.1825,rust
14v92v5,jrd0n4w,I use Delphi for new projects because Ive built a huge framework which provides most of the functionality I miss over the years.,0.34545454545454546,delphi
14v92v5,jrd0n4w,"But I feel like I will switch to Rust as soon as a matured, native and multi os GUI platform is available... :/",0.07500000000000001,rust
14v92v5,jrnuxjw,"Like I said, it's a lot simpler in some ways than Pascal (it doesn't even have a Boolean type, nor does it have floating point), but its syntax is interestingly strange in that "","", "";"" and "":"" are considered delimiters that are entirely ignored (except for separating tokens like space), which results in the weird reversed Algol-like declaration syntax: ""a b c integer"".",-0.18333333333333335,pascal
14v92v5,jrnuxjw,"Like I said, it's a lot simpler in some ways than Pascal (it doesn't even have a Boolean type, nor does it have floating point), but its syntax is interestingly strange in that "","", "";"" and "":"" are considered delimiters that are entirely ignored (except for separating tokens like space), which results in the weird reversed Algol-like declaration syntax: ""a b c integer"".",-0.18333333333333335,c
14v92v5,jrjvrch,> Algol-67  This page has a reference to an Algol 67 draft proposal.,0.0,algol
14v92v5,jrko3a6,"That would be alternate names for Algol X, or as we would say today, Algol 6x (like C2x, which in the future probably will be known as C23).",0.0,algol
14v92v5,jrko3a6,"Yes, I knew there was at least one other proposal besides Wirth and Hoare's (which later was implemented as Algol W) and Aad van Wijngaarden's.",-0.14166666666666666,algol
14v92v5,jrko3a6,"I hadn't seen these titles using the term Algol 67 before though, thank you for the links.",0.0,algol
14v8lsz,jrbwf6j,Its ideas are mixing TypeScript's type system and general syntax with fuctional features such as immutability and flow control without loops (like Ruby - you use functors i.e.,0.02500000000000001,typescript
14v8lsz,jrbwf6j,Its ideas are mixing TypeScript's type system and general syntax with fuctional features such as immutability and flow control without loops (like Ruby - you use functors i.e.,0.02500000000000001,ruby
14v8lsz,jrbwf6j,"It's pretty cool if anything because it doesn't look as exotic as the average functional language, and strives to be as simple and regular as possible.",0.13571428571428573,cool
14v8lsz,jre236s,"This is an example from the Readme:      const msg = String::concat(List<String>{""hello world"", "" @ "", timestamp.toString()});  If the meaning of that is what I think it is, then a better way of expressing this is:      const msg = ""hello world"" + "" @ "" + tostring(timestamp())  So in terms of simplicity it has some way to go!",0.625,go
14v8lsz,jree2if,"I agree it's not the ergonomic or simple (kinda like Python having you join arrays for performance) but it's not bad, especially if they have a reason not to give a concatenation operator or method to strings.",0.11666666666666664,python
14v8lsz,jre6gsz,": Pascal, Modula2, Oberon, Python 2, [Seed7](https://seed7.sourceforge.net), ...",0.0,pascal
14v8lsz,jre6gsz,": Pascal, Modula2, Oberon, Python 2, [Seed7](https://seed7.sourceforge.net), ...",0.0,python
14v8lsz,jre6gsz,": Oracle, SQLite, SQL Server, MySQL, PostgreSQL, ...  Java generics also use `<>` (this is neither concatenation nor not equal).",0.0,java
14v8lsz,jre6gsz,"For that reason [Seed7](https://seed7.sourceforge.net) uses [&](https://seed7.sourceforge.net/libraries/string.htm#(in_string)&(in_string)) for string concatenation (Basic, Ada, and other languages also decided for `&`):      msg := ""hello world"" & "" @ "" & timestamp();  This string concatenation does no type conversions (unlike the `+` string concatenation of Java).",-0.0625,ada
14v8lsz,jre6gsz,"For that reason [Seed7](https://seed7.sourceforge.net) uses [&](https://seed7.sourceforge.net/libraries/string.htm#(in_string)&(in_string)) for string concatenation (Basic, Ada, and other languages also decided for `&`):      msg := ""hello world"" & "" @ "" & timestamp();  This string concatenation does no type conversions (unlike the `+` string concatenation of Java).",-0.0625,java
14v8lsz,jrei91v,"For example Lua uses `..`, which strikes me as unintuitive, while your `<>`, as  u/ThomasMertes mentioned, often means `not equal`, as it does in my syntax, so may be confusing to some.",-0.15,lua
14v8lsz,jrei91v,"So that impenetrable C++ code I sometimes come across could really be quite simple after all, if I just ignore 90% of the syntax?",0.1,c++
14v8lsz,jrefwoh,Lua uses `..` but I don't like it that much.,0.2,lua
14v8lsz,jrl5l2s,"In Python, for instance, there's both, and the file example would be `open(f""{path}{file}{ext}"")`.",0.0,python
14v8lsz,jrl5l2s,"That's why having to spell out `concat([a, b, c])` seems more appropriate to me.",0.5,c
14v8lsz,jrla25r,"If the destination is represented as `D`, then my version results in these operations behind the scenes:      D := """"     D +:= path     D +:= file     D +:= ext  So the string adds are still there, but now they're the slightly more elaborate inplace versions!",0.43125,d
14v8lsz,jrlc657,"In Python specifically, more complex expressions are allowed, but that doesn't have to be so in your language.",0.1,python
14v8lsz,jrlc657,"Not in Python (nor some other languages with unicode strings), because `str` is immutable for good reasons.",0.2875,python
14v8lsz,jrlc657,"However, it has drawbacks, and could've been better off if implemented in a slightly different way (`Option<&T>` in Rust, for instance, is optimized to represent `None` with a null reference, but unlike a raw null pointer, this cones with convenient and simple compile-time guarantees).",0.0673076923076923,rust
14uzqze,jrdyhqz,MSVC will generate jump tables for switch statements use godbolt to look at the assembly to see and get an idea of how you may need to change the source so it emits better code.,0.5,assembly
14uttxo,,So I have come up with a pretty cool idea for a programming language that I would like to implement.,0.3,cool
14uttxo,,How should I go about this?,0.0,go
14uttxo,jr9djoi,[ANTLR](https://www.antlr.org) is a good way to go for this.,0.7,go
14uttxo,jr9djoi,You can have a [go of it](http://lab.antlr.org/) without installing anything.,0.0,go
14uttxo,jr9ddjb,"This IMO qualifies, check the use of EBNF notation in the Go language specification: https://go.dev/ref/spec#Notation",0.0,go
14uttxo,jrbqegb,Go to statements         4.4.,0.0,go
14usw9q,,"For chaining calls I have pipelines, as in F#, Elixir or Elm: `1 |> isNegative ==> isNegative(1)`.",0.0,elixir
14usw9q,,"For chaining calls I have pipelines, as in F#, Elixir or Elm: `1 |> isNegative ==> isNegative(1)`.",0.0,elm
14usw9q,jra06v5,"You could also try something like haskell's Hoogle, where you can search for functions by type, allowing users to filter down the total number of functions they could use in that part of the pipeline (I believe there are plugins for doing this within an IDE but idr)",-0.07777777777777779,haskell
14usw9q,jre5xfc,"The Elm and Purescript documentation compliments this really well, since you get the type of your ""hole"" and just search for it across the available packages.",0.30000000000000004,elm
14usw9q,jre5xfc,The only downside is that the Haskell syntax for declaring generic parameters for whatever reason puts the generic constraints before the argument/return types.,0.0,haskell
14usw9q,jre5xfc,"This can make it quite opaque to scroll through purescript or Haskell docs, but with Elm docs it's quite nice.",0.6,haskell
14usw9q,jre5xfc,"This can make it quite opaque to scroll through purescript or Haskell docs, but with Elm docs it's quite nice.",0.6,elm
14usw9q,jre5xfc,"(Seriously, polymorphism is nice but does Haskell have to be *that* polymorphic?)",0.13333333333333333,haskell
14upgz1,jr8scqn,"If you want to really understand how your high-level language features can be micro-optimized, you'll need to know assembly.",0.2,assembly
14upgz1,jr8scqn,But you can make very non-trivial programming languages without any assembly at all.,0.2,assembly
14upgz1,jr93wf3,"You don't have to to start out, but you will eventually know assembly better than everyone but hardcore assembly programmers if you stick with this hobby for long enough.",0.15,assembly
14upgz1,jr93wf3,"And as far as ABIs go, LLVM doesn't really do ABIs in a sane way, it's one of my biggest gripes with it.",0.15000000000000002,go
14upgz1,jr9gy4n,"I'd recommend knowing how to *read* assembly, it might make debugging easier and you'll know when to blame yourselves and when to blame llvm, but for the vast majority of things you won't need to know how to *write* it, which are two very different skills.",0.0,assembly
14upgz1,jr8ylk2,Many developers use C as their destination P.L.,0.5,c
14upgz1,jr8ylk2,"Or, Typescript or CoffeeScript to JS.",0.0,typescript
14upgz1,jr966ni,I guess you should know some principles on how Assembly works.,0.0,assembly
14upgz1,jr966ni,You do not need to know every single assembly instruction and certainly not every single architecture.,-0.08333333333333333,assembly
14upgz1,jr9wwpy,"hardware is for compilation, you can have wild semantics and an original paradigm all staying in python if you will",0.2375,python
14upgz1,jr9dtpu,"I can say that if you target C or C++ as your final target, it would suffice.",0.0,c
14upgz1,jr9dtpu,"I can say that if you target C or C++ as your final target, it would suffice.",0.0,c++
14upgz1,jr9dtpu,"Especially if you want to define a language like JavaScript, there's no point to work with LLVM, SSA or assembly.",0.0,javascript
14upgz1,jr9dtpu,"Especially if you want to define a language like JavaScript, there's no point to work with LLVM, SSA or assembly.",0.0,assembly
14upgz1,jratcwd,"You don't need to get your hands dirty knowing or writing assembly, which is different for every target and platform anyway, or needing to deal with optimisation.",-0.3,assembly
14upgz1,jratcwd,"I think it is worth knowing at some point, it's just not a prerequisite for implementing a language (unless that language is assembly!).",0.375,assembly
14upgz1,jratcwd,I'm pretty sure very few of those presenting functional-style languages here know or care about assembly programming.,0.16333333333333333,assembly
14upgz1,jratcwd,"LIBFFI is one heavyweight and complex solution, consisting of C code plus various platform-specific ASM files.",-0.15,c
14upgz1,jratcwd,"It requires a C compiler to process, and is generally horrible to build and an undesirable dependency.",-1.0,c
14upgz1,jratcwd,"But, using inline assembly in my systems language, I have my own solution in the form of a single 50-line function, specific to Win64 ABI.",0.1761904761904762,assembly
14upgz1,jratcwd,"Or you can do the same thing writing the assembly code in a discrete ASM file, then you use a separate assembler.",0.0,assembly
14upgz1,jrawjzz,"Unless you're writing another ""C replacement language"" as a design goal, the compilation step can happen later.",0.0,c
14upgz1,jrawjzz,"A-normal form is homomorphic to most assembly languages, so you just need one transformation after getting to this step.",0.5,assembly
14upgz1,jrawjzz,"From there, if you want to compile to assembly, it's pretty trivial.",0.25,assembly
14upgz1,jrawjzz,"(well, maybe not trivial because you have to think about linking and stuff, but outputting the actually assembly instructions as text is pretty easy).",0.22777777777777777,assembly
14upgz1,jr8zpyc,So ABI stability simply because C's ABI is stable for platforms.,0.0,c
14upgz1,jr9996h,"* It can also be run from the terminal in the way Python scripts are ""interpreted"" (fast-compiled to bytecode and then run on a VM, except mine will be fast-compiled to WASM and run via a WASI runtime).",0.0,python
14upgz1,jr9996h,"* Most likely, like Python, a file will represent a single module, with directories being used to group them (though Rust's crate tree structure also looks appealing as the basic build unit).",0.18571428571428572,python
14upgz1,jr9996h,"* Most likely, like Python, a file will represent a single module, with directories being used to group them (though Rust's crate tree structure also looks appealing as the basic build unit).",0.18571428571428572,rust
14upgz1,jr9996h,"If the user module is being ""interpreted"" like a python script as described above, or if one is importing the library into the REPL, then compiled DLL must be in WASM.",0.0,python
14upgz1,jr9996h,Take for example Cython's compiled DLLs (which can be directly imported by a python script like any `.py` module).,0.1,python
14upgz1,jreospd,I'm familiar with C and know basic pointer arithmetic (and manipulating C arrays with it).,0.1875,c
14upgz1,jreospd,"I may not know an actual assembly language and be able to write actual programs in one (TBF, I prefer not to have to master 3 or 4 ISAs and all their peculiarities) but I know what assembly languages/ISAs are generally like, to the point I get the conceptual difference between RISC and CISC.",0.1375,assembly
14upgz1,jr9kkd1,"These are some characteristics of my own systems language:  * Primarily supports Windows on x64 via direct native code generation * Other 64-bit platforms can be supported via transpilation to C, although that doesn't cover all language features * The compiler is fast enough to run programs directly from source (up to a certain size anyway; 500K lines would take one second to compile) * There is no REPL; this would be impractical in this language as it is strictly AOT: all code must be compiled before calling the entry point * There was an experimental, discrete VM target with an interpreter.",0.15892857142857145,c
14upgz1,jrqbsef,I'd say that you don't have to know assembly to make this possible.,0.0,assembly
14upgz1,jrqbsef,"I think _implementing it_ would pull you closer to the machine level and more ""ready"" to understand it than someone jumping in to assembly with zero context.",0.35,assembly
14upgz1,jr9lzet,"Also, preferably it should be a ""quick 0 to 60"" type language like C (and Go and Zig from what I hear).",0.3333333333333333,c
14upgz1,jr9lzet,"Also, preferably it should be a ""quick 0 to 60"" type language like C (and Go and Zig from what I hear).",0.3333333333333333,go
14upgz1,jrr23hm,"I was thinking of WASM/WASI because the impression I get is that it's more low level or ""assembly like"" than existing bytecode schemes, closer to actual machine instructions and hence execution would be faster.",0.16666666666666666,assembly
14uc5t2,jrobor3,It has the same kind of esoteric vibes that APL and Nock give off!,0.375,apl
14ua5dx,jr70895,"I'm pretty sure Swift does it, so do HotSpot (VM) and Go.",0.375,swift
14ua5dx,jr70895,"I'm pretty sure Swift does it, so do HotSpot (VM) and Go.",0.375,go
14ua5dx,jr7nvnc,"the go compiler does something like this, for example, as well as many dynamic language VMs (e.g.",0.25,go
14ua5dx,jr7nvnc,for javascript),0.0,javascript
14ua5dx,jreh2nv,The idea for Swift was initially to just move allocations to the heap for ref counting or on the stack depending on what the analysis showed.,0.0,swift
14ua5dx,jrc9h8i,"And then programmers prefer to go for simple programs that are easy to know if they'll cycle or not, which means that now we're covering 98% of actually used code (even if it's only 80%, that 20% includes weird programs most people wouldn't want to use).",0.07222222222222223,go
14ua5dx,jr7c7hy,"I considered a lot of programming languages to write my compiler in (C, Zig, F#, OCaml, Standard ML, Crystal,...), and when I got bored of my indecisiveness about languages, I picked V without thinking about it much.",-0.09999999999999999,c
14ua5dx,jr7c7hy,"I considered a lot of programming languages to write my compiler in (C, Zig, F#, OCaml, Standard ML, Crystal,...), and when I got bored of my indecisiveness about languages, I picked V without thinking about it much.",-0.09999999999999999,crystal
14ua5dx,jr7nhrt,"a borrow checker as in Rust), or a runtime cost (e.g.",0.0,rust
14ua5dx,jr6gckn,If I'm not mistaken that's how Rust does it.,0.0,rust
14ua5dx,jrdbwnz,I took following snippet from generated C code: ``` void _v_free(voidptr ptr) {     #if defined(_VPREALLOC)     {     }     #elif defined(_VGCBOEHM)     {     }     #else     {     }     #endif } ``` `_v_free` is the the function which is suppose to do the deallocation.,0.0,c
14ua5dx,jr6ytec,"It is possible, but as a note, Rust doesn't prevent all leaks.",0.0,rust
14ua5dx,jr8z3jv,&#x200B;  >If I'm not mistaken that's how Rust does it.,0.0,rust
14ua5dx,jr8z3jv,"Other programming languages have offered viable solutions, different strategies, and alternate directions, besides what Rust is doing.",-0.041666666666666664,rust
14ua5dx,jr7utm5,"smart pointers in C++, but basically this is the idea behind destructors.",-0.09285714285714287,c++
14ua5dx,jr93g82,"C#, for example, uses the `stackalloc` keyword for this.",0.0,c
14ua5dx,jr9oy8u,"I'm not a Rust aficionado so maybe I'm not fully understanding the implications of ""borrow checker"", but for a language without mutable references, you just need a type system utilizing some kind of substructural logic that fits your use case, be it linear, affine etc.",0.6,rust
14ua5dx,jr6iqkg,"It left quite a sour taste for many people that will take time to go away, even if V eventually delivers on their promises.",0.11666666666666665,go
14ua5dx,jr6nmku,"Not necessarily, COBOL for example divides variables into sections, where each section has a specific lifetime requirement.",0.0,cobol
14ua5dx,jr6nmku,COBOL slightly abstracts this lifetime requirement in the syntax.,-0.16666666666666666,cobol
14ua5dx,jr6nmku,"In COBOL you can't return a variable from a function's  local-storage or working-storage directly, you have to move it into the linkage section.",0.1,cobol
14ua5dx,jr6nmku,"Also, you can't return or pass file descriptors around in COBOL, that would be unsafe since it has native resources associated with it, so file descriptors are only valid in the scope that they were declared.",0.0,cobol
14ua5dx,jr6j14y,"Yes if you do it the Rust way, but I wonder if there's another set of constraints that would work.",0.0,rust
14ua5dx,jr8091o,"As a note to the note, off the top of my head the only two cases of leaks that Rust doesn't catch is 1) explicitely leaking and 2) Reference-counted cycles.",0.25,rust
14ua5dx,jr7udyp,in Python),0.0,python
14ua5dx,jr995py,Depends on what kind of Rust.,0.6,rust
14ua5dx,jr995py,"AFAIK a restrictive Rust without unsafe, forget, Rc and Arc (and maybe some other features) could probably do it.",-0.125,rust
14ua5dx,jr7uzhx,"No large enough examples to try it on, so I created a program with 1 million repetitions of `a = b + c * d`, one of my favourite tests because it needs so few language features.",-0.10238095238095239,c
14ua5dx,jr7uzhx,"No large enough examples to try it on, so I created a program with 1 million repetitions of `a = b + c * d`, one of my favourite tests because it needs so few language features.",-0.10238095238095239,d
14ua5dx,jr7uzhx,"I've no idea if this is supposed to be a performant version of it, or if that relies on using Tiny C backend.",0.0,c
14ua5dx,jr7uzhx,"This is about the same time as Tiny C working on a version in pure C, but the executable was 23MB.",0.07142857142857142,c
14ua5dx,jr6kpny,"Like, somebody doing experiments in this direction is totally cool, but misrepresenting it as a production ready product implementing some next level memory management is how you make me never trust a project again.",0.18333333333333335,cool
14ua5dx,jrc6hen,How about you go back to shilling Rust then.,0.0,go
14ua5dx,jrc6hen,How about you go back to shilling Rust then.,0.0,rust
14ua5dx,jr6o5z9,I haven't studied COBOL and I couldn't grasp any of that.,0.0,cobol
14ua5dx,jr7um54,People acting like Rust is the only way are fooling themselves.,0.0,rust
14ua5dx,jryljtv,in Python  [Python's GC handles cyclic references without leaking memory.,0.0,python
14ua5dx,jr79v4u,COBOL source code is syntactically separated into divisions and sections.,0.0,cobol
14ua5dx,jr79v4u,"The key thing here, is that COBOL doesn't allow you to return variables directly from other sections.",-0.008333333333333331,cobol
14ua5dx,jryoej3,"Yeah, I don't really write python since 3.7, I'm glad about the new stuff but don't really follow it closely",0.2590909090909091,python
14ua5dx,jrc5rfm,"In one like C and like mine, applying gcc-class optimisation might only double performance, but at a cost of taking up to 100 times longer to build, so it's not worth doing for routine development.",-0.049999999999999996,c
14u1brp,jr5k9do,"This problem occurs in C too, where the types are `T*[]` for `array of pointer`, and `T(*)[]` for pointer to array, or somthing like that.",0.25,c
14u1brp,jr5k9do,"It was actually solved by Algol68 (four years before C first appeared), by using a left-to-right syntax.",0.125,c
14u1brp,jr5k9do,Here `ref` means `pointer to` (although Algol68 had grander concepts):      ref[]T   A      # pointer to array of T     []ref T  B      # array of pointer to T  I've used this scheme too for decades.,0.0,scheme
14u1brp,jr5k9do,"C tried to make it correspond, and the result was disastrous.",-0.7,c
14u1brp,jr5q4zw,I've had a similar problem working with C where this can become ambiguous.,0.0,c
14u1brp,jr6h62s,"I never really liked how TypeScript has `Array<T>` (good - ""Array of T"") but then has a syntax sugar of `T[]`, which feels backwards.",0.19999999999999998,typescript
14u1brp,jra5psl,Just read through the linked page and wanted to say that Ruby handles array indexing the same way!,0.0,ruby
14u1brp,jr65x1m,This issue was notorius in C++ until C++11 and required you to put an extra space.,0.0,c++
14u1brp,jr62sz8,"It's ugly, but you rarely see this in actual C code.",-0.13333333333333333,c
14u1brp,jr62sz8,"The reason: nobody uses pointers to arrays (`T(*)[]`) in C; the universal idiom is to use a `T*` type instead (pointer to the first element), even though this is unsafe: `A` might not be an array, but C allows indexing of pointers anyway.",0.16666666666666666,c
14u1brp,jr62sz8,"Yet another is pointer-to-function `F`, called as `(*F)(x)`, but this is rarely seen too, because one of C's quirks allows you to just use `F(x)`.",0.3,c
14u1brp,jr62sz8,"So, it's all very well saying that having extraneous parentheses is OK, but even C,  not averse to punctuation, avoids using them as much as possible!",0.2333333333333333,c
14u1brp,jr62sz8,"Personally I prefer a postfix dereference operator (mine was based on Pascal's `^`), but as I said it's your choice.",0.0,pascal
14u1brp,jr62sz8,"Go with `@`, whether prefix or postfix, and see what sample programs look like.",0.0,go
14tvuta,jr4kw0w,"As far as programming history goes, don't forget about the array languages, like APL.",0.1,apl
14tvuta,jr4kw0w,"In fact, Jeremy Gibbons has an article, [Origami Programming](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf), which explains (via Haskell) more than you ever wanted to know about reduce.",0.5,haskell
14tvuta,jr4s5mj,"IIRC they're present in the lisp 1 programming manual, which was written in 1960.",0.0,lisp
14tvuta,jr4kaj7,Probably APL.,0.0,apl
14tvuta,jre45ig,"I believe it was John Backus doing research for good functional primitives, and he found out that 90% of for loops in the Fortran compiler were either filter, map, or reduce.",0.7,fortran
14tvuta,jr51b2v,"That said, some commentators have mentioned APL, and quoting the Wikipedia page linked above:  > Plankalkül has drawn comparisons to the language APL",0.25,apl
14tvuta,jr509ln,"I’ve always assumed Lisp, but since it’s older than I am, and older than most living people for that matter, I guess it doesn’t matter too much at this point.",0.2583333333333333,lisp
14tvuta,jr9g2dz,"When I said ""earlier Lisps"" I was thinking Scheme but of course Scheme is notoriously minimalistic.",0.0,scheme
14tvuta,jr9g2dz,Tbh it doesn't make sense to have a Lisp without filter map reduce.,0.0,lisp
14tvuta,jr9g2dz,"Edit: having read the document, Lisp 1 does indeed not have built in filter or reduce functions.",0.0,lisp
14tvuta,jr9g2dz,"There's a select, which is like first() in C#, and a reduce, which is unrelated to functional array manipulation.",0.25,c
14tvuta,jr9g2dz,"Edit 2: I read through the Chinual and found that, in Lisp Machine Lisp, filter is called ""subset"" or ""rem-if-not"".",0.0,lisp
14tvuta,jr4s8c5,"This is probably close to correct, but with the following caveats:  * Original APL did not have a real `map` construct where you could apply an arbitrary function to each element of an array.",0.11875,apl
14tvuta,jr4s8c5,"Instead, all APL operations were implicitly rank-polymorphic.",0.0,apl
14tvuta,jr4s8c5,"The actual APL version of `map` (called ""each"") is much younger.",0.0,apl
14tvuta,jr4s8c5,"* APL's `filter` operation was also somewhat different, as it took a boolean array instead of a function.",0.0,apl
14tvuta,jr4s8c5,"* APL's `reduce` was pretty much what you'd expect it to be however, although limited to a handful of built-in functions IIRC.",0.1261904761904762,apl
14tvuta,jr4s8c5,"The connecting thread here is that APL didn't have first class functions, so the modern filter/map/reduce operations would not be expressible.",0.225,apl
14tvuta,jr4s8c5,"I'm not sure when they first occurred in their modern form, but I think Lisp was the first reasonably widespread language with first class functions, so I'd point to somewhere in that vicinity.",0.15,lisp
14tvuta,jr9gb05,"Yeah, the fact that it's the oldest functional language and that it's list-based and loops through recursion makes it a safe bet for being the first to implement filter map reduce, but surprisingly older versions of Scheme don't have built in implementations of filter and reduce, and somehow I was dumb enough not to consider there are other old Lisps besides Scheme.",0.0738095238095238,scheme
14tvuta,jr5487a,"I believe map originates in lisp, and that reduce was taken from apl.",0.0,lisp
14tvuta,jr5487a,"I believe map originates in lisp, and that reduce was taken from apl.",0.0,apl
14tvuta,jr5487a,"Apl had user-defined functions—howbeit with really horrible syntax—_fairly_ early, though I don't know exactly how early.",-0.1375,apl
14tk6p4,,"class BoundingBox2D implements Interval      {        field Min: Point2D;        field Max: Point2D;      }          class NumberRange implements Interval     {        field Min: Number:        field Max: Number;       }          concept Interval<Element : Numerical>     {         field Min : Element;         field Max : Element;       }          operations Interval     {         function Size(i) = i.Max - i.Min;         function IsEmpty(i) = i.Min >= i.Max;         function Lerp(i, amount) = i.Min * (1.0 - amount) + i.Max * amount;         function InverseLerp(i, value) = (value - i.Min) / i.Size;         function Multiply(i, x) = (i.Min * x, i.Max * x);         function Add(i, x) = (i.Min + x, i.Max + x);         function Negate(i) = (-Max, -Min);         function Reverse(i) = (Max, Min);         function Resize(i, sz) = (i.Min, i.Min + sz);         function Center(i) = i.Lerp(0.5);             function Contains(i, x) = i.Min <= x and x <= i.Max;         function Contains(i, other) = i.Min <= other.Min and i.Max >= other.Max;         function Overlaps(ia, ib) = ia.Contains(ib.Min) or ib.Contains(ia.Min);         function Split(i, t) = (i.Left(t), i.Right(t));         function Split(i) = i.Split(0.5);         function Left(i, t) = (i.Min, i.Lerp(t));         function Right(i, t) = (i.Lerp(t), i.Max);         function MoveTo(i, t) = (t, t + i.Size);         function Recenter(i, c) = (c - i.HalfSize, c + i.HalfSize);         function Clamp(i, x) = x < i.Min ?",-0.6979166666666666,c
14tk6p4,jravt66,"- `field`/`function` feels a bit wordy, but I like that you have definition bodies with `=` from the get go.",0.0,go
14tk6p4,jrp44wj,"If it is just an Interface, I would rather call it just Interface or better Trait like rust does it.",0.5,rust
14tk6p4,js2t9ev,"I did want to minimize people bringing old baggage, and I like that in C++ for many years the idea of a concept suggested signature-based polymorphism (aka duck typing).",0.3,c++
14tjakk,jr2ybnf,">Most programming languages I know use `}` for all of those things,  That's C having far more influence than it deserves.",0.3,c
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,pascal
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,matlab
14tjakk,jr2ybnf,>and those that do not (such as Pascal or MatLab or Lua) use end for all of those.,0.0,lua
14tjakk,jr2ybnf,"Plus there are a couple  more categories: the ones using S-expressions so `)` is used for everything, and those using no terminator at all (like Python and Nim).",0.5,python
14tjakk,jr2ybnf,"As for the reasons for those using only `End`, with Pascal and Algol60, `Begin ... End` are a form of parentheses just like `{ ... }` and `( ... )`.",0.0,pascal
14tjakk,jr3u86i,I think scala 3's indentation sensitive syntax does this really well.,0.15000000000000002,scala
14tjakk,jr5747e,Erlang has many ways of ending block structures and it's a mess.,0.1625,erlang
14tjakk,jr5lia7,> That's C having far more influence than it deserves.,0.3,c
14tjakk,jr4jc1w,"It’d be handy for avoiding duplication in cases like this:      if allow_retry() then       while should_retry()     end then          try_action()      then         backoff()       end while     end if  But even if you don’t allow deduplicating that `if` condition, the pattern does come up from time to time.",0.6,d
14tjakk,jr4jc1w,"HTML template languages often have ways of separating delimiters like this, so that the meta-level template blocks don’t have to be strictly nested in the object-level HTML blocks.",0.0,html
14tjakk,jr663lx,"Take this example from C (which often allows braces to be optional: yet another possibility):      if (a) {b; c;} else {d; c;}  The two blocks are separated by `} else {`; think of how many ways there are of placing those, occupying anything from 1 to 3, lines, with  `}` possibly sharing with the previous line,  maybe `{` with the next.",0.08333333333333334,c
14tjakk,jr663lx,"Take this example from C (which often allows braces to be optional: yet another possibility):      if (a) {b; c;} else {d; c;}  The two blocks are separated by `} else {`; think of how many ways there are of placing those, occupying anything from 1 to 3, lines, with  `}` possibly sharing with the previous line,  maybe `{` with the next.",0.08333333333333334,d
14tjakk,jr663lx,"Now compare with `end` style:      if a then b; c else d; c end  Only `else` is needed to separate the blocks, so there are fewer ways of doing it.",0.0,c
14tjakk,jr663lx,"Now compare with `end` style:      if a then b; c else d; c end  Only `else` is needed to separate the blocks, so there are fewer ways of doing it.",0.0,d
14tjakk,jr663lx,"The first `b;c` block doesn't need a special delimiter, because `else` fills that role.",0.3035714285714286,c
14tjakk,jr663lx,But if you try and mark that with braces:      if (a) b; c; else d; c; }  it looks weird - the `}` is unbalanced.,-0.5,c
14tjakk,jr663lx,But if you try and mark that with braces:      if (a) b; c; else d; c; }  it looks weird - the `}` is unbalanced.,-0.5,d
14tjakk,jr663lx,"C's approach is to use no braces for a block of one statement, and braces otherwise, but that can be odd too:      if (a) b; else {d; c;}  Also, a syntax that doesn't have parentheses around the condition, needs something that separates `a` from `b`; another brace?",-0.16666666666666666,c
14tjakk,jr663lx,"C's approach is to use no braces for a block of one statement, and braces otherwise, but that can be odd too:      if (a) b; else {d; c;}  Also, a syntax that doesn't have parentheses around the condition, needs something that separates `a` from `b`; another brace?",-0.16666666666666666,d
14tjakk,jr663lx,This:      if {b; else d; c; }  still looks well-weird.,0.0,d
14tjakk,jr663lx,This:      if {b; else d; c; }  still looks well-weird.,0.0,c
14tjakk,jr4rvt5,"Past that, it seems like what you're getting at is meta-programming, especially with the HTML part.",-0.125,html
14tjakk,jr4rvt5,"Same for meta-programming: macro -> code, template -> html, and so on.",0.0,html
14tjakk,jr4rvt5,"As someone said, that's essentially just goto:      retryable: someAction();     if(allowRetry() && shouldRetry()) {         backoff();         goto retryable;     }  That's actually shorter, although that's partially due to C syntax, and IMO much easier to follow mentally.",-0.004999999999999999,c
14tjakk,jr4rvt5,"You have the duplicated `retryable` tag but the duplication seems well worth it, and if you really wanted to and the language supported it, you could do something like this:      someAction();     if(allowRetry() && shouldRetry()) {         backoff();         goto -3;     }  where -3 tells it to go 3 lines up.",0.25,go
14tjakk,jr4rvt5,"For example:      if(a)          while(b)     fi     if(c)         while(d)     fi      doStuff()      if(a)             somecleanup()         elihw     fi     if(c)             othercleanup()         elihw     fi  I mean we can match up the if conditions, but this is still relatively simple, and do you really want the compiler making that call?",-0.0375,c
14tjakk,jr4rvt5,"For example:      if(a)          while(b)     fi     if(c)         while(d)     fi      doStuff()      if(a)             somecleanup()         elihw     fi     if(c)             othercleanup()         elihw     fi  I mean we can match up the if conditions, but this is still relatively simple, and do you really want the compiler making that call?",-0.0375,d
14tjakk,jr4rvt5,"Take:      if(a) then         while(b)     fi     if(c) then         while(d)     fi      doStuff()      then             somecleanup()         elihw     fi     then             othercleanup()         elihw     fi  First, I had to add `then` to even make this syntax work.",0.25,c
14tjakk,jr4rvt5,"Take:      if(a) then         while(b)     fi     if(c) then         while(d)     fi      doStuff()      then             somecleanup()         elihw     fi     then             othercleanup()         elihw     fi  First, I had to add `then` to even make this syntax work.",0.25,d
14tjakk,jr4rvt5,"Meta-programming is super cool and I should've clarified that point in my original post, and this was fun to sort out my thoughts on and write up (I spent far longer on it than I should've).",0.2263888888888889,cool
14tjakk,jr4rvt5,"Second, the HTML example looks like it's more or less just permuting over the combinations of essentially singly nested arrays.",0.0654761904761905,html
14tjakk,jr4xrrc,"C also has something I'd perceived as an ambiguity:      do ; while (c) {}  Does that `while` end the `do` statement, or does it start a new `while` statement?",0.13636363636363635,c
14tjakk,jr3ndba,"BTW I sometimes use an alternate, more compact syntax with parentheses:      if a then b else c fi       # or:     ( a | b | c )          record R = ... end          # or:     record R = (...)  This form is more suitable for one-liners.",0.00833333333333334,c
14tjakk,jr3ndba,"BTW I sometimes use an alternate, more compact syntax with parentheses:      if a then b else c fi       # or:     ( a | b | c )          record R = ... end          # or:     record R = (...)  This form is more suitable for one-liners.",0.00833333333333334,r
14tjakk,jr3purw,"But syntactically, my favorite language is also Lisp—although I wish they'd budge on the whole all the closing parens go on the same line—so I undeniably have my biases.",0.2333333333333333,go
14t96qf,,"Great examples are Crystal and Codon (a Python ""subset"", which treats the language like a statically typed one).",0.8,crystal
14t96qf,,"Great examples are Crystal and Codon (a Python ""subset"", which treats the language like a statically typed one).",0.8,python
14t96qf,,"I am barely convinced that such a language would enable the compiler to do even deeper and interesting optimizations than the classical ones (but still mind blowing) applied to languages such as C, C++ (an example is Zig, which is even more optimizable AFAIK because of its very clever approach to Meta Programming, isn't it?",0.18095238095238095,c
14t96qf,,"I am barely convinced that such a language would enable the compiler to do even deeper and interesting optimizations than the classical ones (but still mind blowing) applied to languages such as C, C++ (an example is Zig, which is even more optimizable AFAIK because of its very clever approach to Meta Programming, isn't it?",0.18095238095238095,c++
14t96qf,,"('value cannot be deduced by this instance')          # Casting (functional-style casting in this case)     # when the caster is an impl and not a type     # works as injection of the implementation methods     token = Token(kind: TokenKind.id, value: 'match')     std.io.println(       '       is_match: %{token.is_fake_keyword('match')}       value: %r{token.get_value()}       '       # `%r{}` should trigger `repr` instead of `to_str`     )          token = Token(kind: TokenKind.kw_fn)     std.io.println(token.get_value()) # => `fn`  &#x200B;      impl IString:       fn is_pascal_case():         if is_empty():           return false                  return first().is_upper()            fn is_snake_case():         if is_empty():           return false                  # The foreach uses         # different iteration         # techniques based on the         # provided iterable.",-0.2666666666666667,r
14t96qf,,"# With c strings it should         # behave like a `while (ptr)`,         # but with other containers         # should use the `len()` method,         # or even with integers, just `i++`         for c in this:           if c.is_upper():             return false                  return true          # Injecting an implementation overwrites     # methods with clashing names.",-0.05833333333333338,c
14t96qf,,"The compiler informs you that \`data\` must be something iterable, which means it must implement attributes      fn len()    // used in foreach and return     fn nth(idx) // used in foreach  and then each iterated element should implement specific attributes as well      static default // used as base for the sum     fn add()       // used to sum all the elements  &#x200B;  **Why I don't like the idea of making type annotations just optional**  What seems to happen in Crystal code is that users just end up using explicit typing over implicit one, because:  * The language allows you to do it, so for Crystal users it's easier to just reject a new way to code and continue using the classic approach with types * The compiler doesn't explain to you why a function raises compilation errors when you pass a wrong argument  &#x200B;  **Ways to make it easier for the user to spot wrong arguments**  Using this approach may be hard for the user to understand what to pass to a certain function of an X library, maybe not well documented.",-0.11937229437229441,crystal
14t96qf,,"One solution would be just printing some sort of compile time stack trace of function instantiations, like Clang does when using \`auto\` on parameters in C++.",0.0,c++
14t96qf,jr1a3ha,"You can do that in any sort of MLy language to be honest, especially if you don't use advanced type-level magic like it's common in Haskell.",0.24,haskell
14t96qf,jr1l2ty,You can see this in action when using complicated C++ templates or writing Haskell code without enough type annotations.,-0.13333333333333333,c++
14t96qf,jr1l2ty,You can see this in action when using complicated C++ templates or writing Haskell code without enough type annotations.,-0.13333333333333333,haskell
14t96qf,jr1l2ty,"There's a good reason why the Haskell community has developed the convention that all top-level declarations should have type declarations, and why Rust promoted that contention to a rule.",0.39999999999999997,haskell
14t96qf,jr1l2ty,"There's a good reason why the Haskell community has developed the convention that all top-level declarations should have type declarations, and why Rust promoted that contention to a rule.",0.39999999999999997,rust
14t96qf,jr1jd1k,"Haskell in particular was designed such that in _any valid Haskell program_, with no type annotations at all, the types can be fully inferred.",0.08333333333333333,haskell
14t96qf,jr1g2j9,You could even go full dependent types.,0.35,go
14t96qf,jr30r3j,"To echo some other comments, give an ML language such as ReScript or OCaml a go.",-0.0625,go
14t96qf,jr30r3j,"ReScript is syntactic sugar on OCaml (same AST, different parser) designed to transpile to JavaScript, and the syntax is more comfortable if you’ve come from a C or JS background.",0.225,javascript
14t96qf,jr30r3j,"ReScript is syntactic sugar on OCaml (same AST, different parser) designed to transpile to JavaScript, and the syntax is more comfortable if you’ve come from a C or JS background.",0.225,c
14t96qf,jr2ch7p,I'm not willing to go that far.,-0.012499999999999997,go
14t96qf,jr2ma88,"I see the many comments that so and so functional language that does it, frankly no one cares, it's imperative and C level performance or go home.",0.5,c
14t96qf,jr2ma88,"I see the many comments that so and so functional language that does it, frankly no one cares, it's imperative and C level performance or go home.",0.5,go
14t96qf,jr1kwo9,Modern Java has this.,0.2,java
14t96qf,jr6nl67,I guess there is a good reason Rust requires explicit types at the function boundary and why functional languages have this at least as the best practice.,0.4666666666666666,rust
14t96qf,jr1lqzb,"Make me a real example where a function require for param1 x y and z methods and for param2 the a b and c methods, but the function has an abnormal behaviour with certain inputs because those methods mean something other",-0.005803571428571436,c
14t96qf,jr1ppie,"For example:      fn rot(c, key):       return type!",0.0,c
14t96qf,jr1ppie,(c)(         type!,0.0,c
14t96qf,jr1ppie,"(key)(c) + key       )          fn caesar_encrypt(a, source, key):       en = a.alloc_sequence(type!",0.0,c
14t96qf,jr1ppie,"(source[0]), source.len())              for c in source:         source = rot(c, key)            return en          fn caesar_decrypt(a, source, key):       return caesar_encrypt(a, source, -key)  Then you can call this functions like this:      # std.mem is actually a module     _ = caesar_encrypt(std.mem, [1, 2, 3, 4], 432847392490384)     _ = caesar_encrypt(std.mem, 'ab', 3 + 4j) # key as a complex number          with std.mem.Arena(100) as a:       # the allocator is not boxed into a generic       # `Allocator` like in Zig, so no vtable is involved       # and the runtime soffers zero from this call       caesar_encrypt(a, [1.2, 3.4, 5.6], std.math.pi)",-0.04285714285714286,c
14t96qf,jr51m0f,"Using typeclasses ala Haskell, a and b would be inferred as: `(Read a, Num a) => a` That is, some type a, for which the appropriate methods (in this case read and (+)) are defined, but we don't yet know concretely what it is.",0.325,haskell
14t96qf,jr3n3c9,It is common to write Rust code that requires explicit type annotations.,-0.3,rust
14t96qf,jr274pq,I already don't write types in Rust until I have to (due to ambiguity and choices).,-0.125,rust
14t96qf,jrh8kdo,"It's an interesting language, but it does not match C for performanc https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/ocaml-gpp.html, and thus is useless for a variety of cases, e.g.",0.0,c
14t96qf,jr3cpw4,The implementation of ML languages is not based around copying the body of a function like Crystal.,0.0,crystal
14t96qf,jr60s7o,"Then values from the buffer are read into any variables that are provided, so, reading 3 values can be done like this:      readln a     read b, c  In a static language, it will know what types to expect.",0.5,c
14t7ig2,jr4znt0,"Val originates from taking Swift's double nature of both reference and value semantic, and pushing the value semantic part and only it to the maximum.",0.0,swift
14t7ig2,jr4znt0,"Also, they think Val is easier to understand than Rust lifetimes and borrow checker, and therefore decided to try and develop Val as a mainstream programing language.",0.0,rust
14t7ig2,jr4znt0,Halide is cool.,0.35,cool
14ssjiv,jr13j4h,It's something of a paradox :)  What I think is:  - It's 10x-100x harder to write a production C compiler (Clang/LLVM) than a toy C compiler - It's 10x-100x harder to write a production shell (our goal) than a toy shell - C/C++ are ~10x bigger than shell?,0.07500000000000001,c
14ssjiv,jr13j4h,It's something of a paradox :)  What I think is:  - It's 10x-100x harder to write a production C compiler (Clang/LLVM) than a toy C compiler - It's 10x-100x harder to write a production shell (our goal) than a toy shell - C/C++ are ~10x bigger than shell?,0.07500000000000001,shell
14ssjiv,jr13j4h,"My impression of GCC/Clang is that they're 1M+ lines of code, while bash is ~160K lines of code  So it's a big problem, but definitely should be doable.",0.0,bash
14ssjiv,jr13j4h,"Open source is really like those sci-fi books where the civilization is running, but nobody knows how the tech works anymore  Shell is sprayed all over the foundations of software, both at build time and runtime (and it's more popular now than EVER!",0.3625,shell
14ssjiv,jr13j4h,"due to the cloud and embedded systems becoming Linux systems)  But there are lots of parts that only a few people know about  ---  To be honest we still need a lot of help, and I think the people on this sub have the right skills - e.g https://www.oilshell.org/blog/2023/03/roadmap.html  If anyone likes generating C++ code, there are some exciting projects there, like ""boxless optimization"" to remove a level of boxing from the interpreter  Generating C++ is the best of both worlds IMO -- you don't have all the pitfalls of writing it by hand (e.g.",0.28883928571428574,c++
14snerw,jqzr4d9,Very cool; I'd like to see a comparison with lexy as it immediately reminded me of lexy,0.45499999999999996,cool
14snerw,jqzzirf,:D,1.0,d
14sbn35,,"That makes such a loop a *list-comprehension*, a slightly different beast, which in Python has dedicated syntax:      x = [elem + 2 for elem in [1,2,3,4]]  In Pyret, the same example is:      x = for map(elem from [list: 1,2,3,4]):       elem + 2     end  Pyret is touted as being *designed to serve as an outstanding choice for programming education*, so I'm surprised it makes the basics so hard: the original BASIC gave you `for i = a to b`; I couldn't tell you how it would be in Pyret.",0.08541666666666667,python
14sbn35,jqwyo6c,Pyret is pretty much a Scheme with a facelift to make it more accessible.,0.33125,scheme
14sbn35,jqxf5hw,"I can't speak for the Pyret designers, but: when you have `for i = a to b`, you have `for i = a to b` and you need a whole lot more other things that will need to be taught as well, such as list comprehensions in Python.",0.14375,python
14sbn35,jqxf5hw,"(I invented this kind of 'for' expression, in a post to comp.lang.lisp in the 90s where it was a Lisp macro called 'with'.",0.6,lisp
14sbn35,jqxf5hw,Later it went into [my own Lisp](https://github.com/darius/cant) as 'for'.,0.3,lisp
14sbn35,jqwzn9i,I think the point of the for loop is that its implemented as syntactic sugar around a simple map-fold pattern (which I think is pretty cool).,0.19999999999999998,cool
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,ruby
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,julia
14sbn35,jr2e6jq,"This construct strongly reminds me of Ruby and Julia's `do` form:      # Julia     map([1, 2, 3, 4]) do e       e + 2     end      # Ruby     [1, 2, 3, 4].map {|e| e + 2}     [1, 2, 3, 4].map do |e|       e + 2     end  In terms of the complexity of the syntax, this is nothing compared to Common Lisp:      (defvar *list* '(1 2 3 4))     (defvar *arr* #(1 2 3 4))     (loop for e in *list* collect (+ e 2))     (loop for e across *arr* collect (+ e 2))     (map 'list (lambda (e) (+ e 2)) *list*) ; also works on arrays     (mapcar (lambda (e) (+ e 2)) *list*)     (defvar *list* '(""Ahoy"" ""world!""))",-0.010833333333333339,lisp
14sbn35,jqxi2l2,">It's used to demonstrate functions-as-values,  That was demonstrated by `d-dx` (another source of confusion: I haven't used minus signs inside identifiers since I wrote some COBOL.",-0.1,cobol
14sbn35,jqxi2l2,"So, calling `around(d, t)` creates an anonymous function `$F`, where parameters `d` and `t` are baked in, and that function is called as `$F(x)` (`x` is locally called`actual`).",0.0,d
14sbn35,jqxi2l2,So presumably that returns with `true` when `x` is near the value of `t` within a tolerance of `d`.,0.22499999999999998,d
14sbn35,jqxkwif,">(I invented this kind of 'for' expression, in a post to comp.lang.lisp in the 90s where it was a Lisp macro called 'with'  Yes I noticed that Lisp was also open-ended when it came to loops, with endless flexibility and possibilities (from looking at CLisp).",0.2375,lisp
14sbn35,jr06ve7,"(My `head` and `tail` functions were named after the Haskell versions, but mine are not lazy.)",0.125,haskell
14sbn35,jr06ve7,"Here's an example of an endless loop combined with `switch`, used to scan the characters of an identifier within a lexer:      doswitch c:=lxsptr++^     when 'a'..'z','0'..'9','_','$' then        ...",-0.125,c
14sbn35,jqzcs0w,"To give an example in a language I'm more familiar with, Haskell's `take`, which takes n amount of items from the start of a list and returns a new list of those items, is auto-curried.",0.3371212121212121,haskell
14sbn35,jqzcs0w,"This is why most Haskell functions don't pass the ""object"" first (in this case the list) because it's the most likely to vary rather than being fixed.",0.27,haskell
14sbn35,jqxwsy0,"The idea is only that if you wrote out the call by hand, it'd have a readability problem exactly like the readability problem of (Scheme)  ``` ((lambda (x y z) ...)    (compute-foo)    (compute-bar)    (compute-baz)) ```  which the `let` expression was invented to improve on.",0.125,scheme
14sbn35,jqwxut3,"If I would pick a language to teach beginners for ease of teaching it would neither be Python, JS nor a functional language of any kind.",0.6,python
14sbn35,jr09ct4,">Or the loop-index is used to access multiple data structures  Just operate on the structures using their associated functions after generating the indexes, why go through the middle man of an Integer and a loop?",0.0,go
14sbn35,jr09ct4,"It's a different way of thinking in that, instead of jumping right into ""I want to loop, get the index at the ready, go go go!""",0.17857142857142858,go
14sbn35,jqyet2k,"Maybe that's how it works in languages like Lisp, but I'd implement loops using lower-level features, not higher-level ones.",0.0,lisp
14sbn35,jqxqaql,"And from looking at open-source projects, it's not common elsewhere either (except programs written in Rust which seem to do little else except pattern-matching).",-0.018750000000000003,rust
14sbn35,jr0janv,It means I can also do simple embellishments:      for i in range do         redo          # various multi-level loop controls         exit         next     else              # (from Python) execute on normal exit     end  It becomes harder to incorporate this stuff when the concept of iteration revolves around traversing some linear data structure instead of just existing independently.,0.008333333333333331,python
14sbn35,jqz4fgo,"Going back to Pyret, from what I've read, the designers see equational reasoning about programs as a big deal and not just for the Haskell freaks who like big words like ""equational reasoning"".",0.0,haskell
14sbn35,jqxudbq,Throwing someone head first in Scheme might be significantly harder than easing them into functional programming with Pyret.,0.075,scheme
14sbn35,jqxudbq,However the question is whether it compares favourably with say Pascal or BASIC if the intention is *just to teach people the basics of programming*.,0.0,pascal
14sbn35,jqxudbq,"If the intent is to later just use functional programming, then clearly using something like BASIC or Pascal would point people in the whole wrong direction – they'd have to do a 180 to get aligned with functional programming.",-0.039999999999999994,pascal
14s9pnm,,"It seems to be common knowledge that the D compiler has very fast clean compile times, even though it's packed to the brim with language features.",0.10888888888888891,d
14s9pnm,,"**Question:** Are there any blog posts or articles digging into the design of the D compiler, or some of its implementation choices?",0.0,d
14s9pnm,,"There a handful of articles on the [official D blog](https://dlang.org/blog/), but they mostly don't cover compiler internals.",0.5,d
14s9pnm,,And the personal blogs of some of the D contributors seems rather sparse.,0.0,d
14s9pnm,jqxpuem,There's quite a lot of info on the compiler source on the D Wiki.,0.0,d
14rjg05,jqygp6g,"So like, TLDR, we can write C code to an API that generates code like the way LLVM does, but with more cowbell?",0.5,c
14rjg05,jqysix6,"You can write your code in any language that can interface with the c ffi, so zig, c++, c, python, whatever else.",0.0,c
14rjg05,jqysix6,"You can write your code in any language that can interface with the c ffi, so zig, c++, c, python, whatever else.",0.0,c++
14rjg05,jqysix6,"You can write your code in any language that can interface with the c ffi, so zig, c++, c, python, whatever else.",0.0,python
14rfz9f,,"I've been looking at other compilers and they use some c++ classes such as ""_Unwind_Exception"".",-0.0625,c++
14rfz9f,jr9hcvp,"Rust also has exceptions, and they're very frequently used.",0.13,rust
14rfz9f,jraenfd,"What would be ""Rust exceptions""?",0.0,rust
14rfz9f,jrata2a,"Yes, Rust's panic is a form of unchecked exception, which can be caught with catch_unwind.",0.0,rust
14rfz9f,jrata2a,It's essentially the same as in Java or C++.,0.0,java
14rfz9f,jrata2a,It's essentially the same as in Java or C++.,0.0,c++
14re46t,,I’m considering utilizing C as a compilation target for an unannounced language;  1.,0.0,c
14re46t,,Any good libraries for building C Source?,0.7,c
14re46t,,Any good libraries aside from TinyC to compile the C into an Executable?,0.7,c
14re46t,jqrs2af,"This is my experience from a previous language that I've abandoned:  - C compilers don't like huge generated functions, had to use TinyCC to even able to compile (the self build of a compiler took about 2mins still, painfully slow for the development - don't try to selfhost too early) - the generated binaries were huge (I did inline some stuff but mostly things like refcounting and other small rudimentary stuff, still it added up a lot) - the performance boost (when I managed to compile it in GCC by splitting the huge functions) is not much unless your language is pretty much just C with a different syntax, you're still required to do your own optimizing compiler if you want performance gains - general linking with arbitrary function names (eg.",0.1387254901960784,c
14re46t,jqry4o4,My [language project](https://norstrulde.org/language84/) uses C as a target language.,0.0,c
14re46t,jqry4o4,"If you follow the “browse” links and look for files named “84_stable.c” and “c.84”, you can find the generated C code and the compiler component that writes it out for each release of the self-hosted compiler.",0.0,c
14re46t,jqry4o4,"At the start, I would put all of the generated C code into one giant C function with lots of labels and gotos.",0.0,c
14re46t,jqry4o4,"Later, I changed my approach to iteration and that made it easier to turn source functions into isolated C functions.",0.0,c
14re46t,jqry4o4,"One trick I found helpful was to use the C extensions provided by gcc and clang for things like arithmetic overflow checking, scoped labels, and statement expressions.",0.0,c
14re46t,jqrqv56,There are some very good Scheme implementations that compile to c like chicken.,0.15499999999999997,scheme
14re46t,jqrqv56,There are some very good Scheme implementations that compile to c like chicken.,0.15499999999999997,c
14re46t,jqtqyi6,"I've used C as an optional backend (for when I want code to build on Linux instead of Windows, or make use of an optimising compiler).",0.0,c
14re46t,jqtqyi6,"When used as an IL for my own systems language, which although not much higher level than C, it still has enough mismatches:  * My `int` types, literals etc are `i64/u64`; C's literals are `i32/u32` * My string literals have a type roughly equal to `u8*`; C's strings are `char*`, but `char` is a type with unspecified signedness that is neither `i8` nor `u8` * If I want to use C's `puts()` say from my language, via its FFI, I will need to declare `puts` in my syntax using `u8*` equivalant.",0.11875,c
14re46t,jqtqyi6,"When transpiling those, the declarations have to be written as C syntax, but compilers will complain that my `puts(u8*)` doesn't match the standard library version.",0.125,c
14re46t,jqtqyi6,* My arrays have value semantics; C's arrays always decay to pointers * My syntax is expression-based (statements and expressions can be mixed).,0.0,c
14re46t,jqtqyi6,"C isn't, unless you target gnu C (as supported by gcc).",0.0,c
14re46t,jqtqyi6,"* C has lots of UB that can get in the way, for things that are well-defined in both my language and my intended targets (for example, signed integer overflow) * Many constructs in my language, like a 3-way comparison `if f()=g()=h()`, end up being evaluated twice or more in the C (`if (f()==g() && g()==h())`); these all need attention * I use new features like slices, multiple function returns, multiple assignment, which I simply haven't bothered with.",0.18939393939393936,c
14re46t,jqtqyi6,"(To transpile a program to C, I have avoid those features and many more) * All my records (structs) effectively use `pack(1)`, although the majority of fields are properly aligned.",0.4,c
14re46t,jqtqyi6,"* When generating C, the sizes of pointers are hard-coded as either 4 or 8 (or just 8 now as I only do 64 bits), so a particular C rendering can only be compiled as `-m32` or `-m64`, whereas proper C code will work as either * I sometimes use inline assembly.",0.041666666666666664,c
14re46t,jqtqyi6,"* When generating C, the sizes of pointers are hard-coded as either 4 or 8 (or just 8 now as I only do 64 bits), so a particular C rendering can only be compiled as `-m32` or `-m64`, whereas proper C code will work as either * I sometimes use inline assembly.",0.041666666666666664,assembly
14re46t,jqtqyi6,"This is generally accepted, except for Tiny C where you have to use the ridiculous option `-fdollars-in-identifiers`.",-0.09444444444444444,c
14re46t,jqtqyi6,"* C has complex rules to do with mixed arithmetic, which in no way match mine.",-0.15,c
14re46t,jqtqyi6,My whole-program compiler will produce a one-file C rendering of the whole application.,0.2,c
14re46t,jqtqyi6,"There is already a problem where, after taking a few tens of milliseconds to produce the C, it will hit a brick wall as soon as gcc is invoked, but large inputs of tens of thousands of lines combined with `-O2` or `-O3` will make it even slower.",0.007142857142857131,c
14re46t,jqtqyi6,This is where Tiny C is a better match for the output of my compiler.,0.25,c
14re46t,jqtqyi6,"When someone else is responsible for compiling the resulting C, the results can vary.",0.2,c
14re46t,jqtqyi6,"My aims with generating C were mostly met (although it would cramp my coding style as I needed to use cruder features sometimes): I could run code on Linux, and optimisation usually gave a useful speedup.",0.18333333333333335,c
14re46t,jqtqyi6,"The generated C, while I made an attempt to keep it structured, mostly looked dreadful; the mangled names didn't help.",-0.25,c
14re46t,jqtqyi6,"I've also experimented with generating low-level, unstructured C code, with few of C's data types (eg.",-0.2,c
14re46t,jqtqyi6,"I even tried generating from a separate linear IL into C code, but that was awful - so many redundant temporaries and copies, that you *need* an optimising compiler to tidy it all up.",-0.024999999999999994,c
14re46t,jqtqyi6,"Here is my transpiler in action on a 40KLoc project `qq`; `tm` is a timing tool:      c:\qx>tm mm qq                       # Using direct native codegen     Compiling qq.m---------- to qq.exe     TM: 0.09          c:\qx>tm mc -tcc qq                  # Via C and Tiny C     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: tcc  -oqq.exe qq.c c:\windows\system32\user32.dll -luser32 c:\windows\system32\kernel32.dll -fdollars-in-identifiers     TM: 0.27          c:\qx>tm mc qq                       # Via C and gcc -O0     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: gcc -m64   -oqq.exe qq.c -s     TM: 6.36          c:\qx>tm mc -opt qq                  # Via C and gcc -O3     M6 Compiling qq.m---------- to qq.c     W:Invoking C compiler: gcc -m64  -O3 -oqq.exe qq.c -s     TM: 49.51  If I need optimisation (the main reason I would do this on Windows), transpiling to C can take 500 times longer to build.",0.09166666666666667,c
14re46t,jqtqyi6,"But if this is your main way of getting a binary, then Tiny C is the best bet for routine builds unless your programs are small.",0.22916666666666669,c
14re46t,jqsh0ua,> Any good libraries for building C Source?,0.7,c
14re46t,jqsh0ua,"I used both llvm-ir (text) and C. I like the C code better but maybe it's because I wrote that second so it was less rough  I didn't use the tcc lib, I used the binary by spawning multiple processes",0.046666666666666676,c
14re46t,jqtybly,Somehow related: [a list of open source compilers that can generate C code](https://github.com/dbohdan/compilers-targeting-c).,-0.25,c
14re46t,js16hsm,"I have a [public domain 128 bit integer library](https://github.com/aeldidi/int128) which you can use if you want to do that, since C doesn't actually have 128 bit integers.",0.0,c
14re46t,jqs4g9l,"If your language matches C well, then it’s *fine*, as long as you really thoroughly understand the pitfalls of defined behaviour in C. It’s very helpful as a first step for getting something running and interoperating with other code.",0.1486111111111111,c
14re46t,jqs4g9l,"Still I do wish for a better “portable assembler”, because C isn’t quite it.",0.5,c
14re46t,jqs4g9l,"You can also use a C backend as a jumping-off point to start generating native code, or retargetable code (LLVM, JVM, CIL, whatever).",0.0,c
14re46t,jqtnsw8,">the generated binaries were huge (I did inline some stuff but mostly things like refcounting and other small rudimentary stuff, still it added up a lot)  That doesn't look like the fault of using C; presumably the generated C code was also huge?",0.18500000000000005,c
14re46t,jqv3tuf,"It also used generics implemented as specialized copies, that added a lot, but even without that the generated C code of the individual functions was big due to refcnts, handling of exceptions when calling functions and other small stuff that added up.",-0.1,c
14re46t,jqv3tuf,"But maybe the C compilers would handle calling a lot of inlined functions better than directly embedding it, I haven't tested that.",0.3,c
14re46t,jqv3tuf,The main problem is that the C optimizer can't optimize out redundant refcnt operations or other high-level things.,-0.052777777777777785,c
14re46t,jqv3tuf,And I think most people who want to output to C are in the mindset that they wouldn't need to care about optimizations by doing that.,0.5,c
14re46t,jqv3tuf,There was just generation of C code so I don't have a comparison unfortunatelly.,0.0,c
14rdg9d,jr1zb9g,"I'd be interested to see what his opinions are today on the extensibility of languages, and how both Scheme and Java have fared on growth here.",0.25,scheme
14rdg9d,jr1zb9g,"I'd be interested to see what his opinions are today on the extensibility of languages, and how both Scheme and Java have fared on growth here.",0.25,java
14rdg9d,jqtbjm7,Java is a brand name for a computer programming language.,0.0,java
14rdg9d,jqtbjm7,I shall speak of The Java Programming Language™ a great deal more in this talk.,0.65,java
14rdg9d,jqtbjm7,I have to say the full phrase The Java Programming Language™ for there is a guy who works where I do who deals with the laws of marks of trade and he told me I have to say it that way.,0.35,java
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,fortran
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,apl
14rdg9d,jqtbjm7,"Names of other programming languages are Fortran, APL, Pascal, and PL/1.",-0.125,pascal
14rdg9d,jr2hzfz,"Obviously there is a peak, or an answer, to Gossling and Java community at the time, we should not forget that it was a time when Java was marketed heavily as a simpler (better) C++ by trashing some C++ features, in particular operator overloading and multiple inheritance.",0.09333333333333334,java
14rdg9d,jr2hzfz,"Obviously there is a peak, or an answer, to Gossling and Java community at the time, we should not forget that it was a time when Java was marketed heavily as a simpler (better) C++ by trashing some C++ features, in particular operator overloading and multiple inheritance.",0.09333333333333334,c++
14rdg9d,jr2hzfz,"I don't know if Bjarne & Co have seen this talk and have taken a big note from it, but recent C++ development, C++ 11 and further seem to reflect what Steel is talking about big language, extending the language, so the new add-ons feel the same as the language itself, and so on.",0.022727272727272724,c++
14rc8yc,jqrk58j,I’d say “symbol”,0.0,d
14rc8yc,jqrk7zc,"""symbol"" or ""object"" is what I'd probably go with",0.0,go
14rc8yc,jqsousg,"Haskell for example, treats the variables as nullary functions, and therefore no distinction.",0.0,haskell
14rc8yc,jqsasrw,"where and how it's declared/defined, what it stands for, etc) generally go in a **symbol table**, which is an abstraction.",0.05000000000000002,go
14rc8yc,jqsb3bj,"Eiffel uses ""feature"" for pretty well exactly this purpose.",0.25,eiffel
14rc8yc,jqumghg,"Symbol, taken from Lisp.",0.0,lisp
14rc8yc,jr4gu4m,"In Scheme et al, an environment maps **symbols** to **values**.",0.0,scheme
14rc8yc,jqscrtb,you can also go with name.,0.0,go
14ra832,jqr8iif,"Sure it has it's flaws, but I wanted to spend my time on language design not writing optimisers, and there is no other reusable backend with the same performance and transpiling to C is ugly and fragile.",-0.02749999999999999,c
14ra832,jqrc6vj,"I do sometimes use a C backend (although C makes a poor IL), but I know that in that case, the minimal dependency to turn that C into executable binary is under 0.25MB of the Tiny C compiler (a 1.6MB installation, but I only need 2-3 files of it).",-0.125,c
14ra832,jr21znr,"Big things like LLVM, Web Browser(HTML, CSS, js), OS-APIs, SQL (vs the actual relational model that is truly simple), C++, etc is that are BIG.",0.0,html
14ra832,jr21znr,"Big things like LLVM, Web Browser(HTML, CSS, js), OS-APIs, SQL (vs the actual relational model that is truly simple), C++, etc is that are BIG.",0.0,c++
14ra832,jr21znr,"And if you are making C++, LLVM, *THE* way.",0.0,c++
14ra832,jqryx4q,"Rust has some bindings for it, but then I couldn't fully work through documentation on how to use llvm either way.",0.0,rust
14ra832,jqryx4q,I even made c abi for it so I could use it outside of rust.,0.0,c
14ra832,jqryx4q,I even made c abi for it so I could use it outside of rust.,0.0,rust
14ra832,jqspcsh,"Rust does work on different backends, but these have rather low priority and are mostly not ment to replace the LLVM-backend.",-0.08333333333333333,rust
14ra832,jqtzzay,"Well it seems to be the main bottleneck of several compilers including Zig, Crystal, Odin (and probably Rust)",0.08333333333333333,crystal
14ra832,jqtzzay,"Well it seems to be the main bottleneck of several compilers including Zig, Crystal, Odin (and probably Rust)",0.08333333333333333,rust
14ra832,jqrdxuc,Why transpiling to C is ugly and fragile?,-0.35,c
14ra832,jqr8l9x,They mostly compare it to other backends like C and gccjit,0.1875,c
14ra832,jqrsp2b,Nim transpiles to C quite successfully.,0.75,c
14ra832,jqtk2n7,The Rust compiler uses LLVM and it definitely isn't written in C++,0.0,rust
14ra832,jqtk2n7,The Rust compiler uses LLVM and it definitely isn't written in C++,0.0,c++
14ra832,jqsaywh,"Can you expand a little more, is your compiler written in Rust and you also interface with cranelift using its Rust library API, i.e.",0.15625,rust
14ra832,jquv5v8,Just the effort put into llvm to make clang a fast c compiler should be enough to discourage anyone from making their own compiler backend.,0.26666666666666666,c
14ra832,jqsrev7,"I feel like generating text as an internal representation is hard to do elegantly, and unless you want to hook into the AST of some C compiler you will be generating text.",0.06944444444444443,c
14ra832,jqsrev7,"And if you do, you essentially defeat the point as that C compiler will act like LLVM.",0.0,c
14ra832,jqsrev7,"Not only that, unless you are targeting one C compiler, on a single operating system, you will have to account for their differences, and write a lot of tedious logic that locates and calls the compiler.",-0.19047619047619047,c
14ra832,jqsrev7,"A final reason for my newest language is that I explicitly do not want some of C's UB, e.g.",0.0,c
14ra832,jqsrev7,Both of those things require more compiler specific hacks to implement on top of C.,0.3333333333333333,c
14ra832,jqs35iw,C is not the prettiest language to begin with first of all.,0.25,c
14ra832,jqs35iw,"A great example is the Koka language, if you look in the C headers and source files, almost everything is static and inline in order to not incur extra runtime overhead.",0.43333333333333335,c
14ra832,jqsryvf,"If you want to generate C, generate C, it's ugly, but it's an easy way to prototype when you are only targeting one platform and C compiler.",-0.08888888888888886,c
14ra832,jqscm57,"Unfortunately, you couldn't use cranelift without making that c compatible layer.",-0.5,c
14ra832,jqscm57,"&#x200B;  [https://github.com/coffeebe4code/type-lang](https://github.com/coffeebe4code/type-lang)  &#x200B;  I still need to decide how I plan to interface with cranelift\_object, I could make another c ffi to do it, or just give up and go totally to rust.",0.0,c
14ra832,jqscm57,"&#x200B;  [https://github.com/coffeebe4code/type-lang](https://github.com/coffeebe4code/type-lang)  &#x200B;  I still need to decide how I plan to interface with cranelift\_object, I could make another c ffi to do it, or just give up and go totally to rust.",0.0,go
14ra832,jqscm57,"&#x200B;  [https://github.com/coffeebe4code/type-lang](https://github.com/coffeebe4code/type-lang)  &#x200B;  I still need to decide how I plan to interface with cranelift\_object, I could make another c ffi to do it, or just give up and go totally to rust.",0.0,rust
14ra832,jqscm57,"I wanted to continue down the zig path, because it is a lot easier to do certain things, and ""will"" be faster than rust in the future (if not already faster in most places), they also might open up their backend, so i could not need cranelift all together in the future, but that seems very far away.",0.09839002267573696,rust
14ra832,jqscm57,"Either way, +1 cranelift is 1000x easier than llvm, and if you already are doing your language in rust, its a no brainer imo.",0.0,rust
14ra832,jqscm57,"The cranelift people are also really helpful on their zulip chat, lots of lacking documentation, and not clear how to go about using it initially, but after some back and forth.",0.0375,go
14ra832,jqscm57,"The cranelift people are also really helpful on their zulip chat, lots of lacking documentation, and not clear how to go about using it initially, but after some back and forth.",0.0375,forth
14ra832,jqvcb9i,their own C compiler backend,0.6,c
14ra832,jqrot1r,well odin is now com/transpiling to c and zig is making its own backend with blackjack and hookers,0.6,c
14ra832,jqu0259,A valid alternative is usually a C backend,-0.25,c
14ra832,jqtgmfu,[C--](https://en.wikipedia.org/wiki/C--) is another option it inspired Cmm in Haskell,0.0,c
14ra832,jqtgmfu,[C--](https://en.wikipedia.org/wiki/C--) is another option it inspired Cmm in Haskell,0.0,haskell
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,rust
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,kotlin
14ra832,jqu8v55,"The Zig and Rust community won't stop whinging about LLVM, Kotlin and Scala the JVM, etc.",0.0,scala
14ra832,jqu8v55,"I think the characterization of C as ""ugly and fragile"" is _not_ a principled analysis - we should be talking more about some of the benefits you mentioned: expressiveness, performance, interop, distributability, binary size, debugability  and compile time of the target, and whether it was worth the pain.",0.02500000000000001,c
14ra832,jqs9q6l,Any inspiration from Holy C?,0.0,c
14ra832,jqtx0lg,"But... what will the Zig devs actually accomplish, with this R&D opportunity?",0.0,r
14ra832,jqtx0lg,"But... what will the Zig devs actually accomplish, with this R&D opportunity?",0.0,d
14ra832,jqtx0lg,"But then again, I'm not trying to write a C replacement.",0.0,c
14ra832,jqt4cit,"Yeah, it can very easily go either way.",0.5633333333333334,go
14ra832,jqt4cit,"The other is that you end up with something you're happy with, but the community as a whole is less happy, a la like Graydon's talk about his vision for Rust.",0.30166666666666664,rust
14ra832,jqsd6kf,Holy C of TempleOS?,0.0,c
14ra832,jqsd6kf,"No, my stuff was from much earlier than that (from '81), and actually I had nothing to do with C at all, until the 90s when it started turning up in APIs (specifically, Win16 API).",0.0,c
14ra832,jqrzpdo,> Debug build backend for the Rust compiler.,0.0,rust
14r2pkq,,"Also, the compiler output human-readable Typescript code.",0.0,typescript
14r2pkq,jqv95hv,"HTML is in there as well, and I assume it's not a string?",0.0,html
14r2pkq,jqv95hv,It also outputs HTML and TS.,0.0,html
14r2pkq,jqvcx6n,Also the language implements an HTML-like variant it's not really HTML.,-0.1,html
14r2pkq,jqvcx6n,"The output is different languages because your app should eventually has a server (can be implemented using any language but I chose to compile to Node.js) and a client app (which should be HTML, CSS, and JS because that's what run on the browser).",0.0,html
14r2pkq,jqve0a3,Do you parse html or treat it like a string template?,0.0,html
14r2pkq,jqvezh5,"Check this todo app example built using the DSL: [https://github.com/algorizr/thoth/blob/main/examples/todo.thoth](https://github.com/algorizr/thoth/blob/main/examples/todo.thoth)  The code responsible for parsing HTML elements can be found here in the repo: [https://github.com/algorizr/thoth/blob/main/src/analyzer/parsing/helper.ml#L121](https://github.com/algorizr/thoth/blob/main/src/analyzer/parsing/helper.ml#L121)  Also, the code responsible for checking the UI code for any sementic errors can be found here: [https://github.com/algorizr/thoth/blob/main/src/analyzer/type\_checler/xra\_checker.ml](https://github.com/algorizr/thoth/blob/main/src/analyzer/type_checler/xra_checker.ml)  Sorry, the code is not documented and not very clean so it can be a little hard to read.",-0.3300213675213675,html
14qv5lp,,"I just read these two articles about how rust ""solves"" some aspects of ""dependency hell"", and how there are still problems with peer dependencies (which as far as I can tell is a feature unique to Node.js, it doesn't seem to exist in Rust/Go/Ruby, the few I checked).",0.09166666666666666,rust
14qv5lp,,"- [How Rust solved dependency hell](https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell) - [Addressing the shortcomings of peer dependencies](https://hackmd.io/@dzearing/BJifNnpsq)  To be brief, have these issues been solved in dependency/package management, or is it still an open question?",0.0,rust
14qv5lp,jqpj5gs,In C#/Nuget you get one version per library but with build time checks for possible compat issues.,0.0,c
14qv5lp,jqpjuz3,"Well, first off, my thesis of “it isn’t just Rust or JS that has this problem, you know”… I’m not going to call it conclusively demonstrated, but I’ve found some strong support and a couple decent counterpoints.",0.2833333333333333,rust
14qv5lp,jqpjuz3,There are potentially a lot of unexpected dependencies hiding in even a quite small C program.,-0.049999999999999996,c
14qv5lp,jqpjuz3,"A medium-sized Rust project can easily tip the scales at 2-300 crates, which is still rather more dependencies than anything I’ve looked at here, but that’s explained by the simple fact that using libraries in C is such a monumental pain in the ass that it’s not worth trying for anything unless it’s bigger than… well, a base64 parser or a hash function.",0.13055555555555556,rust
14qv5lp,jqpjuz3,"A medium-sized Rust project can easily tip the scales at 2-300 crates, which is still rather more dependencies than anything I’ve looked at here, but that’s explained by the simple fact that using libraries in C is such a monumental pain in the ass that it’s not worth trying for anything unless it’s bigger than… well, a base64 parser or a hash function.",0.13055555555555556,c
14qv5lp,jqpjuz3,">   >The real thing with toools like go, cargo and npm is they move that library management out of the distro’s domain and into the programmer’s.",0.2,go
14qv5lp,jqqchsv,"Rust's Cargo is quite clearly well regarded, but it is complicated.",-0.19999999999999998,rust
14qv5lp,jqqchsv,"For my language, I copied the principles of the Go package manager.",0.0,go
14qv5lp,jqqct5b,This not only solves dependency hell but also enables other cool features.,0.075,cool
14qv5lp,jqr8h94,"If you are a programming language, the rust approach has benefits and drawbacks.",0.0,rust
14qv5lp,jrel9go,It's easy to find rust projects with multiple https and crypto implementations.,0.21666666666666667,rust
14qv5lp,jqscqf7,This not only solves dependency hell but also enables other cool features.,0.075,cool
14qv5lp,jqqgu26,Julia's dep management works great for me,0.8,julia
14qv5lp,jqsrf2v,"For example if you have libA depending on libC v1.1 and libB depending on libC v1.2, in your approach the application that uses both A and B can not pass C typed objects between A and B, because the identifiers wouldn't match?",0.0,c
14qv5lp,jqy3chz,Fwiw here is the result in Rust.,0.0,rust
14qv5lp,jqy3chz,"And once again, Rust error messages take the cake at letting you know what’s going on.",0.0,rust
14qv5lp,jqt9zxt,"That is true, the application using both A and B would have to map the data between the two different versions of C. However, I would not recommend using something related to C when using A and B, A and B should stand on their own.",0.2375,c
14qv5lp,jreikpc,"Parts of the rust ecosystem solve this with the ""semver trick"": upon release of libC v1.2, you can release libC v1.1.1 which includes libC v1.2 as a dependency and reexports all the compatible types.",0.0,rust
14qv5lp,jreikpc,A language can also go further than Rust does to support this.,0.0,go
14qv5lp,jreikpc,A language can also go further than Rust does to support this.,0.0,rust
14qv5lp,jqwz2mg,"It sounds like the scheme you're describing uses internet voting to determine whether updates are good or bad, rather than having an authoritative maintainer (or organization) that chooses whether changes get merged or not.",0.10000000000000003,scheme
14qn9of,jqqlomc,\> No parser   \> Just start with the AST     So... Lisp.,0.0,lisp
14qc538,jqmjfvz,"I watched the video and looks very cool, but one thing that wasn't shown or wasn't clear to me is how it works when you don't have a hard-coded constant?",0.18499999999999997,cool
14qc538,jqn9pf4,I loved this in elixir,0.7,elixir
14qc538,jqn7w3d,Something like what you have here combined with TypeScript's type narrowing?,0.0,typescript
14q21pz,,"[This](https://www.reddit.com/r/rust/comments/svum60/how_the_rust_playground_works/) hints at how the rust playground works, using dynamically generated docker containers to run the rust code in an isolated way on the backend.",0.0,rust
14q21pz,jqlaati,https://godbolt.org is my favorite for C,0.5,c
14pzzs6,,"I am looking at these sorts of things for ""documentation inspiration"" when it comes to programming languages:  - [docs.rs](https://docs.rs/): Documentation for rust packages, generated from source code.",-0.75,rust
14pzzs6,,"In [this rust code](https://docs.rs/log/0.4.19/src/log/lib.rs.html), for example, half of it or more is probably docs instead of code, and I've seen source code files were 90+% is docs instead of code.",0.16666666666666669,rust
14pzzs6,,"- Guides I feel like are better, covering what you need to know in whatever depth (there is even a [rust compiler guidebook](https://rustc-dev-guide.rust-lang.org/) to explain the internals of the compiler code, which is way more helpful than generated API docs on the rust compiler IMO).",0.5,rust
14pzzs6,,"- OTOH, source-code-generated-docs normalize how code docs are, like the rust [docs.rs](https://docs.rs/) paradigm, so it sort of forces or encourages package creators/maintainers to write docs.",0.0,rust
14pzzs6,jqkyghp,If you're building a library then the rust approach is the best since it doesn't clog your code + I think it isn't too much of a problem.,0.6,rust
14pzzs6,jqnnl2d,I think Lua is a good example of doing documentation well.,0.7,lua
14pzzs6,jqnnl2d,"[The API is documented in a single HTML file on the website](https://www.lua.org/manual/5.4/manual.html) that has both the high level descriptions of the language and architecture, as well as documentation for each public-facing function.",0.04428571428571429,html
14pzzs6,jqlswwc,I think your Rust example is a good example of documentation that \*doesn't\* clutter the code unduly.,0.7,rust
14pzzs6,jqmwwjd,"Either way, one thing to learn from the Rust documentation project may be ways to automate testing of code samples in docs so they stay in sync as the code evolves.",0.0,rust
14pzzs6,jqouds0,"It seems like the current best pattern is to have your API docs inline (how does this right here work), and then have optional external documentation that describes how the different parts go together (usually only for bigger projects).",0.18367346938775508,go
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,rust
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,python
14pzzs6,jqouds0,"This is the pattern used by a lot of Rust & Python projects, as well as some of the better documented C libraries.",0.5,c
14pzzs6,jqouds0,"I do this a lot more for Python than other languages (since doc comments break up the function definition and implementation, annoying) but it can help make it less spaced out.",-0.14791666666666667,python
14pzzs6,jqpb6oy,"Haskell can infer most of the types, people really do write them into the code mostly as a means of documentation because they're that useful, and can say a lot more than you can in English with significantly-fewer characters and significantly less room for (mis)interpretation.",0.2619047619047619,haskell
14psfd7,,"(DRY = Don't Repeat Yourself)  This is a bit of C code I encountered today:      uint64_t maxOR(uint64_t a, uint64_t b, uint64_t c, uint64_t d) {         ....     }  The problem for me is that declaration: 4 parameters, all with the same type, but the type has to be written 4 times.",-0.033333333333333326,c
14psfd7,,"(DRY = Don't Repeat Yourself)  This is a bit of C code I encountered today:      uint64_t maxOR(uint64_t a, uint64_t b, uint64_t c, uint64_t d) {         ....     }  The problem for me is that declaration: 4 parameters, all with the same type, but the type has to be written 4 times.",-0.033333333333333326,d
14psfd7,,"This style is common across lots of languages, but C has that extra-cluttery typename, so that I can barely make out the parameter names.",-0.125,c
14psfd7,,"C could at least have gone with `u64`:      u64 maxOR(u64 a, u64 b, u64 c, U6 d) {             # (typo left in)  Now it is much less objectionable, but I would have gone further to:      u64 maxOR(u64 a, b, c, d) {  While C is a lost cause, I wonder why other languages do this as well: create extra maintenance, extra things to check, extra things you can get wrong (one of those types could have been `int64_t` \- not easy to spot in that sea of `uint64_t`).",-0.13083333333333336,c
14psfd7,,"C could at least have gone with `u64`:      u64 maxOR(u64 a, u64 b, u64 c, U6 d) {             # (typo left in)  Now it is much less objectionable, but I would have gone further to:      u64 maxOR(u64 a, b, c, d) {  While C is a lost cause, I wonder why other languages do this as well: create extra maintenance, extra things to check, extra things you can get wrong (one of those types could have been `int64_t` \- not easy to spot in that sea of `uint64_t`).",-0.13083333333333336,d
14psfd7,,"Funnily enough older C allowed you to do this, or along these lines:      u64 maxOR(a, b, c, d) u64 a, b, c, d; {  In my own syntaxes, it usually something like:      func maxor(u64 a, b, c, d)u64 =                # `=> u64` is optional  Types are only repeated when there are no parameter names (as in, FFI declarations, but I can choose to add names to enable keyword parameters).",0.10333333333333332,c
14psfd7,,"Funnily enough older C allowed you to do this, or along these lines:      u64 maxOR(a, b, c, d) u64 a, b, c, d; {  In my own syntaxes, it usually something like:      func maxor(u64 a, b, c, d)u64 =                # `=> u64` is optional  Types are only repeated when there are no parameter names (as in, FFI declarations, but I can choose to add names to enable keyword parameters).",0.10333333333333332,d
14psfd7,jqk3bfo,"If you needed to change the type of b in your example (`u64 maxOR(u64 a, b, c, d) {` ), You would also be forced to redeclare the types of c and d (`u64 maxOR(u64 a, i64 b, u64 c, u64 d) {`).",-0.30000000000000004,c
14psfd7,jqk3bfo,"If you needed to change the type of b in your example (`u64 maxOR(u64 a, b, c, d) {` ), You would also be forced to redeclare the types of c and d (`u64 maxOR(u64 a, i64 b, u64 c, u64 d) {`).",-0.30000000000000004,d
14psfd7,jqk3bfo,"Having to change the way you declare c & d just because you changed the type of b, goes against the spirit of DRY.",-0.06666666666666665,c
14psfd7,jqk3bfo,"Having to change the way you declare c & d just because you changed the type of b, goes against the spirit of DRY.",-0.06666666666666665,d
14psfd7,jqjnj4l,I’d say one reason is that it does not happen enough to make the added complexity in the language worth it.,0.15,d
14psfd7,jqjtzp8,Eiffel manages this.,0.0,eiffel
14psfd7,jqjtzp8,"It uses name : TYPE for variables and parameters, and your parameter list could be stated:     maxor(a, b, c, d : INTEGER) : INTEGER  If multiple types occur, groupings are separated by semicolons:  maxor(a, b, c, d : INTEGER; s : STRING) : INTEGER",0.0,c
14psfd7,jqjtzp8,"It uses name : TYPE for variables and parameters, and your parameter list could be stated:     maxor(a, b, c, d : INTEGER) : INTEGER  If multiple types occur, groupings are separated by semicolons:  maxor(a, b, c, d : INTEGER; s : STRING) : INTEGER",0.0,d
14psfd7,jqkp1uh,"Go has this:      func(a, b int, z float64) bool { return a*b < int(z) }  In this example, `a` is also type `int`.",0.0,go
14psfd7,jqldgy9,"Let me give an example, with just type definitions (which I hope makes it clear)  This is not DRY pseudo-code (no specific language):      type TempCelcius = int;      fun temp_f_to_c(int fahrenheit) -> TempCelcius {...}      type Temp = struct {         int c,         int thousands,     }      fun curr_temp(location at) -> Temp {...}      type Temperature = double;      fun (Element self).melting()->temperature {...}  You can see the problem, we define Temperature in so many places and so differently.",0.1703703703703704,c
14psfd7,jqldgy9,"Because they're two different things then the types should be defined separately, imagine I had a function defined `fun foo(int a, int t, int f, int r, int l)` it might make sense to rewrite it `fun foo(int a,t,f,r,l)` but now imagine I want to change one `fun foo(int a,t, temp f, int f,r,l) and we start to see why it isn't that readable or convenient.",0.22499999999999998,r
14psfd7,jqlacos,"> u64 maxOR(u64 a, b, c, d) {  Frankly I'd rather do  [maxOR a b c d][...]  and infer everything, but I haven't worked out everything yet.",0.0,c
14psfd7,jqlacos,"> u64 maxOR(u64 a, b, c, d) {  Frankly I'd rather do  [maxOR a b c d][...]  and infer everything, but I haven't worked out everything yet.",0.0,d
14psfd7,jqlmgw6,"if you're willing to use C++ you could avoid the repeated explicit types  auto maxOR(uint64\_t a, decltype(a) b, decltype(a) c, decltype(a) d) -> decltype(a) {  // return type same as param 'a' type  (even though it's more typing as in input device and just making them all template params of a single typename T would probably make more sense)",0.2357142857142857,c++
14psfd7,jqlmgw6,"if you're willing to use C++ you could avoid the repeated explicit types  auto maxOR(uint64\_t a, decltype(a) b, decltype(a) c, decltype(a) d) -> decltype(a) {  // return type same as param 'a' type  (even though it's more typing as in input device and just making them all template params of a single typename T would probably make more sense)",0.2357142857142857,c
14psfd7,jqlmgw6,"if you're willing to use C++ you could avoid the repeated explicit types  auto maxOR(uint64\_t a, decltype(a) b, decltype(a) c, decltype(a) d) -> decltype(a) {  // return type same as param 'a' type  (even though it's more typing as in input device and just making them all template params of a single typename T would probably make more sense)",0.2357142857142857,d
14psfd7,jqqp0gu,"If you can declare multiple names to be of some type using `sometype a, b, c` or for that matter `a b c sometype` in one place, you should be able to do so everywhere.",0.25,c
14psfd7,jqqp0gu,"And as usual, this has been true since Algol times, but C screwed it up, maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something.",-0.0638888888888889,algol
14psfd7,jqqp0gu,"And as usual, this has been true since Algol times, but C screwed it up, maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something.",-0.0638888888888889,c
14psfd7,jqqp0gu,"Much as I love C, it is cluttered and inconsistent as few other languages (most of C's own deplorable descendants aside, of course.)",0.11249999999999999,c
14psfd7,jqqp0gu,"And don't get me started on declarators, qualifiers, specifiers, storage classes, attributes, initializers and whatever - suffice it to say that C's declaration syntax is just abominable in general.",0.05000000000000002,c
14psfd7,jqsxijw,"If readability is the complaint, I'd write this as      uint64 maxOR(        uint64 a,        uint64 b,        uint64 c,        uint64 d     ) {      ....      }  Now it's abundantly clear that all the parameter types are the same.",-0.06666666666666665,c
14psfd7,jqsxijw,"If readability is the complaint, I'd write this as      uint64 maxOR(        uint64 a,        uint64 b,        uint64 c,        uint64 d     ) {      ....      }  Now it's abundantly clear that all the parameter types are the same.",-0.06666666666666665,d
14psfd7,jqsxijw,"Changing the language's notation may be an option in Perl, but it is not an option for me.",0.0,perl
14psfd7,jqk4w3k,"However, the choice is always there to use dedicated type denotations for each parameter, but the language won't warn you if one is missed out; here: `(u32 a, i64 b, c, u64 d)`, `c` shares the type of `b`, which may not have been the intention.",0.0,c
14psfd7,jqk4w3k,"However, the choice is always there to use dedicated type denotations for each parameter, but the language won't warn you if one is missed out; here: `(u32 a, i64 b, c, u64 d)`, `c` shares the type of `b`, which may not have been the intention.",0.0,d
14psfd7,jqk2pvr,"In C, four struct members with identical types, followed by one of a different type to address your other point, could be written like this:      struct {         uint64_t a, b, c, d;         int64_t  e;     }  Unless you specifically wanted one member per line (for example if the members weren't related), you wouldn't use separate types like this:      struct {         uint64_t a; uint64_t b; uint64_t c; uin64_t d;         int64_t  e;     }  At least, the choice is there.",-0.10625,c
14psfd7,jqk2pvr,"In C, four struct members with identical types, followed by one of a different type to address your other point, could be written like this:      struct {         uint64_t a, b, c, d;         int64_t  e;     }  Unless you specifically wanted one member per line (for example if the members weren't related), you wouldn't use separate types like this:      struct {         uint64_t a; uint64_t b; uint64_t c; uin64_t d;         int64_t  e;     }  At least, the choice is there.",-0.10625,d
14psfd7,jqk2pvr,"With mixed types, I still use a comma separator between them (just as C does actually); I could have made it stronger with a semicolon, as used the top struct example.",0.16666666666666666,c
14psfd7,jqk2pvr,"I'd write that as this (here I've chosen to use capitalisation to mark the types better; it is case-insensitive):      proc pout(Int n, j, k, Real x1, x2, x3, x4) =  In C however it would be:      void pout(int n, int j, int k, double x1, double x2, double x3, double x4) {  Which is more readable?",0.17142857142857143,c
14psfd7,jqk3m84,I think Pascal and Ada would be similar to this.,0.0,pascal
14psfd7,jqk3m84,I think Pascal and Ada would be similar to this.,0.0,ada
14psfd7,jqk3m84,"It's clearly too much work to duplicate the code that already exists to enable them to declare:      int a, b, c, d  everywhere else in the language!",0.17500000000000002,c
14psfd7,jqk3m84,"It's clearly too much work to duplicate the code that already exists to enable them to declare:      int a, b, c, d  everywhere else in the language!",0.17500000000000002,d
14psfd7,jqk6u8c,"In some ML languages, ``` fun foo (a : int) (b : int) (c : int) (d : int) (s : string) = ... ``` can be written as ``` fun foo (a b c d : int) (s : string) = ... ```",0.3,c
14psfd7,jqk6u8c,"In some ML languages, ``` fun foo (a : int) (b : int) (c : int) (d : int) (s : string) = ... ``` can be written as ``` fun foo (a b c d : int) (s : string) = ... ```",0.3,d
14psfd7,jqmtw9v,"Here is C's famous `for`\-loop which for some inexplicable reason, every other language likes to copy:      for(index = 0; index < N; ++index) {...}  Notice THREE instances of the loop index variable, with two needless repetitions!",-0.2125,c
14psfd7,jqqxvnv,">maybe because it was ""too hard"" to parse `(t a, b, x c)` and determine whether x is a typename or an identifier or something  It shouldn't be hard in C, or any harder than it normally is to parse types that wrap themselves around names, since it will know exactly what every identifier is when encountered.",-0.056666666666666664,c
14psfd7,jqqxvnv,"&#x200B;  >Much as I love C,  You do?",0.5,c
14psfd7,jqqxvnv,"We need such language, but C is a very poor example of it.",-0.26,c
14psfd7,jqqxvnv,This is legal C:      long unsigned const const int typedef long const const T;  It defines T as an alias for `const u64`.,0.03333333333333334,c
14psfd7,jqqxvnv,"Thinking of it, C legalises repetition in several places:      int a, a, a, a, a, a;         // at module scope          void F(int a, int b);     void F(int a, int b);         // parameter names can match ...     void F(int c, int d);         // ... or not     void F(int b, int a);         // ... or be switched     void F();                     // or just forget about them          const const const int;        // like my earlier example     L1:; int L1; goto L1;         // L1 is a variable AND a label!",0.0,c
14psfd7,jqqxvnv,"Thinking of it, C legalises repetition in several places:      int a, a, a, a, a, a;         // at module scope          void F(int a, int b);     void F(int a, int b);         // parameter names can match ...     void F(int c, int d);         // ... or not     void F(int b, int a);         // ... or be switched     void F();                     // or just forget about them          const const const int;        // like my earlier example     L1:; int L1; goto L1;         // L1 is a variable AND a label!",0.0,d
14psfd7,jqqxvnv,But taking pot-shots at C is too easy (and too much fun).,0.3666666666666667,c
14pjx5p,jqjdxqo,"If you view a procedural language as a purely expression-based syntax (like, say, Algol 68,) then you will find that short-circuiting return is just a form of clever syntactic sugar.",0.19047619047619047,algol
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,typescript
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,rust
14piaj7,jqjm3c7,"I added it to the end of my index of Pratt parsing posts:  [Pratt Parsing Index and Updates](https://www.oilshell.org/blog/2017/03/31.html) (2017)  In 2019 we had TypeScript, 2020 Rust, and now Elm :)",-0.125,elm
14piaj7,jqio7u8,"I took a small project (a Basic intepreter) and replaced the main expression parser with the following `pratt()` routine; this shows how it is called:      func readexpr(needtk=1)=         if needtk then nexttoken() fi         pratt(5)     end          func pratt(preclimit)=         l:=readterm()              while tk in binops do             prec:=priotable[tk]             opc:=tk             nexttoken()             if prec<=preclimit then                 exit             else                 r:=pratt(prec)                 l:=mapss(qoptable[opc], l, r)             fi         od         return l     end  On entry to `pratt`, global `tk` already contains the first token of the expression.",0.027777777777777776,r
14piaj7,jqio7u8,"Maybe that `<=` is wrong; changing it to `>=` makes it work, but it goes wrong now with `A + B + C`.",-0.5,c
14pghf5,jqhx6dv,In prolog Definite Clause Grammars can be used to accomplish both verify/generate and parse a list.,0.0,prolog
14pghf5,jqs7jd5,"Output to an intermediate representation that gives hints about where different kinds of whitespace might reasonably go, and then use that IR to schedule line breaks and indentation according to aesthetic heuristics.",0.1,go
14o068e,jqc1q2j,in JavaScript they are kind of similar—because it's a dynamic language with first-class functions/closures—but not the same).,0.19999999999999998,javascript
14o068e,jqc1q2j,"In a language like JavaScript, you can nest function definitions, but you are allocating memory if you do so!",0.0,javascript
14o068e,jqb58hj,"For example let's use braces           x: 5          foo: {(a,b)                    blah blah blah                 }  Using indents                  x: 5         foo: (a, b)->c            blah            blah  or you can try bash style I guess             foo(a,b):{                   blah              }  Personally I don't like significant whitespace but that's just me.",-0.375,c
14o068e,jqb58hj,"For example let's use braces           x: 5          foo: {(a,b)                    blah blah blah                 }  Using indents                  x: 5         foo: (a, b)->c            blah            blah  or you can try bash style I guess             foo(a,b):{                   blah              }  Personally I don't like significant whitespace but that's just me.",-0.375,bash
14o068e,jqa94gs,"Haskell pretty much does this (in a roundabout way): [edited this part out to to inaccuracy]  Using that philosophy, your `main` could look like this:      // The ""null"" program: exits immediately with code 0     // main has type: Int     main = 0  Using a more complex example:      // Says ""hello"" to the first provided argument, or exits with code 1     // main has type: [String] -> Int     main args: [String] = match (first_of args):         Some name:             println (concat ""Hello, "" name)             exit 0         None:             exit 1  Defining a type (here `Option t` is the ""type"" and `Some t`/`None` are the constructors and possible values):      type Optional t:         Some t | None          foo = Some 3 // Has type ""Option Int"" and value ""Some 3""     bar = None // Has type ""Option t"" for any type ""t"" and value ""None""  Defining a typical function:      // Square has type: Int -> Int     square n: Float = n*n  Defining a typical variable:      pi = 3.14159 //...",-0.053125000000000006,haskell
14o068e,jqa94gs,"There are many ways to go about it, this syntax is just an example of Haskell's semantics that I've adapted into a Python-esque indent-based syntax style.",0.5,go
14o068e,jqa94gs,"There are many ways to go about it, this syntax is just an example of Haskell's semantics that I've adapted into a Python-esque indent-based syntax style.",0.5,haskell
14o068e,jqarqkc,"You could take inspiration from scala, which very much supports assigning functions and has type computation.",0.26,scala
14o068e,jqarqkc,Scala 3 also supports classic brackets as well as a custom indent-based syntax.,0.16666666666666666,scala
14o068e,jqafpqw,"I don't think it's bad, it's not unlike JavaScript in a way, so it's not necessarily unfamiliar.",-0.3499999999999999,javascript
14o068e,jqana0u,It can easily be desugared from the C syntax into an assignment.,0.43333333333333335,c
14o068e,jqg2oth,For types I think being more explicit is better:      struct Person          name: Str         age: Int<64>          validatePerson = (input: Person):           // Logic         input                  type CouldBeInvalid = ReturnOf<validatePerson>     type ValidPerson = NominalReturnOf<validatePerson>  I think structural typing is the way to go 90% of the time.,0.08333333333333333,go
14o068e,jqa7dtq,"In Scheme, `(define (f args) body)` is really just syntactic sugar for `(define f (lambda (args) body))`.",0.2,scheme
14o068e,jqbd1hy,Sounds like what haskell does:      add x y = x + y  You could also do      add = with x y return x + y,0.0,haskell
14o068e,jqaonfj,"> Haskell pretty much does this (in a roundabout way): Everything is a function (even single values), and ""types"" are just special kinds of functions (functions that ""hold on"" to their arguments for later de-structuring).",0.14714285714285716,haskell
14o068e,jqaonfj,"Normal ""variables"" are also just functions, so in a roundabout way everything is a variable in Haskell.",0.15,haskell
14o068e,jqaonfj,"Not everything is a function in Haskell, certainly not single values (`""foo""` isn’t a function, it’s a string).",0.03571428571428571,haskell
14o068e,jqaonfj,"It’s somewhat more accurate to say “everything is a _value_ in Haskell”, since functions are values, but even that isn’t very helpful really since there are plenty of non-value concepts in the language.",0.325,haskell
14o068e,jqbtbbc,Haskell only allows this at the top level.,0.25,haskell
14o068e,jqaggnr,"Another angle: would you consider Python to be a language where ""everything is a variable"" like this?",0.0,python
14o068e,jqa8dza,`{ }` denotes a sequence (similar to scheme `begin`).,0.0,scheme
14o068e,jqb9ex6,I consider Python a language where every top-level user identifer (ie.,0.0,python
14o068e,jqb9ex6,This is what makes Python somewhat difficult to optimise.,-0.5,python
14o068e,jqb9ex6,"The only names in Python you can't change are the keywords, and anything else that is a hard-coded built-in.",0.0,python
14o068e,jqbsg16,"In Scheme, everything is a *value*, including the symbols themselves.",0.0,scheme
14ngaly,jqca2ti,Everyone's projects sound so cool!,0.41875,cool
14ngaly,jqca2ti,I've got several irons in the fire with my lang that I keep hopping back and forth on.,0.0,forth
14ngaly,jqca2ti,"I've been chipping away at the (bytecode) compiler, which is *significantly* faster than the (written in Python) interpreter -- and since I'm out of Python-land I can actually do deep recursion.",0.1875,python
14ngaly,jqca2ti,"I wrote the compiler in D -- not because I know or have a great affinity for D, but because I wanted something familiarly C-ish but with niceties like less pointer chasing, dynamic arrays, and strings that make sense -- but I'm starting to feel the pain of writing something in a less-well-known host language, and so started something in C++ for static analysis to both practice and see if that's a better option.",0.2869047619047619,d
14ngaly,jqca2ti,"I wrote the compiler in D -- not because I know or have a great affinity for D, but because I wanted something familiarly C-ish but with niceties like less pointer chasing, dynamic arrays, and strings that make sense -- but I'm starting to feel the pain of writing something in a less-well-known host language, and so started something in C++ for static analysis to both practice and see if that's a better option.",0.2869047619047619,c++
14ngaly,jq7bdod,"I  already had a formatter for my lang and symbol resolution, everything in python with mypy.",0.0,python
14ngaly,jq7bdod,I'm rewriting everything in Haskell as I couldn't stop thinking that something can be incredible wrong with the python code I wouldn't know until it is a problem.,0.2,haskell
14ngaly,jq7bdod,I'm rewriting everything in Haskell as I couldn't stop thinking that something can be incredible wrong with the python code I wouldn't know until it is a problem.,0.2,python
14ngaly,jq7bdod,"Right now I have almost ported the parser, 150 grammar rules from python to Haskell!",0.3571428571428571,python
14ngaly,jq7bdod,"Right now I have almost ported the parser, 150 grammar rules from python to Haskell!",0.3571428571428571,haskell
14ngaly,jq8hffa,"For example, I have written a small tool which takes C Headers as input and produces glue code to call them from my lang.",-0.25,c
14ngaly,jq9wcbd,Realised I was just reinventing a worse version of Rust.,-0.4,rust
14ngaly,jqikc4o,[https://github.com/Gwenio/abyss-lisp](https://github.com/Gwenio/abyss-lisp)  A Lisp based on Kernel.,0.0,lisp
14ngaly,jqb41jz,"I want to be able to go from scratch and have lexer->parser->ast->some passes, in let's say 2 hours.",0.5,go
14ngaly,jqb41jz,"I'm working in Ruby so creating a whole DSL for my ideas is pretty simple, plus it makes everything go very smoothly from one part of the compiler to the other.",0.16899999999999998,ruby
14ngaly,jqb41jz,"I'm working in Ruby so creating a whole DSL for my ideas is pretty simple, plus it makes everything go very smoothly from one part of the compiler to the other.",0.16899999999999998,go
14ngaly,jq94umk,"im keeping changing my mind about my projects, i was making an extended c compiler to write a minecraft-like voxel world generator but i then realized i need to port c++ libraries, useful for gamedev, to c.  i obviously cannot write an extended c++ compiler, but was thinking about a language where you can wrap c++ as easily as in nim, i would implement it in the same way, by compiling to c++ so that i can quickly wrap entire headers (maybe automating this task)  what do you think?",0.17777777777777778,c
14ngaly,jq94umk,"im keeping changing my mind about my projects, i was making an extended c compiler to write a minecraft-like voxel world generator but i then realized i need to port c++ libraries, useful for gamedev, to c.  i obviously cannot write an extended c++ compiler, but was thinking about a language where you can wrap c++ as easily as in nim, i would implement it in the same way, by compiling to c++ so that i can quickly wrap entire headers (maybe automating this task)  what do you think?",0.17777777777777778,c++
14ngaly,jqmrxur,"Timings include transpilation to C, but that is insignificant.",0.0,c
14ngaly,jqmrxur,"(I'm no longer able to transpile M6 to C, so the build-times above could have been even better, but since no app takes longer than 0.1 seconds to build, I wouldn't notice in practice.",0.3333333333333333,c
14ngaly,jqmrxur,**EDIT**: I've managed to transpile `mm6.exe` (M6 compiler) into C and therefore to optimise it via `gcc-O3`.,0.0,c
14ngaly,jqmrxur,Build-times for these apps are now up to 700 times faster than `gcc-O3` building C renderings of those same apps.,0.0,c
14ngaly,jqsr0lp,"Working on `dt` ([site](https://hiljusti.github.io/dt/), [repo](https://github.com/hiljusti/dt))  It's a concatenative programming language targeting the unixy-area of tools for pipes and shebang scripts, kinda like awk/sed/xargs or perl one-liners.",0.0,perl
14ngaly,jqsr0lp,"Previously it was implemented in Rust, and a tenant of a different experimental language/VM called Rail with different semantics and goals.",-0.016666666666666663,rust
14ngaly,jqsr0lp,Moving from Rust was motivated by the ease of cross-compiling and the relative tiny-ness of the produced executables.,0.0,rust
14ngaly,jqxcrhf,"I already dabbled in a simple Lisp-y thing in Rust (an interpreter) and then got to somewhere halfway through Writing a Compiler in Go (in Golang, just keeping the syntax Lisp-y)  As I am going to have afternoons free for the next two weeks, I decided to pick this idea up.",0.13333333333333333,rust
14ngaly,jqxcrhf,"I already dabbled in a simple Lisp-y thing in Rust (an interpreter) and then got to somewhere halfway through Writing a Compiler in Go (in Golang, just keeping the syntax Lisp-y)  As I am going to have afternoons free for the next two weeks, I decided to pick this idea up.",0.13333333333333333,go
14ngaly,jrn73za,"Started out with enums as a set of names denoting different values (a little java-ish), and also that they should be able to index other values (like EnumMap in java).",0.046875,java
14ngaly,jqgxsod,"I've also done a bunch to clean up the internals, and Sophie is now available on the command-line without mentioning Python thanks to some packaging goop, which is nice for usability.",0.3916666666666667,python
14ngaly,jqm37of,"So far my IR is pretty simple, but can be used to implement a subset of C, the next things i want to add are floating point numbers, malloc/free built-ins, global register allocator and eventually FFI.",0.06999999999999999,c
14ngaly,js2ri3a,If interested you can find the [constraint gathering code in C# here](https://github.com/cdiggins/plato/blob/main/PlatoAst/Constraints.cs).,0.25,c
14ngaly,jsv9btb,"I am implementing a language with go style concurrency, I implemented coroutines and channels.",0.0,go
14ngaly,jswo747,Wrote a summary here:  https://jevko.github.io/writing/2023-07-20-lambda.html  Also recently ported my little lambda-calculus-based language to from JS to C: https://codeberg.org/xtao-org/last.c  Been fun debugging the minimal refcounting garbage collector.,0.003124999999999996,c
14ngaly,jswo747,;D,0.25,d
14ngaly,jt322uh,"I'm thinking about implementing a language... (which, if successful, will serve as a second language to my Lua game framework Lyte2D.)",0.11666666666666665,lua
14ngaly,jt322uh,I'm torn between Python and TS.,0.0,python
14ngaly,jt322uh,Leaning towards Python syntax.,0.0,python
14ngaly,jqgdvxi,Very cool features -- I love the easy caching!,0.4988888888888889,cool
14ngaly,jqnf1o8,\> by compiling to c++    I think compiling to another language (transpiling) is a totally viable approach to programming implementation.,0.0,c++
14ngaly,jrl870h,I've just done something else that I should have done long ago: cut most ties with the C language.,0.225,c
14ngaly,jrl870h,That language can come up when dealing with APIs; when trying to build open source stuff; when used as a transpiler target; comparing benchmarks between my language and C; when optimising my apps via the transpiler (see the EDIT PS of my first post).,0.125,c
14ngaly,jrl870h,"So, I've deleted the various C compilers I had lying around: gcc, tcc and Clang, although that last barely worked.",0.016666666666666666,c
14ngaly,jrl870h,"I've archived my `mc` transpiler (M to C compiler), which already only existed in an older compiler version, and which didn't support the full M language.",0.1722222222222222,c
14ngaly,jrl870h,"I will still retain my own `bcc` C compiler, but that's of little help in either optimising, or working on Linux!",0.1828125,c
14ngaly,jrl870h,It includes an option to do the bulk of the work in translating some C APIs into my syntax.,0.0,c
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,c++
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,c
14ngaly,jqngg4b,* C++ [https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser](https://www.codeproject.com/Articles/9121/Parsing-XML-in-C-using-the-YARD-Parser) * C# - [https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp](https://www.codeproject.com/Articles/272494/Implementing-Programming-Languages-using-Csharp)  * TypeScript - [https://github.com/cdiggins/myna-parser](https://github.com/cdiggins/myna-parser)  * C# - [https://github.com/cdiggins/parakeet](https://github.com/cdiggins/parakeet),0.0,typescript
14ngaly,jr56c3i,"i let go of llvm in favor of a python implementation because i don't know much c++, and llvm's tutorial wasn't working.",0.2,go
14ngaly,jr56c3i,"i let go of llvm in favor of a python implementation because i don't know much c++, and llvm's tutorial wasn't working.",0.2,python
14ngaly,jr56c3i,"i let go of llvm in favor of a python implementation because i don't know much c++, and llvm's tutorial wasn't working.",0.2,c++
14ngaly,jt42vke,I'm torn between Python and TS.,0.0,python
14ngaly,jt42vke,Leaning towards Python syntax.,0.0,python
14ngaly,jt42vke,"I'm more of a python guy myself, at the very least it's a language that cares for its syntax to be beginner friendly, in general (but don't go for python's multiple inheritence, it's a disaster)  If by ""not much creativity"" you mean you're happy to use syntax common in other language, that means experienced developpers in those other language would pick up on your language easily, but not necesserly complete beginners  If by ""not much creativity"" you mean overall keeping the syntax small, that means less stuff to learn to master the language, which makes it easier for beginners, but might put off some experienced developpers used to wider syntaxes  The python data model is a nice in between i think, there's a dunder method for anything, \_\_add\_\_, \_\_sub\_\_, \_\_contains\_\_, and so on, each defining the behavior of the class that implents it against whatever operator.",0.10841269841269842,python
14ngaly,jt42vke,"I'm more of a python guy myself, at the very least it's a language that cares for its syntax to be beginner friendly, in general (but don't go for python's multiple inheritence, it's a disaster)  If by ""not much creativity"" you mean you're happy to use syntax common in other language, that means experienced developpers in those other language would pick up on your language easily, but not necesserly complete beginners  If by ""not much creativity"" you mean overall keeping the syntax small, that means less stuff to learn to master the language, which makes it easier for beginners, but might put off some experienced developpers used to wider syntaxes  The python data model is a nice in between i think, there's a dunder method for anything, \_\_add\_\_, \_\_sub\_\_, \_\_contains\_\_, and so on, each defining the behavior of the class that implents it against whatever operator.",0.10841269841269842,go
14ng0eq,jq8a2qd,Does anyone know of an implementation for Rust ?,0.0,rust
14neutn,jqag99u,Scheme is lovely.,0.5,scheme
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,go
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,objective-c
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,swift
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,rust
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,java
14n9a4g,jq6476c,"Convince a prestigious corporation to pick it up and effectively sponsor it, like Google sponsored Go, Apple sponsored Objective-C and Swift, Mozilla sponsored Rust, Sun sponsored Java, AT&T sponsored C, etc.",0.6,c
14n9a4g,jq6ehdb,"Ruby, as a language, was *fine*, but Ruby on Rails made it *wildly popular*.",0.5083333333333333,ruby
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,c
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,c++
14n9a4g,jq66rar,"Give the name some version of 'C' (eg C, C++, C#, Objective-C).",0.0,objective-c
14n9a4g,jq74his,"To get a new language on the map, the best way is to go after a small niche and make your language the absolute best batteries-included way to get things done in that niche.",0.4172727272727272,go
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,php
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,r
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,matlab
14n9a4g,jq74his,"Like how people learned PHP solely because it was good for websites, R & Matlab solely for their scientific tools, and Lua was (for a lot of people) solely a way to make WoW addons.",0.39999999999999997,lua
14n9a4g,jq9579b,"Popularity isn't all of it: the difference between what you achieve privately and a monster language like C++, say, with its vast choice of implementations, tools and libraries, is like that between a home movie and a $100m Hollywood production that employs a crew of a thousand.",0.0,c++
14n9a4g,jq9579b,"Maybe that's a journey you want to go on, but it's not something that would appeal to me.",0.0,go
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,c
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,java
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,javascript
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,go
14n9a4g,jq69vob,"C#, Java, Javascript, Go, Rust and C all had them.",0.0,rust
14n9a4g,jqkt09d,"a lot of people pick up a new language, go ""wow!""",0.13068181818181818,go
14n9a4g,jqqmejy,"Before you go down this road, also understand exactly what you would want out of popularity.",0.04722222222222221,go
14n9a4g,jqc515c,Though Lua is perhaps not the best example because it wasn't aimed at the niche they found.,1.0,lua
14n9a4g,jqc515c,"It was designed as a general-purpose scripting language but someone at Lucasfilm Games read about it in Dr Dobbs' Journal and thought it was way better than their in-house scripting language, and so Lua got into gamedev and it sort of snowballed.",0.5,lua
14n9a4g,jqgr4m9,I trust it's more interesting than Paul Graham's claim that Lisp was the magic sauce behind getting Yahoo to buy him out?,0.275,lisp
14n9a4g,jq6itm8,"It's worth mentioning that various ""web"" languages, such as Python and Ruby, didn't have corporate sponsors initially.",0.06,python
14n9a4g,jq6itm8,"It's worth mentioning that various ""web"" languages, such as Python and Ruby, didn't have corporate sponsors initially.",0.06,ruby
14n9a4g,jq6itm8,"Guido didn't go to work for Google and get their support, until a fairly long time into Python's history.",-0.05,go
14n9a4g,jq6itm8,"Guido didn't go to work for Google and get their support, until a fairly long time into Python's history.",-0.05,python
14n9a4g,jqoxa9m,"Go read old BYTE magazines, there were ads for compilers back then!",0.05,go
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,swift
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,go
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,rust
14n9a4g,jqoxa9m,"- Swift, Go, Rust, C were all I think instances of ""self-motivated small team of engineers in a company do an independent side project, eventually once it's working-ish get parent company interested enough to sponsor further development as a bet / way to keep engineers happy with a toy project"".",0.13333333333333333,c
14n9a4g,jqoxa9m,"- Java was started as an _inducement_ to a Sun employee to remain at the firm, basically a bribe -- ""do whatever you feel like so long as you stay here"".",-0.125,java
14n9a4g,jqoxa9m,"I would generalize this to ""most R&D""; almost always it's started outside company planning -- government or academic labs, occasional personal projects -- and companies join in funding once it's already underway.",0.1,r
14n9a4g,jqoxa9m,"I would generalize this to ""most R&D""; almost always it's started outside company planning -- government or academic labs, occasional personal projects -- and companies join in funding once it's already underway.",0.1,d
14n9a4g,jq69rtt,"If you measure success by having as much adoption as newer languages like C# or Swift, your odds are going to be very low without a major backer.",0.140625,c
14n9a4g,jq69rtt,"If you measure success by having as much adoption as newer languages like C# or Swift, your odds are going to be very low without a major backer.",0.140625,swift
14n9a4g,jqew37k,"[There's a nice writeup of the history on Lua's website if anyone wants more of the story, which is pretty interesting](https://www.lua.org/history.html).",0.3875,lua
14n9a4g,jqjmknq,"Another part of the story that's important, is **LuaJIT** was primarily responsible for game industry popularity, and it is not part of the core Lua development.",0.0666666666666667,lua
14n9a4g,jqjmknq,"Whereas, Lua devs' primary goal was to be easily embedded on all platforms.",0.4166666666666667,lua
14n9a4g,jqjmknq,"Because they did not agree on goals, and architecture necessary to achieve the different goals, Lua did not incorporate LuaJIT performance increases.",0.0,lua
14n9a4g,jqjmknq,They were compatible at Lua version 5.1 and then the 2 developments went their separate ways.,0.0,lua
14n9a4g,jqjmknq,"Meanwhile Lua proper is on version 5.4.6, with 5.1 being quite awhile ago in the Lua rear view mirror.",0.0,lua
14n9a4g,jqjmknq,Lua also doesn't attempt to retain backwards compatibility.,0.0,lua
14n9a4g,jqjmknq,This prevents any long term ecosystem from stabilizing around Lua.,-0.05,lua
14n9a4g,jqjmknq,"Like to the extent game devs care about Lua, they're likely to use 5.1 forever.",-0.2,lua
14n9a4g,jqjmknq,"Personally as a lone wolf indie game developer, I pretty much gave up on the idea of Lua 1) because its ecology is rearguard and will never amount to anything, and 2) I personally can't think about 3D math in terms of Lua.",0.008333333333333331,lua
14n9a4g,jq6bo6p,Having the language be open source and getting people to contribute can also go a long way to building a community that uses the language.,-0.025,go
14n9a4g,jq6g6gq,"*Or*, they might get some new corporate suit manager who cuts costs, hires new people, and orders everybody to rewrite everything in C++.",0.0909090909090909,c++
14my9mx,,"Hello everyone, I have shared two posts about GQL (Git Query Language) on this subreddit and this week I want to share some cool updates for version 0.2.0  **For Full Docs, Code, Binraires and samples**     Github: [https://github.com/AmrDeveloper/GQL](https://github.com/AmrDeveloper/GQL)     **Order by DSC and ASC**     Now you can explicitly set the order of your data to be Ascending and Descending  **Group by** statement      groups rows that have the same values into summary rows  **Aggregation functions**     Now you can use Aggregation functions like count, and max to perform calculations on the current group, this feature is very useful when used with group by statement.",0.056666666666666664,cool
14my9mx,,"`SELECT name, count(name) AS commit_num FROM commits GROUP BY name ORDER BY commit_num DES LIMIT 10`     **Alias Column name**  `SELECT max(commit_count) as max_commit_count from branches`  **Having statement**  After introducing, Group by statement it must implement having  statement to perform filtration after grouping data  `SELECT name, count(name) AS commit_num FROM commits GROUP BY name HAVING commit_num > 0`  **Between expression**  `SELECT commit_count FROM branches WHERE commit_count BETWEEN 0 .. 10`  The project is now in the early stages and there are a lot of cool things to do, everyone is most welcome to join, contribute and learn together",0.4375,cool
14my9mx,jq4hxy4,Cool.,0.35,cool
14my9mx,jq4pyae,"Sure you are right, my plan is to optimize code then in some places i can run on multi threads easily for example aggregations function run on each group and the result are related only to one group so we can run functions for each group on speared thread, the sample arecfrom rust analysis repo with around 30k commit and it works fine, but later will be very fast",0.23696428571428574,rust
14mno1w,jq6m8ml,"As if that wasn't enough, most of the comments in the issue thread are clear that low-friction integration with C++ builds is a big part of why many people are using Zig.",0.22000000000000003,c++
14mno1w,jq3n5vl,"There's no way I am porting the entirety of LLVM, it's dependencies and a C++ compiler.",0.0,c++
14mno1w,jq6485u,"Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,go
14mno1w,jq6485u,"Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,c
14mno1w,jq6485u,And it's usually compared to Java which had/ has decades of more speed optimizations behind it.,-0.05000000000000001,java
14mno1w,jq6485u,Yet I have seen no complaints that Go is slower than Java.,0.0,go
14mno1w,jq6485u,Yet I have seen no complaints that Go is slower than Java.,0.0,java
14mno1w,jq6485u,LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,c
14mno1w,jq6485u,LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,c++
14mno1w,jq6485u,"Lastly, I'm really interested to see how the C interop will go.",0.25,c
14mno1w,jq6485u,"Lastly, I'm really interested to see how the C interop will go.",0.25,go
14mno1w,jq6485u,Their easy inclusion of C files was a big selling point early on.,0.17777777777777778,c
14mno1w,jq7fwgb,"Haven't seen it mentioned anywhere, but one solution for not having to deal with C++ compilation is to simply compile LLVM to WebAssembly and convert it back to C.  Mozilla already uses that approach for sandboxing ([link](https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/)).",0.0,c++
14mno1w,jq5rtoo,"He wrote the Datalight C compiler from scratch, including the codegen back-end.",0.0,c
14mno1w,jq5rtoo,"That same back-end has been in a lot of different compilers, including the Symantec C++ compiler which also holds the distinction of being the first compiler to turn C++ directly into a binary format without first transpiling to C.  This codegen back-end has been actively maintained and updated since the 1980s and is now part of the Digital Mars C++ compiler, and the reference compiler for D (also created by Walter).",0.06666666666666667,c++
14mno1w,jq5rtoo,"That same back-end has been in a lot of different compilers, including the Symantec C++ compiler which also holds the distinction of being the first compiler to turn C++ directly into a binary format without first transpiling to C.  This codegen back-end has been actively maintained and updated since the 1980s and is now part of the Digital Mars C++ compiler, and the reference compiler for D (also created by Walter).",0.06666666666666667,d
14mno1w,jq5rtoo,"Impressive as all that is, it didn't take long for people to lift the front-end from the reference D compiler and slap it on top of both LLVM and GCC back-ends, and within the D community it's generally preferred to use either LDC (LLVM D Compiler) or GDC (GNU D Compiler) when deploying code to production because they both have better optimization, cross-compilation support, more arch targets, and are just generally more feature-rich.",0.42857142857142855,d
14mno1w,jq401ax,"Also note: Cranelift, the rust only JIT compiler backend, is already at LLVM-JIT speeds, or within 10% of those, so I think it is completely possible for Zig to have an LLVM like backend.",0.0,rust
14mno1w,jq5yx74,The C backend is not the replacement backend.,0.0,c
14mno1w,jq5yx74,"LLVM does not have a C backend, that's an extra bonus that zig offers.",0.05,c
14mno1w,jq5hwlh,"To be fair, ""delegate everything to the C compiler"" is easier than integrating with LLVM in the first place.",0.475,c
14mno1w,jq5s4xf,C++ is still fumbling with const/constexpr/consteval.,0.0,c++
14mno1w,jq6qbia,Java isn't somehow the gold standard here.,0.0,java
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,go
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,c
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,c++
14mno1w,jq6qbia,"CPU-bound Go is substantially slower than C, C++, and Rust.",0.0,rust
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,c
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,c++
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,go
14mno1w,jq6qbia,"Since Zig has been courting the C & C++ crowd from day 1, it's relevant to compare to them, not to compare to Go or Java.",0.4,java
14mno1w,jq6qbia,"Some of Go's slowness is due to language specification decisions which cannot be amended now \[1\], but a *lot* is due to reinventing optimizations that other compilers have had for years, and Zig is currently enjoying via LLVM even if LLVM integration itself takes some work.",0.03125,go
14mno1w,jq6qbia,"That's *despite* Go having Google's weight behind it, and a huge Go footprint at Google making a ripe target for optimization with ROI.",2.7755575615628914e-17,go
14mno1w,jq6qbia,"It's also part of why idiomatic Rust *can be* faster than idiomatic C, because it's like having the speed of `restrict` everywhere with none of the UB.",0.0,rust
14mno1w,jq6qbia,"It's also part of why idiomatic Rust *can be* faster than idiomatic C, because it's like having the speed of `restrict` everywhere with none of the UB.",0.0,c
14mno1w,jq8u5gg,>  Their easy inclusion of C files was a big selling point early on.,0.17777777777777778,c
14mno1w,jq8u5gg,Zig being a drop-in replacement for your entire C++ toolchain is *still* one of the three major selling points advertised on the website.,0.03125,c++
14mno1w,jqkofc3,"> Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,go
14mno1w,jqkofc3,"> Just for a related example: The language Go has it's own compiler, it doesn't use C as a backend nor LLVM or GCC.",0.3,c
14mno1w,jqkofc3,And it's usually compared to Java which had/ has decades of more speed optimizations behind it.,-0.05000000000000001,java
14mno1w,jqkofc3,Yet I have seen no complaints that Go is slower than Java.,0.0,go
14mno1w,jqkofc3,Yet I have seen no complaints that Go is slower than Java.,0.0,java
14mno1w,jqkofc3,Go prioritizes compiler speed over final executable speed.,0.0,go
14mno1w,jqkofc3,Using LLVM would be a non-starter for them (see Rust).,0.0,rust
14mno1w,jqkofc3,Zig on the other hand wants to be a sort of competitor to C. And being a competitor to C means that you need fast executables.,0.09166666666666667,c
14mno1w,jqkofc3,C is spoiled with a ton of work being put into optimizing compilers.,0.0,c
14mno1w,jqkofc3,> LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,c
14mno1w,jqkofc3,> LLVM is sometimes seriously hindered by it's primary focus on C and C++.,0.1,c++
14mno1w,jqkofc3,It’s filled with people who are complaining that their multi-language projects (including C++) rely on Zig’s current compiler architecture.,0.2,c++
14mno1w,jq97mwp,I do something of the sort by having a path to generate C source code.,0.0,c
14mno1w,jq97mwp,"Then I can apply `gcc-O3`, or I can even get Clang, which just about works (it doesn't have working standard C headers, or a linker), to generate LLVM IR.",0.0,c
14mno1w,jq5rw4a,"Just targeting LLVM text IR (similar to what llvmlite does in Python) is just text generation, and can still be fed into LLVM tools or the API via IR parsers.",0.0,python
14mno1w,jq5rw4a,"But, it decouples you from troubles of linking and versions of the LLVM C++ codebase.",0.0,c++
14mno1w,jqknlv8,There’s also the advantage that C++ has that you have more control over your API by having to explicitly declare it “const” (_edit_: or maybe I’m thinking of “constexpr”?).,0.5,c++
14mno1w,jqknlv8,"Zig’s approach seems more like a cool *academic* approach, not something that a pragmatic language should really strive for.",0.2625,cool
14mno1w,jqknlv8,(It goes without saying: doing something better than C++ is not an achievement in current year.),0.25,c++
14mno1w,jq5t0ag,It is true c++ is a behemoth of complexity,0.35,c++
14mno1w,jq4rrpw,Also the zig guys are spreading propaganda such as zig is faster than c. The reason was because they were using compile time stuff in their zig program but didn’t in their c program.,-0.05,c
14mno1w,jwcm3hn,Even GO could REALLY benefit from LLVM.,0.2,go
14mno1w,jwcm3hn,Switching from debug to release builds in C++ can alone gain an order of magnitude in performance - and all you had to do was flip a switch in the compiler.,0.0,c++
14mno1w,jwcm3hn,"If the GO contributors and Google were smart, they’d seriously consider LLVM for release builds.",-0.05952380952380952,go
14mno1w,jwcm3hn,"If the GO contributors and Google were smart, they’d seriously consider LLVM for release builds.",-0.05952380952380952,d
14mno1w,jqr2ce0,So that maps semantically to unsafe C functions dealing with void\* parameters.,0.0,c
14mno1w,jqr2ce0,"The ""how"" is a separate concern - in other mainstream languages such as Rust there is a duplicated mechanism within the language: ""generics"".",-0.0625,rust
14mno1w,jqr2ce0,"For example, instead of a separate \`where\` clause mechanism as in Rust, it could be  done much more ergonomically IMO if we simply had Zig's \`comptime\` combined with DBC (design-by-contracts).",0.25,rust
14mno1w,jq64i5n,"You’re limited by what the hardware and OS let you do, and they’re heavily influenced by C, so the only way of going “faster than C” is to address a *limitation* imposed by C that makes it hard to write a fast program conveniently/correctly/reliably/&c.",-0.07261904761904761,c
14mno1w,jq96jj5,"I think partially Andrew Kelley could have worded the proposal better (putting proposal in the title, not using future tense such as ""this will remove C++ compilation""), and partially they are getting the feedback they asked for.",-0.00555555555555555,c++
14mno1w,jqdniwa,Yet I do still have a path (via a C backend) to optimise *some* programs (since the translation is not 100%).,0.0,c
14mno1w,jq8bc6v,It might take many years to gain parity with all possible use cases of a C replacement.,0.25,c
14mno1w,jq8y2mw,"Not true, java python go etc … are slower than c because of their design choice",-0.175,java
14mno1w,jq8y2mw,"Not true, java python go etc … are slower than c because of their design choice",-0.175,python
14mno1w,jq8y2mw,"Not true, java python go etc … are slower than c because of their design choice",-0.175,go
14mno1w,jq8y2mw,"Not true, java python go etc … are slower than c because of their design choice",-0.175,c
14mhu3o,,"These types function similarly to how they work in TypeScript, so if you've ever wanted to know more about how TypeScript's type system works this might be helpful.",0.25,typescript
14mhu3o,jq78ltw,"I was just talking about how they function in the type checker, TypeScript style unions.",0.0,typescript
14mhu3o,jq2jv1z,"""for all c: c -> c"" is a subtype of ""for all a, b: (a, b) -> (a, b || a)"".",-0.75,c
14mhu3o,jq3g2bq,"> `for all c: c -> c` is a subtype of `for all a, b: (a, b) -> (a, b || a)`  Is that really the case, or am I misunderstanding the problem?",-0.43333333333333335,c
14mhu3o,jq3g2bq,Should it not only be the case that `c -> c` is a subtype of `a & b -> a & b` if `c` is constrained to be `a & b` rather than universally quantified?,0.0,c
14mhu3o,jq3g2bq,"(ie, `forall c` should not be there, but it should be a constraint quantifier: `forall c, c <: a & b`).",0.0,c
14mhu3o,jq3g2bq,"Consider:      class A a     class B b     class (A c, B c) => C c      baz :: (A c, B c) => (c -> c) -> c -> c      quux :: C c => c -> c  Where we want to be able to use a value of the type `C c => c -> c` where type `(A c, B c) => c -> c` is expected - eg, call `baz quux`, but we don't want to allow a value of `(A c, B c) => c -> c` to be used where `C c => c -> c` is expected.",-0.11249999999999999,c
14mhu3o,jq3g2bq,"(Because not all `a & b` are `c`, but all `c` are `a & b`)",0.0,c
14meda1,jq69gkf,"However, if you know the compilation scheme used by the programmer, you can exercise surprisingly good control over such things.",0.35,scheme
14mbu1p,jq2g366,"As I'm a little unexperienced on the field, my initial thoughts were that my testing mechanism was kind of 'naive', but I'm glad to discover that such approach kind of common c: (I this will definitely help a lot in the future as well).",0.01477272727272726,c
14mbu1p,jq2mnau,You led me to think of another super interesting approach by describing your own c:,0.4777777777777777,c
14mbu1p,jq5jivu,This black box testing is not just catching parser errors but all sorts of things that might go wrong as I also liberally sprinkle asserts in the code to check assumptions.,-0.022222222222222216,go
14m98qv,jq0s9gk,"`a := []int{}`  `b := [10]int{}`  `c := map[string]string{}`  I've given up trying to understand the decisions that drove Go's design, I just use the recommended practices at this point.",0.0,c
14m98qv,jq0s9gk,"`a := []int{}`  `b := [10]int{}`  `c := map[string]string{}`  I've given up trying to understand the decisions that drove Go's design, I just use the recommended practices at this point.",0.0,go
14m98qv,jq1rvy5,"`v := make([]int, 10)` is shorthand for      var v []int     {         var tmp [10]int         v = tmp[:]     }  while `v := make([]int, 0, 10)` is short for      var v []int     {         var tmp [10]int         v = tmp[:0:len(tmp)]     }  Because slices are so common in Go, `make` is an extremely useful convenience.",0.125,go
14m98qv,jqa22dp,"``` // Probably the main use case: make a buffer for something buf := make([]byte, bufSize)  // Data conversion ids := make([]ID, len(strs)) for i, s := range strs {     ids[i], err = parseID(s)     // if err ... }  // Running jobs or something jobs := make([]Job, tasks) for i, t := range tasks {     i, t := i, t      jobs[i] = Job{         donec: make(chan struct{}),     }      go func() { /* ... */ }() }  // And I preallocate sometimes, but more frequently just use append and reuse buffer.",0.25555555555555554,go
14lcvm1,,"If this makes somehow sense to you, I would like to go one step further and map concrete CWEs to the chomsky hierarchy.",0.07500000000000001,go
14lcvm1,jpy89b2,The C programming language has five decades of backwards-compatible cruft layered on.,0.0,c
14lcvm1,jpy89b2,"You can't make silk purse from a sow's ear, and you can't test quality into a system, and you can't call C a tool-chain that provides any assurance of reliable or safe software.",0.5,c
14lcvm1,jpy89b2,"I mean it may look like C, but any nontrivial property is undecidable.",-0.3125,c
14lcvm1,jpwgdqt,"&#x200B;  >Yes, LLMs can only be as good as a lexical static analyzer  Cool, that means that my idea is not completely wrong.",0.36,cool
14lcvm1,jpwgdqt,"I think it is hard to show it empirically, since datasets and so forth may be heavily biased, models tend to overfit on artifacts/coding styles and so on.",-0.13055555555555556,forth
14lcvm1,jpxdgsw,"There are high-quality C parsers (e.g., libclang), so it makes no sense not to just use those.",0.0,c
14lcvm1,jpxdgsw,"It’s a worthy discussion, since some languages (e.g., C++) are not context-free.",0.3333333333333333,c++
14lcvm1,jq0jzxi,Im going to deanonymize myself with that but here it is :D  [https://mlsec.org/docs/2023-eurosp.pdf](https://mlsec.org/docs/2023-eurosp.pdf),1.0,d
14kzoiz,jpwc6sm,"Just jump on the next plane to Denmark and there you go, a year of hacking with u/jozefg, let the cool stuff happen.",0.175,go
14kzoiz,jpwc6sm,"Just jump on the next plane to Denmark and there you go, a year of hacking with u/jozefg, let the cool stuff happen.",0.175,cool
14kzoiz,jq05i0l,"I find that stuff very interesting but, as tempting as it is, I won't go into it here.",0.65,go
14kf214,jq5fa8c,A1 is such a cool name for a language,0.175,cool
14k9c5x,jpr1ry2,are handled by the underlying Fortnite game engine (presumably written mostly in C++).,0.04999999999999999,c++
14k9c5x,jpsfeqm,If I have the operations a \* b \* c \* d then you do a*b while you do c\*d (while you do e\*f...) and then finish up by \*ing the results (possibly also concurrently).,0.0,c
14k9c5x,jpsfeqm,If I have the operations a \* b \* c \* d then you do a*b while you do c\*d (while you do e\*f...) and then finish up by \*ing the results (possibly also concurrently).,0.0,d
14k9c5x,jpqe2z5,I hope so because that would be really cool if they reconcile that concurrency model with the rest of the language.,0.35,cool
14k3frc,jpq54j8,:D so it's like a C on your A-F tier [ranking](https://www.youtube.com/watch?v=AzLqTgC0E0s)?,1.0,d
14k3frc,jpq54j8,:D so it's like a C on your A-F tier [ranking](https://www.youtube.com/watch?v=AzLqTgC0E0s)?,1.0,c
14k3frc,jpq54j8,"I'm firmly in the prolog camp these days as my main lang but, having come from haskell, and haskell's type system having been what attracted me to it in the first place, and static analysis being sorely missing from prolog, I have to say, a functional logic cross paradigm lang with this much academic backing and a ""Static Proof Search fixes everything"" approach, even if fallacious or hyperbolic, sounds interesting to me.",0.1685185185185185,prolog
14k3frc,jpq54j8,"I'm firmly in the prolog camp these days as my main lang but, having come from haskell, and haskell's type system having been what attracted me to it in the first place, and static analysis being sorely missing from prolog, I have to say, a functional logic cross paradigm lang with this much academic backing and a ""Static Proof Search fixes everything"" approach, even if fallacious or hyperbolic, sounds interesting to me.",0.1685185185185185,haskell
14k3frc,jprtgib,"Check out Mercury if you haven't already, it's a blend between Prolog and Haskell including support for linear types and typeclasses.",0.0,prolog
14k3frc,jprtgib,"Check out Mercury if you haven't already, it's a blend between Prolog and Haskell including support for linear types and typeclasses.",0.0,haskell
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,typescript
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,lisp
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,c
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,haskell
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,c++
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,rust
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,python
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,forth
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,d
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,java
14k3frc,jpso0zp,"S:  Typescript, Lisp, Smalltalk  A:  C, Haskell  B:  C++, Rust, ATS  C:  Python, Forth  D:  Java, F#  F:  Javascript, C#",0.0,javascript
14j52c8,,"The type system I chose to design largely mimics Typescript, except that it supports both structural and nominal typing.",0.21428571428571427,typescript
14j52c8,,"**Using KeyOf and ValueOf to get a specific value:**      type KeyOf[T: Object] = T.keys() as Union     type ValueOf[T: Object] = T.values() as Union          type GetT = (T: Object, K: KeyOf(T)): ValueOf(T) => T[K] as Literal          const x: String = GetT({a: ""John"", b: ""Stacey""}, ""a"")          println(x)           // John          const y = GetT({a: ""John"", b: ""Stacey""}, ""c"")          // Error in 'source' @ (12, 50): Type function 'GetT' expects argument 'K' to be of type 'b | a'  The above error would happen at compile time.",-0.25,c
14j52c8,,"**Using Extract to extract specific types from a union:**      type Extract[T, U] = (T as Iterator).filter((E) => U is E) as Union          type BunchOfTypes = String | Number | (() => Number) | (() => String) | ((x: String, y: String) => String) | Boolean          type FunctionTypes = Extract(BunchOfTypes, Function)          println(FunctionTypes)          // () => Number | () => String | (x: String, y: String) => String  And here's a quick look at how hooks can now be used (and also why they are useful to add constraints at runtime):      const capColor = (c: Number) => {         if (c < 0) {             c = 0         } else if (c > 255) {             c = 255         }     }          type Color = {         r: Number = 0,         g: Number = 0,         b: Number = 0,         _init = () => {             this.values().map((v: Number) => {                 capColor(v)                 v::onChange((p) => {                     capColor(p.new)                 })             })         }     }          var color = Color {r: 344}     color.g = -10     color.b = 30          var color2 = Color {r: 344}     color2.g = -10     color2.b = 455          color2.b = -100          println(color, color2)          // Color { r: 255 g: 0 b: 30 }     // Color { r: 255 g: 0 b: 0 }  **Explanation:**  We create new type `Color`, and within that type we declare an `_init` function that runs whenever that an object is instantiated with that type.",-0.2114718614718615,c
14j52c8,,"**Using Extract to extract specific types from a union:**      type Extract[T, U] = (T as Iterator).filter((E) => U is E) as Union          type BunchOfTypes = String | Number | (() => Number) | (() => String) | ((x: String, y: String) => String) | Boolean          type FunctionTypes = Extract(BunchOfTypes, Function)          println(FunctionTypes)          // () => Number | () => String | (x: String, y: String) => String  And here's a quick look at how hooks can now be used (and also why they are useful to add constraints at runtime):      const capColor = (c: Number) => {         if (c < 0) {             c = 0         } else if (c > 255) {             c = 255         }     }          type Color = {         r: Number = 0,         g: Number = 0,         b: Number = 0,         _init = () => {             this.values().map((v: Number) => {                 capColor(v)                 v::onChange((p) => {                     capColor(p.new)                 })             })         }     }          var color = Color {r: 344}     color.g = -10     color.b = 30          var color2 = Color {r: 344}     color2.g = -10     color2.b = 455          color2.b = -100          println(color, color2)          // Color { r: 255 g: 0 b: 30 }     // Color { r: 255 g: 0 b: 0 }  **Explanation:**  We create new type `Color`, and within that type we declare an `_init` function that runs whenever that an object is instantiated with that type.",-0.2114718614718615,r
14j52c8,jplonyh,C++ uses `FT CT::*` for a reason.,0.0,c++
14j52c8,jplsoqv,"But you can use refinement types + multiple dispatch to get something similar:      type LessThan10 = (x: Number) => x < 10     type Is42 = (x: Number) => x == 42          const func = (x: LessThan10) => x      const func = (x: Is42) => ""cool"" as Literal      const func = (x) => ""hi""          println(func)          // Output //          (x: LessThan10) => Number     (x: Is42) => cool      (x: Any) => hi  These refinement types also work at compile time, however if the values aren't actually known then they will fail.",-0.3227272727272727,cool
14j52c8,jptg0f3,"Does it correctly determine that ""for all c: c -> c"" is a subtype of ""for all a, b: (a, b) -> (a, b | a)""?",-0.75,c
14j52c8,jptksex,"Can a value of type ""for all c: c -> c be used in a place where a value of type ""for all a, b: (a, b) -> (a, b | a)"" is required?",-0.75,c
14iz6jf,,I'm working on a *“TypeScript but better”* type of language.,0.5,typescript
14iz6jf,,"The language would get statically typed errors for free, with better support for error subtyping than Rust's monad-based *Result* as a bonus.",0.45,rust
14iz6jf,,"If I tell them to use monads or effects for state mutations, most of them will just return to JavaScript land instead.",0.5,javascript
14iz6jf,jpkchd1,">this isn't really OOP  There [doesn't seem to be consensus](https://doc.rust-lang.org/book/ch17-00-oop.html) whether Rust is OOP or not – it lacks inheritance, but has instantiation, delegation, limited encapsulation, etc.",0.0642857142857143,rust
14iojtb,jpi7ceb,IMO it is executed much better than yours because Lisp is a much better suited language.,0.5,lisp
14iojtb,jpics4d,"I never used Lisp, but I'll check it out for sure!",0.625,lisp
14iojtb,jpidn1a,"However, the concept applies to UI quite gracefully, so consider using a Lisp next.",0.0,lisp
14in0pn,jphjpc9,The simplest and fastest way to do it for you is to simply go up in levels when searching:      var name = fullyQualifiedName.split('.,0.0,go
14ic9c8,,I don't know I would love to write my code in pure 0s and 1s or in assembly (because i didn't ask for low or middle level languages..?,0.17857142857142858,assembly
14ic9c8,,"yeah that too, but I'm asking for high level language such as rust, c, go, cobol, fortran, nim, v, etc.)",0.08,rust
14ic9c8,,"yeah that too, but I'm asking for high level language such as rust, c, go, cobol, fortran, nim, v, etc.)",0.08,c
14ic9c8,,"yeah that too, but I'm asking for high level language such as rust, c, go, cobol, fortran, nim, v, etc.)",0.08,go
14ic9c8,,"yeah that too, but I'm asking for high level language such as rust, c, go, cobol, fortran, nim, v, etc.)",0.08,cobol
14ic9c8,,"yeah that too, but I'm asking for high level language such as rust, c, go, cobol, fortran, nim, v, etc.)",0.08,fortran
14ic9c8,jpg9njw,"It's a funny stunt, but utterly useless; go ham, I guess.",-0.125,go
14ic9c8,jpgcylu,"Information about which libraries are used (like, the standard C library containing the `printf()` function) is stored differently, and those libraries are stored in different locations in your file system.",0.0,c
14ic9c8,jpgcylu,"Alternately, you could do like Java does it: Compile to some bytecode, and then have a bytecode interpreter or JIT-compiler that translates the bytecode to each platform.",0.0,java
14ic9c8,jpgca7n,"It's maybe not quite what you meant, one count argue Python and Lua scripts can also be run on any computer that has the interpreter installed, but JVM languages are still compiled and most machines have the interpreter installed, so it runs everywhere in practice.",0.5,python
14ic9c8,jpgca7n,"It's maybe not quite what you meant, one count argue Python and Lua scripts can also be run on any computer that has the interpreter installed, but JVM languages are still compiled and most machines have the interpreter installed, so it runs everywhere in practice.",0.5,lua
14ic9c8,jpk105w,"This class of languages includes everything from Python to Java, depending on what you need.",0.0,python
14ic9c8,jpk105w,"This class of languages includes everything from Python to Java, depending on what you need.",0.0,java
14ic9c8,jpk105w,"Another option could be to compile to WASM, which is pretty much the same thing as I described above, but it's cool and new and everyone's excited about it, so I thought I'd mention it here.",0.18733766233766236,cool
14ic9c8,jpga18d,"A Java program, once compiled, can be run everywhere for example.",0.0,java
14ic9c8,jpgkovg,> > *I would love to write my code in pure 0s and 1s or in assembly*  Putting those three comments together I think OP is talking about *one* executable that runs on *two* (or more) distinct OSes.,0.3785714285714286,assembly
14ic9c8,jphnzpc,On any posix compliant system you should be able to assume a posix shell.,0.5,shell
14i037i,jpdxm47,I am a bit confused by the mention of Haskell.,-0.4,haskell
14i037i,jpdxm47,The integer type you are using for Haskell is not the correct one to look at this issue because it is not a 32-bit integer *or* a 64-bit integer.,0.0,haskell
14i037i,jpdxm47,"Also, Haskell has no implicit type conversions at all.",0.0,haskell
14i037i,jpdxm47,"If you give no type signature to `g`, it will default to `Integer` which is [Haskell's infinite precision integer type](https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Integer.html#t:Integer).",0.0,haskell
14i037i,jpdxm47,"Also, Haskell's issue with negative literals is a bit different than what you're describing.",-0.15,haskell
14i037i,jpdxm47,The reason this can be a problem in a different way than other languages is because the Haskell function call syntax is juxtaposition: `f x` is `f` applied to `x`.,-0.0625,haskell
14i037i,jpdxm47,This is what `NegativeLiterals` does in the context of Haskell and GHC.,0.0,haskell
14i037i,jpgd95p,Rust has no implicit conversion.,0.0,rust
14i037i,jpe9rex,(I created a whole thread about this exact question [here](https://www.reddit.com/r/C_Programming/comments/14gyl0a/why_long_really_needs_to_be_deprecated/?utm_source=share&utm_medium=web2x&context=3) in the C subreddit; the replies were not sympathetic.),0.06666666666666667,c
14i037i,jpeclwz,"also, check how java behaves.",0.0,java
14i037i,jpemm38,Why are you mentioning Python and JavaScript?,0.0,python
14i037i,jpemm38,Why are you mentioning Python and JavaScript?,0.0,javascript
14i037i,jpemm38,Why are you using I64 in rust and swift?,0.0,rust
14i037i,jpemm38,Why are you using I64 in rust and swift?,0.0,swift
14i037i,jpemqjz,"I actually tested it like this:      #include <stdio.h>      long f(void){return -1;}     long g(void){return 0xFFFFFFFF;}      int main(void) {         printf(""%f\n"",(double)f());         // both -1.000000         printf(""%f\n"",(double)g());     }  with a conversion to double, since in C, because you have to tell `printf` whether an expression is signed or unsigned, that influences the result.",-0.025,c
14i037i,jpg74d6,"The main repository is:  https://gitlab.com/mail.umlcat  I'm working in both a FreePascal version and a Plain C version, but it could be migrated to other P.L.",-0.057539682539682536,c
14i037i,jpfju5d, >Why are you mentioning Python and JavaScript?,0.0,python
14i037i,jpfju5d, >Why are you mentioning Python and JavaScript?,0.0,javascript
14i037i,jpfju5d,haskell too.,0.0,haskell
14i037i,jpfju5d,"i should've mentioned them along with haskell later, but that was not the point i was trying to make anyway.",0.0,haskell
14i037i,jpfxgwq,"the link that i embedded was from  visual studio 2022 ""windows programming in c++"", it does not make it very clear.",0.06500000000000002,c++
14i037i,jpfybhd,Rust doesn't have a prefix decrement operator: `--x` is also equal to `x`,0.0,rust
14i037i,jpfx8b7,"also, check the java behaviour.",0.0,java
14i037i,jpfzn23,This is special behavior Java has that you didn't clarify which is confusing because the code example you generalize to multiple other languages depends on this behavior.,-0.01696428571428571,java
14hs70w,jpdu04u,reminds me a bit of TCL's return that can return up several stack frames with the -level param.,0.0,tcl
14hcw00,,"I'm designing a statically-typed compile-to-JavaScript language, like a better TypeScript, based on looking at the patterns in my code that are a pain to express in TypeScript or that require sacrificing performance for flexibility or readability.",0.5,typescript
14hcw00,,"The type system will be simple enough to have a spec, and nominal (like Java), but ""modern.""",0.06666666666666667,java
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,java
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,javascript
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,c
14hcw00,,"It's true that I've written a lot of framework/engine code in high-level languages like Java and JavaScript, and I care more about performance across the board than your average programmer, but I really think that people would not be needing to rewrite so much code in languages like C and Rust (e.g.",0.21999999999999997,rust
14hcw00,,"There are different ways to represent a set of integers in JavaScript, for example a built-in Set, or you could use a sorted array of integers, or a sorted typed array (e.g.",0.0,javascript
14hcw00,,"In addition, if we change our mind about how Foo should store its integers, or the requirements change, we can implement a different kind of integer set and easily switch back and forth between two implementations with the same interface.",0.20666666666666664,forth
14hcw00,,"So if you have some noun and want to perform a verb on it—suppose it's some custom data structure called ""List"" and you want to get the ""length""—the best thing for the JavaScript engine is if you just call a function like ""listLength"".",1.0,javascript
14hcw00,,"It doesn't happen in TypeScript, for obvious reasons.",0.0,typescript
14hcw00,,"In Haskell or ML, it is also verboten for types to affect behavior, because you are not supposed to have to specify any type annotations; the type system is designed around the goal of whole-program type inference (which is a non-goal for me).",0.0,haskell
14hcw00,,(I think Scala can do something like this.),0.0,scala
14hcw00,,The duplicated code might be identical—in which case it still could benefit the JavaScript engine by being monomorphic—or it might have different inlined—or macro-expanded—code based on the differently instantiated type parameters.,0.0,javascript
14hcw00,,"(Scala can make sure instances that are associated with different ""parent"" instances aren't used interchangeably, but as much time as I've spent reading about Scala's type system and calculus, I don't think it's what I need.)",0.15,scala
14hcw00,,"Modules, instead of being singletons like in TypeScript, would have parameters and type parameters that form the ""configuration"" or context of the module.",0.0,typescript
14hcw00,,Maybe this was the idea with C++.,0.0,c++
14hcw00,jpamyvk,"My day job is C# code and it always irks me that I have to do ""Go To Implementation"" to just look at the code that's being called.",0.0,c
14hcw00,jpamyvk,"My day job is C# code and it always irks me that I have to do ""Go To Implementation"" to just look at the code that's being called.",0.0,go
14hcw00,jpamyvk,"I consider the entire notion of ""Go To Implementation"" to be a code smell because it implies that there's only a single implementation.",-0.023809523809523808,go
14hcw00,jpamyvk,"There's a thing you want to do but it depends on some runtime information to choose which strategy to go with, and each strategy shares a common shape.",-0.3,go
14hcw00,jpamyvk,"In TypeScript, my preferred approach is actually a map (object literal) of strings to functions.",0.0,typescript
14hcw00,jpamyvk,There's a follow-up by someone else ['Modules Matter Most' for the Masses](https://www.pathsensitive.com/2023/03/modules-matter-most-for-masses.html) that explained it better IMO and has TypeScript code examples.,0.5,typescript
14hcw00,jpamyvk,"I also found [Encoding ML-style modules in Rust](https://blog.waleedkhan.name/encoding-ml-style-modules-in-rust/) helpful in the sense of explaining this ""functional"" language feature in terms of an imperative language but it does require familiarity with Rust.",0.0,rust
14hcw00,jpblsad,> However—and this is the point—the purpose of having different implementations of an interface here is not so we can do some kind of late-bound dynamic dispatch...  What you're describing here reminds me of how templates are used in the C++ STL.,0.19999999999999998,c++
14hcw00,jpblsad,"For example, C++ has for a long time had names like [InputIterator](https://en.cppreference.com/w/cpp/named_req/InputIterator).",-0.05,c++
14hcw00,jpblsad,"Another, weirder example is C# extension methods.",0.0,c
14hcw00,jpblsad,(I think Scala can do something like this.),0.0,scala
14hcw00,jpblsad,Kotlin too.,0.0,kotlin
14hcw00,jpblsad,"However, it's not perfect, and there are cases where Kotlin needs to box the wrapped primitive into an object.",-0.5,kotlin
14hcw00,jpblsad,"Technically, the Kotlin approach isn't restricted to primitives.",0.0,kotlin
14hcw00,jpblsad,Haskell has the same general idea with [newtype](https://wiki.haskell.org/Newtype).,0.02500000000000001,haskell
14hcw00,jpblsad,"---  FWIW, if you haven't, you might want to look at Go.",0.0,go
14hcw00,jpblsad,"To be clear, I'm not recommending Go.",0.10000000000000002,go
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,c++
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,c
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,javascript
14hcw00,jpb5qkw,"Looking behind the scenes, I think your descriptions sound a lot like ""structs"", a feature that C++, C#, and C have, but Javascript (and typescript) do not.",0.0,typescript
14hcw00,jpb5qkw,"Structs are great for memory usage, and they are fast to get the size and the type itself isn't actually important, it's just a way to more easily see the data (C# Spans have a similar goal).",0.38888888888888884,c
14hcw00,jpb5qkw,"(Later versions try to add more C and C++ features like ""enum"", but its hardly required, and just an easier way to write constants.)",0.06944444444444443,c
14hcw00,jpb5qkw,"(Later versions try to add more C and C++ features like ""enum"", but its hardly required, and just an easier way to write constants.)",0.06944444444444443,c++
14hcw00,jpbfa3n,Insightful blog post but just wanted to mention that behavior can in fact depend on types in Haskell trough the use of type classes.,0.0,haskell
14hcw00,jpitaev,"I guess I am talking about a specific set of circumstances where you have a high-level, statically-typed language, somewhere between Java and Haskell, and you can write modules that have types as parameters, and types can have ""methods,"" but in many cases the substitution is done at compile time (and this can be relied on, both for performance purposes and for the sake of language features that rely on it).",0.25,java
14hcw00,jpitaev,"I guess I am talking about a specific set of circumstances where you have a high-level, statically-typed language, somewhere between Java and Haskell, and you can write modules that have types as parameters, and types can have ""methods,"" but in many cases the substitution is done at compile time (and this can be relied on, both for performance purposes and for the sake of language features that rely on it).",0.25,haskell
14hcw00,jpdskxi,"I'm not a huge fan of Go for other reasons either, but I do actually really like shaped types as opposed to named types.",-0.041666666666666685,go
14hcw00,jpdskxi,Both let you notice patterns as you go and allow you to formalize those patterns without having to explicitly alter the type hierarchies of all your structs or spend too much time up front trying to design them.,0.2,go
14hcw00,jpdskxi,"The advantage, for me, that Go has over OCaml is its explicitness.",0.0,go
14hcw00,jpdskxi,My major gripe with Go here is that there's no way to let the compiler verify conformance so you're stuck writing a test for every interface you want to make sure conforms and the test is likely only calling a dummy method that accepts the interface.,0.140625,go
14hcw00,jpdskxi,"Go has some interesting ideas, but is a bit too DIY for my taste to use regularly.",0.25,go
14hcw00,jpjpci2,The problem with Javascript and similar languages is that it is a *really* terrible language for actually writing decent programs in.,-0.20833333333333334,javascript
14hcw00,jpe493c,> My major gripe with Go here is that there's no way to let the compiler verify conformance so you're stuck writing a test for every interface you want to make sure conforms and the test is likely only calling a dummy method that accepts the interface.,0.140625,go
14hcw00,jpe493c,You'll need to go change them to line up or else create adapters.,0.0,go
14hcw00,jpe493c,"If Go added a succinct way to say ""this struct should implement that interface"", I think I would at least be neutral on the topic.",-0.3,go
14hcw00,jpe493c,"> Go has some interesting ideas, but is a bit too DIY for my taste to use regularly.",0.25,go
14hcw00,jpe493c,"I think it's trying to be a better C, and I think it largely succeeds at that.",0.6,c
14hcw00,jpe493c,And I think that attitude has ossified in the Go community.,0.0,go
14hcw00,jpe493c,I remember when generics came to Java 5 (almost 20 years ago) and it was such a huge improvement in the language.,0.20000000000000004,java
14hcw00,jpe97da,"If Go added a succinct way to say ""this struct should implement that interface"", I think I would at least be neutral on the topic.",-0.3,go
14hcw00,jpe97da,"With Go syntax, it'd probably be an expansion of tags, like `type MyStruct struct 'implements:[InterfaceA, InterfaceB]' {}` (single quotes because Reddit apparently doesn't like letting us escape ticks).",-0.010714285714285711,go
14hcw00,jpe97da,I think anyone who's worked in Java is familiar with the inconsistency of the `@Override` annotation.,0.375,java
14hcw00,jpe97da,">I think it's trying to be a better C, and I think it largely succeeds at that.",0.6,c
14hcw00,jpe97da,"I will give Go that it's a very consciously designed language and a lot of it does contribute to their goals, i.e., there should generally be one way to do things, enforcing KISS, and making the code as easy or easier to read than it is to write.",0.20444444444444446,go
14gwj0t,jp85094,"I cant use sqlite or postgress for 2 reason first i want to perform the queries on the fly without recreating db from git files and also i want to add a custom queries fit git like push, blame... etc  I started it to test the idea and learning rust and i want it to be wild usages in the near future,  BTW, In the demo i am running queries on the offical Rust analyzer repo.",0.2750000000000001,rust
14gtffa,jp8x47f,"Ok so here is the deal, Monotonicity like <<< operator in c++ is very overloaded.",0.35,c++
14gqgsj,,"I'm pretty sure I've seen this somewhere in the past for Haskell a couple of years back, and maybe some other langs.",0.075,haskell
14gqgsj,,"Example of unformatted code (Haskell):      data Row = Row {colA :: String, colB :: String}      table :: [Row]     table =     [ Row ""xxxxxx"" ""xx"",       Row ""x"" ""xxxx"",       Row ""xxxxxxxx"" ""xxxx""     ]  Example of the auto-formatted code:      table :: [Row]     table =     [ Row ""xxxxxx""   ""xx"",       Row ""x""        ""xxxx"",       Row ""xxxxxxxx"" ""xxxx""     ]   Obviously the data could just put put in `.csv` / `.tsv` files.",-0.5,haskell
14gqgsj,jp72n2t,I embed a small bit of Emacs Lisp code that I can manually run to realign things when I make changes.,-0.25,lisp
14gqgsj,jp8ktnf,(for any langs)  [Brittany](https://hexagoxel.de/gitea/hexagoxel/brittany/src/branch/ghc92) for haskell can do it.,0.0,haskell
14ghevk,jp661h3,So in Prolog Syntax I assume you want something like this.,0.0,prolog
14ghevk,jp661h3,```prolog |= mortal(sokrates).,0.0,prolog
14ghevk,jp661h3,I hear also some  forms of Prolog support limited version of it.,-0.07142857142857142,prolog
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,haskell
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,prolog
14ghevk,jp661h3,Lovechild of Haskell and Prolog with shitty typeclasses like rust and half baked uniqueness model from clean language.,0.10000000000000002,rust
14ghevk,jp85abz,I didnt check the current version of the code but back then during one of his stream his rule definitions reminded me of higher order prolog.,0.08333333333333333,prolog
14gdtg7,jp556d2,"Consider the following formal language: a^n b^n c^n (a, b and c are tokens and n is an arbitrary number of repetitions.",-0.05,c
14gdtg7,jp54pab,"``` fn foo(a, b, c) {}  fn bar(a, b) {}  foo(a, b, c);  bar(a, b); ```  Could you show me what that grammar would look like?",0.0,c
14gcuev,,"&#x200B;  I wanted to ask you how Swift accomplished to define primitive types like `Int`, `Bool` and `Character` in its standard library without having a compiler instrinsic type (I don't know if they exist but I haven't seen them).",0.1,swift
14gcuev,jp4synt,"Sorry to not answer the question in the title (I don't know about Swift), but [here](https://github.com/nim-lang/Nim/blob/devel/lib/system/basic_types.nim) is how Nim does it (this module is implicitly imported).",-0.5,swift
14gcuev,jp4z9fz,"Based on the docs, there is a very magic `Builtin` object available for the stdlib: https://www.swift.org/standard-library/  You can also try looking at the source code for the stdlib, but I don't know enough Swift to make sense of anything.",0.35000000000000003,swift
14gcuev,jpc5r67,"I don't know how Swift does it, but I've done it by making primitive types into ""external"" classes.",0.0,swift
14g8vwb,,"For processing operations, consider concatenative languages such as Forth, whose operands are on a stack.",0.0,forth
14g8vwb,,"I have found that when trying to schedule low level assembly code, operations upon FIFO queues produce natural orderings of pipelined instructions whereas LIFO stacks produce complications and convolutions.",0.05,assembly
14g8vwb,jp4d4ak,If you used queues as the underlying data structure in Forth rather than stacks you'd introduce a lot of problems with memory moving around.,0.0,forth
14g8vwb,jp4itsc,"As Forth illustrates, groups of stack operations can be reasoned about in isolation as an unit that consumes the top N values and pushes M values, making stack-based models very composable.",0.35,forth
14g8vwb,jp5w8pp,"When coupled with the natural levels of language/supervision (cf Erlang's 5 levels), the upshot is a complete solution for arbitrarily complex computational systems that is fully consistent with arbitrary machine code provided it follows the simple actor model rules.",0.008333333333333337,erlang
14g8vwb,jp5w8pp,"As far as I can tell, if you create a language that creates the assembly pipelines you speak of, while following the actor model rules, and cover the natural levels of language/supervision, you should be all set, no stacks needed.",0.06666666666666667,assembly
14g8vwb,jp6pef9,"Languages including assembly are based on function calls and the expectation that you can nest function calls arbitrarily, and these calls will build up and collapse down in their expected order.",-0.11851851851851854,assembly
14g8vwb,jp9o3dx,"See LabVIEW G, Simulink, Verilog, Cal for examples of languages.",0.0,verilog
14g8vwb,jp6wux2,"For instance, Forth’s “retain” is an enqueue, and “restore” is just waiting for the value to come around again.",0.0,forth
14g8vwb,jp6wux2,One is left-to-right composition of functions:      f : A → B     g : B → C     h : C → D      f g h : A → D     ≅     λs0:A.     let s1:B = f(s0) in     let s2:C = g(s1) in     let s3:D = h(s2) in     s3  The other is right-to-left composition of continuation transformers.,-0.125,c
14g8vwb,jp6wux2,One is left-to-right composition of functions:      f : A → B     g : B → C     h : C → D      f g h : A → D     ≅     λs0:A.     let s1:B = f(s0) in     let s2:C = g(s1) in     let s3:D = h(s2) in     s3  The other is right-to-left composition of continuation transformers.,-0.125,d
14g8vwb,jp6wux2,f : (B → Z) → (A → Z)     g : (C → Z) → (B → Z)     h : (D → Z) → (C → Z)      f g h : (D → Z) → (A → Z)     ≅     λk0:(D→Z).,-0.75,c
14g8vwb,jp6wux2,f : (B → Z) → (A → Z)     g : (C → Z) → (B → Z)     h : (D → Z) → (C → Z)      f g h : (D → Z) → (A → Z)     ≅     λk0:(D→Z).,-0.75,d
14g8vwb,jpc2aih,"The other thing I come to think of is my days of fortran programming on a vector machine, where adding two large vectors together was 6 times (IIRC) faster than adding the elements individually, because you could feed a new addition into the head of the adder circuit every clock cycle instead of waiting 6 cycles for the result.",0.05641233766233766,fortran
14g8vwb,jp56895,"Really the Unix shell, too.",0.2,shell
14g8vwb,jp4iab6,"Let's assume that it would be a concatenative language, not Forth, and that stacks are not a desired paradigm of computation.",0.0,forth
14g8vwb,jp4m62l,Consider the 4-vector dot product: a*x + b*y + c*z + d*w  Ignore the extra syntax needed to specify loads from memory for now.,0.0,c
14g8vwb,jp4m62l,Consider the 4-vector dot product: a*x + b*y + c*z + d*w  Ignore the extra syntax needed to specify loads from memory for now.,0.0,d
14g8vwb,jp4m62l,"I've spent a lot of brain cells on whether explicit register allocation should be programmer visible, ala assembly code.",-0.1,assembly
14g8vwb,jp482n6,I mentioned concatenative languages and Forth.,0.0,forth
14g8vwb,jp6u7s3,"I understood the point of most of what you were saying, but here:  >  including assembly   I don't know whether to regard this as a mistake on your part, or a belief, or what.",0.5,assembly
14g8vwb,jp6u7s3,Assembly or machine code is generally what gives *the ability to* make function calls in higher level languages.,0.15000000000000002,assembly
14g8vwb,jp6u7s3,"But sure, as you go higher up in abstraction layers, maybe stacked scopes are better than queued scopes for a lot of problems.",0.4166666666666667,go
14g8vwb,jpa0i4b,Verilog's delayed actions and JavaScript's event-based concurrency are examples of ordering work via a priority queue.,0.0,verilog
14g8vwb,jpa0i4b,Verilog's delayed actions and JavaScript's event-based concurrency are examples of ordering work via a priority queue.,0.0,javascript
14g8vwb,jp4r2ad,I'm not trying to prove a better Haskell or something.,0.5,haskell
14g8vwb,jp4szga,"The main reason I thought in terms of *only* a queue, is because concatenative languages such as Forth create a great deal of brevity by assuming there's some implicit data you're working on.",0.24166666666666667,forth
14g8vwb,jp4szga,"I like the brevity offered by Forth, and I like postfix notation just fine, because that's the actual natural order of ASM instructions.",0.17222222222222225,forth
14g8vwb,jphlmrj,I thought Fort sounded like a really cool language!,0.4375,cool
14g8vwb,jp59yme,Well I was thinking a Forth style global data structure that everything (not separately allocated) gets pushed or popped from.,0.0,forth
14g8vwb,jp769hr,"Some key differences:  * You send a ""message"" (think procedure/function call that doesn't return -- there's no returned value, no error codes returned, no promise/future, etc, nothing whatsoever is returned) to an ""address"" (think email address, but obviously low level, almost at the level of a machine address but not quite that simple) of an actor (think ""process"" in the general sense and think extremely lightweight, so maybe 256 bytes per ""process"" max -- see Ponylang whose actors/processes are 256 bytes each; I think Scala's are around the same size, or maybe 512 bytes per).",-0.012499999999999997,scala
14g8vwb,jp8cred,"When I invoked assembly I really meant two things:   Firstly, during my ECE degree we used ARM for writing assembly.",0.225,assembly
14g8vwb,jp8cred,"I may have been bit by the fact that there is more than one kind of assembly language, but a link register does seem to be a primitive to help write functions.",0.55,assembly
14g8vwb,jp8cred,"Secondly, regardless, I'm pretty certain that hand-written assembly for the majority of applications is going to be organized as lists of calls or procedures much like C, simply because it's the intuitive way to organize things.",0.13285714285714287,assembly
14g8vwb,jp8cred,"Secondly, regardless, I'm pretty certain that hand-written assembly for the majority of applications is going to be organized as lists of calls or procedures much like C, simply because it's the intuitive way to organize things.",0.13285714285714287,c
14g8vwb,jp53gyz,It makes sense for a distinction so fundamental to what can go wrong with your code to be reflected in the code.,-0.5,go
14g8vwb,jp97ljd,"But to be honest, I've used macro systems in assembly languages very little.",0.17812499999999998,assembly
14g8vwb,jp97ljd,That would be a higher level job for the C code of the 3D graphics device driver.,0.25,c
14g8vwb,jp5c9n0,"It’d be a dag as your IR : edges are dependencies, and nodes represent instructions.",0.0,d
14g8vwb,jp5c9n0,"To produce code you’d, at every given point, have a set of unexecuted-but-executable nodes.",0.0,d
14g8uyu,jp44ey2,It's basically an attempt to find methods of memory safety that are simple enough to retrofit onto C++.,0.0,c++
14g8uyu,jp44ey2,"I'm also thinking about adding a section to the end, briefly going over all the other methods of memory safety that I know, in case someone else can think of a method for making them fit C++.",0.09166666666666667,c++
14g8uyu,jp6kbkg,"""Making C++"" ...  Why try to revive something that is dead by design?",-0.2,c++
14g8uyu,jp8zecd,"I don't have much to add, because I'm not an expert in memory management, but I really wish this arrives somewhere cool!",0.2791666666666667,cool
14g8uyu,jp4iya6,"Sounds like C++Now would be the perfect venue--I'm being serious: https://cppnow.org/about/faq/#viewer-faq  That being said, last year's CFP was in December, https://cppnow.org/announcements/2022/12/2023-CfS/, so probably a good idea to go for CppCon first.",0.32333333333333336,go
14g8uyu,jp4iya6,"Also make sure to relate to prior work in this area (comparing pros/cons--in your talk, I mean, as that would be interesting to the broader C++ audience; no need to reply here):  - -fbounds-safety, https://discourse.llvm.org/t/rfc-enforcing-bounds-safety-in-c-fbounds-safety/70854 - -Wlifetime, e.g., https://godbolt.org/z/_midIP, https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/ - SAL annotations, https://learn.microsoft.com/en-us/cpp/code-quality/understanding-sal?view=msvc-170 - GCC 13 -Wdangling-reference, https://developers.redhat.com/articles/2023/06/21/new-c-features-gcc-13 - “safe libc++” mode, https://libcxx.llvm.org/UsingLibcxx.html#enabling-the-safe-libc-mode - RFC: C++ Buffer Hardening: https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734  - Safe Buffers Programming Model under which any pointer arithmetic is considered unsafe and clang warns about it  - -Wunsafe-buffer-usage initial commit https://reviews.llvm.org/D137346, docs https://reviews.llvm.org/D136811 - [RFC] Lifetime annotations for C++: https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377 	- See also: Comparison with other work in this area: https://discourse.llvm.org/t/rfc-lifetime-annotations-for-c/61377#heading--other-work 	- https://github.com/google/crubit/blob/main/docs/lifetimes_static_analysis.md 	- implementation: https://github.com/google/crubit/tree/main/lifetime_analysis",0.1953125,c++
14g8uyu,jp5zofh,"Well I'm sure you already know [my views](https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html), but the ""brutal"" truth is that anyone who cares about safety and isn't burdened by legacy codebases will use Rust, and so the people still stuck on C++ are the ones who can't just up and migrate their codebase to a new-fangled ad-hoc subset of C++.",-0.1875,rust
14g8uyu,jp5zofh,"Well I'm sure you already know [my views](https://blog.polybdenum.com/2023/03/05/fixing-the-next-10-000-aliasing-bugs.html), but the ""brutal"" truth is that anyone who cares about safety and isn't burdened by legacy codebases will use Rust, and so the people still stuck on C++ are the ones who can't just up and migrate their codebase to a new-fangled ad-hoc subset of C++.",-0.1875,c++
14g8uyu,jp5zofh,"Also, the design of C++ is fundamentally limited in ways that make it difficult to retrofit safety on top anyway.",-0.023809523809523798,c++
14g8uyu,jp4t8f9,* Something more like Rust's Arc<Mutex<T>> would work.,0.5,rust
14g8uyu,jp4mzx5,"Edit: Added ""Our ultimate goal is to find simple ways to make C++ memory-safe, simple enough that they can be accomplished via static analysis or linters, without extending the language.""",0.11666666666666665,c++
14g8uyu,jp6v6t3,"So, for most of these places its not easy to simply pivot from C++ to Rust.",0.09444444444444444,c++
14g8uyu,jp6v6t3,"So, for most of these places its not easy to simply pivot from C++ to Rust.",0.09444444444444444,rust
14g8uyu,jp6cn6i,"I think a lot of people think the same as you do, but there are a few reasons I don't share that worldview:   * If someone actually wanted absolute safety, they'd use a language safer than Rust, perhaps something like Typescript.",0.0,rust
14g8uyu,jp6cn6i,"I think a lot of people think the same as you do, but there are a few reasons I don't share that worldview:   * If someone actually wanted absolute safety, they'd use a language safer than Rust, perhaps something like Typescript.",0.0,typescript
14g8uyu,jp6cn6i,"Most popular Rust crates have some usage of unverified `unsafe`, either directly or in non-stdlib dependencies.",0.4000000000000001,rust
14g8uyu,jp6cn6i,"People who use Rust are pragmatic folks who are fine [sacrificing _some_ speed for safety](https://verdagon.dev/blog/myth-zero-overhead-memory-safety), and _some_ safety for their low-level goals.",0.4166666666666667,rust
14g8uyu,jp6cn6i,"* I believe that with some improvements, C++ can also occupy a sweet spot in that vicinity.",0.35,c++
14g8uyu,jp6cn6i,"And if we can provide a smooth, gradual on-ramp to it (such as described in the draft) that's easier than Rust, then we might actually make it to a memory-safe world faster than we would with a slow global migration to Rust, which I think you would agree is a good thing.",0.13333333333333333,rust
14g8uyu,jp6cn6i,"* `unsafe`, and the entire C++-to-Rust migration story, suggests that non-memory safe code can coexist with (and gradually transition to) safe code, which hints it's also possible to migrate to a safe subset of C++, or Vale, or CppFront or Carbon if they ever choose to add safety.",0.3,c++
14g8uyu,jp6cn6i,"* There are still some reasons to use C++, such as existing libraries whose paradigms Rust can't reason about (UI, OO, etc), existing frameworks that still use C++ (Unreal), and existing programs that still use C++ (Spanner).",0.0,c++
14g8uyu,jp6cn6i,"* There are still some reasons to use C++, such as existing libraries whose paradigms Rust can't reason about (UI, OO, etc), existing frameworks that still use C++ (Unreal), and existing programs that still use C++ (Spanner).",0.0,rust
14g8uyu,jp6cn6i,I see a path forward for C++.,0.0,c++
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,typescript
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,kotlin
14g8uyu,jp6cn6i,"History has shown that gradual transitions get adopted more easily (hence Typescript, Kotlin, and Swift's success).",0.41111111111111115,swift
14g8uyu,jp6cn6i,I'd hesitate to say that Rust's future supremacy is a brutal truth.,-0.4375,rust
14g8uyu,jp4usus,"FWIW, `int main() {}` is legal and standard (including omitting the explicit `return 0;` statement)--and shorter than the `void` version (which is sufficiently out of place in either C or C++ code to be distracting here, I think), https://en.cppreference.com/w/cpp/language/main_function  > The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.",0.13999999999999999,c
14g8uyu,jp4usus,"FWIW, `int main() {}` is legal and standard (including omitting the explicit `return 0;` statement)--and shorter than the `void` version (which is sufficiently out of place in either C or C++ code to be distracting here, I think), https://en.cppreference.com/w/cpp/language/main_function  > The body of the main function does not need to contain the return statement: if control reaches the end of main without encountering a return statement, the effect is that of executing return 0;.",0.13999999999999999,c++
14g8uyu,jp4usus,"More on the friendly nitpicking side ;-) Using `std::endl` (I cannot bring myself to omit `std::`) other than as an explicit buffer flushing operation for a non-error output stream is going to raise some eyebrows, too: C++ Weekly - Ep 7 Stop Using std::endl, https://www.youtube.com/watch?v=GMqQOEZYVJQ",0.25,c++
14g8uyu,jp4pq5k,It’s valid to only move in one branch - are you saying you’d propose enforcing that you can only move in both or none?,0.0,d
14g8uyu,jp55a2n,"No problem, glad the nitpicking can be useful :-)  As for the `std::endl`: Generally I'd go with the isocpp.org FAQ, https://isocpp.org/wiki/faq/input-output#endl-vs-slash-n or the C++ Core Guidelines, https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio50-avoid-endl  In my context `'\n'` is also shorter to type than `std::endl`--with the context being never `using namespace std;`, https://isocpp.org/wiki/faq/coding-standards#using-namespace-std (yes, even for short snippets of code that I need to fit on the slides in a presentation--it can be even more useful for talks as the audience can quickly tell at a glance whether I'm talking about, say, `std::sort`, `llvm::sort`, https://developers.redhat.com/blog/2019/10/18/extend-c-capabilities-with-llvm-stlextras-h, or more likely `std::ranges::sort` nowadays).",0.30757575757575756,go
14g8uyu,jp55a2n,"No problem, glad the nitpicking can be useful :-)  As for the `std::endl`: Generally I'd go with the isocpp.org FAQ, https://isocpp.org/wiki/faq/input-output#endl-vs-slash-n or the C++ Core Guidelines, https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slio50-avoid-endl  In my context `'\n'` is also shorter to type than `std::endl`--with the context being never `using namespace std;`, https://isocpp.org/wiki/faq/coding-standards#using-namespace-std (yes, even for short snippets of code that I need to fit on the slides in a presentation--it can be even more useful for talks as the audience can quickly tell at a glance whether I'm talking about, say, `std::sort`, `llvm::sort`, https://developers.redhat.com/blog/2019/10/18/extend-c-capabilities-with-llvm-stlextras-h, or more likely `std::ranges::sort` nowadays).",0.30757575757575756,c++
14g8uyu,jp54mps,"I updated the article to add this near the top (in response to another comment):  > Our ultimate goal is to find simple ways to make C++ memory-safe, simple enough that they can be checked via static analysis tooling or linters, without extending the language.",0.2,c++
14g8uyu,jp54mps,"Some things feel Rust-esque (borrowless affine style and simplified borrowing, definitely), but the other parts (gen refs, constraint refs, shared_ptr) are specifically to make things easier than Rust.",-0.0625,rust
14g8uyu,jp5c8oz,"I'm saying that we don't need to change anything in the C++ compiler (clang, GCC, etc) or the C++ standards.",0.0,c++
14g8uyu,jp5c8oz,"I suspect you mean ""We need to change how we use C++, which in practice is just like changing the language"", which is a reasonable stance TBH, even though I don't necessarily share the definition.",-0.0375,c++
14g8uyu,jp6kr58,"If you squint, it's what Rust's borrow checker is doing too since you can choose to use `unsafe` anywhere you'd like (minus the opt-out/opt-in distinction).",-0.1,rust
14fti7o,jp48eab,It's moderately horrifying to me that important and performance-intensive work is being done in shell scripts instead of a more performance-oriented language.,0.0,shell
14fti7o,jp48eab,"That being said, this work is pretty cool and seems like a good drop-in solution in cases when it's unlikely the code would get rewritten in a more appropriate language.",0.3,cool
14fti7o,jp48eab,"> We implement our approach in a prototype we call hs—so called because it’s the shell (sh), but out-of-order.",0.0,shell
14f99ui,,this is something I've been wondering about playing around with types in python and rust.,0.0,python
14f99ui,,this is something I've been wondering about playing around with types in python and rust.,0.0,rust
14f99ui,,"like an example would be having a function in rust that can take an  Array1 or Array2(from ndarray), and returns either an Array2 or Array3, respectively (the real function takes an arrayDyn and returns an arrayDyn, and wraps around 2 different typed functions).",0.06666666666666667,rust
14f99ui,joz2wx9,"Languages like TS, Crystal are able to infer things to a limited extent, and certain advanced techniques like semantic subtyping and [algebraic subtyping](https://lptk.github.io/files/[v6.2]%20mlstruct.pdf) can provide complete or almost complete inference, though it may take some time to understand these approaches.",0.20714285714285718,crystal
14f99ui,joyurgi,"Python tools like mypy or pyright have overloads, which let you specify the output given specific inputs (especially with the Literal type).",0.0,python
14f99ui,joyurgi,Typescript also has similar.,0.0,typescript
14f99ui,joz47hs,typescript can narrow down your type as you introduce more context in the code.,0.04814814814814813,typescript
14f99ui,jp0d0xh,"Typescript will automatically infer union return types, based on function bodies and multiple return statements, but it won't automatically infer that it's *tied* to argument type.",0.0,typescript
14f99ui,jp06h0q,"For your specific question it seems like a rust type parameter should do the trick, fun<T>(...) which returns an array of T or similar.",0.0,rust
14f99ui,jp06h0q,"If you're looking more generally for ""I have a type union A | B | C, but here there's only A | B"".",0.18333333333333335,c
14f99ui,jp06h0q,"It's a type system built after the fact on top of Erlang, and infers types (that are unions of values) from the code.",0.5,erlang
14f99ui,jp06h0q,"The advantage of this approach to typing is that the type system can express the types A, A | B, and A | B | C with no trouble.",0.1,c
14f99ui,jozhb7a,"btw, off topic but any resources for learning typescript you would recommend(preferably that don't assume or require the reader to first learn javascript).",0.25,typescript
14f99ui,jozhb7a,"btw, off topic but any resources for learning typescript you would recommend(preferably that don't assume or require the reader to first learn javascript).",0.25,javascript
14f99ui,jozfpn9,"more like code path 1 yields one type, code path 2 yields another type, but in situations where  ``` def foo(x: array|float) -> array|float:     match typeof(x):         case array:             #return array         case float:             #return float ```  both languages in question don't support overloading(to my knowledge at least), and often python numpy functions generally return a fat union of types that sometimes seems as though a overengineered static analysis tool could derive to be a specific compile time type.",0.15,python
14f99ui,jp0fjw1,"In Haskell, you would write something like       {-# LANGUAGE FunctionalDependencies #-}  -- implies MultiParamTypeClasses      class Fooable a b | a -> b where         -- | a -> b is the functional dependency                                              -- implying that the type of b depends on the type of a.         foo : a -> b      instance Fooable Array Array where         foo = fooArray      instance Fooable Float Float where         foo = fooFloat  If you then call `foo` with an array argument, it will infer the result type to be array so you need not specify it.",0.0,haskell
14f99ui,jp0fjw1,---  Another possibility to consider is C++ function template specialization:      template <typename T>     T foo(T x);      template<>     float foo<float>(float x) { ... }      template<>     array foo<array>(array x) { ... }  Function template parameters can be inferred from the argument type (but cannot be inferred from return type).,0.0,c++
14f99ui,jp3g372,"the other situation I've seen where it would be useful is avoiding python ""None pollution"", a single code path of a function can potentiall not return and now pylance/pyright is complaining everywhere that called methods are invalid.",0.03452380952380952,python
14f99ui,jp3g372,"You can use narrowing in python, but without shadowing there are plenty of situations where this just gets excessive.",-0.25,python
14f5wp0,,The compiler is written in Kotlin without using any 3rd party dependencies and is around ~300 lines.,0.0,kotlin
14f5wp0,,"If people are curious or find my work useful I'll upload the code and provide a Kotlin script that can be easily executed like ``` qc template.qc ""{ //JSON vars here }"" ```  What are your thoughts?",0.2111111111111111,kotlin
14f5wp0,jozta26,Being able to embed loops and the ease of extension with python are what sold it to me,0.5,python
14f5wp0,jplg2bf,"Another possible approach for this is doing something similar to what a Lisp does: build up a data structure representing the AST, and dump that out to a string.",0.0,lisp
14f5wp0,jplg2bf,"Then you can write functions that generate a 'sub-AST', akin to Lisp macros.",0.0,lisp
14f5wp0,jplg2bf,"Haskell tends to be quite nice for this (for example because it allows you to define custom infix operators, and is quite good at dealing with recursive data types).",0.6499999999999999,haskell
14e8erj,jpse5ao,So if you have a program written in COBOL in 1965 then it will run fine in 2365 on the Star-Ship Enterprise if you only present it to a COBOL compiler designed to target the Majel Barrett Architecture.,0.1388888888888889,cobol
14dlbc8,joztdsm,"The indexing scheme doesn't protect you from memory errors like use-after-free, dangling pointers (indices in this case), or memory leaks.",0.0,scheme
14dlbc8,joztdsm,"This is basically equivalent to using a per-type arena allocator in C, which is not memory safe by any reasonable standard.",0.2333333333333333,c
14dlbc8,jozhkao,"Or perhaps also about unsafe languages guarded with sanitizing tools, e.g., like C with AddressSanitizer?",0.4,c
14dlbc8,jor31j7,However to me it felt like I had roughly as many `if` checks as I would need in C++,0.5,c++
14dlbc8,joyagx3,ATS gets to zero-cost memory safety much closer than most others including Rust.,0.35,rust
14dkx6p,josoi9l,"For a couple examples of recent _adoption_ of PEG,   * Python is moving from a LL(1) parser to a PEG parser: https://peps.python.org/pep-0617/ * Zig's grammar is specified as a PEG: https://github.com/ziglang/zig-spec/blob/master/grammar/README.md",0.0,python
14dkx6p,jotu9nl,Languages like C usually resolved the dangling else conflict by an ad hoc disambiguation criteria.,-0.25,c
14dgvwy,jot0sz6,"I have made a compiler for my programming language targetting WebAssembly, and it outputs assembly code compatible with the wat2wasm assembler from WebAssembly Binary Toolkit: https://aecforwebassembly.sourceforge.io/",0.0,assembly
14de1dr,joszfjl,This is exactly what should have been happening for Elm in the last 5 years.,0.125,elm
14daokr,jop1sv8,"* In particular, a new language that has some cool new features, but which doesn't come with 'batteries included', i.e.",0.19734848484848483,cool
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,c
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,assembly
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,fortran
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,java
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,ruby
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,prolog
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,lisp
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,javascript
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,c++
14daokr,jouu3d5,"[ ] The most significant program written in your language is its own compiler [ ] The most significant program written in your language isn't even its own compiler [ ] No language spec [ ] ""The implementation is the spec""    [ ] The implementation is closed-source  [ ] covered by patents  [ ] not owned by you [ ] Your type system is unsound  [ ] Your language cannot be unambiguously parsed    [ ] a proof of same is attached    [ ] invoking this proof crashes the compiler [ ] The name of your language makes it impossible to find on Google [ ] Interpreted languages will never be as fast as C [ ] Compiled languages will never be ""extensible"" [ ] Writing a compiler that understands English is AI-complete [ ] Your language relies on an optimization which has never been shown possible [ ] There are less than 100 programmers on Earth smart enough to use your language [ ] ____________________________ takes exponential time [ ] ____________________________ is known to be undecidable  Your implementation has the following flaws: [ ] CPUs do not work that way [ ] RAM does not work that way [ ] VMs do not work that way [ ] Compilers do not work that way [ ] Compilers cannot work that way [ ] Shift-reduce conflicts in parsing seem to be resolved using rand() [ ] You require the compiler to be present at runtime [ ] You require the language runtime to be present at compile-time [ ] Your compiler errors are completely inscrutable [ ] Dangerous behavior is only a warning [ ] The compiler crashes if you look at it funny [ ] The VM crashes if you look at it funny [ ] You don't seem to understand basic optimization techniques [ ] You don't seem to understand basic systems programming [ ] You don't seem to understand pointers [ ] You don't seem to understand functions  Additionally, your marketing has the following problems: [ ] Unsupported claims of increased productivity [ ] Unsupported claims of greater ""ease of use"" [ ] Obviously rigged benchmarks    [ ] Graphics, simulation, or crypto benchmarks where your code just calls        handwritten assembly through your FFI    [ ] String-processing benchmarks where you just call PCRE    [ ] Matrix-math benchmarks where you just call BLAS [ ] Noone really believes that your language is faster than:     [ ] assembly  [ ] C  [ ] FORTRAN  [ ] Java  [ ] Ruby  [ ] Prolog [ ] Rejection of orthodox programming-language theory without justification [ ] Rejection of orthodox systems programming without justification [ ] Rejection of orthodox algorithmic theory without justification [ ] Rejection of basic computer science without justification  Taking the wider ecosystem into account, I would like to note that: [ ] Your complex sample code would be one line in: _______________________ [ ] We already have an unsafe imperative language [ ] We already have a safe imperative OO language [ ] We already have a safe statically-typed eager functional language [ ] You have reinvented Lisp but worse [ ] You have reinvented Javascript but worse [ ] You have reinvented Java but worse [ ] You have reinvented C++ but worse [ ] You have reinvented PHP but worse [ ] You have reinvented PHP better, but that's still no justification [ ] You have reinvented Brainfuck but non-ironically  In conclusion, this is what I think of you: [ ] You have some interesting ideas, but this won't fly.",-0.012896825396825384,php
14daokr,jormady,"I don't think we should discourage people from making languages, as long as they go in with realistic expectations.",0.05833333333333333,go
14daokr,jopm6jh,Once the language takes over 1-2 more secondary domains it needs to try and go mainstream:  * The library problem can prove impossible to solve.,-0.15555555555555553,go
14daokr,jopm6jh,Lots of things that can go wrong.,-0.5,go
14daokr,jrbb5ty,An example could be C++ references.,0.0,c++
14daokr,jrbb5ty,"C++ also has pointers which it ""inherited"" from C. So now it has to equivalent features that basically do the same, but in different ways, and they also interact in weird ways.",-0.16666666666666666,c++
14daokr,jrbb5ty,I guess Stroustrup's reason may have been that this meant that C++ could have backwards compatibility with C. In my opinion this came at a high price.,0.16,c++
14daokr,jrbb5ty,"C++ was attempting that, but failed: it added a new kind of pointers - yet at the same time it changed the meaning of struct types.",0.05909090909090908,c++
14daokr,jrbb5ty,Look at Object Pascal to see how OOP could be added without messing up with the base Pascal language.,-0.8,pascal
14daokr,jrbb5ty,"By the looks of what went into C23, I expect the next version of C to include lambdas - but why does the latest version then not at least have nested functions, a simple and useful feature that already exists as incompatible proprietary extensions in the two probably most influential compiler systems GCC/GNUC and Clang, and was standard in Algol- and Pascal-derived languages going back to the late 60es and 70es?",0.07777777777777778,c
14daokr,jrbb5ty,"Why isn't there a language close to being as simple as original C or Pascal/Modula-2, with all the lessons added that we ought to have learnt in 75 years of computers and programming language design.",0.1875,c
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,c
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,c++
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,java
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,javascript
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,swift
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,go
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,rust
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,lisp
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,scheme
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,tcl
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,perl
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,python
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,php
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,ruby
14daokr,jrbb5ty,"Why is the choice *still* between a C language that is in many ways archaic, unsafe, and unsound, despite regular attempts at patching it up gently every decade or so; a dozen (and more joining each year) derivatives of C, all repeating at least some of C's flaws, be it C++, objectiveC, Java, C#, GNU C, clang, Javascript, Swift, Go, Rust... just to mention the major ones; some classic functional style languages based on LISP and Scheme, which always end up as niche because most people just don't want to cope with the parentheses; and endless forest of scripting languages like TCL, REXX, Perl, Python, PHP, Ruby, BASIC, ... each with its own history of evolution and degeneration to a zombie-state; and the ""academic"" languages like ML, Haskell etc, which to me look as if they just casually expect the programmer to have a degree in mathematics, thereby restricting their use.",0.12339743589743589,haskell
14daokr,jrbb5ty,"Other scripting languages fill this niche now, perhaps mainly Javascript and Python (until recently Php), and before them it was BASIC.",0.010416666666666664,javascript
14daokr,jrbb5ty,"Other scripting languages fill this niche now, perhaps mainly Javascript and Python (until recently Php), and before them it was BASIC.",0.010416666666666664,python
14daokr,jrbb5ty,"Other scripting languages fill this niche now, perhaps mainly Javascript and Python (until recently Php), and before them it was BASIC.",0.010416666666666664,php
14daokr,jrbb5ty,"And of course there are the immortal dinosaurs, FORTRAN and COBOL, and maybe even their offspring PL/1.",0.0,fortran
14daokr,jrbb5ty,"And of course there are the immortal dinosaurs, FORTRAN and COBOL, and maybe even their offspring PL/1.",0.0,cobol
14daokr,jop8s0h,"They usually come back to the same archetypes:  Algol C likes, lisps, MLs  Edit : for non dead languages :)",0.009999999999999998,algol
14daokr,jop8s0h,"They usually come back to the same archetypes:  Algol C likes, lisps, MLs  Edit : for non dead languages :)",0.009999999999999998,c
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,javascript
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,python
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,haskell
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,rust
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,go
14daokr,jos8hyw,"Some aren’t intended to grow hugely but do [Javascript, Python], others have all the right pieces but don’t get a lot of traction and remain niche [F#, Pony], some are designed with non-growth as a design principle [Ocaml, Haskell], still others break out because of a confluence of the right things [Rust, Go, TypeScript].",0.3238095238095238,typescript
14daokr,jop3dvi,"Why would I use a language without even syntax highlighting where I'd need to run the compiler to see typos when I can just use typescript or Kotlin with a full IDE, autocomplete, linting etc.",0.35,typescript
14daokr,jop3dvi,"Why would I use a language without even syntax highlighting where I'd need to run the compiler to see typos when I can just use typescript or Kotlin with a full IDE, autocomplete, linting etc.",0.35,kotlin
14daokr,josx2j0,The only language that I'd call dead is Elm.,-0.1,elm
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,prolog
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,forth
14daokr,joqmnkb,"I didn’t downvote but: Prolog, Forth, APL, Smalltalk, …",0.0,apl
14daokr,joqaqug,"To be fair, almost every new language did become popular because it was very similar to an existing popular language (almost always C, and C is quite similar to Algol).",0.33939393939393936,c
14daokr,joqaqug,"To be fair, almost every new language did become popular because it was very similar to an existing popular language (almost always C, and C is quite similar to Algol).",0.33939393939393936,algol
14czkbu,jop3rnt,You say a simple one is easy to make.. do you have any resources you’d recommend for it?,0.21666666666666667,d
14czkbu,joppssr,I recommend  - https://davidchristiansen.dk/tutorials/nbe/ in Racket or https://davidchristiansen.dk/tutorials/implementing-types-hs.pdf in Haskell - https://github.com/AndrasKovacs/elaboration-zoo,0.0,haskell
14czkbu,joqqa0o,It seems like something along the lines of Rust's shared vs unique references might be useful here.,0.3375,rust
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,javascript
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,c++
14cxmbr,,"Indeed, some languages have this: JavaScript has `Array.prototype.unshift`, C++ has `std::vector::insert`, Rust has `Vec::insert`.",0.0,rust
14cxmbr,jona67v,"Better to:  \- support all reasonable operations on all containers (push-back, push-front, delete, insert, etc)    \- use the same interface for all containers so it's easy to move between them   \- make the tradeoffs clear in documentation     Otherwise people will invent their own containers that do what they want, then you'll get two standard libraries (look at boost vs C++ STL ugh), and then everyone will use both, and then everything will be a mess.",0.15648148148148147,c++
14cxmbr,jooloet,"See for example [""Q: Remove element by value in Go list""](https://stackoverflow.com/questions/31080285/remove-element-by-value-in-go-list).",0.0,go
14cxmbr,joollm6,"For example, if we go with functional lists (linked lists), there are multiple ways we could implement them with various tradeoffs.",0.0,go
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,lisp
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,c
14cxmbr,joollm6,"A functional list is intrinsic to a language like Lisp, but it is not necessary for a language like C or Rust.",0.0,rust
14cxmbr,joonxut,"Clojure is good here, even if it means sometimes weird decisions at first glance.",0.15,clojure
14cxmbr,joonxut,"For example,`contains?` works on keys of a map and _indexes_ of a vector (not the values as that’d be O(n) and the function is meant to be closer to O(1)).",0.0,d
14cxmbr,joohc7t,"EDIT: also another thing, for high performance software i usually build my own containers, and since i work in c well i rewrite them every time i need them, also containers are very bad for DOD so rewriting them every time i need is a good way to save memory and increase cache hits (and it really works good with performance).",0.17142857142857146,c
14cxmbr,joohc7t,for example do i have a `token_t` in my whole c compiler?,0.2,c
14cxmbr,jot5z43,Historically boost could be viewed as a feeder for getting libraries into the ISO C++ standard.,0.0,c++
14cxmbr,jot5z43,For a better example of the two conflicting standard libraries problem consider Tango and Phobos from the early days of [D](https://en.wikipedia.org/wiki/D_(programming_language)).,0.19999999999999998,d
14cv7tg,joqnjz7,"The last few months has been implementing threads, getting a second backend, implementing cross language inline (so C++ code inlines into bolin builds), improving codegen so the optimizer doesn't need to deal with sloopy codegen, now recently syntax changes, etc  There's going to be quiet a few months before we'll have a killer app with all the syntax it uses fully implemented.",-0.05714285714285715,c++
14cv7tg,joqnjz7,If you like you can go into more detail and I'll try to keep it in mind on the redesign,0.5,go
14cv7tg,joqny1n,I tried to design the whole thing so you'd have the answer on the same page and so not too many lines change on the next level (unless it's a different set of problems)  You can go back if you change the level at the top of the page,0.17142857142857143,go
14cu0id,jompulh,Pretty much anything is going to be more readable than AT&T assembly syntax for example.),0.31666666666666665,assembly
14cu0id,joof9xj,"On a Pentium4 machine, the register machine required 32.3% less time to execute standard benchmarks if dispatch is performed using a C switch statement.",-0.08333333333333333,c
14cu0id,joof9xj,Designing your runtime around the constraints of the hardware can be the difference between your language being ~10x slower than C versus ~100x slower than C.,0.0,c
14cu0id,jop6u3u,Here's a recent article about [arbitrary decisions in Rust](https://graydon2.dreamwidth.org/307291.html).,-0.05,rust
14cu0id,jooo6tr,"Bytecodes are like assembly, and they usually are a mix of both stack and register instructions.",-0.25,assembly
14cu0id,jooo6tr,"The reasons Java went stack only were, one to avoid to look like another processor codes and avoid been sued.",0.0,java
14cqhj1,,"I came across the paper and presentation [*Generalized Evidence Passing for Effect Handlers*](https://www.microsoft.com/en-us/research/uploads/prod/2021/03/multip-tr-v4.pdf), (and it's Haskell implementation [EvEff](https://hackage.haskell.org/package/eveff)) which describes the process Koka's compiler uses when compiling effect handlers to C, but it is a completely over my head and I am not very familiar with programming language papers.",-0.022115384615384606,haskell
14cqhj1,,"I came across the paper and presentation [*Generalized Evidence Passing for Effect Handlers*](https://www.microsoft.com/en-us/research/uploads/prod/2021/03/multip-tr-v4.pdf), (and it's Haskell implementation [EvEff](https://hackage.haskell.org/package/eveff)) which describes the process Koka's compiler uses when compiling effect handlers to C, but it is a completely over my head and I am not very familiar with programming language papers.",-0.022115384615384606,c
14cqhj1,jon1fac,"I think what happens in C is that the handler is called immediatly and then if you need to suspend, a global variable is set and the function return (if you don't need to suspend, the handler just return the value), then every function above in the call stack will check if the global variable is set and if so will add the continuation to the list and the return.",0.0,c
14cqhj1,joon6w8,"I'd like to explain how the ""bubbling"" works in analogy to how the `Result` monad works in a strict language like OCaml or Rust.",0.0,rust
14cqhj1,jom1aqd,"I did notice that the EvEff implementation uses a free monad, but I believe in the compilation to C the monad is compiled away rather than interpreted at runtime.",0.4,c
14cqhj1,jom1aqd,I wanted to avoid using free monads to model effects in my language because it forces you to perform allocations for every bind to build the tree even when not using effects with special control flow (and even then require more allocations than would be necessary to capture a resumption); which is what I think Koka's scheme is designed to avoid.,0.3142857142857143,scheme
14chayf,,"I have absolutely no idea how to approach parsing, so much so that I got bored and am currently rewriting the lexer in like 3 other languages (the implementation on GitHub is in Go).",-0.10500000000000001,go
14chayf,jolbm6u,I’d highly recommend reading through these resources.,0.16,d
14chayf,jolqbch,"There are many ways to go about implementing a parser, but if you are just getting started and the jargon about LR, LL(1), context-free grammars is going over your head, here's what I would recommend (I'm also gonna assume you're gonna use Go because you mentioned Go):  You probably want to have expressions in your language.",0.5,go
14chayf,jolr2p4,I have write [a blog about writing a parser in Haskell](https://terenceng03.github.io/blogs/parser_combinator.html).,0.0,haskell
14chayf,jom28iu,"I'm going to use C as the example language to parse, where every top level item is a declaration of some sort, could be variables, types, function prototypes/forwards, or function definitions.",0.5,c
14chayf,jom28iu,"When a C function is defined, language statements are allowed (a block is required to start).",0.0,c
14chayf,jom28iu,"For C, expressions may also appear in declarations, so the declaration parser needs a subset of an expression parser, where in some sense, basically only unary operators are allowed (with an exception for constant expressions such as for initializers and array bounds, which allow binary operators as well).",0.0,c
14chayf,jom28iu,"A language like C requires complete forward declarations, so can logically combine symbol table construction, scoping maintenance, as well as symbol resolution with parsing.",0.175,c
14chayf,jond8xq,First research and generate an Abstract Syntax Tree with tree walking and then you can go on more effective methods.,0.45,go
14chayf,joq1bvt,"Check out ""Writing an Interpreter in Go"" by Thorsten Ball.",0.0,go
14camve,,"Is the idea that the linters take the AST (like a Rust linter, how does it work in Rust?",0.0,rust
14camve,jok4xpl,"For example the transformation `x == False` -> `x is False` is suggested by some Python linters, but since operators can be overloaded this can cause the program to break.",-0.4000000000000001,python
14c83jy,,"I don't like how TypeScript does it and makes it so the global is extended, because then you can't have different versions of the type at the same time.",0.0,typescript
14c83jy,jol0mo7,"Swift allows new members to be declared in extensions, but they have some limitations.",0.13636363636363635,swift
14c83jy,joleoek,"To clarify a couple of things: in Typescript, the syntax you've written there wouldn't work — only `interface` performs the automatic extension that you're describing.",0.0,typescript
14c83jy,joleoek,"Secondly, Typescript is distinct from Javascript, particular in this area.",0.15555555555555556,typescript
14c83jy,joleoek,"Secondly, Typescript is distinct from Javascript, particular in this area.",0.15555555555555556,javascript
14c83jy,joleoek,"They generate no code, and if you had a file containing only them, when you ran `tsc`, the Typescript compiler over that file, you'd end up with an empty output.",-0.05,typescript
14c83jy,joleoek,That's because the purpose of `type` and `interface` is to describe the shape of various types in Javascript.,0.0,javascript
14c83jy,joleoek,"In this case, for example, the `Array` runtime Javascript class will typically be defined by a browser's Javascript engine — it'll be some sort of built in value, and there are a bunch of specifications which say which methods it should have, and what signatures those methods will have.",-0.16666666666666666,javascript
14c83jy,joleoek,"The files you've linked to are essentially copies of those specifications (without any notes on the behaviour, just the relevant types and methods), that can be read by the Typescript compiler.",0.2,typescript
14c83jy,joleoek,"That way, when you create an array in Javascript code, the Typescript compiler can figure out what methods it will have (and if you try and do something like `[].slice` but you've not declared that your program supports Javascript v2, then Typescript will complain).",0.0,javascript
14c83jy,joleoek,"That way, when you create an array in Javascript code, the Typescript compiler can figure out what methods it will have (and if you try and do something like `[].slice` but you've not declared that your program supports Javascript v2, then Typescript will complain).",0.0,typescript
14c83jy,joleoek,"This is the reason why the Typescript types are so global: because they're not values in of themselves, but rather they represent real Javascript values that are defined elsewhere.",0.1,typescript
14c83jy,joleoek,"This is the reason why the Typescript types are so global: because they're not values in of themselves, but rather they represent real Javascript values that are defined elsewhere.",0.1,javascript
14c83jy,joleoek,"If you tell the Typescript compiler that you want to support Javascript v2 (which you'd typically do via a config file rather than imports), then you're saying that the whole program will be run in an environment where the global `Array` object has the `slice` method.",0.011111111111111118,typescript
14c83jy,joleoek,"If you tell the Typescript compiler that you want to support Javascript v2 (which you'd typically do via a config file rather than imports), then you're saying that the whole program will be run in an environment where the global `Array` object has the `slice` method.",0.011111111111111118,javascript
14c83jy,joleoek,It might be worth looking into extension methods in [Kotlin](https://kotlinlang.org/docs/extensions.html) and [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/).,0.3,kotlin
14c83jy,joleoek,It might be worth looking into extension methods in [Kotlin](https://kotlinlang.org/docs/extensions.html) and [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/).,0.3,swift
14c83jy,joleoek,"Alternatively, you can do similar things in Rust with traits.",0.0,rust
14c83jy,joleoek,"In Rust, however, that ""I follow this interface"" declaration is separate from the class declaration, which means you can declare methods on classes that you didn't write.",0.0,rust
14c83jy,joleoek,"For example, in Rust, `Vec` is the built-in equivalent of Javascript's `Array`.",0.0,rust
14c83jy,joleoek,"For example, in Rust, `Vec` is the built-in equivalent of Javascript's `Array`.",0.0,javascript
14c83jy,joleoek,"I could write a `CanSlice` trait in my own code, and implement it for the built-in `Vec` type, and then as long I've imported the trait and Rust knows about it, I can use the `slice` method from my trait on the built-in type.",0.27499999999999997,rust
14c83jy,joleoek,"Rust normally exports an `Iterator` trait, which has a bunch of different ways of iterating over collections.",0.075,rust
14c83jy,jokn1n1,"The inconsistencies push you to try to add methods, but this problem does not exist in the first place if you go with plain functions first (see Haskell and typeclass methods).",0.04642857142857143,go
14c83jy,jokn1n1,"The inconsistencies push you to try to add methods, but this problem does not exist in the first place if you go with plain functions first (see Haskell and typeclass methods).",0.04642857142857143,haskell
14c83jy,jok7aiy,Look at Ruby for prior art.,0.0,ruby
14c83jy,jomlyug,"I like how Rust does this particular thing, though it could go further.",0.08333333333333333,rust
14c83jy,jomlyug,"I like how Rust does this particular thing, though it could go further.",0.08333333333333333,go
14c3wkr,,So I've started to work on this new programming language that aims for building machine learning systems (like what Python has being doing so well in recent years).,0.06818181818181818,python
14c3wkr,,"I have thought of some of these small features that might be interesting for AI/ML people:  * better performance over Python (which should be the same case for different sorts of hardware); * better compile time checking, which minimises run time error (such as strongly typed, but would not require a type keyword when initialising variables like Python, so a type inferencing system is required); * better native support for AI/ML code/utils, like built-in tensor types, functions, etc.",0.2425925925925926,python
14c3wkr,,"Please comment below if you have any idea of a cool feature for this language, I appreciate any help :)",0.425,cool
14c3wkr,jok7lut,"One benefit to python is that it allows for lisp-style interactive debugging and notebooks, which are really the only way to practically debug these kind of statistical problems.",0.26666666666666666,python
14c3wkr,jok7lut,"Additionally, almost all of the runtime on large models is spent doing matrix multiplications that are implemented in C, so the python overhead matters very little.",-0.04315476190476192,c
14c3wkr,jok7lut,"Additionally, almost all of the runtime on large models is spent doing matrix multiplications that are implemented in C, so the python overhead matters very little.",-0.04315476190476192,python
14c3wkr,jok7lut,Honestly I think there's not much that can easily be improved on vs Python.,0.3111111111111111,python
14c3wkr,jolfwx6,Even Fortran was better at this than many modern languages.,0.39999999999999997,fortran
14c3wkr,jokppjp,"So because this language is planing to support JIT compiling, a notebook style debugging / documenting system should be relatively easy to implement, so this means dynamic compiling, or more specifically, it will have a compiler and an interpreter, which will support features like interactive debugging and interactive command line tools like Python's idle.",0.3111111111111111,python
14c3wkr,jokppjp,"In terms of the actual performance gain over Python, you are right, the critical part of ML computation is handled with C. However, seeing what Mojo's LLVM & MLIR system can do, I'm confident that with careful optimisation, there are still some potential for these languages to improve upon C's performance, especially in exotic hardware like GPUs, TPUs and NPUs.",0.24081632653061225,python
14c3wkr,jokppjp,"In terms of the actual performance gain over Python, you are right, the critical part of ML computation is handled with C. However, seeing what Mojo's LLVM & MLIR system can do, I'm confident that with careful optimisation, there are still some potential for these languages to improve upon C's performance, especially in exotic hardware like GPUs, TPUs and NPUs.",0.24081632653061225,c
14c3wkr,jokppjp,"Even if there is little performance gain over C, MLIR will provide much better scalability to different hardware without the need for changing much code.",0.128125,c
14c3wkr,jokppjp,"Python is a great language, especially for AI/ML, to dramatically improve the performance of large models like large transformer models, the change has to be low level, so in the implementation of the language used to build the model, or hardware improvements.",0.2457142857142857,python
14c3wkr,jokppjp,"It is hard to build on top of or even surpass Python in some areas, without sacrificing existing develop&debug experience, but like what I mentioned before, it is not impossible.",0.18055555555555555,python
14c3wkr,jov7prv,"So, Haskell's port of torch does this, but it requires type-level integer addition.",0.0,haskell
14c2f6q,,"https://www.youtube.com/@rubykaigi4884/videos  Lost of talks on ruby internals including JIT, typing, picoruby, mruby, jruby and other implementations, concurrency advancements etc.",-0.125,ruby
14c2f6q,jomqq94,I have an interest in alternate ruby implementations.,0.0,ruby
14c2017,,"Hi  A few years ago Ive written a virtual processor runtime and a simple compiler for a somewhat self designed/dialect of a low level assembler language, all written in C++ as a learning project.",-0.06666666666666667,c++
14c2017,,"I also started a simple c like compiler which would generate my asm dialect but wasnt too happy about a small part of the AST, wanted to rewrite it but never done it lol.",0.3375,c
14c2017,,:)   I since would like to rewrite the runtime environment/virtual processor part in Rust.,0.5,rust
14c2017,,"I would give both ""virtual"" adress ranges, for example, ever call to an address of 0x0 to 0x4FFFFFFF would go into the the stack memory, everything above in the heap memory (minus the offset of 0x4FF... ) This would probably work as intended so the host system would only need as many resources as my program running in my VM.",0.1,go
14c2017,,"Feel free to check out the repositories: (Warning, not the best docs and certainly not the best c++ haha)   Virtual Processor/Rumtime Environment  - https://github.com/pointermess/FlexRTE-X  Assembler/Compiler/FlexASM to FlexRTE Executable  - https://github.com/pointermess/FlexASM-Compiler  Some docs if interested  FlexASM Quick Start - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexASM%20QuickStart%20Guide.md - https://github.com/pointermess/FlexRTE-X/blob/master/SystemCalls.md - https://github.com/pointermess/FlexASM-Compiler/tree/master/examples  Flex Executable Format (Basically the generated ""machine""/byte code from my asm dialect)  - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexApplication%20Excutable%20Format.md   Thanks for your time   For the lulz, my unfinished attempt at a tiny C compiler, comes with tokenizer, ast parser and representation.",0.25261904761904763,c++
14c2017,,"Feel free to check out the repositories: (Warning, not the best docs and certainly not the best c++ haha)   Virtual Processor/Rumtime Environment  - https://github.com/pointermess/FlexRTE-X  Assembler/Compiler/FlexASM to FlexRTE Executable  - https://github.com/pointermess/FlexASM-Compiler  Some docs if interested  FlexASM Quick Start - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexASM%20QuickStart%20Guide.md - https://github.com/pointermess/FlexRTE-X/blob/master/SystemCalls.md - https://github.com/pointermess/FlexASM-Compiler/tree/master/examples  Flex Executable Format (Basically the generated ""machine""/byte code from my asm dialect)  - https://github.com/pointermess/FlexASM-Compiler/blob/master/FlexApplication%20Excutable%20Format.md   Thanks for your time   For the lulz, my unfinished attempt at a tiny C compiler, comes with tokenizer, ast parser and representation.",0.25261904761904763,c
14c2017,jokcrsl,If you just use `malloc` (C) or `new` (C++) then it will typically attempt full allocation.,0.10656565656565657,c
14c2017,jokcrsl,If you just use `malloc` (C) or `new` (C++) then it will typically attempt full allocation.,0.10656565656565657,c++
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,r
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,d
14bz7jf,,Now I am 2 years past graduation and into professional work (R&D w/ C++) and I have also done my premasters.,-0.075,c++
14bz7jf,joikybk,Look at Ada and it's subset Spark.,0.0,ada
14bz7jf,jozyn5i,The first talks about how a JS and Go program that are textually almost identical have very different security properties.,0.125,go
14bz7jf,jozyn5i,- I worked on Go's [html/template](https://pkg.go.dev/html/template) library which touches on design of DSLs for [securely composing network messages](https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition) from untrusted and trusted strings.,0.4,go
14bz7jf,joj4bkb,Look at papers about Rust.,0.0,rust
14bz7jf,joj4bkb,Rust took a lot of stuff from Cyclone and then put it in a security critical path.,0.0,rust
14bz7jf,joklvnx,Haskell and Rust should provide plenty of opportunities to write real code with strong static guarantees.,0.37777777777777777,haskell
14bz7jf,joklvnx,Haskell and Rust should provide plenty of opportunities to write real code with strong static guarantees.,0.37777777777777777,rust
14bz7jf,joklvnx,"You could also look into properly dependently-typed languages, but they tend to lack a large ecosystem, so I'd say Haskell is currently the farthest you can go.",0.07142857142857142,haskell
14bz7jf,joklvnx,"You could also look into properly dependently-typed languages, but they tend to lack a large ecosystem, so I'd say Haskell is currently the farthest you can go.",0.07142857142857142,go
14bz7jf,jp0c941,"For example, Java's stronger typing makes it easy to preserve invariants around what messages an object can respond to.",0.43333333333333335,java
14bz7jf,joktk1o,"Thanks, I thought there'd be more ""use rust"" everywhere without any consideration of what came before.",0.35,rust
14bz7jf,jojquvp,"For example, you could safely download a json package without fear of it being rootkitted, because for that module to either touch the network or spawn a shell, it would require a network Auth or shell Auth token (neither of which would be required for a legitimate json library).",0.5,shell
14bz7jf,jokthru,"Ada forces you to make objects aliased if you need to access them through another object and it limits their scope and usage, you can extend it in unsafe ways in which  you have to specify, i.e.",0.0,ada
14bz7jf,jokthru,Parallel blocks are in Ada 2022.,0.0,ada
14blzws,jogwzfc,Obviously ignore the fact that Java messed up the default treatment of arrays.,0.0,java
14blzws,jogqayy,"Got your point, thanks for your answer :D  Currently I'm unable to write your counter-example in TS because it seems that TS isn't smart enough, but if the type system allowed me to exploit the invariant of `f` and `s` having the same type I would have had some surprises at runtime if `Pair<U | V>` and `Pair<U> | Pair<V>` were considered equal.",0.13061224489795917,d
14blzws,joh0ceu,I think a restricted version of F<A | B> ⊆ F<A> | F<B> might be to force A and B to be linear types (which will probably not happen in typescript).,0.0,typescript
14blzws,johv1su,They may return different functions using a ki d of switch statement on their type arguments.,0.0,d
14blzws,johlvj0,The go to book for starting out in my understanding is Benjamin Pierce's Types and Programming Languages.,0.0,go
14blzws,jolb0lo,Thanks for the clarifications anyway :D,0.6,d
14b8c0r,,"Egel is implemented in C++ without an explicit garbage collector, parallel evaluation is simply spawning of another root node, and the graph -or parts of the graph- can be serialized, shipped, or saved to disc.",0.0,c++
14b8c0r,,"Referencing combinators that are not present for whatever reason (for instance, opaque objects like file handles or dynamically loaded c code) is undefined behaviour.",0.0,c
14b8c0r,,"import ""egel_rpc.ego""          using System          def main =          let C = rpc_client ""localhost:50001"" in              rpc_call C [_ -> [X -> X] ] 42  In the above example, a lambda is sent to server, that returns the identity function to the client, and the client applies that to the constant 42.",0.05555555555555555,c
14b8c0r,,"import ""prelude.eg""      import ""egel_rpc.ego""          using System using List          def main =          let C = rpc_client ""localhost:50001"" in              rpc_call C [_ -> from_to 1 1000 ] |> sum   It works reasonably well but I am still wrinkling out the features.",0.18333333333333335,c
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,java
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,python
14b7jqi,jof3p9j,"Since Java bytecode uses MUTF-8, which encodes astral characters as surrogate pairs, I've had to implement this conversion in Python multiple times, in [Krakatau](https://github.com/Storyyeller/Krakatau) and [Enjarify](https://github.com/Storyyeller/enjarify) (as well as in Rust for Krakatau v2).",0.0,rust
14acrae,,"Rust went the GAT way, and all pure functional languages that have HKTs that I know don't monomorphize.",0.21428571428571427,rust
14acrae,,"C++ and D template metaprogramming come somewhat close, but are not exhaustively type-checked like proper implementations of HKTs.",0.0,c++
14acrae,,"C++ and D template metaprogramming come somewhat close, but are not exhaustively type-checked like proper implementations of HKTs.",0.0,d
14acrae,jobtxo7,But HKT is perfectly compatible with monomorphization and it would work fine in Rust.,0.7083333333333334,rust
14acrae,jo9vza1,"Also, Haskell has its equivalent of GATs through functional dependencies.",0.0,haskell
14acrae,jo9vza1,"Finally, functional languages face different tradeoffs than Rust does.",0.0,rust
14acrae,jo9vza1,"By contrast, for a language like Rust, different types are represented differently on the stack, so even something as simple as hard-coding the size of stack allocations can be a big win.",0.16,rust
14acrae,jobul1u,"I think they are as expressive as Haskell's HKTs (you can define abstractions for functors, monads, etc), but notationally much more cumbersome.",0.65,haskell
14acrae,jobul1u,"`(Type -> Type) -> Type`) things get quite hairy, and while I think the module language is strong enough to express it, it becomes quite a Turing tarpit compared to Haskell.",0.21666666666666665,haskell
14acrae,jocqg4b,"From what I've heard, Standard Chartered's Haskell variant Mu also uses monomorphization, I'm guessing it must support HKTs, otherwise, it wouldn't really be Haskell-like, but I don't have first-hand knowledge of it.",0.1,haskell
14acrae,joc5z8s,">so far these languages only allow parameterisation over types, not type constructors  C++ has ""template template"" parameters though.",0.05,c++
14a79va,jo9731m,"*/     	free(p);  /* `p` is `free()`d and `moved`, we can no longer use it.",0.0,d
14a79va,jo9731m,"*/     	free(p);  /* error: `p` has already `moved` */     }  Even wrote a POC C parser so I could extend the type system and enforce this, but never completed it because life caught up.",0.0,c
14a79va,jo91kix,"I liked lot of parts for instance:  ""As any C programmer knows, we carefully track who owns the data,"" "" We have a mental distinction between owning pointers and non-owning pointers.""",0.13333333333333333,c
14a79va,jo91kix,```c struct X * p = malloc(1); ```  In this case we can infer that p is owner without annotation.,0.0,c
14a79va,jobg5r0,"very interesting paper, maybe i could implement something like this in my c compiler and make it more memory safe.",0.5499999999999999,c
14a79va,jobg5r0,"nowadays the power of c comes exactly from these two points, you can deal with your memory in the way you want, and this makes it possible to create very smart architectures adhoc for your software.",0.1761904761904762,c
14a79va,joa7krr,"It allows cheap and small actors to perform garbage collection concurrently with any number of other actors, and this number can go into the millions since one actor needs only 256 bytes on 64bit systems.",0.0062500000000000056,go
14a79va,job9xz0,"For example:      users = [userAlice, adminBob, evilCharlie]     adminIDs = [1]     ...     users.remove(0) // Alice deleted her acouunt     ...     for index in adminIDs:         giveSecretsTo(users[index])         // whoops, just gave secrets to Evil Charlie!",-1.0,alice
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,rust
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,c
14a79va,jobp9r6,"While I agree in general (and btw this is what bugs me about Rust, it also seems to encourage using indices when the borrow checker gives up), a segfault isn't guaranteed in C or C++, it's undefined behavior that might be also hard to debug.",-0.12083333333333333,c++
14a79va,joizi09,"Here's another example:      users = [alice, bob, charlie]     gifts.append({recipient_id=1, item=""Apple""}) // Give Bob an apple     ...     users.remove(0) // Delete Alice     ...     for gift in gifts:         users[gift.recipient_id].send_message(""You got a ""+gift.item)         // Whoops, just told Charlie he got an apple instead of Bob  A more safe way to approach this would be with a map from globally unique IDs to users: `users = {alice.id: alice, ...}`.",0.4583333333333333,alice
14a79va,jodn5rt,> a segfault isn't guaranteed in C or C++  Yep!,0.0,c
14a79va,jodn5rt,> a segfault isn't guaranteed in C or C++  Yep!,0.0,c++
149vqg4,,"I know that TypeScript allows you to specify array types like this: [Header, ...Body[], Tailer].",-0.75,typescript
149vqg4,jo7d336,"There are some nice languages for implementing state machines, like Ragel, which can emit code in C and C++.",0.6,c
149vqg4,jo7d336,"There are some nice languages for implementing state machines, like Ragel, which can emit code in C and C++.",0.6,c++
149vqg4,jo7guzo,"Clojure spec allows you to type collections using regular expressions, but they are only checked at testing/runtime, not statically.",0.0,clojure
149vqg4,jo8j38j,Or like in Rust if something is marked [must_used](https://doc.rust-lang.org/std/hint/fn.must_use.html) it can be used to trigger the problem.,0.1,rust
149vqg4,jo7lre7,I'm fairly certain you can do this in scala 3.,0.21428571428571427,scala
149vqg4,jo7lre7,"Effectively scala 3 tuples can be used as standard functional single linked lists, but with every value having a different type.",0.13214285714285715,scala
149vqg4,jo8hree,Erlang bit syntax is somewhat related to this.,0.0,erlang
149vqg4,joby1py,But I would rather have solid runtime checks with best-effort static checking than the brokenness of Typescript or the limitations of a statically checkable system.,0.25,typescript
149vqg4,jodi9wk,"In Rust, it's usually done manually via session types:      pub fn stream() -> (Sender<Header>, Receiver<Header>);      pub struct Sender<T>(...);      impl Sender<Header> {         #[must_use]         pub fn send_header(self, header: Header) -> Sender<BodyPart>;     }      impl Sender<BodyPart> {         #[must_use]         pub fn send_body(self, body: BodyPart) -> Self;          pub fn send_tailer(self, tailer: Tailer) -> Sender<Header>;     }  So, that's cool, we have a state machine that enforces the sequence Header, followed by any number of BodyParts, followed by Tailer.",0.04999999999999999,rust
149vqg4,jodi9wk,"In Rust, it's usually done manually via session types:      pub fn stream() -> (Sender<Header>, Receiver<Header>);      pub struct Sender<T>(...);      impl Sender<Header> {         #[must_use]         pub fn send_header(self, header: Header) -> Sender<BodyPart>;     }      impl Sender<BodyPart> {         #[must_use]         pub fn send_body(self, body: BodyPart) -> Self;          pub fn send_tailer(self, tailer: Tailer) -> Sender<Header>;     }  So, that's cool, we have a state machine that enforces the sequence Header, followed by any number of BodyParts, followed by Tailer.",0.04999999999999999,cool
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,rust
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,c
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,python
149vqg4,jo8n3tg,"This seems to be popular even among modern imperative languages (Rust, C#, Python, JavaScript, ...) and I quite like this approach.",0.4,javascript
149vqg4,jo9bibi,"I'm don't know much Erlang, so I'm wondering is there a difference between giving the ascii code points as numbers      <<82,73,70,70>>:4/binary-little, %""RIFF""  compared to specifying it with the ascii string itself      <<""RIFF"">>:4/binary-little,  The latter would feel a bit more ergonomic to use.",0.2333333333333333,erlang
149vqg4,jo8nwkr,"Unless you mean that thing which TypeScript calls tuples, because that is pretty much what I'm interested in.",0.096875,typescript
149vqg4,jo9evma,"IIRC, in Erlang a string is just syntactic sugar around a binary.",0.0,erlang
149vqg4,jo9evma,The code I pasted was lifted directly from an actual program I wrote while learning Erlang.,0.05,erlang
149fzge,jo6vuh7,This is basically the C++ approach.,0.0,c++
149fzge,jo6vuh7,"This is basically the Java approach, especially since generics are erased at runtime.",0.0,java
149fzge,jo8vhv0,"I will go with the c++ way, thanks!",0.25,go
149fzge,jo8vhv0,"I will go with the c++ way, thanks!",0.25,c++
149fzge,jo8ydgo,"In the case of C++, template instantiation is *roughly* similar to macro expansion.",0.0,c++
149fzge,jo8ydgo,I don't know how clever C++ compilers are at reusing work.,0.16666666666666666,c++
149fzge,joajp8g,"Again, I'm not quite sure how C++ compilers work under the covers.",0.5,c++
148szdv,,"As I'm sure many of you will be aware, when implementing a new language, the ability to call C code from it is very useful because of the ubiquity of existing software and libraries in said language, and because in most OSes it's the only way you can talk directly to the OS.",0.29704545454545456,c
148szdv,,"This had me thinking, gee it'd be great if I could automatically import the stdlib declarations from C headers into my language without having to write special ""glue"" code for each declaration I want to import...",0.5785714285714286,c
148szdv,,"I figured I could use a minimised C parser that is only designed to understand declarations (no definitions, function implementations or whatever), to parse any C header file that is requested, and then comb the declarations out of there.",0.0,c
148szdv,,"This should work fine for all C code which only consists of declarations, however there's a big issue here: what about macros?",0.1388888888888889,c
148szdv,,Edit: I'm wondering whether I should look into using SWIG for this and consume the XML parse tree it outputs for C headers on my end...,0.0,c
148szdv,jo1snic,">the ability to call C code from it is very useful because of the ubiquity of existing software and libraries in said language, and because in most OSes it's the only way you can talk directly to the OS.",0.2475,c
148szdv,jo1snic,"These just happen to be low level machine types, they are not specific to C.  But it is unfortunate that APIs for such libraries are very often expressed as C header files, using C syntax, which is really unsuitable for describing cross-language interfaces, for many reasons some of which you've discovered:  * It is necessary to parse C declaration syntax * Nested includes need algorithms (which are implementation-defined) to locate header files, together usually with a location for system headers, and a bunch of search locations for others * Headers may include conditional blocks using `#if`, `#ifdef` and so on.",0.01666666666666667,c
148szdv,jo1snic,"* Macro may expand to arbitrary C expression syntax * Instead of enumerations, headers may use tons of `#defines` to declare global constants.",-0.05,c
148szdv,jo1snic,There isn't really a simple solution that doesn't involve at least half of a C compiler.,-0.15555555555555556,c
148szdv,jo1snic,It does involve a home-made C compiler.,0.0,c
148szdv,jo1snic,"Some macro are simple, but others can contain arbitrary C code, expressions or statements.",-0.05,c
148szdv,jo1snic,Now you need a transpiler *from* C to your language (the other way is more common!).,0.0,c
148szdv,jo1snic,"Sorry I don't have a solution for you, and don't really like solutions that involve a C compiler (I think Zig bundles Clang for example).",-0.15,c
148szdv,jo1up8e,luajit ffi does a similar thing and it just ignores the macros....      it expects fully preprocessed C headers.,0.0,c
148szdv,jo1up8e,"alternatively you can just run the headers through a preprecessor first...       unless they contain some c code rather then type definitions, then this whole thing becomes useless",-0.016666666666666663,c
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,pascal
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,c
148szdv,jo2yqa4,"There was a `PIncludes` folder for Pascal, a `CIncludes` folder for C, and an `AIncludes` folder for the assembly language interface.",0.0,assembly
148szdv,jo2yqa4,"A more modern approach is to write a tool to do a rough parse of the preprocessed C headers (I once wrote [a simple regex-based PHP script for that](https://github.com/uliwitness/Forge/blob/2c9e3245896342d10875629c1817bce909872a17/headerimport.php) for Apple platforms) and then add an ""overlay"" of hand-written code in your language that can replace parts of the automated import, or provide a more native interface.",0.22000000000000003,c
148szdv,jo2yqa4,"A more modern approach is to write a tool to do a rough parse of the preprocessed C headers (I once wrote [a simple regex-based PHP script for that](https://github.com/uliwitness/Forge/blob/2c9e3245896342d10875629c1817bce909872a17/headerimport.php) for Apple platforms) and then add an ""overlay"" of hand-written code in your language that can replace parts of the automated import, or provide a more native interface.",0.22000000000000003,php
148szdv,jo2yqa4,"Swift does that very well, but I think Perl does something similar.",0.1,swift
148szdv,jo2yqa4,"Swift does that very well, but I think Perl does something similar.",0.1,perl
148szdv,jo2yqa4,"Swift allows this by annotating API so it gets imported ""hidden"" and can only be used by the overlay.",-0.08333333333333333,swift
148szdv,jo2yqa4,"In any way, as C API is often not complete anymore, you'll likely end up writing a different script for each platform, one to parse Apple's Swift interfaces, one for Microsoft's C# interfaces etc.",-0.016666666666666666,c
148szdv,jo2yqa4,"In any way, as C API is often not complete anymore, you'll likely end up writing a different script for each platform, one to parse Apple's Swift interfaces, one for Microsoft's C# interfaces etc.",-0.016666666666666666,swift
148szdv,jo2yqa4,You might even write it so that it generates little C adapter functions based on attribute annotations and other things a particular platform's headers contain (e.g.,-0.04861111111111111,c
148szdv,jo2yqa4,Apple's headers use a proprietary 'nullable' attribute on all C headers to provide information C usually doesn't have).,-0.25,c
148szdv,jo3jzmq,In general as many others have mentioned C headers are a nasty pice of code and you'll effectivly need a full C compiler to parse them.,-0.024999999999999994,c
148szdv,jo3jzmq,Solutions to this problem include  a) Just have C or large parts of it as a subset in you language.,0.21428571428571427,c
148szdv,jo3jzmq,This is for the most part what C++ does.,0.5,c++
148szdv,jo3jzmq,"(More technically however most C headers still have to use ifdef CPP wrapped extern ""C"" blocks to get the name mangling right.)",0.3214285714285714,c
148szdv,jo3jzmq,"b) Just like a) but instead of really being a real subset, we parse C files with a different tokenizer, that remapps common tokens like ""if"", ""for"" and ""int"" onto specialized C version.",0.02500000000000001,c
148szdv,jo3jzmq,This would allow you to not being forced to have C constructs to take all the sweetspots.,-0.30000000000000004,c
148szdv,jo3jzmq,c) Have a bindgen tool like Rust's cbindgen.,0.0,c
148szdv,jo3jzmq,c) Have a bindgen tool like Rust's cbindgen.,0.0,rust
148szdv,jo3jzmq,This uses libclang to parse you code and then create somehow meaningfull Rust code from it.,0.0,rust
148szdv,jo3jzmq,d) Just like c) but have that tool as a buildin into your language directly.,0.1,d
148szdv,jo3jzmq,d) Just like c) but have that tool as a buildin into your language directly.,0.1,c
148szdv,jo4z5u8,A language I worked on used the clang library to generate bindings (rather than the compiler reading c files directly).,0.1,c
148szdv,jo4z5u8,It also supports some limited amount of C++ bindings which further complicates things.,-0.03571428571428571,c++
148szdv,jo3dix7,"In what I can only describe as _thoroughly annoying_, it turns out that stdlib implementations often don't just contain macros that we have to handle, but actual C code too (not just prototypes)!",-0.26666666666666666,c
148szdv,jo3jn0g,"It's almost like this problem is so annoying that I'm better off just building a library that documents the structure of the C stdlib in a machine-readable way using data structures, from which then any needed C glue code can be generated to lift out macro definitions and what-not...",-0.15000000000000002,c
148szdv,jo1t4cu,"I am really curious about your tool that parses C headers, would you mind linking to it, if it's openly available?",0.15000000000000002,c
148szdv,jo4wpme,C isn’t portable at all either without tons of macros.,0.0,c
148szdv,jo2zp1g,"That's cool, thanks!",0.3,cool
148szdv,jo2zp1g,"I won't be wanting to parse function definitions like `int main(){}`, only declarations such as `int rand();`...  Re typedefs, yes I am already anticipating needing to do some kind of typedef-tree lookup in my parser for this (looking at preprocessed C source made it abundantly clear of the need to do so!).",0.17833333333333332,c
148szdv,jo2zzmf,"Really cool and thorough history story, thanks!",0.3,cool
148szdv,jo2zzmf,"On adapting things, I've already contended with that at the bare minimum, I will need to write some additional C code of my own to be patched onto the end of any stdlib headers that define macros that I might want to use in my lang...",0.325,c
148szdv,jo2zwac,"I've thought about doing that, but I'd really like to avoid writing a whole C macro processor if I can possibly avoid it...",0.13333333333333333,c
148szdv,jo2zwac,I'd ideally like to take the cleanest fairly robust route towards turning a C header into a bunch of symbol definitions to import.,0.8,c
148szdv,jo37oxd,"Oh wait, I think I misunderstood —do you mean, process all C stdlib headers whilst my language compiler is being compiled?",-0.3125,c
148szdv,jo2zos6,The tool is based on a C compiler I created a few years ago.,-0.2,c
148szdv,jo2zos6,"I assume you're on Linux, but if you want to try it out, as an example of how it might work, try downloading this single-file C rendering of my compiler, which is for Linux:  [https://github.com/sal55/langs/blob/master/temp/cc.c](https://github.com/sal55/langs/blob/master/temp/cc.c)  This should be built using `gcc cc.c -occ -lm -ldl -fno-builtin`.",-0.75,c
148szdv,jo2zos6,"And C source may use names that are keywords in my syntax, although some are taken care of.",0.0,c
148szdv,jo2zos6,"In general however it will have trouble compiling arbitrary C code, even just the headers.",-0.08333333333333333,c
148szdv,jo2zos6,"Sometimes, a single DLL exists that corresponds to the C module name, in which case I can remove the `$`.",-0.07142857142857142,c
148szdv,jo2zos6,"In general, it will consist of C expression syntax, that needs to be translated by hand.",0.05000000000000002,c
148szdv,jo2zos6,ETA: [this](https://github.com/sal55/langs/blob/master/temp/cc_export.m) is the exports module of my C compiler that handles the `-mheaders` option.,-0.75,c
148szdv,jo30e0c,"If it worked, I would have used it on `windows.h`, which is a collection of 100-150 header files, which use `#define` extensively:      #define CommDlg_OpenSave_GetSpecA(h,p,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)p)",0.0,c
148szdv,jpfyoed,So why import the raw standard C library?,-0.11538461538461539,c
148szdv,jpfyoed,"C arrays and strings don't know their length, something most modern languages have built in.",0.35,c
148szdv,jpfyoed,"So it may be worth taking a step back, and instead of importing the C standard library, creating your own library that is implemented using standard C calls so it's portable.",0.18,c
148szdv,jpfyoed,Especially C's string manipulation is rudimentary.,0.0,c
148szdv,jpfyoed,So why even bother with C calls that don't support that?,0.0,c
148szdv,jo30c2g,"Really cool, thanks for sharing!",0.3,cool
148szdv,jo31t1x,"An initial workaround I can think of, at least for the stdlib, is to special-case them with some additional C code to extract them.",-0.15,c
148szdv,jo31t1x,"Apparently, you can ask GCC to dump macro names ~~(but not values)~~ with different options:    https://stackoverflow.com/questions/24388575/print-all-defined-macros   _Correction: I get both names **and** values when I use it!_   In any case, it seems to me the ideal would be to have a way to extract object-like macro definitions from C headers, but have the macro processing done separately...",0.3166666666666667,c
148szdv,jo33vha,"Those intrinsics, for example:      #define _mm256_mask_cvt_roundps_ph(A,B,C,D) _mm256_mask_cvtps_ph ((A), (B), (C), (D))  may be necessary for the *implementation* of SDL, where it will pull in the same system headers (or might not be needed at all, and they are just there), but they are certainly not needed to just use the SDL library via its API, so they don't need to be part of your bindings for the library.",-0.03571428571428571,c
148szdv,jo33vha,"Those intrinsics, for example:      #define _mm256_mask_cvt_roundps_ph(A,B,C,D) _mm256_mask_cvtps_ph ((A), (B), (C), (D))  may be necessary for the *implementation* of SDL, where it will pull in the same system headers (or might not be needed at all, and they are just there), but they are certainly not needed to just use the SDL library via its API, so they don't need to be part of your bindings for the library.",-0.03571428571428571,d
148szdv,jo3728d,"Also, unintuitive things like remembering that C's canonical `bool` is actually named `_Bool`..!",0.0,c
148szdv,jo3hcar,"If I set up this test input (which also takes `SIZE_MAX` that you mentioned elsewhere, and copies it from the system header):      #include <stdint.h>          #define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL     #define SIZE_MAX ULLONG_MAX          struct T1 {int x,y;};     typedef struct T2 {int x,y;} P2;     typedef int newint;          newint F(int64_t, struct T1, P2);          enum {abc=100, def=200};     int x,x,x;     int y,z=300;  Then the output produced is:      importdll $c =         record T1 = $caligned             i32 x             i32 y         end              record T2 = $caligned             i32 x             i32 y         end              func ""F""               (i64,T1,T2)i32         const abc              = 100         const def              = 200         i32 x         i32 y         i32 z =300     end     global const ULLONG_MAX = 0xFFFFFFFFFFFFFFFFLL     global const SIZE_MAX =  ULLONG_MAX  Here, `ULLONG_MAX` also had to be extracted, since the define chain is split between user- and system headers.",0.0,c
148szdv,jo3hcar,"In real code, there is the possibility of a clash between struct tag names and ordinary identifiers, since few languages have copied those peculiar namespaces from C.",-0.08333333333333333,c
148szdv,jo3m09o,"In original C code outside of macros, then `123ULL` would have `u64` type, however such constants I don't think occur in declarations, except perhaps as enum values, but C limits those to `int` values (maybe some apply extensions for wider types).",0.125,c
148szdv,jo3m09o,"When it comes to C runtime functions that users of my language want to call, then I write those bindings manually.",0.0,c
148szdv,jo3m09o,"While there can be over 1000 functions in the C runtime, I only define a few dozen.",-0.1,c
148pni0,,&#x200B;  I guess this is what makes scheme such a powerful language.,0.15,scheme
148pni0,,scheme really does capture the essence of computation?,0.2,scheme
148pni0,jo1grje,"IMO, Kernel captures the essence of computation much more than Scheme, even though the languages look similar on the surface.",0.25,scheme
148pni0,jo2l4ou,"The linker merges some variables together for languages following the C model but even then things get way more interesting with dynamic linking and multi-threading thrown in (especially with the ""C"" model).",0.2,c
148pni0,jo2l4ou,"Java doesn't have ""global variables"" though it has static class level variables which suffer some of the same downsides as truly ""global"" variables.",0.125,java
148pni0,jo2l4ou,"Java also doesn't have dynamic scope (which at least one Scheme, MIT-Scheme supports via fluid-let and dynamic-wind (apparently conceptualized by RMS)).",-0.08333333333333333,java
148pni0,jo2l4ou,"Java also doesn't have dynamic scope (which at least one Scheme, MIT-Scheme supports via fluid-let and dynamic-wind (apparently conceptualized by RMS)).",-0.08333333333333333,scheme
148pni0,jo2l4ou,Steve Yegge claims dependency injection (aka Guice) is related to Java not having dynamic scope and I'm inclined to hear him out a bit.,0.0,java
148pni0,jo2l4ou,"What SICP never showed was how this might end up optimized, by a smart enough compiler, to exactly create what say a Java compiler might produce (namely a shared method table plus an array of values (aka instance variables).",0.15476190476190477,java
148pni0,jo2l4ou,"I believe MIT-Scheme got reasonably close with ""multi-closures"" which I think only need a level of indirection plus interning to behave more like Java style dispatch.",0.2333333333333333,java
148pni0,jo2l4ou,People weren't writing Scheme code in an OOP style so at best chicken and the egg to incentivize certain work.,0.20476190476190478,scheme
148pni0,jo2l4ou,"Of course to compare with C++ where much dynamic dispatch is actually statically done, that might be a heavier lift.",0.0,c++
148pni0,jo1ekqi,The ability to embed assembly in your language allows you to get rid of absolutely everything  /s,0.2,assembly
148pni0,jo2dwbj,"From a certain perspective, therefore, there are no ill-typed Scheme, Python, BASIC, etc.",0.10714285714285714,scheme
148pni0,jo2dwbj,"From a certain perspective, therefore, there are no ill-typed Scheme, Python, BASIC, etc.",0.10714285714285714,python
148pni0,jo1r3fs,"It is true that we _can_ legally type all terms in, say, lisp, with Int | Cons Object Object | Lambda [...] | Symbol | etc., though of course, as you say, that doesn't give us anything useful.",0.2833333333333334,lisp
148pni0,jo1r3fs,"We could also take a (well-formed) haskell program, strip it of its type annotations, and type all its terms in just the same way, and that would be completely valid too (and just as useless).",-0.13333333333333333,haskell
148pni0,jo1fz77,"I can run the same haskell program on and M1 mac, on x86, and on ARM, but if embedded assembly were possible, then the program would fundamentally only run on one cpu architecture.",0.0,haskell
148pni0,jo1fz77,"I can run the same haskell program on and M1 mac, on x86, and on ARM, but if embedded assembly were possible, then the program would fundamentally only run on one cpu architecture.",0.0,assembly
148pni0,jo5sho8,"He carefully read the entire ""Lambda: The Ultimate..."" series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system.",-0.0875,scheme
148pni0,jo369a6,"There are examples of tools which reject badly typed or insufficiently typed dynamic languages statically, such as Erlang's dialyzer.",-0.23333333333333328,erlang
148pni0,jo369a6,I know because I spent a long time there myself before I learned Scheme and then later Kernel (which I discovered when searching for solutions to problems I had with macros and quotation).,-0.05000000000000001,scheme
148pni0,jo369a6,"The presence of preprocessors, never-ending extensions to Haskell and tools like TemplateHaskell demonstrate that static typing is clearly less expressive than we want it to be.",0.37777777777777777,haskell
148pni0,jo1uwit,"Statically typed languages with statically resolved overloading cannot have the types stripped without affecting semantics, but that overloading doesn't tend to go well (moreso with subtyping that isn't respected by the dynamic semantics), so that doesn't really bother me.",0.1,go
148pni0,jo1y6xj,"If I add a `list` to a `list of int`, should this return (a) an error (b) return a `list` (c) a `list` if some of the elements of the first list aren't `int`, but a `list of int` if they all are (d) an error if some of the elements of the first list aren't `int`, but a `list of int` if they all are?",0.25,c
148pni0,jo1y6xj,"If I add a `list` to a `list of int`, should this return (a) an error (b) return a `list` (c) a `list` if some of the elements of the first list aren't `int`, but a `list of int` if they all are (d) an error if some of the elements of the first list aren't `int`, but a `list of int` if they all are?",0.25,d
148pni0,jo40cfm,I just claim you get a quantum leap in benefits from type checking when you go from optional to mandatory.,0.0,go
148pni0,jo40cfm,"And I don't dispute that the profusion of extensions to Haskell shows *something*, but I'd argue it is more about the limitations of *Haskell* than the limitations of type-checking as a convention.",0.5,haskell
148pni0,jo40cfm,"The choice to use, say, TemplateHaskell rather than C++ means someone sees a certain benefit to making that particular compromise.",0.19047619047619047,c++
148pni0,jo33rkt,"Simply-typed lambda calculus gets around this by being sufficiently restricted that its type system can be both sound and complete (I believe this is correct—it's been a while since I've been in close quarters with these issues, and I haven't bothered to go through the exercise of proving it), but most programming languages prefer to let you write real programs in them instead.",0.3,go
148pni0,jo3pw4k,"For example, in Dart:      extension IntExt on int {       int get increment => this + 1;     }      main() {       var n = 1;       print(n.increment); // ""2"".     }",0.16666666666666666,dart
148pni0,jo3pw4k,You can't make a functioning C++ implementation without a type checker.,0.0,c++
148pni0,jo3pw4k,"> In the case of something more interesting like indirect method calls, the static type annotations do not direct semantics;  Sure, dynamic dispatch doesn't require static types, as Smalltalk, JavaScript, Ruby, etc.",0.35000000000000003,javascript
148pni0,jo3pw4k,"> In the case of something more interesting like indirect method calls, the static type annotations do not direct semantics;  Sure, dynamic dispatch doesn't require static types, as Smalltalk, JavaScript, Ruby, etc.",0.35000000000000003,ruby
148pni0,jo3i6kw,I would consider overloading in Haskell.,0.0,haskell
148k8qy,,"If you'd ever wanted to just brain dump language ideas that should be in C, here's the time someone would actually appreciate it.",0.0,c
148k8qy,jo18f0p,"For start, few things that I miss in og C and just can't refuse this opportunity to rant about them, even though they are pretty specific and mostly don't make sense in your C3:  * typedefs nested inside structs etc.",0.1375,c
148k8qy,jo18f0p,"that don't pollute global namespace * GCC-like nested functions, but pointer to them can be safely returned by the enclosing function in the special case that they don't access closure * builtin constant that tells you how many parameters a variadic macro got passed in * builtin variadic macro that applies other macro to all its parameters * ability to split wide char literal into multiple pieces just as you can with strings ( `'a' 'bc'` would be the same as `'abc'`) (ofc wide chars are useless historical artefact, but this totally random inconsistency just triggers me for some reason)  As far as more generally useful features go:  * Ability to declare variables of type `void` and generally just use `void` as you use any other type (can be stored, loaded and passed to functions, all operations, iterations on `void[]` etc.",0.04761904761904761,go
148k8qy,jo18f0p,"* Post-assignment operators (like post-increment/decrement, but generic assignment operation) - I don't have a good idea how the syntax should look like, but it's just really inconsistent, that C has post- variants specifically for `++`, `--`, but not for anything else.",0.3,c
148k8qy,jo1ej96,Go has this and it's a huge headache when it comes to dealing with databases.,0.4000000000000001,go
148k8qy,jo1ej96,Even go introduced the reflection API to enable this.,0.0,go
148k8qy,jo2zxkm,I think you'd probably get more suggestions if you didn't assume everyone reading this Reddit had a GitHub account and was willing to go through the effort of going through a GitHub Issues form.,0.375,go
148k8qy,jo2zxkm,"I at least am happy to suggest a few things off-the-cuff in Reddit while I'm already there, but that's as far as I'm willing to go for a stranger without pay.",0.13,go
148k8qy,jo0nejk,I’d like to see c and c++ six feet under where they belong to be.,0.0,d
148k8qy,jo0nejk,I’d like to see c and c++ six feet under where they belong to be.,0.0,c
148k8qy,jo0nejk,I’d like to see c and c++ six feet under where they belong to be.,0.0,c++
148k8qy,jo0y60j,First class arrays with strict aliasing like FORTRAN.,0.25,fortran
148k8qy,jo0y60j,That's my number one feature for any low-level language trying to improve upon C.,0.0,c
148k8qy,jo1a6ql,">If you'd ever wanted to just brain dump language ideas that should be in C,  In C, or in C3?",0.0,c
148k8qy,jo1a6ql,The feature list you recently posted for the latter already covers most of the things people want to have in C. (Other than C++ features without being C++; that seems a very common desire.),-0.0030000000000000027,c++
148k8qy,jo1a6ql,The enhancements you've already made to C are plenty to be going on with.,0.0,c
148k8qy,jo3vbpb,"I'd like sum types (Rust `enum`s) and pattern matching, but that seems to conflict with 'zero is initialization'.",0.0,rust
148k8qy,jo0g9vr,For a moment I though that the CONST passive-agressive was a C like feature,0.0,c
148k8qy,jo0n4is,Memory safety through the borrow checker is Rust's main feature.,0.16666666666666666,rust
148k8qy,jo0n4is,"But it requires things like move semantics, which is very different from C semantics.",0.0,c
148k8qy,jo0n4is,"As C3 is an evolution on C, it doesn't fit well.",0.4,c
148k8qy,jo1v08a,Rust's memory safety is via the type system.,0.0,rust
148k8qy,jo1v08a,The OP's response mentioning Rust's borrow checker suggests that you're talking past each other.,-0.1875,rust
148k8qy,jo1f3df,"that don't pollute global namespace  Is that particularly useful in C because of headers and no namespacing, or is there something else you want it for?",0.15,c
148k8qy,jo1gvbd,"> Go has this and it's a huge headache when it comes to dealing with databases  Ok, so I'm not sure how the problem arises there, but I would assume that fields are passed by reference as pointers, in which case you have `null` as null and everything should be fine.",0.2666666666666667,go
148k8qy,jo1gvbd,"> somestruct.set(""name"")=""bob""  This is super cool, but assumes that ""name"" is available at runtime.",0.36111111111111116,cool
148k8qy,jo13y56,Maybe we should do away with assembly languages and even machine code while we're about it.,0.0,assembly
148k8qy,jo13y56,Meanwhile C is commonly used as a target or intermediate language by such higher level languages as Nim or Haskell.,-0.016666666666666663,c
148k8qy,jo13y56,Meanwhile C is commonly used as a target or intermediate language by such higher level languages as Nim or Haskell.,-0.016666666666666663,haskell
148k8qy,jo13y56,"BTW the thread isn't about C or C++, but ideas suitable for that level of language.",0.55,c
148k8qy,jo13y56,"BTW the thread isn't about C or C++, but ideas suitable for that level of language.",0.55,c++
148k8qy,jo50bbv,"When you say sum types and mention Rust, I assume you basically mean tagged unions?",-0.3125,rust
148k8qy,jo50bbv,"That is not necessarily difficult, but I've found it somewhat hard to find good syntax for it that meshes with C syntax.",0.21944444444444441,c
148k8qy,jo50bbv,"Plus in C at least I run into the case where a single ""tag"" field affects the interpretation of multiple separate union members in a struct.",-0.12380952380952381,c
148k8qy,jo50bbv,"I extended the switch in C to take arbitrary ""case"" expressions, making it a lot like pattern matching but without the binding.",-0.1,c
148k8qy,jo3eurl,"Best solution I found so far how to solve this runtime-overhead-free in og GCC C is by defining zero-length array of the handle type inside the node type ([like here](https://github.com/MarkusSecundus/Shell/blob/main/datastructs/ultimate_list.h)) and then using `__typeof__(node->_handle_typeinfo[0])` or something like that xDD, which is just so insanely ugly.",0.1333333333333334,c
148k8qy,jo3eurl,"Defer is a cool feature, but your syntax still doesn't reach the elegance I could imagine with post-assignment oneliner.",0.35,cool
148k8qy,jo3eurl,"From surface view, your language looks pretty cool, I'll definitely look into it more as soon as I'm over with state exams xD.",0.275,cool
148k8qy,jo1krmo,"(C3 also has some ability to annotate for null safety)  Let's say you have three fields in a postgres database a, b, and c. All are nullable but C has a default value.",0.0,c
148k8qy,jo1krmo,"If you do an insert statement that contains a, b, c and set all of them to null the database will set all fields to null because null is an acceptable value.",0.0,c
148k8qy,jo1krmo,"If you only insert a, and b then C will get the default value specified in the database and not null as above.",0.0,c
148k8qy,jo1krmo,">This is super cool, but assumes that ""name"" is available at runtime.",0.36111111111111116,cool
148k8qy,jo1krmo,As I said go introduced a reflections API for this use case because they omitted it from the language originally.,0.375,go
148k8qy,jo1krmo,"It works great in Erlang, PgPsql, crystal etc.",0.8,erlang
148k8qy,jo1krmo,"It works great in Erlang, PgPsql, crystal etc.",0.8,crystal
148k8qy,jo1krmo,The elixir style is the most elegant.,0.5,elixir
148k8qy,jo1arpb,"Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,c
148k8qy,jo1arpb,"Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,go
148k8qy,jo1arpb,"Plenty of people would dearly love C++ to die, and that's not really commentary on C.",0.2,c++
148k8qy,jo1arpb,"Plenty of people would dearly love C++ to die, and that's not really commentary on C.",0.2,c
148k8qy,jo339yr,"So we could imagine something like this:  ```c typedef struct { int; char; } mytuple;  mytuple foo = { 42, 'c' }; int x = foo.0; char y = foo.1; ```  We take the `.X` syntax from Rust and simply re-use other C syntax.",-0.0625,c
148k8qy,jo339yr,"So we could imagine something like this:  ```c typedef struct { int; char; } mytuple;  mytuple foo = { 42, 'c' }; int x = foo.0; char y = foo.1; ```  We take the `.X` syntax from Rust and simply re-use other C syntax.",-0.0625,rust
148k8qy,jo339yr,"You could during compilation generate the names and desugar it to:  ``` typedef struct { int field_0; char field_1; } mytuple;  mytuple foo = { .field_0 = 42, .field_1 = 'c' }; int x = foo.field_0; char y = foo.field_1; ```  ---  For atoms, they are simply user-defined symbols.",0.0,c
148k8qy,jo0oolk,"Compiling LLVM and LLD by hand will always work, but not everyone has the time to spend compiling those... :D",1.0,d
148k8qy,jo2w75f,So for example you can do dynamic calling in C3 by just doing a regular call on the `any` type (so like Go's `interface{}`):      Foo f;     Bar b;     any x = &f;     any y = &g;     x.test(); // Calls `test` on Foo     y.test(); // Calls `test` on Bar  But in order to make this happen and fit for C more ceremony in terms of *defining* `test()` is needed.,0.225,go
148k8qy,jo2w75f,So for example you can do dynamic calling in C3 by just doing a regular call on the `any` type (so like Go's `interface{}`):      Foo f;     Bar b;     any x = &f;     any y = &g;     x.test(); // Calls `test` on Foo     y.test(); // Calls `test` on Bar  But in order to make this happen and fit for C more ceremony in terms of *defining* `test()` is needed.,0.225,c
148k8qy,jo2w75f,"It works great in Erlang, PgPsql, crystal etc.",0.8,erlang
148k8qy,jo2w75f,"It works great in Erlang, PgPsql, crystal etc.",0.8,crystal
148k8qy,jo1v7l9,">Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,c
148k8qy,jo1v7l9,">Why is C a good step to go above ASM, other than it historically happened and it's what most people are familiar with?",0.24166666666666667,go
148k8qy,jo1v7l9,"(Now they target C, LLVM, WebAssembly, Javascript, JVM, and other such ubiquitous layers.)",-0.0625,c
148k8qy,jo1v7l9,"(Now they target C, LLVM, WebAssembly, Javascript, JVM, and other such ubiquitous layers.)",-0.0625,javascript
148k8qy,jo1v7l9,>that's not really commentary on C  Which is why discussing it here is off-topic.,-0.1,c
148k8qy,jo4dh8q,I suggest you go and cool down.,0.0972222222222222,go
148k8qy,jo4dh8q,I suggest you go and cool down.,0.0972222222222222,cool
148k8qy,jo2wcdm,"Don't forget p-code, which first showed up in the late 60s, then going mainstream with the Pascal compilers in the 70s.",-0.024999999999999994,pascal
148k8qy,jo1x0m1,Why C ?,0.0,c
148k8qy,jo1x0m1,"Forth was easily ported, for instance...",0.43333333333333335,forth
148k8qy,jo3853o,https://github.com/c3lang/c3c/issues/783 here you go.,0.0,go
148k8qy,jo2xzr0,"Languages with C backends, like Nim and Zig, are portable because C is, again, *ubiquitous*.",0.0,c
148k8qy,jo2xzr0,There are portable Forth systems ... they are portable because *they are written in C*.,0.0,forth
148k8qy,jo2xzr0,There are portable Forth systems ... they are portable because *they are written in C*.,0.0,c
148k8qy,jo2xzr0,"And Forth is an interpreted language ... there are no good reasons to write a Forth backend for a compiler and several good reasons to write a C backend, including efficient interop with the existing extensive C ecosphere.",0.0875,forth
148k8qy,jo2xzr0,"And Forth is an interpreted language ... there are no good reasons to write a Forth backend for a compiler and several good reasons to write a C backend, including efficient interop with the existing extensive C ecosphere.",0.0875,c
148k8qy,jo2xzr0,"As u/till-one already pointed out, whining about C and C++ is off topic.",0.0,c
148k8qy,jo2xzr0,"As u/till-one already pointed out, whining about C and C++ is off topic.",0.0,c++
148k8qy,jo2xzr0,And Forth is even more off topic.,0.5,forth
148k8qy,jo2xzr0,"I already answered your question of why C is a good backend target, and I'm not even sure you're not pulling my leg by bringing up Forth.",0.6,c
148k8qy,jo2xzr0,"I already answered your question of why C is a good backend target, and I'm not even sure you're not pulling my leg by bringing up Forth.",0.6,forth
148k8qy,jo31fo6,It's clear that C is just riding a historical headwind.,0.05000000000000001,c
148k8qy,jo31fo6,"I'm saying, why C as opposed to other languages that did exist at that level?",-0.125,c
148k8qy,jo31fo6,I suppose I'll go read about [third generation languages](https://en.wikipedia.org/wiki/Third-generation_programming_language).,0.0,go
148k8qy,jo31fo6,The history of C and its near competitors is hardly off-topic.,-0.09583333333333334,c
148k8qy,jo31fo6,"Forth did not, historically, achieve portability by being written in C.  It achieved it by being mostly written in *Forth*, with not that much machine-specific code necessary.",0.175,forth
148k8qy,jokla92,"As you say, C is omnipresent.",0.0,c
148k8qy,jokla92,And I actually like C quite a lot.,0.0,c
148k8qy,jokla92,"But C is already perfectly good at being C-like (being the most C-like language there is - the real thing, by definition.)",0.4666666666666666,c
148jook,,"If you want to add in-line assembly, there's an assembler module you can include.",0.0,assembly
148jook,,A good example is a Bash program that compiles a Bash string to an executable.,0.7,bash
148jook,jo0hfd6," cool ideas (esp 1 and 3) but for number three, how are you going to handle types that have unbounded quantity of possible values?",0.175,cool
148jook,jo0zeqp,smells like lisp.,0.0,lisp
148jook,jo0sry1,i am curious and think it is a cool idea,0.12499999999999999,cool
1486fxk,,I took a lot of inspiration from Typescript (since I work in that language pretty much daily).,0.125,typescript
1486fxk,,"Here  is my attempt at re-creating some of Typescript's common utility types:      // Makes object properties nullable          type Partial(T) {         var partial = {}              for (T.keys, i, k) {             partial[k] = union _ {T[k], None}         }              partial as Type     }          // Maps properties of one type to another          type Record(Keys, Type) {         var obj = {}         for (Keys, i, k) {             obj[string(k)] = Type         }         obj as Type     }          // Removes type(s) from union          type Exclude(T, U) {         ret T - U     }          // Extracts types from a union          type Extract(T, U) {         var ls = []         for(T, i, v) {             if (v in U) {                 ls.append(v)             }         }         ret ls as Union     }          // Extracts properties from a type based on specified keys          type Pick(T, Keys) {         var partial = {}              for (T.keys, i, k) {             if (k in (Keys as UnionL)) {                 partial[k] = T[k]             }         }              partial as Type     }          // Removes properties from a type based on specified keys          type Omit(T, Keys) {         var partial = {}              for (T.keys, i, k) {             if (!",-0.13749999999999998,typescript
147rwl1,jo7a2ma,"Tell us about the process, why you used java and how is that.",0.0,java
147rwl1,jocsebm,I chose Java because it is a awesome object oriented language and I wanted something different from C++.,0.5,java
147rwl1,jocsebm,I chose Java because it is a awesome object oriented language and I wanted something different from C++.,0.5,c++
147k92s,,"Hello everyone, i started this project one week ago, it's a query language with a syntax very similar to SQL written in Rust Programming language to perform CURD operations on .git files, for now, it only supports selecting but will implement more operations.",0.16666666666666666,rust
147k92s,jnxc7by,Looks cool!,0.4375,cool
147k92s,jnxc7by,Given that your project is also written in Rust you could just include the prql-compiler crate and have that generate SQL/GQL which you then process as before.,0.0,rust
147k92s,jnvwuay,Very cool!,0.56875,cool
147k92s,jnxlqid,That’s really cool actually and at the same time surprising that no one did it before!,0.30625,cool
147k92s,jnyywd0,Really cool project!,0.4375,cool
147k92s,jnyxnt7,"Very cool idea i will check it, thanks for suggesting it",0.3275,cool
147k92s,jnvxih4,"Currently, I am working on improving code structures then I will add the option to be used as a library because already i need to use it inside another project :D",0.5,d
147k92s,jnyzrx4,"As an objective benchmark (which I just thought of), the difference between Google search results for ""I hate Java"" and ""I hate SQL"" (as phrases in quotes) is two orders of magnitude in favor of SQL.",-0.5333333333333333,java
147k92s,jnyzrx4,"The difference between ""I love Java"" and ""I love SQL"" is one order of magnitude in favor of SQL.",0.5,java
147k92s,jnyyzp1,Cool i will check it,0.35,cool
147k92s,jnyxjax,"I am very interested in Compiler and Programming languages, so when trying to practice as much as I can for example I created a port for Turtle graphics [https://github.com/AmrDeveloper/Turtle](https://github.com/AmrDeveloper/Turtle), last two weeks I was reading a book called Building git, it is about building git from scratch and start learning rust then got the idea of merging the idea and create a language to run on .git files and on the started i think of implementing it as some language like Lua but i found that SQL like will be easier for this case",0.17500000000000002,rust
147k92s,jnyxjax,"I am very interested in Compiler and Programming languages, so when trying to practice as much as I can for example I created a port for Turtle graphics [https://github.com/AmrDeveloper/Turtle](https://github.com/AmrDeveloper/Turtle), last two weeks I was reading a book called Building git, it is about building git from scratch and start learning rust then got the idea of merging the idea and create a language to run on .git files and on the started i think of implementing it as some language like Lua but i found that SQL like will be easier for this case",0.17500000000000002,lua
147k92s,jnvy6no,"Great to hear :) I have use for something like this in a python project, do you think it would be possible to wrap the rust library in C to facilitate import to python?",0.43333333333333335,python
147k92s,jnvy6no,"Great to hear :) I have use for something like this in a python project, do you think it would be possible to wrap the rust library in C to facilitate import to python?",0.43333333333333335,rust
147k92s,jnvy6no,"Great to hear :) I have use for something like this in a python project, do you think it would be possible to wrap the rust library in C to facilitate import to python?",0.43333333333333335,c
147k92s,jnyz0ma,"Very cool, i will do if i found any issue with integration",0.45499999999999996,cool
147k92s,jnvzjx8,"It's not very in depth, but there's a short section in the  [embedded rust book](https://docs.rust-embedded.org/book/interoperability/rust-with-c.html) about this.",-0.05,rust
147k92s,jnvzmoj,"I don't know if it possible, this is my first Rust project :D, we can search about it",0.4166666666666667,rust
147k92s,jnvzmoj,"I don't know if it possible, this is my first Rust project :D, we can search about it",0.4166666666666667,d
147k92s,jnw509e,"There is PyO3 project, created specifically to facilitate developing python modules in Rust.",0.0,python
147k92s,jnw509e,"There is PyO3 project, created specifically to facilitate developing python modules in Rust.",0.0,rust
147k92s,jnw1az5,Cool thank you,0.35,cool
14783jp,,For the problem I'm trying to solve the union and intersection types correspond roughly to TypeScript's.,-0.1,typescript
14783jp,jnvitvb,"""Semantic subtyping"" is an older technique than algebraic subtyping, it was designed to deal with XML back in the days where XML was cool, and it works very well with unions and intersections, and other ""set-theoretic"" features of type systems.",0.11833333333333332,cool
14783jp,jnvitvb,"It is being used to try to add static types to Elixir for example, see [this blog post](https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/).",0.5,elixir
14783jp,jo2iqop,"Very cool stuff, thanks for sharing!",0.3525,cool
14783jp,jo2k866,Hot news: [Elixir's “Set Theoretical Type System” prototype/demo/showcase](https://news.ycombinator.com/item?id=36299214).,-0.16666666666666666,elixir
147657x,jnusw0r,I'm using C for my language so I can't use any fancy OOP.,0.0,c
147657x,jnvufrv,"Then in the IDE (in my case a vscode extension written in typescript), I have a type solver that does all the type checking.",0.0,typescript
147657x,jnvufrv,"Afaiu, this is also how typescript basically works (types ignored at runtime, static types all checked only at development type by a tool separate from the interpreter - ofc typescript is a bit different because it gets transpiled, but i feel the general idea applies here).",0.1375,typescript
147657x,jnvufrv,"Given how messy type solvers can get with generics and type inference, it also helps that I don't have to be writing that logic in C (my interpreter is in C89)  I'm kind of curious what other people's approaches are as well  If I had all the time and money in the world though, I would be building an interpreter that can make optimizations based on static types.",0.13499999999999998,c
147657x,jnzqi1v,"I have runtime types, so instructions like 'add', 'sub' perform action on runtime types.I want move out types from VM, but the main problem is order-independent declaration.I don't want to implement forward declaration like in C or C++.",0.13333333333333333,c
147657x,jnzqi1v,"I have runtime types, so instructions like 'add', 'sub' perform action on runtime types.I want move out types from VM, but the main problem is order-independent declaration.I don't want to implement forward declaration like in C or C++.",0.13333333333333333,c++
1475h9o,jntz751,They might generate source code for another language (eg C); or generate some intermediate language like LLVM; or generate assembly *source code* like ASM.,0.0,c
1475h9o,jntz751,They might generate source code for another language (eg C); or generate some intermediate language like LLVM; or generate assembly *source code* like ASM.,0.0,assembly
1475h9o,jntyywr,Figure out its grammar (see the back of the classic ANSI C book for C's grammar) and the semantics for that grammar.,0.08333333333333333,c
1475h9o,jntyywr,"* Then you'll need to glue your ASTs to LLVM, which takes care of turning them into intermediate representation, optimizing them, and converting them into assembly language.",0.0,assembly
1475h9o,jnv5phw,"If you want to do it manually, you need to go through the technical documentation of PE/2 / elf / whatever your system's executables files are and the instructions your processor uses.",0.0,go
1475h9o,jntvw7d,"Will you make it like an existing language, like Basic, C, or Lisp?",0.0,c
1475h9o,jntvw7d,"Will you make it like an existing language, like Basic, C, or Lisp?",0.0,lisp
1475h9o,jntvw7d,Making a Basic interpreter in Python: https://youtube.com/playlist?list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD  Making a Lisp interpreter: https://youtube.com/playlist?list=PLWUx_XkUoGTrXOU0pFa_OVGA-6voiIEAt,0.0,python
1475h9o,jntvw7d,Making a Basic interpreter in Python: https://youtube.com/playlist?list=PLZQftyCk7_SdoVexSmwy_tBgs7P0b97yD  Making a Lisp interpreter: https://youtube.com/playlist?list=PLWUx_XkUoGTrXOU0pFa_OVGA-6voiIEAt,0.0,lisp
1475h9o,jnvhwu9,"* Compile your language to another one, preferably to C, and compile the generated C source for the final product.",0.0,c
1475h9o,jnvhwu9,"Writing a transpiler can be pretty easy, especially, if your language is similar to C (even Python is a C-like language, with a slightly different syntax).",0.13666666666666666,c
1475h9o,jnvhwu9,"Writing a transpiler can be pretty easy, especially, if your language is similar to C (even Python is a C-like language, with a slightly different syntax).",0.13666666666666666,python
1475h9o,jnzq8we,Another common recommendation:  * Thorsten Ball's [Writing A Compiler In Go](https://compilerbook.com/),-0.3,go
14759gv,,Many of the comments you write on here go a bit over my head.,0.5,go
14759gv,,"Some of the features I'm proud to have included include being able to extract fields from collections by doing the following:      myCollection.name  Assignments return values, so you can do things like the following:      func fibonacci(size) {        fib = [a = 0, b = 1];        for (i++;0;<size) {            fib += [c = a + b];            a = b;            b = c;        }        return fib;     }     return fibonacci(10);  One of the more recent additions is import of both raw source and ""compiled"":      import 'CompiledSource', @'UncompiledSource.slp'          /* Compiled function */     compiledMethod();     /* Uncompiled function */     uncompiledMethod();  This model I find does have some benefits:  * Very fast to add new language features (elvis operator literally took 2 minutes to add) * Everything is configurable even down to operators and their order * Very decoupled code - you probably shudder reading this with regards to language development though!",0.18727625909444087,c
14759gv,,Parser errors only go so far.,0.05,go
14759gv,,"As I wrote in the release notes, it doesn't currently support things like indentation or new lines impacting on code capture or grouping (python for example).",0.06818181818181818,python
14759gv,,It sits on top of another language (Java) and is interpreted.,0.5,java
14759gv,jnw5dey,Some people (or bots) go around down voting every new submission on reddit,-0.009595959595959616,go
146xui4,,"So I was learning a bit of Haskell recently, and thought wouldn't it be nice if we could write foldl and foldl' as one polymorphic function?",0.3,haskell
146qyyc,,"Hello, I'm writing a C compiler for fun, and I would like my compiler to go from source code to SSA IR in one pass.",0.3,c
146qyyc,,"Hello, I'm writing a C compiler for fun, and I would like my compiler to go from source code to SSA IR in one pass.",0.3,go
146qyyc,jnrtqtn,"In C, preprocessing is done first as a strictly textual replacement and then the lexer is run in the next step.",0.125,c
146qyyc,jnsdpgv,"A ""traditional"" C compiler operates on streams.",0.0,c
146qyyc,jnrvaxt,I've done a C preprocessor in a single pass.,-0.07142857142857142,c
146qyyc,jnrvaxt,"This way, you will be able to offload the work to a separate C compiler to get started (use it with `-E` to get preprocessed input for your compiler), and get back to your own CPP later.",0.275,c
146qyyc,jnrvaxt,You say you're doing this for fun; I can tell you from experience that writing a C preprocessor is not fun!,0.056249999999999994,c
146qyyc,jnrw9nd,Others like sectioning/print-formatting pragmas might need to be interpreted even when `#if`’d out.,0.0,d
146qyyc,jnrw9nd,"-------  \* IntelC, unusually, “supports” `#pragma GCC warning` but only because it ~ignores the namespace; so `#pragma intel warning` or just `#pragma warning` are really what it does, and that follows the MSVC `#pragma warning` scheme (give or take syntax checks) and configures diagnostics.",0.13333333333333333,scheme
146qyyc,jnsnqi4,"Macros in C never operate on ""old ones""; they only operate on subsequently processed text.",0.03333333333333333,c
146qyyc,jnsnqi4,"I'm not aware of any examples in C in which a single pass that includes macro expansion would not work, but if you are, then please share the problems that you're aware of, using examples.",0.01785714285714286,c
146qyyc,jnterwr,"C translation is specified to be an ... 8-phase process, at least in whatever old draft of C23 I have laying around.",-0.09999999999999999,c
146qyyc,jnterwr,"Or in other words: if you can operate entirely on *streams* of data (like a shell pipeline), it doesn't matter how many phases you have, it's still a 1-pass compilation process.",0.125,shell
146qyyc,jnv7awo,"very good question, unfortunately im almost sure you can't really, basically because preprocessing is not even a real pass for compiling c code, it is just an optional step you can add before all the other ones.",0.19749999999999998,c
146qyyc,jnv7awo,"EDIT: by the way i was starting to write a c compiler too, and then modify it implementing generics and non in order declarations, i can't do it in one pass but i at least want to onepass the ast.",-0.15,c
146qyyc,jo0p5rf,"In the example you gave in this comment (which I know you said was invalid C but it needs to be lexed to figure that out in the first place, right?",0.26785714285714285,c
146qyyc,jnsrlhp,"Yup, preprocessor isn't valid C, instead it is a second language meant to define ways to rewrite and modify text files.",0.0,c
146qyyc,jnsa5w5,"Yeah, I imagine you could still just do any replacements between reading the text and outputting the AST, either before or after the lexer tokenises depending on whether you want to preprocess the raw text (as the C preprocessor does) or tokens (no idea if it would be useful to process tokens prior to generating the AST nodes vs processing the AST nodes like in a macro system)",0.023076923076923068,c
146qyyc,jnsdc0d,"The C pre-processor transforms an intermediate tokenized stream of so called ""pre-processor"" tokens into a different stream of the same.",0.0,c
146qyyc,jnsrbn1,I thought code like this could be a problem  &#x200B;  \#define PLUS +   int main() {     int i = 0;     return i+PLUS;        }  &#x200B;  But apparently that's not valid C code.,0.10833333333333334,c
146qyyc,jnsp0iz,"A pre processor can work like a transpiler (like typescript) and output the full file, then the compiler reprocess the new file from lexer.",0.24318181818181817,typescript
146qyyc,jnsp0iz,Tho you can still go though 1 with flags if you really wish to do that in your build process.,0.2,go
146qyyc,jnt7nbc,"I don't think the second scenario is possible, the preprocessor wouldn't produce binary (in C or C++ at least, I don't know of any other langs that use preprocessing) it's just text replacement",-0.10625,c
146qyyc,jnt7nbc,"I don't think the second scenario is possible, the preprocessor wouldn't produce binary (in C or C++ at least, I don't know of any other langs that use preprocessing) it's just text replacement",-0.10625,c++
146noct,,"Oh, and it's a hacked Haskell, so the sequencing primitive turns into do-notation, and the *don't-memoize* operator turns into the IO monad.",0.0,haskell
146noct,,"Arguably, do-notation is just the ALGOL semicolon in disguise.",0.0,algol
146noct,,"The only resolution to this paradox -- at least in the Haskell worldview -- seems to be that `IO` is highly magical, so that functions in that monad must be recalculated rather than memoized.",0.06666666666666667,haskell
146noct,jnrlgmc,Also note that the final IO monad in that post is not equivalent to the one in Haskell and will probably not hold up under aggressive GHC-style optimizations and inlining (more on this later).,0.16666666666666666,haskell
146noct,jnrlgmc,>do-notation is just the ALGOL semicolon in disguise  It's not.,0.0,algol
146noct,jnrlgmc,"`seq` is the ALGOL semicolon in diguise (well, up to weak head normal form anyway).",-0.1125,algol
146noct,jnrlgmc,"`(>>=)` on its own does not perform any sequencing (that is what `seq`, a primitive that cannot be implemented in Haskell directly, is for).",0.4000000000000001,haskell
146noct,jnrlgmc,"Haskell's semantics never ""rewrite under a lambda"" (unlike, e.g.",0.0,haskell
146noct,jnrlgmc,But optimizations do exist and that is why Haskell's `IO` is defined more intelligently than `() -> a`.,0.65,haskell
146noct,jnrlgmc,"The full definition looks like this (which would still be fine if Haskell could rewrite under lambdas)      newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)  Note that `RealWorld` is a phantom argument that is only necessary to distinguish between effectful `IO` and pure `ST`, `State#` is a zero-sized type, and `(# , #)` is an unboxed tuple.",0.1961904761904762,haskell
146noct,jnrlgmc,This is used to implement Haskell's infamous lazy IO.,-0.375,haskell
146noct,jnwkmfd,Haskell even has an extension for this (`-XStrictData`) that makes constructor fields strict by default.,0.0,haskell
146noct,jnwb1q8,"What about Haskell’s approach, where it’s lazy by default but you simply put a `!` before a data type field that you want to be strict (and also you can use `seq` for strictness in expressions)?",-0.125,haskell
146noct,jnz4nco,"This is Haskell's ""lol no generics"" and GHC fixed it recently with [unlifted datatypes](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/primitives.html#unlifted-datatypes) in a very late response to the [famous blog post by Bob Harper](https://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/).",0.202,haskell
146noct,jpfvz9a,Did you not go over this in your discrete math classs lol?,0.8,go
146noct,jo1q05p,"I had to read the comment a couple times, but I think it is an analogy to how people talk about the lack of generics in Go?",0.0,go
146noct,jo367sv,"In analogy to Go's ""lol no generics"" (which has been a joke for years and finally fixed), there is the ""lol no values"" joke about Haskell (which has been finally fixed).",0.45000000000000007,go
146noct,jo367sv,"In analogy to Go's ""lol no generics"" (which has been a joke for years and finally fixed), there is the ""lol no values"" joke about Haskell (which has been finally fixed).",0.45000000000000007,haskell
146noct,jo2z5bs,So it’s not that Haskell would supposedly not have generics.,0.0,haskell
146noct,jo2z5bs,It’s like the situation with Go.,0.0,go
146au5t,jnpeau5,"a = b.c           ^  This one was pretty, weird, I didn't understand why the parser wasn't using the right rule and instead it retuned internally a record update of the form        a = {b:c}  At the end, I use the wrong transformation for the rule, putting RecordUpdate instead of RecordSelector.",-0.09285714285714286,c
146au5t,jnpeau5,"Also I corrected the lexer, so now I lex the full      A.B.C.d.e.f.g  And then splitting it as imports     A.B.C  Accessing import variable      c  Accessing record fields     e.f.g  Before I had it at the parser allowing for        (A.B .",0.35,c
146au5t,jnpeau5,C .,0.0,c
146au5t,jnpeau5,c)    .,0.0,c
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,go
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,php
146au5t,jnpk19t,"No, wait, that was g++ (and clang outputs the same)  Honerable mentions go to [PHP's hebrew error](https://stackoverflow.com/questions/592322/php-expects-t-paamayim-nekudotayim) and [Haskell's](https://www.thecodedmessage.com/posts/haskell-gripe/) [confusing](https://www.thecodedmessage.com/posts/haskell-error-message-2/) [error](https://gitlab.haskell.org/ghc/ghc/-/issues/19361) [messages](https://anthony.noided.media/blog/haskell/programming/2020/05/14/haskell-errors.html), I'm sure there are more examples.",0.3333333333333333,haskell
146au5t,jnvqb7t,I'm implementing a subset of C++ with WebAssembly and custom VM targets.,0.0,c++
146au5t,jnqn43p,"I was going to say while I don't have my own compiler, I've seen some pretty outrageous error messages when template metaprogramming in c++.",-0.05000000000000001,c++
1464vgx,jnoq7k3,Edit: To expand...  `compile_to_file` and `compile_to_memory` both start by compiling your program to an assembly text file (\*.s) in a temporary directory.,0.0,assembly
1464vgx,jnoq7k3,"`compile_to_file` compiles it to the requested format, or if the format is assembly it just copies it.",0.0,assembly
1464vgx,jnvqz2m,"Hmm, cool, creative hack!",0.4875,cool
1464vgx,jnvqz2m,"However, I've seen that one of the C++ classes used internally by JIT has a tempdir member and I'm sure `FILE*`s are stored somewhere too, so I think the way I really want to be approaching it is to acquire them.",0.175,c++
1461k0z,,"Thought I'd share it:      let rec bind arg (patt, ty) rest fail =       match patt with       | Ty.PAny ->         let ty = compile_type ty in         eLet((PVar(tmp()), ty), arg, rest)       | Ty.PLit(Ast.Int n) -> eIf(arg =: int n, rest, fail)       | Ty.PLit(Ast.Float x) -> eIf(arg =: float x, rest, fail)       | Ty.PLit(Ast.Char c) -> eIf(arg =: int(Char.code c.[0] |> Int64.of_int), rest, fail)       | Ty.PLit(Ast.String s) ->         let strcmp = eVar ""strcmp"", TArrow(TTuple[TInt; TInt], TInt) in         let args = ETuple[arg; string s], TTuple[TInt; TInt] in         eIf(eApply(strcmp, args) =: int 0L, rest, fail)       | Ty.PVar var ->         Hashtbl.replace type_of_var var ty;         let ty = compile_type ty in         eLet((PVar var, ty), arg, rest)       | Ty.PTuple patts ->         let tmps = List.map (fun patt -> (tmp(), type_of patt |> compile_type), patt) patts in         let patts = List.map (fun ((var, ty), _) -> PVar var, ty) tmps in         let varpatts = List.map (fun ((var, ty), patt) -> (eVar var, ty), patt) tmps in         eLet(pTuple patts, arg, binds varpatts rest fail)       | Ty.PUnion(constr, patt) ->           let patt, ty =             match patt with             | None -> (Tc.PTuple[], Tc.TTuple[]), Tc.TArrow(Tc.TTuple[], ty)             | Some patt -> patt, ty in           let tag = tmp() in           let ptr = tmp() in           let payload = tmp() in           let tyPayload = compile_type(type_of patt) in           eLet((PTuple[PVar tag, TInt; PVar ptr, TInt], TTuple[TInt; TInt]), arg,               eIf((EVar(tag, IntMap.empty), TInt) =: int(Hashtbl.find tag_of_constr constr),                   eLet((PVar payload, tyPayload),                         (ELoad(EVar(ptr, IntMap.empty), TInt), tyPayload),                         bind (EVar(payload, IntMap.empty), tyPayload) patt rest fail),                   fail))       | Ty.PAs(patt, var) ->         let rest = bind arg patt rest fail in         eLet((PVar var, type_of patt |> compile_type), arg, rest)       | Ty.POr(patt1, patt2) -> bind arg patt1 rest (bind arg patt2 rest fail)     and binds argpatts rest fail =       match argpatts with       | [] -> rest       | (arg, patt)::argpatts -> bind arg patt (binds argpatts rest fail) fail in      let rec pmatch arg = function       | [] -> invalid_arg ""pmatch []""       | [patt, expr] -> bind arg patt (compile_expr expr) match_failure       | (patt, expr)::rules -> bind arg patt (compile_expr expr) (pmatch arg rules)",-0.35,c
1461k0z,jobwo32,To add more language constructs just append to the sum types involved and go to where the compiler tells you the pattern matches are inexhaustive and add more code until the compiler is happy.,0.6,go
1460agz,,And an assembler which takes the assembly and turns it into machine code for the CPU.,0.0,assembly
1460agz,jnogpfg,This is really cool!,0.4375,cool
1460agz,jno3eyj,Cool as hell project.,0.35,cool
1460agz,jno3eyj,And with the compiler written in Haskell no less!,0.10416666666666666,haskell
1460agz,jnolpqn,"I wanted to do this, only with an OS as the 'cherry on top' (OS built with custom compiler, targeting custom assembly targeting custom CPU etc...).",0.25,assembly
1460agz,jnolpqn,Really cool to see this project.,0.35,cool
1460agz,jnolpqn,How was writing the compiler in Haskell though?,0.0,haskell
1460agz,jnossrp,Writing an OS would be cool!,0.4375,cool
1460agz,jnosvcd,"The parser was auto-generated, but the actual conversion of code to assembly was hand-written.",0.0,assembly
1460agz,jnz3qm9,"Well, if you like Haskell you could look into the [CPU example in Clash](https://yager.io/CPU/CPU1.html)",0.0,haskell
1460agz,jnouyjx,"I am in the UK, but not the North so that was someone else :D",1.0,d
1460agz,jnov46w,"Ah cool, haha he helped me with a problem I had implementing context switches.",0.275,cool
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,c
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,typescript
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,rust
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,go
145llww,,"For example, the following C# code does not compile, the type parameter is required at initialization and cannot be inferred later:      using System;     using System.Collections.Generic;          public class HelloWorld     {         public static void Main(string[] args)         {             var list = new List {};             list.Add(""test"");         }     }  The equivalent TypeScript code [sometimes compiles](https://www.typescriptlang.org/play?#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) and [sometimes doesn't compile](https://www.typescriptlang.org/play?noImplicitAny=false#code/MYewdgzgLgBANgS2jAvDA2gXQFCOgOgAcBXCACwAoAiKAU2ioEpsg) based on configuration of the type checker:      let list = []     list.push(""test"")  The [equivalent Rust code compiles](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a9c24e242387c2e01f4fdf18ed7db8da):      fn main() {         let mut list = Vec::new();         list.push(""test"");     }  I checked a couple of other languages that I'm less familiar with, for example Go and C++ but I'm not sure I was creating an equivalent example so I didn't share it here.",0.05785123966942149,c++
145llww,jnncqhz,C# uses (as far as I'm aware anyway) a relatively standard bidirectional inference algorithm.,0.11666666666666665,c
145llww,jnncqhz,"But at this point, there is no way for C# to know which type would be appropriate!",0.625,c
145llww,jnncqhz,"`IEnumerable<out T>`, C# doesn't do this, even though it could).",0.0,c
145llww,jnncqhz,"Similarly, TypeScript infers `never []`, which is sound, because it means that the array is effectively immutable (there is no way to construct values of type never), so *all* elements of the list vacuously have any type you want (there are none).",0.3333333333333333,typescript
145llww,jnncqhz,"Rust on the other hand is (roughly) Hindley-Milner based, so it doesn't have to work out every type immediately.",-0.1125,rust
145llww,jnncqhz,"In Rust, `Vec::new()` will return `Vec<_a>`, where `_a` is a *unification variable*.",0.0,rust
145llww,jnncqhz,"In other words, instead of committing to a type immediately, Rust infers a placeholder for it.",-0.125,rust
145llww,jnncqhz,"Later, instead of checking for type equality directly, Rust will perform unification and work out the values of these unification variables.",0.05,rust
145llww,jnncqhz,"Rust's syntax for function types is not great, so I am going to use something a bit more Haskelly here.",0.04999999999999999,rust
145llww,jnncqhz,"Now, Rust knows that `_a = &str` and so it knows that the *real* type of `list` should be `Vec<&str>`.",0.2,rust
145llww,jnncqhz,Note that it doesn't need to go back to the definition of list!,0.0,go
145llww,jnncqhz,"In Rust's type system (without unions), what you described is exactly what is going to happen.",0.25,rust
145llww,jnncqhz,"It is a bit long, but very detailed and it features a full implementation in Haskell",0.2733333333333334,haskell
145llww,jnlvhya,The type might be required to compile a component (eg a function) ahead of the full scope of use (this is true for c++ generics at least).,0.13333333333333333,c++
145llww,jnol753,TypeScript is actually an... [interesting example](https://www.typescriptlang.org/play?#code/PQKhCgAIUgVBPADgU0gSwHYDNkCdkYDGqA7mgC4AWkARgK5oA25mkAFAIK64CG8AlFBhDIASWx4AzpAAGPDPADaAXRm065SJOTIAttPIB7Wqh5aUhND0aRCh3YiZ5bPbZCOQ6GNFnjpNjDzkeELA4OCMyAFokpoAvJAq4MDAkJAAegD8ETHkAHSIdJKUbABEwbGlgikZ2Yy5yalZ4QAmyISB+JAAbjy4WvbIAMKGGC0UaKMAXLSGhpHy4ZHRsQBMkAlJNWnN4D7skoMjYxOj-JAA3lBpkPVrBUUl5ciV1am14AC+kMiMblc3W65VYPYpsACMqwAzG8dtlPktgY0PskwCIECh0BJ8ERSBRqEU8ABaNpYTDIFqQFpBMzkJDIEToyioSQ8XSoADWmEphiwnm8ZMIQUmGCphheGAA5JpDIRCHRcAAaOD0gDKhFwaEQ5BEACsippMDhcAZme5DIh3PS8qFwnTMbB8MgADywAB8G2uaQAPpdIFyxjNJQssJLIAjAb6Lv7uUGMIY2pLldTyDwZrBlYRKEwWjj007XW6VOHwlgvIQWKNILoeBzkAAZZA8LCFtj8fM6QuXL2QfDkBWi6MBlozUoh0olhHgMtESuimt1gByCZd7rYKbTcEz2cYuYIHdXReUG0SynbcAL7u7gL7A79w7jK6TVJp25zOMnSyitybfISC4bX822RD5ll7OZ4mrWtkGXNoIWhZVFBDM8QKyIA) because it depends on compiler settings.,0.25,typescript
145llww,jnol753,The TypeScript [checker.ts code](https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts) is a single 50k LOC file so I'm probably not going to be able to understand the implementation.,0.2142857142857143,typescript
145llww,joy4x67,C# doesn't add covariance to `List` because it is backed by a mutable array.,0.0,c
145llww,joy4x67,The mistake was made with arrays and inherited from Java:      Tiger[] tigers = new Tiger[] { new().... };     Animal[] animals = tigers;     animals.Add(new Giraffe());  Crashes because `Giraffe` may use more memory than the `Tiger` array slot provides or someone might inspect the `Tiger` array after the giraffe was added.,0.25757575757575757,java
145llww,jnlzppe,RE: #3 - One example is [TypeScript unifies](https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEA3W8DOB7AtiAwugdsAJYAuRBAXPAEbroQhT4BQzDJ8ERqHAvPAG0AuqyIAzeAAoM2PIVLl8ASngBvZvE2duJAHQAHAK6oAFpIBEJED3NLmAX3ggIqBOq3aeB42YCMAJgBmO3tWLh5mAHpI+AA9AH5WaPgAQQAfACF4bngoNENqEgBPfQR0CXSMtJxmYtL4ABVrPikeGCJ8AHN4NPh8Q0xqEBgVEAAPK0JUVpJ2rp6+gaGYBdp6RmV4ePhZwwQqMSgXECiYrQTmIA) that situation as `List<A|B>`.,0.0,typescript
145llww,jnortte,"My compiler is also written in Rust and has basically the same idea of a ""database"" (a struct of arenas) that gets updated as we churn through the HIR.",0.0,rust
145llww,jno18ya,"For `Any`, are you referring to the [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any) kind of any which turns off the type checker completely, or are you referring to the [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) kind of any that is the top type?",0.44999999999999996,typescript
145llww,jno18ya,"For `Any`, are you referring to the [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any) kind of any which turns off the type checker completely, or are you referring to the [Kotlin](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) kind of any that is the top type?",0.44999999999999996,kotlin
145llww,jnoh7f5,Go).,0.0,go
145llww,jno2edb,"I refer to `Any` in the TypeScript sense, which seems common among numerous tools.",-0.15,typescript
145llww,jno2edb,Kotlin's choice of terminology there is confusing - is it what is often called `BaseObject` (since often there are primitive types that don't extend `Object`)?,-0.3,kotlin
145llww,jnoj6on,Go).,0.0,go
145llww,jnoj6on,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,pascal
145llww,jnoj6on,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,algol
145llww,jno5umm,"If I understand correctly, from a type system perspective Kotlin has no primitive types, so `Any` is the top type, the superclass of every class.",0.5,kotlin
145llww,jno5umm,"So yeah, in other languages that might be called `Object`, and like Java `Object` it has methods `equals`, `hashCode`, `toString`.",-0.125,java
145llww,jno5umm,Unlike Java `Object` it really is the top type because there are no primitives.,0.35,java
145llww,jno5umm,"I believe Kotlin compiles the `Int` ""class"" into JVM primitive integers when possible, but that's an implementation detail of the JVM code generation not the type system (Kotlin has other compilation targets like JS or experimental WASM compilation).",-0.008333333333333331,kotlin
145llww,jnollaj,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,pascal
145llww,jnollaj,"Pascal, ML, OCaml, ALGOL, ...), which is exactly what it means in this case.",0.25,algol
145kps7,jnlvtnf,[Here's an implementation in Common Lisp](https://github.com/stylewarning/computable-reals).,-0.3,lisp
145hkld,,On Elm's homepage there's a reference to a John Carmack tweet praising the Elm compiler: [https://twitter.com/ID\_AA\_Carmack/status/735197548034412546?s=20](https://twitter.com/ID_AA_Carmack/status/735197548034412546?s=20)   I've been using Better Exceptions with the python interpreter and I hate developing without it.,-0.35000000000000003,elm
145hkld,,On Elm's homepage there's a reference to a John Carmack tweet praising the Elm compiler: [https://twitter.com/ID\_AA\_Carmack/status/735197548034412546?s=20](https://twitter.com/ID_AA_Carmack/status/735197548034412546?s=20)   I've been using Better Exceptions with the python interpreter and I hate developing without it.,-0.35000000000000003,python
145hkld,jnmszq0,Try Steel Bank Common Lisp.,-0.3,lisp
145hkld,jnlg34z,"The Rust language compiler is known for generally having good error messages, and being much more clear in what the issue is compared to other languages.",0.24500000000000002,rust
145hkld,jnmzh04,"C++ aside, what languages do you think have compilers with incomprehensible error messages?",0.0,c++
145hkld,jnqafzn,"Elm's error messages are famously detailed, but I sure did hit a lot of them while banging my head against its standard JSON library.",0.3,elm
145hkld,jnqafzn,"In contrast, Python's a bit more terse, and I agree that static types are nice, but json.loads(...) is practically a godsend in comparison.",0.5333333333333333,python
145hkld,jnnk0x7,"Gotchaaa, the short loop of development sounds like what I’ve heard from Clojure devs.",0.0,clojure
145hkld,jnlgox8,A great compiler might be the push that gets me to finally try Rust.,0.4,rust
145hkld,jnnkgme,Maybe I just need to get better at programming :) Idk if I’ll get around to creating a toy language but I do want to write a simple “compiler” for python so I can use some syntax that is not natively supported.,0.3333333333333333,python
145hkld,jnn37gu,"Not exactly compiled, but Groovy.",-0.125,groovy
145hkld,jnnj5l6,I wouldn’t say they’re incomprehensible but for my day job I’ve been training computer vision models in python and it can take me a while to parse the error message and understand where my problem actually is.,0.0,python
145hkld,jnnj5l6,I mentioned better_exceptions for python in the OP and one thing great about it is that it displays the values of function arguments in the stack trace.,0.8,python
145hkld,jnnj9l9,That’d be great :) maybe we’ll there EDIT: maybe we'll SEE,0.65,d
145hkld,jnnp8tc,"Sure, Clojure was created by a guy who was proficient in Common Lisp and tailored it specifically to his needs.",0.1,clojure
145hkld,jnnp8tc,"Sure, Clojure was created by a guy who was proficient in Common Lisp and tailored it specifically to his needs.",0.1,lisp
145hkld,jnnp8tc,"It's more opinionated a language as well and it's easier to write ""line-of-business"" applications in it which can leverage existing Java ecosystem (which is important for many enterprises).",0.4666666666666666,java
145hkld,jnnp8tc,He also decided not to incorporate many Common Lisp features (some because they don't really play well with Java and some because he decided they were detrimental to the style of programming he promotes) and added some extra (which are either external libraries in CL or don't exist at all).,0.08,lisp
145hkld,jnnp8tc,He also decided not to incorporate many Common Lisp features (some because they don't really play well with Java and some because he decided they were detrimental to the style of programming he promotes) and added some extra (which are either external libraries in CL or don't exist at all).,0.08,java
145hkld,jnnp8tc,Problem with Clojure is that you often see Java stack traces and Java exceptions.,0.0,clojure
145hkld,jnnp8tc,Problem with Clojure is that you often see Java stack traces and Java exceptions.,0.0,java
145hkld,jnnp8tc,"Not a problem for me, I have written more Java than any other language (yes, I was paid to do so, that was the reason :-D ).",0.4583333333333333,java
145hkld,jnnp8tc,"If you really decide to dig into Common Lisp (it's not everybody's cup of tea), check this linter as well: [https://github.com/g000001/lisp-critic](https://github.com/g000001/lisp-critic) , or this wrapper over Lisp Critic which can work very well in your CI/CD pipelines if you use them: [https://github.com/40ants/40ants-critic](https://github.com/40ants/40ants-critic) .",-0.27999999999999997,lisp
145hkld,jnls7z8,"Wouldn’t say Rust is exclusively for “low-level programming”, depending on which definition you are using.",0.0,rust
145hkld,jnls7z8,Rust has a lot of modern language features,0.2,rust
145hkld,jnm5k5i,It's worth noting that the Rust compiler team [draws a lot of inspiration from Elm](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html)   > Those of you familiar with the Elm style may recognize that the updated --explain messages draw heavy inspiration from the Elm approach.,0.15833333333333335,rust
145hkld,jnm5k5i,It's worth noting that the Rust compiler team [draws a lot of inspiration from Elm](https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html)   > Those of you familiar with the Elm style may recognize that the updated --explain messages draw heavy inspiration from the Elm approach.,0.15833333333333335,elm
145hkld,jnnrt4r,Sounds cool!,0.4375,cool
145hkld,jnumeat,"Elm evidently treats `type` definitions as like a nominal reference-type, but `type alias`es as structural composite things without any implied referencing.",0.25,elm
145hkld,jnumeat,"If you find one, you go and trigger this error.",0.0,go
145hkld,jnnx60b,"Mmmmm okay, I found: ""He also decided not to incorporate many Common Lisp features \[...\] some because he decided they were detrimental to the style of programming he promotes"" especially interesting because programming style is so personal.",0.33999999999999997,lisp
145hkld,jnnx60b,"Maybe his style and my own are similar, or maybe not /shrug  I'll keep that in mind about the stack traces - hopefully I'll finally use clojure more and get to see some :)  Lisp-critic seems like a great aid in writing idiosyncratic common lisp, and I find learning to write idiosyncratic code in new languages can be challenging, so good to know, thank you!",0.3611363636363637,clojure
145hkld,jnnx60b,"Maybe his style and my own are similar, or maybe not /shrug  I'll keep that in mind about the stack traces - hopefully I'll finally use clojure more and get to see some :)  Lisp-critic seems like a great aid in writing idiosyncratic common lisp, and I find learning to write idiosyncratic code in new languages can be challenging, so good to know, thank you!",0.3611363636363637,lisp
145hkld,jnllsu2,"(Right now, I think this about Ruby and TailwindCSS).",0.2857142857142857,ruby
145hkld,jnmaxjp,"Wowww, very cool.",0.45499999999999996,cool
145hkld,jnnt67i,"I want to support Julia-esque map usage in python, what I consider to be a more ergonomic version of map.",0.5,python
145hkld,jnqdfj2,"Ironically, Clojure has pretty bad error messages.",-0.22499999999999992,clojure
145hkld,jnlw3tg,I just thought you should give Rust a try even if you’re not writing performance and memory safety sensitive programs.,0.1,rust
145dugl,jnkv2io,There is an interesting stack overflow discussion on pickling generators in python https://stackoverflow.com/questions/7180212/why-cant-generators-be-pickled   .,0.5,python
145dugl,jnkv2io,Apparently stackless python supports it but cpython does not.,0.05,python
145dugl,jnkv2io,There is also a lua library called pluto which supports this.,0.0,lua
145dugl,jnl2pjl,"Some ecosystems like Cloud Haskell did it for static closures (known ahead of time, like functions within the same code base which get explicitly marked as such), which is easier but it won't work for arbitrary database servers.",-0.05000000000000001,haskell
145dugl,jnn7zhy,See [javactrl](https://github.com/javactrl/javactrl) for a Java implementation of continuations that is serializable,0.0,java
145dugl,jnnhfy4,Adam Dunkels' [Protothreads](http://dunkels.com/adam/pt/) library is an implementation of stackless coroutines based on C macros that resolve to state machines.,0.0,c
145d24u,jnnsago,copy-paste the same little benchmark a million times and compile them all in one go.,-0.09375,go
145d24u,jnmj4pz,"If you visit this link and search ""toy script""  you'll see my python script that generates array writes.",0.0,python
145d24u,jnmj4pz,"It can generate C, Go and my language.",0.0,c
145d24u,jnmj4pz,"It can generate C, Go and my language.",0.0,go
145d24u,jnmj4pz,"Go was about 85K (array writes) on my PC, clang was 95K (array writes, clang compiles 230K lines of sqlite in <2s) and mine... well... let's just say I doubt anyone is getting my speeds anytime soon.",0.0,go
145d24u,jnnw186,"One of Go's selling point was that it was fast to compile, so I'd expect them to have benchmarks, but maybe they are internal to Google.",0.1,go
145d24u,jnnwdfl,"About Go being advertised as fast to compile, then yes I fully agree with you, they should have provided benchmarks to back their claims.",0.1,go
145d24u,jno5zfj,"The simplest examples to sort 0, 1 or 2 elements might look like:      let sort0() = ()          let sort1 a = a          let sort2(a, b) = min(a, b), max(a, b)          let sort3(a, b, c) =       let a, c = sort2(a, c) in       let a, b = sort2(a, b) in       let b, c = sort2(b, c) in       a, b, c          let sort4(a, b, c, d) =       let a, c = sort2(a, c) in       let b, d = sort2(b, d) in       let a, b = sort2(a, b) in       let c, d = sort2(c, d) in       a, b, c, d  and so on.",-0.75,c
145d24u,jno5zfj,"The simplest examples to sort 0, 1 or 2 elements might look like:      let sort0() = ()          let sort1 a = a          let sort2(a, b) = min(a, b), max(a, b)          let sort3(a, b, c) =       let a, c = sort2(a, c) in       let a, b = sort2(a, b) in       let b, c = sort2(b, c) in       a, b, c          let sort4(a, b, c, d) =       let a, c = sort2(a, c) in       let b, d = sort2(b, d) in       let a, b = sort2(a, b) in       let c, d = sort2(c, d) in       a, b, c, d  and so on.",-0.75,d
145d24u,jnnz2ss,I won't just provide a link as those eventually break:      COMPILER TESTS (c.,0.0,c
145d24u,jnnz2ss,"The test inputs were 20K, 100K,     500K or 2000K lines of:              a = b+c*d          or equivalent in each language.",0.0,d
145d24u,jnnz2ss,"a,b,c,d are integers when declared,     and initialised to 1,2,3,4.",0.0,c
145d24u,jnnz2ss,"a,b,c,d are integers when declared,     and initialised to 1,2,3,4.",0.0,d
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,c
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,d
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,lua
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,python
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,ruby
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,perl
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,rust
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,pascal
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,go
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,lisp
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,julia
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,dart
145d24u,jnnz2ss,"C Language:            Lines:          20K    100K    500K   2000K            PellesC         1.1     7.1    35.0     OOM       PellesC opt    25.0     T/O     ---     ---            lccwin          0.4     1.8     8.7    *OOM       lccwin opt      0.2     1.1     7.4    67.0            DMC           Crash     T/O     ---     ---            gcc 8.1.0       3.2    16.5   137.0    *OOM       gcc opt         0.5     1.5    12.0     T/O       g++ 8.1.0       ---    19.3       g++ opt         ---     2.7            TinyC           0.1     0.2     0.8     3.3            MSVC            1.4    11.6     T/O     ---       MSVC opt        1.4    11.6     T/O     ---            Clang           1.1     4.6    22.5    *OOM       Clang opt       0.8     3.4    18.6    73.0               Smaller C       0.8     3.6    17.8    72.0       Pico C          OOM     ---     ---     ---               Other languages:            DMD (D)        28.7    T/O     ---     ---            Lua (not JIT)   0.1    0.3     1.6     6.3            Python 2.7      0.3    1.3     5.9     OOM       Python 3.7      0.4    1.4     6.6     T/O       PyPy            1.1    5.0     OOM     ---            Ruby 192        0.2    0.8     4.0    17.7            Perl            0.2    1.0     4.8    19.6            Rustc (Rust)   30.7    T/O     ---     ---       Rustc -O        5.2    T/O     ---     ---            Nim+CC         16.0    OOM     ---     ---       Nim to C        2.0   25.0     T/O     ---            FPC (Pascal)   Fail    ---     ---     ---  (proc too complex)       FBC (Basic)     9.0    T/O     ---     ---              Go              0.8    2.0     8.0    31.0              CLISP (Lisp)    0.3    1.2     5.7    22.0  (Appears to parse and execute as it goes)            A68G (Algol68)  OOM    ---     ---     ---            Zig             8.7   40.0    *OOM     ---       eui (Euphoria)  0.3    1.3     5.1    21.0            Julia          13.0  189.0     T/O     ---            LuaJIT          0.0    0.1     0.5     2.0              Clox (Lox)      0.0    0.1     0.3     1.0              V (Vlang)       5.2   20.0     ---     ---              Dart            8.5   19.5    74.5     --- (Compiling just hello.dart takes 6.5 seconds)              Vox             1.3    1.5    2.3      5.4              Wren            0.1    0.2    0.6      2.2 (Compile only; code is inside a function)              Wasm            0.2    0.6    2.7     Fail (File too big; note line counts are 6x as high for Wasm; each a=b+c*d takes 6 lines)            Javac (Java)   Fail    ---    ---      --- (Code too large)          My languages:            MM ('M')        0.1    0.4     1.8     7.2  (5-pass, to .exe; self-hosted, built with MM)       QQ ('Q')        0.1    0.2     0.7     2.4  (3-pass Dynamic language, to internal byte-code, built with MM)          ------------------------------          Notes:          OOM means compiler reported Out of Memory and bailed out          *OOM means memory usage reached 99% (of 8GB) and was aborted          T/O means it timed out and was aborted (over 2 mins or so)          Some compilers are much faster when optimised, however virtually     no output is done (all code is eliminated), so take those results     with a pinch of salt.",-0.09647959183673471,java
145d24u,jnojggj,"    let sort4(a, b, c, d) =       let a, c = sort2(a, c) in       let b, d = sort2(b, d) in       let a, b = sort2(a, b) in       let c, d = sort2(c, d) in       a, b, c, d  Shouldn't this be defined on top of `sort3()`?",0.5,c
145d24u,jnojggj,"    let sort4(a, b, c, d) =       let a, c = sort2(a, c) in       let b, d = sort2(b, d) in       let a, b = sort2(a, b) in       let c, d = sort2(c, d) in       a, b, c, d  Shouldn't this be defined on top of `sort3()`?",0.5,d
145c4ih,jnmrm95,"Alternatively, take a look at the Array languages like APL, J, or BQN.",0.0,apl
145c4ih,jnwumrk,"Code generation is the key, just use something like Rust or Go, create a rule engine with a tiny local DB and apply rules around annotations etc on compilation time.",0.0,rust
145c4ih,jnwumrk,"Code generation is the key, just use something like Rust or Go, create a rule engine with a tiny local DB and apply rules around annotations etc on compilation time.",0.0,go
145c4ih,jnkaf6n,I believe Eiffel works that way,0.0,eiffel
145c4ih,jnlmqsh,"It's very unclear what you mean, but does sound like common lisp macros.",-0.003124999999999989,lisp
145c4ih,jnmb8n9,"I can’t think of a situation where this wouldn’t be tied to a variable changing, so it’d maybe be cheaper to look at each ‘rule’ and instrument the variables themselves.",0.0,d
145c4ih,jnmb8n9,Clojure can [add watchers](https://clojuredocs.org/clojure.core/add-watch) to its mutable containers.,0.0,clojure
145c4ih,jnmb8n9,Tcl can [add traces](https://www.tcl.tk/man/tcl8.4/TclCmd/trace.html#M14) to variables in a similar way.,0.0,tcl
145c4ih,jnmedk6,I mean that’s the general format of haskell’s rewrite rules.,-0.13124999999999998,haskell
145c4ih,jnmwfws,This is like a require statement in Eiffel.,0.0,eiffel
145c4ih,jnmxvcq,"Only because I haven’t seen anyone mention it, the https://dynamicland.org project uses a Lua dialect extended with `When` statements that function similar to what you’re describing.",0.0,lua
145c4ih,jnn0875,clojure has validators https://clojuredocs.org/clojure.core/set-validator!,0.0,clojure
145c4ih,jnn3f9j,Prolog programs are essentially a series of rules.,0.0,prolog
145c4ih,jnnsegx,"C# has attributes, which I only know the basics of - this gives a kind of metadata to a specific function or variable.",0.19999999999999998,c
145c4ih,jnxqsth,haskell if you wanted to just go all the way with your idea?,0.0,haskell
145c4ih,jnxqsth,haskell if you wanted to just go all the way with your idea?,0.0,go
145c4ih,jnncfzt,"For example if would be neat if `fun(A, B): C` could be made into a time-dependent value, by just adding an operator, like `fun!",0.375,c
145c4ih,jnncfzt,"(Signal<A>, Signal<B>): Signal<C>`.",0.0,c
145c4ih,jnncfzt,"I think Haskell does something with Monads and the ""do""-notation and Scala with ""for""-notation.",0.0,haskell
145c4ih,jnncfzt,"I think Haskell does something with Monads and the ""do""-notation and Scala with ""for""-notation.",0.0,scala
145c4ih,jnlbv4e,"Well, if “a” were a database table, I’d say SQL could do it, because you can put an update trigger on “a” and it would execute that code any time table “a” was updated…",0.0,d
145c4ih,jnldgmb,Something like Common Lisp would make this approachable.,-0.3,lisp
145c4ih,jnkfi3g,JavaScript example:  ``` function* rules() {   let a = 0;   if (a == 0) {     yield a++;   } }  function main() {   let rules = rules();   let a = rules.next().value;   console.log(rules.next().value); } ```,0.16666666666666666,javascript
145c4ih,jnojxnn,Look at Ada’s aspects which is nicked from Eiffel.,0.0,ada
145c4ih,jnojxnn,Look at Ada’s aspects which is nicked from Eiffel.,0.0,eiffel
145c4ih,jnmxflp,With haskell's do notation it would look unnoticeable,0.0,haskell
145bk89,jnk448q,[Elm](https://elm-lang.org/) does this.,0.0,elm
145bk89,jnkj2u9,"All of this is to say: if you want to specify that type-incompatible changes require major version bumps, go for it.",0.0625,go
145bk89,jnnzoas,"Which is not to say that semantic versioning based on formal semantics wouldn't be cool, but insisting on it is letting perfect be the enemy of good.",0.6833333333333332,cool
145bk89,jnmxp8i,"Considering that language-level support for preconditions/postconditions has yet to go mainstream, that's one indication of how the upfront costs aren't currently viewed as worthwhile.",0.25,go
145b3eg,jnqby21,Perl has something like a pronoun in the form of `$_` and `@_` but they have precisely defined semantics.,0.4,perl
145b3eg,jnkh6av,"I haven't come across this concept in particular before, but reading that page it is clearly about universal and existential quantifiers, and [Haskell totally lets you use them if you want](https://serokell.io/blog/universal-and-existential-quantification) - in fact, things are implicitly universally quantified by default.",0.05333333333333333,haskell
145b3eg,jnkh6av,"We can translate of the donkey sentence to type-level Haskell, which reads something like:  ```haskell class Farmer f where class Donkey d where class Owns f d where class (Farmer f, Donkey d, Owns f d) => Beats f d where     beat :: f -> d -> () ```  The type of `beat` is actually `forall f d .",0.0,haskell
145b3eg,jnkh6av,"We can translate of the donkey sentence to type-level Haskell, which reads something like:  ```haskell class Farmer f where class Donkey d where class Owns f d where class (Farmer f, Donkey d, Owns f d) => Beats f d where     beat :: f -> d -> () ```  The type of `beat` is actually `forall f d .",0.0,d
145b3eg,jnkh6av,"(Farmer f, Donkey d, Owns f d) => f -> d -> ()` and you can see that this is the donkey sentence where `f -> d -> ()` is `BEAT(X,Y)`.",0.0,d
145b3eg,jno5s4u,"To clarify, `forall f d .",0.0,d
145b3eg,jno5s4u,"(Farmer f, Donkey d, Owns f d) => BEATS(F,D)` *is the correctly encoded donkey sentence that fixes the out of scope variable*.",0.0,d
145b3eg,jno5s4u,"``` -- Taken straight from the wiki: --  ""A correct translation into first-order logic for the donkey sentence seems to be"" ∀ x ∀ y ((FARMER(x) ^ DONKEY(y) ^ OWNS(x,y)) -> BEAT(x,y)) -- The haskell encoding forall f d .",0.2,haskell
145b3eg,jno5s4u,"``` -- Taken straight from the wiki: --  ""A correct translation into first-order logic for the donkey sentence seems to be"" ∀ x ∀ y ((FARMER(x) ^ DONKEY(y) ^ OWNS(x,y)) -> BEAT(x,y)) -- The haskell encoding forall f d .",0.2,d
145b3eg,jno5s4u,"(Farmer f, Donkey d, Owns f d) => BEATS(f,d) ```  It should be clear how they are the same.",0.05000000000000001,d
145b3eg,jno5s4u,Your pseudo-code example *of an ill-formed donkey sentence* would be more akin to:  ``` forall f d .,0.5,d
145b3eg,jno5s4u,"(Farmer f, Donkey d, Owns f d) => forall d .",0.0,d
145b3eg,jno5s4u,"BEATS(f,d) -- Or maybe forall f d. (Farmer f, forall d .",0.0,d
145b3eg,jno5s4u,"(Donkey d, Owns f d)) => BEATS(f,d) -- Or maybe forall f .",0.0,d
145b3eg,jno5s4u,"(Farmer f, Donkey d, Owns f d) => forall d .",0.0,d
145b3eg,jno5s4u,"BEATS(f,d) ```  Note how the second type variable `d` shadows the first if the first is not missing entirely?",0.12,d
145b3eg,jnokwng,"This is precisely why the *correctly encoded donkey statement* starts with `forall f d` (that is, ""forall x .",0.4,d
145b3eg,jnokwng,"(Farmer f, Donkey d, Owns f d) => forall d .",0.0,d
145b3eg,jnokwng,"BEATS(f,d) ```  Note that all of the `d` to the left of `=>` are bound by whatever context encloses the sentence, eg *there exists some `d`* such that `Donkey d` and `Owns f d`.",0.0,d
145b3eg,jnokwng,"(Farmer f, exists d .",0.0,d
145b3eg,jnokwng,"(Donkey d, Owns f d)) => forall d .",0.0,d
145b3eg,jnokwng,"BEATS(f,d) -- Or -- Taken straight from the wiki: --  ""[...] it still does not give a correct translation"" forall f .",0.2,d
145b3eg,jnokwng,(exists d .,0.0,d
145b3eg,jnokwng,"(Farmer f, Donkey d, Owns f d)) => forall d .",0.0,d
145b3eg,jnokwng,"BEATS(f,d) ```  > Note that haskell doesn't have an `exists` keyword, so that's just for exposition.",0.0,d
145b3eg,jnokwng,"BEATS(f,d) ```  > Note that haskell doesn't have an `exists` keyword, so that's just for exposition.",0.0,haskell
145b3eg,jnp3hux,"If you are curious, by all means, ask questions - but you shouldn't go around asserting to people that they're wrong without being able to show it.",-0.033333333333333326,go
1457g52,,"I've been working on creating a small assembly language including an assembler, disassembler and virtual machine for the past two days.",-0.25,assembly
1457g52,,"The featureset is not huge yet (the assembly language has 28 opcodes currently, and not all of them have been implemented), but I just wanted to show it off and ask for suggestions to improve it.",-0.10000000000000002,assembly
1457g52,jnnr8n9,"Speaking of jumps, the current recursive scheme doesn't convince me with it's correctness.",0.0,scheme
1457g52,jnk4ryj,"Modern assembly code does not benefit from cryptic abbreviations; just use full words (even if you care about tab alignment, at least up to 7 chars ).",0.08333333333333336,assembly
1457g52,jnk4ryj,I'm not very familiar with C# but your memory manipulation looks *very* expensive.,-0.39711538461538465,c
1457g52,jnk4ryj,I think shifts are safe in C#?,0.5,c
1457g52,jnjpkhs,"Very cool, if I have time I’ll try to help you with that project, lemme check it out on GitHub  Edit: nvm i don’t think I’ll be able to help you, I am not very fluent in c#",0.285,cool
1457g52,jnjpkhs,"Very cool, if I have time I’ll try to help you with that project, lemme check it out on GitHub  Edit: nvm i don’t think I’ll be able to help you, I am not very fluent in c#",0.285,c
1457g52,jnk7a9r,>   >I'm not very familiar with C# but your memory manipulation looks very expensive.,-0.39711538461538465,c
1457g52,jnk7a9r,"I wrote the current implementation of the VM itself in about an hour and it is not meant to stay this way, I just wanted to get my assembly running as quickly as possible.",0.0,assembly
1457g52,jnkhbes,"Just a side note, for assembly you really don't need a ""real"" parser at all.",0.2,assembly
1452482,,"From what I've heard, other languages, such as Zig and C++, include an additional interpreter for it's *comptime* evaluation.",-0.0625,c++
1452482,,"Please enlighten me :D  My language is meant to be transpiled down to C, as I didn't want to mess with LLVM docs.",0.22314814814814818,d
1452482,,"Please enlighten me :D  My language is meant to be transpiled down to C, as I didn't want to mess with LLVM docs.",0.22314814814814818,c
1452482,,"I was thinking the compiler could take that AST nodes that are necessary for comp-time evaluation and transpile only them to C.      int32_t add (int32_t a, int 32_t b) {         return a + b;     }     int main (void) {         return add(1, 2); // 3     }  Then this C code, as explained in the begging, would get compiled down to an executable and executed.",0.002777777777777768,c
1452482,,"The result of this evaluation would get ""pasted"" into the above rust'y pseudo-code.",0.0,rust
1452482,,"fn sub (i32 a, i32 b) -> i32 {         return a - b;     }     fn main () -> void {         i32 x = 3;         i32 y = sub(10, 3);     }  This would then get transpiled down to C and from C down to the final executable.",-0.03611111111111113,c
1452482,jnipmud,"I do this by making every AST an expression and then make sure to rewrite the AST to statements where necessary for C code generation  The hard part is doing name resolution at right stage, I also allow compile time closures to close over bindings of runtime values and pass them around as first class objects so it gets a bit tricky.",0.1488095238095238,c
1452482,jnk9iiq,Not an expert but you might want to check how common lisp implementations implement macros,-0.3,lisp
1452482,jnmd1h4,This is not dissimilar to how macros tend to work in Common Lisp implementations - the function for a macro is compiled just as any other function is.,-0.2125,lisp
1452482,jnj0d59,"The only downside I can see in using libgccjit for this, is that currently they only support compiling to binary (file) or memory, but not both at once (you'd need to compile twice if your compile-time function is to be executed at both compile-time and run-time, as C++'s `constexpr` supports).",0.0,c++
1452482,jnke4ut,I think Rust and C++ are a bit more complicated because they have limitations on what can be done at compile time and at least for Rust there are a bunch of extra checks to confirm you aren’t doing anything that they consider undefined,-0.075,rust
1452482,jnke4ut,I think Rust and C++ are a bit more complicated because they have limitations on what can be done at compile time and at least for Rust there are a bunch of extra checks to confirm you aren’t doing anything that they consider undefined,-0.075,c++
1452482,jnilz2v,This is pretty much what Scala 3 does I think.,0.225,scala
1452482,jnnbp5h,Although instead of compiling an .exe i will try out C JIT compilers such as libgccjit or tccjit.,0.0,c
1452482,jnnehff,"Compiling to an executable will definitely hurt, but what about JITing C?",0.0,c
1452482,jniviyw,"And the typed ASTs are then passed to one of a few library functions that output any of C, Javascript, GLSL or webassembly  >inline AST to require a specific keyword  This is something like a lisp 'quote' function which I thought about but I think they would be unhygienic macros right?",0.028571428571428564,c
1452482,jniviyw,"And the typed ASTs are then passed to one of a few library functions that output any of C, Javascript, GLSL or webassembly  >inline AST to require a specific keyword  This is something like a lisp 'quote' function which I thought about but I think they would be unhygienic macros right?",0.028571428571428564,javascript
1452482,jniviyw,"And the typed ASTs are then passed to one of a few library functions that output any of C, Javascript, GLSL or webassembly  >inline AST to require a specific keyword  This is something like a lisp 'quote' function which I thought about but I think they would be unhygienic macros right?",0.028571428571428564,lisp
1452482,jniviyw,I use these for everything like a foreach just expands to a templated function call with a closure as a parameter  Also my compiler is written in typescript and its slow as hell so don't take any performance advice from me,-0.30000000000000004,typescript
1452482,jnj8ilg,>Also my compiler is written in typescript and its slow as hell so don't take any performance advice from me  haha,-0.05000000000000002,typescript
144owz5,jno0cif,You can use intersection types in [Scala 3](https://docs.scala-lang.org/scala3/book/types-intersection.html)!,0.0,scala
144owz5,jno0cif,"I think TypeScript also has them, but I can't find the docs page.",0.0,typescript
144ekk3,jniisgd,"What is particularly interesting to me is that if we look at the usual syntax of GADTs (Generalized Algebraic Data Types), as found in OCaml or Haskell for example, it resembles TF a lot.",0.125,haskell
143po64,jnfch8o,"I won't go into more detail on this here, other than to say that there is a lot more to it than this and there are many other denotations than the one I've outlined above.",0.20833333333333334,go
143po64,jnfch8o,I'll go one step further to give you some more context.,0.25,go
143po64,jno0v86,"If you go through the axioms carefully, you will find that this model *also* obeys them.",-0.1,go
143bzzd,,In this one we add call expressions to Wanda and make it so the reader produces linked lists like any worthy Lisp.,0.3333333333333333,lisp
143fgv6,,"Although it looks cool, I still didn't play enough with it to see if it's going to be useful at all, and I have concerns that this feature will conflict with my future intent of writing a compiler.",0.16249999999999998,cool
143fgv6,,"From what I understand, looking at Lisp/Scheme compilers, macros are expanded before compilation, and having them saved in variables would prevent the compiler to know what to expand to (unless the variable can be resolved at compile time, which might be why Scheme has let-syntax instead of just let for macros).",0.0,scheme
143fgv6,,"I'll start working on a type checker now, so I'm thinking on also separating the features that don't go well with a compiler and make them be available just before (or during) the type checker execution.",0.4,go
143fgv6,,"Those macros look equivalent to haskell functions, that evaluates their bodies before evaluating the parameters, and that can be passed around.",0.0,haskell
143fgv6,,"Haskell is able to compile them, but I was reading Simon Peyton Jones books and it looks like that requires a very different compilation scheme.",0.25,haskell
143fgv6,,"Haskell is able to compile them, but I was reading Simon Peyton Jones books and it looks like that requires a very different compilation scheme.",0.25,scheme
143fgv6,jnvjcos,"for example,      fn hello(a: int, b: macro, c: string) { ... }  would get compiled into,      fn hello(a: int, c: string) { ... }  Then, for each call of `hello()`, you would have to (at compile time) generate multiple versions of the hello function, each one with a different macro applied.",0.0,c
143fgv6,jncy4tp,form Syntax))     (expand form env)))          (a (print 1)) # *> (print 1)     (b (print 2)) # *> (print 2)     (let c a)     (c (print 3)) # *> (print 3)          (var d b) # d : (Mut (type b))     # (set!,-0.9375,c
143fgv6,jncy4tp,form Syntax))     (expand form env)))          (a (print 1)) # *> (print 1)     (b (print 2)) # *> (print 2)     (let c a)     (c (print 3)) # *> (print 3)          (var d b) # d : (Mut (type b))     # (set!,-0.9375,d
143fgv6,jncy4tp,"d a) !> cannot swap (type a) with (type b)          # (d) is dereference : (type b)     # as b is unique, this can be expanded without runtime knowledge     ((d) (print 4)) # *> (print 4)",-0.1875,d
143a6qa,jnb2xoh,"Using the file system + a list of search directories (like `-I` for C and C++ includes, and `-L` for `.so`/`.dll` files) actually gives all the freedom necessary for implementing a package manager.",0.0,c
143a6qa,jnb2xoh,"Using the file system + a list of search directories (like `-I` for C and C++ includes, and `-L` for `.so`/`.dll` files) actually gives all the freedom necessary for implementing a package manager.",0.0,c++
143a6qa,jn9o96a,"Type parameters are fields on that struct with the type `Box<dyn Type>` (where `Type` is a trait):  ```rust struct func_f {   A: Box<dyn Type>, }; ```  Then, when you call `f<int>(42)`:  ```rust let func_instance = func_f { A: Box::new(IntType{}) }; func_instance.call(args); ```",0.0,rust
143a6qa,jn9ou31,Will this cause the generated rust code to throw a compiler error?,0.0,rust
143a6qa,jn9q6jf,"And even if I had rustc errors, I set its output format to JSON to catch them and then use source maps to track down the Letlang code that produced the faulty Rust code.",-0.15555555555555559,rust
143a6qa,jn9r7pa,">And even if I had rustc errors, I set its output format to JSON to catch them and then use source maps to track down the Letlang code that produced the faulty Rust code.",-0.15555555555555559,rust
143a6qa,jn9vvkk,"This happens to be true for `A = int`, but not for anything else, so if you interpret type parameters as parametric (which you should, because that is how they work in most statically typed languages except C++), it is still a contract violation.",0.425,c++
1437nai,,It gave some examples like Rust not including a Random package (since one for cryptography would be unsuitable for day to day [i.e.,-0.5,rust
142qw6x,jn5xafa,Java did not choose type erasure because of backwards compatibility.,0.0,java
142qw6x,jn5xafa,C# does not erase generic types.,0.0,c
142qw6x,jn5yddy,"> All realizations using reference types can share the same compiled code  That can be true for a lot of generics such as collections, though if we have a type bound on a generic parameter `T extends ISpaceship` and want to call `.launch()` on an instance of `T`, then a language like Vale or Rust would need different instantiations to call the correct function...",0.06999999999999999,rust
142qw6x,jn5yddy,"I think Java doesn't need to, not sure about C#.",-0.25,java
142qw6x,jn5yddy,"I think Java doesn't need to, not sure about C#.",-0.25,c
142qw6x,jn5yddy,We would only need to instantiate different versions of a function for different sizes of T. That would be pretty cool.,0.12,cool
142qw6x,jn5w9cy,why Python does not need generics?,0.0,python
142qw6x,jn6iij4,">  though if we have a type bound on a generic parameter `T extends ISpaceship` and want to call `.launch()` on an instance of `T`, then a language like Vale or Rust would need different instantiations to call the correct function...",0.0,rust
142qw6x,jn6iij4,"I think Java doesn't need to, not sure about C#.",-0.25,java
142qw6x,jn6iij4,"I think Java doesn't need to, not sure about C#.",-0.25,c
142qw6x,jn6iij4,Same with C#.,0.0,c
142qw6x,jn6iij4,The reason Rust (and I assume Vale) need monomorphization to call trait methods is because those trait methods are dispatched *statically*.,0.0,rust
142qw6x,jn6iij4,Java and C# can compile a generic method once for all type arguments because any method called on an instance of the type argument is a virtual call going through the instance's v-table.,0.0,java
142qw6x,jn6iij4,Java and C# can compile a generic method once for all type arguments because any method called on an instance of the type argument is a virtual call going through the instance's v-table.,0.0,c
142qw6x,jn6iij4,"In Rust, since trait calls are statically dispatched, the calls at runtime are faster.",0.0,rust
142qw6x,jn66r9v,Java references are similar to dyn Trait in Rust.,0.0,java
142qw6x,jn66r9v,Java references are similar to dyn Trait in Rust.,0.0,rust
142pydn,,Relish  is a homegrown LISP I have written from scratch using only safe Rust  (with the exception of libc calls in POSIX job control libraries).,0.25,lisp
142pydn,,Relish  is a homegrown LISP I have written from scratch using only safe Rust  (with the exception of libc calls in POSIX job control libraries).,0.25,rust
142pydn,,"Relish  implements most features one would expect from a LISP (while, let,  lambda, quote/eval, def, if, etc...) as well as a fully interactive job  control shell!",0.625,lisp
142pydn,,"Relish  implements most features one would expect from a LISP (while, let,  lambda, quote/eval, def, if, etc...) as well as a fully interactive job  control shell!",0.625,shell
142pydn,,"Included in the shell features are first class forms for  piped commands, command short circuiting, and IO redirection.",0.125,shell
142pydn,,It turns out being able to work with a homoiconic  language for your shell is super powerful.,0.37777777777777777,shell
142pydn,,I can make self programming  routines that generate shell commands and bindings without individually  aliasing things or writing redundant boilerplate code.,-0.10000000000000002,shell
142pydn,,I  hope at least one other person thinks this is cool.,-0.025000000000000005,cool
142pydn,,You (could possibly) wish your shell config looked this cool: [(My shell config)](https://pastebin.com/tRZPx9ff)  Relish called in CI: [(Tests for optional features written in Relish)](https://gitlab.com/whom/relish/-/blob/main/snippets/userlib-tests.rls)  Homoiconicity put to work for shell use: [(Shell command binding generator)](https://gitlab.com/whom/relish/-/blob/main/snippets/genbind.rls)  (Docs are linked to in the Readme),-0.38,shell
142pydn,,You (could possibly) wish your shell config looked this cool: [(My shell config)](https://pastebin.com/tRZPx9ff)  Relish called in CI: [(Tests for optional features written in Relish)](https://gitlab.com/whom/relish/-/blob/main/snippets/userlib-tests.rls)  Homoiconicity put to work for shell use: [(Shell command binding generator)](https://gitlab.com/whom/relish/-/blob/main/snippets/genbind.rls)  (Docs are linked to in the Readme),-0.38,cool
142pydn,jna3pxx,Wicked cool.,0.35,cool
142pydn,jna3pxx,"Fyi, there is another lisp shell project called ciel; it's a precompiled sbcl binary with a bunch of libraries included: http://ciel-lang.org/#/ it's not meant to also be a shell though, and yours is built from the ground up.",0.0,lisp
142pydn,jna3pxx,"Fyi, there is another lisp shell project called ciel; it's a precompiled sbcl binary with a bunch of libraries included: http://ciel-lang.org/#/ it's not meant to also be a shell though, and yours is built from the ground up.",0.0,shell
142pydn,jn8e1al,Closer to Scheme or Cl ?,0.0,scheme
142pydn,jn7tzbe,Relish is a terminal agnostic shell that will handle programs like vim and emacs (-nw) just fine.,0.4166666666666667,shell
142pydn,jn7tzbe,> Eshell commands can not (easily) be combined with lisp forms  Writing in Relish all commands are written as sexprs/forms.,-0.21666666666666667,lisp
142pydn,jn7tzbe,You can conceptualize it more like scheme than elisp (it is not a scheme though).,0.5,scheme
142pydn,jn96x3w,"The core interpreter isn't that complex :)  The language itself is closer to scheme than cl, but more simple than scheme even.",0.175,scheme
142pydn,jnd8nuu,Emacs as any other Lisp has its own symbol tables too :).,0.325,lisp
142pydn,jnd8nuu,"I am not sure what you mean that Relish keep it's symbol tables  synchronized to the environment, but as any process, Emacs as well reflects changes in its process environment, to the level that programmers who write lisp applications in Emacs Lisp care about the environment.",-0.28125,lisp
142pydn,jnd8nuu,>     Eshell commands can not (easily) be combined with lisp forms >  > Writing in Relish all commands are written as sexprs/forms.,-0.21666666666666667,lisp
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,shell
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,bash
142pydn,jnd8nuu,"I don't know if you are just unfamiliar with the Eshell to that level, but Eshell lets you use either shell commands (a.k.a Bash), or Lisp forms.",0.0,lisp
142pydn,jnd8nuu,The comment you have quoted is talking about combining shell commands with Lisp forms.,0.0,shell
142pydn,jnd8nuu,The comment you have quoted is talking about combining shell commands with Lisp forms.,0.0,lisp
142pydn,jnd8nuu,"But you can use Elisp in Eshell and as long as you are keeping yourself in the Lisp land you can combine lisp forms as normally in Lisp, which makes Eshell equal to Relish in that regard (just with a more powerful Lisp).",0.18,lisp
142pydn,jnd8nuu,"Generally, since Eshell supports *two* different syntaxes, shell and lisp, it is not very meaningful to compare the two featurewise.",-0.04743589743589743,shell
142pydn,jnd8nuu,"Generally, since Eshell supports *two* different syntaxes, shell and lisp, it is not very meaningful to compare the two featurewise.",-0.04743589743589743,lisp
142pydn,jnd8nuu,"It is of course not a critique to a toy lisp like Relish, it would be unrealistic to expect it to support same stuff as Emacs, just trying to clear up potential confusion here that people might have.",-0.09999999999999999,lisp
142pydn,jn9xgj0,(Also not too familiar with Rust).,0.375,rust
142pydn,jnef157,"> you can use Elisp in Eshell and as long as you are keeping yourself in the Lisp land you can combine lisp forms as normally in Lisp, which makes Eshell equal to Relish in that regard (just with a more powerful Lisp).",0.18,lisp
142pydn,jnef157,"Actually, with relish you can seamlessly integrate lisp forms with shell commands.",0.05,lisp
142pydn,jnef157,"Actually, with relish you can seamlessly integrate lisp forms with shell commands.",0.05,shell
142pydn,jng9v9e,"> (l ping -c COUNT (get-api-domain)) Here COUNT is either used verbatim or expanded to whatever value that variable references  Your example is trivial in Emacs Lisp and Eshell:      (defmacro l (&rest args)       (let ((cmd))         (dolist (arg (nreverse `(,@args)))           (push arg cmd))         (shell-command-to-string (format ""%S"" cmd))))  The mockup:      (defun get-api-domain ()       'api.trashcan.services)     (defvar COUNT 4)      Eshell just did it:      c:/emacs/help-remote $ (l ping -c COUNT (get-api-domain))  Perhaps better with something that does not require admin priviledge?",-0.3333333333333333,lisp
142pydn,jng9v9e,"> (l ping -c COUNT (get-api-domain)) Here COUNT is either used verbatim or expanded to whatever value that variable references  Your example is trivial in Emacs Lisp and Eshell:      (defmacro l (&rest args)       (let ((cmd))         (dolist (arg (nreverse `(,@args)))           (push arg cmd))         (shell-command-to-string (format ""%S"" cmd))))  The mockup:      (defun get-api-domain ()       'api.trashcan.services)     (defvar COUNT 4)      Eshell just did it:      c:/emacs/help-remote $ (l ping -c COUNT (get-api-domain))  Perhaps better with something that does not require admin priviledge?",-0.3333333333333333,c
142pydn,jng9v9e,"> (l ping www.google.com)  The answer:      c:/emacs/help-remote $ (l ping www.google.com)             Pinging www.google.com [142.250.74.36] with 32 bytes of data:         Reply from 142.250.74.36: bytes=32 time=143ms TTL=53         Reply from 142.250.74.36: bytes=32 time=20ms TTL=53         Reply from 142.250.74.36: bytes=32 time=24ms TTL=53         Reply from 142.250.74.36: bytes=32 time=14ms TTL=53          Ping statistics for 142.250.74.36:         Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),     Approximate round trip times in milli-seconds:         Minimum = 14ms, Maximum = 143ms, Average = 50ms  But that is totally missing the point, since Eshell does not have to do anything like creating that macro but can just execute shell syntax directly, and even combine it with Emacs Lisp functions:          Welcome to the Emacs shell          ~ $ ping -c COUNT (get-api-domain)     Access denied.",-0.00833333333333336,c
142pydn,jng9v9e,"> (l ping www.google.com)  The answer:      c:/emacs/help-remote $ (l ping www.google.com)             Pinging www.google.com [142.250.74.36] with 32 bytes of data:         Reply from 142.250.74.36: bytes=32 time=143ms TTL=53         Reply from 142.250.74.36: bytes=32 time=20ms TTL=53         Reply from 142.250.74.36: bytes=32 time=24ms TTL=53         Reply from 142.250.74.36: bytes=32 time=14ms TTL=53          Ping statistics for 142.250.74.36:         Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),     Approximate round trip times in milli-seconds:         Minimum = 14ms, Maximum = 143ms, Average = 50ms  But that is totally missing the point, since Eshell does not have to do anything like creating that macro but can just execute shell syntax directly, and even combine it with Emacs Lisp functions:          Welcome to the Emacs shell          ~ $ ping -c COUNT (get-api-domain)     Access denied.",-0.00833333333333336,shell
142pydn,jng9v9e,"> (l ping www.google.com)  The answer:      c:/emacs/help-remote $ (l ping www.google.com)             Pinging www.google.com [142.250.74.36] with 32 bytes of data:         Reply from 142.250.74.36: bytes=32 time=143ms TTL=53         Reply from 142.250.74.36: bytes=32 time=20ms TTL=53         Reply from 142.250.74.36: bytes=32 time=24ms TTL=53         Reply from 142.250.74.36: bytes=32 time=14ms TTL=53          Ping statistics for 142.250.74.36:         Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),     Approximate round trip times in milli-seconds:         Minimum = 14ms, Maximum = 143ms, Average = 50ms  But that is totally missing the point, since Eshell does not have to do anything like creating that macro but can just execute shell syntax directly, and even combine it with Emacs Lisp functions:          Welcome to the Emacs shell          ~ $ ping -c COUNT (get-api-domain)     Access denied.",-0.00833333333333336,lisp
142pydn,jng9v9e,"Or what about this:      ~ $ (message ""Hello"") > greeting.txt     ~ $ ls | grep greeting     (standard input):greeting.txt  There are limitations of course when it comes to shell syntax, but on Lisp side, Eshell can do anything Relish can and much more.",0.25,shell
142pydn,jng9v9e,"Or what about this:      ~ $ (message ""Hello"") > greeting.txt     ~ $ ls | grep greeting     (standard input):greeting.txt  There are limitations of course when it comes to shell syntax, but on Lisp side, Eshell can do anything Relish can and much more.",0.25,lisp
142pydn,jng9v9e,"It is a bit similar idea to yours, but Emacs Lisp itself provides for what Relish does, in quite trivial manner, while Eshell adds shell syntax and let you mix the two seemlesly.",0.0,lisp
142pydn,jng9v9e,"It is a bit similar idea to yours, but Emacs Lisp itself provides for what Relish does, in quite trivial manner, while Eshell adds shell syntax and let you mix the two seemlesly.",0.0,shell
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,c
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,d
142ixw5,jn4v85p,"Since `C` is described as ""fast"", but `Cython`, `D` and `Julia` are ""very fast"".",0.23,julia
142ixw5,jn4v85p,As is `Lua`.,0.0,lua
142ixw5,jnbw66m,"Yeah, as much as I love D, characterizing it as faster than C seems wrong.",0.0,d
142ixw5,jnbw66m,"Yeah, as much as I love D, characterizing it as faster than C seems wrong.",0.0,c
142ixw5,jnbw66m,"D's performance is C-like for most things, but it is generally a little slower, and occasionally *much* slower.",0.1708333333333333,d
142ixw5,jnbw66m,According to https://programming-language-benchmarks.vercel.app/d-vs-c D only outperformed C on one microbenchmark (nsieve).,0.0,d
142ixw5,jnbw66m,According to https://programming-language-benchmarks.vercel.app/d-vs-c D only outperformed C on one microbenchmark (nsieve).,0.0,c
142ixw5,jnbw66m,"From my limited experience with Julia, it's the same kind of mixed bag.",0.13214285714285715,julia
142ixw5,jnbw66m,"Julia outperforms C on matrix operations, but slightly underperforms C on pretty much everything else.",0.09444444444444444,julia
142ixw5,jnbw66m,"Julia outperforms C on matrix operations, but slightly underperforms C on pretty much everything else.",0.09444444444444444,c
142ixw5,jnbw66m,"D has three compilers -- the reference implementation (DMD), the GCC implementation (GDC) and the LLVM implementation (LDC).",0.0,d
142ixw5,jnbw66m,"When gauging the performance of Lua, does one use luac as the standard, or luajit?",0.0,lua
142iq4o,,"It is inspired by bash pipelines, prolog and EBNF.",0.0,bash
142iq4o,,"It is inspired by bash pipelines, prolog and EBNF.",0.0,prolog
142iq4o,,"Here's the syntax for two threads that sends a value to another thread and then the receiving thread sends a value back again:  ``` thread(s) = state1(yes) | send(message) | receive(message2); thread(r) = state1(yes) | receive(message) | send(message2); ```  Both threads parse the state machine and run it but their own copy of it  * thread(s) stateline is marked as runnable in thread 0 * thread(r) stateline is marked as runnable in thread 1  The threads know about eachother when there is a send  I mean interpolated by the fact that the variable is used to identify data flow between states  You could have a flow of books through different states  ```  books(n) = available(n) | reserved(n) | lent-out(n)  ```  then you could create `books(101)`, `books(102)` `books(103)` at runtime  You could trigger logic to happen when a book reservation is cancelled by writing   ``` books(n) cancelled(n) = lent-out(n) | available(n)  ```  In this manner, collections can be represented in the state machine.",0.08124999999999999,r
142iq4o,jne0dm6,"To paraphrase a famous quote, those who do not learn from Erlang are doomed to reimplement it.",0.5,erlang
142cxoh,,"So I just write a simple script to test how fast you can sum all numbers up to a certain amount...      //the test case (toy)     fn test_sum(key: int, val: int) {     	fn sum(n: int) {     		if (n < 2) {     			return n;     		}          		return n + sum(n - 1);     	}          	var result: int const = sum(val);     	print string key + "": "" + string result;     }          for (var i: int = 0; i <= 10; i++) {     	test_sum(i, i * 1000);     }  And then I wrote the [exact same code in JavaScript and C](https://github.com/Ratstail91/Toy/tree/main/scripts/test_sum), and compared them.",0.11071428571428571,javascript
142cxoh,,"So I just write a simple script to test how fast you can sum all numbers up to a certain amount...      //the test case (toy)     fn test_sum(key: int, val: int) {     	fn sum(n: int) {     		if (n < 2) {     			return n;     		}          		return n + sum(n - 1);     	}          	var result: int const = sum(val);     	print string key + "": "" + string result;     }          for (var i: int = 0; i <= 10; i++) {     	test_sum(i, i * 1000);     }  And then I wrote the [exact same code in JavaScript and C](https://github.com/Ratstail91/Toy/tree/main/scripts/test_sum), and compared them.",0.11071428571428571,c
142cxoh,,"The result was quite good, IMO -  C : JavaScript : Toy = 1.00 : 16.25 : 109.50  For a language implementation built from the ground up in six months, I'm quite surprised that it's less than than one order slower than JS, and only roughly 2 orders slower than C.  I know this is a pretty simple way of testing speed, but I figured I'd put it up to see what others thought.",0.11190476190476191,c
142cxoh,,"The result was quite good, IMO -  C : JavaScript : Toy = 1.00 : 16.25 : 109.50  For a language implementation built from the ground up in six months, I'm quite surprised that it's less than than one order slower than JS, and only roughly 2 orders slower than C.  I know this is a pretty simple way of testing speed, but I figured I'd put it up to see what others thought.",0.11190476190476191,javascript
142cxoh,,&#x200B;  Edit: NEVERMIND I should learn to run tests multiple friggin' times  C	0.002s	1  JS	0.064s	32  Py3	0.070s	35  Toy	0.430s	215,0.0,c
142cxoh,jn42p4d,"With C, I got a timing of pretty much zero seconds, even unoptimised; at any rate hard to disinguish from the time taken to run an empty program.",0.01458333333333333,c
142cxoh,jn42p4d,"The benchmark also isn't the same: some use nested functions, the C at least doesn't do that.",-0.15,c
142cxoh,jn42p4d,"A better benchmark should run a bit longer (on Windows at least, measuring very fast runtimes is hard), and the C should not be affected by optimisation too much.",0.07366666666666667,c
142cxoh,jn42p4d,Measuring against upoptimised C might be fairer: you are still comparing interpreted code against native.,0.0,c
142cxoh,jn717ig,"Now I could put together a `Fibonacci` test like this:      fn fib(n:int) {         if (n<3) {             return 1;         } else {             return fib(n-1)+fib(n-2);         }     }          for (var i: int = 1; i <= 36; i++) {         var res:int =fib(i);         print string i + "" "" + string res;     }  I tested this with `toyrepl` and compared with other products I had lying around:       PicoC      81,000    seconds (extrapolated)      toyrepl       340      A68G           16    (Algol68 interpreter)      CPython 3.11    7      Q-fn            5.4      Lua 5.4         3.7      Q-asm           1.35 (Q is my dynamic language)      PyPy            0.7      LuaJIT          0.33      C               0.2  unoptimised      C               0.11 optimised  This shows a wider disparity than your test.",-0.0625,lua
142cxoh,jn717ig,"Now I could put together a `Fibonacci` test like this:      fn fib(n:int) {         if (n<3) {             return 1;         } else {             return fib(n-1)+fib(n-2);         }     }          for (var i: int = 1; i <= 36; i++) {         var res:int =fib(i);         print string i + "" "" + string res;     }  I tested this with `toyrepl` and compared with other products I had lying around:       PicoC      81,000    seconds (extrapolated)      toyrepl       340      A68G           16    (Algol68 interpreter)      CPython 3.11    7      Q-fn            5.4      Lua 5.4         3.7      Q-asm           1.35 (Q is my dynamic language)      PyPy            0.7      LuaJIT          0.33      C               0.2  unoptimised      C               0.11 optimised  This shows a wider disparity than your test.",-0.0625,c
142cxoh,jn717ig,"Notes:  * Fibonacci can be a challenging benchmark, especially if your function calls are slow * I don't know if `toyrepl` is optimised or is the fastest way of running this program * PyPy and LuaJIT use JIT, so I wouldn't pay much attention to those timings; JIT always gives astonishing results on microbenchmarks * Pico C is a C interpreter, and not a fast one.",0.13333333333333333,c
142cxoh,jn4zsze,The C entry was just curiosity.,0.0,c
142cxoh,jn5odgg,"Cool, thanks!",0.3,cool
142cxoh,jn5h1j7,"You may be right in this case, but I've seen people's benchmarks ""my language is almost as fast as C!""",0.26785714285714285,c
142cxoh,jn8h0kl,"I eventually figured it out, I created `toy.exe` from inside `./source` like this, which runs directly under Windows:      c:\toy\source>gcc -O3 -s *.c ..\repl\*.c -I.",0.1,c
141z4k2,jn3u2hs,FYI: Did you know LOGO is actually Lisp without all those parentheses?,0.0,lisp
141z4k2,jn6s5ka,"Arguably a dialect of lisp, but with a *heavy* accent because words had defined arity and there was operator precedence and square brackets meant something different than round parentheses, but GOD it was fun!",-0.0062500000000000056,lisp
141z4k2,jn6skpf,Pascal was a teaching language.,0.0,pascal
141z4k2,jn6skpf,Python started life as a teaching language.,0.0,python
141sjvi,jn1lw2d,"----  Several companies in fact do profit(now or in the past) with programming languages: MS, Borland, Apple, Amazon, Ericcson, IBM, Informix, FoxPro, SAP (and a lot of ERP/app Bussines makers), kdb+, APL, RDBMS & NoSQL makers, Some game makers, etc  It would be best if you *opened your mind* about how *exactly* this fit in the idea (I think you will not see at first how Apple ""profit"" from programming languages!",0.1875,apl
141sjvi,jn1j1vr,Why not just go into consulting for existing languages?,0.0,go
141sjvi,jn200fy,"Not for Python, not for Zig, not for Apple, *NOBODY* makes money on that *particular* aspect of the game.",-0.11666666666666668,python
141sjvi,jn200fy,There's no doubt that Apple released Swift so that developers would release iPhone-only applications.,0.0,swift
141sjvi,jn200fy,"Python was a teaching language, but Guido can write a number on paper and someone will pay it.",0.0,python
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,go
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,dart
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,swift
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,rust
141sjvi,jn3cc2s,"Google made Go and Dart, Apple made Swift, Mozilla made Rust, Microsoft made Typescript.",0.0,typescript
141sjvi,jp6z1lr,Look at Objective-C for instance.,0.0,objective-c
141sjvi,jp6z1lr,"It achieved that by taking the language people had used so far, C, and adding a few small constructs on top that made it easy to do polymorphism, dynamism and message sending _only when you needed it_.",0.09722222222222222,c
141sjvi,jp6z1lr,So Objective-C runs any of your old C code.,0.1,objective-c
141sjvi,jp6z1lr,So Objective-C runs any of your old C code.,0.1,c
141sjvi,jp6z1lr,"(compatibility) Also, if you need to optimize for speed, you are able to replace object-oriented code with plain C code for those important tight loops.",0.12678571428571428,c
141sjvi,jp6z1lr,"I wouldn't try being the next C# or C++ at this point, though.",0.0,c
141sjvi,jp6z1lr,"I wouldn't try being the next C# or C++ at this point, though.",0.0,c++
141sjvi,jn1t569,Step 1: Learn cobol.,0.0,cobol
141sjvi,jn1zkhd,Then you release a new free service that also just so happens to go smoothly with your language.,0.31212121212121213,go
141qm6g,jn38nzo,"to be clear, i think rust has been a wild success, and i feel thankful for the product that so many people's hard work has produced.",0.14166666666666666,rust
141qm6g,jn38nzo,i'm not even sure the original vision would have been able to have the social success that has been so vital to rust's adoption.,0.30138888888888893,rust
141qm6g,jn38nzo,"that said, i have been following rust since the earliest days and i always felt more aligned with graydon's vision in those early days than i feel to the current rust.",0.15,rust
141qm6g,jn38nzo,"there is so much ground between c++ replacement and ocaml when it comes to performance, abstraction capabilities, expressiveness, convenience.",0.2,c++
141qm6g,jn1vh0p,"I liked how the article talked about tail calls at the *end*  “I got argued into not having them because the project in general got argued into the position of ""compete to win with C++ on performance"" and so I wound up writing a sad post rejecting them which is one of the saddest things ever written on the subject”",0.1566666666666667,c++
141qm6g,jn3a1eg,"I really wish the rust he wanted existed, it sounds beautiful.",0.525,rust
141qm6g,jn3a1eg,"These are 2 of the 3 reasons I quit using rust at different points in the past, with the 3rd being no obvious way to make your own error system and how unwrap with ?",0.06999999999999999,rust
141qm6g,jn1uwo6,It's crazy that in 2014 I said several of these reasons of why I didn't like rust and I was told I just didn't understand it enough and that I needed to do multiple projects to see why these decisions were good.,0.019999999999999997,rust
141qm6g,jna20d9,I definitely think there's space in the ecosystem for a natively compiled language mid-way between Go and Rust:   - More heavily typed than Go.,0.09999999999999999,go
141qm6g,jna20d9,I definitely think there's space in the ecosystem for a natively compiled language mid-way between Go and Rust:   - More heavily typed than Go.,0.09999999999999999,rust
141qm6g,jna20d9,- Not quite as low-level as Rust: green threads + no-lifetimes.,-0.2,rust
141qm6g,jna43dp,"Well, you weren't wrong, and you weren't right either :)  As Graydon mentions, his Rust wouldn't have been _better_, it would have been _different_.",0.15714285714285714,rust
141qm6g,jna43dp,"I really like today's Rust, but part of it is because I _love_ performance/pedal-to-the-floor code, and today's Rust offers me that in a nice package.",0.35,rust
141qm6g,jna43dp,"Don't like the syntax, can't program like it were Java or Python, etc...",0.0,java
141qm6g,jna43dp,"Don't like the syntax, can't program like it were Java or Python, etc...",0.0,python
141qm6g,jna43dp,"Rust clashes with that because the ownership/borrowing discipline is just plain new to many, and it takes time getting used to it.",0.14069264069264067,rust
141qm6g,jna43dp,"Most people who stuck to hit -- who reach the ""hindsight"" part -- agree that Rust has changed the way they approach programming even in other languages, and that their programs are better for it.",0.2916666666666667,rust
141qm6g,jn2ok7n,"Rust has TCO, not guaranteed tail callss which the article talks about  See https://github.com/phi-go/rfcs/blob/guaranteed-tco/text/0000-explicit-tail-calls.md",0.0,rust
141qm6g,jymlfl5,"But I think, in a lot of ways, Haskell is this language.",0.0,haskell
141qm6g,jymlfl5,"I know, I know, it’s Haskell!",0.0,haskell
141qm6g,jymlfl5,"But I happen to believe that much of what makes it truly so impressive is often unsung:  * Many of Rust’s features, such as traits and enums, come more or less directly from Haskell.",0.30476190476190484,rust
141qm6g,jymlfl5,"But I happen to believe that much of what makes it truly so impressive is often unsung:  * Many of Rust’s features, such as traits and enums, come more or less directly from Haskell.",0.30476190476190484,haskell
141qm6g,jymlfl5,"It includes Go-style channels and queues for cross-thread communication (and, incidentally, it did before Go so much as existed), plus an efficient implementation of software transactional memory largely based around optimistic, lock-free transactions.",0.20714285714285713,go
141qm6g,jymlfl5,"* Despite its reputation, the Haskell type system is legitimately simpler than Rust’s.",0.0,haskell
141qm6g,jymlfl5,"* Despite its reputation, the Haskell type system is legitimately simpler than Rust’s.",0.0,rust
141qm6g,jymlfl5,The trait metaprogramming routinely used in Rust would make most Haskellers’ heads spin.,0.5,rust
141qm6g,jymlfl5,"* `cabal`, Haskell’s equivalent to `cargo`, is not nearly as polished or friendly, and it is sadly somewhat old and crufty.",-0.018749999999999996,haskell
141qm6g,jymlfl5,* The library ecosystem is pretty solid for most of the usual things people do with languages like Go.,0.125,go
141qm6g,jymlfl5,Writing Haskell is not doing mathematics.,0.0,haskell
141qm6g,jymlfl5,"Haskell is a programming language, and writing Haskell is programming.",0.0,haskell
141qm6g,jymlfl5,"And if you’re coming from Rust, you’ll find it remarkably easy to pick up.",0.43333333333333335,rust
141qm6g,jymlfl5,"Give it a try—and even if you decide you don’t like it, frankly, I’d be super interested to hear what your biggest pain points were.",0.29166666666666663,d
141qm6g,jna4yq0,"From a language design perspective, it seems like rust as it is now was carefully tuned to be good at mutable aliasing in parallelism.",0.3,rust
141qm6g,jna4yq0,I agree that there is a space above rust.,0.0,rust
141qm6g,jna4yq0,"Rust is successful because of its ecosystem and tooling, not because of lifetime annotations and async/await.",0.75,rust
141qm6g,jp6s22n,Maybe Crystal?,0.0,crystal
141qm6g,jnmgti2,"> As Graydon mentions, his Rust wouldn't have been better, it would have been different.",0.25,rust
141qm6g,jnmgti2,"> I really like today's Rust, but part of it is because I love performance/pedal-to-the-floor code, and today's Rust offers me that in a nice package.",0.35,rust
141qm6g,jnmgti2,"Some of his criticisms are entirely performance focus like Cross-crate inlining, monomorphization and iterators  I find rust slow but performance to me means something different than most people.",0.04999999999999999,rust
141qm6g,jnmgti2,To me go compiler isn't fast a single clang process compiles faster than go (wall clock time).,0.0642857142857143,go
141qm6g,jnmgti2,It isn't a fair comparison either because go uses multiple threads while most people never use a single process to build.,0.28214285714285714,go
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,go
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,c
141qm6g,jnmgti2,"clang destorys go in build time (C, with C++ YMMV, few templates and many destructors is roughly C fast).",0.16666666666666666,c++
141qm6g,jnmgti2,Painful  I'm very tired of hearing people think this is the reason and given up saying anything about rust.,-0.61,rust
141qm6g,jnoz2qv,The switching back and forth could be done through simple jumps.,0.0,forth
141qm6g,jz9s43u,"Rust's enum don't come from Haskell, they come from ML/OCaml.",0.0,rust
141qm6g,jz9s43u,"Rust's enum don't come from Haskell, they come from ML/OCaml.",0.0,haskell
141qm6g,jz9s43u,> The trait metaprogramming routinely used in Rust would make most Haskellers’ heads spin.,0.5,rust
141qm6g,jz9s43u,"Do you have specific examples of Rust trait metaprogramming, to give me some idea?",0.0,rust
141qm6g,jz1x5e1,"i've been a fan on your work with haskell, hackett, effects etc and am really enjoying your recent vids in defense of laziness.",0.25,haskell
141qm6g,jz1x5e1,i have to agree that i find myself coming back to haskell in a way that surprises me.,0.0,haskell
141qm6g,jz1x5e1,"it was the era of ""everyone should try out haskell, prolog, lisp, forth, apl, just to see how weird it all is"".",-0.5,haskell
141qm6g,jz1x5e1,"it was the era of ""everyone should try out haskell, prolog, lisp, forth, apl, just to see how weird it all is"".",-0.5,prolog
141qm6g,jz1x5e1,"it was the era of ""everyone should try out haskell, prolog, lisp, forth, apl, just to see how weird it all is"".",-0.5,lisp
141qm6g,jz1x5e1,"it was the era of ""everyone should try out haskell, prolog, lisp, forth, apl, just to see how weird it all is"".",-0.5,forth
141qm6g,jz1x5e1,"it was the era of ""everyone should try out haskell, prolog, lisp, forth, apl, just to see how weird it all is"".",-0.5,apl
141qm6g,jz1x5e1,"then it was a thing that was like a practice tool where i would periodically go try to learn how to do complex things in it and feel way out of my depth reading papers i didn't understand, but having fun the whole time.",0.06666666666666667,go
141qm6g,jz1x5e1,"then one day i looked up and realized it's actually incredibly productive, and when i work in other languages day to day (even rust!)",0.371875,rust
141qm6g,jz1x5e1,"i thought lazy-by-default was such a headache for a long time, but at this point most of my day to day work involves (often high-volume) streaming, and every single ecosystem i work in has their own way of expressing that, usually either explicit opt-in laziness, if you're lucky with some syntax sugar, but i have realized that it's so much more to hold in your head than going the other way and making a given codepath eager in haskell.",0.15965608465608466,haskell
141qm6g,jz1x5e1,"laziness ""infects"" an eager language/runtime in a way that doesn't seem to go the other way.",-0.125,go
141qm6g,jz1x5e1,I think there are other languages doing interesting stuff right now and there are certainly some warts with haskell but really the only thing that keeps me from reaching for haskell first is a lack of libraries.,0.18928571428571428,haskell
141qm6g,jneuhmo,"> From a language design perspective, it seems like rust as it is now was carefully tuned to be good at mutable aliasing in parallelism.",0.3,rust
141qm6g,jneuhmo,Rust is tuned to be good at mutable aliasing.,0.7,rust
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,c
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,c++
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,go
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,java
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,javascript
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,python
141qm6g,jneuhmo,"C, C++, and Go have crashes, Java has `ConcurrentModificationException` if you're lucky, C#, JavaScript, Python, and Ruby may not have anything (just be careful).",0.11666666666666665,ruby
141qm6g,jneuhmo,"Rust is somewhat unique in that it deals with the mutable aliasing problem head-on, and actually ""solves"" it... at an ergonomic cost.",0.1875,rust
141qm6g,jp8wsog,"Not for me ;)  I favor type-classes over inheritance and Result over exceptions, so... no, not Crystal.",0.25,crystal
141qm6g,jnn6m4u,Painful > > I'm very tired of hearing people think this is the reason and given up saying anything about rust.,-0.61,rust
141qm6g,jnn6m4u,"I remember playing with Forth and Haskell, and boy was my whole world turned upside down.",0.022222222222222213,forth
141qm6g,jnn6m4u,"I remember playing with Forth and Haskell, and boy was my whole world turned upside down.",0.022222222222222213,haskell
141qm6g,jnn6m4u,"I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,rust
141qm6g,jnn6m4u,"I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,c++
141qm6g,jnn6m4u,"I still remember the joy when Mutable XOR Aliasing kicked in, and how it helped me better structure (and debug) my C++ code afterwards.",0.65,c++
141qm6g,jnn6m4u,"Before Rust, I would sometimes have a ""gut feeling"" that a piece of code may be trouble, and I would try to think of various execution paths to see if any would be problematic... and when I couldn't find any, I'd leave with a dread feeling in my guts, not quite convinced it was alright, and quite afraid it would still blow-up in my face one day.",-0.26666666666666666,rust
141qm6g,jnn6m4u,"All of this doesn't mean you should absolutely learn Rust, that you're not a good programmer if you don't, or anything like that.",-0.15416666666666665,rust
141qm6g,jnn6m4u,"It just means that learning Rust may require more effort than learning another language more similar to what you're used to, and that you won't get any benefit if you don't stick long enough for the concepts to click.",0.19,rust
141qm6g,jnrmyfj,"I had not realized that the non-escaping coroutines was essential to the scheme, and I now understand better indeed.",0.25,scheme
141qm6g,jn38ofk,"I think the point is that in C++ you can't just write a function that would blow the stack without TCO, as the compiler is free to just not do it (and probably won't in a debug build, even if it would in release).",0.4,c++
141qm6g,jn38ofk,"So it can only be treated as a possible optimization that might make some programs faster, but not as free rein to write C++ as if it was a functional language.",0.13333333333333333,c++
141qm6g,jno6e5v,"I'll probably never talk about rust ever again and this response is a perfect example of why I don't like talking about it  > Hard to judge without an example, but I would say you did something wrong.",0.06944444444444442,rust
141qm6g,jno6e5v,"Go ahead, tell me what I did wrong.",-0.5,go
141qm6g,jno6e5v,Painful  > > I'm very tired of hearing people think this is the reason and given up saying anything about rust.,-0.61,rust
141qm6g,jno6e5v,Go ahead and tell me why my code is wrong.,-0.5,go
141qm6g,jno6e5v,Also deadlocking in singlethreaded is a problem only in rust.,0.0,rust
141qm6g,jno6e5v,"> I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,rust
141qm6g,jno6e5v,"> I had less issues with Rust, since coming from C++ ownership was a known concept, and borrowing was already a source of trouble.",-0.18333333333333335,c++
141qm6g,jno6e5v,"Before thinking I might have no idea what I'm talking about feel free to try out my compiler and reproduce my build speed https://bolinlang.com/ There's likely no way a person can get that kind of performance without knowing what their doing  > All of this doesn't mean  So many words and it doesn't seem like you ever thought maybe a person has no issues with manual memory management, C++ code and has valid reasons not to like rust  In the article graydon says ""Performance: A lot of people in the Rust community think ""zero cost abstraction"" is a core promise of the language.""",0.2375,c++
141qm6g,jno6e5v,"Before thinking I might have no idea what I'm talking about feel free to try out my compiler and reproduce my build speed https://bolinlang.com/ There's likely no way a person can get that kind of performance without knowing what their doing  > All of this doesn't mean  So many words and it doesn't seem like you ever thought maybe a person has no issues with manual memory management, C++ code and has valid reasons not to like rust  In the article graydon says ""Performance: A lot of people in the Rust community think ""zero cost abstraction"" is a core promise of the language.""",0.2375,rust
141qm6g,jno6e5v,One thing I will never understand is why people think rust is zero cost when you can't turn off runtime array bounds checking and forced to have lock with writing to global objects.,-0.15000000000000002,rust
141qm6g,jno6e5v,As I said earlier I think rust isn't fast.,0.1,rust
141qm6g,jno6e5v,But I think the C and C++ standard library has 'ok' performance in some areas and slow in others.,0.06666666666666665,c
141qm6g,jno6e5v,But I think the C and C++ standard library has 'ok' performance in some areas and slow in others.,0.06666666666666665,c++
141qm6g,jno6e5v,Here's my language beating C in one area and C++ was painfully slow here https://bolinlang.com/more_optimal_standard  Since you brought up understanding how to write code multiple times I'll bring up for the third time that you should tell me what's wrong with the code in my example.,-0.2,c
141qm6g,jno6e5v,Here's my language beating C in one area and C++ was painfully slow here https://bolinlang.com/more_optimal_standard  Since you brought up understanding how to write code multiple times I'll bring up for the third time that you should tell me what's wrong with the code in my example.,-0.2,c++
141qm6g,jno6e5v,It's common everyday code and AFAIK no language but rust has that problem.,-0.25,rust
141qm6g,jnoeq4x,"> Go ahead, tell me what I did wrong.",-0.5,go
141qm6g,jnz8qel,I know that languages like Python and Go don't do it because they are determined to have intact stack traces for debugging.,0.0,python
141qm6g,jnz8qel,I know that languages like Python and Go don't do it because they are determined to have intact stack traces for debugging.,0.0,go
141qm6g,jnz8qel,But for C++ that sort of thing wouldn't be a priority...,0.0,c++
141qm6g,jnohhc7,Go ahead.,0.0,go
141qm6g,jnohhc7,But let it be known that my codegen+runtime executes significantly faster than code rust generates and my compiler is over 150x faster while doing things rust doesn't (such as detect if array bounds access is safe and error out when it doesn't know),0.2916666666666667,rust
141qm6g,jyldotb,"So if you have a loop header A invoking an iterator B that yields values to a loop body C, you get A calls B with the pointer-to-C, and B calls C for each step, just as if you'd passed a lambda / closure as C.  But there are details that differ:    * C can't escape, so you get the lifetime nesting of everything that you expect.",0.0,c
141qm6g,jyldotb,"* The variable-environment of C is extends the frame of A, so a frame-pointer from A is passed to B, and then back to C to run in, so variables in the loop body live across multiple calls back from B to C. The calls from B to C extend the _stack_ pointer of B with register spills and reloads (extending B's frame) but use the _frame_ pointer from A-and-C to find the environment for C.   * There's a loop-control protocol (continue, break, early-return) encoded in a token passed back and forth.",0.02727272727272727,c
141qm6g,jyldotb,"* The variable-environment of C is extends the frame of A, so a frame-pointer from A is passed to B, and then back to C to run in, so variables in the loop body live across multiple calls back from B to C. The calls from B to C extend the _stack_ pointer of B with register spills and reloads (extending B's frame) but use the _frame_ pointer from A-and-C to find the environment for C.   * There's a loop-control protocol (continue, break, early-return) encoded in a token passed back and forth.",0.02727272727272727,forth
141qm6g,jyldotb,"I think a similar translation scheme exists in the C++ coroutine stuff that's in LLVM now, but I haven't looked at the exact details.",0.125,scheme
141qm6g,jyldotb,"I think a similar translation scheme exists in the C++ coroutine stuff that's in LLVM now, but I haven't looked at the exact details.",0.125,c++
141qm6g,jyldotb,"Oh one final note: in early rust what I'm calling ""yield"" here was called ""put"" and so if you're foolish enough to dig into the old code, you want to look for the translations of ""put"" constructs.",0.05,rust
141mbnr,jn0wyot,"""Array languages"" like APL and its descendants can also be understood that way.",0.0,apl
141mbnr,jn0xqmr,Cons (f x) xs)  You essentially define what to do for a given constructor and the recursion scheme (with church encodings the construction of the type itself) handles the recursion for you.,0.0,scheme
141mbnr,jn0zk0b,"That said, I feel like you would run into practical problems as far as implementation goes - recursion in a language like Haskell mainly ""works"" (is efficient and reasonable for large inputs) because Haskell is able to optimize tail recursion so as to avoid stack overflows or ballooning memory requirements.",0.2361904761904762,haskell
141mbnr,jn0zk0b,I would recommend looking at a language like Python and trying to write a meaningful program only using those higher order functions (or perhaps a few more you implement yourself) and seeing how far you can get.,0.19166666666666668,python
141mbnr,jn1fox9,APL?,0.0,apl
141mbnr,jn1fox9,-   wikipedia https://en.wikipedia.org/wiki/APL_(programming_language)   try APL https://tryapl.org/,0.0,apl
141mbnr,jnds98h,"In Python you can write:      def makeRecursive(f):         return lambda args: f(f, args)          @makeRecursive     def factorial(alsoFactorial, n):         return 1 if n == 1 else n * alsoFactorial(alsoFactorial, n-1)      assert factorial(6) == 720  There is also a paper on why fold is awesome, but I haven't read it: http://www.cs.nott.ac.uk/~pszgmh/fold.pdf",1.0,python
141mbnr,jn3yk59,"To more-directly answer your question, you don't need any built higher order functions if you go the untyped route.",0.25,go
141mbnr,jn0vzqd,Usually with a recursion scheme.,-0.25,scheme
141mbnr,jn1hila,"If you like JavaScript, I wrote about implementing the “Mockingbird” in JS—plus some related combinators—here:  http://raganwald.com/2018/08/30/to-grok-a-mockingbird.html",0.0,javascript
141m6a4,jn0w2oy,"I like the Python variant of this - when you have several strings after each other in the code, they get concatenated to a single string.",-0.06547619047619048,python
141m6a4,jn0w2oy,"I'd also ask myself if generic interpolation makes sense - I've found the ""choose when to interpolate"" from Python (prefix to activate interpolation, allow strings to be either single or double quote delimited) to be slightly better than the ""Default to interpolation with need to escape, use single quotes to avoid it"" from Perl/Ruby/Shell.",0.07142857142857144,python
141m6a4,jn1fa0u,What about just escaping the line break like you do in C?,0.0,c
141m6a4,jn1fa0u,And it will be familiar syntax to anyone who ever wrote a non-trivial macro in C xD,0.375,c
141m6a4,jn0tal2,"80 columns is probably too limited today, but you probably shouldn't go past ~128 if you want 2 editors side-by-side and be able to read everything.",0.059523809523809534,go
141m6a4,jn22xkd,"But if I learned anything at all from PHP, it's that you shouldn't mix large literal binary or text data into your programming language.",0.21428571428571427,php
141m6a4,jn22xkd,"Whatever fills in the template can be responsible for formatting stuff as HTML, or the correct number of digits after the region-specific decimal separator, etc.",0.2,html
141m6a4,jn1afp8,Reminds me the fond days of sed regexps going through bash tokenizer.,0.0,bash
141m6a4,jn1afp8,I'd rather have whatever python is doing with string prefixes for everything else.,0.0,python
141m6a4,jn1ly88,"Of course, that’s probably still a pain for noncommittal or quick-and-dirty coding, so I’d recommend introducing some way to break literals over lines anyhow, like another commenter’s recommendation of Python-style implicit concatenation, or perhaps some kind of facility for removing *isolated* newlines from within a string to make representing multi-line text that may also have overly long lines simple.",0.18333333333333332,d
141m6a4,jn1ys1m,"I like the way that Python does this: you can enclose multiple string literals (without commas in between them) in parentheses to create a single string literal, ex:      x = (         ""this is a long string""         ""literal broken across many lines""         ""goodbye""     )      y = ""this is a long stringliteral broken across many linesgoodbye""      assert x == y  In its absence, languages that support compile-time macros like Rust also have an easy way of doing this:      let x: &'static str = concat!",0.027033730158730156,python
141m6a4,jn1ys1m,"I like the way that Python does this: you can enclose multiple string literals (without commas in between them) in parentheses to create a single string literal, ex:      x = (         ""this is a long string""         ""literal broken across many lines""         ""goodbye""     )      y = ""this is a long stringliteral broken across many linesgoodbye""      assert x == y  In its absence, languages that support compile-time macros like Rust also have an easy way of doing this:      let x: &'static str = concat!",0.027033730158730156,rust
141m6a4,jn2wam8,"That said, regarding breaking up strings: you can make up a syntax for that, like adjacent C strings concatenating together or JS' backslash, or, even simpler, you can make a semantic guarantee that manual concatenation of literals is done at compile-time.",0.0,c
141m6a4,jn210pj,Just one voice of opposition: The implicit concatenation of Python has been a source of weird bugs for me.,-0.5,python
141m6a4,jndv751,"80 chars come from punched cards used for Fortran programs etc, and at that time nobody thought of CRT terminals.",0.0,fortran
141m6a4,jn2cegl,Something like Go's template library should solve this.,0.0,go
141m6a4,jn3izlw,"Was just about to say go templates, that way it could be introduced as a new feature and also more powerful and most importantly separate concern from simple string interpolation including some built-in funcs etc.",0.3060606060606061,go
141m6a4,jn4qb7q,"ahaha :D It was just an opinion of mine, no annoyance intended.",1.0,d
141m6a4,jn0u6kg,"I would definitely go for the factory solution, but that's just my personal preference.",0.0,go
141dvnb,,Labels are identical to those found in an assembly language of the form `label: statement`.,0.0,assembly
141dvnb,jn1x4st,Can we assume you've read [Structured Programming with go to Statements](https://dl.acm.org/doi/10.1145/356635.356640)?,0.0,go
1414ryo,,"A big reason why newer programming languages aren’t used in industry is because of the sheer amount of existing libraries and resources that already exist for it; for example, ML models are currently mainly built in Python because of the existence of libraries like numpy and pytorch, even though Python may not be the most efficient language for the task.",0.16666666666666666,python
1414ryo,,"I am wondering if there is any research on allowing multiple languages to be used in a *single* program such that, for example, a project can mainly be coded in a newer language but it can also have a bit of python code in it to use a python library.",0.023809523809523808,python
1414ryo,jmykhzd,"Google's Carbon is compatible with C++, and allows C++ to be inlined with Carbon.",0.0,c++
1414ryo,jmykhzd,"D is (mostly) a superset of C.  C can frequently be compiled as D.  Also, D can call gluelessly into (most) C libraries.",0.3666666666666667,d
1414ryo,jmykhzd,"D is (mostly) a superset of C.  C can frequently be compiled as D.  Also, D can call gluelessly into (most) C libraries.",0.3666666666666667,c
1414ryo,jmykhzd,"Perl has a bunch of Inline:: modules, allowing other languages to be used within perl scripts.",-0.125,perl
1414ryo,jmyo0xm,"There are attempts to have a ""common runtime"", like the Java and dotnet virtual machines, but these are very opinionated and are a poor fit for many languages.",0.08,java
1414ryo,jmyrvkn,"Well, HTML5 allows you to mix CSS (called ""inline CSS""), HTML and JavaScript in a single file, although it is discouraged.",-0.07142857142857142,html
1414ryo,jmyrvkn,"Well, HTML5 allows you to mix CSS (called ""inline CSS""), HTML and JavaScript in a single file, although it is discouraged.",-0.07142857142857142,javascript
1414ryo,jmyukpd,"EDIT: Also, the old [Arity/Prolog32](http://petergabel.info/ArityProlog32/ArityProlog32/) Prolog compiler allowed users to combine C and Prolog code in the same file, albeit the C code was limited in nature.",0.009523809523809526,prolog
1414ryo,jmyukpd,"EDIT: Also, the old [Arity/Prolog32](http://petergabel.info/ArityProlog32/ArityProlog32/) Prolog compiler allowed users to combine C and Prolog code in the same file, albeit the C code was limited in nature.",0.009523809523809526,c
1414ryo,jmz6r5x,I actually did a toy project that mixed python and c++.,0.0,python
1414ryo,jmz6r5x,I actually did a toy project that mixed python and c++.,0.0,c++
1414ryo,jmz6r5x,You could even embed python into a cpp file.,0.0,python
1414ryo,jmz6r5x,"You could use python for compile time logic and some code-gen stuff (makinging it a more versatile way of making complicated macros, python macros that expand into c++).",0.0,python
1414ryo,jmz6r5x,"You could use python for compile time logic and some code-gen stuff (makinging it a more versatile way of making complicated macros, python macros that expand into c++).",0.0,c++
1414ryo,jmz6r5x,No tooling is prepared for multi language source files (other than html&js).,-0.125,html
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,lisp
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,scheme
1414ryo,jmz81m3,"Common Lisp and some other Lisp languages (such as some Scheme implementations that go beyond the Scheme standard) have a feature called **reader macros**, which could be used to mix syntaxes within a single file.",-0.09928571428571428,go
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,java
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,python
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,javascript
1414ryo,jmzznhh,"Check out Shark and SharkG, they can both compile to and use any library from C/C++, Java, Python, JavaScript and Lua, in both statically typed (SharkG) or dynamic (Shark) ways.",0.0,lua
1414ryo,jn04rjh,"I don't know about _research_, but we did have a component based development environment in the '97 timeframe, built in Java, that did enable different languages to be used to build software, specifiable down to the method level.",-0.07777777777777779,java
1414ryo,jn04rjh,"In other words, the same class could have one method written in Java, another in BASIC, and another in JavaScript -- not that that was the goal.",-0.041666666666666664,java
1414ryo,jn04rjh,"In other words, the same class could have one method written in Java, another in BASIC, and another in JavaScript -- not that that was the goal.",-0.041666666666666664,javascript
1414ryo,jmyx0mc,Html,0.0,html
1414ryo,jmyvffa,"Just look at nodejs, why on earth did that get from a cool project to production?",0.35,cool
1414ryo,jmzyb1g,"In Node, you could call child_process.exec and run your python code and store the returned output in a variable.",0.0,python
1414ryo,jmzyb1g,You could use shell piping to orchestrate data flows across multiple languages.,0.0,shell
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,python
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,c
1414ryo,jmzyb1g,Lots of popular python libraries are C or Fortran with python bindings.,0.6,fortran
1414ryo,jn010bw,"Some languages, like D, also allow you to literally [mark a class as COM](https://dlang.org/spec/interface.html#com-interfaces) and all instances will be callable from other binaries in different languages, without any kind of C FFI.",0.15833333333333333,d
1414ryo,jn010bw,"Some languages, like D, also allow you to literally [mark a class as COM](https://dlang.org/spec/interface.html#com-interfaces) and all instances will be callable from other binaries in different languages, without any kind of C FFI.",0.15833333333333333,c
1414ryo,jn0q9a4,by writing some extensions in C or by using [FixNative](https://www.fixscript.org/docs/native/) or other libraries).,-0.125,c
1414ryo,jn0q9a4,"While I'm not sure how much such language mixing is useful, there are enough of real world examples where it turned out just fine (PHP, SQL, HTML, regexps, etc.)",0.11111111111111112,php
1414ryo,jn0q9a4,"While I'm not sure how much such language mixing is useful, there are enough of real world examples where it turned out just fine (PHP, SQL, HTML, regexps, etc.)",0.11111111111111112,html
1414ryo,jn0v9mz,"> mainly built in Python because of the existence of libraries like numpy and pytorch, even though Python may not be the most efficient language for the task.",0.3333333333333333,python
1414ryo,jn0v9mz,"> I am wondering if there is any research on allowing multiple languages to be used in a single program such that, for example, a project can mainly be coded in a newer language but it can also have a bit of python code in it to use a python library.",0.023809523809523808,python
1414ryo,jn0v9mz,A PHP or ASP file is designed to contain HTML portions.,0.0,php
1414ryo,jn0v9mz,A PHP or ASP file is designed to contain HTML portions.,0.0,html
1414ryo,jn0v9mz,Those HTML portions are designed to contain JavaScript and CSS portions.,0.0,html
1414ryo,jn0v9mz,Those HTML portions are designed to contain JavaScript and CSS portions.,0.0,javascript
1414ryo,jn0v9mz,The biggest issue (aside from the attention required to not make subtle mistakes when you're switching between languages several times in a file) is that handing data or control back and forth between languages can be tricky.,-0.1111111111111111,forth
1414ryo,jn0v9mz,"For example, JavaScript has both ""null"" and ""undefined"", a distinction that may be lost when handing data back and forth with another language.",0.0,javascript
1414ryo,jn0v9mz,"For example, JavaScript has both ""null"" and ""undefined"", a distinction that may be lost when handing data back and forth with another language.",0.0,forth
1414ryo,jn29d10,"Related paper:  https://tratt.net/laurie/blog/2016/fine_grained_language_composition.html  https://soft-dev.org/pubs/html/barrett_bolz_diekmann_tratt__fine_grained_language_composition/  ---  As an example of syntax, you can switch from Bourne-compatible shell to the new YSH dialect in https://www.oilshell.org/      #!/bin/sh      echo 'hi bourne shell ' >&2      shopt --set ysh:upgrade  # shell is parsed line-by-line, and this changes a parsing mode!",0.1065340909090909,shell
1414ryo,jn29d10,"cd /tmp {        echo 'this kind of block is not allowed in bourne shell'      }  This isn't the recommended way to change from OSH to YSH, but it's possible!",0.3,shell
1414ryo,jn29d10,In shell you can always compose multiple languages with here docs too.,0.0,shell
1414ryo,jmyumnb,Don't forget the [inline-java](https://github.com/tweag/inline-java) package for Haskell.,0.0,haskell
1414ryo,jmztemv,- embedding gpu shader code and engine code in a single file - or really any form of heterogeneous computing for that matter - inline assembly where performance or other details matter - which you could generalize as needing an escape hatch out of any higher level language (not just limited to software) - html and js interop (more or less jsx),0.07363945578231293,assembly
1414ryo,jmztemv,- embedding gpu shader code and engine code in a single file - or really any form of heterogeneous computing for that matter - inline assembly where performance or other details matter - which you could generalize as needing an escape hatch out of any higher level language (not just limited to software) - html and js interop (more or less jsx),0.07363945578231293,html
1414ryo,jn6amot,Making the language X which can embed Y Z A B C D E is already quite a feat.,0.0,c
1414ryo,jn6amot,Making the language X which can embed Y Z A B C D E is already quite a feat.,0.0,d
1414ryo,jn6amot,"Like if you come up with Gunkface, a language capable of embedding Python, the Python Software Foundation is *not* going to adjust itself to make sure it can embed Gunkface.",0.35,python
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,haskell
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,c
1414ryo,jmz6fie,"Haskell also has ""inline"" packages for [C](https://hackage.haskell.org/package/inline-c) and C++ which are very convenient.",0.2,c++
1414ryo,jmz6fie,"And I think Javascript and a few other languages as well, though I might be misremembering.",-0.1625,javascript
1414ryo,jn13hh1,"It might sound like I'm clutching at straws here, but there are certainly languages with `|]`, such as OCaml and F# which use them for array literals, but also, Haskell itself, which uses it for quasiquotes.",0.20476190476190478,haskell
1414ryo,jn13hh1,Can you embed a quasiquote in haskell embedded in a quasiquote in haskell?,0.0,haskell
1414ryo,jmyx17g,"It has a very opinionated architecture, like Java, in that everything is an object.",0.2,java
1414ryo,jmyx17g,There's no Haskell for .NET for example (it was attempted and abandoned).,0.0,haskell
1414ryo,jmz7jj6,"I have never written any Kernel (I have heard of it though), and I have a few questions as someone who writes quite a bit of Scheme.",-0.2,scheme
1414ryo,jmz7jj6,All of what you said about environments here seems to also be true in Scheme.,0.35,scheme
1414ryo,jmz7jj6,Is the environment system very different from Scheme?,0.0,scheme
1414ryo,jn0glw0,Not a problem in Scheme either.,0.0,scheme
1414ryo,jn0glw0,"Now try to add `and` and `or` to it, and you see a problem: These are not first-class procedures in Scheme, they're second-class, because they do short-circuiting evaluation.",0.0,scheme
1414ryo,jn0glw0,"(This exact problem is what led me to Kernel in the first place: I was writing an interpreter in Scheme and came across several awkward points like this, before I found Kernel and everything seemed much more intuitive to me).",0.08,scheme
1414ryo,jn0glw0,I consider the Kernel approach to be the duel of the Scheme approach.,0.0,scheme
1414ryo,jn0glw0,"In Scheme, everything is implicitly evaluated, unless explicitly quoted.",0.0,scheme
1414ryo,jn0glw0,> All of what you said about environments here seems to also be true in Scheme.,0.35,scheme
1414ryo,jn0glw0,Is the environment system very different from Scheme?,0.0,scheme
1414ryo,jn0glw0,"There are limitations on how you can create your own environments in Scheme, but almost none in Kernel.",0.6,scheme
1414ryo,jn0glw0,Scheme environments are middle-class.,0.0,scheme
140s7im,,"``` fn main(arg: type): result_type @event {} ```  ## Function Calls & Statements They're a lot like what they are in Java, C, etc.",0.0,java
140s7im,,"``` fn main(arg: type): result_type @event {} ```  ## Function Calls & Statements They're a lot like what they are in Java, C, etc.",0.0,c
140s7im,,"I don't think this can replace Java for Minecraft servers, but it should have it's own little niche where it can support both high-level and low-level control.",0.20625,java
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,javascript
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,rust
140s7im,,"Another reason I styled it the way it is, is because I'm mostly getting inspiration from JavaScript, Rust, and Python.",0.5,python
140s7im,,"I don't want a lot of boilerplate in this, so no nonsense like `function my_function(a: b) -> c` when it could be expressed in less.",0.16111111111111112,c
140s7im,,"However, I don't want to go as far as a language like Haskell - it should be easily readable without problem to most C-style developers.",0.3444444444444444,go
140s7im,,"However, I don't want to go as far as a language like Haskell - it should be easily readable without problem to most C-style developers.",0.3444444444444444,haskell
140s7im,,I also don't like Java's verbosity - it's nice while debugging but it's painful to write without IDE tooling (which I don't always have access to).,-0.04999999999999999,java
140s7im,,"And currently, it's hard for new people to get into the Spigot realm - most people dive in without knowing any Java, so giving them some language that can fit inbetween the realms of Skript's englishness and Java's verbosity would be nice.",0.2689393939393939,java
140s7im,,"## Example So, for example, here's a simple Hello World in Java.",0.0,java
140s7im,,"This allows this language to (hopefully) be **extremely** fast (speed is one of my priorities for this) using a bytecode interpreter and it's in Rust instead of Java, which should be a nice little speedup.",0.2041666666666667,rust
140s7im,,"This allows this language to (hopefully) be **extremely** fast (speed is one of my priorities for this) using a bytecode interpreter and it's in Rust instead of Java, which should be a nice little speedup.",0.2041666666666667,java
140s7im,jn0anwd,"## Programming Style  Be consistent in your approach, and avoid mixing syntax patterns (i.e., variable definition: `Type identifier = expr` in C family languages).",0.25,c
140s7im,jn0anwd,"You could aim to make your language more like Python, JS.",0.5,python
140s7im,jmz3spc,I’ll go more into depth later.,0.25,go
140s7im,jn0c2ce,"My personal preferences are Ballerina, Python, or Go.",0.0,python
140s7im,jn0c2ce,"My personal preferences are Ballerina, Python, or Go.",0.0,go
140s7im,jn16wv0,"I decided to change it around a bit and line it up a bit closer to JavaScript, which was my original goal, something like JS but with some nice changes and less verbose (although verbosity is opt-in-able if you like, stuff like types).",0.26944444444444443,javascript
140s7im,jn16wv0,I'm gonna implement it over Valence Framework in Rust ([https://github.com/valence-rs/valence](https://github.com/valence-rs/valence)) so it can go fast and have both low-level and high-level control.,0.2,rust
140s7im,jn16wv0,I'm gonna implement it over Valence Framework in Rust ([https://github.com/valence-rs/valence](https://github.com/valence-rs/valence)) so it can go fast and have both low-level and high-level control.,0.2,go
140hy0r,jmvxlyh,Our LLVM backend is still under development and has a long way to go.,-0.05,go
140hy0r,jmw9656,"It teaches Scheme bit by bit, building up to implementing a metacircular evaluator for the same language.",0.0,scheme
140hy0r,jmw9656,"If you were going to go through all 4, I would probably recommend them in this order: SICP (videos), EoC, CI Dragon book.",0.0,go
140hy0r,jmyfwc4,"If you've ever programmed a (tree walking) interpreter yourself and really felt like comfortable, I think all you need to learn is something called SSA form and you're good to go, when wanting to write a proper compiler.. everything else just falls into place.",0.325,go
140hy0r,jmyldu3,This way you will learn to build a frontend with CLox and a backend by trying to adapt your existing backend to produce actual assembly.,0.0,assembly
13zzzfc,,"If you were to build an opinionated formatter like `gofmt` or `prettier` for a non-braced language like Python, how would you format it?",0.0,python
13zzzfc,jmujnoj,"If you say python like, you don't mean indentation based, right?",-0.01339285714285715,python
13zzzfc,jmujnoj,"Because in python a lot of your examples wouldn't be valid since you can't introduce newlines anywhere you want (without explicit `\`), specifically because it gets harder to parse for humans (and to a lesser extend computers).",-0.05,python
13zzzfc,jmujnoj,In python I would probably write this as  ``` if (     condition_1     and condition_1     and condition_1 ):     body_1 elif (     condition_2     and condition_2 ):     body_2 ```  Although I don't actually know what black would do.,-0.08333333333333333,python
13zzzfc,jmttv9r,Python has `elif`.,0.0,python
13zzzfc,jmtvkct,Actually this made me think of a \`branch\` structure like this:  ``` branch      <some_very_long_condition>     and <some_very_long_condition>     and <some_very_long_condition>     or <some_very_long_condition>     then          <statement>         <statement>         <statement>      <condition> and <condition>     then          <statement>         <statement>      (<condition> and <condition>)     and (         <some_very_long_condition>         or <some_very_long_condition>     )     then          <statement>         <statement> ```  Which is a glorified JavaScript's `switch (true)\,0.0,javascript
13zzzfc,jmtwdvs,"`cond` comes from LISP, 1958.",0.0,lisp
13zzzfc,jmvizir,Python also has a match/case system now: structural pattern matching.,0.0,python
13ztlms,jmswmat,"I like the fact that it jokes about rust's name shadowing and also JavaScript's quirkiness, it's kinda funny, also this language would strangely be usable unlike other esoteric programming languages",0.025000000000000005,rust
13ztlms,jmswmat,"I like the fact that it jokes about rust's name shadowing and also JavaScript's quirkiness, it's kinda funny, also this language would strangely be usable unlike other esoteric programming languages",0.025000000000000005,javascript
13ztlms,jmtw1rd,"Maybe I drank too much white wine last night, but having float indexes as a way to implicitely insert values in an array sounds kind of cool 🤔",0.2375,cool
13ztlms,jmv709g,> ❌ Rust Foundation (owned by the DreamBerd Foundation - please consider renaming)  This might be the best thing I've read all day,1.0,rust
13ztlms,jx0zexx,"toadpond, i once discovered your programming language DreamBerd (now renamed to C, probably to abide by the naming laws) on a youtube short, and then I red through the documentation laughing my ass off the hilarius and implausible ideas, and I am asking, will it be OK if I make a meme programming language inspired by DreamBerd?",0.16666666666666666,c
13ztlms,jmuiwe4,Currently dealing with an existing codebase that does that *in python*.,0.0,python
13ztlms,jmuiwe4,"In Java at least there's the excuse the specification ""simply"" required absolutely everything to be in a Class because it was the 90s and OO was cool.",0.04,java
13ztlms,jmuiwe4,"In Java at least there's the excuse the specification ""simply"" required absolutely everything to be in a Class because it was the 90s and OO was cool.",0.04,cool
13ztlms,jmtcqjj,"You're drunk, but you're at the bar in good company with C++ `friend`s",0.09999999999999998,c++
13ztlms,jn2mis5,"I'm not sure exactly how useful this is, but I think you might be interested in Parsing Expression Grammars (PEGs) (such as [LPEG](http://www.inf.puc-rio.br/~roberto/docs/peg.pdf) in Lua) and perhaps [Abstract Syntax Definition Languages](https://eli.thegreenplace.net/2014/06/04/using-asdl-to-describe-asts-in-compilers) (ASDLs) as potential source of inspiration for Language Language if you weren't already aware of them.",0.1142857142857143,lua
13ztlms,jmvzqin,"This is valid Perl to print  foo   bar      $x = foo;     print $x, ""\n"";          sub foo() {         bar     }     $y = foo;     print $y",0.0,perl
13ztlms,jp160mr,https://www.mcmillen.dev/sigbovik/  93% of Paint Splatters are Valid Perl Programs,0.0,perl
13zjq3y,,Our approach was greatly influenced by Java because at that time Ballerina was initially a JVM-based interpreted language.,0.4,java
13zh58i,jmrc873,Haskell lists are extremely efficient for that so there's no need for a special abstraction.,0.11607142857142858,haskell
13zezki,jmxqomx,"You might give [PLT redex](https://redex.racket-lang.org/) a go, and there's an associated book, ""Semantics Engineering with PLT redex""",0.0,go
13zezki,jmzmdyh,:D Thanks for the link.,0.6,d
13zcm5i,,Needing some way to tie those `t`s to the element type of the array I thought about adding a language feature to annotate the type of a function either at the top-level (like Haskell) or inline (like OCaml).,0.0,haskell
13zcm5i,,"So the `capacity_of` function takes the length of an array and rounds it up to the next power of two:        let capacity_of n =         if n=0 then 0 else Int.next_pow_two(n-1)  Now the `resize` function appends `dn` elements onto the end of `a` in-place using C's `realloc`:        let resize(a, dn) =         let n2 = length a + dn in         Array(n2, C.realloc(ptr a, capacity_of n2 * size_of t))  Even if I added a `realloc` instrinsic there's still no way to tie the type of the input array to the type of the output array in my language today.",0.0,c
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,c
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,c++
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,java
13zcm5i,jmr6a3h,"Arrays are built in to C, C++, C#, Java, JavaScript, etc.",0.0,javascript
13zcm5i,jmr3oqy,"An example is the Haskell [ListLike](https://hackage.haskell.org/package/ListLike-4.7.8/docs/Data-ListLike.html) class, which provides generic operations over types which behave like lists.",0.0,haskell
13zcm5i,jmrc0ky,"(Like C#'s indexer properties for example)  Similarly, Lists in Haskell are given special treatment, but are not very special.",0.07326007326007326,c
13zcm5i,jmrc0ky,"(Like C#'s indexer properties for example)  Similarly, Lists in Haskell are given special treatment, but are not very special.",0.07326007326007326,haskell
13zcm5i,jmvwb87,> Arrays are built in to C  I wouldn't say that C has proper array support.,0.0,c
13zcm5i,jmvwb87,This is actually one of the biggest complaints I hear from C programmers.,0.0,c
13zcm5i,jmsl8qe,"JavaScript's built in array type supports the stack protocol, so it's both.",0.0,javascript
13zcm5i,jmsl8qe,"Since arrays are growable in JavaScript (which you need for them to support being used as stacks), the internal representation of an array has an indirection.",0.0,javascript
13zcm5i,jmsl8qe,A reference to a JavaScript array is a reference to a reference to an allocated block of memory.,0.0,javascript
13zcm5i,jmsl8qe,"If you have fixed-sized arrays as your primitive (like C, Java, and C#), then you can avoid that double indirection in places where you know you don't need to be able to grow the array.",0.25,c
13zcm5i,jmsl8qe,"If you have fixed-sized arrays as your primitive (like C, Java, and C#), then you can avoid that double indirection in places where you know you don't need to be able to grow the array.",0.25,java
13zcm5i,jmsl8qe,(Like C#'s indexer properties for example)  The syntax is an orthogonal question.,0.0,c
13zcm5i,jmw68fz,"Array decay is certainly annoying, but C absolutely has arrays built into the language as a fundamental construct.",-0.30000000000000004,c
13zcm5i,jmt74ci,"Even indexer properties in C# are not completely first-class, because you can't specify `x[N]` where `x` is a polymorphic variable over all types which support indexing.",-0.05,c
13zcm5i,jmt74ci,"If you throw away the indexer property and just have methods, then these can be treated exactly the same as any other method - they're first-class, and you can separate out the setter and getter, which you can't do in C# because of the limitation of properties (which are second-class).",0.041666666666666664,c
13zcm5i,jmt74ci,"let peek collection index = collection[index]      f peek c  A first-class solution is to have operators and methods be interchangeable with syntax, as Haskell does.",0.0,c
13zcm5i,jmt74ci,"let peek collection index = collection[index]      f peek c  A first-class solution is to have operators and methods be interchangeable with syntax, as Haskell does.",0.0,haskell
13zcm5i,jmt74ci,"c  Indexed mutation is tricker with operator syntax because it's not a binary operator, it's ternary.",0.0,c
13zcm5i,jmt74ci,"There are languages like Agda which support mixfix operators which can be treated as first-class functions, so an idealized solution for polymorphic indexing might look something like:      class Peekable t index where         _[_] :: ∀elem => t -> index -> elem      class Pokeable t index where         _[_]_:=_ :: ∀elem => t -> index -> elem -> ()      instance Peekable Array Int where         x[i] = #internal_implemention(array_get_index(x, i))#      instance Pokeable Array Int where         x[i]:=a = #internal_implementation(array_set_index(x, i, a))#  And back to calling `f`, we would then use      f (_[_]) c  And regular indexing could use syntax most programmers are used to, but this is not limited to arrays.",0.13392857142857142,c
13zcm5i,jmwq34x,"For instance, there's also no size or aliasing information, so C still pales in comparison to languages like FORTRAN, Futhark, Chapel, etc.. when it comes to array support.",0.0,c
13zcm5i,jmwq34x,"For instance, there's also no size or aliasing information, so C still pales in comparison to languages like FORTRAN, Futhark, Chapel, etc.. when it comes to array support.",0.0,fortran
13y6nol,,"The stage 1 uses C as backend, as input to gcc.",0.0,c
13y6nol,,Should my stage 2 mainly target LLVM or C?,0.16666666666666666,c
13y6nol,,"But it's also known to be slow at compiling, also with `-O0`, while C has tcc which would speed up my c-to-exe step.",-0.30000000000000004,c
13y6nol,,Also targetting C would keep the ability to get my executable as optimized as the LLVM one.,0.0,c
13y6nol,,Now a couple of questions: * if targetting C: are all those string manipulations going to slow down my compilation anyway?,-0.2277777777777778,c
13y6nol,jmlf2sx,"LLVM also does not help you implement the C ABI, nor a lot of other things you get for free lowering to C. It does give you control, but that control often means you have to do a bunch of research in order to implement it right.",0.1869047619047619,c
13y6nol,jmlf2sx,"Several projects using LLVM later ends up eyeing other options (Rust, Zig, Odin etc)  Personally my project is using LLVM, so I’ve had to tackle these issues and every time I’ve felt I’m “done” digging into details, I’ve later discovered I was completely wrong.",-0.10416666666666667,rust
13y6nol,jmlf2sx,"On the other hand, it’s great being able to tailor the debug info and not have a dependency on an external C compiler.",0.29375,c
13y6nol,jmlj3wh,>if targetting C: are all those string manipulations going to slow down my compilation anyway  Let's try it with some of my tools.,-0.2277777777777778,c
13y6nol,jmlj3wh,"`mc` is a transpiler that, with `-c`, turns it into a single C source file; oh and `tm` is a timing tool:      c:\qx>tm mm qc     Compiling qc.m---------- to qc.exe     TM: 0.10          c:\qx>tm mc -c qc     M6 Compiling qc.m---------- to qc.c     TM: 0.09          c:\qx>tm mc -tcc qc     M6 Compiling qc.m---------- to qc.exe     W:Invoking C compiler: tcc  -oqc.exe qc.c c:\windows\system32\user32.dll -luser32 c:\windows\system32\kernel32.dll -fdollars-in-identifiers     TM: 0.33  Building directly takes 0.1 seconds; turning it into C source (and it is very busy source of 43,000 lines) is marginally faster.",0.05285714285714286,c
13y6nol,jmlj3wh,But then you need to invoke the C compiler.,0.0,c
13y6nol,jmlj3wh,"Overall the process is slower than a direct build, but 0.3 seconds to build an app like this is still reasonable, compared with:      c:\qx>tm mc -opt qc     M6 Compiling qc.m---------- to qc.exe     W:Invoking C compiler: gcc -m64  -O3 -oqc.exe qc.c -s     TM: 51.09  This invokes `gcc -O3`, and takes 50 seconds.",0.10000000000000002,c
13y6nol,jmlj3wh,"`gcc -O0` takes 6.5 seconds, 25 times as slow as tcc (factoring out the C generation), but the generated code is not much better.",-0.275,c
13y6nol,jmlafpy,It's a bit odd to be stating that LLVM is slower than C when clang is itself powered by LLVM.,-0.16666666666666666,c
13y6nol,jmlooty,"LLVM is notoriously slow, generating c & feeding that through tcc will be faster, & then fallback on llvm codegen for release builds  Alternatively you can roll your own simple x86 backend, which will be much faster than either gcc or llvm  > if targetting C: are all those string manipulations going to slow down my compilation anyway?",0.007407407407407386,c
13y6nol,jmn3zxe,"For my project's C code generator, there is some string manipulation (mostly concatenation, no searching or substring operations on already ""generated"" code - I also use a header and footer template though there is only a few dozen lines in each), BUT this could be (and perhaps should have been) hidden.",0.03333333333333333,c
13y6nol,jmn3zxe,"A way to do this would be to create an AST for the C code and then just ""pretty print"" it to obtain C source code to pass to the C compiler.",0.25,c
13y6nol,jmn3zxe,tcc has been helpful to reduce the time to run my conformance tests but this is mostly because I don't do any kind of separate compilation so I compile my standard library once for each test case and I don't do any parallel building of test cases yet (so I'm using a single core unless the C compiler itself is multi-threaded).,0.20571428571428574,c
13y6nol,jmm3ujr,"I’ve been thinking about targeting C for a long time, and I’ve been drawing up some ideas where based on string length and possibly other heuristics I either use ropey structures (which would be used anyways for incremental compilation via LSP) and use kernel file ops for file appending, and for smaller strings just roll a StringBuilder.",-0.05833333333333333,c
13y6nol,jmm3ujr,"string roping, would be good to take a deep look at V8 JIT internals for how they handle string concat in javascript - a ton of work has gone in to that!",0.35,javascript
13y6nol,jmpuuly,I wonder if I'm the only person here who has a supported llvm and c backend.,0.0,c
13y6nol,jmpuuly,Here's my numbers for an apple M2 with tcc https://bolinlang.com/bolin-is-fast IIRC clang was over half a million (which kicks go's butt)  I suggest sticking to C. I haven't found many places where an optimized llvm build was significantly better than an optimized gcc or clang (llvm with c input) build.,0.2777777777777778,go
13y6nol,jmpuuly,Here's my numbers for an apple M2 with tcc https://bolinlang.com/bolin-is-fast IIRC clang was over half a million (which kicks go's butt)  I suggest sticking to C. I haven't found many places where an optimized llvm build was significantly better than an optimized gcc or clang (llvm with c input) build.,0.2777777777777778,c
13y6nol,jmpuuly,My C generation looks like SSA so I have many variables which doesn't seem to slow down tcc,0.01481481481481479,c
13y6nol,jmlq7z9,[Heres a godbolt link](https://godbolt.org/z/Wvzn9GcKv) demonstrating this approach with some C code.,0.0,c
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,c
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,rust
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,d
13y6nol,jmmamnq,"Another alternative is to target a C ""replacement"" like Rust, D, Zig, Pascal, Odin, etc.",0.0,pascal
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,pascal
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,d
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,assembly
13y6nol,jmmamnq,"(Zig, Pascal, D are probably the ""best"" from the speed of compiler POW)  But I lean now to use web assembly as an intermediate between target C <-> LLVM (not used it myself but in $job is what we are working towards).",1.0,c
13y6nol,jmmamnq,"The *major* advantage is that you can compile Rust and others to small `.wasm` modules, simplifying the bootstrapping and FFI.",-0.09375,rust
13y6nol,jmmp2pf,"> LLVM also does not help you implement the C ABI,  Can you elaborate?",0.5,c
13y6nol,jmmeaft,">On the other hand, it’s great being able to tailor the debug info and not have a dependency on an external C compiler.",0.29375,c
13y6nol,jmmeaft,"On the other hand, the minimal dependency for C is a 1.6MB (not GB) Tiny C installation.",-0.075,c
13y6nol,jmmeaft,"And for the C code I sometimes generate, I only need 2-3 files totalling under 0.25MB.",0.0,c
13y6nol,jmmeaft,"At the user-site, yes, a C installation will be needed.",0.0,c
13y6nol,jmmeaft,"Otherwise, Tiny C is small enough to bundle.",-0.08333333333333333,c
13y6nol,jmlax1r,"> It's a bit odd to be stating that LLVM is slower than C when clang is itself powered by LLVM  C has a lot of compilers (some of them are very fast, for example tcc which is not powered by llvm for sure, and one passes c code).",0.1977777777777778,c
13y6nol,jmlax1r,I doubt most people target it due to its ease of use  i said it's easier (for me) to target then c (all string manipulations are annoying to me).,-0.1416666666666667,c
13y6nol,jmlax1r,"also in c, order of the declarations matters, which makes it even more annoying to target.",-0.15000000000000002,c
13y6nol,jmm28th,"yes ahah, i would use for sure some kind of arena allocation or maybe an array of strings for outputting c, by the way i decided at the end to go for llvm + custom x86native",0.55,c
13y6nol,jmm28th,"yes ahah, i would use for sure some kind of arena allocation or maybe an array of strings for outputting c, by the way i decided at the end to go for llvm + custom x86native",0.55,go
13y6nol,jmm04xj,"thanks, are you suggesting me that to output c i don't need all those string manipulations i thought to?",0.2,c
13y6nol,jmnyvga,how bout  luajit or even better the new  faster luajit that someone https://sillycross.github.io/ these fine folks are working on IDK havent used it in years but lua was the first language I learned luajit for love2d game engine to be exact and I knew then.,0.19217171717171713,lua
13y6nol,jmnyvga,Lua is one of the fastest lightest high level scripting lang there is designed for embedded systems in the mid 90's when they had less juice then your average ant.,-0.03916666666666666,lua
13y6nol,jmnyvga,I kinda want to now I may spend rest of my life writing my own modules and possibly trying to erase luarocks from my mind.Yes btw I KNOW the new luajit or luajr I think is still very much a work in progress as mentioned librarys and a bunch more stuff but I for one would love Lua to be at least on people's mind when there looking at embedded systems.,0.24233766233766232,lua
13y6nol,jmm8cra,CIL is very flexible; you can even do pointer arithmetic; I would say whatever you can do with standard C you can also do with CIL.,0.1,c
13y6nol,jmmtc0w,"Yet, `bcc` is limited in throughput by needing to use intermediate ASM source code (`tcc` is straight to binary in one pass), so there are two lots of lowering to source code, first to C, then to ASM.",0.1261904761904762,c
13y6nol,jmlchby,"I didn't mention gcc in response to anything you've written, but because gcc and clang are the two major C compilers.",0.0625,c
13y6nol,jmmbczg,"what is very cool about cil, compilation speed aside, is the great support for debugging, do you think you can debug also raw memory address errors like `*null` in c?",0.34141025641025635,cool
13y6nol,jmmbczg,"what is very cool about cil, compilation speed aside, is the great support for debugging, do you think you can debug also raw memory address errors like `*null` in c?",0.34141025641025635,c
13y6nol,jmmg0lp,"Which is why my `mc` transpiler product, if it also invokes the C compiler, defaults to gcc; Tcc requires the `-tcc` option.",0.0,c
13y6nol,jmmg0lp,"Because the problem with gcc (I think you found this with LLVM) is that the translation to C is so fast, invoking gcc is like driving into a brick wall.",0.2,c
13y6nol,jmlhhwv,Tiny C runs on ARM too.,0.0,c
13y6nol,jmle1hm,yes probably i will go for llvm + x86 native backend,0.0,go
13y6nol,jmnm664,"However, I'm using a weird and non-standard ABI that is just C compliant enough to let me use all the C runtime and POSIX functions I want to.",-0.25,c
13y6nol,jmw7hf9,Weighing in at just 12.5kLOC of C it is only 0.17% of the 7.3MLOC in LLVM.,0.0,c
13y35a5,jmlvjdj,"Zig is rooted in pragmatism & trying to be a better C, and its main focus is systems programming.",0.3333333333333333,c
13y35a5,jmmcagl,"Is like before Rust, a language that *not* fill (enough!)",0.0,rust
13y35a5,jmmcagl,"So doing a lang you start with was is *very well know first* and then, maybe, you start adding complex things like:  - Type checking - Limited Type inference (hard) - Full Type inference (VERY hard) - Macros (hard) - Good macros (harder) - Generics (even harder) - RC (easy) - Gc (very hard to very very hard) - Novel GC replacements like Rust borrow checking (almost God tier hard until recently?)",-0.040662202380952396,rust
13y35a5,jmnkxbn,"Let me give one reason that confuses me:  C++ template metaprogramming is compile-time code execution, and it is very different from the usual conceptions of dependent types.",-0.125,c++
13y35a5,jmnkxbn,"Macro systems like m4 or the macros of Scheme and Common Lisp can offer compile-time (or ""pre-compile-time"") code execution, but they are not type systems at all, let alone dependent ones!",-0.375,scheme
13y35a5,jmnkxbn,"Macro systems like m4 or the macros of Scheme and Common Lisp can offer compile-time (or ""pre-compile-time"") code execution, but they are not type systems at all, let alone dependent ones!",-0.375,lisp
13y35a5,jmo1tbx,"This is how I rewrote [this Stack Exchange example](https://proofassistants.stackexchange.com/questions/1609/what-are-some-good-bad-examples-of-green-slime) in Idris:      data P : Bool -> Type where       Base  : P False        Slime : P b -> P c -> P (b || c)          total f : P False -> r     f Base = ?base_case     f (Slime {b = False} {c = False} x y) = ?slime_case     f (Slime {b = True}              x y) impossible  I had to specify \`{b}\` and \`{c}\` and the \`impossible\` case explicitly, but I mean, it doesn't seem that bad?",-0.16279761904761908,c
13y35a5,jmo1tbx,"This is how I rewrote [this Stack Exchange example](https://proofassistants.stackexchange.com/questions/1609/what-are-some-good-bad-examples-of-green-slime) in Idris:      data P : Bool -> Type where       Base  : P False        Slime : P b -> P c -> P (b || c)          total f : P False -> r     f Base = ?base_case     f (Slime {b = False} {c = False} x y) = ?slime_case     f (Slime {b = True}              x y) impossible  I had to specify \`{b}\` and \`{c}\` and the \`impossible\` case explicitly, but I mean, it doesn't seem that bad?",-0.16279761904761908,r
13y35a5,jmo1tbx,At least compared to some C++ template error messages I have seen in the past.,-0.275,c++
13y35a5,jmsby4t,">I had to specify `{b}` and `{c}` and the `impossible` case explicitly, but I mean, it doesn't seem that bad?",-0.5597222222222221,c
13y35a5,jmsby4t,At least compared to some C++ template error messages I have seen in the past.,-0.275,c++
13y35a5,jmsby4t,Here is a way to do this that avoids the green slime:      data Even : Nat -> Bool -> Type where       EvenZ : Even 0 True       Even1_False : Even 1 False       EvenS_False : Even n True -> Even (S n) False       EvenS_True : Even n False -> Even (S n) True      data Add : Nat -> Nat -> Nat -> Type where       AddZ : Add x 0 x    -- x + 0 = x       AddS :         Add x y z ->      --     x + y = z         Add x (S y) (S z) -- ==> x + (y+1) = z+1      data EvenSum : Bool -> Type where       Step : Add x y z ->   -- z = x+y              Even x True ->              Even y True ->              Even z r ->              EvenSum r      total h : EvenSum True -> ()     h (Step a b c d) = ()  This works fine.,0.028205128205128178,r
13y35a5,jmsby4t,Here is a way to do this that avoids the green slime:      data Even : Nat -> Bool -> Type where       EvenZ : Even 0 True       Even1_False : Even 1 False       EvenS_False : Even n True -> Even (S n) False       EvenS_True : Even n False -> Even (S n) True      data Add : Nat -> Nat -> Nat -> Type where       AddZ : Add x 0 x    -- x + 0 = x       AddS :         Add x y z ->      --     x + y = z         Add x (S y) (S z) -- ==> x + (y+1) = z+1      data EvenSum : Bool -> Type where       Step : Add x y z ->   -- z = x+y              Even x True ->              Even y True ->              Even z r ->              EvenSum r      total h : EvenSum True -> ()     h (Step a b c d) = ()  This works fine.,0.028205128205128178,c
13y35a5,jmsby4t,Here is a way to do this that avoids the green slime:      data Even : Nat -> Bool -> Type where       EvenZ : Even 0 True       Even1_False : Even 1 False       EvenS_False : Even n True -> Even (S n) False       EvenS_True : Even n False -> Even (S n) True      data Add : Nat -> Nat -> Nat -> Type where       AddZ : Add x 0 x    -- x + 0 = x       AddS :         Add x y z ->      --     x + y = z         Add x (S y) (S z) -- ==> x + (y+1) = z+1      data EvenSum : Bool -> Type where       Step : Add x y z ->   -- z = x+y              Even x True ->              Even y True ->              Even z r ->              EvenSum r      total h : EvenSum True -> ()     h (Step a b c d) = ()  This works fine.,0.028205128205128178,d
13xzgbs,,"Have a presentation on a selected programming language that I don't know yet, (so python, java, C++ and Scheme/Racket are out) and next week I need to send in 3 suggestions for my presentation.",0.0,python
13xzgbs,,"Have a presentation on a selected programming language that I don't know yet, (so python, java, C++ and Scheme/Racket are out) and next week I need to send in 3 suggestions for my presentation.",0.0,java
13xzgbs,,"Have a presentation on a selected programming language that I don't know yet, (so python, java, C++ and Scheme/Racket are out) and next week I need to send in 3 suggestions for my presentation.",0.0,c++
13xzgbs,jmk7ilj,Cobol.,0.0,cobol
13xzgbs,jmk7oc5,"OCaml has objects lol  Or Common Lisp, CLs objects are pretty cool.",0.275,lisp
13xzgbs,jmk7oc5,"OCaml has objects lol  Or Common Lisp, CLs objects are pretty cool.",0.275,cool
13xzgbs,jmk4qtq,"My first and unusual suggestion is ( commercial) Delphi / ( Open Source) FreePascal which is considered for many obsolete, which is not, because it's very detailed in it's design, besides supporting procedural and object orientation also supports modules.",0.24571428571428572,delphi
13xzgbs,jmk4qtq,"The second suggestion would be python since it's trendy, and it's a mix of Functional programming and object orientation.",0.3,python
13xzgbs,jmk4qtq,"The third could be JavaScript due functional programming, object orientation and dynamic declaration of properties and methods.",-0.041666666666666664,javascript
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,go
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,kotlin
13xzgbs,jmkd3zh,"Is you want mainstream languages: Go, Kotlin, Swift.",0.0,swift
13xzgbs,jmkrbia,Scala should suit you because you can compare it with your Java language.,0.0,scala
13xzgbs,jmkrbia,Scala should suit you because you can compare it with your Java language.,0.0,java
13xzgbs,jmkrbia,And C# is “not too exotic”(tm) and I can help you answer the questions and give you pointers to documentation.,0.5,c
13xzgbs,jmkw15s,What about R?,0.0,r
13xzgbs,jmlut64,"Second for smalltalk, also [IOLang](https://iolanguage.org) is super great, and of course the mighty Lua",0.3833333333333333,lua
13xzgbs,jmk6kow,"Javascript is definitely one that came to mind, I also migt suggest ruby, but javascript will probbaly be picked by a lot of people.",0.0,javascript
13xzgbs,jmk6kow,"Javascript is definitely one that came to mind, I also migt suggest ruby, but javascript will probbaly be picked by a lot of people.",0.0,ruby
13xzgbs,jmp57nv,Kotlin might be an interesting one since I'd love to dip my toes a bit in app making.,0.5,kotlin
13xzgbs,jmp57nv,"I did it with java a bit, wanna see how kotlin fairs",0.0,java
13xzgbs,jmp57nv,"I did it with java a bit, wanna see how kotlin fairs",0.0,kotlin
13xw8jg,,I've been a C++ developer for 20 years.,0.0,c++
13xw8jg,,I spent many years honing my craft under the scrutinizing look of C++ chat on StackOverflow.,0.2,c++
13xw8jg,,"I was obsessed with C++ templates for a long time, but now I've toned it down a lot (because they negatively affect compilation time, readability and cause disproportional complexity).",-0.2513888888888889,c++
13xw8jg,,"I've dabbled in Haskell 15 years ago, from the YAHT tutorial (anyone remember that?).",0.0,haskell
13xw8jg,,"I've also played a bit with Clojure but didn't go deep into macros, which is probably where the exciting stuff begins?",0.15,clojure
13xw8jg,,"I've also played a bit with Clojure but didn't go deep into macros, which is probably where the exciting stuff begins?",0.15,go
13xw8jg,jmjpkwa,"Personally, the last language that 'blew my mind' was Elixir.",0.0,elixir
13xw8jg,jmjpkwa,"Coming from the world of mutexes and complicated sharing, Elixir makes everything so much easier.",-0.15,elixir
13xw8jg,jmjyizy,Prolog / Datalog.,0.0,prolog
13xw8jg,jmjyizy,I heard Prolog made writing interpreters so easy it was banned in competitions!,0.5416666666666667,prolog
13xw8jg,jmjrpem,FORTH will probably fit your needs.,0.4,forth
13xw8jg,jmju3ry,Scheme and/or Haskell.,0.0,scheme
13xw8jg,jmju3ry,Scheme and/or Haskell.,0.0,haskell
13xw8jg,jmju3ry,For example in scheme you can express iteration with recursion.,0.0,scheme
13xw8jg,jmju3ry,Haskell is also a beautiful language - thinking functionally will expand your mind since you’re very experienced with imperative programming,0.925,haskell
13xw8jg,jmjqd93,"Avoiding the esoteric languages, my vote is APL.",0.0,apl
13xw8jg,jmjqd93,"I've been working with C++ for over a decade, and APL is one of the few languages that revert me to the layman's position of ""it's magic, got it.""",0.15,c++
13xw8jg,jmjqd93,"I've been working with C++ for over a decade, and APL is one of the few languages that revert me to the layman's position of ""it's magic, got it.""",0.15,apl
13xw8jg,jml3fa4,"A few ideas:  - [Uxntal](https://100r.co/site/uxn.html) - essentially a forth-like assembly language  for a small virtual computer - [Futhark](https://futhark-lang.org/) - use a functional language to program the gpu - [Haskell](https://haskell.org) - a general-purpose functional language with many unique properties (purely functional, lazy, expressive types, STM, etc).",0.04880952380952382,assembly
13xw8jg,jml3fa4,"A few ideas:  - [Uxntal](https://100r.co/site/uxn.html) - essentially a forth-like assembly language  for a small virtual computer - [Futhark](https://futhark-lang.org/) - use a functional language to program the gpu - [Haskell](https://haskell.org) - a general-purpose functional language with many unique properties (purely functional, lazy, expressive types, STM, etc).",0.04880952380952382,haskell
13xw8jg,jml3fa4,"You mentioned you dabbled in Haskell, why not try it again?",0.0,haskell
13xw8jg,jml3fa4,"(I've written about [7 things I learned from Haskell](https://gilmi.me/blog/post/2022/12/13/learned-from-haskell), and my book is linked at them bottom if you're interested :) ) - [Zig](https://ziglang.org) - might hit closer to home with your C++ background, but is doing a few new and interesting things in that space.",0.2372727272727273,haskell
13xw8jg,jml3fa4,"(I've written about [7 things I learned from Haskell](https://gilmi.me/blog/post/2022/12/13/learned-from-haskell), and my book is linked at them bottom if you're interested :) ) - [Zig](https://ziglang.org) - might hit closer to home with your C++ background, but is doing a few new and interesting things in that space.",0.2372727272727273,c++
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,haskell
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,lisp
13xw8jg,jmktye5,"Haskell, Common Lisp, Rust, are the three big ones, but I'll actually say you should look into 'real' OO.",-0.024999999999999994,rust
13xw8jg,jmktye5,"Personally I'm fond of Ruby (yes, under the hood, Ruby is a smalltalk dialect.)",0.0,ruby
13xw8jg,jmjz8an,"Prolog, or another of the logic programming languages maybe?",0.0,prolog
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,fortran
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,algol
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,pascal
13xw8jg,jmju1e7,"But there were several languages that deeply impressed *me*;  One was `Algol68`, which I first encountered around 1980, although you need to know that I'd only used ones like Fortran, Algol, Pascal and Cobol, rather staid in comparison.",0.3125,cobol
13xw8jg,jmju1e7,And one more was `K` (related to `J` and `APL`).,0.25,apl
13xw8jg,jmkrpnr,https://red-lang.org  A modern take on Lisp with a focus in DSLs.,0.2,lisp
13xw8jg,jmjv3q0,"WRT to OOP, if you haven't yet, give Smalltalk a decent go.",0.16666666666666666,go
13xw8jg,jmk2hqk,"Rust was mine, and I know it’s a popular one for this sort of thing.",0.6,rust
13xw8jg,jmjzcm6,Watch this video about writing meta interpreters in Prolog.,0.0,prolog
13xw8jg,jmld3d9,"Coming from C++ you can expect a much shorter, more elegant and expressive and ergonomic version of what you already know, with added metaprogramming in the language itself.",0.5,c++
13xw8jg,jmld3d9,What you will especially like is that you can take any C++ project and integrate it with Nim with no overhead at all.,0.0,c++
13xw8jg,jmld3d9,"I used it to run write a quick, one-off genetic algorithm to guess future user behavior of a legacy C++ app by calling into the actual code with Nim- yet the programming still felt quick-n-easy.",0.1111111111111111,c++
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,javascript
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,c
13xw8jg,jmld3d9,"Compile it to JavaScript so you don't have to write that stuff, then share data structures and routines between web frontend and backend (one gets compiled to JS, the other to C or C++).",-0.125,c++
13xw8jg,jmld3d9,"Write a cross-platform GUI app using C++ libraries, get done faster and have it be more pleasant.",0.6166666666666667,c++
13xw8jg,jmld3d9,Leverage decades-old C libraries and give them your own usability spin.,0.6,c
13xw8jg,jmld3d9,"Then there's the community projects... probably the most amazing one is futhark, which leverages LLVM to auto-generate Nim-bindings for any C library.",0.55,c
13xw8jg,jmld3d9,I actually am this enthusiastic about it so I can go on and on... it's really the first language I worked with that satisfies me.,0.2625,go
13xw8jg,jmjw1z3,"Go deeper in Haskell, learn Racket and read Beautiful Racket to see what the fuss about language oriented programming is all about.",0.85,go
13xw8jg,jmjw1z3,"Go deeper in Haskell, learn Racket and read Beautiful Racket to see what the fuss about language oriented programming is all about.",0.85,haskell
13xw8jg,jmjw1z3,Unison is p cool.,0.35,cool
13xw8jg,jmkda76,"Erlang blew my mind two decades ago, and it has remained blown.",0.0,erlang
13xw8jg,jmkda76,"I would avoid, for now, Elixir.",0.0,elixir
13xw8jg,jmkda76,"While it inherits much of what Erlang provides, there's a whole lot more piled on top that obscures the elegance and simplicity of the Erlang approach.",0.35,erlang
13xw8jg,jmk6k4z,Raku  At first glance it seems like a more polished version of Perl with more features.,0.4166666666666667,perl
13xw8jg,jmjppu7,Ada?,0.0,ada
13xw8jg,jmletrl,Nobody said scala.,0.0,scala
13xw8jg,jmletrl,Try common algo in various languages and see if you like scala one to be much more readable.,0.06666666666666667,scala
13xw8jg,jmlhru4,> I was obsessed with C++ templates  You might be into [Spiral's](https://github.com/mrakgr/The-Spiral-Language) staging capabilities.,-0.5,c++
13xw8jg,jmlkdgw,Rust for changing the natural patterns I've always used in imperial programming,0.1,rust
13xw8jg,jmll3m2,"Actually, from what you describe as the ""major breakthroughs in programming"", you should definitely have a look at Common Lisp.",-0.059375,lisp
13xw8jg,jmll3m2,"I'd recommend you start by installing SBCL + Quicklisp and a editor that supports Lisp (Emacs is not required, but it's a good choice if you already know how to use it).",0.7,lisp
13xw8jg,jmll3m2,"A good book to get you started is ""Common Lisp: A Gentle Introduction To Symbolic Computation"".",0.19999999999999998,lisp
13xw8jg,jmll3m2,"More advanced books are ""Let over Lambda"" and ""On Lisp"".",0.45,lisp
13xw8jg,jmkkz8d,Top contender : [https://mercurylang.org/](https://mercurylang.org/)  It's like if Prolog and Haskell had a baby.,-0.125,prolog
13xw8jg,jmkkz8d,Top contender : [https://mercurylang.org/](https://mercurylang.org/)  It's like if Prolog and Haskell had a baby.,-0.125,haskell
13xw8jg,jmjllt1,Try Rust and play with it a little bit.,-0.1875,rust
13xw8jg,jmli0od,"Datalog is a nice simple one that's very powerful and then there's something like Idris, it's Haskell but abstract.",0.33,haskell
13xw8jg,jmlnbb2,The first is APL.,0.25,apl
13xw8jg,jmlnbb2,I was told it wasn't so much a language as a religion (by one of the developers of the Fortran language).,0.2,fortran
13xw8jg,jmlnbb2,The other is Elixir!,-0.15625,elixir
13xw8jg,jmma7a4,Julia.,0.0,julia
13xw8jg,jmma7a4,And also the syntax is Pythonic but the performance is like C++.,0.0,c++
13xw8jg,jmkb0nj,Rust is the best answer I can give you.,1.0,rust
13xw8jg,jmkb0nj,"It’s not a VASTLY different paradigm from languages like C++ in the way that things like Haskell are, but it’s way more pragmatic than either C++ or Haskell.",0.25,c++
13xw8jg,jmkb0nj,"It’s not a VASTLY different paradigm from languages like C++ in the way that things like Haskell are, but it’s way more pragmatic than either C++ or Haskell.",0.25,haskell
13xw8jg,jmkb0nj,Out-there languages are cool but usually sacrifice low-level understandability for interesting abstractions.,0.19999999999999998,cool
13xw8jg,jmkb0nj,"Rust reaches for a higher-level of abstraction with the adoption of some functional-programming concepts, but maintains a level of tramsparency between the code you write and the low-level semantics.",0.0,rust
13xw8jg,jmkb0nj,"Rust has got a bit of a bad reputation on here for its cult-like level of recommendation, but I don’t think that’s worth paying much attention to.",-0.06666666666666661,rust
13xw8jg,jmkb0nj,It’s the only language I know of that has a chance of being “the thing to now use anywhere we used to choose C++”,0.0,c++
13xw8jg,jmkiyev,Prolog or Agda.,0.0,prolog
13xw8jg,jmkiyev,The gap between Haskell’s type system and Agda’s type system about as large as the gap between C’s and Haskell’s.,0.21428571428571427,haskell
13xw8jg,jmkiyev,The gap between Haskell’s type system and Agda’s type system about as large as the gap between C’s and Haskell’s.,0.21428571428571427,c
13xw8jg,jmkgua2,*Erlang or any BEAM language* - and the secret here is the BEAM VM.,-0.4,erlang
13xw8jg,jmltlgh,Scheme was great for me.,0.8,scheme
13xw8jg,jmltlgh,"I don't use it very often for practical purpose (although I have some personal clis written in Chicken scheme), but learning it and using it really improved my programming in other languages.",-0.06499999999999999,scheme
13xw8jg,jmltlgh,"For statically typed FP I prrfer OCaml over Haskell, I find it more pragmatic and very nice to use.",0.64,haskell
13xw8jg,jmm1lze,"There are a lot of good languages out there with novel ideas, such as Nim, Zig, and of course Rust.",0.35,rust
13xw8jg,jmm7tue,Forth  APL  Brainfuck  OOK!,0.0,forth
13xw8jg,jmm7tue,Forth  APL  Brainfuck  OOK!,0.0,apl
13xw8jg,jmmlf7r,Rust will blow your mind.,0.0,rust
13xw8jg,jmntfhc,"Try Ada, it has structured programming as a key design idea.",0.0,ada
13xw8jg,jmklfyo,You should try ruby but go into the depths of metaprogramming with it.,0.0,ruby
13xw8jg,jmklfyo,You should try ruby but go into the depths of metaprogramming with it.,0.0,go
13xw8jg,jmkdh9z,I really enjoyed coding in Ruby (not Rails).,0.5,ruby
13xw8jg,jmka845,"Rust, man  It seems like stuff you know on the surface, so I'm sure it doesn't sound exciting, but once you go all in on Rust, it'll change your entire life I promise",0.3,rust
13xw8jg,jmka845,"Rust, man  It seems like stuff you know on the surface, so I'm sure it doesn't sound exciting, but once you go all in on Rust, it'll change your entire life I promise",0.3,go
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,c
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,c++
13xw8jg,jmmdv32,I went from C# to C++(5 years) and I made one program in python and python is by far the craziest in terms of what you can do per line of code.,0.1,python
13xw8jg,jmldl42,"JavaScript will most likely, as yout stated: blow your mind and make you question everything you've believed in - I'm not sure though if that's the way you wanted your mind to be blown.",0.08333333333333333,javascript
13xw8jg,jmmz9x1,I guess Lisp could do the same when you go deep enough.,0.0,lisp
13xw8jg,jmmz9x1,I guess Lisp could do the same when you go deep enough.,0.0,go
13xw8jg,jmn7onn,Odin might not blow your mind but it will definitely make you go “man I wish C was like this!”,0.0,go
13xw8jg,jmn7onn,Odin might not blow your mind but it will definitely make you go “man I wish C was like this!”,0.0,c
13xw8jg,jmnaam1,Something similar can be done in *Ada* when you define a type for everything.,0.0,ada
13xw8jg,jmnaam1,I've seen highly efficient implementations of cryptographic algorithms in Ada that read like a book.,0.16,ada
13xw8jg,jmnaam1,"Other than that, I'd also recommend *Prolog* and *Mercury* like others have.",-0.125,prolog
13xw8jg,jmo9zqs,"Total mind-blowing is a big ask, but a very cool language not yet mentioned in the comments is the Icon programming language designed by Ralph Griswold and his colleagues at the University of Arizona.",0.15166666666666664,cool
13xw8jg,jmo9zqs,"Basically the same data structures as Python, but a completely different evaluation model: “goal-directed” evaluation.",0.0,python
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,scala
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,java
13xw8jg,jmpbdeq,Scala  OOP like Java and Pure functional like haskell.,0.21428571428571427,haskell
13xw8jg,jmr90vx,"Considering your rich background in C++ and Haskell, along with your interest in functional programming paradigms, I wouldn't necessarily predict that [Ballerina](https://ballerina.io) will ""blow your mind.""",0.1875,c++
13xw8jg,jmr90vx,"Considering your rich background in C++ and Haskell, along with your interest in functional programming paradigms, I wouldn't necessarily predict that [Ballerina](https://ballerina.io) will ""blow your mind.""",0.1875,haskell
13xw8jg,jmrkk26,Have you tried Lisp (as in common Lisp)?,-0.3,lisp
13xw8jg,jmrkk26,"I know Clojure is ""a lisp,"" but I've never tried it myself, and you saying that you never really dove into the macros makes me think you didn't really experience the parts of Lisp I'm thinking about.",0.05,clojure
13xw8jg,jmrkk26,"I know Clojure is ""a lisp,"" but I've never tried it myself, and you saying that you never really dove into the macros makes me think you didn't really experience the parts of Lisp I'm thinking about.",0.05,lisp
13xw8jg,jmrkk26,"Basically, Lisp starts out as a pretty simple programming language that can do ""a few things.""",0.016666666666666663,lisp
13xw8jg,jmrkk26,The process of writing a complex program in Lisp is basically extending the Lisp language itself to become a domain-specific language.,-0.3,lisp
13xw8jg,jmrkk26,"Take these, they may help you out along the way:      )))))))))))))))))))  Other than that, maybe prolog?",0.1875,prolog
13xw8jg,jmx55dc,CHICKEN Scheme uses continuation  passing style (CPS) so functions never return but rather continue executing the continuation (rest of progeam).,-0.6,scheme
13xw8jg,jmmffep,Elixir was a huge game changer for me.,2.7755575615628914e-17,elixir
13xw8jg,jmk1274,\+1 for Prolog.,0.0,prolog
13xw8jg,jmk1274,"Mercury is also worth a try if you like strong types, but it helps if you've dabbled a little in Prolog first.",0.19895833333333332,prolog
13xw8jg,jml8n2t,"Yep, Prolog for sure.",0.5,prolog
13xw8jg,jml8n2t,Prolog does the “logic programming” thing so much better compared to logic libraries in other languages.,0.1875,prolog
13xw8jg,jml8n2t,"Also, the fact that it’s homoiconic like Lisp allows so much cool metaprogramming stuff.",0.35,lisp
13xw8jg,jml8n2t,"Also, the fact that it’s homoiconic like Lisp allows so much cool metaprogramming stuff.",0.35,cool
13xw8jg,jml6as4,I will giving a talk later this year at Gophercon UK about how I implemented it in Go using concurrency.,0.0,go
13xw8jg,jmjslli,Scheme was a stretch but not mind-bending in any way.,0.0,scheme
13xw8jg,jmjslli,But array processing languages like APL and J are a total mind melt and a blast.,0.0,apl
13xw8jg,jmjslli,"It isn't just the syntax - its the ideas on basic structures, rethinking composition from scratch, combinatorial logic and you can go on and on.",0.0,go
13xw8jg,jmk821y,>APL  Just curious.,-0.1,apl
13xw8jg,jmk821y,Last time I used APL was on an IBM 5100 which had an APL keyboard.,0.0,apl
13xw8jg,jmkdrpv,"APL was my first programming language, back around 1972.",0.125,apl
13xw8jg,jmkdrpv,"Decades later when I discovered Functional Programming, it felt familiar to APL, in the sense of composing programs from expressions returning values.",0.1875,apl
13xw8jg,jml7xpd,"Modern, very good documentation, a bit less confusing than APL imo.",0.16083333333333333,apl
13xw8jg,jmk5xkz,"Yes in terms of “blew my mind”, prolog was definitely it",0.0,prolog
13xw8jg,jmk1vr8,I know only prolog,0.0,prolog
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,c++
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,rust
13xw8jg,jmlfhw3,"C++ has been my main programming language since early 2000s, but two yeas ago I started learning Rust, now I dread having to go back to C++.",0.08888888888888889,go
13xw8jg,jmlorlg,"While Rust without a doubt puts a big emphasis on compile-time verification, things like integer overflows still happen, and are not caught by the compiler.",0.0,rust
13xw8jg,jmkfjds,I found Erlang to be underwhelming as a programming language.,0.0,erlang
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,elixir
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,ruby
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,lisp
13xw8jg,jmlx2yk,"I feel like elixir was easy to learn and grasp (I came from ruby background though with a strong grasp of lisp and SML) you do end up learning Erlang too, if you ever want to do anything interesting with Elixir anyway.",0.45555555555555555,erlang
13xw8jg,jmlx2yk,The thing that elixir has over Gleam and Erlang is it’s meta programming capabilities.,0.0,elixir
13xw8jg,jmlx2yk,The thing that elixir has over Gleam and Erlang is it’s meta programming capabilities.,0.0,erlang
13xw8jg,jmlx2yk,"Elixir is really good and doing scientific computing, data analytics, machine learning, etc.",0.7,elixir
13xw8jg,jmlx2yk,where as Erlang isn’t great for it.,0.8,erlang
13xw8jg,jmlx2yk,"Lib, does macro black magic to get Elixir to run on GPUs, etc)",0.16666666666666669,elixir
13xw8jg,jmn7bnw,First time when I got introduced to Scala.,0.25,scala
13xw8jg,jmlag0y,"For an experienced c++ dev, the Rust experience will probably be “oh this is nice, finally some built in tooling“ and then “why can’t I build my linked list example, get out of my way Rust I know what I’m doing”.",0.4666666666666666,c++
13xw8jg,jmlag0y,"For an experienced c++ dev, the Rust experience will probably be “oh this is nice, finally some built in tooling“ and then “why can’t I build my linked list example, get out of my way Rust I know what I’m doing”.",0.4666666666666666,rust
13xw8jg,jmlag0y,"Rust is great if you come directly from the front end world and want to do some lower level development, or just prioritize safety over convenience, but Rust is just a more unpractical c++ imo.",0.4666666666666666,rust
13xw8jg,jmlag0y,"Rust is great if you come directly from the front end world and want to do some lower level development, or just prioritize safety over convenience, but Rust is just a more unpractical c++ imo.",0.4666666666666666,c++
13xw8jg,jn628j7,"I never really liked Python and when Julia came out I liked it way more right away, and now it has more libraries and support than it used to",0.31714285714285717,python
13xw8jg,jn628j7,"I never really liked Python and when Julia came out I liked it way more right away, and now it has more libraries and support than it used to",0.31714285714285717,julia
13xw8jg,jn61zmx,"Lol one big issue with Ada is you need a bootstrapped GCC 10 to compile it, and then you need to compile gcc 11, and then gcc 12, and then gcc13, and 14 if you really want.",0.3333333333333333,ada
13xw8jg,jn61zmx,but I'm proud to say I have the latest master branch of the gcc14 ada compiler on my Gentoo now,0.65,ada
13xw8jg,jmkbty4,"I mean, they've done some Haskell, so that's not mind blowing anymore and it would be the obvious go-to answer.",-0.15625,haskell
13xw8jg,jmng36m,">I guess Lisp could do the same  Did you ever see DSSSL, which was the predecessor of XSLT?",0.0,lisp
13xw8jg,jmjvqq0,"Erlang obviously, LFE is like Common Lisp but BEAM, Gleam is a new BEAM language.",-0.05454545454545454,erlang
13xw8jg,jmjvqq0,"Erlang obviously, LFE is like Common Lisp but BEAM, Gleam is a new BEAM language.",-0.05454545454545454,lisp
13xw8jg,jmjyf3y,Pony is a pretty cool language that does actor concurrency,0.3,cool
13xw8jg,jmnp19u,"Ecstasy supports a very similar model of concurrency:  * Ecstasy ""services"" are like Erlang processes: Objects that represent async execution and a domain of owned/managed state.",0.0,erlang
13xw8jg,jmnp19u,"mutable data) only exists within the realm of a service; this is different from Erlang, which does not allow mutable data for the most part.",0.16666666666666666,erlang
13xw8jg,jmkjcv6,"There are other BEAM languages, although probably not as developed/popular as Elixir.",-0.125,elixir
13xw8jg,jmkqy25,"In python I made my own async library, which beats asyncio.",0.6,python
13xw8jg,jml50dw,I think there's a BEAM-style concurrency library in Rust but it might not have taken off.,0.0,rust
13xw8jg,jml50dw,There's also some mentions of BEAM-style concurrency using new lightweight Java threads?,0.13636363636363635,java
13xw8jg,jml50dw,But probably someone is experimenting with it in Clojure by now.,0.0,clojure
13xw8jg,jml633k,"Yeah Idris or LeanProver or Coq since you have worked with Haskell the syntax is kind of similar, but being able to then also prove programs are correct is mind blowing.",0.3666666666666667,haskell
13xw8jg,jml633k,"Since you have done some clojure, you can pick up a copy of “the Little Typer”, it teaches you all the basics of dependent types and the only prerequisite is understanding recursion.",-0.09375,clojure
13xw8jg,jmkx0gj,Damn I’ll have to add Prolog to my list of languages to try.,0.0,prolog
13xw8jg,jmkx0gj,So far APL is at the top,0.3,apl
13xw8jg,jmkba7m,"https://tryapl.org/  Also, I think Dyalog will install a custom keyboard map just for APL.",0.0,apl
13xw8jg,jmmaq0v,"I now dabble with both APL and BQN which have prefix key system, where you hit  a prefix, then a key after that to get the symbol you want.",0.0,apl
13xw8jg,jmll702,Curry (similar to Haskell but with logic features added),0.0,haskell
13xw8jg,jmmepyp,Er… rust _does_ check for const-known overflows at compile time https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2305827b8c7c09d2c43275510c859e0b and has runtime overflow checks that are on by default for debug builds (or with all builds if you put `overflow-checks = true` in your Cargo.toml)  And of course the compiler is allowed to omit things like bound and overflow checking if it can be proven redundant!,0.04999999999999999,rust
13xw8jg,jmmcgjs,The thing I found interesting about Erlang is that it's basically microservices and Kubernetes two decades before everyone was raving about how this new concept was going to revolutionize the industry.,0.3181818181818182,erlang
13xw8jg,jmn74ws,"I understand Elixir's appeal, it's just not for me.",0.0,elixir
13xw8jg,jmn74ws,If I wanted Ruby I would learn Ruby.,0.0,ruby
13xw8jg,jmkp77p,Do people really think Carp is harder than Rust?,0.05,rust
13xw8jg,jmkp77p,"When I had used it, with no Rust experience, I figured Carp out in a few hours.",-0.2,rust
13xw8jg,jmkp77p,"Rust, on the other hand, has such dense syntax and an endless list of features that it was not something I figured out in a few hours.",-0.1125,rust
13xw8jg,jmkwz0i,"Also, you can make a lot of Erlang pids.",0.0,erlang
13xw8jg,jmmy8iy,Go absolutely does not.,0.2,go
13xw8jg,jmli2tg,Go concurrency is not identical but it is *really* similar...,0.0,go
13xw8jg,jmlummy,"Yes, prolog will give you a single answer at a time, but it can continuously generate possibilities until all possibilities are exhausted as long as you keep asking",-0.17380952380952383,prolog
13xw8jg,jmngjuo,"All of those ways are reasonably efficient  Notably, “strip suffix” _should_ be `semidet`, but a typical Prolog implementation will actually be `nondet`, so it will do an extra iteration just to tell the caller “no more results”.",0.04722222222222222,prolog
13xw8jg,jmp08zv,"Yes, Prolog has first-class support for nondeterminism.",0.0,prolog
13xw8jg,jmp08zv,There is a joke that Prolog only has one algorithm: exponential backtracking search.,0.0,prolog
13xw8jg,jmp08zv,"This is indeed a joke, but it's true that writing exponential backtracking search is much easier in Prolog than in most other languages.",0.23125,prolog
13xw8jg,jn14owr,Elixir is superficially similar to ruby the syntax looks similar but the semantics are completely different,0.0,elixir
13xw8jg,jn14owr,Elixir is superficially similar to ruby the syntax looks similar but the semantics are completely different,0.0,ruby
13xw8jg,jmlou1s,"In my case I've used more Rust than C++, but now recently I've found myself going back to C++ due to convenience.",0.09375,rust
13xw8jg,jmlou1s,"In my case I've used more Rust than C++, but now recently I've found myself going back to C++ due to convenience.",0.09375,c++
13xw8jg,jmlou1s,"Convenience of being a more mature language with generally larger, more popular and more feature rich libraries for a much broader usecases than Rust.",0.34687500000000004,rust
13xw8jg,jmlou1s,"There are fun PoC projects like Bevy and (now archived) amethyst, but actual real world development is done in C++ and that's where the cutting edge is (e.g.",-0.024999999999999994,c++
13xw8jg,jmlou1s,"Also I have tried to use Rust for ""low level hackery"", like creating an injectable dynamic library that can hook functions of an application, and it's more of a hassle in Rust than with C++.",0.16666666666666666,rust
13xw8jg,jmlou1s,"Also I have tried to use Rust for ""low level hackery"", like creating an injectable dynamic library that can hook functions of an application, and it's more of a hassle in Rust than with C++.",0.16666666666666666,c++
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,c++
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,c
13xw8jg,jmlou1s,"For low level stuff I'd still use C++ (or C, or Zig) instead of Rust.",0.0,rust
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,rust
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,c++
13xw8jg,jmlou1s,"Idk, to me there aren't very obvious use cases where Rust shines more than C++, C or Zig.",0.25,c
13xw8jg,jmlou1s,"However, if there is a project where security is the #1 concern of an application together with performanc, then Rust could be a good fit.",0.55,rust
13xw8jg,jna3kda,"I didn’t know about that Ada overlay though, so thanks for the link.",0.2,ada
13xw8jg,jmmi1lj,Is there a good book you’d recommend on Pony?,0.7,d
13xw8jg,jmm335q,"While the actor model used by Erlang and communicating sequential processes which inspired Go are in some ways two sides of the same coin, Go is missing out on a lot of the things that make Erlang great:  - Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.30000000000000004,erlang
13xw8jg,jmm335q,"While the actor model used by Erlang and communicating sequential processes which inspired Go are in some ways two sides of the same coin, Go is missing out on a lot of the things that make Erlang great:  - Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.30000000000000004,go
13xw8jg,jmm335q,"In Go, all goroutines share one big global mutable heap.",0.0,go
13xw8jg,jmm335q,"Go's memory model is built on racy concurrent mutation of global state, where Erlang doesn't have mutation of global state whatsoever, and very little global state to begin with beyond the code server.",-0.060937500000000006,go
13xw8jg,jmm335q,"Go's memory model is built on racy concurrent mutation of global state, where Erlang doesn't have mutation of global state whatsoever, and very little global state to begin with beyond the code server.",-0.060937500000000006,erlang
13xw8jg,jmm335q,"- Erlang is built on asynchronous messaging, which is much more flexible.",0.5,erlang
13xw8jg,jmm335q,"Go channels use synchronous, bounded, blocking messaging - The Erlang/OTP framework provides extensive built-in support for building fault-tolerant concurrent applications, including declarative structuring of supervision hierarchies, and a ""let it crash"" philosophy intended to enable self-healing applications, with extensive exception reporting capabilities.",0.0,go
13xw8jg,jmm335q,Go has none of that.,0.0,go
13xw8jg,jmm2k2o,"The only difference is that concurrent processes communicate by sending messages over channels in Go, where concurrent processes communicate by sending messages directly each other in Elixer.",-0.008333333333333331,go
13xw8jg,jmm2k2o,There are different consequences in how they are implemented in Go vs OTP.,0.0,go
13xw8jg,jmm2k2o,"Yes, Go and Erlang have differences beyond their concurrency systems.",0.0,go
13xw8jg,jmm2k2o,"Yes, Go and Erlang have differences beyond their concurrency systems.",0.0,erlang
13xw8jg,jmm551p,"> Erlang uses an immutable ""shared nothing"" model where every process has its own heap (with some caveats, e.g.",0.6,erlang
13xw8jg,jmm551p,"In Go, all goroutines share one big global mutable heap.",0.0,go
13xw8jg,jmm551p,Mutability can be a pain point in Go.,0.0,go
13xw8jg,jmm551p,"> Erlang is built on asynchronous messaging, which is much more flexible.",0.5,erlang
13xw8jg,jmm551p,"Go channels use synchronous, bounded, blocking messaging  I disagree that Erlang style asynchronous messaging is more flexible.",0.5,go
13xw8jg,jmm551p,"Go channels use synchronous, bounded, blocking messaging  I disagree that Erlang style asynchronous messaging is more flexible.",0.5,erlang
13xw8jg,jmm551p,You have to synchronize actors manually by essentially implementing TCP-lite if you want that kind of behavior using Erlang actors.,0.3,erlang
13xw8jg,jmm551p,I don't think it's fair to say Erlang actors are more flexible.,0.6,erlang
13xw8jg,jmm551p,Go has none of that.,0.0,go
13xw8jg,jmm551p,CSP in Go can be implemented on a fault tolerant runtime - it just isn't.,0.0,go
13xw8jg,jmmedgo,Go's concurrency model (CSP ) and Erlang/BEAM's (Actor) are different.,0.0,go
13xw8jg,jmmedgo,")*  Go's model does allow shared state, but the idiomatic way to handle shared state is to ""share memory by communicating"", i.e., to use channels to pass the state around, these are not messages, and should not be confused with such.",-0.2,go
13xw8jg,jmmedgo,"In Go's CSP model, goroutines (lightweight threads) communicate primarily through channels which can be thought of as typed pipes that allow you to send and receive values with the channel operator, <-.",0.4,go
13xw8jg,jmmedgo,"There is no direct channel of communication as in Go; instead, each actor has a mailbox for incoming messages.",-0.05,go
13xw8jg,jmmedgo,"In Go, goroutines and channels are the main concurrency primitives.",0.16666666666666666,go
13xw8jg,jmmedgo,"In Go, error handling tends to be done through multiple return values and the error type.",0.0,go
13xw8jg,jmmedgo,"Go’s channels provide a mechanism for guaranteed delivery – if a goroutine sends a message on a channel, another goroutine will receive it.",0.0,go
13xw8jg,jmmedgo,"the Actor model and Go's CSP model both provide robust frameworks for handling concurrency, they embody different philosophies and offer different sets of trade-offs.",0.0,go
13xw8jg,jmmybn0,Except Go isn't pure CSP as there's no restrictions on memory sharing at all.,0.21428571428571427,go
13xw8jg,jmm89xe,> I disagree that Erlang style asynchronous messaging is more flexible.,0.5,erlang
13xw8jg,jmm89xe,Erlang has blocking *receive*.,0.0,erlang
13xw8jg,jmm89xe,Joe Armstrong did a great job of covering the tradeoffs here in his book Programming Erlang.,0.8,erlang
13xw8jg,jmm89xe,> You have to synchronize actors manually by essentially implementing TCP-lite if you want that kind of behavior using Erlang actors.,0.3,erlang
13xw8jg,jmm89xe,"It's one of the most common patterns in all of Erlang, and it's built into the framework that ships with the language.",0.1,erlang
13xw8jg,jmm89xe,"Go, on the other hand, bakes this into the language at a very very deep level, rather than it being a framework implemented in lower-level, more flexible primitives.",0.125,go
13xstwh,,"I liked clox in Crafting Interpreters, but im looking forward to build something similar in rust",0.3,rust
13xstwh,jmkukxt,"There's a bunch of Lox implementations in Rust:  https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust  If you understood the book, and as I see from other comments that you're more at home with Rust than C, then can you kind of imagine the book with these as the code examples?",0.325,rust
13xstwh,jmkukxt,"There's a bunch of Lox implementations in Rust:  https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust  If you understood the book, and as I see from other comments that you're more at home with Rust than C, then can you kind of imagine the book with these as the code examples?",0.325,c
13xstwh,jmj5iff,If you know how to program then you can do the C part of that book.,0.0,c
13xstwh,jmj5iff,"Rust is different for sure, but you can probably extrapolate and figure it out.",0.25,rust
13xstwh,jmj5iff,"C is a small language, it doesn't have any special features.",0.053571428571428575,c
13xstwh,jmjbkfa,"if you struggle from the books chosen language, I'd really advice to go through it.",0.2,go
13xstwh,jmjbkfa,"If you are good at rust, it should get easy fast, if not you'll learn even more from it.",0.4583333333333333,rust
13xstwh,jmjz7uc,You can checkout the [Rust implementations of clox](https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations#rust) interpreter.,0.0,rust
13xstwh,jmjz7uc,It might teach you how to express the ideas presented in the book in idiomatic Rust.,0.0,rust
13xstwh,jmjcu4n,Can write but need deep compiler expert that first masters Rust.,0.125,rust
13xstwh,jmmxv00,"https://m.youtube.com/watch?v=WdoAJ_ouWRM&pp=ygUdV3JpdGluZyBhbiBpbnRlcnBldGVyIGluIHJ1c3Q%3D  This is a video series of a guy following the ""Crafting Interpreters"" book by Rob Nystrom but changed the implementation to rust.",0.0,rust
13xstwh,jml6ied,"It’s a bit tougher with rust, using The same interface for the GC would likely cause UB (&mut references would be non-exclusive)",0.0,rust
13xstwh,jmj0sgp,Because im not as good with C as I am in Rust,0.7,c
13xstwh,jmj0sgp,Because im not as good with C as I am in Rust,0.7,rust
13xstwh,jmj6b0j,"Rust has so many feautures to make things faster, i preferred learning from a ""rusty"" source then porting C to Rust, so I can learn the many features of the language, i will try to implement clox again tho",0.5,rust
13xstwh,jmj6b0j,"Rust has so many feautures to make things faster, i preferred learning from a ""rusty"" source then porting C to Rust, so I can learn the many features of the language, i will try to implement clox again tho",0.5,c
13xstwh,jmkjha0,im pretty sure i saw a video series on youtube of someone going through the java implementation of clox and just translating it to rust.,0.375,java
13xstwh,jmkjha0,im pretty sure i saw a video series on youtube of someone going through the java implementation of clox and just translating it to rust.,0.375,rust
13xpicd,,The nearest such feature is something that C calls 'X-macros\`.,0.0,c
13xpicd,,"):      #include <stdio.h>            #define COLORS \         X(WHITE,  0xFFFFFF)   \         X(RED,    0xFF0000)   \         X(GREEN,  0x00FF00)   \         X(BLUE,   0x0000FF)   \         X(BLACK,  0x000000)          enum colors {         #define X(value, rgb) value,             COLORS         #undef X     };            char* toString(enum colors value) {         switch (value) {             #define X(color, rgb) \                 case color:  \                     return #color;                     COLORS             #undef X         }     }          int getrgb(enum colors value) {         switch (value) {             #define X(color, rgb) \                 case color:  \                     return rgb;                     COLORS             #undef X         }     }          int main(void) {         for (int i=WHITE; i<=BLACK; ++i) {             printf(""%d: %8s %06X\n"", i, toString(i), getrgb(i));         }     }  I have to say, I'd forgotten how much of an abomination it is.",-0.09999999999999999,d
13xpicd,jmitixg,"General solutions I am aware of:  * Code generation, of with X-macros is a clever hack to work within the limitations of the C preprocessor.",0.15555555555555556,c
13xpicd,jmitixg,"For example, Java enums have built-in methods to retrieve the name of an enum value.",0.0,java
13xpicd,jmitixg,"I want to highlight Java enums here, which I think are a fairly elegant solution following the ""turn it into a language feature"" approach.",0.25,java
13xpicd,jmitixg,"WHITE(0xFFFFFF),       ...       BLACK(0x000000);        // whatever internal data you want       private final int rgb;       Color(int rgb) { this.rgb = rgb; }        public int getRgb() { return rgb; }        // toString() is automatically implemented       // ordinal() is automatically implemented       // Color.values() is automatically implemented     }      ...     for (Color c: Color.values())       System.out.format(""%d: %s %06X\n"", c.ordinal(), c, c.getRgb());  Output:      0: WHITE FFFFFF     ...     1: BLACK 000000  Limitation: enum constructors are executed at runtime (at class load time) during static initialization.",0.04761904761904762,c
13xpicd,jmitixg,"WHITE(0xFFFFFF),       ...       BLACK(0x000000);        // whatever internal data you want       private final int rgb;       Color(int rgb) { this.rgb = rgb; }        public int getRgb() { return rgb; }        // toString() is automatically implemented       // ordinal() is automatically implemented       // Color.values() is automatically implemented     }      ...     for (Color c: Color.values())       System.out.format(""%d: %s %06X\n"", c.ordinal(), c, c.getRgb());  Output:      0: WHITE FFFFFF     ...     1: BLACK 000000  Limitation: enum constructors are executed at runtime (at class load time) during static initialization.",0.04761904761904762,d
13xpicd,jmk81cr,"Just for fun, I implemented the [same kind of thing in TypeScript here](https://www.typescriptlang.org/play?target=7#code/PTAEGcBcENISwMakgTwA4FNymgJw6AgPa74KQA2KocAdgGYakYAmoAFABZEBuTovfpE4EeeONABGFLAEoAUMVpRQAbRb4A5rWgBbLABpQW8HABeh4xk10WiLAF1QAXmREAKgFc0MgPL0AQVJoFHB2VXlQKLUAIhYABhijAA4jGNxEhwNI6NU4gEYk0FTQdMKsnKi8lkKUtNwAJhiK6NjoRKMAFnrM7Na86FrQbtLccuyHBXkQUABhCkQAa1KAJU9aGLcIDAJhAgoiTUUiZSIZADoDzXYNax19cAUlcDOMS8P2E3M5Y9OLq8+1ls9ke8jB4OmACpIZFIaAAOIYWhMRCgejrchwE6EE58XDwWiaHDBFAAWiI9FJkG8MmwkCIyBpGHJlLwuBC4CMumgdBgdDoR1AcKgsFRqEw4HOsOA0zAvloVAg3AA7rQ0SRQN4ttSfFgBPRQDJCcJQPFSSMENA1cQ0ChgGhoFBdgzlSRlvQNVbqEbNMJ5OjaJjsfSvLr-EF2aEbrBoAAuNSTeOqBz+jHwYMeJnhkngAA8AQAfNGYEmAg5k7JS8mUwGg2qQ1nAjn80YAEJFlgx0tt8uJtQBZNt6upwPp+uZsNNyN5gJtoyzDtd-tzua9yv9wegVub2bD2tjtyhvxTjktrfzowAEUXJeX57mV7XVayW53m8vw5mcF0uv0tBgY4jnWh6NhGHLFnGmq0IstBEKqyYVqAADelQ4sokCGkivqcC4oCdjAqjxA4AD8lxYSaxHEaaYKtPg1K4GqYEoOc9C4EQujsEhmHGjhAC+RjsAA+kYcCyC4BZ4TG5zcmg7BwJAGC6OJNAKboqhwJMCi8fIQA).",0.3,typescript
13xpicd,jmlgmai,">Just for fun, I implemented the same kind of thing in TypeScript here.",0.3,typescript
13xpicd,jmlgmai,"That's quite neat, I'd never seen Typescript in action before.",0.1,typescript
13xpicd,jmlgmai,"As I said, the array examples can be expressed as sets of records or tuples, and I suppose you can go further in expanding them into columns using software.",0.0,go
13xpicd,jmlgmai,"I had a go at your example in my scripting language, shown below.",0.0,go
13xpicd,jmlgmai,"(dregnames, regsizes, regindices) := getcolumns((         (""d0"", 8, ""r0""),         # (r0/1/2 were enums in original,         (""d1"", 8, ""r1""),         # defined elsewhere)         (""d1"", 8, ""r2""),         (""a0"", 4, ""r0""),         (""a1"", 4, ""r1""))     )          func getcolumns(table) =         cols := table[1].len         arrays ::= ((),)*cols    # ::= makes distinct, mutable copies         for r to table.len do             for c to cols do                 arrays[c,r] := table[r,c]             od         od              arrays     end          println =dregnames     println =regsizes     println =regindices",-0.025000000000000005,r
13xpicd,jmlgmai,"(dregnames, regsizes, regindices) := getcolumns((         (""d0"", 8, ""r0""),         # (r0/1/2 were enums in original,         (""d1"", 8, ""r1""),         # defined elsewhere)         (""d1"", 8, ""r2""),         (""a0"", 4, ""r0""),         (""a1"", 4, ""r1""))     )          func getcolumns(table) =         cols := table[1].len         arrays ::= ((),)*cols    # ::= makes distinct, mutable copies         for r to table.len do             for c to cols do                 arrays[c,r] := table[r,c]             od         od              arrays     end          println =dregnames     println =regsizes     println =regindices",-0.025000000000000005,c
13xkz1o,jmssmg9,"Instead of passing by value with great difficulty, why not support Rust's `&mut`?",0.8,rust
13xkz1o,jmhznwf,The great thing about Haskell etc.,0.8,haskell
13xkz1o,jmmu0jf,"It depends on the language, but in C, you can get the address of a variable that lives on the stack, and if you're not careful, the pointer can outlive the stack frame it points to.",0.05,c
13xkz1o,jmj6my6,"Monads were adopted by Haskell as a way of achieving purity without needing uniqueness types that Clean had adopted - so I'd say there is, in some sense, a fundamental connection there.",0.3666666666666667,haskell
13xkz1o,jmj6my6,[Phillip Wadler's Monads For Functional Programming paper](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf) gives a pretty good overview of why the Haskell developers went with monads.,0.475,haskell
13xkz1o,jmiofcc,Just like in Haskell `IO ()` is the unit type in a context where input/output is possible.,0.0,haskell
13xkz1o,jmipc4d,"I think `Random a` would be something like `Rng -> (a, Rng)`, so `Random ()` is still a pretty useless `r -> ((), r)`.",-0.3125,r
13xkz1o,jmiui3g,"For example, take the function `putChar :: Char -> IO ()` from [Haskell](https://hoogle.haskell.org/?hoogle=putChar).",0.0,haskell
13xkz1o,jmiui3g,"This is especially important in strict functional languages like Haskell, where all functions are pure and side effects are prohibited.",0.5071428571428571,haskell
13xkz1o,jmiui3g,Haskell gets around this restriction by making the side effect part of the type.,0.0,haskell
13xkz1o,jmiyct4,"Yeah, I know Haskell and how IO works.",0.0,haskell
13xkz1o,jmiyct4,"It could be defined as, in Haskell terms,  ```` newtype Random a = Random (Rng -> (a, Rng)) ````  where `Rng` is a known random number generator type (it could be a parameter to `Random` though).",-0.5,haskell
13xkz1o,jmiyct4,"Or simply  ```` type Random = State Rng ````  This does seem to be the same as  ```` [r, set rand] = RandInt(rand); ````  in the OP, except that if you have linear types in language it also protect against copying of the Rng state even when writing it that way, without any special syntax for monads.",-0.03571428571428571,r
13xkz1o,jmiyct4,"(GHC has a language option to enable linear types, but I haven't written any Haskell long before this was added, so I'm not sure how it works).",-0.15,haskell
13xdkmr,jmhhy9q,"Just did some benches, the code is [here](https://gist.github.com/yndc/6691f1cc0dcc31de59fffa13d5afa0d3) (C++).",0.0,c++
13xdkmr,jmhhy9q,"To simulate padding, I used different data types in C++ (`short, int, long long` to store the same `char` type (1 byte).",-0.02,c++
13xdkmr,jmhhy9q,So I think using 4-bytes-aligned is the best way to go for me.,1.0,go
13xdkmr,jmhjsis,"For example, C# has special annotations like `[FieldOffset(n)]` to let users customize exactly how data is aligned.",0.3035714285714286,c
13xdkmr,jmhjsis,Overlapping memory can even be used to model C unions.,0.0,c
13xdkmr,jmhjsis,"Still, this makes C# a lot better at native code interop than Java.",0.5,c
13xdkmr,jmhjsis,"Still, this makes C# a lot better at native code interop than Java.",0.5,java
13xdkmr,jmi7spx,"Yeah C# keeps the default alignment as an implementation detail, unless you manually specify the alignment via annotations.",0.0,c
13xdkmr,jmhydpq,"Any C compiler will align 64-bit entities at 8-byte boundaries, I'd be surprised if other languages did anything different.",-0.008333333333333331,c
13xdkmr,jmi3b79,"Both Java and C# seem to default to system pointer size alignments, which is 8 byte for 64 bit machines.",0.0,java
13xdkmr,jmi3b79,"Both Java and C# seem to default to system pointer size alignments, which is 8 byte for 64 bit machines.",0.0,c
13xcpsn,,Or go there directly [https://docs.google.com/document/d/1EPYLojn9PzslmOFhBT4PYFKFGkrmreRBxPHN\_KHEkRw/edit?usp=sharing](https://docs.google.com/document/d/1EPYLojn9PzslmOFhBT4PYFKFGkrmreRBxPHN_KHEkRw/edit?usp=sharing).,0.1,go
13x7r6s,jmqq9gc,This may be partially why Go switches stacks when calling into C,-0.1,go
13x7r6s,jmqq9gc,This may be partially why Go switches stacks when calling into C,-0.1,c
13x3q8g,jmhbbk7,"And that's beside the mention of ""great success""... Rust wasn't even around in 2002, and I don't think any language other than MLKit used regions at the time.",0.325,rust
13x3q8g,jmhc2wm,"By C, I believe they're referring to Cyclone, which was being worked at around the same time.",0.0,c
13x2iv3,jmfvkzo,"When I first hacked my type system together, only structs were nullable, and they all were (like Java I guess).",0.125,java
13x2iv3,jmfvkzo,I finally buckled down and figured out the syntax and semantics of the Imperative Shell part of my FC/IS language.,-0.07777777777777779,shell
13x2iv3,jmfvkzo,"I need to look into a bug that may still be lurking in the multiple dispatch, add a little more built-in IO, add a `rune` type for compatibility with Go, and bring the docs up to date.",0.10416666666666667,go
13x2iv3,jmmjcbm,"It was originally in D, but I was never able to setup a debugger on Windows, so I've swiched to C# (that I'm more used to) and quickly was able to fix some bugs that were haunting me for months and finally advanced again.",0.30972222222222223,d
13x2iv3,jmmjcbm,"It was originally in D, but I was never able to setup a debugger on Windows, so I've swiched to C# (that I'm more used to) and quickly was able to fix some bugs that were haunting me for months and finally advanced again.",0.30972222222222223,c
13x2iv3,jmj3b7c,The Cara language (https://cara-lang.com): right now I'm rewriting the interpreter in Elm (it was previously in TypeScript and before that in OCaml).,0.05952380952380952,elm
13x2iv3,jmj3b7c,The Cara language (https://cara-lang.com): right now I'm rewriting the interpreter in Elm (it was previously in TypeScript and before that in OCaml).,0.05952380952380952,typescript
13x2iv3,jnt1ses,I was finally inspired to get started after reading Graydon Hoare’s post on how Rust would have looked different if he could make all the decisions.,0.0,rust
13x2iv3,jnt1ses,"One of the things that struck me is that Hoare didn’t want capture groups in Rust, and I realized from my own immediate disagreement that I really like closures, so I decided to put together some ideas for a language that used scopes (closures) as it’s “atomic” unit.",0.4,rust
13x2iv3,jnt1ses,"It would be a systems level language with managed memory like rust but draw several inspirations from Julia, another language I really enjoy.",0.2,rust
13x2iv3,jnt1ses,"It would be a systems level language with managed memory like rust but draw several inspirations from Julia, another language I really enjoy.",0.2,julia
13x2iv3,jnt1ses,"struct Foo {         bar: String,          fn bar_ref(&self) => &self.bar     }      let foo = Foo{“hello”.as_string()}     let s = foo.bar_ref() // not allowed      foo.bar_ref() |&s| {         // s captures the reference to bar         // &s pattern matches &bar so s is bar         // this is okay; foo can’t be freed while in here         @println(s)     }   I’ve completed writing the lexer in rust and am moving on to the parser.",0.5,rust
13x2iv3,jmgdjtf,"In June, I could go a few different directions.",-0.1,go
13x2iv3,jmgdjtf,"They are really cool, but probably should wait for the scheduler.",0.35,cool
13x2iv3,jo8qvxq,"There are still functions in some ways via a trait system kind of like Rust (also where and polymorphism appears), but it's not quite the same.",0.3,rust
13x2iv3,jo8qvxq,It's `a add b` or with C++-esque syntax it's like `(&c)->add(b)` or something.,0.0,c
13x2iv3,jo8qvxq,These procedures can also have embedded C code which is how you interact with external stuff and how the core and standard libraries are implemented.,0.0,c
13x2iv3,jo8qvxq,"Trait and struct definitions go under `[Type]` and have their own syntax  Forcing all logic to be an explicit mutation of a singular datum may end up being the worst way to program ever, but it's at least a different way",-0.175,go
13x2iv3,jmjx4jt,"standards that's pretty dumb, but it does work, which is really cool.",0.075,cool
13x2iv3,jmn06go,It's a sort of esolang / alternative history for the original LISP language.,0.375,lisp
13x2iv3,jmn06go,"I want to use lists of symbols as the universe of data but instead of the nested trees that LISP uses, I want to keep things flat.",-0.025,lisp
13x2iv3,jmn06go,"The current plan is to provide a syntax for describing machines that operate like Turing machines, treating the lists like tapes and using a pattern-matching-on-symbols scheme to define the finite state machines.",0.0,scheme
13x2iv3,jo1uusi,"A couple years into it, I discovered the D programming language and fell in love.",0.5,d
13x2iv3,jo1uusi,"D is already pretty close to what I wanted ZACL to be, and much more mature.",0.2833333333333333,d
13x2iv3,jo1uusi,It seemed to me that I should be able to implement ZACL's value-add features as a D framework.,0.5,d
13x2iv3,jo1uusi,"That proved a lot more difficult than I thought, and I've lowered my sights for that D framework.",0.0,d
13x2iv3,jo1uusi,"One of the ways I am toning down my ambitions is to make at least the first version a transpiler instead of a compiler, targeting C as its IR and using gcc as its back-end.",-0.06851851851851853,c
13x2iv3,jo1uusi,"* Extending the struct type to include class-like capabilities, pretty much identical to D's structs.",0.225,d
13x2iv3,jmizxp9,"a language with these specs: * python syntax  * no types like crystal  * c performance  * for low level system programming  * manual mem management but in the jai's style which ables writing gc-like code  * fast compilation  * compile time execution (not like zig, but more like nim's `const` variables)  * meta functions (jitted at compile time, and taking as parameters the compiler's instance and the ast node to the call of itself), you can use them to do whatever you want with the compiler instance, for example you can mutate the ast, you can change the output path of the compilation, this makes incredibly easy to implement stuff like rust dbg!",0.3104166666666667,python
13x2iv3,jmizxp9,"a language with these specs: * python syntax  * no types like crystal  * c performance  * for low level system programming  * manual mem management but in the jai's style which ables writing gc-like code  * fast compilation  * compile time execution (not like zig, but more like nim's `const` variables)  * meta functions (jitted at compile time, and taking as parameters the compiler's instance and the ast node to the call of itself), you can use them to do whatever you want with the compiler instance, for example you can mutate the ast, you can change the output path of the compilation, this makes incredibly easy to implement stuff like rust dbg!",0.3104166666666667,crystal
13x2iv3,jmizxp9,"a language with these specs: * python syntax  * no types like crystal  * c performance  * for low level system programming  * manual mem management but in the jai's style which ables writing gc-like code  * fast compilation  * compile time execution (not like zig, but more like nim's `const` variables)  * meta functions (jitted at compile time, and taking as parameters the compiler's instance and the ast node to the call of itself), you can use them to do whatever you want with the compiler instance, for example you can mutate the ast, you can change the output path of the compilation, this makes incredibly easy to implement stuff like rust dbg!",0.3104166666666667,c
13x2iv3,jmizxp9,"a language with these specs: * python syntax  * no types like crystal  * c performance  * for low level system programming  * manual mem management but in the jai's style which ables writing gc-like code  * fast compilation  * compile time execution (not like zig, but more like nim's `const` variables)  * meta functions (jitted at compile time, and taking as parameters the compiler's instance and the ast node to the call of itself), you can use them to do whatever you want with the compiler instance, for example you can mutate the ast, you can change the output path of the compilation, this makes incredibly easy to implement stuff like rust dbg!",0.3104166666666667,rust
13x2iv3,joqkhwz,"I’m implementing my language, sammy-lang, in C++ using LLVM.",0.0,c++
13x2iv3,joqkhwz,My previous version is written in JavaScript and compiles to JavaScript.,-0.16666666666666666,javascript
13x2iv3,joqkhwz,"Here’s the JS version that you can play around with:  https://github.com/pinksynth/sammy-lang  It supports some fun things like piping:  ``` dog -> add_name(“spot”) -> add_vaccination_status(true) ```  As well as ranges:  ``` 1..5 # [1, 2, 3, 4, 5]  “a”..”d” # [“a”, “b”, “c”, “d”] ```",0.3,d
13x2iv3,joqkhwz,"Here’s the JS version that you can play around with:  https://github.com/pinksynth/sammy-lang  It supports some fun things like piping:  ``` dog -> add_name(“spot”) -> add_vaccination_status(true) ```  As well as ranges:  ``` 1..5 # [1, 2, 3, 4, 5]  “a”..”d” # [“a”, “b”, “c”, “d”] ```",0.3,c
13x2iv3,joslvvk,"I'm continuing to work on [pliron](https://github.com/vaivaswatha/pliron) (an MLIR like extensible compiler IR framework written in Rust), and recently added infrastructure for [automatic verification of interface (trait) implementations](https://github.com/vaivaswatha/pliron/wiki/Automatically-Verifying-Implementation-of-Interfaces).",0.0,rust
13x2iv3,jp905ma,I'm considering what to tackle on my toy project that started as an idea of having a gui for a expression explorer that turned into a full blown language without any gui in a single rust file ([here if you want to check it](https://github.com/ekinimo/gui-expression-plot) .,0.1392857142857143,rust
13x2iv3,jp905ma,Since its a dynamic language i thought it would be cool to  pattern match on the identifier of structures as well.,0.175,cool
13x2iv3,jp905ma,"note that right hand side of struct definition is semantically meaningless; left hand side codifies the existence of structs via patterns               complex{_x,_y} = 1;               +(complex{_x,_y},complex{_z,_w}) = complex{_x+_z,_y+_w};     -(complex{_x,_y},complex{_z,_w}) = complex{_x-_z,_y-_w};     *(complex{_x,_y},complex{_z,_w}) = complex{_x*_z-_y*_w,_y*_z+_x*_w};          complex(_x,_y) = complex{_x,_y};     magnitude(complex{_x, _y}) = floor_sqrt(_x*_x + _y*_y);               lcm(_x,_y) = _x*_y / gcd(_x,_y);          rat{_x,_y} = 1;     +(rat{_x,_y},rat{_z,_w}) = rat{ _w * _x + _y *_z,                                     _y * _w};     -(rat{_x,_y},rat{_z,_w}) = rat{ _w*_x - _y*_z,                                     _y * _w};     *(rat{_x,_y},rat{_z,_w}) = rat{_x*_z , _w*_y};                    //matching generic structs     first( _pair{_a,_b} ) = _a;     second( _pair{_a,_b} ) = _b;          complex{0,1} * complex{0,1} ;     complex{0,1} + complex{0,1} ;          complex{3,10} * complex{5,10} ;     complex{4,1} + complex{2,12} ;                    rat{3,10} * rat{4,10} ;     rat{3,10} + rat{4,10} ;          first(rat{3,10});     first(complex{3,10});          // STRUCT PATTERN DEFINITIONS, you can encode structures with patterns               nil{_x} = 1 ;          linked{_x,nil{_y}} = 1 ;     linked{_x,linked{_y,_z}} = 1;           linked{1,linked{2,linked{3,nil{4}}}};          //FAILS Because all existing two element linked structs must end with nil/linked      linked{1,linked{2,linked{3,4}}};               push(linked{_a,_b},_c) = linked{_c,linked{_a,_b}};     push(nil{_n},_x) = linked{_x,nil{_n}};     push(_n) = nil{_n};          //Function and struct patterns can only refer to structs/variables/constants/integers          push(linked{1,linked{2,linked{3,nil{4}}}},3);          push(push(push(1),2),3);               sum(nil{_n}) = 0;     sum( linked{_x, nil{_n}}) = _x;     sum(linked{_x, linked{_y, _ys}}) = x +  sum(linked{ _y, _ys});          sum_upto(0) = 0;     sum_upto(_x) = _x + sum_upto(_x-1);               // define a function to calculate the sum of a sequence of rational numbers     sum_rat(nil{_n}) = 0;     sum_rat( linked{rat{_x, _y}, nil{_n}}) = rat{_x, _y};          sum_rat(linked{rat{_x, _y}, linked{_xs, _ys}}) = rat{_x, _y} +                                                      sum_rat(linked{ _xs, _ys});          // define a linked list of rational numbers     linked{rat{1, 2}, linked{rat{3, 4}, linked{rat{5, 6}, nil{0}}}};          // calculate the sum of the linked list of rational numbers     sum_rat(linked{rat{1, 2}, linked{rat{3, 4}, linked{rat{5, 6}, nil{_n}}}});                    // a scheme to implement mono type lists          generic_linked{_t{_x,_y},_t} = 1 ;     generic_linked{_t{_x,_y},generic_linked{_t{_w1,_w2},_z}} = 1;     generic_push(_type{_x,_y},                   _type) =                             generic_linked{                                   _type{_x,_y},                                   _type};          generic_push( generic_linked{                           _t{_w1,_w2},                             _z},                   _t{_x,_y}) = generic_linked{_t{_x,_y},generic_linked{                           _t{_w1,_w2},                             _z}};                    generic_linked{rat{0,1},            rat};               generic_linked{complex{0,1},         generic_linked{complex{0,1},            complex}};          generic_linked{rat{0,1},         generic_linked{rat{0,1},            rat}};               generic_linked{complex{0,1},            complex};          generic_linked{complex{1,1},generic_linked{rat{0,1},         generic_linked{rat{0,1},            rat}}}; // This should fail               generic_push(generic_push(complex{1,2},complex),complex{1,3});               // Lazy calls (or macros) can pattern match everything          f[_x + _y] = f[_x] - f[_y] ;     f[_x] = _x;          f[1+2+3+4+5+6+7+8];",-0.11948051948051948,scheme
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,python
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,d
13x2iv3,jmkg314,"I can relate to that, my interpreter was in Python, I switched it to D some months ago, and just now I've rewritten it to C#.",0.0,c
13x2iv3,jnrjdye,How did you find the rewrite from OCaml to Typescript?,0.0,typescript
13x2iv3,jnrkjfg,"I needed to change my grammar from what I'd _like_ to write to something else just to appease the LR gods) - in TypeScript I used a simple recursive descent - sure, probably less performant, but I had the freedom to eg.",0.11111111111111112,typescript
13x2iv3,jnrkjfg,"I am for some reason way better at using ML languages than ALGOL ones, and was having trouble getting my head around some things, like the semantics of modules, private declarations etc.",0.09999999999999999,algol
13x2iv3,jnrkjfg,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,typescript
13x2iv3,jnrkjfg,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,elm
13x2iv3,jns74ix,"The code didn't change much, probably I was writing unidiomatic D to begin with haha (C# was already my daily language).",0.13333333333333333,d
13x2iv3,jns74ix,"The code didn't change much, probably I was writing unidiomatic D to begin with haha (C# was already my daily language).",0.13333333333333333,c
13x2iv3,jns74ix,"Now I have some extra seconds of start up time (D compiler was very fast), but my interpreter is still too simple for me to be able to tell if I got a speed improvement or regression.",0.19,d
13x2iv3,jnrovs1,"I needed to change my grammar from what I'd like to write to something else just to appease the LR gods) - in TypeScript I used a simple recursive descent - sure, probably less performant, but I had the freedom to eg.",0.11111111111111112,typescript
13x2iv3,jnrovs1,"I am for some reason way better at using ML languages than ALGOL ones, and was having trouble getting my head around some things, like the semantics of modules, private declarations etc.",0.09999999999999999,algol
13x2iv3,jnrovs1,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,typescript
13x2iv3,jnrovs1,"Since theoretically TypeScript can express algebraic data types and has compile-time checking the same way as Elm does, yet I still feel much more comfortable doing big refactors and wrapping my head around things in Elm than in TS.",0.18,elm
13x2iv3,jmmido6,It’s got some cool features I’ve never seen before,0.35,cool
13woyvm,jmckrdw,"There are a few more to go as well, but thought I'd share the progress.",0.15,go
13woyvm,jmf4bnv,Implementing this kind of thing at the language level is really cool.,0.475,cool
13wopmk,jmcva5l,"Some C and C++ programmers mistakenly believe that other programmers avoid these low level languages because they are bad programmers, but it's precisely the opposite: they understand the value of ruling out as many types of errors as possible.",0.01071428571428574,c
13wopmk,jmcva5l,"Some C and C++ programmers mistakenly believe that other programmers avoid these low level languages because they are bad programmers, but it's precisely the opposite: they understand the value of ruling out as many types of errors as possible.",0.01071428571428574,c++
13wopmk,jmcve6m,"I agree with his initial point that it’s good to pick whatever language you want to use/are good at, with some guidelines based on the situation, but I also feel like his dismissal of any criticisms of C as a language choice doesn’t make as much sense.",0.39999999999999997,c
13wopmk,jmcve6m,"Like, it’s inarguable that C has both safety and expressiveness flaws that other languages improve upon to various degrees, so while sure, use C if that’s what you feel like using, I don’t see why people suggesting you use another language that avoids some of its major flaws is a bad thing.",-0.05249999999999997,c
13wopmk,jmcve6m,You can simply just not take their advice if you really want or need to use C.,0.1,c
13wopmk,jmcolqt,"I get where the author is coming from, but I think the title should be changed to something like - why you shouldn't listen to anyone telling you not to write your compiler in C",0.0,c
13wopmk,jmdkgoj,"No, C is not hard because ""manual memory management is hard"".",-0.07291666666666667,c
13wopmk,jmdkgoj,"C and C++ (despite sometimes being the only choice, e.g.",0.0,c
13wopmk,jmdkgoj,"C and C++ (despite sometimes being the only choice, e.g.",0.0,c++
13wopmk,jmdkgoj,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,c++
13wopmk,jmdkgoj,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,c
13wopmk,jmdkgoj,Can you write stable and fast code using C?,0.2,c
13wopmk,jmdkgoj,But why go through the effort when other languages have a standard library that doesn't invite using it wrong ?,-0.20833333333333334,go
13wopmk,jmdkgoj,"In the end, the important thing is that you actually write your compiler, your interpreter, your parser ...  (Disclaimer: I write C and C++ every day at work because we have no choice for our use case.",0.2,c
13wopmk,jmdkgoj,"In the end, the important thing is that you actually write your compiler, your interpreter, your parser ...  (Disclaimer: I write C and C++ every day at work because we have no choice for our use case.",0.2,c++
13wopmk,jmdkgoj,I like C++.,0.0,c++
13wopmk,jmcw959,C is **usually** a bad choice for writing a compiler.,-0.6999999999999998,c
13wopmk,jmcw959,"Of course, manual memory management, lack of features, etc are possible to make do with, and plenty of people do because they have other reasons to use C.  But it's still more difficult, more expensive, so if you're not a team of programmers working on a high speed compiler for all platforms, you absolutely should not use C. In my extremely limited experience it's quite cumbersome to write compilers and tests in C due to the lack of meaningful abstraction.",0.04896103896103896,c
13wopmk,jmdfd01,"""Real Programmers use FORTRAN.",0.2,fortran
13wopmk,jmdfd01,"Quiche Eaters use PASCAL.""",0.0,pascal
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,pascal
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,c
13wopmk,jmcprpt,"Years ago, I made a Compiler alike tool, using Procedural & Modular Pascal ( Turbo Pascal ), as a test to prove it can be used for compiler alike development, and because compiler development was too focused in Plain C and C++.",-0.21428571428571427,c++
13wopmk,jmcprpt,That was before Java & Python mainstream days.,0.0,java
13wopmk,jmcprpt,That was before Java & Python mainstream days.,0.0,python
13wopmk,jmcprpt,I could done it in Object and Class ( and Modular ) Oriented Pascal.,0.0,pascal
13wopmk,jmcprpt,"(s) done in new P.L., several are using Functional Programming, which is not a new trend, because early Lisp developers where also using it.",0.042045454545454546,lisp
13wopmk,jmcprpt,"I recently switched from Object Pascal to Plain C, for another hobbyist compiler project, for the simple reason that I need it to be portable/ crossplatform as possible, even if I preferred Object Oriented Pascal.",-0.05357142857142857,pascal
13wopmk,jmcprpt,"I recently switched from Object Pascal to Plain C, for another hobbyist compiler project, for the simple reason that I need it to be portable/ crossplatform as possible, even if I preferred Object Oriented Pascal.",-0.05357142857142857,c
13wopmk,jmi8pdq,So I do think C is a fine choice for this.,0.4166666666666667,c
13wopmk,jmi8pdq,"That said, if someone is so defensive of C that they genuinely see no downside the lack of safety, I don't really understand why they'd be motivated to design a programming language in the first place and I don't think I'd be interested in anything they produced...",0.275,c
13wopmk,jmg10j5,"Symbols almost always need to stay alive until debug info is written into the final object or assembly file, and writing the output file is the very last thing a traditional compiler does before exiting.",0.025,assembly
13whdk5,,"I wouldn’t use it personally because I like basic shit like python and JavaScript, but I’m interested in programming langauge design and want to hear the communities opinions (critical but be nice it’s obviously a long time passion project for the creator)",0.0857142857142857,python
13whdk5,,"I wouldn’t use it personally because I like basic shit like python and JavaScript, but I’m interested in programming langauge design and want to hear the communities opinions (critical but be nice it’s obviously a long time passion project for the creator)",0.0857142857142857,javascript
13whdk5,jmdk1kp,I think it's a really cool language and programming environment in general.,0.2,cool
13whdk5,jmbm7yr,"It is not however a new construct, it looks like the arithmetic `if` that used to be in Fortran (maybe it still is?",0.13636363636363635,fortran
13whdk5,jmfxc4w,">it looks like the arithmetic `if` that used to be in Fortran  Yes, the `3-way if` example was inspired by the arithmetic `if` of Fortran.",0.0,fortran
13whdk5,jmpqbyi,Seed7 was inspired by:  * The basic concepts of Pascal and Modula-2 and that they lead to a well structured compiler without complicated parsing tricks.,-0.25,pascal
13whdk5,jmpqbyi,"* The idea from Algol 68, to have some basic orthogonal concepts which can be combined.",0.0,algol
13whdk5,jmpqbyi,Algol 68 needs a 2-level syntax description and it is hard to compile.,-0.2916666666666667,algol
13whdk5,jmpqbyi,* How Ada tried to improve over Pascal with the negative consequence that parsing and compiling Ada is extremely complicated.,-0.4,ada
13whdk5,jmpqbyi,* How Ada tried to improve over Pascal with the negative consequence that parsing and compiling Ada is extremely complicated.,-0.4,pascal
13whdk5,jmpqbyi,I took the idea of exceptions from Ada and rejected its overloading concept that leads to ambiguous sub-expressions.,0.0,ada
13whdk5,jmpqbyi,* The pragmatism of C where it is important to get things done.,0.4,c
13whdk5,jmpqbyi,You don't have C dialects like in Pascal and you have a capable standard library everywhere.,0.1,c
13whdk5,jmpqbyi,You don't have C dialects like in Pascal and you have a capable standard library everywhere.,0.1,pascal
13whdk5,jmpqbyi,* The aim of Java to create libraries that are portable and independent from the world of C libraries.,0.0,java
13whdk5,jmpqbyi,* The aim of Java to create libraries that are portable and independent from the world of C libraries.,0.0,c
13whdk5,jmpqbyi,: You would import a Pascal library and the rest of the program would be in Pascal.,0.0,pascal
13whdk5,jmpqbyi,"Java did it, but these libraries require the use of the JVM.",0.0,java
13whdk5,jmpqbyi,"There are of course many C libraries, but using them directly would expose Seed7 with all the low-level C concepts that I want to avoid.",0.3,c
13whdk5,jmpqbyi,So it was necessary to create driver libraries to interface C libraries (that might also differ between operating systems).,0.0,c
13whaja,jmbnga3,"If C3 is intended as a C replacement, then surely that would make a stronger case for it.",0.5,c
13whaja,jmbnga3,"If I didn't have my own better-than-C systems language, then yes I would use C too, for all of its problems and quirks.",0.6,c
13whaja,jmcd49j,"Later, if you wish to use C or C++, you can do use the same techniques by kind of mechanically translating the ideas in your head into idiomatic C or C++.",0.19999999999999998,c
13whaja,jmcd49j,"Later, if you wish to use C or C++, you can do use the same techniques by kind of mechanically translating the ideas in your head into idiomatic C or C++.",0.19999999999999998,c++
13whaja,jmcd49j,"My recommendation for most people is to go about learning compilers in a project based fashion, regardless of language chosen (that way you can avoid the complexity trap).",0.5,go
13whaja,jmcd49j,"Then, once you see that many compilers are just a bunch of separate transformations, you can go about learning decent ways to go about each part.",0.3333333333333333,go
13whaja,jmcd49j,My issue with recommending C is how it relates to the poor way beginners go about learning compilers.,-0.4,c
13whaja,jmcd49j,My issue with recommending C is how it relates to the poor way beginners go about learning compilers.,-0.4,go
13whaja,jmcd49j,"You get these people who kind of want to create a language for novelty purposes and then design a very complex system on paper and then want to implement it all in C. These people almost always end up paralysed by analysis paralysis, riddled by the pollution of the problem domain as it appears in C, and just end up yak shaving all these silly concerns - it is not unusual in amateur circles to find people yak shaving the same old lexer or parser for months!",-0.07357142857142858,c
13whaja,jmcd49j,are fond proponents of things like using garbage collection (even in C) and using languages from the ML family.,0.0,c
13whaja,jmcd49j,"It's not correct to be like ""well, Clang uses C++, therefore C++ must be ideal for hobbyist compiler implementation"".",0.9,c++
13whaja,jmdmgii,"No, C is not hard because ""manual memory management is hard"".",-0.07291666666666667,c
13whaja,jmdmgii,"C and C++ (despite sometimes being the only choice, e.g.",0.0,c
13whaja,jmdmgii,"C and C++ (despite sometimes being the only choice, e.g.",0.0,c++
13whaja,jmdmgii,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,c++
13whaja,jmdmgii,"And then there is the mistaken belief that C++ was a speed-first language, which hasn't been true since the backwards-compatibility faction of the C and C++ committees won ... oh, 15 years ago?",0.35,c
13whaja,jmdmgii,Can you write stable and fast code using C?,0.2,c
13whaja,jmdmgii,But why go through the effort when other languages have a standard library that doesn't invite using it wrong ?,-0.20833333333333334,go
13whaja,jmdmgii,(Disclaimer: I write C and C++ every day at work because we have no choice for our use case.,0.0,c
13whaja,jmdmgii,(Disclaimer: I write C and C++ every day at work because we have no choice for our use case.,0.0,c++
13whaja,jmdmgii,I like C++.,0.0,c++
13whaja,jmbljy0,"> The C3 compiler is written in C, and there is frankly no other language I could have picked that would have been a substantially better choice.",0.28125,c
13whaja,jmbljy0,"The vast majority of the heavy lifting is done by LLVM and, yet, this project is still over 65kLOC of C code.",-0.1,c
13whaja,jmbljy0,"Tens of thousands of lines of code like this:                  case BINARYOP_BIT_OR:                         if (lhs.type->type_kind == TYPE_ARRAY)                         {                                 llvm_emit_bitstruct_binary_op(c, be_value, &lhs, &rhs, binary_op);                                 return;                         }                         val = LLVMBuildOr(c->builder, lhs_value, rhs_value, ""or"");                         break;                 case BINARYOP_BIT_XOR:                         if (lhs.type->type_kind == TYPE_ARRAY)                         {                                 llvm_emit_bitstruct_binary_op(c, be_value, &lhs, &rhs, binary_op);                                 return;                         }                         val = LLVMBuildXor(c->builder, lhs_value, rhs_value, ""xor"");                         break;                 case BINARYOP_ELSE:                 case BINARYOP_EQ:                 case BINARYOP_NE:                 case BINARYOP_GE:                 case BINARYOP_GT:                 case BINARYOP_LE:                 case BINARYOP_LT:                 case BINARYOP_AND:                 case BINARYOP_OR:                 case BINARYOP_ASSIGN:                 case BINARYOP_MULT_ASSIGN:                 case BINARYOP_ADD_ASSIGN:                 case BINARYOP_SUB_ASSIGN:                 case BINARYOP_DIV_ASSIGN:                 case BINARYOP_MOD_ASSIGN:                 case BINARYOP_BIT_AND_ASSIGN:                 case BINARYOP_BIT_OR_ASSIGN:                 case BINARYOP_BIT_XOR_ASSIGN:                 case BINARYOP_SHR_ASSIGN:                 case BINARYOP_SHL_ASSIGN:                         // Handled elsewhere.",0.0,c
13whaja,jmbljy0,A hand-rolled parser (no lex/yacc) including 222 lines of C code to parse an int.,0.0,c
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,haskell
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,swift
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,rust
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,scala
13whaja,jmbljy0,"Almost any other modern language (Haskell, OCaml, Swift, Rust, Scala, SML...) would have been a better choice than C for this task.",0.19166666666666665,c
13whaja,jmbljy0,"Even if I was forced to use C I'd at least use `flex`, `bison` and as many libraries as I can get for all the tedious string manipulation and conversion.",-0.15000000000000002,c
13whaja,jmcoxgl,"I get where the author is coming from, but I think the title should be changed to something like - why you shouldn't listen to anyone telling you not to write your compiler in C..",0.0,c
13whaja,jmbfxoj,"> And doing an OO-style C++, or worse, Java, would just have pushed the compiler to slower and more bloated, with no additional benefits ...",0.04999999999999999,c++
13whaja,jmbfxoj,"> And doing an OO-style C++, or worse, Java, would just have pushed the compiler to slower and more bloated, with no additional benefits ...",0.04999999999999999,java
13whaja,jmbfxoj,"I agree with Java (because of all dynamic allocation overhead and JVM dependency), but C++ is very well suited for compiler implementation (neither slower nor bloated, but easier to maintain) when moderately and judiciously used.",0.06666666666666667,java
13whaja,jmbfxoj,"I agree with Java (because of all dynamic allocation overhead and JVM dependency), but C++ is very well suited for compiler implementation (neither slower nor bloated, but easier to maintain) when moderately and judiciously used.",0.06666666666666667,c++
13whaja,jmbfxoj,"I used both - C and C++ - to write compilers; both work well for the purpuse, but the latter makes a lot of things easier.",0.0,c
13whaja,jmbfxoj,"I used both - C and C++ - to write compilers; both work well for the purpuse, but the latter makes a lot of things easier.",0.0,c++
13whaja,jmbfxoj,"EDIT: just had a look at the C3 language; looks interesting, a bit like Oberon+ with a C syntax ;-) Nice to see that generic modules are considered useful by more language designers.",0.3583333333333334,c
13whaja,jmbfxoj,The LLVM backend looks a bit like a kludge; why not just a C cross-compiler?,0.0,c
13whaja,jmbnorn,"If there is a case where “use C to implement your language” is good advice, it’s probably limited to people who are writing languages that are similar to C.  “You can do anything in C if you’re good enough” is not an argument I usually expect from people who are investing effort into creating new languages.",0.1735621521335807,c
13whaja,jmbq5kh,">  > If C3 is intended as a C replacement, then surely that would make a stronger case for it.",0.5,c
13whaja,jmcfd0q,"What I **don't** like is when someone comes in and says *""I want to write a compiler and I'm thinking of doing it in C""* and then someone just vomits their opinions all over the whole discussion claiming it's impossible to write compilers in C, and how if you don't have feature X (usually pattern matching and sum types are listed as the magical components needed) it's impossible to write a compiler.",-0.17666666666666664,c
13whaja,jmcfd0q,"That said, I know a lot of people trying out in particular *Rust* as a language to implement languages in because everyone is recommending it.",0.16666666666666666,rust
13whaja,jmcfd0q,And then they try to learn Rust and implement a compiler at the same time.,0.0,rust
13whaja,jmcfd0q,"In the case of C, there is a very gentle introduction to creating a compiler in C with Crafting Interpreters.",0.26,c
13whaja,jmcfd0q,Following that makes C a breeze to use.,0.0,c
13whaja,jmcfd0q,"Maybe if someone had written something similar in Rust then learning compilers and learning Rust at the same time would be more successful for people, but we're not there yet.",0.3125,rust
13whaja,jmcfd0q,So for that you'd stay away from C and so on.,0.0,c
13whaja,jmmptt3,"I personally do think that C is better them what you might think, given that a compiler is actually not heavyly involved in string processing.",0.16666666666666666,c
13whaja,jmmptt3,"The biggest issue with C IMO is that you have no structural matching and ADTs and have to emulate these features on a near constant base, since transfering ADTs is indeed a core part of a compiler.",-0.23333333333333336,c
13whaja,jmc51bt,>A hand-rolled parser (no lex/yacc) including 222 lines of C code to parse an int.,0.0,c
13whaja,jmc51bt,"I can save 20 lines on mine by using C's `strtod` to turn text into a float, once it has been isolated and freed of separators etc.",0.0,c
13whaja,jmbrra5,SURELY that is just some bad requirement by C?,-0.09999999999999992,c
13whaja,jmbrra5,"C surely doesn't have a `DEFAULT` statement, right?",0.39285714285714285,c
13whaja,jmbpu8w,i agree and that's why usually firstly write the stage1 in python and than the stage2 in the language itself,0.25,python
13whaja,jmbsqrw,"I worked with lowering to C, and while it has advantages, it also gives you less control and more need for additional installs.",0.16666666666666669,c
13whaja,jmcch93,> C++ is very well suited for compiler implementation  Tree rewriting is tedious in C++ due to the lack of sum types and pattern matching.,-0.14166666666666666,c++
13whaja,jmbg2f8,"Yes, I agree and that's why I qualified it, writing ""OO-style C++"" and not ""C++""",0.0,c++
13whaja,jmbpmdz,"> If there is a case where “use C to implement your language” is good advice, it’s probably limited to people who are writing languages that are similar to C.  That doesn't follow.",0.20952380952380953,c
13whaja,jmbpmdz,Only really esoteric languages like BF offer comparably-complicated implementations in C and other languages.,0.025000000000000005,c
13whaja,jmcilgc,"It cannot be argued that it's the most productive to go about certain parts of compilers in C. If we look at a screenshot from Andrew Appel's book ""Modern Compiler Implementation in C"":  [https://i.imgur.com/zEFlfIy.png](https://i.imgur.com/zEFlfIy.png)  You can see that it's basically matching over the structure of a tagged union encoding of the IR trees (as part of how to do tree tiling instruction selection), right.",0.09000000000000001,go
13whaja,jmcilgc,"It cannot be argued that it's the most productive to go about certain parts of compilers in C. If we look at a screenshot from Andrew Appel's book ""Modern Compiler Implementation in C"":  [https://i.imgur.com/zEFlfIy.png](https://i.imgur.com/zEFlfIy.png)  You can see that it's basically matching over the structure of a tagged union encoding of the IR trees (as part of how to do tree tiling instruction selection), right.",0.09000000000000001,c
13whaja,jmcilgc,"Although, it can just be written directly in OCaml, Standard ML, Haskell, Scala, etc.",0.05,haskell
13whaja,jmcilgc,"Although, it can just be written directly in OCaml, Standard ML, Haskell, Scala, etc.",0.05,scala
13whaja,jmcilgc,"it's also far less error prone and potentially will yield more efficient matchers when done in those languages as well (match compilation algorithms usually out-do humans writing manual switch cases for many nested patterns, as matchers go in parallel and produce a fairly optimised decision DAG).",0.17291666666666666,go
13whaja,jmcilgc,"So, as much as I agree that it's possible, it's by no means the most illuminating, productive, or maintainable approach to take (using C).",0.2333333333333333,c
13whaja,jmcilgc,"I usually don't actively dissuade people already using C, but it is painful to avoid the classic ""in OCaml, this is just..."" replies.",-0.2222222222222222,c
13whaja,jmumjz3,"_Note: the C and C++ compilation models are a bit ""odd"", since each file leads to a separate process invocation.",-0.16666666666666666,c
13whaja,jmumjz3,"_Note: the C and C++ compilation models are a bit ""odd"", since each file leads to a separate process invocation.",-0.16666666666666666,c++
13whaja,jmc7y14,I get why some people want to bootstrap their minimalistic language in asm by hand: it is cool.,0.35,cool
13whaja,jmc7y14,"> I can save 20 lines on mine by using C's strtod to turn text into a float, once it has been isolated and freed of separators etc.",0.0,c
13whaja,jmc7y14,There must be C libraries that already do almost all of this for you.,0.0,c
13whaja,jmc7y14,Maybe if you want to support some exotic number representation you'll need to write an extra line of code but writing 222 lines of code and then concluding that C rules is lunacy.,0.25,c
13whaja,jmc9tl5,"As soon as you step outside the features of C, LLVM is flakey, e.g.",0.0,c
13whaja,jmcb66r,Even if I was writing that in C I'd use `flex` and a string conversion library.,0.0,c
13whaja,jmcb66r,SURELY that is just some bad requirement by C?,-0.09999999999999992,c
13whaja,jmcb66r,"C surely doesn't have a DEFAULT statement, right?",0.39285714285714285,c
13whaja,jmcb66r,Hence your argument that C is blub doesn't hold water.,0.0,c
13whaja,jmbv6wy,C has had a default statement since K&R.,0.0,c
13whaja,jmbv6wy,C has had a default statement since K&R.,0.0,r
13whaja,jmcya2a,"> Tree rewriting is tedious in C++  What language would you then recommend for this purpose, and can you reference an example which demonstrates the specific advantage compared to C++?",-0.25,c++
13whaja,jmbg99g,Even OO-style C++ is ok when judiciously used; e.g.,0.5,c++
13whaja,jmcnuvz,Someone who really wants a “better C” is unlikely to enjoy writing their compiler in Haskell and someone who wants dependent types is unlikely to enjoy writing it in C. This is a coarse generalization of course.,0.08750000000000001,c
13whaja,jmcnuvz,Someone who really wants a “better C” is unlikely to enjoy writing their compiler in Haskell and someone who wants dependent types is unlikely to enjoy writing it in C. This is a coarse generalization of course.,0.08750000000000001,haskell
13whaja,jmcoekc,"I don't know if the code in ""Modern Compiler Implementation in C"" is a good argument against C, given that it supposedly had all C auto-translated from the original ML sources or some such.",0.31875,c
13whaja,jmcoekc,""");         int thenJump = emitJump(OP_JUMP_IF_FALSE);       statement();        patchJump(thenJump);     }  Here is a snippet from my parser, I would also say that I am hard pressed to simplify this much further in another language:      static Expr *parse_orelse(ParseContext *c, Expr *left_side)     {        assert(left_side && expr_ok(left_side));       advance_and_verify(c, TOKEN_QUESTQUEST);            Expr *right_side;       // Assignment operators have precedence right -> left.",0.0988095238095238,c
13whaja,jmcoekc,"ASSIGN_EXPR_OR_RET(right_side, parse_precedence(c, PREC_TERNARY), poisoned_expr);            Expr *expr = expr_new_expr(EXPR_BINARY, left_side);       expr->binary_expr.operator = BINARYOP_ELSE;       expr->binary_expr.left = exprid(left_side);       expr->binary_expr.right = exprid(right_side);            RANGE_EXTEND_PREV(expr);       return expr;     }",0.0,c
13whaja,jmd37sy,"In mine, the loop that accumulates an integer values uses `a` to hold that value, `c` which contains the next input character, and `lxsptr` pointing to the input stream.",0.0,c
13whaja,jmdv5z9,"When I once attempted a C compiler from scratch, I spent around 90 days, for an indifferent result that could nevertheless turn some C source programs into runnable binaries for x64.",-0.1,c
13whaja,jmdv5z9,"(I was able to build and run Lua, Seed7 and SQLite3 - nearly half a million lines - with varying success.)",0.2111111111111111,lua
13whaja,jmdv5z9,Including 1.5 to 3 days to write a full C preprocessor.,0.35,c
13whaja,jmdv5z9,"My actual C compiler is a 100% self-contained 1MB executable, and compiles C code at about half the speed of Tiny C.",-0.05555555555555555,c
13whaja,jmccp0x,"LLVM IR is more of an assembly language for a generic machine, while C is a portable language abstracting PDP-like machines.",0.25,assembly
13whaja,jmccp0x,"LLVM IR is more of an assembly language for a generic machine, while C is a portable language abstracting PDP-like machines.",0.25,c
13whaja,jmccp0x,"Rust targets LLVM IR as well, does it make LLVM IR a Rust-like language?",0.0,rust
13whaja,jmccp0x,"You can do oneliners in Haskell that are unreadable but would take 10 lines of human readable C.  If I need Haskell's features, I'll choose Haskell.",0.0,haskell
13whaja,jmccp0x,"If I need C's features, I'll choose C. LOC is not a feature.",0.0,c
13whaja,jmcd0mw,>Even if I was writing that in C I'd use flex and a string conversion library.,0.0,c
13whaja,jmbws6m,"With additional installs I mean that if one lowers to C, a C compiler needs to be installed for the platform, and on several platforms that means a lot of downloads.",-0.15625,c
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,haskell
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,rust
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,swift
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,scala
13whaja,jmd2lz0,"OCaml, SML, Haskell, Rust, Swift, Scala, Kotlin.",0.0,kotlin
13whaja,jmd2lz0,Scheme and Lisp have good libraries to help with this.,0.7,scheme
13whaja,jmd2lz0,Scheme and Lisp have good libraries to help with this.,0.7,lisp
13whaja,jmd2lz0,> and can you reference an example which demonstrates the specific advantage compared to C++?,0.0,c++
13whaja,jmcql6k,"The C wasn't auto translated, not that part of the book anyway.",0.0,c
13whaja,jmcql6k,"Crafting Interpreters also doesn't do any good techniques for teaching instruction selection and is far simpler than real targets, so doesn't need to describe techniques that may permit better selection (for example compilers targeting ARM may wish that `mul a, b, c; add a, a, d;` become a single `madd`/`mla`).",0.2857142857142857,c
13whaja,jmcql6k,"Crafting Interpreters also doesn't do any good techniques for teaching instruction selection and is far simpler than real targets, so doesn't need to describe techniques that may permit better selection (for example compilers targeting ARM may wish that `mul a, b, c; add a, a, d;` become a single `madd`/`mla`).",0.2857142857142857,d
13whaja,jmcql6k,"Most people dissuading people from C aren't saying it's impossible, they just don't want them to spend so long doing it (I'm sure you have your own articles where you've pondered C3's design for over a decade).",0.17666666666666667,c
13whaja,jme6tp4,"However, few are written in C.  The nearest I can think of is something like a [C parser written in OCaml](https://github.com/jhjourdan/C11parser) or the static analyzer [Frama-C](https://frama-c.com/).",0.15,c
13whaja,jme6tp4,"Even if there were, who is to say that two C compilers are comparable?",0.0,c
13whaja,jme6tp4,OCaml vs C for a decent sized program should be comparable.,0.16666666666666666,c
13whaja,jme6tp4,C is likely to be much slower in a first cut but has the potential to be ~3x faster than OCaml if you devote enough time to optimising it.,0.09,c
13whaja,jme6tp4,"> When I once attempted a C compiler from scratch, I spent around 90 days, for an indifferent result that could nevertheless turn some C source programs into runnable binaries for x64.",-0.1,c
13whaja,jme6tp4,"(I was able to build and run Lua, Seed7 and SQLite3 - nearly half a million lines - with varying success.)",0.2111111111111111,lua
13whaja,jme6tp4,That's incredible and a great target but I don't know of anyone writing C compilers in OCaml.,0.8500000000000001,c
13whaja,jme6tp4,"Rust was originally written in OCaml but I don't know of anyone rewriting it in C.  > Applying that factor, I would have been able to do that in 5-10 days?",0.4375,rust
13whaja,jme6tp4,Including 1.5 to 3 days to write a full C preprocessor.,0.35,c
13whaja,jme6tp4,If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,c
13whaja,jme6tp4,Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,c
13whaja,jme6tp4,"> My actual C compiler is a 100% self-contained 1MB executable, and compiles C code at about half the speed of Tiny C.  That's awesome but surely when you look at your compiler you see lots of repeating patterns in the code?",0.2666666666666667,c
13whaja,jmcf8ra,"> LLVM IR is more of an assembly language for a generic machine,  Let's look at the features:  * Functions (C and LLVM IR but not asm).",0.25,assembly
13whaja,jmcf8ra,"> LLVM IR is more of an assembly language for a generic machine,  Let's look at the features:  * Functions (C and LLVM IR but not asm).",0.25,c
13whaja,jmcf8ra,* Arguments (C and LLVM IR but not asm).,0.0,c
13whaja,jmcf8ra,* Return value (C and LLVM IR but not asm).,0.0,c
13whaja,jmcf8ra,* Structs (C and LLVM IR but not asm).,0.0,c
13whaja,jmcf8ra,* Only fixed-width registers (asm but neither C nor LLVM IR).,0.0,c
13whaja,jmcf8ra,* Arbitrary jumps (asm but neither C nor LLVM IR).,-0.1,c
13whaja,jmcf8ra,* Raw stack (asm but neither C nor LLVM IR).,-0.23076923076923078,c
13whaja,jmcf8ra,LLVM IR is just a parsed and sanitised C with some additions like extra calling conventions and optional TCO.,0.0,c
13whaja,jmcf8ra,How many assembly languages do you know where a single register had hold an arbitrarily complicated data structure?,-0.023809523809523798,assembly
13whaja,jmcf8ra,"You can do oneliners in Haskell that are unreadable but would take 10 lines of human readable C. >  > If I need Haskell's features, I'll choose Haskell.",0.0,haskell
13whaja,jmcf8ra,"If I need C's features, I'll choose C. LOC is not a feature.",0.0,c
13whaja,jmbxul2,> a C compiler needs to be installed for the platform  Not sure whether this is a valid point; never came across a platform where there wasn't a standard C compiler easily available; even C++98 is virtually available everywhere with little effort; after all that's the main reason why e.g.,0.08819444444444445,c
13whaja,jmbxul2,I am using C or C++ for my compilers.,0.0,c
13whaja,jmbxul2,I am using C or C++ for my compilers.,0.0,c++
13whaja,jmd2jk3,"Products and sum types are ADTs, and C++ have both.",0.0,c++
13whaja,jmd2jk3,"- `std::variant` is the equivalent to Rust enums  - `std::optional` is the Maybe monad  - `std::expected` is the Either monad  By your logic, Rust enums and the Maybe/Either monads are the poor man's sum types.",-0.4,rust
13whaja,jmd2jk3,"In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,rust
13whaja,jmd2jk3,"In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,haskell
13whaja,jmd2jk3,"`std::holds_alternative` and `std::get` are the equivalent of Rust's `if let` expressions, which are a form of pattern matching.",0.0,rust
13whaja,jmbueco,"Well, LLVM is not exactly an example of ""moderate"" C++, is it?",-0.0625,c++
13whaja,jme6p3q,"But I mind people saying ""It's impossible to write a compiler in C, there isn't a worse choice, you need to have sum types and pattern matching to write a compiler"".",-0.5333333333333333,c
13whaja,jmeeo3v,>If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,c
13whaja,jmeeo3v,"You could just use an existing C compiler, it would be even quicker!",0.0,c
13whaja,jmeeo3v,>Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,c
13whaja,jmeeo3v,I could write a long article on what makes C hard to compile.,-0.17083333333333334,c
13whaja,jmeeo3v,"Plus, and this is the bit that takes man-years, is ensuring it will work for the billions of lines of existing C code.",0.0,c
13whaja,jmeeo3v,(So much for C being portable!),0.25,c
13whaja,jmch0o8,"Even so, many features you listed are available in many programming and assembly languages that are nothing like C.  Your argument is not holding up to reality.",0.4666666666666666,assembly
13whaja,jmcgjxq,LLVM doesn't implement the C ABI aside from placing things in the right registers.,0.2857142857142857,c
13whaja,jmcgjxq,LLVM has no concept of unions (which makes implementing some parts of C very very gnarly) 3.,0.26,c
13whaja,jmcgjxq,"Saying ""LLVM IR is like C"" is frankly a clown.",0.0,c
13whaja,jmeearg,Like Rust and Swift that both clock in at about 50% of the time spent in the frontend.,-0.1,rust
13whaja,jmeearg,Like Rust and Swift that both clock in at about 50% of the time spent in the frontend.,-0.1,swift
13whaja,jmbz03i,\> Not sure whether this is a valid point; never came across a platform where there wasn't a standard C compiler easily available  Windows requires downloading MSVC or doing things through Mingw which is a problem in itself.,0.05000000000000001,c
13whaja,jmd5fwy,"Can you speak to the ergonomics of C++ features such as using `std::variant` for full encoding of ASTs, type representations, etc.",0.175,c++
13whaja,jmd5fwy,"Tells me a lot that your language is written in Rust and not C++, in spite of the fact you've noted C++ does have pretty poor versions of all of the things mentioned.",-0.07500000000000001,rust
13whaja,jmd5fwy,"Tells me a lot that your language is written in Rust and not C++, in spite of the fact you've noted C++ does have pretty poor versions of all of the things mentioned.",-0.07500000000000001,c++
13whaja,jmd7b13,"> Products and sum types are ADTs, and C++ have both.",0.0,c++
13whaja,jmd7b13,> std::variant is the equivalent to Rust enums > std::optional is the Maybe monad > std::expected is the Either monad  In a loose sense.,-0.07692307692307693,rust
13whaja,jmd7b13,"> By your logic, Rust enums and the Maybe/Either monads are the poor man's sum types.",-0.4,rust
13whaja,jmd7b13,"This is getting off topic but, FWIW, the issue with Rust in this context is the inability to pattern match through an `Rc`.",0.0,rust
13whaja,jmd7b13,"> In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,rust
13whaja,jmd7b13,"> In Rust, you would have a trait and static dispatch, in Haskell you would have a typeclass and instances of that class.",0.5,haskell
13whaja,jmd7b13,Both Rust and Haskell have actual sum types and pattern matching with few limitations.,-0.1,rust
13whaja,jmd7b13,Both Rust and Haskell have actual sum types and pattern matching with few limitations.,-0.1,haskell
13whaja,jmd7b13,"> std::holds_alternative and std::get are the equivalent of Rust's if let expressions, which are a form of pattern matching.",0.0,rust
13whaja,jmd7b13,"Here's a little OCaml function to locally rebalance a red-black tree:      let balance = function       | `Black, z, `Node(`Red, y, `Node(`Red, x, a, b), c), d       | `Black, z, `Node(`Red, x, a, `Node(`Red, y, b, c)), d       | `Black, x, a, `Node(`Red, z, `Node(`Red, y, b, c), d)       | `Black, x, a, `Node(`Red, y, b, `Node(`Red, z, c, d)) ->           `Node(`Red, y, `Node(`Black, x, a, b), `Node(`Black, z, c, d))       | a, b, c, d -> `Node(a, b, c, d)  Please can you translate those 7 lines of sum types and pattern matches into C++ using `std::variant` and `std::visit`?",-0.14236111111111108,c
13whaja,jmd7b13,"Here's a little OCaml function to locally rebalance a red-black tree:      let balance = function       | `Black, z, `Node(`Red, y, `Node(`Red, x, a, b), c), d       | `Black, z, `Node(`Red, x, a, `Node(`Red, y, b, c)), d       | `Black, x, a, `Node(`Red, z, `Node(`Red, y, b, c), d)       | `Black, x, a, `Node(`Red, y, b, `Node(`Red, z, c, d)) ->           `Node(`Red, y, `Node(`Black, x, a, b), `Node(`Black, z, c, d))       | a, b, c, d -> `Node(a, b, c, d)  Please can you translate those 7 lines of sum types and pattern matches into C++ using `std::variant` and `std::visit`?",-0.14236111111111108,d
13whaja,jmd7b13,"Here's a little OCaml function to locally rebalance a red-black tree:      let balance = function       | `Black, z, `Node(`Red, y, `Node(`Red, x, a, b), c), d       | `Black, z, `Node(`Red, x, a, `Node(`Red, y, b, c)), d       | `Black, x, a, `Node(`Red, z, `Node(`Red, y, b, c), d)       | `Black, x, a, `Node(`Red, y, b, `Node(`Red, z, c, d)) ->           `Node(`Red, y, `Node(`Black, x, a, b), `Node(`Black, z, c, d))       | a, b, c, d -> `Node(a, b, c, d)  Please can you translate those 7 lines of sum types and pattern matches into C++ using `std::variant` and `std::visit`?",-0.14236111111111108,c++
13whaja,jmd7b13,That would be great but I've been hearing that C++ is about to get these features for 20 years now...,0.8,c++
13whaja,jmbvwbz,"It's an example of ""by the book"" C++ OO.",0.0,c++
13whaja,jmew4hr,I've done a few in C (I think you saw my 99-line JIT).,-0.2,c
13whaja,jmew4hr,> > If you use an existing C parser written in OCaml and LLVM I expect you could get a C compiler up and running in a day.,0.0,c
13whaja,jmew4hr,"You could just use an existing C compiler, it would be even quicker!",0.0,c
13whaja,jmew4hr,>  > > Doing it from scratch would be hard though and parsing C is gnarly.,-0.2916666666666667,c
13whaja,jmew4hr,>  > I could write a long article on what makes C hard to compile.,-0.17083333333333334,c
13whaja,jmew4hr,"Plus, and this is the bit that takes man-years, is ensuring it will work for the billions of lines of existing C code.",0.0,c
13whaja,jmew4hr,(So much for C being portable!),0.25,c
13whaja,jmew4hr,I suppose C is a different kettle of fish.,0.0,c
13whaja,jmcyi2k,In C functions accept many values but can return only one value.,0.25,c
13whaja,jmcyi2k,"> Even so, many features you listed are available in many programming and assembly languages that are nothing like C.  You didn't say ""programming languages unlike C"".",0.4666666666666666,assembly
13whaja,jmcyi2k,"> Even so, many features you listed are available in many programming and assembly languages that are nothing like C.  You didn't say ""programming languages unlike C"".",0.4666666666666666,c
13whaja,jmcyi2k,"You said specifically [""LLVM IR is more of an assembly language for a generic machine""](https://www.reddit.com/r/ProgrammingLanguages/comments/13whaja/language_design_bullshitters/jmccp0x/).",0.25,assembly
13whaja,jmcyi2k,Functions and structs alone put LLVM IR much closer to C than any asm.,0.2,c
13whaja,jmcx4xl,> LLVM doesn't implement the C ABI aside from placing things in the right registers.,0.2857142857142857,c
13whaja,jmcx4xl,"> LLVM has no concept of unions (which makes implementing some parts of C very very gnarly)  Well, ok. You bitcast between structs to emulate unions.",0.38,c
13whaja,jmcx4xl,My point is that they're C style not tagged or discriminated unions like sum types in most modern languages.,0.35,c
13whaja,jmcx4xl,> LLVM IR is in SSA form  True but neither C nor asm are SSA.,0.35,c
13whaja,jmcx4xl,> LLVM IR is built around basic blocks  Ok but how is that more like asm and less like C?,0.20833333333333334,c
13whaja,jmcx4xl,C has block statements.,0.0,c
13whaja,jmcx4xl,In C and LLVM they cannot.,0.0,c
13whaja,jmd7bh7,"My language (letlang) is written in Rust because of the ecosystem: logos, rust-peg, etc...  Not because of the language's syntax and features.",0.0,rust
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,haskell
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,c++
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,erlang
13whaja,jmd7bh7,"I can have sum types and pattern matching in Haskell, Ocaml, C++, Erlang, Elixir, etc...",0.0,elixir
13whaja,jmd7bh7,"The first draft of my language was done in Python, prior to the \`match\` statement.",0.125,python
13whaja,jmd7bh7,"My choice of Rust is not based on the syntax/features of the language, therefore it does not invalidate my argument.",0.0,rust
13whaja,jmczytr,"Not by your ridiculous standards, still that's what they are, and that's what C functions are usually translated to (if not inlined).",-0.29166666666666663,c
13whaja,jmczytr,"> You didn't say ""programming languages unlike C""  ""programming and assembly"", at least quote me correctly.",-0.3,c
13whaja,jmczytr,"> You didn't say ""programming languages unlike C""  ""programming and assembly"", at least quote me correctly.",-0.3,assembly
13whaja,jmczytr,"And yes, I stand by it: LLVM is more an assembly languages, AND the features you listed are available in many programming AND ASSEMBLY languages.",0.4666666666666666,assembly
13whaja,jmczytr,> Functions and structs alone put LLVM IR much closer to C than any asm  [HighLevel ASM records](https://www.plantation-productions.com/Webster/HighLevelAsm/HLADoc/HLARef/HLARef_html/HLAReference.htm#pgfId-1003858) disagree with you.,0.2,c
13whaja,jmdv5ng,"CCC does not implement the C ABI, It just packs things in the right registers.",0.2857142857142857,c
13whaja,jmdv5ng,My point is that they're C style  Being able to bitcast between types is not doing C unions.,0.5,c
13whaja,jmdv5ng,"Oh, so you think this is equivalent to C scopes?",0.0,c
13whaja,jmdv5ng,"> Ok but how is that more like asm and less like C  You're the one suggesting that the transformation C -> LLVM IR was a trivial one, not me.",0.2777777777777778,c
13whaja,jmdv5ng,In C and LLVM they cannot.,0.0,c
13whaja,jmd9xsy,"Yet, in response, they get replies that sometimes imply it's not tedious (""but.. but.. C++ has a shit version of this"").",0.024999999999999994,c++
13whaja,jmca4n1,"Nor is it my favourite, but hopefully this explains why I was saying ""OO C++"" is a bad idea with this definition of ""OO C++""",-0.6999999999999998,c++
13whaja,jmdb8zw,"Not by your ridiculous standards, still that's what they are, and that's what C functions are usually translated to (if not inlined).",-0.29166666666666663,c
13whaja,jmdb8zw,"The fact that C functions are usually translated to labels, calls and returns does not mean labels, calls and returns are functions.",-0.046875,c
13whaja,jmdb8zw,"> > You said specifically [""LLVM IR is more of an assembly language for a generic machine""](https://www.reddit.com/r/ProgrammingLanguages/comments/13whaja/language_design_bullshitters/jmccp0x/).",0.25,assembly
13whaja,jmdb8zw,">  > ""programming and assembly"", at least quote me correctly.",-0.3,assembly
13whaja,jme1zwh,">  > CCC does not implement the C ABI, It just packs things in the right registers.",0.2857142857142857,c
13whaja,jme1zwh,">  > Oh, so you think this is equivalent to C scopes?",0.0,c
13whaja,jme1zwh,"> > > LLVM IR is built around basic blocks > > > > Ok but how is that more like asm and less like C >  > You're the one suggesting that the transformation C -> LLVM IR was a trivial one, not me.",0.20833333333333334,c
13whaja,jme1zwh,Then we agree that LLVM IR being built around basic blocks does not make it more of an assembly language.,0.25,assembly
13whaja,jme1zwh,In C and LLVM they cannot.,0.0,c
13whaja,jme7wzp,"The problem is when someone asks ""how do I solve this problem in my compiler written in C?""",0.0,c
13whaja,jme7wzp,"and the answer is ""You can't write a compiler in C, you should use Rust or Ocaml!""",0.0,c
13whaja,jme7wzp,"and the answer is ""You can't write a compiler in C, you should use Rust or Ocaml!""",0.0,rust
13whaja,jme3z49,When I said that LLVM doesn't have scopes I am referring to C nestable scopes.,0.0,c
13w4l1z,,My goal is to have enough knowledge to try building a compiler for a simple functional programming language (something similar to Haskell or Ocaml I gusss?),0.0,haskell
13w4l1z,jm9we7j,"Boom, now you have most of Scheme.",0.5,scheme
13w4l1z,jmau3c2,"If you do decide to go that route, feel free to DM me for clarification on anything up to Chapter 15.",0.4,go
13w4l1z,jmf2kht,"Go back and read about System F, universal/existential types, and higher-order polymorphism.",0.0,go
13w4l1z,jmf2kht,"Note that implementing something like Haskell or OCaml would require learning about modules/typeclasses, but at that point you'll have enough knowledge to find those resources yourself.",0.0,haskell
13w4l1z,jmami22,"Elixir and Rust also have hygienic macros, if I’m not mistaken.",0.0,elixir
13w4l1z,jmami22,"Elixir and Rust also have hygienic macros, if I’m not mistaken.",0.0,rust
13w4l1z,jmami22,"I know elixir does, and a friend I trust told me rust has racket macros.",0.0,elixir
13w4l1z,jmami22,"I know elixir does, and a friend I trust told me rust has racket macros.",0.0,rust
13w4l1z,jmf2d6q,"They're significantly better than C's preprocessor macros, but they are not quite as robust as Racket's.",0.5,c
13w4l1z,jmf2d6q,"(A few searches indicate that Rust's macros are not hygienic over things like type parameters or something, and Elixir's fall short because their hygiene is rooted in a late resolution system.",-0.16666666666666666,rust
13w4l1z,jmf2d6q,"(A few searches indicate that Rust's macros are not hygienic over things like type parameters or something, and Elixir's fall short because their hygiene is rooted in a late resolution system.",-0.16666666666666666,elixir
13w3cw3,jmd8op6,"I recommend being familiar with both and the relevant literature prior to these papers you've linked: see TIL and David Tarditi's PhD thesis, see Compiling with Continuations, look at MLton's IRs, look at Haskell's Core language, etc.",0.25833333333333336,haskell
13w2oya,jmax0da,"C is faster in terms of execution time, not development time.",0.0,c
13w2oya,jmax0da,"No one has ever said ""I'll develop this in C because it will take me half the time"".",-0.16666666666666666,c
13w2oya,jmax0da,"If anything C should be a good example of this, where you choose a programming language that's less productive in order to benefit in terms of performance once the project is complete.",0.2111111111111111,c
13w2oya,jmb35jf,"From a language perspective Java is lacking, there is no doubt.",0.0,java
13w2oya,jmb35jf,But nowadays tooling exists (and is widely used) to make the boilerplate go away.,-0.1,go
13w2oya,jmb35jf,"When I see seasoned Java developers move to Kotlin which also makes it very easy, I still observe old patterns being followed: mutable state and huge objects.",0.32833333333333337,java
13w2oya,jmb35jf,"When I see seasoned Java developers move to Kotlin which also makes it very easy, I still observe old patterns being followed: mutable state and huge objects.",0.32833333333333337,kotlin
13w2oya,jmb35jf,Whereas the Scala code bases I have seen are much better.,0.5,scala
13vxdez,jm8h03p,I have been working on something with similar goals (also in Haskell!,0.0,haskell
13vxdez,jm8h03p,Trying to hash pure lambda expressions is like trying to hash executable assembly - at some point we go from functional equivalence to structural equivalence.,0.21428571428571427,assembly
13vxdez,jm8h03p,Trying to hash pure lambda expressions is like trying to hash executable assembly - at some point we go from functional equivalence to structural equivalence.,0.21428571428571427,go
13vxdez,jm91nro,"This should be fairly equivalent to your example hashing scheme:  ```haskell data TermF r = Abs r | App r r | Var Int type Term = Fix TermF  hash :: ByteString -> Hash hempty :: Hash happend :: Hash -> Hash -> Hash  -- Left-associative to match function application infixl 5 <#> (<#>) = happend  hashInt :: Int -> Hash hashInt i = hash ""Int"" <#> hash (showBS i)  hashTermF :: TermF Hash -> Hash hashTermF (Abs r)   = hash ""Abs"" <#> r hashTermF (App r s) = hash ""App"" <#> r <#> s hashTermF (Var i)   = hash ""Var"" <#> hashInt i  hashTerm :: Term -> Hash hashTerm = cata hashTermF ```  I am working on extending this to include a module system, which means I can't always reduce it down to de Bruijn indices because we may be referencing functions in an external module.",0.18148148148148147,scheme
13vxdez,jm91nro,"This should be fairly equivalent to your example hashing scheme:  ```haskell data TermF r = Abs r | App r r | Var Int type Term = Fix TermF  hash :: ByteString -> Hash hempty :: Hash happend :: Hash -> Hash -> Hash  -- Left-associative to match function application infixl 5 <#> (<#>) = happend  hashInt :: Int -> Hash hashInt i = hash ""Int"" <#> hash (showBS i)  hashTermF :: TermF Hash -> Hash hashTermF (Abs r)   = hash ""Abs"" <#> r hashTermF (App r s) = hash ""App"" <#> r <#> s hashTermF (Var i)   = hash ""Var"" <#> hashInt i  hashTerm :: Term -> Hash hashTerm = cata hashTermF ```  I am working on extending this to include a module system, which means I can't always reduce it down to de Bruijn indices because we may be referencing functions in an external module.",0.18148148148148147,haskell
13vxdez,jm91nro,"This should be fairly equivalent to your example hashing scheme:  ```haskell data TermF r = Abs r | App r r | Var Int type Term = Fix TermF  hash :: ByteString -> Hash hempty :: Hash happend :: Hash -> Hash -> Hash  -- Left-associative to match function application infixl 5 <#> (<#>) = happend  hashInt :: Int -> Hash hashInt i = hash ""Int"" <#> hash (showBS i)  hashTermF :: TermF Hash -> Hash hashTermF (Abs r)   = hash ""Abs"" <#> r hashTermF (App r s) = hash ""App"" <#> r <#> s hashTermF (Var i)   = hash ""Var"" <#> hashInt i  hashTerm :: Term -> Hash hashTerm = cata hashTermF ```  I am working on extending this to include a module system, which means I can't always reduce it down to de Bruijn indices because we may be referencing functions in an external module.",0.18148148148148147,r
13vsbrh,,"The APL language has multidimensional arrays as a first-class data type, but up to now only vectors (lists) can be written literally in code.",0.0,apl
13vsbrh,,Dyalog is considering adding a general notation for arrays to APL.,0.05000000000000002,apl
13vsbrh,jm9v35o,"I am not a habitual APL user, but I was under the impression you could lay out your code pretty much how you liked, and there was a reshape operator for vectors.",0.35000000000000003,apl
13vsbrh,jmbiiyz,APL distinguishes between lists of lists and N-dimensional arrays.,0.0,apl
13vsbrh,jmbiiyz,"You could always use reshape \`⍺⍴⍵\` to create N-dimensional arrays in APL, but now your source code can visually reflect the structure:      [ 'abc' 'def'       (1 2) (3 4) ]  The above example is APLAN syntax equivalent to the APL expression:  `2 2⍴'abc' 'def' (1 2) (3 4)`  Lastly, the diamond here is not an operator in that it doesn't accept arguments and return results - but rather it is *syntax* for constructing higher dimensional arrays and namespaces.",-0.1,apl
13vsbrh,jmbiiyz,"In the same way you're unlikely to call the parentheses and commas in an ALGOL-style function call `myFunction(param1,param2)` ""operators"", we wouldn't call APL Array Notation ""functions"" in APL.",-0.25,apl
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,php
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,c++
13vozxh,,"PHP 8.2 introduced [readonly classes](https://wiki.php.net/rfc/readonly_classes), which makes me think about the advantages/disadvantages (in general, not PHP-specific) of this approach (making all instances of a type immutable) vs. postponing the decision to where the type is actually used, as C++ does with `const` [annotations](https://en.cppreference.com/book/intro/const) (and Rust with `mut`).",0.02500000000000001,rust
13vozxh,jm7888e,This is what Rust works hard to prevent.,-0.2916666666666667,rust
13vozxh,jm8l40j,"Java is infamous for failing badly here, even within its chosen paradigm.",-0.5999999999999999,java
13vozxh,jm9cj7q,In my current project we are working with Kotlin and make heavy use of [data classes](https://kotlinlang.org/docs/data-classes.html) which is essentially the same thing.,-0.05,kotlin
13vozxh,jmcp0lm,"Pony, an actor language, uses what it calls [reference capabilities](https://tutorial.ponylang.io/reference-capabilities/index.html) to govern data sharing: Immutable data can be freely shared between actors, isolated data (like C++'s unique\_ptr) can be passed from one actor to another by giving up ownership, and regular data can do whatever except being passed to another actor.",0.2,c++
13vozxh,jm77cu5,"If I understand the PHP case correctly, there will be no mutable version of a class if you declare the class `readonly`.",0.0,php
13vozxh,jm77cu5,"The C++ analogy would be a class with every member (and member function) being `const`, I guess.",0.0,c++
13vozxh,jm7uvxy,"Rust's references are closest to Affine types, because there is a requirement to use them at most once (borrowing aside), but there is no hard requirement that they must be used, as with a linear type system.",0.3229166666666667,rust
13vozxh,jm7uvxy,Rust does allow violating any uniqueness guarantees due to unsafe code.,-0.125,rust
13vozxh,jm7uvxy,[Austral](https://borretti.me/article/introducing-austral#linear) attempts to have Rust style borrowing with the additional linearity constraint.,0.0,rust
13vozxh,jo9f4l0,The person you're replying to is using `struct` and `class` in ways that are consistent with the Swift programming language.,0.25,swift
13vozxh,jo9f4l0,"In Swift, classes are reference types that are similar to heap-allocated objects in other popular languages (except that Swift uses reference counting for garbage collecting rather than a tracing garbage collector), whereas structs are value types, such that even when you mutate a struct-holding variable, it behaves as though you're re-assigning that variable with a new copy of the value.",0.12227272727272727,swift
13vozxh,jmiyr89,"In Java, arrays are mutable so you have to be careful about sharing them.",-0.1,java
13vozxh,jmiyr89,``` byte[] bytes = new byte[10]; // fill bytes f(bytes); // f might hold onto a reference to bytes ```  But there's no way for a Java program to modify a zero length array so it can be safely shared.,0.3181818181818182,java
13vozxh,jmiyr89,But Java's type system does not allow specifying the array length as part of the array type.,0.0,java
13vozxh,jmiyr89,"So in Java, you can't distinguish, without first adding to the type system, between an array that is safe to share and one that is not.",0.375,java
13vozxh,jma5ab9,"I've looked at Clean, Pony and Rust but only done much with Rust.",0.18888888888888888,rust
13vozxh,jma5ab9,I don't fully understand what the type system of Clean or Pony offer that's practically different than that of Rust which seems more limited but enough.,0.15904761904761905,rust
13vozxh,jma5ab9,One thing that I imagine Pony can handle better than Rust is for cyclic data.,0.5,rust
13vozxh,jma5ab9,"I found [A Comparison of the Capability Systems of Encore, Pony and Rust (pdf)](https://uu.diva-portal.org/smash/get/diva2:1363822/FULLTEXT01.pdf) that summaries them in the introduction as:  > The conclusion is that Rust has an advantage in its capability system compared to the other two, but because the languages have very different strengths and weaknesses it depends on the programmer's personal preference of which is the best one for her or him.",0.275,rust
13vozxh,jmizp83,Java is arguably an interpreted language until it's JITed so maybe my example is relevant.,0.4,java
13vozxh,jmizp83,"Fyi, Java's specified semantics require that any use of the `new` operator that completes normally completes with a reference with an identity different from any previously available reference: `new byte[0] != new byte[0]`.",0.16553030303030303,java
13vozxh,jmcw26w,"Haskell originally had a main function `IO a -> IO b`, where you would have to pass and return the IO reference around for anything that was effectful, until monads and typeclasses were added.",0.2708333333333333,haskell
13vozxh,jmcw26w,"The Axum language was C#-like, and could interact with a variant of C# which had `static` (aka global) removed and replaced with an `isolated` keyword, which would be more like a static thread local.",0.3,c
13vozxh,jmcw26w,"I think the idea in both of these languages is to make actor based systems more accessible to non purely functional programmers, but get many of the benefits of languages like Erlang.",0.39732142857142855,erlang
13vozxh,jmcw26w,Rust's design is clearly descended from C++'s move semantics and `unique_ptr`.,0.10000000000000002,rust
13vozxh,jmcw26w,Rust's design is clearly descended from C++'s move semantics and `unique_ptr`.,0.10000000000000002,c++
13vozxh,jmcw26w,These were a bit of a trade-off because they were designed to keep backward-compatibility in mind with older versions of C++.,0.16666666666666666,c++
13vozxh,jmcw26w,"Rust fixed this by enforcing no use-after-move at compile time, and the rest of the language was then designed around that model.",0.1,rust
13vozxh,jmjuag8,"Yeah, Java's abnormal in any number of ways.",0.0,java
13vozxh,jmjuag8,But Java arrays are mutable and it is only the sheerest coincidence that they also have fixed size at allocation time.,0.05,java
13vozxh,jmjuag8,Were that last constraint lifted then it would go without saying that each new empty array must have distinct identity.,0.08409090909090908,go
13vozxh,jmjuag8,"Given the business strategy around Java, it all makes sense.",0.0,java
13vozxh,jmnosgg,I may give Clean another go to learn more about how it does things.,0.43333333333333335,go
13vozxh,jmnod8e,The JVMs `native` mechanism to connect Java methods to (mostly) C code and the JVM embedding ABI both assume that Java arrays do not change size and may not be `realloc`ed or reduce in size when native code calls back into Java code.,0.25,java
13vozxh,jmnod8e,The JVMs `native` mechanism to connect Java methods to (mostly) C code and the JVM embedding ABI both assume that Java arrays do not change size and may not be `realloc`ed or reduce in size when native code calls back into Java code.,0.25,c
13vozxh,jmnod8e,My understanding is that not having a type that maps straightforwardly to C arrays would complicate a lot of that supporting C code.,0.3125,c
13vozxh,jmq7xgo,"To do serious IO in haskell, you need libraries like Conduit or Pipes, which add more learning.",0.08333333333333334,haskell
13vozxh,jmq7xgo,I was infatuated with Haskell for a while but came to the realization that the world is inherently dynamic and trying to shoehorn everything into static types just means adding more and more layers of abstraction.,0.26,haskell
13vozxh,jmq7xgo,"In this case though, I'm using it as a transpiler to C, because I want low level access to the processor and memory for performance reasons.",0.0,c
13vozxh,jmskyat,When I first looked at OCaml I think it didn't handle parallel threads and F#/.Net is more likely to be accepted into the mainstream even with its C#/CLR interop baggage.,0.1875,c
13vozxh,jmstxe2,"The JVM ecosystem and languages like Scala are obviously much simpler on android, but not much help on iOS.",0.05,scala
13vozxh,jmstxe2,"For most things, the syntax is more terse than C#, and it has better defaults.",0.5,c
13v7xul,jm7s12a,used on UNIX-likes to tell the shell what interpreter program to run a script with...,0.0,shell
13v7xul,jm7s12a,"Your scheme, as I can make it out, just about avoids conflicting with this by inserting the comments _after_ rather than before the offending lines...",0.0,scheme
13v7xul,jm50ake,"Like C# Roslyn Analyzers, or the Roc IDE.",0.0,c
13v7xul,jmqqx5k,For example you typically write a comment `/** */` over a method name in C++ or Java.,-0.16666666666666666,c++
13v7xul,jmqqx5k,For example you typically write a comment `/** */` over a method name in C++ or Java.,-0.16666666666666666,java
13v7xul,jmqqx5k,"(In Python it's `"""""" """"""`.)",0.0,python
13v7xul,jmqqx5k,You can also declare a method in Java and have it throw an `UnsupportedOperationException`.,0.0,java
13v7xul,jmqqx5k,"As opposed to that, in Scala, you can have it return `???`.",0.0,scala
13usqwq,,"I first noticed it in Rust that the language designers are very comfortable with just declaring ""X is UB"" (undefined behaviour) instead of providing sensible behaviour for edge-cases.",0.385,rust
13usqwq,,"Currently, I'm refreshing my knowledge of C and found that newer C standards introduced UB where previously it was up to the implementation to define behaviour.",0.16666666666666669,c
13usqwq,jm2a34t,"(I'm talking about C, I'm not really familiar with how Rust does or uses UB.)",-0.1875,c
13usqwq,jm2a34t,"(I'm talking about C, I'm not really familiar with how Rust does or uses UB.)",-0.1875,rust
13usqwq,jm2cf6s,Iirc especially early C standards left lot of behavior implicitly undefined which I suspect was recognized as problematic.,0.1,c
13usqwq,jm2cf6s,Especially for C standard they also have to take into account existing implementations; while the standard is written in prescriptive tone in actuality it is more just descriptive.,0.125,c
13usqwq,jm27jei,"I may be wrong but I feel like it's more a matter of being the case that once you define a behaviour you can't undefine it, and I know Rust in particular is extremely careful (for backward compatability reasons) about what behaviour it declares as stable.",0.016666666666666663,rust
13usqwq,jm29sjw,"In Rust, this is trivial.",0.0,rust
13usqwq,jm29sjw,"I'd never heard of the ""zero sized allocations are UB"" thing before, because it's not something Rust programmers ever have to worry about, unlike in C.",0.0,rust
13usqwq,jm29sjw,"I'd never heard of the ""zero sized allocations are UB"" thing before, because it's not something Rust programmers ever have to worry about, unlike in C.",0.0,c
13usqwq,jm343lg,"> I first noticed it in Rust that the language designers are very comfortable with just declaring ""X is UB"" (undefined behaviour) instead of providing sensible behaviour for edge-cases.",0.385,rust
13usqwq,jm343lg,"Rust has two ""modes"": safe and unsafe.",0.5,rust
13usqwq,jm343lg,"In safe rust, it is impossible to invoke UB (unless a badly written library exposes unsafe operations in a safe API).",-0.09166666666666662,rust
13usqwq,jm343lg,When only using the standard library in safe rust (or other libraries that do not depend on unsafe code) UB is impossible.,-0.05833333333333333,rust
13usqwq,jmab5lx,"In the current UB arms race between C and C++ compilers, what programmers *think* UB means is ""whatever the CPU does is what should happen"", but the way that the language-lawyering compiler developers interpret it is ""the compiler is allowed to assume that UB never happens"".",0.0,c
13usqwq,jmab5lx,"In the current UB arms race between C and C++ compilers, what programmers *think* UB means is ""whatever the CPU does is what should happen"", but the way that the language-lawyering compiler developers interpret it is ""the compiler is allowed to assume that UB never happens"".",0.0,c++
13usqwq,jmab5lx,"int d[16];      int SATD (void)     {         int satd = 0, dd, k;         for (dd=d[k=0]; k<16; dd=d[++k]) {             satd += (dd < 0 ?",-0.75,d
13usqwq,jmab5lx,The compiler reasoned:  * An out-of-bounds access of `d` is UB and cannot happen.,0.0,d
13usqwq,jmab5lx,* Therefore `k` cannot be greater than 15 before the array access `d[++k]`.,0.5,d
13usqwq,jmab5lx,This is part of the semantics of C++.,0.0,c++
13usqwq,jmab5lx,"C++ is meant to support object identity, which means that if you call \`operator new\` twice in a row, without deleting one of those objects, it must return different pointers.",0.0,c++
13usqwq,jm40t9d,I am not entirely sure why you think allocating zero memory in Rust is undefined behaviour.,-0.25,rust
13usqwq,jm40t9d,"Perhaps if you’re implementing extremely low-level data structures, you may need to be concerned about some unsafe APIs, but most people writing Rust will never need to worry about this.",0.1875,rust
13usqwq,jm40t9d,"Rust strives to make as much of the language as possible undefined-behaviour free (or “safe”, in Rust parlance).",0.275,rust
13usqwq,jm4co16,"In practice, this is not a thing you often rub up against if you're not working in a language like C, because most languages don't let you wantonly break their constraints; they will have some combination of static and dynamic checks and restrictions on basic language functionality to ensure that you play within their rulesets.",0.25,c
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,c
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,rust
13usqwq,jm4co16,"It can be as dangerous as C which has very few safety mechanisms in the first place, as sophisticated as Rust's safe–unsafe split, as elegant as Haskell's `unsafePerformIO`, or as boring as a simple FFI layer that lets you call out to a C library and run amok.",-0.08714285714285715,haskell
13usqwq,jm2b7ko,Sounds like Rust is a good language to avoid.,0.7,rust
13usqwq,jm7p2zu,"In Rust, integer overflow is defined as a panic.",0.0,rust
13usqwq,jm7p2zu,"This code wont even compile:        let mut i = 0i8;     let n = 1000i32;     while i <= n{        //<-- mismatched types, comparing i8 and i32         i += 1;     }      You have to explicitly cast the `i` to a `i32` for this to work:        let mut i = 0i8;     let n = 1000i32;     while i as i32 <= n{         i += 1;     }      Now the code is equivalent with the c code again and the compiler can make the same assumtions.",0.0,c
13usqwq,jm7p2zu,The C version will most likely loop forever (it is UB after all.,0.25,c
13usqwq,jm7p2zu,The rust version will panic on the overflow at runtime.,0.0,rust
13usqwq,jm7p2zu,Both version should be able to optimise the same execpt the rust version is well defined and c isnt.,0.25,rust
13usqwq,jm7p2zu,Both version should be able to optimise the same execpt the rust version is well defined and c isnt.,0.25,c
13usqwq,jm588a8,"My view about C's UB is that I don't care for it, especially for things that I don't consider UB, like signed integer overflow.",0.0,c
13usqwq,jm588a8,"Quite often I've had a language where such overflow is well-defined, and desired target machines where it is well defined, but if using intermediate C between the two, now you have to run the gauntlet of some bloody-minded C compiler messing up your code and doing whatever the hell it likes.",0.0,c
13usqwq,jm588a8,Why is it UB in C?,0.0,c
13usqwq,jm588a8,"Even if writing in C, you're going to end up with different behaviour across compilers and with with the same compiler, depending on options.",0.0,c
13usqwq,jm588a8,"C is supposed to be a lower level language where you call the shots, but apparently not; the compiler does.",-0.025,c
13usqwq,jm2hw2m,"This was the case with early C, but is nowadays not really a factor because everything is so standardized.",0.0,c
13usqwq,jm2hw2m,"Even the Wikipedia article on UB seems to state this: https://en.wikipedia.org/wiki/Undefined_behavior  The undefined behaviour talked about here is more like one where you divide by 0, rather than go out of array bounds, so, things you can't really fundamentally solve, rather than those that are generalized so much that edge cases aren't solved.",0.3,go
13usqwq,jm3cbmx,Annex J in the C standard is invaluable.,0.0,c
13usqwq,jm2bqg9,">it's not something Rust programmers ever have to worry about,  ""Ever"" is doing a lot of work here.",0.0,rust
13usqwq,jm2bqg9,"People do write low level code in Rust (with custom allocators and whatnot, though that part is unstable), it's just that the most common cases for memory allocation are already covered by `std`.",0.06666666666666667,rust
13usqwq,jm3xohk,"> I'd never heard of the ""zero-sized allocations are UB"" before, because it's not something Rust programmers ever have to worry about, unlike in C.  Somewhat amusingly, you have this backwards.",0.6,rust
13usqwq,jm3xohk,"`malloc(0)`, `new T[0]`, and `Alloc().allocate(0)` (for any `Alloc` implementing the Allocator requirements) are not undefined in C and C++; they all return a value which is unspecified except that it may be subsequently deallocated with `free`, `delete`, or `deallocate`, respectively (this may be null or another singleton, or it may be the address of an actual allocation, but either way the user is not allowed to dereference it).",0.10727272727272727,c
13usqwq,jm3xohk,"`malloc(0)`, `new T[0]`, and `Alloc().allocate(0)` (for any `Alloc` implementing the Allocator requirements) are not undefined in C and C++; they all return a value which is unspecified except that it may be subsequently deallocated with `free`, `delete`, or `deallocate`, respectively (this may be null or another singleton, or it may be the address of an actual allocation, but either way the user is not allowed to dereference it).",0.10727272727272727,c++
13usqwq,jm3xohk,"In Rust, by contrast, a type implementing `std::alloc::GlobalAlloc` _may_ invoke undefined behavior when passed 0 (though the default `std::alloc::System` allocator does not, as it also implements `std::alloc::Alloc`, which has a stronger set of requirements).",0.0,rust
13usqwq,jm36y53,"`unsafe` is *far* from the only kind of UB in Rust, and it's scary that people still believe that.",0.04999999999999999,rust
13usqwq,jmgd6m4,"This is a bigger problem in Rust than in C or other similar unsafe languages because Rust requires a LOT of invariants from your code, and really will do crazy things if you mess up any of the subtle details of pointers and aliasing, etc..",-0.1476190476190476,rust
13usqwq,jmgd6m4,"This is a bigger problem in Rust than in C or other similar unsafe languages because Rust requires a LOT of invariants from your code, and really will do crazy things if you mess up any of the subtle details of pointers and aliasing, etc..",-0.1476190476190476,c
13usqwq,jm3uea8,"Per DonaldPShimoda's exposition higher up: C has ""undefined"" and also has ""implementation defined"" and ""unspecified"".",0.25,c
13usqwq,jm4fn50,> I am not entirely sure why you think allocating zero memory in Rust is undefined behaviour.,-0.25,rust
13usqwq,jm40saf,"For example, you prepare a nice sanitized bash command into a buffer, you call function A that invokes undefined behavior, you call function B that does something else with the stack or heap (which at this point could be in any state imaginable), then you call `system()` with the contents of your buffer (which now contains arbitrary data) and hey presto, you wipe your hard drive.",0.06944444444444443,bash
13usqwq,jpuitya,What UB does eg JavaScript have?,0.0,javascript
13usqwq,jm2idkd,"I assure you, the existence of UB in Rust is grossly mischaracterized by OP.",0.0,rust
13usqwq,jm352kh,> Sounds like Rust is a good language to avoid.,0.7,rust
13usqwq,jm3jiyy,The size of an `int` in C is an implementation-defined behavior.,0.0,c
13usqwq,jm3jiyy,The order of evaluation of arguments to a function in C is an unspecified behavior.,0.0,c
13usqwq,jmaqer2,"It should be noted that in C, infinite loops (with non-constant conditions) themselves are undefined behavior (unless you perform IO, access a volatile/atomic value, or a small number of other exceptions of ""observable behavior"" inside of the loop).",-0.1875,c
13usqwq,jmaqer2,"So unless there's a black-box function call inside, a C compiler is free to assume *all* loops terminate.",0.4,c
13usqwq,jm2hx3w,"In Rust, most of the way one can invoke UB is by deliberately circumventing the strong guarantees the language provides  (using `unsafe { ...",0.4666666666666667,rust
13usqwq,jm2hx3w,There is also the MIRI project which is a rust interpreter for detection of UB-related bugs.,0.0,rust
13usqwq,jm2hx3w,The problem that C(++) has compared to Rust is that any piece of code can have UB and innocuous looking code can be UB.,0.0,c
13usqwq,jm2hx3w,The problem that C(++) has compared to Rust is that any piece of code can have UB and innocuous looking code can be UB.,0.0,rust
13usqwq,jm2hx3w,"Rust is quite literally designed with the property that the safe subset of the language will never introduce UB, almost like a mamaged language such as Java.",0.25,rust
13usqwq,jm2hx3w,"Rust is quite literally designed with the property that the safe subset of the language will never introduce UB, almost like a mamaged language such as Java.",0.25,java
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,go
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,rust
13usqwq,jm46oxv,"My point is that it is possible to go many years in Rust without ever learning such trivia because it isn't relevant to normal programming, whereas C programmers have to worry about what is and isn't UB constantly.",0.17500000000000002,c
13usqwq,jm3g53x,Can you give an example of user-error UB in safe Rust?,0.5,rust
13usqwq,jm2hf2o,> Are you  saying that it impossible for a Rust program to call the `malloc` function of the C library via whatever FFI it has?,-0.6666666666666666,rust
13usqwq,jm2hf2o,> Are you  saying that it impossible for a Rust program to call the `malloc` function of the C library via whatever FFI it has?,-0.6666666666666666,c
13usqwq,jm2hf2o,"Calling functions through FFI in Rust requires `unsafe`, so if you restrict your code to safe Rust then it's not (directly) possible.",0.25,rust
13usqwq,jm4sjwp,"I'm most familiar with what Rust does as that's the systems language I use the most, and for the most part I think that what they label as UB is rather sensible, [according to this partial list](https://doc.rust-lang.org/reference/behavior-considered-undefined.html), at least.",0.24583333333333332,rust
13usqwq,jm4sjwp,"For what it's worth, I do agree that UB should probably be a last resort, or reflecting of some problems with the backend (if you transpile to C or are working on top of LLVM or something), instead of being the first thing you reach for.",0.2625,c
13usqwq,jp710jy,"I think the point @BobSanchez47 is making is that Rust has objects that you just create, so few devs ever really call `alloc()`.",0.0,rust
13usqwq,jp710jy,Whereas C always requires you to call `malloc(sizeof(MyStruct))` to get something roughly equivalent.,-0.1,c
13usqwq,jp710jy,"For all I know, Rust might have more UB in total than C, but only in gnarly low-level API nobody ever uses, making it UB-free in practice.",0.16666666666666666,rust
13usqwq,jp710jy,"For all I know, Rust might have more UB in total than C, but only in gnarly low-level API nobody ever uses, making it UB-free in practice.",0.16666666666666666,c
13usqwq,jm2s7l7,C++),0.0,c++
13usqwq,jm42l7l,"In particular, Rust still hasn’t pinned down exactly what constitutes undefined behaviour when it comes to pointer aliasing and provenance, so any proof that undefined behaviour is impossible relies on a non-settled definition of UB.",-0.10138888888888889,rust
13usqwq,jm37gjm,You can brick a system with Python if you really want to.,0.2,python
13usqwq,jm37gjm,"Rust, being a very low-level systems programming language needs to give you access to the tools you need to... program systems.",0.2,rust
13usqwq,jm3t9vz,"I know that it's not how C works, but by golly, the way it currently works is just too bizarre and arguably far more dangerous than it should be.",0.08,c
13usqwq,jmb07zy,that only applies to c++,0.0,c++
13usqwq,jm2qwph,And Rust developers LOVE happy paths.,0.65,rust
13usqwq,jm2qwph,"But alas, Rust is not the only language there is.",-0.2,rust
13usqwq,jm2jsvz,"Well, if I'm going down anyway, let's make it official:  *I dislike Rust, but not nearly much as its trigger-happy mob of fans.",-0.1277777777777778,rust
13usqwq,jm3812x,Then how would Rust allow FFI with C/C++/whatever else that handles raw pointers?,-0.23076923076923078,rust
13usqwq,jm56iqd,"> Rust, being a very low-level systems programming language   If Rust is 'very low level', that would make mine the other side of assembly.",0.025000000000000005,rust
13usqwq,jm56iqd,"> Rust, being a very low-level systems programming language   If Rust is 'very low level', that would make mine the other side of assembly.",0.025000000000000005,assembly
13usqwq,jm45dge,Hmm but it is _useful_ (for C) to have these dark corners where the behavior is undefined.,0.075,c
13usqwq,jm2x3ix,"> But alas, Rust is not the only language there is.",-0.2,rust
13usqwq,jm44z53,It really sounds to me like you don't know the tradeoffs that go into designing systems programming languages.,0.2,go
13usqwq,jm44z53,Also sounds like you haven't actually coded any rust.,0.0,rust
13usqwq,jm3ygax,Writing a memory safe language that is free from UB is barely any work (I could do it in a day); writing a memory safe language that is as performant as C is a substantial amount of work (it takes dozens of developers working together 5+ years); writing a memory safe language that is free from UB and as performant as C is literally impossible.,0.2404761904761905,c
13usqwq,jm4cfkr,"> there would have at least been runtime checks on whether specific pointers can be dereferenced  Rust has ""managed pointers"" that are guaranteed to always be safe to de-reference: borrows!",0.10833333333333334,rust
13usqwq,jm3j46e,"For actually performance-critical systems programming, generally nothing above C or even ASM is tolerable, this does not mean there aren't any other languages that do more, and this does not mean a certainly constrained design isn't lazy.",0.07797619047619048,c
13usqwq,jm3j46e,"I'm good enough to program in C, CUDA or ASM for things that need to be programmed in those.",0.35,c
13usqwq,jm3btvp,"My criticism is not that this stuff isn't checked, but that `safe` Rust is lazily defined, not as things that can be done safely, but as things that the authors think should be deemed safe.",0.3125,rust
13usqwq,jm3btvp,"If this means a systems language, for example, in Go you would receive an error.",0.0,go
13usqwq,jm3btvp,"Well, there is a lot to learn from other language designers, the question is only if the Rust community wants to.",0.025000000000000005,rust
13usqwq,jm3gnyd,"> My criticism is not that this stuff isn't checked, but that `safe` Rust is lazily defined, not as things that can be done safely, but as things that the authors think should be deemed safe.",0.3125,rust
13usqwq,jm3gnyd,Care to explain what is **certainly always safe** but safe rust doesn't allow it?,0.4047619047619048,rust
13usqwq,jm3gnyd,"> If this means a systems language, for example, in Go you would receive an error.",0.0,go
13usqwq,jm3gnyd,"Go has a GC, I don't even consider it for this discussion.",0.0,go
13usqwq,jm3gnyd,"--  So, do I have to take this as ""I don't want what Rust wants to be, a GC-less safe language with optional access to unsafe low level details""?",0.2333333333333333,rust
13usqwq,jm3i2ym,> Care to explain what is certainly always safe but safe rust doesn't allow it?,0.4047619047619048,rust
13usqwq,jm3i2ym,"Go, for example, does this.",0.0,go
13usqwq,jm3i2ym,"It's not like Rust doesn't compromise on performance for the sake of safety generally, this shouldn't come to a surprise.",0.05000000000000002,rust
13usqwq,jm3i2ym,"> Go has a GC, I don't even consider it for this discussion.",0.0,go
13usqwq,jm3i2ym,"> So, do I have to take this as ""I don't want what Rust wants to be, a GC-less safe language with optional access to unsafe low level details""?",0.2333333333333333,rust
13usqwq,jm3i2ym,You don't have to take it as anything - it's not like any individual in particular has any power to change Rust.,0.08333333333333333,rust
13usqwq,jm3i2ym,"And at this point to counter this laziness you would need a new language most likely, Rust is too far gone.",0.18409090909090908,rust
13usqwq,jm3i2ym,"Those insights you can apply to all languages, not only Rust.",0.0,rust
13usqwq,jm3p0c1,"Rust was born for writing an efficient, parallel, but memory safe browser, not just as a random language.",0.0,rust
13usqwq,jm3p0c1,"If I say I want to know how Rust could have been better, I mean with this goal in mind.",0.09375,rust
13usqwq,jm4x5zc,"here's the thing, Rust's type system ensures that a value's type never changes.",0.0,rust
13usqwq,jm4x5zc,"Instead of complicating the type system to such an extent (as what you're suggesting isn't just about freshly allocated pointers, at the very least you have to also propagate that additional type info down the line), Rust simply says - if you want to ensure this is always in a valid state, use wrapper types (like Box, which is a wrapper around a pointer).",-0.04911111111111112,rust
13usqwq,jm4x5zc,"This offloads the burden from the language developers to create safe wrappers for all potential use cases of unions, pointers, C FFI, to the developers, which makes much more sense as the language devs can't possibly cover all such cases (and if you're suggesting ""don't cover all cases, only some"", where do you draw the line?)",0.16666666666666666,c
13usqwq,jm3sw7p,"The goal of Rust is providing safety, which is what my proposal does.",0.0,rust
13usqwq,jm3sw7p,"> Rust was born for writing an efficient, parallel, but memory safe browser, not just as a random language.",0.0,rust
13usqwq,jm3sw7p,You reject this because the very notion of this solution insults your perception of Rust and perhaps even your notion of oneself.,0.2,rust
13usqwq,jm3sw7p,"But realize that Rust is not the only language with lazy design, in fact, I'm sure there is laziness in every language to an extent, so there is no reason to outright defy this so much.",0.1125,rust
13uh17j,,"I'm pretty firmly convinced that using a more dedicated teaching language is a better approach than having beginners just start with Python/JavaScript/other language goes here and I'm not really here to discuss that, so I'm not really interested in comments like ""Just use Python because x, y, and z.""",0.1375,python
13uh17j,jm2gx57,Students that intend to go into programming eventually (but can still drop out / change majors if it doesn't work out) - **Career switchers**: People learning to get a job or build an app.,0.0,go
13uh17j,jm2gx57,"TypeScript) to introduce various type concepts gradually - **Mutability**: Immutable by default, but with the possibility for opt-in mutability.",0.0,typescript
13uh17j,jm2gx57,"I've seen people learn Python via Jupyter Notebooks and then be completely lost trying to make their own program - **Easy to run**: As a beginner, one of my frustrations was ""I just want to run the code"".",0.37777777777777777,python
13uh17j,jm2gx57,"- **Libraries to create cool stuff**: More important for younger learners, they should be able to make a video game, control a robot, etc.",0.225,cool
13uh17j,jm2drem,"Something like Scheme, with SICP as an example of how to teach.",0.0,scheme
13uh17j,jm2drem,"If you grasp SICP, you not only learn Scheme, you learn how to implement it, or how features of programming languages in general are implemented.",0.02500000000000001,scheme
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,c
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,python
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,javascript
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,c++
13uh17j,jm2drem,"So in this case, C, Python, JavaScript or perhaps C++, Java and C# would be preferred.",0.0,java
13uh17j,jm268jg,https://hedycode.com/ is a great example of teaching to program by gradually building up to Python.,0.8,python
13uh17j,jm268jg,I'd also recommend Elm as a source of inspiration.,0.0,elm
13uh17j,jm3k9jr,"For beginners I'd probably have a language that requires type signatures on everything (including locals) with the ability to relax the requirement later - I also agree that algebraic data types are great for learning - loops, probably a single keyword for all kinds akin to go - low boilerplate (as somebody mentioned Java is terrible with this - it also requires everything to be in a class which is just silly and pedantic) - comprehensive package management that makes it easy for students to build fun little projects without needing to add to a config file.",-0.0325595238095238,go
13uh17j,jm3k9jr,"For beginners I'd probably have a language that requires type signatures on everything (including locals) with the ability to relax the requirement later - I also agree that algebraic data types are great for learning - loops, probably a single keyword for all kinds akin to go - low boilerplate (as somebody mentioned Java is terrible with this - it also requires everything to be in a class which is just silly and pedantic) - comprehensive package management that makes it easy for students to build fun little projects without needing to add to a config file.",-0.0325595238095238,java
13uh17j,jm3k9jr,"Students don't need to worry about perf, but could get discouraged with long compile times - I agree with another commenter's mentions of immutability by default - ""everything is a pointer"" (a la Java) is also probably quite beneficial to students - it's a difficult concept and one that can be tackled down the line.",-0.2351851851851852,java
13uh17j,jm7osyn,I've thought about this a bit - I actually think introducing a non-programmer to a pure functional language (like Haskell) *could* be a good idea (though it certainly has its limitations and detractors).,0.28214285714285714,haskell
13uh17j,jm7osyn,"So, to answer your question, I would take Haskell and simplify it to within an inch of its life, mostly in terms of the type system and syntax.",0.5,haskell
13uh17j,jm7osyn,Anything that hinders understanding and isn't fundamentally necessary has to go.,0.0,go
13uh17j,jm2dwn6,Or is the thread really about how to teach people to code in Rust or other such modern language?,0.06875,rust
13uh17j,jm2yava,"It's one of the reasons why Python is better than some languages for this purpose, but has its own issues.",0.55,python
13uh17j,jm2yava,"Pascal has an ecosystem outside its use in academics, so not only can students learn CS with the language, the language and its ecosystem are large enough to accommodate higher levels of skill.",0.09285714285714286,pascal
13uh17j,jp8y6ii,Having to declare variables in a VAR section that has to be below the CONST section both of which have to be at the top of my function like Pascal will put unnecessary obstacles between learners and the successes that keep them coding.,0.01666666666666666,pascal
13uh17j,jp8y6ii,You can always move on to C later if you want to teach them how to associate errors where the compiler got confused with the actual error location.,-0.13333333333333333,c
13uh17j,jm3kqpu,And a type checker something like TypeScript's where 90% of the time all you need to annotate is your functions and it can infer the rest.,0.0,typescript
13uh17j,jm6oeqp,Somebody on the C subreddit specifically asked about a simple graphics library; one suggestion was GTK3!,0.0,c
13uh17j,jm2raw2,People say it a lot in regards to learning Haskell or something after C (or something).,0.0,haskell
13uh17j,jm2raw2,People say it a lot in regards to learning Haskell or something after C (or something).,0.0,c
13uh17j,jm3u204,"The maintainers are super cool people, too.",0.3416666666666667,cool
13uh17j,jm70sy7,"When they do the quadratic formula, the values for a,b,c don't change _while they are solving the problem_, it might be different in a different problem which is just like applying a function multiple times to different values.",0.0,c
13uh17j,jm2v2wl,"The knowledge doesn't go away, it's just that you don't reach for it unless you really need to.",0.2,go
13uh17j,jm81jhp,When I moved on from C++ I had to unlearn loads of accepted wisdom because it turned out to be completely wrong:  * Simula-style OOP sucks.,-0.4,c++
13uh17j,jm81jhp,* C++ isn't conducive of good performance.,0.7,c++
13uh17j,jm81jhp,Basically everything C++ added to C had already been done better before C++ was invented.,0.5,c++
13uh17j,jm81jhp,Basically everything C++ added to C had already been done better before C++ was invented.,0.5,c
13uh17j,jm75rv3,">When they do the quadratic formula, the values for a,b,c don't change while they are solving the problem  They generally don't change within a single expression in a language either:      x1 := (-b + sqrt(b*b-4*a*c))/(2*a)  But if used in a program, you need to get values into `a b c` in the first place.",-0.13035714285714284,c
13uh17j,jm75rv3,"If this is part of a loop that reads sets of coefficients to solve lots of equations, those `a b c` need to be writeable.",0.0,c
13uh17j,jm75rv3,"Easier to just have *variables* that you can assign things to, and then possibly modify:      a +:= 1.0  This gives great flexibility, for example you can rotate the coefficients to see what happens: `(a, b, c) := (b, c, a)`.",0.01666666666666668,c
13uh17j,jm3lm20,"Where I would argue for recursion over loops stems from my experience in teaching programmers using JavaScript where, once they learn how to think I'm terms of recursion, it's often been easier to move to iteration without losing the intuition for recursion in the process.",0.0,javascript
13uh17j,jm3t3to,">Using recursion ... now I have to stop and think *how* I'm going to achieve that -  I had a go at it and came up with this:      proc nstars(n)=         if n>0 then             print ""*""             nstars(n-1)         fi     end          proc nlines(n,i=1)=         if n in 1..n then             nstars(i)             println             nlines(n,i+1)         fi     end          nlines(100)  For `nlines(4)` it displays:      *     **     ***     ****  It was much harder than I thought, and ended up needing *two* parameters to `nlines`, one of which had to be optional (to avoid needing an auxiliary function) in order to display the stars in order of increasing length.",-0.1,go
13uh17j,jm7qz87,"> If this is part of a loop that reads sets of coefficients to solve lots of equations, those a b c need to be writeable.",0.0,c
13uh17j,jm7qz87,"let rec loop() = loop(solve(read_coeffs()))  > This gives great flexibility, for example you can rotate the coefficients to see what happens: (a, b, c) := (b, c, a)      (a, b, c) := (b, c, a)  vs      let a, b, c = b, c, a  ?",-0.3625,c
13uai8f,, All I need is a sample how to call a language server written in C that can  be empty like //put your code here.,-0.1,c
13uai8f,jm065nf,I guess you need to choose the IDE client (vs code etc) I’m not sure how the commands are sent (maybe stdin in C and maybe sockets.. no idea where to configure this) There are sample projects but for some reason for me particularly they write a about everything but not about the bits I need so it is very frustrating reading.,-0.20111111111111113,c
13uai8f,jm0f0cm,lets say my server is in C where do I specify the port for instance..these are the parts that are driving me crazy :-/,-0.425,c
13u5ie6,jlzbsm0,"(Since you mention Clang so are using C, if the parameter type uses `const`, it may not be necessary to make a copy, as that stops the callee writing into the struct.)",0.0,c
13u5ie6,jm1ybn4,the llvm abi is different from the c abi.,0.0,c
13u5ie6,jm1ybn4,llvm just expands aggregates to scalars but c has different complicated abis for different platforms.,-0.16666666666666666,c
13u5ie6,jm1ybn4,i believe clang has some very long and ugly code to “emulate” the c abi with llvm ir.,-0.38249999999999995,c
13u5ie6,jm1ybn4,for now my compiler ignores that and passing structs by value to c code silently doesn’t work.,0.0,c
13u5ie6,jm4d16y,If you want to pass data to or from C you need to get your hands dirty and implement the ABIs.,-0.6,c
13u5ie6,jm4d16y,LLVM by default will just do some simple best effort when you don’t lower according to the C ABI.,0.5,c
13u5ie6,jlzgraa,"Take this example code:      struct S {       int a;       float b;       long c;     };     float f(struct S arg) {       return arg.a + arg.b + arg.c;     }     void test() {       struct S arg;       arg.a = 1;       arg.b = 2.f;       arg.c = 3;       float val = f(arg);     }  My implementation would generate something like this (if, of course, it was made to parse C):      define float @f({ i32, float, i64 } arg) {       %0 = extractvalue { i32, float, i64 } arg, 0       %1 = extractvalue { i32, float, i64 } arg, 1       %2 = sitofp i32 %0 to float       %3 = fadd float %2,  %1       %4 = extractvalue { i32, float, i64 } arg, 2       %5 = sitofp i64 %4 to float       %6 = fadd float %3, %5       ret float %6     }          define void @test() {       %0 = insertvalue { i32, float, i64 } undef i32 1, 0; My initialization is a bit shorter here because of how I initialize structs       %1 = insertvalue { i32, float, i64 } %0, float 2.000000e+00, 1       %2 = insertvalue { i32, float, i64 } %1, i64 3, 2       %3 = call float @f({ i32, float, i64 } %2)     }  But Clang emitted this (data layout, attributes, and metadata are omitted):      %struct.S = type { i32, float, i64 }          ; Function Attrs: noinline nounwind optnone uwtable     define dso\_local float @f(i64 %0, i64 %1) #0 {       %3 = alloca %struct.S, align 8       %4 = getelementptr inbounds { i64, i64 }, ptr %3, i32 0, i32 0       store i64 %0, ptr %4, align 8       %5 = getelementptr inbounds { i64, i64 }, ptr %3, i32 0, i32 1       store i64 %1, ptr %5, align 8       %6 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 0       %7 = load i32, ptr %6, align 8       %8 = sitofp i32 %7 to float       %9 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 1       %10 = load float, ptr %9, align 4       %11 = fadd float %8, %10       %12 = getelementptr inbounds %struct.S, ptr %3, i32 0, i32 2       %13 = load i64, ptr %12, align 8       %14 = sitofp i64 %13 to float       %15 = fadd float %11, %14       ret float %15     }          ; Function Attrs: noinline nounwind optnone uwtable     define dso\_local void @test() #0 {       %1 = alloca %struct.S, align 8       %2 = alloca float, align 4       %3 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 0       store i32 1, ptr %3, align 8       %4 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 1       store float 2.000000e+00, ptr %4, align 4       %5 = getelementptr inbounds %struct.S, ptr %1, i32 0, i32 2       store i64 3, ptr %5, align 8       %6 = getelementptr inbounds { i64, i64 }, ptr %1, i32 0, i32 0       %7 = load i64, ptr %6, align 8       %8 = getelementptr inbounds { i64, i64 }, ptr %1, i32 0, i32 1       %9 = load i64, ptr %8, align 8       %10 = call float @f(i64 %7, i64 %9)       store float %10, ptr %2, align 4       ret void     }  IIRC, C requires all variables to have addresses, while my language doesn't, but what I don't get is why \`%6\`-\`%9\` in \`test\` are used to load everything out in the form of \`i64\`s, only to reinterpret that again inside \`f\`.",-0.025,c
13u5ie6,jlzjgjm,But I took your test program:      struct S {         int a; float b; long c;     };          float f(struct S arg) {         return arg.a + arg.b + arg.c;     }          void test(void) {         struct S arg;         arg.a = 1;         arg.b = 2.f;         arg.c = 3;         float val = f(arg);     }  and passed it through Clang myself.,-0.05,c
13u5ie6,jm3dlum,"And yes, the memory for the top of the stack is likely in L1, but that's still a handful of CPU cyles back and forth!",0.16666666666666666,forth
13u5ie6,jm3dlum,"The C ABI is typically ""just"" the ABI the kernel designed for system calls from user-space: C adopts this ABI on a per platform/per OS basis simply so that those system calls can be modeled directly in C.  So, to some degree, you're asking why Linux system calls on x64 were chosen to pass your struct as two 64-bits registers :)",0.10833333333333334,c
13tgn0q,jm5ynyn,We're trying to go beyond mere standardization with the introduction of [inflights](https://docs.winglang.io/concepts/inflights) and [local simulation](https://docs.winglang.io/concepts/simulator).,-0.25,go
13tgn0q,jm5ynyn,To go to production either the developer or a DevOps engineer can take care of other non-functional concerns that the compiler cannot deduce automatically.,-0.125,go
13tgn0q,jm7prag,Basically just anything that lets developers configure plugins more formally than writing a bash wrapper script.,0.5,bash
13tgn0q,jm7dhkj,And here's the cool (but difficult) thing: We can be critical and encouraging at the same time.,-0.037500000000000006,cool
13tjaz7,,"I've re-implemented the ALT interpreter almost 20+ times for the past 1.5 years (Scala mostly), but this time I've implemented it in typescript - so it runs in the browser!",0.1875,scala
13tjaz7,,"I've re-implemented the ALT interpreter almost 20+ times for the past 1.5 years (Scala mostly), but this time I've implemented it in typescript - so it runs in the browser!",0.1875,typescript
13tjaz7,jlw0f66,Cool.,0.35,cool
13tjaz7,jlxqigk,"So:      {a:1, b:2, c:3}::""value""  =>  {a:""value"", b:""value"", c:""value""}  That's not all of it.",-0.75,c
13tjaz7,jlyxii9,The javascript code of course is available: just open the .js file.....,0.2,javascript
13ta9vj,jlu3la2,"Not exactly tagged pointers, but Swift keeps track of unused bits and bit patterns and tries to use them to store discriminator of the tagged union.",-0.1125,swift
13ta9vj,jlu3la2,And I think lower bits of the pointer are assumed to be unused (probably only in cases when reference is known to point to pure Swift object).,0.10714285714285714,swift
13ta9vj,jlvjioz,GHC (Haskell) uses pointer tagging to store constructor tags for algebraic data types as an optimization.,0.0,haskell
13ta9vj,jlxbkrg,Objective-C runtime makes extensive use of tagged pointers and values.,0.0,objective-c
13ta9vj,jlyq9i5,"Whether you go with GC or a manual heap, there will be overhead per-object.",0.0,go
13ta9vj,jlush62,"Gilad bracha points out that the use of nonuniform representations in java implementations caused undesirable leakage and duplication in the language: the need for the user-level boxed types Long, Integer, etc., where long and int (etc.)",-0.05,java
13ta9vj,jlygs6z,">  > Gilad bracha points out that the use of nonuniform representations in java implementations caused undesirable leakage and duplication in the language: the need for the user-level boxed types Long, Integer, etc., where long and int (etc.)",-0.05,java
13ta9vj,jlygs6z,"Java was a disaster in so many ways that I find it difficult to learn from beyond ""don't do anything remotely like this"".",-0.03333333333333333,java
13ta9vj,jlzk562,"I have never used ocaml, but common lisp admits unboxed arrays, and they are rather nice to use.",0.15,lisp
13ta9vj,jlzk562,"Let me go a step further: unless you require proof of the ranges of all the integers ever created, it is irresponsible to use fixed-width integers.",0.0,go
13ta9vj,jlz9ecz,This is one of the design goals for Swift for example.,0.0,swift
13ta9vj,jlz9ecz,"Swift has ""real"" compiled polymorphic generics, where the same compiled code can be applied to different types (via indirection).",0.06666666666666667,swift
13ta9vj,jlyp7dy,"Because this:      let max m n = if m>=n then m else n  is far less efficient than this:      let max (m:int) n = if m>=n then m else n  Even if you just do this:      let min(m, n) = if m<=n then m else n     let min_int(m, n) = min(m, n)  It compiles `min_int` into a tail call to `min` which is:      _camlTest__min_267:       sub     sp, sp, #32       str     x30, [sp, #24]     L101:       str     x0, [sp, #8]       str     x1, [sp, #0]       adrp    x8, _caml_lessequal@GOTPAGE       ldr     x8, [x8, _caml_lessequal@GOTPAGEOFF]       bl      _caml_c_call     L102:       cmp     x0, #1       b.eq    L100       ldr     x0, [sp, #8]       ldr     x30, [sp, #24]       add     sp, sp, #32       ret     L100:       ldr     x0, [sp, #0]       ldr     x30, [sp, #24]       add     sp, sp, #32       ret  That's virtual calls to generic functions via a C API.",-0.022222222222222216,c
13ta9vj,jlyhd3b,Having tried Lisps and Haskell I must say that the only place I have ever seen arbitrary precision by default work is computer algebra systems.,-0.05,haskell
13ta9vj,jlzpspe,">  > I have never used ocaml, but common lisp admits unboxed arrays, and they are rather nice to use.",0.15,lisp
13ta9vj,jlzpspe,Ok but Lisp is also grindingly slow.,0.09999999999999998,lisp
13ta9vj,jlzpspe,"Let me go a step further: unless you require proof of the ranges of all the integers ever created, it is irresponsible to use fixed-width integers.",0.0,go
13ta9vj,jlzmlac,> This is one of the design goals for Swift for example.,0.0,swift
13ta9vj,jlzmlac,"Swift has ""real"" compiled polymorphic generics, where the same compiled code can be applied to different types (via indirection).",0.06666666666666667,swift
13ta9vj,jlzt6vx,> Ok but Lisp is also grindingly slow.,0.09999999999999998,lisp
13ta9vj,jlztzjr,"> pushes all of the pointers in it onto the mark queue  Yes, and then when you go to trace those pointers, how do you find out what types they have?",0.0,go
13ta9vj,jlztzjr,> Lisp is also grindingly slow  [That so?,-0.30000000000000004,lisp
13ta9vj,jm26kv1,"Apple spent considerable amount of engineering resources on implementing this type of generics in Swift, I doubt they would just do it for the fun of it.",0.09999999999999999,swift
13ta9vj,jm26kv1,"For performance-critical sections of the code, monomorphization is certainly the way to go.",0.21428571428571427,go
13ta9vj,jm009qp,"> Tracing is a data miss factory;  In Lisp, sure.",0.5,lisp
13ta9vj,jm009qp,"> > pushes all of the pointers in it onto the mark queue >  > Yes, and then when you go to trace those pointers, how do you find out what types they have?",0.0,go
13ta9vj,jm2e2ke,"> Apple spent considerable amount of engineering resources on implementing this type of generics in Swift, I doubt they would just do it for the fun of it.",0.09999999999999999,swift
13ta9vj,jm2e2ke,Swift also uses RC.,0.0,swift
13ta9vj,jm2e2ke,"> For performance-critical sections of the code, monomorphization is certainly the way to go.",0.21428571428571427,go
13ta9vj,jm03exw,"If a sometimes contains a pointer to b, and sometimes to c, then with your approach, it's necessary to perform an (unpredictable) indirect branch to decide which code to execute.",-0.08333333333333333,c
13ta1b6,jlu5z6o,I'm not aware of any but the languages I know that do this are MMA/WL and Erlang.,-0.125,erlang
13ta1b6,jluu5xt,"This is still going to be slow for doubly linked lists, whose counts will commonly go to 2, even though no cycles would ever typically be created.",-0.19166666666666668,go
13ta1b6,jlvubqe,"Whenever you go to move a node, check that it won't become its own ancestor.",0.6,go
13ta1b6,jlw6qwi,"So if you wanted to expose a DEQUE written in C to a language akin to Python, then your PY\_INCREF and PY\_DECREF could manage things that way, and the interface to memory management would all work out.",0.0,c
13ta1b6,jlw6qwi,"So if you wanted to expose a DEQUE written in C to a language akin to Python, then your PY\_INCREF and PY\_DECREF could manage things that way, and the interface to memory management would all work out.",0.0,python
13t91mw,,"I'm bored of headers system in C, I want to start an experimental project for compiling C source without the need of forward declarations, and maybe add then support for generics and some runtime safety check as well.",-0.2,c
13t91mw,,"I have got some idea about how to parse C without a symbol table (I don't want to parse with it, since it would make forward declarations necessary again), but I have seen that D compiles this correctly      void main() {         Person* p = new Person(""John"", 30);     }          struct Person {         string name;         int age;     }  How does the compiler do this?",0.101010101010101,c
13t91mw,,"I have got some idea about how to parse C without a symbol table (I don't want to parse with it, since it would make forward declarations necessary again), but I have seen that D compiles this correctly      void main() {         Person* p = new Person(""John"", 30);     }          struct Person {         string name;         int age;     }  How does the compiler do this?",0.101010101010101,d
13t91mw,jluepx0,D uses unlimited lookahead and disallows certain expression statements (which allows `foo * bar;` to unambiguously be parsed as a declaration).,0.21428571428571427,d
13t91mw,jltw7um,IIRC D uses multi-pass compilation.,0.0,d
13t91mw,jltx6iv,"I don't know how d does it specifically but my guess would be that it has a pass where it 'registers' all types once it has parsed everything, then when doing semantics analysis it already knows all available types.",0.4,d
13t91mw,jltx6iv,But more importantly C's current syntax makes it impossible to parse usages of types before declarations.,-0.055555555555555546,c
13t91mw,jltx6iv,In other words C parsers will parse a statement differently if it starts with an ident which is the same as a previously declared type rather than a function for example.,-0.07291666666666666,c
13t91mw,jlu2kj3,I believe the D parser does multiple passes.,0.0,d
13t91mw,jlu2kj3,"[Heres a talk by Walter on the internals of the D compiler](https://www.youtube.com/watch?v=bNJhtKPugSQ) \- 20 minutes in lists the passes  D is also open source, so you could also [take a look at the code](https://github.com/dlang/dmd/tree/master/src)  Good luck, ✌",0.35,d
13t91mw,jltxmgz,Zig began as a fork of C without the preprocessor and evolved into something quite remarkable.,0.75,c
13t91mw,jlujngw,"I don't know D's syntax, but my language has out-of-order definitions, and there it causes ambiguities in parsing declarations involving user-defined types.",0.0,d
13t91mw,jlujngw,"The alternative was to change the syntax to remove the ambiguity, for example:      var A B ....               # `var` is always followed by a type     var B:A ....               # `:` always precedes a type  but I found the scheme workable.",0.0,scheme
13t91mw,jlujngw,"In examples like the following, out-of-order definations are invaluable:      record R = (int data; ref S link)     record S = (int data; ref R link)  Some languages get tied up in knots doing stuff like this.",-0.5,r
13t91mw,jlu76rr,"Thanks for the answer, I actually know how to parse context-free grammars without a symbol table, but D does not seem to be context-free, it has the same problem with declarations like C (`Person* var;`)  &#x200B;  >If there are ambiguities, you can still parse them into a tree which allows ambiguous forms, and the ambiguities can be resolved in later passes.",0.05,d
13t91mw,jlu76rr,"Thanks for the answer, I actually know how to parse context-free grammars without a symbol table, but D does not seem to be context-free, it has the same problem with declarations like C (`Person* var;`)  &#x200B;  >If there are ambiguities, you can still parse them into a tree which allows ambiguous forms, and the ambiguities can be resolved in later passes.",0.05,c
13t91mw,jlu7od9,"Cool, I know about zig but I was not aware of this, but my goal is actually to extend c but keep 100% compatibility with current c code, like circle with c++",0.056249999999999994,cool
13t91mw,jlu7od9,"Cool, I know about zig but I was not aware of this, but my goal is actually to extend c but keep 100% compatibility with current c code, like circle with c++",0.056249999999999994,c
13t91mw,jlu7od9,"Cool, I know about zig but I was not aware of this, but my goal is actually to extend c but keep 100% compatibility with current c code, like circle with c++",0.056249999999999994,c++
13t91mw,jlvhtf8,"> Person *var;  C deals with this via the Lexer Hack; the `typedef` must always terminate before any use of the `typedef`’d name (AFAIK—maybe you could use it in VLA dimensions), so you know it’s a typename.",0.0,c
13t91mw,jlvhtf8,"> Person *var;  C deals with this via the Lexer Hack; the `typedef` must always terminate before any use of the `typedef`’d name (AFAIK—maybe you could use it in VLA dimensions), so you know it’s a typename.",0.0,d
13t91mw,jlvhtf8,"C++ has the same restriction at block, global, and namespace scopes, but not within `struct`s or `class`es.",0.0,c++
13t91mw,jlvhtf8,"Even without templates, it’s quite possible that a C++ class won’t be able to finish/resolve the parse until reaching the end of the `struct`/`class` body:   	struct Foo { 		Foo(const T &) {T *var; var=0; static_cast<void>(var);} 		typedef Foo T; 	};  With C++ templates (which, when environmentally-unlimited, are themselves a fully Turing-Complete sub-language), parsing becomes undecidable.",0.25,c++
13t91mw,jlvhtf8,Aaaaaaaaaaall of this complication results from C’s gahddangfangled declaration syntax and the contortions everything has to undergo in order to maintain it.,0.0,c
13t91mw,jlvhtf8,"The intent was allegedly that declarations look like the expressions they’d be used in, so it’s little surprise there are parse ambiguities, and I hope this especially-metastatic example is a good enough reason for this idea to be done forsook all permanent-like.",0.103125,d
13t91mw,jlvhtf8,"It *does* make some sense to be able to do things like `&a := &b` for alias creation, but not using C type/declarator syntax, in either event, ’s fer damn sure, mmhmm.",0.5,c
13t91mw,jlvhtf8,"So the first and easiest thing to do would be *eliminate the cause of the Hack,* translate C code to your internal form at import, and move forward unconstrained.",0.125,c
13t91mw,jlvhtf8,"(You could even do this up properly and create a tool to build yourlanguage-native modules and library assemblies from C libraries/refs thereunto, their headers/refs thereunto, and any accompanying ancillary assets and autogenerators, all as an archive.",0.0,c
13t91mw,jlvhtf8,[Apologies; normally I’d avoid all alliteration assiduously.]),0.15,d
13t91mw,jlvhtf8,`:` is only used in C (in some relevant way—not counting e.g.,0.2,c
13t91mw,jlvhtf8,"Labels can do like Java and apply either to `{`braced`}` compound statements (`foo: {}` for the rough equivalent of `foo: (void)0;`) or control statements for use with `continue` and `break`, use a `label` keyword (`foo: label …` or `label(foo) …`; cf.",-0.5333333333333333,java
13t91mw,jlvhtf8,"GCC’s `__label__`), do a `for(register enum {…} __lbl=0;;) switch(__lbl) case 0:`) to avoid label use entirely, or go with a different delimiter like `>|`.",0.08333333333333333,go
13t91mw,jlvhtf8,"For ternary, you can use `if`/`else` as actual operators, rather than as statement markers, do Python’s unpleasant-in-practice `y if x else z` which makes it unclear whether `x` or `y` should be evaluated first, use `if`/`then`/`elif`/`else` as operators (`if x then y else z`), or use matching (switch !",0.15625,python
13t91mw,jlvhtf8,"You can dereference with trailing `@` to eliminate any possible ambiguity around `*`, and if you need `&` for something you can go with Microsoftean unary-`^` for pointer-to.",0.0,go
13t91mw,jlvhtf8,"You can even depart from the C type system and come up with structural sum/product/union/intersection types that can be converted to/from structs and unions with or without discriminants—e.g., `S >< T` or `struct(S, T)` →roughly the effects of  	// Given 	typedef __typeof(sizeof 0) __Size; 	#define __MKREF(quals, T)typedef struct {\ 		__typename(T) quals *ptr;\ 	} T##Ref 	typedef struct {unsigned len; char c[];} __CStr; 	__MKREF(__const, __CStr); 	typedef struct __Type__STAG__ __Type; 	__MKREF(__const, __Type); 	typedrf struct __Attrs__STAG __Attrs; 	__MKREG(__const, __Attrs); 	enum __types_FldVariety { 		__types_TUPLE_ELEM, __types_UNION_ELEM, 		__types_ISECT_ELEM, __typed_SUM_ELEM, 		__types_STRUCT_FIELD, __types_UNION_FIELD, 		__types_LOCAL_VAR, __types_MODULE_VAR, 		__types_LIB_VAR, __types_PRIV_VAR, 		__types_LOCAL_LABEL, __types_ENUM 	}; 	struct __types_FldInf { 		union { 			__umax uvalue; 			__imax ivalue; 			__bfrmax bfrvalue; 			const void *pvalue; 			struct {__Size offset, align, size;}; 		}; 		__CStrRef name; 		__TypeRef type; __AttrsRef attrs; 		enum __types_FldVariety variety; 	}; 	#define __CStrRef_NIL … 	#define __AttrsRef_NIL … 	#define __TypeRef_FOR(...)… 	…  	#ifndef __product___S___T 	typedef struct { 		S __product_fld_0; 		T __product_fld_1; 	} __product___S___T; 	inline const struct __types_FldInf __product___S___T__FIELDS[2] = { 		{ 			.offset=offsetof(__product___S___T,__product_fld_0), 			.align=alignof(S), .size=sizeof(S), 			.name=__CStrRef_NIL, 			.type=__TypeRef_FOR(S), 			.attrs=__AttrsRef_NIL, 			.variety=__types_TUPLE_ELEM 		}, { 			.offset=offsetof(__product___S___T, __product_fld_1), .align=alignof(T), .size=sizeof(T), 			.name=__CStrRef_NIL, .type=__TypeRef_FOR(T), .attrs=__AttrsRef_NIL, 			.variety=__types_TUPLE_ELEM 		} 	}; 	#define __product___S___T __typename(__product___S___T) 	#endif  (which could easily be exported in a simpler table form and autogenned from that, even staying within C/++ using xmacros or xincludes), and `S -|- T` or `union(S, T)` as  	#//etc.",0.43333333333333335,c
13t91mw,jlvhtf8,"You can parse all alternatives (try both typename and vanilla identifier if there’s ambiguity; whichever one parses fully & without error is the interpretation you go with, and >1 left at the end is an error, or requires dynamic assistance if you’re really in a mood.",0.06666666666666667,go
13t91mw,jlubmby,"C has clear keywords to tell you whether something is an enum, struct, typedef etc, to allow you to parse unambiguously.",0.10000000000000002,c
13t91mw,jluc53n,"The zig compiler also compiles C and you can mix and match as required (as far as I can recall) - so yeah, there's that.",0.1,c
13t91mw,jlubcdj,**C to Python Example.,0.0,c
13t91mw,jlubcdj,**C to Python Example.,0.0,python
13t91mw,jlubcdj,**  C:      int C = 5;  Python:     C = 5  **Are your source P.L.,0.0,c
13t91mw,jlubcdj,**  C:      int C = 5;  Python:     C = 5  **Are your source P.L.,0.0,python
13t91mw,jludopu,"zig uses clang under the hood to compile c, btw what does ""zig began as a fork of c"", c is a standard not a compiler",0.0,c
13t8usy,jlvy2o0,"C++ meanwhile just keeps invalid references in the lexical scope after a move, but nullifies them.",0.0,c++
13t8usy,jltzu4k,"It's implemented in Rust, and I use the im-crate, which provides immutable data structures.",0.0,rust
13t8usy,jltzu4k,"So if a structure is shared, and the original is dropped, the Rust persistent data structure takes care of that under the hood.",0.375,rust
13t8usy,jltzu4k,"There are basically two layers of memory management: the one I program, and the one that is provided by the immutable data structures in Rust.",0.0,rust
13t8usy,jm0da55,"We can go further with stack regions and Copying GCs: a Copying GC is fast (partly) because it moves objects out of a region, then frees the entire region in a single operation.",0.03214285714285715,go
13t8usy,jm1grj9,"I like your idea, but that sound like too much work for a project that I want to finish alone, so I'll probably go with one of the standard approaches that were linked in this thread.",0.20000000000000004,go
13syh3m,,"I've been looking into making a transpiler, but when I go to create the output in the target language, the only thing I can think to do is use a lot of recursive string substitution.",0.0,go
13syh3m,jlsixt9,"For example in Rust there is crated named ""syn"" that can parse rust code and represent it in a data struct, so you can also generate this struct as your transpiler output and then deserialize into plain rust code.",-0.21428571428571427,rust
13syh3m,jlsr58u,There are a couple C to Rust transpilers that you can look at for an example.,0.0,c
13syh3m,jlsr58u,There are a couple C to Rust transpilers that you can look at for an example.,0.0,rust
13syh3m,jlt2xb9,"When not generating binary output files, I've used textual output as C source files, ASM source files, and IL source codes, all formats that were then processed by separate tools.",0.0,c
13syh3m,jlt2xb9,"The C version was the most challenging since the output is structured, and nested (unless you are generating very low level C - not recommended).",0.3333333333333333,c
13syh3m,jlt2xb9,"For example even writing expressions like `a = b << c + d` takes a lot of care since you need to consider operator precedences of the target, but then you don't want too many parentheses either.",0.5,c
13syh3m,jlt2xb9,"For example even writing expressions like `a = b << c + d` takes a lot of care since you need to consider operator precedences of the target, but then you don't want too many parentheses either.",0.5,d
13syh3m,jot0bj5,They are often used in web development to convert modern code written in languages like TypeScript or ES6 into backward-compatible versions that can run on older versions.,0.18333333333333335,typescript
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,swift
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,kotlin
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,objective-c
13syh3m,jot0bj5,"Transpilers are also used in mobile app development to translate code written in one language (e.g., Swift or Kotlin) into another (e.g., Objective-C or Java) to ensure cross-platform compatibility.",0.0,java
13syh3m,jltx508,"I like to compare an old ""Pascal vs C"" comparison about string manipulation.",0.1,pascal
13syh3m,jltx508,"I like to compare an old ""Pascal vs C"" comparison about string manipulation.",0.1,c
13syh3m,jlsvod4,I thought about transpiling to JavaScript through TypeScript's compiler.,0.0,javascript
13syh3m,jlsvod4,I thought about transpiling to JavaScript through TypeScript's compiler.,0.0,typescript
13syh3m,jlsvod4,"TypeScript's compiler is available as [an API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API), so the idea is to inject a compliant AST and have it do its magic.",0.45,typescript
13syh3m,jlvlexl,I may be weird but I find the idea of using XSLT for that really cool.,-0.07500000000000001,cool
13syh3m,jltdkw9,My compiler is written in rust and emits c but I wouldn’t mind emitting rust,0.0,rust
13syh3m,jltdkw9,My compiler is written in rust and emits c but I wouldn’t mind emitting rust,0.0,c
13syh3m,jlso0r2,"If I were to translate my AST into Lua syntax, for example, how would it actually write that Lua?",0.0,lua
13syh3m,jlsptvv,Are you trying to transpile to a Lua program that would be as close as possible to something a person would write?,0.0,lua
13syh3m,jlsptvv,You could recursively traverse the AST with each node outputting a string that is the Lua code semantically equivalent to what the AST node represents.,0.0,lua
13syh3m,jlsptvv,"However, if you are trying to transpile to a highly optimized subset of Lua, the code generation may be more akin to emitting a low-level language.",0.33,lua
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,typescript
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,javascript
13syh3m,jlsptvv,"TypeScript transpiled to JavaScript would be an example of the former, while C++ transpiled to asm.js would be an example of the latter.",0.0,c++
13syh3m,jltgb8l,"You can also build up a lua AST and then pretty print that, but the result is roughly the same",0.049999999999999996,lua
13syh3m,jlt1n33,Here are some examples of transpilers which output Lua:   https://github.com/rochus-keller/Oberon/blob/master/ObLuaGen2.cpp  https://github.com/rochus-keller/Som/blob/master/SomLuaTranspiler.cpp,0.0,lua
13syh3m,jltgz3s,[(Computerphile videos)](https://www.youtube.com/@Computerphile/search?query=parser)  JavaScript or Python have a buildt-in function that transforms a string into a dictionary.,0.0,javascript
13syh3m,jltgz3s,[(Computerphile videos)](https://www.youtube.com/@Computerphile/search?query=parser)  JavaScript or Python have a buildt-in function that transforms a string into a dictionary.,0.0,python
13syh3m,jlzj32y,:D,1.0,d
13syh3m,jlss16m,"Lua was just an example, but yeah, that's kind of what I want.",0.6,lua
13syh3m,jlss16m,"My real goal is to emit a virtual machine assembly language called UXNTAL, but in a way that can be read by humans still.",0.2,assembly
13syfpk,,"I've been wondering how languages call functions from their host language, like Lua and C#.",0.0,lua
13syfpk,,"I've been wondering how languages call functions from their host language, like Lua and C#.",0.0,c
13syfpk,,"I know Lua has a Metatable, and C# needs bindings/metadata, I think, but I'm not sure where it goes beyond that.",-0.25,lua
13syfpk,,"I know Lua has a Metatable, and C# needs bindings/metadata, I think, but I'm not sure where it goes beyond that.",-0.25,c
13syfpk,jlsn93y,"When Lua calls a C function, it passes a pointer to the interpreter's stack to the C function, the C function has to manually pop off the parameters from the interpreter's stack, and if it returns something to the interpreter the C function pushes it back on the stack.",0.0,lua
13syfpk,jlsn93y,"When Lua calls a C function, it passes a pointer to the interpreter's stack to the C function, the C function has to manually pop off the parameters from the interpreter's stack, and if it returns something to the interpreter the C function pushes it back on the stack.",0.0,c
13syfpk,jlsrdqp,"When C code calls into Lua, a value representing a lua function is pushed to the lua stack, along with it's arguments, then a lua c api function is called that pops the lua function and some number of arguments off of the stack and calls the given function with that number of arguments.",0.0,c
13syfpk,jlsrdqp,"When C code calls into Lua, a value representing a lua function is pushed to the lua stack, along with it's arguments, then a lua c api function is called that pops the lua function and some number of arguments off of the stack and calls the given function with that number of arguments.",0.0,lua
13syfpk,jltmthm,Here's a practical example with a naive hypothethical Lua interpreter written in Python.,-0.3,lua
13syfpk,jltmthm,Here's a practical example with a naive hypothethical Lua interpreter written in Python.,-0.3,python
13syfpk,jltmthm,"# Lua     function inc (n)         return n + 1     end     a = 5     ---     b = inc(n)     print(b)  To keep track of the local scope, the host will probably have something like a map from names to values.",0.0,lua
13syfpk,jltmthm,"At the `---` point, that map looks like this:      # Python     scope = {         ""inc"": LuaFunction(name=""inc"", args=[""n""], fn=<function ...>),         ""a"": LuaInteger(5),     }  The Lua statement `b = inc(n)` is then equivalent to      # Python     scope[""b""] = scope[""inc""].fn(scope[""a""])  in the host language.",0.0,python
13syfpk,jltmthm,"At the `---` point, that map looks like this:      # Python     scope = {         ""inc"": LuaFunction(name=""inc"", args=[""n""], fn=<function ...>),         ""a"": LuaInteger(5),     }  The Lua statement `b = inc(n)` is then equivalent to      # Python     scope[""b""] = scope[""inc""].fn(scope[""a""])  in the host language.",0.0,lua
13syfpk,jltmthm,"Now to answer your question, if you want the ""print"" function in Lua to invoke the host's ""print"", you just need to format it in a way that's compatible with the example call above, and inject it into the `scope` map.",0.0,lua
13syfpk,jltmthm,"In this case, wrap it in a `LuaFunction` object:      # Python     host_print = lambda value_to_print: print(""From Lua:"", value_to_print.to_pystring())     scope[""print""] = LuaFunction(name=""print"", args=[""value_to_print""], fn=host_print)  Now when Lua does       # Lua     print(b)  it's executed as      # Python     scope[""print""].fn(scope[""b""].to_string())  Which is equivalent to calling Python's ""print"" like so:      # Python     print(""From Lua:"", LuaInteger(6).to_string())  You can also do it the other way around, calling Lua from Python.",-0.125,python
13syfpk,jltmthm,"In this case, wrap it in a `LuaFunction` object:      # Python     host_print = lambda value_to_print: print(""From Lua:"", value_to_print.to_pystring())     scope[""print""] = LuaFunction(name=""print"", args=[""value_to_print""], fn=host_print)  Now when Lua does       # Lua     print(b)  it's executed as      # Python     scope[""print""].fn(scope[""b""].to_string())  Which is equivalent to calling Python's ""print"" like so:      # Python     print(""From Lua:"", LuaInteger(6).to_string())  You can also do it the other way around, calling Lua from Python.",-0.125,lua
13syfpk,jltmthm,"After the Lua code has finished executing:      # Python     b = scope[""inc""].fn(LuaInteger(5))     print(b.to_pyint())  and you've called a Lua function from Python.",0.0,lua
13syfpk,jltmthm,"After the Lua code has finished executing:      # Python     b = scope[""inc""].fn(LuaInteger(5))     print(b.to_pyint())  and you've called a Lua function from Python.",0.0,python
13syfpk,jltmthm,"- Designing your VM to work with host primitives (pure `int` instead of `LuaInteger(int)`) - Injecting variables into the local scope works well (Python's `print` is itself implemented like that), but allows the guest to mess around with it in counterproductive ways (`print = exit; print(0)` is perfectly valid Python).",0.2598214285714286,python
13syfpk,jltmthm,"I consider this a plus to prevent confusion and improve security, but if you want maximally flexible guests, you can:  - Inject all builtins (`scope.update(locals())` puts all Python's local names in the scope map).",0.0,python
13syfpk,jlslmri,The Lua interpreter is a C program.,0.0,lua
13syfpk,jlslmri,The Lua interpreter is a C program.,0.0,c
13syfpk,jlslmri,"If you download [the source](https://www.lua.org/download.html) and unpack it, you'll find a `src/` directory which contains the C code that does the [lexing](https://en.wikipedia.org/wiki/Lexical_analysis) and [parsing](https://en.wikipedia.org/wiki/Parsing) of Lua code, which eventually results in calling code elsewhere in the codebase (e.g.",0.0,c
13syfpk,jlslmri,"If you download [the source](https://www.lua.org/download.html) and unpack it, you'll find a `src/` directory which contains the C code that does the [lexing](https://en.wikipedia.org/wiki/Lexical_analysis) and [parsing](https://en.wikipedia.org/wiki/Parsing) of Lua code, which eventually results in calling code elsewhere in the codebase (e.g.",0.0,lua
13syfpk,jlslmri,"In terms of the situation where Lua is embedded in a larger program, details about how it works in that context can be found in [this section of the Lua reference manual](https://www.lua.org/manual/5.4/manual.html#4).",0.0,lua
13syfpk,jlslmri,"However, Lua doesn't have to be embedded in a larger program; it can also be run [standalone](https://www.lua.org/manual/5.4/manual.html#7).",0.0,lua
13syfpk,jlslmri,"For example, the [Prosody XMPP chat server](https://en.wikipedia.org/wiki/Prosody_(software)) is written in Lua.",0.0,lua
13syfpk,jlslmri,"Finally, and more generally, programming languages often have a '[foreign function interface](https://en.wikipedia.org/wiki/Foreign_function_interface)' (FFI) allowing a language to call functionality of another language (often C).",0.10625000000000001,c
13syfpk,jltg7d3,"I recently wrote a scripting language, and the way this worked for that is the host language (Java) had to tell the scripting system which static methods it wanted the scripts to be able to call, but could call instance methods freely.",0.35,java
13syfpk,jltg7d3,"I do this to make searching for a method a tractable problem, by not having to go through every class in memory.",0.0,go
13syfpk,jltmtwi,"C has a standardized ABI, or a way to call a function from other machine code independently of the language.",-0.0625,c
13syfpk,jltmtwi,It's how you can just call C functions in python without any issues in the REPL.,0.0,c
13syfpk,jltmtwi,It's how you can just call C functions in python without any issues in the REPL.,0.0,python
13syfpk,jltmtwi,"C# goes a bit further by having a lot of compatibility with C. You can still use pointers, including function pointers, to call C functions.",0.0,c
13syfpk,jltmtwi,You can also declare a function as `extern` and then call that native function from normal C# code as if it were written in C#.,0.15,c
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,c
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,java
13syfpk,jltmtwi,"And the language allows you to easily define structs comparable to C structs, so compatibility with C isn't a problem compared to Java, where you'd often need to generate C or C++ source files to call nontrivial native code from the JVM.",0.43333333333333335,c++
13syfpk,jlwvdhf,Though if your host language is C++ you *could* just write horrifying undebuggable templates instead.,-0.9,c++
13syfpk,jluspse,"A long time ago, I had a little C program/library that worked with a bunch of different languages, both calling into the languages and being called by the languages.",-0.07916666666666666,c
13syfpk,jluspse,"In the end, there's two problems: - Given the name of a function in the scripting language, how can you call the right C function?",0.2857142857142857,c
13syfpk,jluspse,"- How can you pass the right ""stuff"" so the C function works correctly and doesn't get horked?",0.2857142857142857,c
13syfpk,jluspse,A simple way is that the C program will pass a dictionary that maps strings that are the function names to function pointers.,0.0,c
13syfpk,jluspse,"If the C program has a ""shared library"" or ""DLL"" interface, the OS will have some functions that can paw through  the library and return a dictionary that maps strings to function pointers.",0.0,c
13syfpk,jluspse,"Or old school fortran would potentially have each argument in its own memory location, dropping the stack requirement entirely.",0.175,fortran
13syfpk,jluspse,"Of all the languages, Erlang had a ton of documentation saying how hard it was to do this, but it was actually easy.",0.07083333333333333,erlang
13syfpk,jluspse,"And Perl had a ton of documentation saying how easy it was, but it was actually impossible in the general case (because Perl could work differently depending on what compiler you used to compile Perl, but that wasn't specified by anyone).",-0.045833333333333316,perl
13syfpk,jlucpj1,"No, C has no standard ABI.",0.0,c
13syfpk,jlucpj1,"When a specific C compiler  exposes some function name in the the .OBJ or .o files that it's making, it will often use the common calling convention for whatever system it's on.",-0.15,c
13syfpk,jlucpj1,"On the old VAX/VMS system, for example, there was a detailed spec for how all languages were supposed to surface functions and also for listing the functions that were going to be called; the DEC C compiler followed those conventions so that it was (mostly) easy to for a program to be composed of modules written in multiple languages.",0.23333333333333334,c
13syfpk,jluhfx0,But there is a standard ABI across C programs compiled for the same platform - even if it isn't necessarily coupled to the C language - and other languages make use of that.,-0.03125,c
13syfpk,jluqt2c,"An older version of the same thing was old Mac applications, where the common calling convension for C wasn't compatible with the ""pascal"" calling convention used by the OS.",-0.008333333333333331,c
13syfpk,jluqt2c,"An older version of the same thing was old Mac applications, where the common calling convension for C wasn't compatible with the ""pascal"" calling convention used by the OS.",-0.008333333333333331,pascal
13shh4m,,"I've toyed around with compilers for a while, one (successful) lisp-like to asm, and one (less successful) C to asm; but never anything quite as complex as citrus.",0.25833333333333336,c
13shh4m,jlq4fl2,"It's a little overwhelming, but you can take a look at Rust's [internal documentation](https://rustc-dev-guide.rust-lang.org/mir/index.html).",0.10416666666666667,rust
13shh4m,jlq4fl2,"Depending on your language semantics, you may want to look at other compilers for inspiration, such as OCaml or Haskell.",-0.0625,haskell
13shh4m,jlq5h09,"I looked at old books for this, and I'm currently going through this book: Retargetable C Compiler, A: Design and Implementation https://a.co/d/awDr2B8  It's an old book but it's actually one of the better instruction books I've found.",0.13999999999999999,c
13shh4m,jlq5h09,It walks you on the design of an ANSI C compiler called lcc.,0.0,c
13shh4m,jlq5h09,Only downside is that some of the source is written K&R style.,0.0,r
13shh4m,jlq2yt2,"Even if you don't use C++, LLVM has bindings to most languages, so everything should still be similar.",0.25,c++
13shh4m,jlpxaqm,Check out Writing a compiler in go by thorsten ball.,0.0,go
13shh4m,jm21h4k,"thank you, I'll look into rust's code",0.0,rust
13s3f9c,jlo10yz,"From what I can remember, Matlab actually does this for lines that *don’t* have semicolons.",0.0,matlab
13s3f9c,jloddn1,"(I think I used something like `DPRINTF` in C, which either passed on its args to `printf`, or was an empty macro, but printing anything in C was a pig anyway.)",-0.1,c
13s3f9c,jloycur,"Julia does something similar to this; only expressions not terminated by a semicolon return a value, and only statements that return a value get printed at the REPL.",0.0,julia
13s3f9c,jloi99a,Is this mindset good for a programming language though that's a thing to think about 🤔 (I'm staring at you typescript!),0.875,typescript
13rztfp,,"lazy x = e();     if(conditional) {       // `x` is only computed if `conditional` returns true       console.log(x);     }  &#x200B;      lazy x = e();     function f() {       // `x` is only computed when `f` is called       // repeated calls don't recompute `x`       return x;     }  **Emulating Call by Need**  Consider this Javascript function:      function need(condition, expensive) {         if(condition) {             return f(expensive(), expensive());         } else {             return g();         }     }  Here the intention is that `expensive` is a call by need argument (while conditional is call by value).",-0.20625,javascript
13rztfp,,"If we imagine Javascript argument with a lazy let, then we can use it to build the thunk for us.",-0.25,javascript
13rztfp,,This would allow creation of lazy lists that appear in functional languages like Haskell.,-0.25,haskell
13rztfp,jlnj0gj,Dart does this.,0.0,dart
13rztfp,jlnj0gj,"Dart also has `late` as a modifier for variable declarations, which does more or less what you describe here.",0.011111111111111118,dart
13rztfp,jlnj0gj,"(In Dart, we check this at runtime and throw an exception if a cyclic initialization is encountered.)",0.0,dart
13rztfp,jlnj0gj,"### Async/await  Dart, like several other languages, also has async/await.",-0.0625,dart
13rztfp,jlnj0gj,The answer for Dart is that it doesn't: You simply can't use await inside the initializer for a late variable.,-0.15,dart
13rztfp,jlnj0gj,We don't have that in Dart and in practice it means that sometimes you end up having to use nullable non-lazy variables and implement the lazy initialization yourself.,-0.25,dart
13rztfp,jlo3dux,"Kotlin sort of provides this, though not as a first-class language feature.",0.0,kotlin
13rztfp,jlo3dux,"But `by` instead invokes a Kotlin language feature called [""property delegation""](https://kotlinlang.org/docs/delegated-properties.html).",0.0,kotlin
13rztfp,jlo3dux,I think Kotlin's approach is quite nice.,0.6,kotlin
13rztfp,jlpzztq,"Scala has `lazy val` and ""by name"" parameters.",-0.25,scala
13rztfp,jlolvvl,"Here is how you could do it in Java      class Lazy<A> {         // Supplier<A> is a function that takes no arguments and returns an A         private Supplier<A> thunk;         private A result;              public Lazy(Supplier<A> thunk){             this.thunk = thunk;             this.result = null;         }         public A force() {             // This means the thunk has already been forced             if (thunk == null) {                 return this.result;             } else {                 let result = thunk();                 // remove the thunk to allow it to be garbage collected                 thunk = null;                 this.result = result;                 return result;             }         }     }  Now, it might still make sense to add `lazy` expressions to the language, because allocating a closure might be more expensive than computing the result and with an expression, the compiler can make the decision to do either (if the computation is pure).",-0.03730158730158731,java
13rztfp,jlqjjwd,Kotlin supports this but as a subset of a much more powerful operator called `by`.,0.4,kotlin
13rztfp,jlnks8t,Oh cool.,0.35,cool
13rztfp,jlnks8t,>Recursive references  The standard answer in a language like Haskell is that your program simply doesn't halt.,0.0,haskell
13rztfp,jlo5rhu,"Yeah, I think this is heavily inspired by C#.",-0.2,c
13rztfp,jlo5rhu,"In the case of C#, you often want to write code that's still fairly fast for a JITed language, and explicitly seeing what's going on is a part of that.",0.2,c
13rztfp,jlqaxm5,D has a `lazy` keyword that is _only_ for function parameters and is essentially just syntax sugar for wrapping the value in a lambda as per usual.,-0.125,d
13rztfp,jlo9ub0,"To be fair, what you describe handles the `lazy { ... }` part of the Kotlin code.",0.22499999999999998,kotlin
13rztfp,jlo9ub0,"That would be more like:      class Wrapper {         private var fooImpl = new Lazy<int>(() => 42);                  public int Foo => fooImpl.Value     }  (There might be a better way to do that now, but my C# experience is fairly old at this point.)",0.20606060606060606,c
13rztfp,jlo9ub0,"With C#, you'd use `foo.Value`.",0.0,c
13rztfp,jlo9ub0,"In Kotlin, if you just use `lazy { ... }`, you'd then use `foo.value`.",-0.25,kotlin
13rztfp,jlot3y2,"The type isn't inferred because as far as I remember, C# only infers generic type parameters in method calls, not in constructors.",0.03333333333333333,c
13rztfp,jlqkn8l,D's system instead requires requires functions types to be augmented with some lazyness feature.,0.0,d
13rztfp,jlognnc,To my knowledge that's still the state of the art in C#.,0.0,c
13rztfp,jlpoigu,"I'd rather have the option to use lazies (even ""hidden lazies"" using Kotlin property delegation) than to be prevented from using them at all.",-0.16666666666666666,kotlin
13rztfp,jlprj08,"And C# now has Roslyn Analyzers: basically compiler plugins that you can write as simple C# code, in parallel packages (""projects"" in a ""solution"") and that just run and do work at compile time.",0.0,c
13rnxrk,jlmscga,"If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,haskell
13rnxrk,jlmscga,"If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,rust
13rnxrk,jlmmu3g,"**Type Info** Let's say my AST node looks like this:      record unit =           # I call a node a 'unit'         int tag             # manually tagged union as warned         ref unit a, b, c    # 0-3 child nodes, but each can be a list too         int value           # for a constant terminal (unions not shown)         symbol def          # reference into ST for an identifier         int mode            # type code for this unit, index into TT         int sourceoffset    # xref to source code         int fileno     end  So types are represented by an index in my case.",0.0,c
13rnxrk,jlmmu3g,Pass 2 is name resolution which must be done first (this also depends on language; in C you only need one pass).,0.125,c
13rnxrk,jlnurwv,"Actually Python does that for me, but ... ISTR making it explicit by calling `string.intern(...)`.",0.0,python
13rnxrk,jlpmes8,"This arrangement works for something like C, where you can only reference stuff above.",0.0,c
13rnxrk,jlpk67r,>I would be very surprised if there wasn't some black magic that let you do this in TypeScript.,0.15444444444444447,typescript
13rnxrk,jlpk67r,But I still needed your explanation & the TypeScript explanation above to level me up in understanding enough to code it.,0.0,typescript
13rnxrk,jltk9ut,"> If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,haskell
13rnxrk,jltk9ut,"> If you're using Haskell, Rust or possibly OCaml, Trees that grow might be a really nice solution.",0.3,rust
13rnxrk,jltk9ut,"FWIW, if you're using Rust or OCaml I recommend just decorating the tree externally using a separate hash table.",0.0,rust
13rjs77,jlklen3,"Rhombus is an experimental new language being developed by the Racket team which shifts away from lisp's traditional s-expressions to an indentation based syntax --- in contrast to other whitespace based lisps, indentation isn't used simply as a replacement for parenthesis, and instead Rhombus code (and macros) operate over a richer representation than S-expressions that it calls shrubbery.",0.035227272727272725,lisp
13rjs77,jll1qmk,Very cool project; thanks for sharing!,0.3525,cool
13rjs77,jlqbck8,:D,1.0,d
13rij54,jlkgzpe,I encourage you to look at *raw string literals* in C# 11.,-0.23076923076923078,c
13rij54,jlkgzpe,And so forth.,0.0,forth
13rij54,jlmdy39,Two interesting implementations are ruby and postgres.,0.5,ruby
13rij54,jlmdy39,In ruby you have four ways of doing this.,0.0,ruby
13rij54,jlmdy39,Two are heredoc syntaxes      <<-SQL     SELECT * FROM food     WHERE healthy = true     SQL  And indent saving version      page = <<-HTML        Heredocs are cool & useful     HTML  You also have the %Q and %q formats these do or do not allow interpolation and let you choose the delimiterer for example %Q{..} or %Q/../ or whatever.,0.375,cool
13rij54,jlmdy39,Two are heredoc syntaxes      <<-SQL     SELECT * FROM food     WHERE healthy = true     SQL  And indent saving version      page = <<-HTML        Heredocs are cool & useful     HTML  You also have the %Q and %q formats these do or do not allow interpolation and let you choose the delimiterer for example %Q{..} or %Q/../ or whatever.,0.375,html
13rij54,jlmdy39,In postgres the format is         $optionalTag$            some text here        $optionalTag  Most people just go with $$ sometext $$  This allows you to embed heredocs inside of heredocs which I have actually had to do once.,0.25,go
13rij54,jll3656,"I uses the rust approach, but additionally I allow appending a dollar sing for custom string interpolation blocks ```js let tagged = ident""tagged string""   let tagged_with_and_allow_qoutes = ident#""tagged with qoutes """" string""#   let interpolated = ident#""tagged with qoutes """" string and {x + y}""#   let interpolated_with_custom_expr_block = ident#$""tagged with qoutes """" string and ${interpolated}""#   let order_does_not_matter = #$#$""$${x + y}""##   ```",0.0,rust
13rij54,jlkk8vs,"C# raw strings look cool, this is indeed a very similar idea.",0.039743589743589734,c
13rij54,jlkk8vs,"C# raw strings look cool, this is indeed a very similar idea.",0.039743589743589734,cool
13rij54,jlkk8vs,":      `dedent         This is a text         across multiple         lines, which will         NOT have indentation space before each line     `  EDIT: see also [this comment](https://www.reddit.com/r/ProgrammingLanguages/comments/13rij54/multistrings_a_simple_syntax_for_heredocstyle/jlkpuun/) showing how to achieve the exact behavior of C# with a multistring which uses ' instead of linebreaks as separators.",0.125,c
13rij54,jlkk8vs,"Same for interpolation:       `$     The name is ""{name}""     `  (Although I'd go with `${name}` here to match the tag nicely and reduce the need for `{{}}`).",0.3,go
13rij54,jlkk8vs,JavaScript has a similar feature known as [tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).,0.0,javascript
13rij54,jlki85v,"Yep, Rust's seems like a good implementation of the basic feature.",0.35,rust
13rij54,jlki85v,A little metadata to go with the string.,-0.1875,go
13rij54,jlki85v,Rust's syntax could be easily extended to support that.,0.43333333333333335,rust
13rij54,jlki85v,"A similar thing can also be achieved with combining raw strings with other language features (as long as such are available, which is true for Rust).",0.049175824175824175,rust
13rij54,jllje1a,But it doesn't take much to go beyond that limitation and if the environment you're working in is a little more advanced then this syntax is simple enough to be accommodated.,0.15208333333333332,go
13rij54,jllkn76,;D,0.25,d
13rij54,jlklp7u,"C#:      indented4 =          """"""             {                 ""Name"": ""Zaphod""             }         """""";          nonindented =          """"""         {             ""Name"": ""Zaphod""         }         """""";  Here indented4 will have this value (indented 4 spaces):          {             ""Name"": ""Zaphod""         }   And nonindented:      {         ""Name"": ""Zaphod""     }",-0.75,c
13rij54,jlmfxmd,"For example a function that returns a large string could simply be tagged or have annotations        #[html]       def foo(a, b, c)         <p> \(a) goes here and then \(b) and then \(c) </p>       end  This would give you tremendous flexibility and result in very readable code.",0.1869047619047619,html
13rij54,jlmfxmd,"For example a function that returns a large string could simply be tagged or have annotations        #[html]       def foo(a, b, c)         <p> \(a) goes here and then \(b) and then \(c) </p>       end  This would give you tremendous flexibility and result in very readable code.",0.1869047619047619,c
13rij54,jlkotne,"***      `    |       {           ""Name"": ""Zaphod""       }     `  (a bit wacky, but short)      `dedent+         |             {                 ""Name"": ""Zaphod""             }     `  (the first line is discarded in the output; the position of `|` there dictates where to stop dedenting, effectively acting as the closing delimiter in C#)      `dedent++         |   {         |       ""Name"": ""Zaphod""         |   }     `  discard everything in every line up to and including `|` (must be space) -- I think Scala does something similar.",0.15,c
13rij54,jlkotne,"***      `    |       {           ""Name"": ""Zaphod""       }     `  (a bit wacky, but short)      `dedent+         |             {                 ""Name"": ""Zaphod""             }     `  (the first line is discarded in the output; the position of `|` there dictates where to stop dedenting, effectively acting as the closing delimiter in C#)      `dedent++         |   {         |       ""Name"": ""Zaphod""         |   }     `  discard everything in every line up to and including `|` (must be space) -- I think Scala does something similar.",0.15,scala
13rij54,jlkotne,"But personally, I'd just go with      `     {         ""Name"": ""Zaphod""     }     ` if I wanted no indent  and      `         {             ""Name"": ""Zaphod""         }     `  if I wanted.",0.0,go
13rij54,jlkotne,"In the end, you could choose to implement a variant which would work exactly like C#, allowing the closing delimiter to be indented.",0.25,c
13rij54,jlkotne,"Personally I always lean towards minimalism, but more and more I don't mind letting go here and there.",0.3333333333333333,go
13rij54,jlktfup,I'm sure C++ brings much excitement with its implementation.,0.35,c++
13rij54,jlkpuun,"So you could implement the `dedent` tag to work exactly like in C#, perhaps getting the best of both worlds.",0.625,c
13rij54,jlmcon0,Like javascripts inside of html.,0.0,html
13rij54,jlks874,":D), just to inspire people like you and start a discussion.",1.0,d
13rhbhd,,"I've written a lot of C, and I won't deny that it does come up to bite you, I still don't understand the hatred.",0.0,c
13rhbhd,,"No one complains when a python function returns """" if there's an error.",0.0,python
13rhbhd,,No one complains if a C function returns -1.,0.0,c
13rhbhd,,This is normal behavior when invalid inputs are given to a language that doesn't have advanced error handling like Rust.,0.275,rust
13rhbhd,,"However, seeing people discuss them you'd think anyone who doesn't use Rust is a caveman for allowing NULL pointers to exist in their programming languages.",0.0,rust
13rhbhd,,"As if this post wasn't controversial enough, I'm going to assert something else even more controversial: The level Rust goes to in order to prevent NULL pointers is ridiculously over the top for the majority of cases that NULL pointers are encountered.",0.29444444444444445,rust
13rhbhd,jlk7xv6,With pointers in C the problem is you never know if the pointer returned by a function may be zero or not.,0.0,c
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,python
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,c
13rhbhd,jlki7kh,"This is pretty common: in Python it might be `None`, in C there's the `NULL` pointer, in Java there's `null`, etc.",-0.024999999999999994,java
13rhbhd,jlki7kh,"In the type system of, say, C, there is no difference between a valid pointer pointing to an integer, and the invalid NULL pointer.",0.0,c
13rhbhd,jlki7kh,"One of the big reasons that we like type systems is that they prevent us from making mistakes, like putting a string where an integer needs to go.",0.0,go
13rhbhd,jlki7kh,"There are different ways to do that, but here's how that works in Typescript:  We define `null` as a type in its own right, and we define `string` such that it can never be `null`.",0.22142857142857142,typescript
13rhbhd,jlki7kh,"Objective-C treats all nulls like ""empty"" values of their type, so a null interpreted as a number is zero, accessing a field of a null object returns another null, etc.",-0.1,objective-c
13rhbhd,jlk9htg,I really don't see how Rust's avoidance of null pointers is over the top.,0.35,rust
13rhbhd,jlk9htg,"I wouldn't even say Rust avoids it, it just doesn't fit into the language design given that it has Option.",0.4,rust
13rhbhd,jlk9htg,The main ergonomic issue with null pointers isn't the concept of having a pointer go to 0.,0.16666666666666666,go
13rhbhd,jlk9htg,"In C you can practically toss `(void*) 0` into anything, and in Java you can also set any type to `null`.",0.25,c
13rhbhd,jlk9htg,"In C you can practically toss `(void*) 0` into anything, and in Java you can also set any type to `null`.",0.25,java
13rhbhd,jlk9htg,"Languages that make that distinguishment are a lot easier to reason about (whether that's in the language itself like Kotlin, or in the library like Rust).",0.0,kotlin
13rhbhd,jlk9htg,"Languages that make that distinguishment are a lot easier to reason about (whether that's in the language itself like Kotlin, or in the library like Rust).",0.0,rust
13rhbhd,jlk9htg,There's also the security issue that they bring alongside languages like C which is honestly enough to warrant avoiding them.,0.0,c
13rhbhd,jlkszdn,Kotlin has nulls and its type system makes it perfectly safe (and convenient) to use them whenever you need them to represent the absence of value.,0.24375,kotlin
13rhbhd,jlkak57,"Also, I don't think having null in a language like C that has basically no seatbelts around raw pointers anyway and where only pointers can be null is much of an issue.",-0.010256410256410256,c
13rhbhd,jlkak57,"In C, returning NULL is not much worse than returning -1.",0.2,c
13rhbhd,jlkak57,It's just that most languages besides C don't use garbage values except null to indicate errors.,0.5,c
13rhbhd,jlkak57,">The level Rust goes to in order to prevent NULL pointers is ridiculously over the top for the majority of cases that NULL pointers are encountered  This is a strange argument IMO, because Rust *doesn't* do much to prevent null pointers.",0.07916666666666668,rust
13rhbhd,jlkak57,"Rust doesn't *prevent* null, it just doesn't introduce null because there is no reason to do so if you have a generic, ergonomic `Option` type.",0.0,rust
13rhbhd,jlkak57,Raw pointers in Rust [can absolutely be null](https://doc.rust-lang.org/std/ptr/fn.null.html).,-0.015384615384615385,rust
13rhbhd,jlkak57,">outside of that it seems the level of hatred is extreme, and many things are blamed on NULL pointers that actually are flaws with language semantics rather than the NULL pointers themselves  In C, I agree (see above), but in high level languages, or languages with even slightly more expressive type systems, null values are absolutely an inherent flaw since they add an invalid garbage value to every single type",0.2181746031746032,c
13rhbhd,jlkf3r8,"> No one complains when a python function returns """" if there's an error.",0.0,python
13rhbhd,jlkf3r8,> No one complains if a C function returns -1.,0.0,c
13rhbhd,jlkf3r8,"Pointer is a type constructor - int pointer, string pointer, so forth, are different types - and so you lose type safety by having a single value that is valid for every pointer type.",-0.03571428571428571,forth
13rhbhd,jlkyqjw,"I'm not a low level programmer, and it's probably different when you don't have Rust semantics and still want to do very controlled low level code, but the whole point of having a type system is that you *can* guarantee stuff about your code.",0.08,rust
13rhbhd,jlkyqjw,"It's hard to make it readable with C syntax and no ability to compose functions (like a pipe operator), and we should create languages that do their best to be readable without a debugger.",0.35416666666666663,c
13rhbhd,jlkyqjw,"Rust does a pretty good job at this, ML languages do a great job at this, but C does a terrible job.",0.1875,rust
13rhbhd,jlkyqjw,"Rust does a pretty good job at this, ML languages do a great job at this, but C does a terrible job.",0.1875,c
13rhbhd,jlkyqjw,C++ is the worst case scenario.,-1.0,c++
13rhbhd,jlkguud,Java).,0.0,java
13rhbhd,jlk8j80,"I’d venture to say this is one of the reasons why people that think static types are useless do so, because if every type can possibly be null, what’s the point of type checking?",0.0,d
13rhbhd,jlk8j80,Rather than languages like ML and Rust which often times tell you what to do to fix things with types.,0.0,rust
13rhbhd,jlkuvl0,"Because everyone's favourite language now is either Rust, or something of its ilk.",0.0,rust
13rhbhd,jlkuvl0,"Such types can be implemented at any level of language, including assembly.",0.0,assembly
13rhbhd,jlw3r0s,"So, Java is a great leap forward in the specific sense that null-pointer has a defined behavior which is unlikely to lead to escalated privileges.",0.10000000000000002,java
13rhbhd,jlxz6yz,You have to go thru your code and check every pointer.,0.0,go
13rhbhd,jlm6o3t,Example:  Typescript:  ``` const a = foo?.a ?,0.0,typescript
13rhbhd,jlm6o3t,"'no'; ```  Rust option without using `?`:  ``` let a = foo.map(|f| f.a).unwrap_or(""no""); ```",0.0,rust
13rhbhd,jlk7a76,Not every language can or should be Rust that checks your inputs every step of the way.,0.0,rust
13rhbhd,jllt9ja,> Kotlin has nulls and its type system makes it perfectly safe  Doesn't that mean its not `null` by definition?,0.09375,kotlin
13rhbhd,jlkbu2x,"People write off C as a language simply because it cannot express optional types, when I’m saying that reaction is over the top for most cases.",0.3333333333333333,c
13rhbhd,jlkbu2x,"C is probably the worst example to illustrate my point, since the consequences are the most severe in C.   However, despite the responses I’m receiving, most languages do not have good methods of expressing errors.",0.175,c
13rhbhd,jlkbu2x,"Actually, only Rust is capable of not doing either of those things as far as I’m aware.",0.1375,rust
13rhbhd,jlkbu2x,"However, there’s a reason 99% of all code ever written was not in Rust.",0.0,rust
13rhbhd,jllsevc,> > No one complains if a C function returns -1.,0.0,c
13rhbhd,jllsevc,"C# is a much higher-level language than C. What do you think of [`System.String.IndexOf` returning `-1` for ""not found""](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-7.0) instead of `null` or a nullable or option type?",0.2,c
13rhbhd,jlkqddd,"Rust, Haskell and OCaml, a type like `Int` *only* contains valid integers.",0.0,rust
13rhbhd,jlkqddd,"Rust, Haskell and OCaml, a type like `Int` *only* contains valid integers.",0.0,haskell
13rhbhd,jlkl07t,"For example, a string in Java can be the empty string (`""""`), but it can also be `null`.",-0.1,java
13rhbhd,jlkl07t,"For example, in Java, I can have a value of type `User` that may or may not be null.",0.0,java
13rhbhd,jlkl07t,"In Rust, there's no built-in null, but there is the library type `Option` which can represent a value that may or may not be present.",0.0,rust
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,kotlin
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,rust
13rhbhd,jlli9vi,"Like I said before, if your language can make a distinction between `NotNull<T>` and `MaybeNull<T>` (which Kotlin and a few languages spell as `T` and `T?`, while languages like Rust calls it `T` and `Option<T>` and Haskell calls it `T` and `Maybe t` modulo syntax) you can avoid this class of problems.",-0.2,haskell
13rhbhd,jlmjao4,"They've been around in familiar forms for ~50 years or so dating back to Pascal and ML (possibly earlier, I don't know).",0.125,pascal
13rhbhd,jllupln,"How do you write a program that can express expressions that can be numbers, variables, sums or products in your language:      42     n     f+g     f*g  How would you implement differentiation:      d(42)/dx = 0     dx/dx = 1     d/dx(f+g) = df/dx + dg/dx     d/dx(f*g) = f*dg/dx + g*df/dx  Here's how you write it in my language:      type rec Expr =       | Constant Number       | Variable String       | Add(Expr, Expr)       | Mul(Expr, Expr)      let rec d f x =       f @       [ Constant _ -> Constant 0       | Variable y -> Constant(if x=y then 1 else 0)       | Add(f, g) -> Add(d f x, d g x)       | Mul(f, g) -> Add(Mul(f, d g x), Mul(g, d f x)) ]",0.0,d
13rhbhd,jlmecjs,"Languages such as Ada have improved upon this with the use of ranges; a day of the week can be precisely represented as `1..7`, rather than as a `u8`.",0.2,ada
13rhbhd,jlk8eh8,"Python has exceptions as the default mechanism for error handling, and choosing to return an empty string instead of throwing an exception is a bad design decision in most cases.",-0.09999999999999994,python
13rhbhd,jlk8eh8,"So yes, if a python function signals errors via dedicated return values without a good reason, it will generally be frowned upon",0.375,python
13rhbhd,jlkmq2d,"Null is just a value in Python like any other one, and you can definitely accidentally get a `None` where you were expecting a `str`, but you can also get an `int` or a `User`, or a whatever else in the same place.",-0.041666666666666664,python
13rhbhd,jlkmq2d,"Python, by default, has no typing system, so nulls aren't worse than any other value!",-0.278125,python
13rhbhd,jlkbyjp,Not in languages such as Haskell and Rust.,0.0,haskell
13rhbhd,jlkbyjp,Not in languages such as Haskell and Rust.,0.0,rust
13rhbhd,jlkbyjp,"Even in C# and others, it is very much possible to create types that cannot be constructed in a safe manner to have invalid values.",0.25,c
13rhbhd,jlkbyjp,"Haskell lets you define list type that does not have an empty constructor, in (safe) Rust a string containing other than valid UTF-8 is impossible (and in unsafe Rust it is UB), and so on.",-0.09791666666666665,haskell
13rhbhd,jlkbyjp,"Haskell lets you define list type that does not have an empty constructor, in (safe) Rust a string containing other than valid UTF-8 is impossible (and in unsafe Rust it is UB), and so on.",-0.09791666666666665,rust
13rhbhd,jllzf83,"Kotlin has `null`, it's just that the language will not let you dereference a `null` value.",0.0,kotlin
13rhbhd,jlkoqxn,">People write off C as a language simply because it cannot express optional types, when I’m saying that reaction is over the top for most cases  While it is probably not the worst thing C does, I don't think this perception is over the top.",0.1,c
13rhbhd,jlkoqxn,"Sure, C could use something other than optional, but the way C uses garbage values for failure is pretty awful.",-0.13833333333333334,c
13rhbhd,jlkoqxn,"What C calls ""error handling"" really falls into two categories: Errors and nonexistence.",0.2,c
13rhbhd,jlkoqxn,"There is an argument to be made for *checked* exceptions that need to be handled at some point (Rust uses `Result`), but most languages have an answer to this.",0.5,rust
13rhbhd,jlkoqxn,"Many languages still throw an exception since they expect the programmer to check if the map contains the value first, but the correct behavior is arguably to return an `Option` or something similar (like an explcitly nullable type in Kotlin).",0.25,kotlin
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,java
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,scala
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,rust
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,haskell
13rhbhd,jlkoqxn,"Java, Scala, Rust, Haskell, Elm, PureScript, Dhall, Idris and OCaml have `Optional`.",0.0,elm
13rhbhd,jlkoqxn,Kotlin and C# have explicit opt-in nullable types.,0.0,kotlin
13rhbhd,jlkoqxn,Kotlin and C# have explicit opt-in nullable types.,0.0,c
13rhbhd,jlkoqxn,Previous versions of C# used to use `out` parameters.,-0.16666666666666666,c
13rhbhd,jlkoqxn,"Go arguably does the wrong thing with it's `if err != null` checks, but I don't think anyone in this sub considers go's behavior well designed.",-0.625,go
13rhbhd,jlkoqxn,">However, there’s a reason 99% of all code ever written was not in Rust.",0.0,rust
13rhbhd,jlkoqxn,"Because 99% of the time, that level of safety is not mission critical  Rust is not much safer than most statically typed high-level languages.",0.13333333333333333,rust
13rhbhd,jlkoqxn,"If performance and predictability are not mission critical, you don't need to use Rust, althought that doesn't mean that using Rust is a bad choice in that case.",-0.3374999999999999,rust
13rhbhd,jlmck17,"There's several things about C headers that make them bad:  - C has only one namespace, so anything included from a header is dumped into that namespace; people still create namespaces, but they have only nominal support.",-0.17499999999999996,c
13rhbhd,jlmck17,"- The C preprocessor operates in a strictly linear manner, making separate and parallel compilation difficult and introducing unexpected dependencies between files.",-0.13333333333333333,c
13rhbhd,jlmck17,This is why so much focus is put on making C and C++ parsers fast.,0.2,c
13rhbhd,jlmck17,This is why so much focus is put on making C and C++ parsers fast.,0.2,c++
13rhbhd,jlmcmi2,"It can't do differentiation (if you're talking about calculus) on an arbitrary expression, because it's not Mathematica or Matlab.",-0.1,matlab
13rhbhd,jlk95ku,"I mean like in Python, where error checking is not a default or enforced practice.",-0.3125,python
13rhbhd,jlp9j5v,> There's several things about C headers that make them bad:  Right.,-0.13809523809523805,c
13rhbhd,jlp9j5v,"> C has only one namespace, so anything included from a header is dumped into that namespace; people still create namespaces, but they have only nominal support.",0.0,c
13rhbhd,jlp9j5v,"> The C preprocessor operates in a strictly linear manner, making separate and parallel compilation difficult and introducing unexpected dependencies between files.",-0.13333333333333333,c
13rhbhd,jlp9j5v,This is why so much focus is put on making C and C++ parsers fast.,0.2,c
13rhbhd,jlp9j5v,This is why so much focus is put on making C and C++ parsers fast.,0.2,c++
13rhbhd,jln22eh,">  > It can't do differentiation (if you're talking about calculus) on an arbitrary expression, because it's not Mathematica or Matlab.",-0.1,matlab
13rhbhd,jlmiznx,"Yes, even C has them now (as `_BitInt(N)`).",0.0,c
13rhbhd,jlkafoo,"I'd encourage you to read [PHP: A Fractal of Bad Design](https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/), not necessarily because you need to know about why PHP is bad but because, to make it clear how PHP violates them, it argues very forcefully for some pretty basic principles of _good design_.",-0.01874999999999996,php
13rhbhd,jlkafoo,Here's an excerpt that's relevant:  > Parts of PHP are practically designed to produce buggy code.,0.45,php
13rhbhd,jlkafoo,"> In C, functions like strpos return -1 if the item isn’t found.",0.0,c
13rhbhd,jlkafoo,"> > In, say, Python, the equivalent .index methods will raise an exception if the item isn’t found.",0.0,python
13rhbhd,jlkafoo,"> > In PHP, these functions return false.",-0.4000000000000001,php
13rhbhd,jlkafoo,"If you use FALSE as an index, or do much of anything with it except compare with ===, PHP will silently convert it to 0 for you.",-0.0666666666666667,php
13rhbhd,jlkafoo,"Here, PHP has actively created a subtle trap for me to fall into, and I have to be vigilant even with such mundane things as string operations and equality comparison.",-0.15833333333333333,php
13rhbhd,jlkafoo,PHP is a minefield.,0.0,php
13rhbhd,jlkbdgd,"_BUT_, because Java has nullability on _every_ non-primitive type, you totally _can_ write:      ValidatedString foo = null;  And now there's no way for any downstream functions to enforce at compile time that the input to a function _cannot_ be`null`.",0.0,java
13rhbhd,jlkbdgd,Put another way: I'm going to give you some Java method signatures.,0.0,java
13rhbhd,jlkbdgd,"For some further reading, I recommend looking into why `Optional<T>` is one of the big candidates for Java's Project Valhalla, which will allow you to define custom non-nullable value types.",0.0,java
13rhbhd,jlpc7vd,"I'm not a C programmer, so for me and any other first time user they seem to only offer confusion and nothing else.",0.041666666666666664,c
13rhbhd,jlpc7vd,But since I've only dabbled in C I'll ask this with an open mind- what trade offs are there?,0.0,c
13rhbhd,jlpx7bw,I'm thinking beyond C but I'd say some advantages are:  * Clear machine-verified API.,0.10000000000000002,c
13rhbhd,jlpx7bw,* Docs could go on implementations only.,0.0,go
13rhbhd,jll9srd,"Some languages like TypeScript or modern C# still have null, but only for types that have explicitly been marked as nullable.",0.10000000000000002,typescript
13rhbhd,jll9srd,"Some languages like TypeScript or modern C# still have null, but only for types that have explicitly been marked as nullable.",0.10000000000000002,c
13rhbhd,jlq0oml,"Just my two cents here, but in my experience using languages where order matters (basically just Python), it only ever feels like it gets in my way when I'm trying to make a clean API, but as I said earlier I'm not really sure what header files have to do with that.",0.029166666666666674,python
13rhbhd,jlkmmf6,Do you think there’s some kind of Typescript or LSP for that?,0.6,typescript
13rhbhd,jlqa1vc,"> Just my two cents here, but in my experience using languages where order matters (basically just Python), it only ever feels like it gets in my way when I'm trying to make a clean API, but as I said earlier I'm not really sure what header files have to do with that.",0.029166666666666674,python
13rhbhd,jlkiop1,"You're the one who brought up programmers who have to work with legacy languages; but this subreddit isn't about that, and we can say ""C sucks"" without concern.",-0.3,c
13qqp2t,,I made a translator that converts C to my esolang (with entirely different logic structure).,0.0,c
13qqp2t,,"How is that different from say, a translator that converts C in english to C in german.",0.0,c
13qqp2t,jlgd5ff,"In software-land, examples are [Flow](https://flow.org/) which is a language whose creators refuse to call it that, and all the C dialects (GNU C, Objective-C, nesC, NQC, NXC, ...) which will depend on who you ask.",0.0,c
13qqp2t,jlgd5ff,"In software-land, examples are [Flow](https://flow.org/) which is a language whose creators refuse to call it that, and all the C dialects (GNU C, Objective-C, nesC, NQC, NXC, ...) which will depend on who you ask.",0.0,objective-c
13qqp2t,jlgd5ff,"Then we call languages in the Lisp family ""Lisp dialects,"" for no particular technical reason.",-0.041666666666666664,lisp
13qqp2t,jlgd5ff,"That's also how you can run Java Bytecode on .Net and vice-versa ([XMLVM](http://www.xmlvm.org/overview/), [IKVM.NET](https://en.m.wikipedia.org/wiki/IKVM.NET)).",0.0,java
13qqp2t,jlgrbop,The underlying language is equivalent to C.,0.0,c
13qqp2t,jlgf6pr,translating call/cc from Scheme to Clojure.),0.0,scheme
13qqp2t,jlgf6pr,translating call/cc from Scheme to Clojure.),0.0,clojure
13qqp2t,jlni4cb,A river and a rock to bash the clothes against will work.,0.0,bash
13qqp2t,jlg9utv,"If you can compile a language to assembly in a deterministic way, that means that the process can be reversed and go from assembly to any language.",0.0,assembly
13qqp2t,jlg9utv,"If you can compile a language to assembly in a deterministic way, that means that the process can be reversed and go from assembly to any language.",0.0,go
13qqp2t,jlg9utv,So a hypothetical translator (extremely inefficient) from A to B can simply compile A and then reverse compile from assembly to B.,-0.0625,assembly
13qqp2t,jlg9utv,"There is no actual answer, you could, for example, grab C and just add a feature from OOP and call it ""C with classes"" (true story).",0.175,c
13qqp2t,jlgfn68,"In my opinion there's only really fortran, lisp, apl, sql, and smalltalk.",0.1,fortran
13qqp2t,jlgfn68,"In my opinion there's only really fortran, lisp, apl, sql, and smalltalk.",0.1,lisp
13qqp2t,jlgfn68,"In my opinion there's only really fortran, lisp, apl, sql, and smalltalk.",0.1,apl
13qqp2t,jlgu2sz,"But you might wonder if you can’t just compile everything to some assembly and then back, but then you need to make sure that the information in the base language doesn’t get lost when converting to assembly.",-0.10000000000000002,assembly
13qqp2t,jlgu2sz,"3) c in German and c in English are isomorphic, because it’s just a syntactic change.",0.0,c
13qqp2t,jlgu2sz,"C to your esolang might be, depending on what your lang can do.",0.0,c
13qqp2t,jlha801,"I guess you can just choose a computational problem whose solutions can be any natural number and go from that, but it feels a bit like cheating.",0.1,go
13qqp2t,jlhd81r,The common language that all languages are translated to is assembly.,-0.3,assembly
13qqp2t,jlhd81r,"Assembly is the ""narrow waist"" of how we instruct computers to do things.",-0.2,assembly
13qqp2t,jlhd81r,Assembly isn't perfect since obviously there are a handful of different instruction sets for various manufacturers,0.25,assembly
13qqp2t,jljftyg,"If you write a program in C, it's going to look very different than a program in Haskell as a result of its features, is there immutability by default?",0.0,c
13qqp2t,jljftyg,"If you write a program in C, it's going to look very different than a program in Haskell as a result of its features, is there immutability by default?",0.0,haskell
13qqp2t,jljftyg,"Sure, you could translate a program from C to Haskell or vice versa, but it's gonna look horrible if you exactly do in one language what you do with the other.",-0.09375,c
13qqp2t,jljftyg,"Sure, you could translate a program from C to Haskell or vice versa, but it's gonna look horrible if you exactly do in one language what you do with the other.",-0.09375,haskell
13qqp2t,jljftyg,"There's also the fact that Haskell needs a runtime to actually execute the code, so the C translation will effectively have to reimplement the Haskell runtime to be equivalent.",0.3,haskell
13qqp2t,jljftyg,"There's also the fact that Haskell needs a runtime to actually execute the code, so the C translation will effectively have to reimplement the Haskell runtime to be equivalent.",0.3,c
13qqp2t,jljftyg,"You could take the resulting program and algebraically manipulate it into something more tasteful, but it's highly subjective (and difficult) in how you go about that.",0.053333333333333344,go
13qqp2t,jlk5a7b,"If your lang is just C with different keywords, it has the same semantics as C and is considered C-like (or ALGOL-like more broadly), but that doesn't preclude it from being an esolang.",0.140625,c
13qqp2t,jljgfy2,"It's a derivative of Haskell, but it's a new language.",0.13636363636363635,haskell
13qqp2t,jlgm29p,Is the ML family lisp since it’s a typed variant of the lambda calculus?,0.0,lisp
13qqp2t,jlgm29p,And where does Prolog fit?,0.4,prolog
13qqp2t,jlgm29p,Algol?,0.0,algol
13qqp2t,jlgm29p,Forth?,0.0,forth
13qqp2t,jlh64sg,All of those can be collapsed under Lisp ;),0.25,lisp
13qqp2t,jljhm4t,"Python 2 Python, despite it being a different formal language than Python 3.",0.0,python
13qqp2t,jlj58qk,"(2) The abstract semantics of Haskell don't specify a way to do I/O, nor is it precluded.",0.0,haskell
13qqp2t,jlj58qk,"One could easily imagine a runtime for Haskell which printed every string in the program as soon as it was created in much the same way that one can graft I/O machinery onto the _implementation_ of any abstract machine, including a Turing machine.",0.2111111111111111,haskell
13qqp2t,jljrt1v,"If language A supports self-modification and language B doesn't, then there will be no straightforward translation of A -> B, even when passing through another language C (eg.",-0.1875,c
13qqp2t,jlgmv5q,"Yeah, I would say that everything (read popular languages) is primarily just Algol.",0.5,algol
13qqp2t,jlib57j,It sounds like you're describing [reader macros](https://lisper.in/reader-macros) :D,1.0,d
13qm38j,,again 2 lifetimes involved  Rust has some examples that can be used: [https://doc.rust-lang.org/rust-by-example/scope/lifetime.html](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).,-0.75,rust
13q76pm,jle6tsk,"(I would also be peeved if it had turned out to be Forth, combinatory logic, a universal Turing machine, or the lambda calculus.)",0.0,forth
13q76pm,jlf6sq3,"By using an S-expression-based syntax, you get to just _skip_ practically all the parsing and go straight into semantics.",0.2,go
13q76pm,jlno7vz,"Crenshaw was 100% hand-rolled recursive-descent, but he was aiming at a much-simplified Pascal.",0.0,pascal
13q76pm,jlsmsgr,"Like most people on this subreddit, I *couldn't* create my own programming language by following OP's instructions because my own programming language isn't a dialect of Lisp.",0.42500000000000004,lisp
13q76pm,jlsmsgr,"> By using an S-expression-based syntax, you get to just skip practically all the parsing and go straight into semantics.",0.2,go
13q76pm,jlsmsgr,Java).,0.0,java
13q76pm,jlhiomk,"As it is, this looks like just another Lisp.",0.0,lisp
13q76pm,jlhiomk,>you get to just skip practically all the parsing and go straight into semantics.,0.2,go
13q76pm,jlhuclg,"> As it is, this looks like just another Lisp.",0.0,lisp
13q76pm,jlhuclg,"And C++ looks like just another C — at least, at the outset.",-0.3,c++
13q76pm,jlhuclg,"And C++ looks like just another C — at least, at the outset.",-0.3,c
13q76pm,jlhuclg,"Nobody who knows what they're talking about looks at Rust code and says ""Ah yes, the critical essence of Rust is that its syntax is mostly C-like but with more noise.""",0.3333333333333333,rust
13pzzah,jlcuu2n,"So are D and C# if you count [`in`](https://dlang.org/spec/function.html#in-params) as the default, instead of the actual default.",0.0,d
13pzzah,jlcuu2n,"So are D and C# if you count [`in`](https://dlang.org/spec/function.html#in-params) as the default, instead of the actual default.",0.0,c
13pzzah,jlcuu2n,"Rust is another [precedent](https://play.rust-lang.org/?version=stable&mode=release&edition=2021&gist=46f628468f8d2db9728f221417ed570f), but from another angle: when you move a value into a function, nobody can observe mutations, so a compiler is free to pass-by-reference all moved objects.",0.4,rust
13pzzah,jldwq65,"Not to simp on Ferris too hard, but rust can be seen as somewhat similar since borrowing is ""passing by const reference,"" and the default parameter passing is ""that value you refer to is mine now, you can't have it.""",-0.14583333333333334,rust
13psmjy,jlcqjg5,Common for functional or C like impl languages.,-0.3,c
13psmjy,jlcqjg5,"And you can't hide the token allocations into the parser nodes - it might then be better to batch lex rather than a streaming lexer that an LL benefits from * C style lists to build the tree enables keeping the list in the parser node allocation too  Kind regards,  M ✌",0.55,c
13psmjy,jlcihts,I can only give a C++ answer.,0.0,c++
13psmjy,jlcihts,Do you want a C++ answer?,0.0,c++
13psmjy,jlcihts,For example on my machine Go does around 85K and that is thought to be 'fast',0.2,go
13psmjy,jlbmih8,It may even be impossible to make efficient depending on comparability constraints (see the design of Python and the poor syntax decisions with C++).,-0.5333333333333333,python
13psmjy,jlbmih8,It may even be impossible to make efficient depending on comparability constraints (see the design of Python and the poor syntax decisions with C++).,-0.5333333333333333,c++
13psmjy,jlfj4mh,"If you can avoid AST, go ahead and avoid it.",0.0,go
13pi1ox,,"So I've been steadily working on my language Vortex, and even though most of the work has gone into updating the internal interpreter code to make it run a little smoother, there are some interesting developments that I'd like to share:  **More Libraries:**  Vortex offers C interoperability out of the box and I've been building the language out using dynamic libraries.",0.19739583333333333,c
13pi1ox,,"Errors in themselves, both as structures and in terms of how clear they are, have a long way to go.",0.02500000000000001,go
13pi1ox,,"**Finally:**  Vortex still has a long way to go, but my main focus has been on just having fun with it.",0.10416666666666666,go
13pi1ox,,And I've been having loads of fun creating libraries to extend the language and optimising the interpreter as I go.,0.3,go
13pd2ho,,"* passable language intrinsic functions and/or standard library - string operations, sorting, hash map, basic statistics (sum, product, avg, var, std) * able to generate standalone binaries (not requiring interpreter at runtime)  Basically Fortran if it was invented in 2014 instead of 1954.",0.16666666666666666,fortran
13pd2ho,jl91azx,"Well Rust is the most popular modern language with a huge ecosystem that is like that, but it also requires you to learn a more modern approach than ""newer Fortran"".",0.4000000000000001,rust
13pd2ho,jl91azx,"Well Rust is the most popular modern language with a huge ecosystem that is like that, but it also requires you to learn a more modern approach than ""newer Fortran"".",0.4000000000000001,fortran
13pd2ho,jl9151d,Ada can do all of those things.,0.0,ada
13pd2ho,jl9151d,"The GNAT compiler is a gcc frontend, so is just as fast as C if you turn off bounds checking and avoid certain constructs.",0.20714285714285713,c
13pd2ho,jl9c6dc,"C++ itself checks all of these boxes, so is there something else you're looking for?",0.0,c++
13pd2ho,jlaq6gu,"Check out [D](https://dlang.org/), in particular since you mention metaprogramming.",0.16666666666666666,d
13pd2ho,jlaq6gu,"Here's operator overloading in D:      struct C     {         int x;         C opBinary(string op)(in C obj) const         {             mixin(""return C(x "", op, "" obj.x);"");         }                  unittest         {             const a = C(21);             const b = C(2);             const c = a * b;             assert(c.x == 42);         }     }  Here's more funky code:      static foreach(T; AliasSeq!",0.5625,d
13pd2ho,jlaq6gu,"Here's operator overloading in D:      struct C     {         int x;         C opBinary(string op)(in C obj) const         {             mixin(""return C(x "", op, "" obj.x);"");         }                  unittest         {             const a = C(21);             const b = C(2);             const c = a * b;             assert(c.x == 42);         }     }  Here's more funky code:      static foreach(T; AliasSeq!",0.5625,c
13pd2ho,jlaq6gu,"It also has both LLVM and GCC frontends, checking the ""as fast as C"" part.",0.2,c
13pd2ho,jlaq6gu,"In fact there's an entire subset of the language called D As Better C, where runtime features (GC, RTTI, exceptions) are disabled and you keep everything else.",0.09999999999999999,d
13pd2ho,jlaq6gu,"In fact there's an entire subset of the language called D As Better C, where runtime features (GC, RTTI, exceptions) are disabled and you keep everything else.",0.09999999999999999,c
13pd2ho,jlcu8hf,Crystal?,0.0,crystal
13pd2ho,jl9szyr,>I am curious what it would take to implement a front end for LLVM  For your requirements probably you don't need to go that far.,0.0,go
13pd2ho,jl9szyr,Do a front-end for C++ code instead.,0.0,c++
13pd2ho,jl9szyr,"That is, transpile your ideal language into C++ source code.",0.9,c++
13pd2ho,jl9szyr,"Or maybe, since you don't seem bothered about syntax, just use C++ directly.",0.1,c++
13pd2ho,jl9szyr,"A solution in C++ would be clunky, but that language is clunky anyway.",0.0,c++
13pd2ho,jlblp7v,Fortran?,0.0,fortran
13pd2ho,jlafkx9,Since no one has mentioned it yet...Julia.,0.0,julia
13pd2ho,jl9tvpy,C is bad for generics.,-0.6999999999999998,c
13pd2ho,jl9tvpy,"I mean, it pulls in the C runtime.",-0.3125,c
13pd2ho,jl9tvpy,> Basically Fortran if it was invented in 2014 instead of 1954.,0.0,fortran
13pd2ho,jlsh3an,"It has an F#, C, and a Python backend.",0.0,c
13pd2ho,jlsh3an,"It has an F#, C, and a Python backend.",0.0,python
13pd2ho,jl91s1c,"Zig is quite intriguing to me, as is Rust.",0.30000000000000004,rust
13pd2ho,jl91s1c,The biggest downside I was seeing to Rust is that OpenMP/MPI support is... Not?,0.0,rust
13pd2ho,jl91s1c,"Is Rust not an imperative, procedural language?",0.0,rust
13pd2ho,jl9249l,That is pretty cool.,0.3,cool
13pd2ho,jl9249l,"I know Ada has massively fallen out of favor, even with its creator, which is somewhat surprising if it has the listed features... Am I the only one that thinks these things would be highly desirable, or do you have any good info on why it is not used so much anymore?",0.29333333333333333,ada
13pd2ho,jl9249l,"EDIT: This thread is ancient, but covers some of the benefits/questions I had about Ada [https://www.reddit.com/r/programming/comments/b39vd/ask\_reddit\_realworld\_c\_vs\_ada\_experiences/](https://www.reddit.com/r/programming/comments/b39vd/ask_reddit_realworld_c_vs_ada_experiences/) Sounds pretty cool tbh.",0.3,ada
13pd2ho,jl9249l,"EDIT: This thread is ancient, but covers some of the benefits/questions I had about Ada [https://www.reddit.com/r/programming/comments/b39vd/ask\_reddit\_realworld\_c\_vs\_ada\_experiences/](https://www.reddit.com/r/programming/comments/b39vd/ask_reddit_realworld_c_vs_ada_experiences/) Sounds pretty cool tbh.",0.3,cool
13pd2ho,jl9157c,"I can't lie, the statements grouped by indentation is 100% the worst aspect of python and probably this language too, but it looks cool.",-0.325,python
13pd2ho,jl9157c,"I can't lie, the statements grouped by indentation is 100% the worst aspect of python and probably this language too, but it looks cool.",-0.325,cool
13pd2ho,jl98k91,"Well Flang, or new-flang, or whatever they want to call it - the new, not production ready, Fortran compiler for LLVM requires special compiler flags to even generate an executable.",0.23116883116883116,fortran
13pd2ho,jl98k91,The issue is really that the standard committee governing Fortran seems to have no interest in adding features to the language that would actually improve it.,0.06666666666666667,fortran
13pd2ho,jl98k91,They won’t fix that or add an actual ‘do parallel.’ Basically the governing body running Fortran is happy to do nothing but maintain legacy codes that are replaced by C++ more and more every year.,0.36,fortran
13pd2ho,jl98k91,They won’t fix that or add an actual ‘do parallel.’ Basically the governing body running Fortran is happy to do nothing but maintain legacy codes that are replaced by C++ more and more every year.,0.36,c++
13pd2ho,jld27w5,It looks pretty cool.,0.3,cool
13pd2ho,jlsk1y1,"To follow up here, I took a look at Crystal and implemented my test code incremental prime sieve.",0.0,crystal
13pd2ho,jlsk1y1,"For nearly the same algorithm (couldn’t figure out how to jump out of nested loops) I can generate 100-1000ish primes as quickly as Fortran (gfortran, ifort, ifx, and AOCC flang), but some inefficiency catches up for 1M-10Mish type values, and Crystal goes from 50% to 100% longer runtime.",0.14444444444444446,fortran
13pd2ho,jlsk1y1,"For nearly the same algorithm (couldn’t figure out how to jump out of nested loops) I can generate 100-1000ish primes as quickly as Fortran (gfortran, ifort, ifx, and AOCC flang), but some inefficiency catches up for 1M-10Mish type values, and Crystal goes from 50% to 100% longer runtime.",0.14444444444444446,crystal
13pd2ho,jlsk1y1,"Overall it seems like a pretty cool language, I just think a lot of languages try to claim “we’re as fast as C” by writing some test case in the best way possible for their new language, which so happens to correspond to a rather slow way to do things in the victim language.",0.1734848484848485,cool
13pd2ho,jlsk1y1,"Overall it seems like a pretty cool language, I just think a lot of languages try to claim “we’re as fast as C” by writing some test case in the best way possible for their new language, which so happens to correspond to a rather slow way to do things in the victim language.",0.1734848484848485,c
13pd2ho,jlsk1y1,"This happens a lot when people want to rag on Python for example, so they do some compiled language and loop a bunch, copy paste that to python and say they’re 10000% faster.",0.0,python
13pd2ho,jlbm6y6,> Do a front-end for C++ code instead  Fortran has better array handling than C++ so maybe write a front-end for Fortran?,0.5,c++
13pd2ho,jlbm6y6,> Do a front-end for C++ code instead  Fortran has better array handling than C++ so maybe write a front-end for Fortran?,0.5,fortran
13pd2ho,jl9tbkk,"A solution in C++ would be clunky, but that language is clunky anyway.",0.0,c++
13pd2ho,jl9tbkk,"C++ is a pig and just another 40 year old, bloated kitchen sink language.",0.1,c++
13pd2ho,jlaumgs,"It would be somewhat insulting to describe Julia as ""Fortran invented in 2014"", but FWIW I think their user base is trying to solve the same kinds of problems ie writing heavy numerical code.",-0.5,julia
13pd2ho,jlaumgs,"It would be somewhat insulting to describe Julia as ""Fortran invented in 2014"", but FWIW I think their user base is trying to solve the same kinds of problems ie writing heavy numerical code.",-0.5,fortran
13pd2ho,jlad3db,"Rust has all the features you mentioned (i.e ADTs, pattern matching, closures....) and still uses LLVM.",0.0,rust
13pd2ho,jlad3db,I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,c
13pd2ho,jl93r24,"As for it being more modern, calling Rust imperative and procedural is right but falls a bit short.",0.2464285714285714,rust
13pd2ho,jl93r24,"And there are plenty of functional idioms that are usually favored when writing idiomatic Rust over C-style flow control structures + state mutation, although it's far from being what's popularly known as a ""proper"" functional language.",0.375,rust
13pd2ho,jl93r24,"I'd describe it as something between ""what C++ would be if designed from scratch with decades of pain as learning material"" and ""systems OCaml"".",0.0,c++
13pd2ho,jl93lno,"Early Ada compilers were expensive and often buggy, which tainted people's perception of the language.",-0.2,ada
13pd2ho,jl93lno,"Combined with a few high profile project failures and the dominance of UNIX and C, Ada lost traction.",-0.020000000000000004,c
13pd2ho,jl93lno,"Combined with a few high profile project failures and the dominance of UNIX and C, Ada lost traction.",-0.020000000000000004,ada
13pd2ho,jl93lno,Modern Ada is a different story.,0.1,ada
13pd2ho,jl93lno,"Ada's certainly got some historical baggage, but it's worth a try if you're looking for a language with an emphasis on safety and maintainability.",0.1714285714285714,ada
13pd2ho,jl9byfe,It is easy to learn for anyone who knows an ALGOL family language.,0.43333333333333335,algol
13pd2ho,jl9byfe,"The rules about pointer scoping/usage are very restrictive in order to avoid dangling pointers and take some getting used to, but you don't need to use pointers nearly as often as in C since you have in/out parameters and the ability to return variable-sized arrays/objects by value from functions.",0.15000000000000002,c
13pd2ho,jl94dt4,"Ada was designed by committee *and it showed, good and hard*.",0.20416666666666664,ada
13pd2ho,jl94dt4,"Oh, and the particular vision of object-orientation espoused by then-current Ada was totally unlike the hot, sexy C++ that was making waves in industry at the time.",0.22916666666666666,ada
13pd2ho,jl94dt4,"Oh, and the particular vision of object-orientation espoused by then-current Ada was totally unlike the hot, sexy C++ that was making waves in industry at the time.",0.22916666666666666,c++
13pd2ho,jlt22f1,"But yea they shouldn't say things like ""fast as C"" that's dumb.",-0.0875,c
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,c
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,c++
13pd2ho,jl9zar1,"But Nim itself transpiles to ""*C, C++ or JavaScript*"".",0.0,javascript
13pd2ho,jl9zar1,"If its syntax is not an obstacle, you might look at Python, especially its Numpy add-on.",0.0,python
13pd2ho,jl9zar1,"Python itself is dead slow, but Numpy AIUI does its array processing using fast native code libraries.",-0.09999999999999999,python
13pd2ho,jlb11ac,I think the creators of Julia would not hate that comparison.,0.4,julia
13pd2ho,jlb11ac,And indeed some old Fortran codebases for numerical modelling are being rewritten in Julia for easier maintenance/development,0.1,fortran
13pd2ho,jlb11ac,And indeed some old Fortran codebases for numerical modelling are being rewritten in Julia for easier maintenance/development,0.1,julia
13pd2ho,jlb17g9,"> Rust has all the features you mentioned (i.e ADTs, pattern matching, closures....) and still uses LLVM.",0.0,rust
13pd2ho,jlb17g9,Although I've written lots of code in both low and high level languages I had never written an asm code gen so I desperately wanted to have a go.,-0.14666666666666664,go
13pd2ho,jlb17g9,I also had cool ideas for novel ways of doing everything.,0.35,cool
13pd2ho,jlb17g9,> I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,c
13pd2ho,jlb17g9,"I also beat C on hailstones (Collatz), Sieve of Eratosthenes, ray tracer and Ackermann.",0.0,c
13pd2ho,jl9484m,"Alright, cool.",0.35,cool
13pd2ho,jl9484m,Really I am searching for something more powerful than what I can do in Fortran but not the absolute hell that is C++.,0.3,fortran
13pd2ho,jl9484m,Really I am searching for something more powerful than what I can do in Fortran but not the absolute hell that is C++.,0.3,c++
13pd2ho,jl9484m,"Thanks for responding, I will have to give Rust a go.",0.2,rust
13pd2ho,jl9484m,"Thanks for responding, I will have to give Rust a go.",0.2,go
13pd2ho,jlbmd64,"The DoD provided a spec, go look at the steel man requirements because that is it.",0.0,go
13pd2ho,jlauwee,"Bear in mind I'm saying this as a long term Python fan, but I probably still wouldn't make a new whitespace sensitive language.",0.06212121212121211,python
13pd2ho,jltw0hp,"this jumps to the next iteration of the outer NUM_CHECKER loop                     end if                 end do prime_checker                 prime_ii = prime_ii + 1                 primes(prime_ii) = num                 unprimes(prime_ii) = num             end do num_checker         else if (n.eq.1) then             primes = 2         end if     end subroutine incremental_sieve ```   In Crystal, I implemented this as: ``` def incremental_sieve(n : Int32)     primes = Array(Int32).new(n)     primes.push(2)     primes.push(3)     unprimes = Array(Int32).new(n)     unprimes.push(2)     unprimes.push(3)     prime_ii = 2     num = 3     while prime_ii < n         num = num + 2         limit = Math.sqrt(num).to_i         is_prime = true         checking_primes = true         i = 1         while checking_primes             if primes[i] > limit                 checking_primes = false             else                 while unprimes[i] < num                     unprimes[i] = unprimes[i] + primes[i]                 end                 if unprimes[i] == num                     is_prime = false                     checking_primes = false                 end                 i = i + 1             end         end         if is_prime             prime_ii = prime_ii + 1             primes.push(num)             unprimes.push(num)         end     end     return primes end ```  I needed the is_prime value since I didn't see a way to jump from the inner loop `while checking_primes` to the next iteration of my main loop `while prime_ii < n`.",-0.03703703703703706,crystal
13pd2ho,jrqgw72,  > > I should also mention that it's really impressive if you were able to beat C in some of the benchmarks using a custom backend!,0.8125,c
13pd2ho,jrqgw72,"I also beat C on hailstones (Collatz), Sieve of Eratosthenes, ray tracer and Ackermann.",0.0,c
13pd2ho,jt8nj02,Recursive calls could use a different ABI but C compilers tend to push all calls through the ABI even when it is really inefficient.,0.1,c
13pd2ho,jlg41pf,Cool.,0.35,cool
13pd2ho,jlbzxmz,"If the committee had valued metaprogramming over strong types, they would have selected a LISP instead -- and the four teams would have seen that coming as the spec evolved, and designed in that direction.",0.4333333333333333,lisp
13pd2ho,jlvtwor,"In Fortran you can name the different loops, and your basic loop control \`exit\` and \`cycle\` (for \`break\` and \`next\`) can be applied to a named loop outside the currently executing one if so desired.",0.0,fortran
13pd2ho,jlvtwor,"In C or Fortran, you can also accomplish this behavior with \`goto\`.",0.0,c
13pd2ho,jlvtwor,"In C or Fortran, you can also accomplish this behavior with \`goto\`.",0.0,fortran
13pd2ho,jlefwyo,Go see how Algol was created to see design by committee.,0.0,go
13pd2ho,jlefwyo,Go see how Algol was created to see design by committee.,0.0,algol
13p3hbq,jl7kql3,"One interesting strategy is available in Prolog, which is a dynamically typed language: In Prolog, you can *ask* the system whether certain cases can arise *at all*, by posting *queries* on the toplevel, to which the Prolog system will respond in the form of *answers*.",0.37142857142857144,prolog
13p3hbq,jl7kql3,"This is a bit similar to what other languages (also functional languages, and also statically typed functional languages such as Haskell) call a ""REPL"", a *read-eval-print-loop*.",-0.041666666666666664,haskell
13p3hbq,jl7kql3,"However, in Prolog, the ability to post queries goes far beyond the ""eval"" of functional languages, because in Prolog, you can *generalize* parts of the query by using logic variables instead of concrete values.",0.125,prolog
13p3hbq,jl7kql3,""", and the Prolog systems answers ""No"", then you can rely on *all* more specific queries to also fail.",0.0,prolog
13p3hbq,jl7kql3,"This reasoning works as long as you program in the pure core of Prolog, where such logical reasoning is admissible.",0.10357142857142856,prolog
13p3hbq,jl7kql3,"For illustration, here is an example: Suppose we have defined a Prolog predicate called `length/2`, which is supposed to relate a list to its length.",0.0,prolog
13p3hbq,jl7kql3,"For example, we know that the list `[a,b,c]`, which we can write equivalently as `""abc""`, is supposed to have length 3.",0.0,c
13p3hbq,jl7kql3,The ability to express such extremely general test cases is a major attraction of logic programming languages like Prolog.,0.037500000000000006,prolog
13p3hbq,jl7j1xv,"For example, both Ruby and JavaScript have very strong community-driven linters that report errors without running the program.",0.5633333333333334,ruby
13p3hbq,jl7j1xv,"For example, both Ruby and JavaScript have very strong community-driven linters that report errors without running the program.",0.5633333333333334,javascript
13p3hbq,jl7uy8v,"Python, are currently spending a lot of effort adding on various type systems.)",0.0,python
13p3hbq,jl8e5xp,This has been my experience with Common Lisp.,-0.3,lisp
13p3hbq,jlqy6rt,Erlang has exhaustive pattern matching and guards on functions.,0.0,erlang
13p3hbq,jl8mfeg,"Additionally, Erlang has a very resilient runtime failure recovery system, which helps when errors _do_ slip through.",-0.05833333333333335,erlang
13p3hbq,jl7xesc,See Python and Erlang's dialyzer for some examples.,0.0,python
13p3hbq,jl7xesc,See Python and Erlang's dialyzer for some examples.,0.0,erlang
13p3hbq,jl9ple7,```  if we were to extend the JS syntax to have Enums like in Rust ``` const (Some x) = Option.Some(20) // weird pseudo syntax ```  The fault with JS is if say XYs is not iterable it'll throw an error but it doesn't throw when XYs doesn't contain 2 elements.,-0.5,rust
13p3hbq,jl860qo,"It's not quite ""dynamic typing"" *dynamic typing*, but you can look into what Python (and others, like TypeScript) does: gradual typing!",0.0,python
13p3hbq,jl860qo,"It's not quite ""dynamic typing"" *dynamic typing*, but you can look into what Python (and others, like TypeScript) does: gradual typing!",0.0,typescript
13p3hbq,jl860qo,The reason why languages like Python and TypeScript offer gradual typing is because they have to maintain backwards-compatibility with software written without types.,0.0,python
13p3hbq,jl860qo,The reason why languages like Python and TypeScript offer gradual typing is because they have to maintain backwards-compatibility with software written without types.,0.0,typescript
13p3hbq,jlejo4i,"At what stage does this happen, are there preceding artefacts, is it exploratory and do you go back and forth and change things?",0.0,go
13p3hbq,jlejo4i,"At what stage does this happen, are there preceding artefacts, is it exploratory and do you go back and forth and change things?",0.0,forth
13p3hbq,jl7udd4,"But from the talks I remember, one idea was to have some support for prolog style queries.",0.0,prolog
13p3hbq,jl96317,"take a look at clojure spec, schema or malli.",0.0,clojure
13p3hbq,jl8iqk6,"Just out of curiosity, I've transliterated your Prolog queries into Idris 1 (a dependently-typed language) REPL inputs to see how it fares and apart from the verbosity, it works just as well (in this specific scenario):      Idris> the (length ['a', 'b', 'c'] = 3) Refl     Refl : 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = 3) (\_, _, _, _ => Refl)     \underscore, underscore, underscore, underscore => Refl : (a : Type) -> a -> a -> a -> 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = _) (\_, _, _, _ => Refl)     ... 11 lines omitted ...         3 = ([__])  For clarification, `Idris> ` is the prompt prefix and if an expression of the form `the (… = …) Refl` comes back without a type error (and it doesn't contain any holes), then the proposition `… = …` is true.",-0.10833333333333334,prolog
13p3hbq,jl8iqk6,"Just out of curiosity, I've transliterated your Prolog queries into Idris 1 (a dependently-typed language) REPL inputs to see how it fares and apart from the verbosity, it works just as well (in this specific scenario):      Idris> the (length ['a', 'b', 'c'] = 3) Refl     Refl : 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = 3) (\_, _, _, _ => Refl)     \underscore, underscore, underscore, underscore => Refl : (a : Type) -> a -> a -> a -> 3 = 3      Idris> the ((a : Type) -> (x, y, z : a) -> length [x, y, z] = _) (\_, _, _, _ => Refl)     ... 11 lines omitted ...         3 = ([__])  For clarification, `Idris> ` is the prompt prefix and if an expression of the form `the (… = …) Refl` comes back without a type error (and it doesn't contain any holes), then the proposition `… = …` is true.",-0.10833333333333334,c
13p3hbq,jl7ub22,"TypeScript, because the abstractions leak and they're not really designed by people who understand type systems.",-0.1,typescript
13p3hbq,jlgfmgm,"You could also check for operations that are known to be invalid, like in this python code:      def add_value(obj, value):         obj.append(value)      add_value(5, 6)  Even though the language is dynamically typed and `add_value` can theoretically take arguments of any type, in this example, you can easily prove that the program won't work because `5` doesn't have a `.append()` method.",0.21666666666666667,python
13p3hbq,jl9gfs2,See template haskell for example.,0.0,haskell
13p3hbq,jl9gfs2,"And while template haskell does have a larger learning curve, as it requires you to understand the AST datatype, I found often these macros worked from the first time, due to the added type safety.",0.041666666666666664,haskell
13p3hbq,jl9gfs2,I found in lisp or scheme that debugging macros can be tricky.,0.0,lisp
13p3hbq,jl9gfs2,I found in lisp or scheme that debugging macros can be tricky.,0.0,scheme
13p3hbq,jma9mgb,Similarly Elixir which runs on the same BEAM VM as Erlang.,0.0,elixir
13p3hbq,jma9mgb,Similarly Elixir which runs on the same BEAM VM as Erlang.,0.0,erlang
13p3hbq,jl9hft9,"I have worked a fair bit in Erlang, and yes, immutability is great, but it mainly makes sure you can read code and won't make certain dumb mistakes.",0.3343253968253969,erlang
13p3hbq,jl9hft9,"Erlang also has a type system now (sort of), so even if the virtual machine is dynamically typed, you can still run static analysis on the code analysing types.",0.5,erlang
13p3hbq,jl9hft9,"Look up Erlang Dialyzer, it's a great tool.",0.8,erlang
13p3hbq,jl8345x,"The folks behind TypeScript understand type systems very well, thank you.",-0.1,typescript
13p3hbq,jl8345x,"They've made deliberate tradeoffs, occasionally questionable but always well-considered, in order to help make as much weird, dynamic Javascript typeable as possible in an ergonomic enough way while maintaining a dead-simple ""compilation strategy"" (it pretty much literally just strips the types).",-0.07857142857142858,javascript
13p3hbq,jl8345x,"Whether those tradeoffs amount to something shitty or not is subjective, but for the most part I honestly really like it...I know Haskell, Ocaml, Coq, Idris, etc.",0.35,haskell
13p3hbq,jl8345x,perfectly well but TypeScript is my go-to for productivity work.,1.0,typescript
13p3hbq,jla4m8i,"I'm certainly not saying that there isn't metaprogramming in Haskell and Rust, but it is decidedly second-class, and it is not used in the same way.",-0.05357142857142857,haskell
13p3hbq,jla4m8i,"I'm certainly not saying that there isn't metaprogramming in Haskell and Rust, but it is decidedly second-class, and it is not used in the same way.",-0.05357142857142857,rust
13p3hbq,jla4m8i,TH and proc macros in Rust are labor saving devices.,0.0,rust
13p3hbq,jla4m8i,"In Ruby and CommonLisp, metaprogramming is a primary modeling tool.",0.4,ruby
13p3hbq,jl8l0pd,"> I know Haskell, Ocaml, Coq, Idris, etc.",0.0,haskell
13p3hbq,jl8l0pd,perfectly well but TypeScript is my go-to for productivity work.,1.0,typescript
13p3hbq,jl8l0pd,"The language I find most productive is actually Scala but that's mostly due to the extensive collections library, which lets you express many algorithms as high-level compositions of collection primitives.",0.175,scala
13p3hbq,jl7l59u,"I was asking in general, but a common dynamic language I like to use is Scheme.",-0.08333333333333333,scheme
13p3hbq,jl958a9,"There's various other ways, too, where Ocaml's rigidity makes it less pleasant than TypeScript with its extreme flexibility.",0.06333333333333332,typescript
13p3hbq,jl958a9,"Also, don't underestimate how powerful TypeScript can be in capable hands (namely Giulio Canti's).",0.25,typescript
13p2x9h,,"Of course, this isn't Haskell's monadic do syntax, but as we all know, applicatives are as good as monads.",0.7,haskell
13p2x9h,jl9161p,"In haskell, one would write      (>.>) = flip (.)",-0.25,haskell
13p2x9h,jl9vkk2,Why does Haskell add do syntax for >>== chains?,0.0,haskell
13p2x9h,jl9vkk2,Haskell would work fine without too.,0.4166666666666667,haskell
13p2x9h,jl9vkk2,"In Haskell, in Ocaml, or other functional languages.",-0.125,haskell
13p2x9h,jl9wk22,def f = (|> ((+) 1) |> ((*) 2))  It would in Haskell.,-0.25,haskell
13o1r8a,jl2ad0r,"I have made something similar, a PicoBlaze assembler and emulator in JavaScript (can be run in a modern browser): https://flatassembler.github.io/PicoBlaze/PicoBlaze.html",0.1,javascript
13o0w1z,,"After some digging  I found ASAP, which I'm faaar to unqualified for to understand and lobster's approach compile time reference counting for which I didn't understand the c++ used in typecheck.h.",0.0,c++
13o0w1z,jl5sq9x,"So it does not answer your question Harder(I guess I never tried to implement) : do what rust does, use affine or linear types General answer: The question you're asking cannot be solved by an algorithm for all programs.",0.05000000000000002,rust
13nyb26,jl1jvbz,I like Rust's approach.,0.0,rust
13nyb26,jl3fezd,"in haskell, printing a string is as simple as `putStrLn str` and you can give any type an instance of the typeclass `show` which allows you to change a value of the given type to a string.",0.0,haskell
13nyb26,jl3fezd,if you're looking to print things the same way you'd do in python for instance where you could just add a print anywhere for debugging then elm has a great `Debug.log :  String -> a -> a` which allows you to swap any value for itself after printing anything you want.,0.4,python
13nyb26,jl3fezd,if you're looking to print things the same way you'd do in python for instance where you could just add a print anywhere for debugging then elm has a great `Debug.log :  String -> a -> a` which allows you to swap any value for itself after printing anything you want.,0.4,elm
13nyb26,jl3fezd,"This with `Debug.toString` allows you to print any value at all, though you may find that most times using the elm time-travelling debugger makes this rather pointless, although there are still cases that the ttd can't handle.",0.125,elm
13nyb26,jl3fezd,"edit: forgot to mention, if the problem you're having is not understanding the type of a value, haskell's repl has a feature for this: any evaluated expression prefixed with :t will give you the type of the expression.",0.0,haskell
13nyb26,jl3fezd,Elm has even better and always shows the type of the result of the evaluation.,0.5,elm
13nyb26,jl33cl8,I thought I ran across something like a *debug-print* while (trying to) learn me a Haskell (for great good).,0.75,haskell
13nyb26,jl2ghlc,"In C#, everything (even value types) derive from an `object` base class that implements a few important methods, including a `.ToString()` that defaults to printing the fully qualified name of the type.",-0.19999999999999998,c
13nyb26,jl4ohva,Ada has an 'Img attribute which is compiler-defined.,0.0,ada
13nyb26,jl4prn9,"Since you already know OCaml, give Rust a try.",0.0,rust
13nyb26,jl4prn9,"Like in Haskell, you can in Rust put a clause on the structs and suddenly your structs have new possibilities.",0.06818181818181818,haskell
13nyb26,jl4prn9,"Like in Haskell, you can in Rust put a clause on the structs and suddenly your structs have new possibilities.",0.06818181818181818,rust
13nyb26,jl4syzs,Rust's `dbg!,0.0,rust
13nyb26,jl1mmpr,It seems similar to what another poster says Rust does.,0.0,rust
13nyb26,jl4d7i0,Haskell,0.0,haskell
13nyb26,jl3bfod,You know trying out a LISP has been on my to-do list for a long time.,-0.05,lisp
13nyb26,jl2opcz,"I don't speak D, but I'm pretty sure that's wrong for debugging - we want escaped strings, among other things.",0.03125,d
13nyb26,jl3g9bc,>I thought I ran across something like a debug-print while (trying to) learn me a Haskell (for great good).,0.75,haskell
13nyb26,jl3g9bc,Converting the value to a string to be printed uses the Show type class (similar to Debug in Rust) and is completely pure.,0.10714285714285714,rust
13nyb26,jl2o2c6,"That said, in Java and C# it's possible to semi-automatically implement `Debug` using reflection to actually print the fields.",0.0,java
13nyb26,jl2o2c6,"That said, in Java and C# it's possible to semi-automatically implement `Debug` using reflection to actually print the fields.",0.0,c
13nyb26,jl1wwxp,"I use Rust for like everything and I never really find it all that annoying, usually what’s more annoying is when something doesn’t implement debug, but that’s rare, most Rust devs just, derive what they need, it makes life easier, and for most use cases “it just works”.",-0.01874999999999999,rust
13nyb26,jl1wwxp,"Like procedural macros in Rust are god tier, just, muah",0.0,rust
13nyb26,jl9o9k2,"I think that if you're worried that adding derive would become annoying, then Rust isn't for you.",-0.8,rust
13nyb26,jl2y8sd,"In contrast to most languages, where you'd have to insert an additional line:      // javascript     let a = func()     console.log(a)  You can add it on the same line:      // rust     let a = dbg!",0.25,javascript
13nyb26,jl2y8sd,"In contrast to most languages, where you'd have to insert an additional line:      // javascript     let a = func()     console.log(a)  You can add it on the same line:      // rust     let a = dbg!",0.25,rust
13nyb26,jl4q55x,Don't forget Common Lisp.,-0.3,lisp
13nyb26,jl4q55x,I'd recommend Paul Grahams ANSI Common Lisp book.,-0.3,lisp
13nyb26,jl5tdp7,"I don’t think I’d consider introspecting in a repl as “printing”, but yeah, I guess it makes sense",0.0,d
13nyb26,jl1x4e3,"In Rust it becomes almost instinctual, like yeah when you create a new type you usually just by default write the derives you need and forget about it",-0.05681818181818182,rust
13nyb26,jl3ajcy,My primary language is Elixir.,0.4,elixir
13nyb26,jl5cy4t,Yep and Rust's `dbg!` inspired Elixir's [dbg](https://elixir-lang.org/getting-started/debugging.html#dbg),0.0,rust
13nyb26,jl5cy4t,Yep and Rust's `dbg!` inspired Elixir's [dbg](https://elixir-lang.org/getting-started/debugging.html#dbg),0.0,elixir
13ny7sd,jl6f737,"Aw cool, hope you find it useful and enjoy the class!",0.3833333333333333,cool
13ntrt7,jl1y5f8,"Even in the last 12 years (which is as far as the official [release notes](https://ocaml.org/releases) go), OCaml has had a ton of massive additions, including among others, first class modules, GADTs, flambda and a bunch of new backends.",0.09727272727272726,go
13ntrt7,jl170o7,"Here, `ms.exe` is a version of my compiler than compiles and runs programs from source without creating an executable:      c:\mx>ms hello     Hello World!",0.0,c
13ntrt7,jl170o7,15:23:36  It can used on itself:      c:\mx>ms ms hello     Hello World!,0.0,c
13ntrt7,jl170o7,15:24:21  And it can be stacked:      c:\mx>ms  ms ms ms ms ms  ms ms ms ms ms  hello     Hello World!,0.0,c
13ntrt7,jl170o7,"Here's another test:      c:\mx>ms ms \qx\qq \qx\hello     Hello, World!",0.0,c
13ntrt7,jl240aw,When I tried Dart once it took 6 seconds to compile Hello World.,0.0,dart
13ntrt7,jl24d5f,Sooner or later we’ll be bottlenecked by compute and this will all go away,0.0,go
13ntrt7,jl3fxx4,"On my much weaker machine, Tiny C can turn source code into executable binary at a speed pushing 1 million lines per second (probably several million lps on yours), and generating 5-10MB per second of native code.",0.04,c
13ntrt7,jl4s8iu,"Even in the last 12 years (which is as far as the official release notes go), OCaml has had a ton of massive additions, including among others, first class modules, GADTs, flambda and a bunch of new backends.",0.09727272727272726,go
13ntrt7,jl4utrs,> When I tried Dart once it took 6 seconds to compile Hello World.,0.0,dart
13ntrt7,jl4kxn6,"You're seriously trying to convince me that I should get mad at the fastest compiled language implementation I have ever used (with the possible exception of Go), because I need to wait 6 seconds for a full build?",-0.15208333333333332,go
13ntrt7,jl4kxn6,"Sure, your language and C are low level and simple enough that they don't need much computational effort to be type checked and translated to machine code, and if you're content with that, that's great!",0.2833333333333333,c
13ntrt7,jl4kxn6,Scala and GHC are slow.,-0.30000000000000004,scala
13ntrt7,jl4kxn6,Rust is slow.,-0.30000000000000004,rust
13ntrt7,jl53jpb,">Sure, your language and C are low level and simple enough that they don't need much computational effort to be type checked and translated to machine code, and if you're content with that, that's great!",0.24,c
13ntrt7,jl53jpb,And yet there are slow C compilers too!,-0.37500000000000006,c
13ntrt7,jl53jpb,"It's not just about optimisation, since those compilers are slow even at `-O0`:      c:\qx>tm tcc qq.c -fdollars-in-identifiers -luser32 -lkernel32 -lgdi32     TM: 0.09          c:\qx>tm gcc qq.c -oqq.exe -s     TM: 6.37  `tm` is a timing tool.",-0.30000000000000004,c
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,go
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,rust
13ntrt7,jl4izxq,If someone wants to improve compiler running time (for a production level language) they should go to Rust or Haskell first.,0.225,haskell
13ntrt7,jl6maue,"Generic ```ocaml let min(m, n) = if m<=n then m else n ``` is indeed not optimized, but it is still one C function call.",0.0,c
13ntrt7,jla3ij9,My favorite language is Haskell.,0.5,haskell
13ntrt7,jl6pk95,"> Generic ocaml let min(m, n) = if m<=n then m else n is indeed not optimized, but it is still one C function call.",0.0,c
13ntrt7,jlb10up,I'm on arm64 now (M2 Mac) so I cannot try it but when I get back to something that still uses Intel I'll give it a go.,0.0,go
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,c
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,d
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,dart
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,go
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,java
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,julia
13ntrt7,jl9ry7y,"The mainstream languages I tested were C, D, Dart, Go, Java, Julia, Odin, Rust, Zig.",0.0,rust
13ntrt7,jl9ry7y,(A C++ test would have just used the same C test code.),0.0,c++
13ntrt7,jl9ry7y,(A C++ test would have just used the same C test code.),0.0,c
13ntrt7,jlb8js4,> I'm on arm64 now (M2 Mac) so I cannot try it but when I get back tosomething that still uses Intel I'll give it a go.,0.0,go
13ntrt7,jla45l3,"I went with the approach from [Practical type inference for arbitrary rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf) (which is also the one taken by GHC), except that mine doesn't do deep subsumption (even the authors of that paper view its introduction as a mistake now and modern Haskell doesn't include it anymore) and is constraint based rather than immediately performing unification.",-0.175,haskell
13nht65,,* [Game Code](https://github.com/kjosib/sophie/blob/main/examples/guess_the_number.sg) written in Sophie * [Teletype Declarations](https://github.com/kjosib/sophie/blob/main/sophie/sys/teletype.sg) also in Sophie * [Teletype Adapter](https://github.com/kjosib/sophie/blob/main/sophie/adapters/teletype_adapter.py) Python module  I've modeled these I/O actions as a variant-record type with four cases:  * `done` is the stopped process.,-0.4,python
13nht65,,"As functions go, it clearly must return something characteristically similar to an `echo` object, but with a number instead of a list of strings.",0.05000000000000001,go
13nht65,,## Taking this to the next level  Python's PRNG is pretty excellent.,0.4166666666666667,python
13nht65,,"Supposing I pass the `teletype_adapter` a functional-process that emits numbers, I can just call that function instead of the Python PRNG from within the `teletype_adapter` module.",0.0,python
13nht65,jl5q6bs,"This could be applied as a twist on Rust's ownership for example, once the variable is sent in a function its ownership is ""abandoned"" instantly and all you are left with is a handle to a new state.",0.04545454545454545,rust
13nd9di,jkzf7ua,">Matches C execution speed, occasionally Bolin is faster  I am new to this programming languages thing.",0.06818181818181818,c
13nd9di,jl1tn3b,"My understanding is that you both do not want to open-source unfinished software, and do not want people to use it for commercial purposes, which all are cool things, but that particular clause also prevents freely sharing information and hinders independent research.",0.18333333333333332,cool
13nd9di,jl1tn3b,Not so cool.,0.35,cool
13nd9di,jl3ct3n,I had a go at running this in WSL within my Windows OS.,0.0,go
13nd9di,jl3ct3n,"I just extracted the files into `C:\bolin` under Windows, then switched to WSL and went to the `bolin\linux\bin` directory where there was an executable.",0.0,c
13nd9di,jl3ct3n,"If it can use a tcc backend, that sounds like it uses C intermediates, therefore gcc could work too (and there should be a option to just produce the C file).",0.0,c
13nd9di,jkzh2ai,"Our standard library has a few functions that may inline where C and C++ standard library does not, and no copying on fread/fgets https://bolinlang.com/more_optimal_standard  For the most part they're roughly the same speed",0.03333333333333333,c
13nd9di,jkzh2ai,"Our standard library has a few functions that may inline where C and C++ standard library does not, and no copying on fread/fgets https://bolinlang.com/more_optimal_standard  For the most part they're roughly the same speed",0.03333333333333333,c++
13nd9di,jl1ndtj,"For now, if I even can't distribute binaries, I would rather go to other languages...",-0.125,go
13nd9di,jl2267c,"I'm not experienced with that, but I'm curious to know a) how it works and b) how it differs from Rust.",-0.25,rust
13nd9di,jl4z8sk,"For example, you mention that it makes use of tcc, which means that it uses intermediate C?",0.0,c
13nd9di,jl4z8sk,"But is that Clang used for processing LLVM stuff, or processing C source code?",0.0,c
13nd9di,jl50ohz,So even if I start it as:      mm prog  that function could give me something like `c:\m\bin\mm.exe`.,0.0,c
13nd9di,jl50ohz,"Since I now know where `mm.exe` lives, in `C:\m\bin\` (or I can use `C:/m/bin/` internally), I can use that path (say I store it in `homepath`), to access a dependency such as `homepath + ""mm_help.txt""`, or `homepath+""../lib/etc...""`.",0.0,c
13nd9di,jl5rza3,I didn't want to write a plain C version since AVX2 has been supported for over a decade.,-0.21428571428571427,c
13nd9di,jl5sdtd,I assumed all the linux people would be hardcore and I didn't think this would run on WSL since I didn't use libc and I wrote lots of assembly,0.0,assembly
13nb6tq,,"// single digit error             case +1:             case -1:             case +10:             case -10:             case +100:             case -100:             printf(""Almost there, you'll get it next time!\n"");         }     }  Yes, this actually works in C and C++ 😂 I wonder if that is by design or accident?",-0.023809523809523808,c
13nb6tq,,"// single digit error             case +1:             case -1:             case +10:             case -10:             case +100:             case -100:             printf(""Almost there, you'll get it next time!\n"");         }     }  Yes, this actually works in C and C++ 😂 I wonder if that is by design or accident?",-0.023809523809523808,c++
13nb6tq,jl06dmm,"lets you do stuff like this: ```c switch(x){    ...    if(0){      case 1:; //initialization specific to 1    }    if(0){      case 2:; //initialization specific to 2    }    // logic shared by 1,2    break;    ... } ``` Yes, it definitely IS ugly, but in some places, especially in language like C where it's problematic to use lambdas for sophisticated code organization, it can help with keeping DRY.",-0.04444444444444443,c
13nb6tq,jl0fx4d,">language like C where it's problematic to use lambdas for sophisticated code organization, it can help with keeping DRY.",0.21666666666666667,c
13nb6tq,jl0fx4d,"I don't have a solution right now except for this which works for a few use-cases (here, it permanently jumps like the C example, it doesn't return):      case x                  # more general form of switch     when 1 then println ""one"";  recase 3     when 2 then println ""two"";  recase 3     when 3 then println ""three""     ...  (\*\* Actually from this perspective it doesn't sound too bad!",0.022959183673469403,c
13nb6tq,jl0fx4d,"Compared to that C `switch` example, it's the picture of elegance.",0.0,c
13nb6tq,jl156pk,"In C#, I'd just put that `print(""three"")` inside a delegate or local function and then invoke it at the end of `case 1`, `case 2`.",0.0,c
13nb6tq,jl156pk,"In C, one could ofc just make a macro and use it in the same way (I guess compiler would probably de-duplicate the code back tbh, but it still would be a terrible code smell because global macro namespacing and everything xD )  `recase` is a pretty interesting concept.",-0.041666666666666664,c
13n8v25,jky8bmy,(The C language also have \ line continuation that is something extra to complicate code - stay away from this kind of problem !),0.375,c
13n8v25,jkyhl86,That could in theory be done in lots of separate stages (the C standard is defined as though that happens).,0.0,c
13n8v25,jkyhl86,"In practice I think it's usually done in a single lexing/parsing pass, doing any macro expansion as you go, and skipping over comments and false conditional blocks (eg.",-0.2404761904761905,go
13n8v25,jkygm5k,C's `\` line continuation is weirder than many realise.,0.5,c
13n8v25,jkygm5k,"My C lexer didn't bother with this (I didn't know about it), but if needed, there is an optional separate pass to splice lines split with `\`, then normal lexing is done on that.",0.15,c
13n8v25,jkyy3p7,```c #define M\ ACRO 1  MACRO ``` expands to 1.  https://godbolt.org/z/Ta156Pr5s  this is insane and should be removed from C.,-1.0,c
13n7lb8,jkz3nhx,What do you think of [Tutorial D](https://www.dcs.warwick.ac.uk/~hugh/TTM/DBE-Chapter11.pdf)?,0.0,d
13n7lb8,jloffqs,"This ""D"" is a specification of features for a family of languages, while TutorialD is a particular quick-and-dirty-ish implementation for use in teaching classes about relational algebra.",0.16666666666666666,d
13n7lb8,jloffqs,"Links to that and other implementations can be found here: [https://www.dcs.warwick.ac.uk/\~hugh/TTM/projects.html](https://www.dcs.warwick.ac.uk/~hugh/TTM/projects.html)  Also my Tailspin language has tried to take influences from the ""D"" specification, although I don't pretend to follow it entirely, and it is still incomplete (no connection to databases, no specific filtering syntax) [https://github.com/tobega/tailspin-v0/blob/master/TailspinReference.md#relations](https://github.com/tobega/tailspin-v0/blob/master/TailspinReference.md#relations)  I'll certainly promote the idea that having relations and relational algebra in a language is very useful.",-0.045119047619047614,d
13n7lb8,jkz0o47,APL,0.0,apl
13morox,jl5ygm0,"> They (Taffy) just ask you to write Rust, and we ask you to learn much easier fastn lang (https://fastn.com/ftd/)  > ftd is designed for everyone, not just programmers.",0.2,rust
13m4wmz,jktz8tb,"Oh, by the way: The above scheme could also work for VTABLE dispatch...",0.0,scheme
13m4wmz,jktoywv,"I think you wanna resolve the `fields` when compiling and storing the `idxs`, then use that to pass the fields into the record, that IMHO should be just a vector:  ```rust struct Record {  fields: Vec<String> //if self-describing  fields: Vec<usize> //if you need to look up the names elsewhere   data:Vec<Scalar> } ```  Now, you need to implement a `project` operator on the record:  ```rust impl Record {   // note this is a `view` on the fields, without cloning   fn project(&self, cols:Vec<usize>) -> Option<Vec<(usize, &Scalar)>> } ```  You only need to check if the `function params` can `project` the record in the call-site, you run this dynamically but at compile time!",0.0,rust
13m4wmz,jktoywv,"```rust data Invoice[qty:i32, price:Dec] data InvoiceLine[qty:i32, price:Dec, ref:String]   fn totalize(of:[qty:i32, price:Dec, ...]) -> Dec    //when compiling you call `.project` and check if this `fit` here... let inv = Invoice[qty:1, price:10.0]  //inv.project(qty, price) == Some([qty:i32, price:Dec,..]) let total = totalize(inv)  ```",0.2,rust
13m4wmz,jkwvqv0,"As someone points out, this kind of scheme works best if everything is known ahead of time.",0.8,scheme
13lzxgd,,"I also also know that generics slow down a lot compilation (for example as from as i know c++ compilers are slowed down especially by templates, or am i wrong?)",-0.22222222222222224,c++
13lzxgd,jksuoyw,This is a great question with a really cool answer!,0.61875,cool
13lzxgd,jksuoyw,"Generics in Rust and especially C++ are slow, because they are implemented via momomorphization, i.e.",-0.15000000000000002,rust
13lzxgd,jksuoyw,"Generics in Rust and especially C++ are slow, because they are implemented via momomorphization, i.e.",-0.15000000000000002,c++
13lzxgd,jksuoyw,"C++ is especially bad in this regard, since it needs to re-typecheck every single instantiation.",-0.5357142857142857,c++
13lzxgd,jksuoyw,"But Generics in Java, OCaml, Haskell, or most high level langauges for that matter don't slow down compilation.",0.0511111111111111,java
13lzxgd,jksuoyw,"But Generics in Java, OCaml, Haskell, or most high level langauges for that matter don't slow down compilation.",0.0511111111111111,haskell
13lzxgd,jksuoyw,"Value types are not heap alllocated, so these are compiled via monomorphization like in C++ and Rust, with the caveat, that they are monomorphized *lazily at runtime*.",-0.25,c++
13lzxgd,jksuoyw,"Value types are not heap alllocated, so these are compiled via monomorphization like in C++ and Rust, with the caveat, that they are monomorphized *lazily at runtime*.",-0.25,rust
13lzxgd,jkst0hi,"This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,rust
13lzxgd,jkst0hi,"This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,c++
13lzxgd,jktghpf,"The C++ compiler has to work with human-readable text, which adds some overhead.",0.0,c++
13lzxgd,jktghpf,Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,c
13lzxgd,jktghpf,Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,c++
13lzxgd,jktghpf,"For example, in C++, `std::array<int, 1>` and `std::array<int, 2>` are different types, while C# has no equivalent of that and you would just use `int[]` for both.",0.0,c++
13lzxgd,jktghpf,"For example, in C++, `std::array<int, 1>` and `std::array<int, 2>` are different types, while C# has no equivalent of that and you would just use `int[]` for both.",0.0,c
13lzxgd,jktghpf,"Or take `Compare` of `std::map`, which is a template parameter, while in C# the equivalent would use an `IComparer<T>` object, so the type of the collection stays the same.",0.0,c
13lzxgd,jku5saj,C++ and Rust are extremely slow at compiling generic functions.,-0.15000000000000002,c++
13lzxgd,jku5saj,C++ and Rust are extremely slow at compiling generic functions.,-0.15000000000000002,rust
13lzxgd,jku5po7,The story for Java is a lot deeper than that.,0.0,java
13lzxgd,jkv5ot0,It's worth noting that most of those things you talk about in Java etc.,0.4,java
13lzxgd,jkv5ot0,"Notably this implies *not* doing type-erasure like Java does - instead, pass the vtables at runtime as an extra argument.",0.25,java
13lzxgd,jkw47jy,"> C++ is especially bad in this regard, since it needs to re-typecheck every single instantiation.",-0.5357142857142857,c++
13lzxgd,jkw47jy,"Quick note about C++ compilation, type-checking of generics is done in two passes:   1.",0.3333333333333333,c++
13lzxgd,jksv6qz,"so does the .net jit use this approach, i barely know how java does it?",0.05,java
13lzxgd,jkvwu25,I don't buy that it is slow to compile; the compilers for Rust and C++ that have been mentioned are slow anyway for lots of other reasons.,-0.2416666666666667,rust
13lzxgd,jkvwu25,I don't buy that it is slow to compile; the compilers for Rust and C++ that have been mentioned are slow anyway for lots of other reasons.,-0.2416666666666667,c++
13lzxgd,jkvwu25,"After all languages where you have to do manual monomorphisation, like C, are not slow to compile.",0.15000000000000002,c
13lzxgd,jkw4df9,"> This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,rust
13lzxgd,jkw4df9,"> This is what Rust and C++ do and is slow to compile because each copy will have to be optimized and compiled separately, but it is also fast because each copy can be optimized separately.",-0.05000000000000002,c++
13lzxgd,jkw4df9,AFAIK the Rust compiler already performs a few (lightweight) optimizations on the generic code itself (at MIR level) prior to generating the backend IR for each set of generic arguments and handing it off to the backend.,-0.05,rust
13lzxgd,jku55mq,"> The C++ compiler has to work with human-readable text, which adds some overhead.",0.0,c++
13lzxgd,jku55mq,At least on my own benchmark suite .NET is competitive with C++ on register heavy tests (sometimes beating C++) and generally loses out on memory intensive tasks.,-0.05,c++
13lzxgd,jku55mq,> Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,c
13lzxgd,jku55mq,> Modern C# uses generics less than modern C++ uses templates.,0.07777777777777779,c++
13lzxgd,jku55mq,"For example, in C++, std::array<int, 1> and std::array<int, 2> are different types, while C# has no equivalent of that and you would just use int[] for both.",0.0,c++
13lzxgd,jku55mq,"For example, in C++, std::array<int, 1> and std::array<int, 2> are different types, while C# has no equivalent of that and you would just use int[] for both.",0.0,c
13lzxgd,jku55mq,"C# specifically has `int[,]` for 2D arrays.",0.0,c
13lzxgd,jku55mq,"> Or take Compare of std::map, which is a template parameter, while in C# the equivalent would use an IComparer<T> object, so the type of the collection stays the same.",0.0,c
13lzxgd,jku55mq,Conversely you have .NET's `Dictionary` where its monomorphization generally seems to produce faster code than C++ hash tables AFAICT.,0.05000000000000002,c++
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,c++
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,rust
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,c
13lzxgd,jkw58hx,"`int[]` would be comparable to `std::vector<int>` or `std::unique<[int]>` more than `std::array<int, N>`, I expect, but otherwise I agree: C++ and Rust lean _heavily_ on generics as part of their Zero-Overhead Abstraction principle, whilst most other languages -- including C -- tend to just go with one type/implementation and call it good enough.",0.22916666666666666,go
13lzxgd,jku72p4,"The important difference between Java and C# is that in Java, monomorphization is an Optimization, while in C#, it is a compilation strategy.",0.4,java
13lzxgd,jku72p4,"The important difference between Java and C# is that in Java, monomorphization is an Optimization, while in C#, it is a compilation strategy.",0.4,c
13lzxgd,jku72p4,"This manifests in the fact that Java does not allow polymorphic functions over value types, because it cannot compile them via the usual generic compilation.",-0.125,java
13lzxgd,jku72p4,"In fact, AOT compiled languages like Haskell also employ monomorphization as an optimization, though not nearly as thoroughly as in JIT compilers (it's usually called Specialization when it's just an optimization, at least in the Haskell world)",-0.19999999999999998,haskell
13lzxgd,jkw50dt,"> After all languages where you have to do manual monomorphisation, like C, are not slow to compile.",0.15000000000000002,c
13lzxgd,jkw50dt,"I remember a talk from Bryan Cantrill, where he explained learning Rust by naively translating a C program he had.",-0.3,rust
13lzxgd,jkw50dt,"I remember a talk from Bryan Cantrill, where he explained learning Rust by naively translating a C program he had.",-0.3,c
13lzxgd,jkw50dt,"After he was done -- ie, the Rust program was compiling and seemingly working as the C program had -- he checked the performance and was surprised that the Rust program outperformed the C one, when the former had not been optimized.",0.05,rust
13lzxgd,jkw50dt,"After he was done -- ie, the Rust program was compiling and seemingly working as the C program had -- he checked the performance and was surprised that the Rust program outperformed the C one, when the former had not been optimized.",0.05,c
13lzxgd,jkw50dt,"Wanting to understand how that came to be, he profiled both, and realized that his C program used hand-written data-structures that had been selected for their simplicity -- since they had been re-implemented in the program -- and that were type-erased.",0.0,c
13lzxgd,jkw50dt,"In contrast, the Rust program relied on the standard data-structures: generic, highly tuned, etc...",0.05333333333333334,rust
13lzxgd,jkva4fq,">C# specifically has int[,] for 2D arrays.",0.0,c
13lzxgd,jkw2pf9,That's more memory traffic than having the accumulator go via the stack!,0.625,go
13lzxgd,jlb3iat,"Actually, something I'd like to see explored -- though it's likely easier in Rust than C++^1 -- is _partial_ monomorphization.",-0.03333333333333333,rust
13lzxgd,jlb3iat,"^1 _The C and C++ standards mandate that different functions, which includes different template instantiations of a template function, have a distinct address.",0.09999999999999999,c
13lzxgd,jlb3iat,"^1 _The C and C++ standards mandate that different functions, which includes different template instantiations of a template function, have a distinct address.",0.09999999999999999,c++
13lzxgd,jkwklwv,"It may be [The Summer of Rust, August 2018](https://www.youtube.com/watch?v=YKv_IDN0zCA), an informal talk (no slide, just him sitting on a chair) as it seems to be his first talk about Rust according to http://dtrace.org/blogs/bmc/2018/02/03/talks/.",0.25,rust
13lzxgd,jkwklwv,> Cantrill appears to be a Rust evangelist so it would be surprising if he'd chosen an example that performed worse in Rust!,0.09999999999999998,rust
13lzxgd,jkwklwv,"He didn't use to be, Cantrill used to work for Sun Microsystems then Oracle, nigh exclusively in C. This was his first foray in Rust, and he was clearly skeptic; he'd old enough to have seen many ""C-killers"" after all.",0.19,rust
13lzxgd,jkwklwv,> My brief experience with Rust seemed to show that Debug mode produced code that was 10 times slower then Release mode; was that non-optimised version using Debug mode?,0.0,rust
13lzxgd,jkwklwv,"Rust and C++ are on par, typically.",-0.16666666666666666,rust
13lzxgd,jkwklwv,"Rust and C++ are on par, typically.",-0.16666666666666666,c++
13lzxgd,jkwklwv,"At O1, when the compilers use registers instead of the stack, it's already quite faster, though the lack of inlining still means that the 4-5 calls required to go through all the layers of `x[0]` cost around 20-25ns.",0.0,go
13lzqpi,jku5aut,"This is so cool, I remember first seeing Inko when looking at Pony.",0.3,cool
13lzqpi,jlfpuyp,"I also really want to like the language, it certainly does cool things!",0.2839285714285714,cool
13lyst8,jkshc2t,"Java, however, proves that even if you're stuck with shitty stack-based *bytecode* for legacy-loading reasons, it's still possible to turn it into register-based code for interpretation.",0.15,java
13lyst8,jksvanv,"Anton Ertl has written several papers about this kind of optimisation in the context of Forth, which you may find useful.",0.3,forth
13lyst8,jkt1n7p,"IMHO, Id go with 4 registers for the data stack, but also try and do something for the locals and call stack - have 4 registers for locals (like lua), and another 4 registers for the call stack too.",0.0,go
13lyst8,jkt1n7p,"IMHO, Id go with 4 registers for the data stack, but also try and do something for the locals and call stack - have 4 registers for locals (like lua), and another 4 registers for the call stack too.",0.0,lua
13lyst8,jkterbp,"Hi Till-one,  HLL variables - There's no ASM, happy to add `register` or anything else that would guarantee they go into registers?",0.8,go
13lyst8,jkterbp,"`make benchmark` will generate the test  I've seen your other comment, and will give those suggestions a go ✌",-0.125,go
13lyst8,jktbmks,"(If transpiled to C, where it ends up as a regular `switch` inside a loop, then `gcc-O3` can't manage any better.)",0.25,c
13lta2u,jkrgchf,Nitpick: you wrote ASCI C instead of ANSI C,0.0,c
13lta2u,jkrowdd,> A lot of programming/developer jobs also refer to C/C++ when they need a programmer who knows either C or C++.,0.0,c
13lta2u,jkrowdd,> A lot of programming/developer jobs also refer to C/C++ when they need a programmer who knows either C or C++.,0.0,c++
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,c
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,haskell
13lta2u,jkrowdd,"In the overall landscape of programming languages from C to Haskell to Prolog, C/C++ are in the same category.",0.0,prolog
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,c
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,c++
13lta2u,jkrowdd,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,go
13lta2u,jkrowdd,"So should I refer to Zig, Go, and Nim as C/Zig, C/Go, and C/Nim?",0.0,go
13lta2u,jkrl9s7,"That, and most jobs I’ve had that advertised needing C/C++ was because it was an old and/or mixed bag of both legacy C code, and C++ so why not?",0.19999999999999998,c
13lta2u,jkrl9s7,"That, and most jobs I’ve had that advertised needing C/C++ was because it was an old and/or mixed bag of both legacy C code, and C++ so why not?",0.19999999999999998,c++
13lta2u,jkrl9s7,“If you’re a C programmer say you’re a C programmer” is lame as it seems to suggest that it’s like an identity rather than a skill you have.,-0.5,c
13lta2u,jkrl9s7,"For instance, I professionally work with C/C++/Python and Rust.",0.1,rust
13lta2u,jkrl9s7,Should I say I’m not any one of these types just to make sure I don’t accidentally give people the impression that I think c and c++ are the exact same?,0.25,c
13lta2u,jkrl9s7,Should I say I’m not any one of these types just to make sure I don’t accidentally give people the impression that I think c and c++ are the exact same?,0.25,c++
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,c
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,c++
13lta2u,jkt0d5o,"> There is probably someone who is going to say, “Well you can write C code in a C++ program, so technically C is a subset of C++.” The only problem is that you can write C code in Zig, Go, Nim, and basically almost every other language out there has a C FFI!",-0.052083333333333336,go
13lta2u,jkt0d5o,"So should I refer to Zig, Go, and Nim as C/Zig, C/Go, and C/Nim?",0.0,go
13lta2u,jkt0d5o,"It's a subset because you can literally copy-paste (most) C into C++, change imports a bit, and it will compile (and usually run) in exactly the same way.",0.125,c
13lta2u,jkt0d5o,"It's a subset because you can literally copy-paste (most) C into C++, change imports a bit, and it will compile (and usually run) in exactly the same way.",0.125,c++
13lta2u,jkt0d5o,"What's not a joke is you can take basically any reasonable C program, only change headers and imports, and get a working C++ program.",0.1,c
13lta2u,jkt0d5o,"What's not a joke is you can take basically any reasonable C program, only change headers and imports, and get a working C++ program.",0.1,c++
13lta2u,jkt0d5o,"The real reason C and C++ are lumped together as C/C++ is because they, although different languages, have more in common than any other (related) language.",0.04583333333333333,c
13lta2u,jkt0d5o,"The real reason C and C++ are lumped together as C/C++ is because they, although different languages, have more in common than any other (related) language.",0.04583333333333333,c++
13lta2u,jkrg784,"I definitely agree, but article talks about scaring off C programmers...",0.0,c
13lta2u,jkrg784,"I had an interview last week for a C programming job, doing a bunch of complicated vector math.",-0.25,c
13lta2u,jksfly4,"Obviously these are different languages now, but I will keep saying C/C++ for as long as C++ programmers expect that standard platform `.h` header files can be interpreted as C++ declarations.",-0.0125,c++
13lta2u,jksfly4,"It's not unusual for various languages to be able to ingest C declarations in order to facilitate FFI, but C++ is unique in not using a dedicated facility for this, but instead hoping that the header file will contain only constructs that are valid C++ - and very likely also additional `extern ""C""`annotations!",0.12916666666666668,c
13lta2u,jksfly4,"It's not unusual for various languages to be able to ingest C declarations in order to facilitate FFI, but C++ is unique in not using a dedicated facility for this, but instead hoping that the header file will contain only constructs that are valid C++ - and very likely also additional `extern ""C""`annotations!",0.12916666666666668,c++
13lta2u,jksfhsd,"Everyone who vehemently shouts about how C and C++ are very different are technically correct, but not correct enough for me to give a shit.",-0.05,c
13lta2u,jksfhsd,"Everyone who vehemently shouts about how C and C++ are very different are technically correct, but not correct enough for me to give a shit.",-0.05,c++
13lta2u,jksfhsd,"""C/C++"" is code for ""you know C++ but aren't gonna whine when you see a malloc.""",0.0,c++
13lta2u,jkrw0z4,In the end C++ still has the allmost-full C compatibility.,0.0,c++
13lta2u,jkrw0z4,In the end C++ still has the allmost-full C compatibility.,0.0,c
13lta2u,jkrw0z4,An other issue seems to be that C and C++ are the two ends of a dialect continuum and some people just choose to sit in the middle.,-0.0625,c
13lta2u,jkrw0z4,An other issue seems to be that C and C++ are the two ends of a dialect continuum and some people just choose to sit in the middle.,-0.0625,c++
13lta2u,jkrw0z4,I do agree that quite a few C/C++ arguments are not really about C/C++ but more about just C and one should cover C++ specifically sometimes.,0.06666666666666665,c
13lta2u,jkrw0z4,I do agree that quite a few C/C++ arguments are not really about C/C++ but more about just C and one should cover C++ specifically sometimes.,0.06666666666666665,c++
13lta2u,jkrw0z4,In C++ this is mostly automatic (but unsafe with respect to dangling pointers) while in C it is mostly manual.,0.5,c++
13lta2u,jkrw0z4,In C++ this is mostly automatic (but unsafe with respect to dangling pointers) while in C it is mostly manual.,0.5,c
13lta2u,jkrw0z4,Most memory bugs are due to particularities of using either C or C++ and don't show up so much in the other.,0.11249999999999999,c
13lta2u,jkrw0z4,Most memory bugs are due to particularities of using either C or C++ and don't show up so much in the other.,0.11249999999999999,c++
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,c
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,c++
13lta2u,jksdnbw,\>Another big incompatibility with C and C++ is that C++ is actually incompatible   with K&R syntax.,0.0,r
13lta2u,jksdnbw,"By this logic, Python 3 is limited because it's not compatible with Python 2.",-0.07142857142857142,python
13lta2u,jkuz44k,Isn’t C/C++ really just C++?,0.2,c++
13lta2u,jkw3j27,I'll stop saying C/C++ when C++ is weaned from C.  How do you communicate over the network with C++?,0.0,c++
13lta2u,jkw3j27,"Hence, communicating over the network -- which, frankly, most applications tend to do nowadays -- requires writing C code.",0.5,c
13lta2u,jkw3j27,"And as long as that's the case, it means programming in C++ requires a working knowledge of C programming, to work as C/C++ programmers on C/C++ codebases.",-0.05,c++
13lta2u,jkw3j27,"And as long as that's the case, it means programming in C++ requires a working knowledge of C programming, to work as C/C++ programmers on C/C++ codebases.",-0.05,c
13lta2u,jkw3j27,"_And yes, it saddens me, I was hoping that C++17 introducing `<filesystem>` meant the end of mandatory C in C++ was nigh, but here we are, 6 years later..._",0.0,c
13lta2u,jkw3j27,"_And yes, it saddens me, I was hoping that C++17 introducing `<filesystem>` meant the end of mandatory C in C++ was nigh, but here we are, 6 years later..._",0.0,c++
13lta2u,jksacsb,Well we mix C and C++ very freely based on what we need.,0.52,c
13lta2u,jksacsb,Well we mix C and C++ very freely based on what we need.,0.52,c++
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,python
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,c
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,go
13lta2u,jksacsb,"Python backend along with high performance library is usually convenient in C and it is usually way faster to go to memory blocks directly for performance, yet you don’t want to give up on C++ completely and cuda also needs C++ so it’s very common that you need both.",-0.08833333333333333,c++
13lta2u,jkrpgvy,"To be fair, he wrote the C in ASCII.",0.7,c
13lta2u,jkwyqno,"But I guess if you mean nemory unsafe languages with a C style syntax, I can only think of C and C++.",-0.15625,c
13lta2u,jkwyqno,"But I guess if you mean nemory unsafe languages with a C style syntax, I can only think of C and C++.",-0.15625,c++
13lta2u,jksgl6b,"It is not at all that strange, less strange than Java/C# imo considering that the two ecosystems there are completely different, whereas there's a huge amount of ecosystem overlap with C and C++.",0.026666666666666682,c
13lta2u,jksgl6b,"It is not at all that strange, less strange than Java/C# imo considering that the two ecosystems there are completely different, whereas there's a huge amount of ecosystem overlap with C and C++.",0.026666666666666682,c++
13lta2u,jksgl6b,"Same build tools, each consuming libraries written by the other with light opaque TU boundary interfaces or convenience layers, thanks to a certain degree of source compatibility (not like Zig, which supports converting C declarations into Zig declarations via a special directive @cImport, fundamentally different from the level of compatibility between C and C++).",0.14948979591836736,c
13lta2u,jksgl6b,"Same build tools, each consuming libraries written by the other with light opaque TU boundary interfaces or convenience layers, thanks to a certain degree of source compatibility (not like Zig, which supports converting C declarations into Zig declarations via a special directive @cImport, fundamentally different from the level of compatibility between C and C++).",0.14948979591836736,c++
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,c
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,c++
13lta2u,jkx1bbv,I'd argue that C and C++ are different categories for the simple reason that they have different modern replacements -- Zig and Rust respectively.,0.04,rust
13lta2u,jkt4d7m,[C Is Not a Low-Level Language](https://queue.acm.org/detail.cfm?id=3212479),0.0,c
13lta2u,jkrjcwa,"while I understand why people enjoy programming in C, that sounds like a really bad decision if they actually want to get anything done",-0.09999999999999994,c
13lta2u,jksczy6,"Unfortunately, even using modern C++, it is still *really* easy to mess things up.",-0.010416666666666657,c++
13lta2u,jksczy6,"With C++, you get the illusion of safety with little actual added safety.",-0.09375,c++
13lta2u,jkw0o5n,"First of all, not all C code compiles in C++.",0.25,c
13lta2u,jkw0o5n,"First of all, not all C code compiles in C++.",0.25,c++
13lta2u,jkw0o5n,"2nd of all, if you write C++ code that would be fully valid C, you're not a good C++ programmer (with the obvious exceptions).",-0.11666666666666665,c++
13lta2u,jkw0o5n,"2nd of all, if you write C++ code that would be fully valid C, you're not a good C++ programmer (with the obvious exceptions).",-0.11666666666666665,c
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,c
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,c++
13lta2u,jktrli7,"I would also assume there are projects that use both C and C++ for different subsystems, but I can't think of a legitimate use case that uses both Java and C#.",0.0,java
13lta2u,jks2bwn,"True, their C skills are rusty",0.35,c
13lta2u,jksd4pw,> Rust programmers who have no interest making a 30 year step backwards.,0.0,rust
13lta2u,jksftgb,I don't think C++ is save.,0.0,c++
13lta2u,jksftgb,"But its memory management works very different from C, with some pros and cons.",0.0,c
13lta2u,jkw0h5e,C++?,0.0,c++
13lta2u,jkrop3t,"Which is why I was interrogating their choice of C. They could get identical performance and much better ergonomics with C, but the founder was fresh out of school when he started the codebase, was only exposed to gamedev C++ (its own trash dialect), and has a bunch of wrong-headed misconceptions about C++.",0.35,c
13lta2u,jkrop3t,"Which is why I was interrogating their choice of C. They could get identical performance and much better ergonomics with C, but the founder was fresh out of school when he started the codebase, was only exposed to gamedev C++ (its own trash dialect), and has a bunch of wrong-headed misconceptions about C++.",0.35,c++
13lta2u,jkrvfde,"What's more, I _can_ use an existing template expression library in C++.",0.5,c++
13lta2u,jkrvfde,"In C, I have to further doom the ergonomics by switching to pointers and temporaries.",0.0,c
13lta2u,jks3mb7,It's not just a bad reason; it's an invalid reason because memory management in C++ can trivially be just as manual as it is in C. Even Rust gives you the same level of control if you want to opt out of all the higher-level primitives for managing memory.,-0.3499999999999999,c++
13lta2u,jks3mb7,It's not just a bad reason; it's an invalid reason because memory management in C++ can trivially be just as manual as it is in C. Even Rust gives you the same level of control if you want to opt out of all the higher-level primitives for managing memory.,-0.3499999999999999,rust
13lta2u,jkrpu0e,You're making a stronger case for C over C++ than you might think.,0.0,c
13lta2u,jkrpu0e,You're making a stronger case for C over C++ than you might think.,0.0,c++
13lta2u,jkrpu0e,"The compiler might do that on -ffast-math, but it probably wont: the only way to really guarantee those kinds of performance characteristics is to use the compiler intrinsics directly, and then you are de facto programming in C.   Sure, there are C++ libraries for SIMD operations, but if you're doing this kind of very high-performance SIMD stuff, it's an entirely reasonable decision to say ""we need very low-level control of how to optimize this stuff, so we use the intrinsics directly"".",0.23333333333333328,c++
13lta2u,jkruiqm,My issue wasn't that they were using C. It isn't _wrong_ to use C for this shit.,-0.35,c
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,c
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,c++
13lta2u,jkruiqm,"But I expected an answer like ""we use XYZ library, and it's in C"", or ""we're targeting ABC arch, and C++ is a bad fit there"", or ""we investigated Rust first, but the cost of developers was too high"".",0.002000000000000041,rust
13lta2u,jkruiqm,"But if you're giving up ergonomics, it's not an acceptable answer to say ""we chose C because we wanted to manually manage our memory"".",0.0,c
13ld7ih,jkpcnjw,This is a cool post / train of thought.,0.35,cool
13ld7ih,jkpcnjw,This is doubly true of the cloud (I think the idea of cloud compilers is really cool for this reason).,0.35,cool
13l5mq9,jkpue4y,"As an example, he said C++ almost had `auto` in its first version.",0.25,c++
13l5mq9,jkpue4y,"Due to ruining compatibility with C, it didn't make the cut.",-0.125,c
13l5mq9,jkpue4y,"His talks usually deal with the design of C++ both past, present, and future)  I realize a language could be created as a specific tool for a specific job, doing it better than more generic languages.",0.05555555555555555,c++
13l5mq9,jkqfwhr,Some examples I can think of are:  -	Rust’s phenomenal of algebraic data types and pattern matching taken from the functional world.,0.5,rust
13l5mq9,jkqfwhr,-	Go’s concurrency model that makes threading so much nicer to use.,0.2,go
13l5mq9,jkqfwhr,-	Python has picked up types and pattern matching.,0.0,python
13l5mq9,jkqfwhr,"-	Rust and Swift have Macro/DSL support built in, allowing different languages to be written inside of the host language, which has a lot of useful cases.",0.15,rust
13l5mq9,jkqfwhr,"-	Rust and Swift have Macro/DSL support built in, allowing different languages to be written inside of the host language, which has a lot of useful cases.",0.15,swift
13l5mq9,jkqfwhr,"-	Typescript’s Structural Typing allows for heterogeneous data types to work across any package, import, or function signature so long as an explicit subset of types work.",-0.05,typescript
13l5mq9,jkw2o0g,"Rust's borrow-checking may have been based on Cyclone's region management, but it's still quite a leap, and is continuously being refined.",0.0,rust
13l5mq9,jkw2o0g,An excellent demonstration is actually C++: it's a blob of many organically tacked together features with many subtle and baffling interactions between them.,0.33333333333333337,c++
13l5mq9,jkqkk8y,"If you look at your pattern matching example, I found:  > Early programming languages with pattern matching constructs include COMIT (1957), SNOBOL (1962), Refal (1968) with tree-based pattern matching, Prolog (1972), SASL (1976), NPL (1977), and KRC (1981).",0.3,prolog
13l5mq9,jkqkk8y,The concept of a macro surely isn't new as we have the example of C macros.,0.13636363636363635,c
13l5mq9,jkrwlo4,"For example, very few languages support higher-kinded types, type-level programming like in TypeScript is super rare, and many or most mainstream languages support either nominal or structural types, but not both.",0.27466666666666667,typescript
13l5mq9,jkrwlo4,(And here I’m considering Haskell “mainstream”.),0.0,haskell
13l5mq9,jkrwlo4,"It’s my position that programming is still in its infancy, and that most of our current languages are as primitive compared to where we’ll be in 50 years as C and Fortran are when compared to now.",0.25,c
13l5mq9,jkrwlo4,"It’s my position that programming is still in its infancy, and that most of our current languages are as primitive compared to where we’ll be in 50 years as C and Fortran are when compared to now.",0.25,fortran
13l5cun,,"The last year I was implementing the compiler for a very basilar programming language with the rust-style syntax but c-style semantic, basically a C with generics.",0.1,c
13l5cun,,"My goal was to get a modernized version of C, but with a blazing compiler and I achieved impressive performance (about 3mln loc/s turned into special bytecode i used).",0.6785714285714286,c
13l5cun,,"(Please note that the examples in the code snippets are useful to give the idea, they are not extracted from any existing code)  I think this behavior is due to the lack of forward declarations in C which makes inline not always possible when using functions defined in .o and declared in .h (I'm aware of linktime inline, but that's not the point).",0.10625,c
13l5cun,jkojrtn,"If you had used C++ instead of C you would likely have gotten such a ""return value optimization"" guaranteed for free, or could have used placement-new to construct the object in an existing location.",0.13333333333333333,c++
13l5cun,jkojrtn,"If you had used C++ instead of C you would likely have gotten such a ""return value optimization"" guaranteed for free, or could have used placement-new to construct the object in an existing location.",0.13333333333333333,c
13l5cun,jkojrtn,"Aside from that, there's no fundamental reason why      Type create();      ...     value = create();  should be slow, assuming that the Type is trivially copyable (in C++ parlance) and that a suitable calling convention is used.",0.125,c++
13l5cun,jkojrtn,My tip would be to look at the assembly code generated for your function calls (and for the contents of that function) to see if there is a substantial difference.,0.0,assembly
13l5cun,jkojrtn,self-referential structs (which is the actual reason why RVO matters in C++).,0.0,c++
13l5cun,jkudh7s,"IMHO, this is a place where many ABIs suck and many C and C++ compilers suck and they all leave a *lot* of performance on the table as a consequence.",0.5,c
13l5cun,jkudh7s,"IMHO, this is a place where many ABIs suck and many C and C++ compilers suck and they all leave a *lot* of performance on the table as a consequence.",0.5,c++
13l5cun,jkudh7s,* Where must this `Person` go?,0.0,go
13l5cun,jkudh7s,If the returned `Person` might go on the heap then you have no choice but to do memory IO.,0.0,go
13l5cun,jkudh7s,those that cannot be called via a C ABI) to adhere to the C ABI.,0.0,c
13l5cun,jkp9btg,>I think this behavior is due to the lack of forward declarations in C which makes inline not always possible when using functions defined in .o and declared in .h  To be able to inline requires the source code of the function to be visible.,0.125,c
13l5cun,jkohjb8,"In C, the functions you've demonstrated should compile the same way, and it's not even an optimization, but part of the standard.",0.0,c
13l5cun,jkohjb8,So in C (and C++) it should have no performance difference whatsoever.,0.0,c
13l5cun,jkohjb8,So in C (and C++) it should have no performance difference whatsoever.,0.0,c++
13l5cun,jkohf37,"init is like a c++ constructor, i just use it to initialize an object, usually on the stack, but it's not necessary.",-0.125,c++
13l5cun,jkohf37,"create the same thing, but you can see it like a rust constructor.",0.0,rust
13l5cun,jkqhi87,"you are right, forward declarations did not cause functions not to be inlined, but i did since i needed different .cpp and i used python as a build system and i compiled each .cpp to its .o and so i had no inline.",0.14285714285714285,python
13l5cun,jksainz,"Also consider `string str = """"; for n -> str += 'c'` turned to `char[] str = new[n]; for n -> str[i] = 'c'` i used to consider this a micro optimization, isn't it?",0.0,c
13l5cun,jkoidhl,"no you should read the entire post please, i specified that in c they compile to different things (one faster and one slower) when call to them is not inlined.",0.0,c
13l5cun,jkon2po,"> The standard literally specifies  To be pedantic, the C standard does no such thing, but then again the C standard also pretends that things such as the ""stack"" don't exist.",0.0,c
13l5cun,jkok44l,well init example assembly is about 70% of create example,0.0,assembly
13l5cun,jkv2plw,"Calling an object ""self"" within functions that are method-like on that object is a pretty common convention in C, enough so that I'd call it idiomatic.",-0.016666666666666663,c
13k8d8k,jkjyv3b,"You are the letlang guy, the one that also did an article on the Rust parsing ecosystem!",0.0,rust
13k8d8k,jklr5a0,"> an article on the Rust parsing ecosystem  I'd be much interested in a link to the article, I couldn't find it.",0.25,rust
13k8d8k,jklydxj,"Here you go:   [https://david-delassus.medium.com/writing-a-simple-lisp-interpreter-in-rust-91dd32ea4d8f?sk=e3b513bd85e9d9d944180ec35d96dbcf](https://david-delassus.medium.com/writing-a-simple-lisp-interpreter-in-rust-91dd32ea4d8f?sk=e3b513bd85e9d9d944180ec35d96dbcf)   (friend link, no paywall, for some reason Reddit does not remove the sk tag here)",-0.75,go
13k1i9i,jkim8uo,"Algebra suitable to perform reduction trees complicates as we go down to natural deduction and Hilbert systems because conjunctions and disjunctions are not a part of the core system, and have to be custom defined, introducing additional complexity in proofs.",0.16481481481481483,go
13jvof8,jkkxkl4,"> dunno why SE was needed  Stack Exchange is designed to go straight from (fact-based, fairly-small-scoped) questions to answers with nothing in between.",0.2,go
13jvof8,jkkxkl4,Trying to do something that Stack Exchange wasn't designed to do within Stack Exchange will go poorly.,-0.4,go
13jvof8,jkihrpn,„Can you help me debug my shunting yard?“ - moved to Trains and Locomotives Stack Exchange :D,1.0,d
13j3u3m,jkgpapo,"Most dependently typed languages use this to enforce complete soundness (the program cannot crash), but Futhark, for mostly pragmatic reasons, does not go this far.",0.30000000000000004,go
13j3u3m,jkig3oq,"I don't envision Futhark running a pacemaker or a nuclear power plant, but then again they put Ada on the Arianne V rocket, and we know how that went.",0.0,ada
13j3u3m,jkih7ea,"If you want to take a Lisp perspective (always good for the soul), it's more that sizes are *quoted expressions*.",0.6,lisp
13j3u3m,jkih7ea,in Lisp `(= '(+ 1 2) '(+ 2 1))` is false.,-0.4000000000000001,lisp
13iqrlm,,"To recap, for anyone who's so far managed to avoid learning how Charm works --- it embodies the [Functional Core/Imperative Shell](https://github.com/tim-hardcastle/Charm/blob/main/docs/functional-core-imperative-shell.md) pattern, in that the language is divided into commands (which have effects but don't return values) and functions (which return values but don't have effects).",0.1,shell
13iqrlm,,I'll go with the `:=` approach for the sake of example.,0.0,go
13iqrlm,,"Which leaves me with the idea of commands explicitly importing globals, as in `global x`, as in Python.",0.0,python
13iqrlm,,"I realize this is a much-hated feature of Python, and I don't have to imitate its semantics exactly, I could make it so you have to import a global both to set and to get it, if y'all think that that would be better.",0.25,python
13iqrlm,jkbio6c,">Within commands, it seemed like a good idea to have local variables created by assignment...  May I just point out that in perl, `use strict;` or go mad.",0.024999999999999984,perl
13iqrlm,jkbio6c,">Within commands, it seemed like a good idea to have local variables created by assignment...  May I just point out that in perl, `use strict;` or go mad.",0.024999999999999984,go
13iqrlm,jkbio6c,"Python sort of half-way gets away with it create-by-assign by requiring `global` or `nonlocal` statements to mutate these, but in practice declaring variables is the only way to stop typo-assignment.",0.0,python
13iqrlm,jkduqkb,"Scheme does this in hygienic macros, IIUC, and you can do it in Common Lisp with a macro like `with-gensym` or `with-unique-names`, using `[gensym](http://clhs.lisp.se/Body/f_gensym.htm)`.",-0.3,scheme
13iqrlm,jkduqkb,"Scheme does this in hygienic macros, IIUC, and you can do it in Common Lisp with a macro like `with-gensym` or `with-unique-names`, using `[gensym](http://clhs.lisp.se/Body/f_gensym.htm)`.",-0.3,lisp
13iqrlm,jkgbpaq,I'm not sure that variables are actually the best way to represent the imperative shell.,0.25,shell
13iqrlm,jkgbpaq,"One might, for example, think of the imperative shell as a state machine.",0.0,shell
13iqrlm,jkgbpaq,"Now what's cool about that is that you can make your state transitions *sort of* functional, in that they take in the state and return a new state.",0.24318181818181817,cool
13iqrlm,jkgbpaq,"My idea is to instead have sub-states, with their own sub-transitions (literally making up syntax as I go):           state TodoListItem {       transition complete() {         return {...this, done: true };       }     }          state Main {       /* ""List"" defines transitions like appending an item or setting an item at   an index */       todoList = [         TodoListItem { done: false, text: 'Take out the trash' },     TodoListItem { done: false, text: 'Buy ham, spam, and cheese' },     TodoListItem { done: true, text: 'Play Civilizations until the 2am' },       ];       mood = 'tired';            command completeToDoListItem(index) {         this.todoList[index].complete();         if(todoList.all(item => item.done)) {           this.setMood('satisfied');         }       }            transition setMood(newMood) {         return {...this, mood: newMood };       }     }  This is... messy, a bit, but I feel like with some more thought we could come up with a cleaner syntax.",0.10606060606060602,go
13iqrlm,jkhqzyf,"I'd suggest using dynamic variables, as are found in Common Lisp; all are declared ahead of use and globally, but their values can be overridden within a scope.",-0.09999999999999999,lisp
13iqrlm,jkhqzyf,For example:  ```lisp (defvar x) (defun f () x) (defun g ()   (let ((x 3))     (f))) (g); => 3```,0.0,lisp
13iqrlm,jki02d0,The problems with locals/globals go deeper than you've actually even approached in your post.,0.0,go
13i9k6f,,Just an example: In C you have unknown structs like this ``` #define T struct { int x; }  T a; a = (T) { .x = 1 }; ``` but this code does not compile.,-0.425,c
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,typescript
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,go
13i9k6f,jk9x0wb,"TypeScript's `type`s are structural, but its ~~interfaces~~ ~~classes~~ `enum`s are nominal, Carbon's `struct`s are structural while its `class`es are nominal, Go's `struct`s are nominal while its `interface`s are structural, Haskell's `type`s are structural while its `newtype`s are nominal.",0.0,haskell
13i9k6f,jkb7cgw,"Small correction, TypeScript's `interface` is still structural, [TS Playground example](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgAoHtRmQb2QDwC5kQBXAWwCNoAaZAT2LKumQF8BuAKC4BMIEAGzhQUCdCADO2GKRAJiACgAOmcMRxESFalDqNtLKOwCUyALwA+ZHIDWIdAHcQPcVOyqsxDFgu4uyATEAIw0AQzEAExhbDyy8ipqYCZcQA).",-0.25,typescript
13i9k6f,jk9yqp0,"TypeScript:      type A = { x: Number };     type B = { x: Number };      type Pointer<a> = { deref: a };      type Equals<a, b> =         a extends b ?",0.0,typescript
13i9k6f,jk9yqp0,"In fact if we go further with types-as-values systems like in Zig, then `Bool f<a>(x a, y a) = (x == y)` will return `true` both for `f(42, 42)` and `f(Pointer<A>, Pointer<B>)`.",-0.13333333333333333,go
13i9k6f,jka5z9v,"Since Javascript doesn't have value types, it would just be:      type A = { x: B };     type B = { x: A };",0.0,javascript
13i9k6f,jkaeub7,":D      type A = { x: B };     type B = { x: A };      type Equals<a, b> =         a extends b ?",1.0,d
13i9k6f,jkaeub7,"true : false) : false;      const x: Equals<A, B> = true;  > ""assume all types are identical""   > repeatedly break aliases until there are no more contradictions  I haven't yet thought how to implement that in my compiler (which should behave like TypeScript, but doesn't), but another approach is to concurrently analyse types and have each await on each other, then all deadlocks are due to cycles which you can iterate over to deduce equivalencies.",-0.08571428571428574,typescript
13i4nm0,jkqjm0w,"If you have something like the following (C#):      using (var x = new T())     {         for (int i=0;i<x.length;i++)          {             x[i] = f (i);         }     }  Then `x` cannot be `Unique` because it makes no guarantee about cleanup, which is required for `using () { }`.",0.17045454545454544,c
13i1mxv,jk8adef,I think continuation oriented languages are cool.,0.35,cool
13i1mxv,jkr5ppi,"Surprisingly, it seems that this ""direct manipulation"" or WYSIWYG style is mostly used for pure graphic design and CAD or 3D, whereas creators of webpages, arguably one of the biggest uses of programming technology, still mostly edit text files containing text-based CSS and HTML to compose the visual appearance, using cartesian coordinates, numeric dimension in units of pixels or mm  or relative percentages, etc.",0.2517857142857143,html
13i1mxv,jkr5ppi,"Maybe its because I used stuff like Hyper/SuperCard, THINK Pascal, MPW, and CodeWarrior back then.",0.0,pascal
13i1mxv,jkr5ppi,"At one point I tried using some Java IDEs, like Symantec VisualCafe, IntelliJ and Eclipse but IMO, these were bloated and slow compared to what I had used on much less powerful Mac computers a decade earlier.",-0.04166666666666667,java
13i1mxv,jkr5ppi,"Having learnt to program with Pascal and the other languages I mentioned, I very much prefer a keyword based representation to a parenthesis (curly braces) based.",0.0675,pascal
13i1mxv,jkr5ppi,"Back in the 60es, the designers of Algol had no scruples defining their language to use two different sets of alphabetic symbols.",0.0,algol
13i1mxv,jkr5ppi,"We see this in C, where ""typename"" requires special treatment, and where the existing codebase makes the policy of reserved words useless for language evolution, necessitating the return to stropping of keywords, like ""\_\_Generic"".",-0.07142857142857142,c
13i1mxv,jk7whsf,In Python those are 'grammaticalized' in the form of `with` blocks:  ```py with open( path ) as myfile:   myfile.write( text ) # file properly closed here even ICO error; variable myfile vanished ```,-0.05,python
13i1mxv,jk983nj,"Another is the `with` block of Pascal, which basically brings the fields of a record into the local scope.",0.0,pascal
13i1mxv,jk983nj,"Or the `with` block of Microsoft BASICs, which does something similar but requires a leading dot to disambiguate, which is probably an improvement over the Pascal approach.",0.0,pascal
13i1mxv,jkh4j8a,The creator of FLECS made a short article on how you could go from ECS as a pattern to ECS as a paradigm.,0.0,go
13i1mxv,jk9ewx0,It also seems to have a fairly direct analogy in Scala's implicit parameters.,0.1,scala
13i1mxv,jlcbfbl,&#x200B;  For the synchronization I'm probably gonna do atomic things - both with Rust's primitives and some custom ones like AtomicString and AtomicHashMap (although I'm not sure how well it will end up).,-0.25,rust
13i1mxv,jkoyx00,"I think 는 can be seen as a scoping operator, but it's more influential than `::` or `.` in C++ because it has larger scope itself.",0.25,c++
13hwld5,,The cool typing powers are explained at [https://sophie.readthedocs.io/en/latest/mechanics.html#functions-as-type-transformers](https://sophie.readthedocs.io/en/latest/mechanics.html#functions-as-type-transformers)  There's probably a name for this.,0.35,cool
13hwld5,jk7kcm1,"But Haskell does support such types if you use explicit type annotations, although perhaps the result is not as polymorphic as in your type system:      example :: (forall b.",-0.375,haskell
13hwld5,jk7u01y,"Once I give annotations teeth, if I needed to draw a line in the sand around `example` I might write this:      example(m:((number)->?a, list[number])->list[?a], ns:list[number]) : pair[list[number], list[string]] = ... ... ...;  Read the annotations a bit like a cross between Pascal and ML.",0.0,pascal
13hwld5,jk81j7h,This is essentially how C++'s templates work.,0.0,c++
13hwld5,jk81j7h,Rust).,0.0,rust
13hulvw,jk6yura,Rust uses a form of affine typing to handle variable lifetimes and borrowing.,0.0,rust
13hulvw,jk8xqjx,Isn't this the concept of ownership in rust?,0.0,rust
13hulvw,jku7fra,"Clean, ATS and Rust, IIRC.",0.3666666666666667,rust
13hulvw,jkmfis6,"And additionally, Rust also addresses this part of the OP  > In a dynamic language I could achieve this I guess by overwriting, x = f(x).",0.0,rust
13hulvw,jkmfis6,"But that won't work if I'm using static types  Rust allows code like this:      let x = f(x)  So even if the first `x` was not moved into `f` (it was either borrowed or copied), the shadowing the first `x` takes it out of scope.",0.3333333333333333,rust
13ht43r,jk7ak0j,"Instead, it generates textual assembly code and uses the system toolchain to assemble it into native code objects.",0.0,assembly
13ht43r,jk7ak0j,"Since LLVM is being linked in anyways for the LLVM backend, having the NCG generate MCInst values in memory would be faster than writing textual assembly to disk.",0.0,assembly
13ht43r,jk8ohmo,"> At a global scale   This is Haskell we're talking about, right?",0.14285714285714285,haskell
13hl8w0,,"There is some documentation on the Github page, so I won't go into too much detail here.",0.2,go
13hl8w0,jktzny8,":)   About the references, they still are inherently unsafe: ``` let x = 0; var r = &x; { let y = 1; r = &y; } // r is now dangling... ``` or ``` fn foo() -> &int { let x = 0; return &x; } ``` is also possible because in general this kind of problem is impossible to diagnose by a compiler.",0.09666666666666665,r
13hl8w0,jktzny8,"So yes, if I go for this idea your example should compile.",0.0,go
13hjah0,jk5pizl,"The simplest way to do this is to have a uniform representation for all your values, which is what many languages do, such as Java, ~C#,~ ¹ OCaml, and Haskell.",0.25,java
13hjah0,jk5pizl,"The simplest way to do this is to have a uniform representation for all your values, which is what many languages do, such as Java, ~C#,~ ¹ OCaml, and Haskell.",0.25,haskell
13hjah0,jk5pizl,"For languages like Java, ~C#,~ ¹ and Haskell, this is done by having all values be _boxed_ as pointers to their actual value; in Java, this is why you have to use `Integer` (a boxed pointer) instead of `int`.",0.0,java
13hjah0,jk5pizl,"For languages like Java, ~C#,~ ¹ and Haskell, this is done by having all values be _boxed_ as pointers to their actual value; in Java, this is why you have to use `Integer` (a boxed pointer) instead of `int`.",0.0,haskell
13hjah0,jk5pizl,"¹ Edit: Turns out C# doesn’t quite do that – it has value types as well as reference types, so it needs to do more",0.5,c
13hjah0,jk5jozp,"In c++, they duplicate those definitions and then dedup the at link-time",0.0,c++
13hjah0,jk7b96f,"Compile a variant of the generic thing for every substitution (like in C++, or JIT in C#).",0.0,c++
13hjah0,jk7b96f,"Compile a variant of the generic thing for every substitution (like in C++, or JIT in C#).",0.0,c
13hjah0,jk7b96f,That's what Java does.,0.0,java
13hjah0,jk716h1,"In any case, you won't go wrong to look at how C++ does it.",-0.5,go
13hjah0,jk716h1,"In any case, you won't go wrong to look at how C++ does it.",-0.5,c++
13hjah0,jk9btwj,"Here you can read *in-depth* how is done in Swift:   Compiling Swift Generics     https://forums.swift.org/t/compiling-swift-generics-part-i/60898     https://download.swift.org/docs/assets/generics.pdf",0.0,swift
13hjah0,jk6r5ao,"Nim is a nice language to study for that as it has generics and compiles through C so you can easily inspect the ""intermediate language"".",0.5166666666666666,c
13hjah0,jk6zpqn,C++ is an example of a language that does this through the template feature.,0.0,c++
13hjah0,jk6zpqn,"Java, on the other hand, does not - instead it boxes all objects, and the same byte code is used for all instantiations of a generic function (and a generic class too).",-0.03125,java
13hjah0,jk5zv5f,Perhaps for something like java it makes sense but I'm looking for something a bit more performant.,0.5,java
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,java
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,c
13hjah0,jkaeeow,">For languages like Java, C#, and Haskell, this is done by having all values be *boxed* as pointers to their actual value  Small objection: This is *not* what C# does.",-0.125,haskell
13hjah0,jkaeeow,In C# you can use both value types and reference types as generics type parameters.,0.0,c
13hjah0,jkaeeow,"Java only supports reference types as type parameters, because of *type erasure*.",0.0,java
13hjah0,jkaeeow,The Java VM does not know about generics and musty treat all generic type parameters the same.,0.0,java
13hjah0,jkaeeow,C# generates one shared realization of a generic for *reference types* (like Java) and in addition to that one realization per unique size of value types used to realize the generic (unlike Java).,0.125,c
13hjah0,jkaeeow,C# generates one shared realization of a generic for *reference types* (like Java) and in addition to that one realization per unique size of value types used to realize the generic (unlike Java).,0.125,java
13hjah0,jk7n1j3,"I might compile all the way down (in my final compiler, rn I'm compiling to C) to machine code but include a bit more information so that a custom ""pre-linker"" could sort all that out.",0.11481481481481481,c
13hjah0,jk7lo00,"I'm currently compiling down to C, and it would be interesting to see how nim does things yeah.",0.11481481481481481,c
13hjah0,jk5d3xr,"An example in c++ would be:      template <typename T>     T add(T a, T b) {         return a + b;     }",0.0,c++
13hjah0,jk616jm,"Rust and C++ solve it, so you can too :-)",0.5,rust
13hjah0,jk616jm,"Rust and C++ solve it, so you can too :-)",0.5,c++
13hjah0,jkaeor2,I didn’t realize C#’s value types were so well-integrated into the language,0.0,c
13hjah0,jk5l1k7,"I'm not sure how it works, but maybe   Look up how the ""inline"" specifier in C++ is implemented   (it has nothing to do with inlining function calls.",-0.25,c++
13hjah0,jk8pzi2,"For user defined struct, you could use something like Go interfaces :  https://research.swtch.com/interfaces",0.0,go
13hjah0,jk7ph8q,"I'm currently compiling down to C, and it would be interesting to see how nim does things yeah.",0.11481481481481481,c
13hjah0,jk63c9o,"yep you're right, looking into how rust and c++ solve it is a good idea",0.4928571428571428,rust
13hjah0,jk63c9o,"yep you're right, looking into how rust and c++ solve it is a good idea",0.4928571428571428,c++
13hjah0,jkcnnc8,"I wouldn't call what C++ and Rust do ""solving"".",0.0,c++
13hjah0,jkcnnc8,"I wouldn't call what C++ and Rust do ""solving"".",0.0,rust
13hjah0,jk7usui,"Well, you compile a Nim program with that setup and look at the C files, that's what is happening.",0.0,c
13gt1ib,,"I'm thinking something along the lines of Rust Game Dev, where you can share your progress and get feedback from a community beyond just Reddit and Discord.",-0.4,rust
13g4r5d,jjyx0ui,"Most times after learning the language basics and probably working through a couple of books and some coding problems, so I feel like I'm starting to get a sense for idiomatic use of the language, I'll write a Lisp interpreter (writing the reader from scratch, no parsing libraries).",0.25,lisp
13g06id,,"The language doesn't have to be JavaScript, I can read code in a lot of languages.",0.0,javascript
13fm2q5,jjxesit,Purely syntactical unification is at least predictable: `a+b+c` (understood as `(a+b)+c`) unifies with `n+m` if `a+b` unifies with `n` and `c` unifies with `m.,-0.09523809523809523,c
13fm2q5,jjxh8qx,"So then, would something like `a+b+c+d+e ~~ l+n+m` generate a unifier `l -> a+b+c; n -> d; m -> e`?",0.0,d
13fm2q5,jjxhvlq,Unification is currently entirely syntactic - just as if you encoded arithmetic at the type level in Standard ML or Haskell.,0.0,haskell
13fm2q5,jjz6yfl,"So then, would something like a+b+c+d+e ~~ l+n+m generate a unifier l -> a+b+c; n -> d; m -> e?",0.0,d
13fa1lc,jjua2r7,"The related function for multiple transforms is usually called [`zip`](https://en.wikipedia.org/wiki/Zipping_(computer_science\)) (or `zipWith`), which lifts `a -> b -> c` into `F a -> F b -> F c`, and it is typical for languages to have a `zip3`/`zipWith3` which lifts `a -> b -> c -> d` to `F a -> F b -> F c -> F d`, and so forth.",-0.10416666666666666,c
13fa1lc,jjua2r7,"The related function for multiple transforms is usually called [`zip`](https://en.wikipedia.org/wiki/Zipping_(computer_science\)) (or `zipWith`), which lifts `a -> b -> c` into `F a -> F b -> F c`, and it is typical for languages to have a `zip3`/`zipWith3` which lifts `a -> b -> c -> d` to `F a -> F b -> F c -> F d`, and so forth.",-0.10416666666666666,d
13fa1lc,jjua2r7,"The related function for multiple transforms is usually called [`zip`](https://en.wikipedia.org/wiki/Zipping_(computer_science\)) (or `zipWith`), which lifts `a -> b -> c` into `F a -> F b -> F c`, and it is typical for languages to have a `zip3`/`zipWith3` which lifts `a -> b -> c -> d` to `F a -> F b -> F c -> F d`, and so forth.",-0.10416666666666666,forth
13fa1lc,jjua2r7,"A related approach is to just say:      repeat (,,) `zapply` [a,b,c,d] `zapply` [1,2,3,4] `zapply` [x,y,z,w]          where zapply = zipWith ($)  Here is another implementation of [`ZipWithN`](https://web.archive.org/web/20161013215858/https://community.haskell.org/~wren/wren-extras/src/Data/List/ZipWithN.hs) which uses this approach but with a typeclass and functional dependency.",0.0,c
13fa1lc,jjua2r7,"A related approach is to just say:      repeat (,,) `zapply` [a,b,c,d] `zapply` [1,2,3,4] `zapply` [x,y,z,w]          where zapply = zipWith ($)  Here is another implementation of [`ZipWithN`](https://web.archive.org/web/20161013215858/https://community.haskell.org/~wren/wren-extras/src/Data/List/ZipWithN.hs) which uses this approach but with a typeclass and functional dependency.",0.0,d
13fa1lc,jjvs8vk,"In the REPL:  ```scheme > (map (λ (x y z) (* x (+ y z)))        (list 1 2 3)        (list 4 5 6)        (list 7 8 9)) '(11 26 45) ```  That said, of course Racket is untyped, and I'm not quite sure how I would encode this type in the type systems I know well!",0.625,scheme
13eztdp,,C was great for my toy JIT but I don't want to rewrite expression trees in it.,0.8,c
13eztdp,,I'd like my compiler's source code to be as small and simple as possible so Rust seems out because of the borrow checker and lack of pattern matching over RC'd trees and lack of tracing GC.,-0.08333333333333333,rust
13eztdp,,Has anyone tried Swift for this?,0.0,swift
13eztdp,jjsmdzy,"Common Lisp is my first choice, Racket the second one, and RAKU (perl6;)) the third one.",0.04,lisp
13eztdp,jjsmdzy,You will find Common Lisp (and the other LISPs) extremely well suited for this job :),-0.012500000000000011,lisp
13eztdp,jjswrj0,I personally like using D for this stuff.,0.0,d
13eztdp,jjswrj0,It's quite fast and has garbage collection and decent support for calling C code.,0.18333333333333335,c
13eztdp,jjsq48a,"Prolog is a good choice for writing compilers: It has a built-in grammar mechanism (definite clause grammars, DCGs), and great support for reasoning about ASTs symbolically via a generalization of pattern matching.",0.5,prolog
13eztdp,jjsq48a,"A compiler can be expressed in Prolog as a *relation* between source code and target code, possibly involving intermediate steps.",0.0,prolog
13eztdp,jjsq48a,"Prolog is ideally suited for reasoning about terms, and can therefore also be easily used to implement term rewriting languages, again as relations between source and target terms.",0.6666666666666667,prolog
13eztdp,jjst8we,Haskell.,0.0,haskell
13eztdp,jjwa9ap,"A Lisp or ML-family language might still be a good choice, for the reasons I listed above, but don't choose a Lisp or ML-family language because it's good at parsing if you're going to be struggling with all the actually hard parts of writing a compiler because of that choice.",0.2770833333333333,lisp
13eztdp,jjwa9ap,It's cool.,0.35,cool
13eztdp,jjt1e5i,Another vote for Rust but you'll have to be prepared to learn the language first before trying to dive into a compiler.,0.25,rust
13eztdp,jjshes3,"Common Lisp and Coalton, if you like high-performance, bleeding edge tech.",-0.3,lisp
13eztdp,jjv8s69,"Rust or Haskell, or any language that supports algebraic data type with pattern matching.",0.0,rust
13eztdp,jjv8s69,"Rust or Haskell, or any language that supports algebraic data type with pattern matching.",0.0,haskell
13eztdp,jju6i3c,"And full interop with C#, if that matters at all.",0.35,c
13eztdp,jjubtn4,"In my case I found C to have been completely perfect for my needs, but you have already tried that so I won’t recommend it.",1.0,c
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,c
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,c++
13eztdp,jjubtn4,So anything with good FFI either to C or to C++ is the way to go.,0.7,go
13eztdp,jjubtn4,"D, Swift, Nim seem to fit the bill, but ultimately you probably want a language you feel comfortable in.",0.26666666666666666,d
13eztdp,jjubtn4,"D, Swift, Nim seem to fit the bill, but ultimately you probably want a language you feel comfortable in.",0.26666666666666666,swift
13eztdp,jjubtn4,"To me C is very nice with sufficient abstractions for my needs, and I’m comfortable with it.",0.5900000000000001,c
13eztdp,jjubtn4,For someone else C is unthinkable.,-0.05,c
13eztdp,jjubtn4,"So see what is sustainable for you in terms of familiarity and FFI, and go with that.",0.0,go
13eztdp,jjubtn4,"That said, if you had problems using C, then it might be worth looking at codebases which implement in C or C-ish C++ to see how they get around those issues.",0.3,c
13eztdp,jjubtn4,"That said, if you had problems using C, then it might be worth looking at codebases which implement in C or C-ish C++ to see how they get around those issues.",0.3,c++
13eztdp,jjuwxkg,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important - except when implementing an interpreter that needs to implement specific integer sizes or make use of the C math library.",0.3464285714285714,haskell
13eztdp,jjuwxkg,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important - except when implementing an interpreter that needs to implement specific integer sizes or make use of the C math library.",0.3464285714285714,c
13eztdp,jjtmbpo,My compiler is in C++ but the prototype that I made the most progress the quickest was in C# (before it became very slow).,0.054999999999999966,c++
13eztdp,jjtmbpo,My compiler is in C++ but the prototype that I made the most progress the quickest was in C# (before it became very slow).,0.054999999999999966,c
13eztdp,jjvdxqe,If you're already used to OCaml I would suggest Haskell as an alternative that solves your two pain points (full width ints and FFI).,0.35,haskell
13eztdp,jjvykbg,Personally I prefer C++ in a moderate style which compiles on any C++98 or C++11 compiler over everything else I've tried.,0.0,c++
13eztdp,jjvykbg,"C works up to a certain complexity, and the fancy languages (including modern modern C++) cause too much dependability.",0.20357142857142857,c
13eztdp,jjvykbg,"C works up to a certain complexity, and the fancy languages (including modern modern C++) cause too much dependability.",0.20357142857142857,c++
13eztdp,jjvykbg,"In terms of C++ library support I solved the dependability, capability and complexity issues by providing LeanQt which is very powerful but still modest and easily integratable.",0.30777777777777776,c++
13eztdp,jjsqi0c,Rust is the closest to oCaml which is also low-level.,0.0,rust
13eztdp,jjsqi0c,> I'd like my compiler's source code to be as small and simple as possible so Rust seems out because of the borrow checker and lack of pattern matching over RC'd trees and lack of tracing GC.,-0.08333333333333333,rust
13eztdp,jjsqi0c,You can make things go simple:  https://stopa.io/post/222  Your wording suggests you need to learn basic stuff.,0.0,go
13eztdp,jjsqi0c,"It sounds puzzling, I start learning Rust with https://tablam.org and probably was making my life harder trying to do ""advanced"" stuff when not **have any idea of what I was doing**.",0.15000000000000002,rust
13eztdp,jjsqi0c,If wanna persist go to the rust reddit and ask questions!,0.0,go
13eztdp,jjsqi0c,If wanna persist go to the rust reddit and ask questions!,0.0,rust
13eztdp,jjsqi0c,---  Swift is fine.,0.4166666666666667,swift
13eztdp,jjsqi0c,"My first prototype was on python, then I move to Swift.",0.25,python
13eztdp,jjsqi0c,"My first prototype was on python, then I move to Swift.",0.25,swift
13eztdp,jjsqi0c,"I then later move to Rust because swift support outside the Apple ecosystem is too poor, but is a good way to just test the water if wanna.",0.07499999999999998,rust
13eztdp,jjsqi0c,"I then later move to Rust because swift support outside the Apple ecosystem is too poor, but is a good way to just test the water if wanna.",0.07499999999999998,swift
13eztdp,jjtati5,Swift is fine.,0.4166666666666667,swift
13eztdp,jjugujz,"Well, I have written [the first compiler for my programming language](https://flatassembler.github.io/compiler), targetting x86, in IE6-compatible JavaScript, and [the second compiler](https://github.com/FlatAssembler/AECforWebAssembly.git), targetting WebAssembly, has been written in C++11.",0.125,javascript
13eztdp,jjugujz,"Because, when outputting assembly, you are going to need those two things a lot.",0.0,assembly
13eztdp,jjv9vg4,I've written a compiler in Rust without much issues with borrowchecker.,0.2,rust
13eztdp,jjx6y45,Go.,0.0,go
13eztdp,jjx6y45,"Wrote a compiler in C before, and while I enjoyed it at the time, I don't think I'll ever do that again.",0.5,c
13eztdp,jjykjur,I'd say take a stab at Julia; (I'm an idiot!,-1.0,julia
13eztdp,jjv198j,Try Julia with LLVM.,0.0,julia
13eztdp,jjwpr7a,Haven’t done it myself but I’ve heard a lot of good things about Haskell in this regard.,0.7,haskell
13eztdp,jjwpr7a,Actually got a summer job where they’ve built a whole compiler in Haskell.,0.1,haskell
13eztdp,jjwpr7a,I saw this one guy also made a compact lil parser in less than 80 lines in Haskell.,-0.16666666666666666,haskell
13eztdp,jjxkyr0,JavaScript.,0.0,javascript
13eztdp,jjzoyno,Looks like a really cool project and is mature enough at this point to use in projects like this and more.,0.2375,cool
13eztdp,jjzoyno,"* **Haskell**: If you're up for a drastically different programming language experience that, if strangers' opinions on the internet (including mine) is anything to go on, will make you a better programmer even when using other languages, then give this beauty a go.",0.125,haskell
13eztdp,jjzoyno,"* **Haskell**: If you're up for a drastically different programming language experience that, if strangers' opinions on the internet (including mine) is anything to go on, will make you a better programmer even when using other languages, then give this beauty a go.",0.125,go
13eztdp,jjzoyno,"Here's an example compiler written in Haskell for a statically-typed, non-GCed, performance-oriented Lisp+Rust-inspired Lisp:  [https://github.com/carp-lang/Carp](https://github.com/carp-lang/Carp)",-0.75,haskell
13eztdp,jjzoyno,"Here's an example compiler written in Haskell for a statically-typed, non-GCed, performance-oriented Lisp+Rust-inspired Lisp:  [https://github.com/carp-lang/Carp](https://github.com/carp-lang/Carp)",-0.75,lisp
13eztdp,jjuigvm,I can suggest Clojure.,0.0,clojure
13eztdp,jjt9wpy,"If you like Prolog, you might want to try Mercury.",0.0,prolog
13eztdp,jjt9wpy,"It's Prolog, but with strong types, strong modes and strong determinism.",0.4333333333333333,prolog
13eztdp,jjtx8al,"Did you ever really try to do a decompiler that way, or you are just discussing a theoretical possibility of having a decompiler as a different way of running Prolog predicates?",0.06666666666666667,prolog
13eztdp,jjt9m3d,I would suggest to give Haskell a try as it is really easy to make parser combinator in Haskell.,0.43333333333333335,haskell
13eztdp,jjt9m3d,Haskell also have a LLVM binding if you are doing some kind of compiled languages.,0.6,haskell
13eztdp,jjwz2s4,"You can write a C compiler in Python, https://web.archive.org/web/20150126174629/http://people.cs.uchicago.edu:80/~varmaa/mini_c/",0.0,c
13eztdp,jjwz2s4,"You can write a C compiler in Python, https://web.archive.org/web/20150126174629/http://people.cs.uchicago.edu:80/~varmaa/mini_c/",0.0,python
13eztdp,jjta9td,I have written a medium size toy language in rust and I sometimes feels borrow checker adds a lot of unnecessary complexity compared to do things in a purely functional language where you completely ignore all memory problems.,-0.02857142857142858,rust
13eztdp,jk8nuvi,I too use C++,0.0,c++
13eztdp,jjvkbsx,"I use Haskell for my compiler, which has a good FFI and full-width integers (if you use the right type), but I can't think of any cases where this was particularly important  I don't understand all these arguments against full-width integers, *especially* regarding compilers.",0.3464285714285714,haskell
13eztdp,jjvr9rq,I'm developing on Aarch64 and targeting only Aarch64 so if MLton's support for Aarch64 is flaky them I'm in trouble from the get go.,-0.1,go
13eztdp,jjvr9rq,"My language supports (only) 64-bit ints and floats so I'm doing lots of rearrangements and calculations on them for optimisation passes:      0+n | n+0 → n     0×n | n×0 → 0     1×n | n×1 → n     2×n | n×2 → n+n     2ⁿ×p | p×2ⁿ → p<<n     p/2ⁿ → p>>n     a×b+c | c+a×b → madd(a, b, c)  The FFI is needed mostly for the JIT, to do the OS calls to get and populate executable memory and to flush CPU caches and so on.",0.25,c
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,go
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,c
13eztdp,jjvmnsk,> You can make things go simple: > > https://stopa.io/post/222  That looks like 50 lines of OCaml or 100 lines of C in 500 lines of Rust.,0.25,rust
13eztdp,jjzrah3,"> Well, I have written the first compiler for my programming language, targetting x86, in IE6-compatible JavaScript, and the second compiler, targetting WebAssembly, has been written in C++11.",0.125,javascript
13eztdp,jjzrah3,Very cool!,0.56875,cool
13eztdp,jjt1le8,"If they've already eliminated C and Rust for lack of abstraction, they're definitely not going to want to use Odin.",0.0,c
13eztdp,jjt1le8,"If they've already eliminated C and Rust for lack of abstraction, they're definitely not going to want to use Odin.",0.0,rust
13eztdp,jjsoz3p,"I wrote my first compiler in C, and at my work we use C++ (although I’m not on the compiler team myself).",0.25,c
13eztdp,jjsoz3p,"I wrote my first compiler in C, and at my work we use C++ (although I’m not on the compiler team myself).",0.25,c++
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,c
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,c++
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,d
13eztdp,jjsoz3p,"I think C or C++ are great choices, although realistically I’d probably go with C++",0.8,go
13eztdp,jjuiyrc,"Well.. every LISP program is a list, not only the clojure ones, that's why LISP dialects are called ""reflective"" and are homoiconic",0.0,lisp
13eztdp,jjuiyrc,"Well.. every LISP program is a list, not only the clojure ones, that's why LISP dialects are called ""reflective"" and are homoiconic",0.0,clojure
13eztdp,jjthcw3,My JIT in C is easy because I can just call anything but if I used OCaml it would be painful having to wrap everything in stubs.,-0.1333333333333333,c
13eztdp,jjtt42v,"I found the docs incomplete/arcane, does it require knowing prolog?",0.0,prolog
13eztdp,jju9pd8,"In addition to this specific extreme (and maybe indeed unattainable) benefit, there are other, in a sense ""less general"", benefits we automatically get from describing a parser and compiler as relations in a logic programming language, including:  - being able to easily search whether the grammar is ambiguous by *asking* the Prolog system for strings that correspond to multiple tokenizations or ASTs - being able to easily express *test cases* as queries that relate (ground or partial) source programs to intended (ground or partial) target programs and must succeed or fail.",0.06153846153846154,prolog
13eztdp,jju9pd8,"For instance, we can relate a source program to a sequence of assembly instructions where jump targets are logic variables, to be filled later, when more becomes known about the layout of the target program in later stages of the compilation.",0.225,assembly
13eztdp,jju9pd8,"These advantages are much easier to achieve, and in fact typical properties of compilers that are written in Prolog.",0.016666666666666677,prolog
13eztdp,jjuuexf,"I would expect that if you're writing rust in a pure, functional style that the borrow checker will not give you grief.",-0.29285714285714287,rust
13eztdp,jjujzn2,I recently got a glimpse into a commercial compiler written in Rust.,0.0,rust
13eztdp,jjwa66w,That's why I put in a disclaimer to really have to learn the language first since that's where the majority of your energy will go.,0.225,go
13eztdp,jjwa66w,I'd rather someone use something else they find easier than stick it out with Rust being miserable.,-1.0,rust
13eztdp,jjvqu4h,"As for slow compile and startup times, that's not generally a complain I hear about C#/F#, but perhaps your case is unique.",0.016666666666666646,c
13eztdp,jkf5d4m,"(un)fortunately a lot of the startup times are due to general dotnet/msbuild startup times on top of the F# compiler, and you can get a much more responsive workflow using F# interactive using #load for files and #r for packages.",0.23125,r
13eztdp,jjvsgak,I do use Haskell's appropriately sized integer types to express these in my AST.,0.5,haskell
13eztdp,jjvs0hp,> I'm developing on Aarch64 and targeting only Aarch64 so if MLton's support for Aarch64 is flaky them I'm in trouble from the get go.,-0.1,go
13eztdp,jjwg9tb,Floats have a -0.0 and this leads to (see also [isNegativeZero](https://seed7.sourceforge.net/libraries/float.htm#isNegativeZero(in_float))):      isNegativeZero(0.0 * -1.0)  --> TRUE     isNegativeZero(-0.0 * 1.0)  --> TRUE     isNegativeZero(0.0 * 1.0)   --> FALSE     isNegativeZero(-0.0 * -1.0) --> FALSE  Floats have also [Infinity](https://seed7.sourceforge.net/libraries/float.htm#Infinity) and this leads to (see also [isNaN](https://seed7.sourceforge.net/libraries/float.htm#isNaN(in_float))):      0.0 * Infinity --> NaN     Infinity * 0.0 --> NaN     0.0 * NaN      --> NaN     NaN * 0.0      --> NaN  The Seed7 compiler leaves such float optimizations to the C compiler.,-0.02000000000000004,c
13eztdp,jk03bo0,Many people say Haskell is an exceptionally good language to write a compiler in.,0.6,haskell
13eztdp,jk03bo0,"If you are not intimately familiar with Haskell, you probably shouldn't try to build a compiler in it.",-0.1875,haskell
13eztdp,jjthbi9,"I’m my experience, I’d rewrite everything I’ve ever done in C/C++ using Odin.",0.0,d
13eztdp,jjxqdip,There are a lot of things about JavaScript that I actually really like.,0.2,javascript
13eztdp,jjxqdip,"I won't go as far as Douglas Crockford in some of the details, but I agree with him that there's a fantastic programming language lurking inside of JavaScript.",0.25,go
13eztdp,jjxqdip,"I won't go as far as Douglas Crockford in some of the details, but I agree with him that there's a fantastic programming language lurking inside of JavaScript.",0.25,javascript
13eztdp,jjujs6q,"Oh, do not go into this rabbit hole.",0.0,go
13eztdp,jjujs6q,"The suggestion was based on my practical experiences on in other LISP dialects, Clojure has a unique position, IMHO.",0.125,lisp
13eztdp,jjujs6q,"The suggestion was based on my practical experiences on in other LISP dialects, Clojure has a unique position, IMHO.",0.125,clojure
13eztdp,jju1lfi,"It doesn't require knowing Prolog, but given that there are far more Prolog tutorials around, you'll probably have an easier time of it.",0.3,prolog
13eztdp,jju1lfi,Erlang might be good enough too.,0.35,erlang
13eztdp,jk4whxl,For a larger compiler in Python look at  https://github.com/windelbouwman/ppci,0.0,python
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,rust
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,haskell
13eztdp,jjuy2dc,Closures (Fn*) in Rust are just too complicated and you don't really get the ergonomics like you do in Haskell or Scala.,-0.016666666666666663,scala
13eztdp,jjuy2dc,"Strictly speaking, it's not Rust's fault, but more like an inherent complexity that comes with the lack of powerful GC.",0.4,rust
13eztdp,jjv4nzi,It is almost impossible to do any advanced functional thing due to rust’s type system.,-0.13055555555555554,rust
13eztdp,jjv4nzi,"Unless you wrap everything in Rc, doing functional style is a huge pain in rust.",0.4000000000000001,rust
13eztdp,jjwfngy,"I would expect that if you're writing rust in a pure, functional style that the borrow checker will not give you grief.",-0.29285714285714287,rust
13eztdp,jjwfngy,Functional style is pathological for Rust.,0.0,rust
13eztdp,jjwfngy,"Rust is really an imperative language, IMHO.",0.2,rust
13eztdp,jjukdw6,This is a common trick but the problems is rust do boundary check every time you access an element.,-0.3,rust
13eztdp,jjv6p4e,"For example, I want to do:      add(mul(a, b), c) -> madd(a, b, c)  but Rust cannot match the inner `mul` if you have to go through an `Rc`.",0.0,c
13eztdp,jjv6p4e,"For example, I want to do:      add(mul(a, b), c) -> madd(a, b, c)  but Rust cannot match the inner `mul` if you have to go through an `Rc`.",0.0,rust
13eztdp,jjv6p4e,"For example, I want to do:      add(mul(a, b), c) -> madd(a, b, c)  but Rust cannot match the inner `mul` if you have to go through an `Rc`.",0.0,go
13eztdp,jjtni54,"Ah cool, didn't know that!",0.4375,cool
13eztdp,jkfrvw7,"> you can get a much more responsive workflow using F# interactive using #load for files and #r for packages  That's a great tip, thanks.",0.5,r
13eztdp,jjulxjj,"It's not to start a debate about which is better or worse, but could you explain what is unique about Clojure about writing compilers and/or interprerers compared to other dialects like CL or Racket?",0.0875,clojure
13eztdp,jjv6u4g,"> Unless you wrap everything in Rc, doing functional style is a huge pain in rust.",0.4000000000000001,rust
13eztdp,jjv6u4g,Even if you wrap everything in `Rc` Rust is painful because tail calls leak not only stack but everything tied to the scope.,-0.35,rust
13etpti,,"I tried to design a lifetimes system both convenient and efficient, inspired by C++, Nim and Vale.",0.0,c++
13etpti,,"# Constructors  An automatic constructor allows to define a default value and to put the variable in a valid state, but does not cover all the C++ constructors use cases.",0.0,c++
13etpti,,"I don’t like exceptions but it may be useful to have a different behavior when an exception is thrown (for example, to have a [D’s scope guards](https://tour.dlang.org/tour/en/gems/scope-guards) equivalent, to solve [the obvious final step](https://akrzemi1.wordpress.com/2023/04/23/the-obvious-final-step/) or to make them compatible with [Vale’s higher RAII](https://verdagon.dev/blog/higher-raii-7drl)).",0.11000000000000001,d
13etpti,jk2u36g,C++ kinda does too when your compiler elides calls to destructors on moved objects.,0.0,c++
13etpti,jjtmj17,I can't believe you mentioned lifetimes but not Rust!,0.0,rust
13etpti,jjtmj17,"Ok, Rust-style lifetimes aren't relevant here, but Rust does track whether variables live or not with a two-state system: either they're fully initialized, in which case they can be used in expressions and they need their destructors called, or they're uninitialized and can't be used in expressions and won't have their destructors called.",0.34545454545454546,rust
13etpti,jjtmj17,Assignment and moves are always just a bitwise copy in Rust so they don't create any new cases.,0.13636363636363635,rust
13etpti,jk5pkdy,"Looks like ""C++ but different"".",0.0,c++
13etpti,jk5pkdy,I have never read about C++ destructor elision before.,0.0,c++
13etpti,jjv21o0,Very nice explanation about Rust.,0.78,rust
13etpti,jjv21o0,"I am not Rust programmer but since,  I am doing ownership check in C I need at least compare against Rust.",-0.3,rust
13etpti,jjv21o0,"I am not Rust programmer but since,  I am doing ownership check in C I need at least compare against Rust.",-0.3,c
13etpti,jjv21o0,"As you said, rust may insert code to track the state at runtime.",0.0,rust
13etpti,jjv21o0,"``` p1 <==  p2; ``` to distinguish this operation from copy ``` p1 = p2; ``` (How to avoid move in rust, since the same operator = is used?)",0.0,rust
13etpti,jjv21o0,The perfect solution for C should be able to track this without adding any extra runtime state.,0.5,c
13etpti,jjv21o0,```c int * p = malloc(..); free(p); ```,0.0,c
13etpti,jjuvwz6,"Rust handles construction/copies/moves/destruction nicely, I particulary like that it has destructive moves (through it has *only* destructive moves), however it’s prohibition of shared mutability makes it cumbersome.",-0.15,rust
13etpti,jk5rfa9,> I have never read about C++ destructor elision before.,0.0,c++
13etpti,jjwtluc,"> As you said, rust may insert code to track the state at runtime.",0.0,rust
13etpti,jjwtluc,Rust avoids it except in really weird cases where a variable is initialized in one code path and left uninitialized in another.,-0.25,rust
13etpti,jjwtluc,"> (How to avoid move in rust, since the same operator = is used?)",0.0,rust
13etpti,jjw0nzi,"I’d say it’s [I saw [the man [on the [hill with the telescope]]]], for other meanings there is less ambiguous word orders.",-0.14583333333333331,d
13etpti,jjwvc1c,Can you help me to translate this C sample to Rust?,0.0,c
13etpti,jjwvc1c,Can you help me to translate this C sample to Rust?,0.0,rust
13etpti,jjwvc1c,``` int * p1 = malloc(..); int p2 = 0; p2 = p1; /*p2 is just a non-owner pointer to p1*/ free(p1); ```  I understand in rust p1 is moved to p2.,0.0,rust
13etpti,jjx69cv,This cannot happen in safe Rust.,0.5,rust
13etpti,jjyfo1p,"Yeah, there's no equivalent of malloc in idiomatic Rust code.",0.0,rust
13eo3pa,jjrp61r,If you look at the Haskell type `(<*>) :: (Applicative f) => f (a -> b) -> (f a -> f b)` it can be seen as distributing the functor type `f` over the function type `(->)`.,-0.175,haskell
13eo3pa,jjrp61r,Python’s `f(*xs)`) then you can construct `liftAn` for arbitrary/inferable `n`.,0.0,python
13eo3pa,jjrp61r,"In general, they can be partially applied to arguments in any order, but in the slightly simpler case that you don’t allow that, they would let you treat an uncurried type `(a, b, c) -> d` as if it were curried `a --> b --> c --> d`; whereas they also ensure that the function will be fully applied at some point locally (which is _almost always_ the case with applicatives in typical Haskell code) or explicitly boxed into a closure.",-0.07666666666666666,c
13eo3pa,jjrp61r,"In general, they can be partially applied to arguments in any order, but in the slightly simpler case that you don’t allow that, they would let you treat an uncurried type `(a, b, c) -> d` as if it were curried `a --> b --> c --> d`; whereas they also ensure that the function will be fully applied at some point locally (which is _almost always_ the case with applicatives in typical Haskell code) or explicitly boxed into a closure.",-0.07666666666666666,d
13eo3pa,jjrp61r,"In general, they can be partially applied to arguments in any order, but in the slightly simpler case that you don’t allow that, they would let you treat an uncurried type `(a, b, c) -> d` as if it were curried `a --> b --> c --> d`; whereas they also ensure that the function will be fully applied at some point locally (which is _almost always_ the case with applicatives in typical Haskell code) or explicitly boxed into a closure.",-0.07666666666666666,haskell
13eo3pa,jjrhcqb,"I don't know much about your language -- if it's dynamically typed, you could make some sort of `Decode.mapMany` that takes varargs, reduces with the (binary) `<*>` to get a list of arguments with the Applicative wrapper (read: `sequenceA`), then map spread-apply on your original function  if it's not dynamically typed, you might still be able to encode this, but it involves talking about mapping over the types in a heterogeneous (argument) list (or just casting to the top type = whatever the ""supertype of everything"" is, but that's no fun :p)  not sure I explained this very well, but I'm happy to rephrase if you could tell me which languages you're familiar with (I'd guess Elm?)",0.33636363636363636,elm
13eo3pa,jjslho3,"I'm literally typing this while watching a talk about Applicative in C++, a language without automatic currying.",0.4,c++
13eo3pa,jjslho3,"Implement manual currying, which is possible in C++.",0.0,c++
13eo3pa,jjt2ubv,How cool would be to have Regular Expression Types!,0.175,cool
13eo3pa,jjt2ubv,a b c -> d e  Is the type of a function that takes 3 arguments from stack and pushes 2 a [ a-> b] -> b  Is the type of a function that takes a and a closure from a to b and returns b a* a -> a Is the type of a function that takes at least on a and returns a List<\x>+ [ \x -> y] -> List<y> Would be the type of general map It takes a at least one list of type x_1 and a closure that goes from x_i to y and returns a list of ys  I've been toying with the idea but never got around to implement it,-0.18333333333333332,c
13eo3pa,jjt2ubv,a b c -> d e  Is the type of a function that takes 3 arguments from stack and pushes 2 a [ a-> b] -> b  Is the type of a function that takes a and a closure from a to b and returns b a* a -> a Is the type of a function that takes at least on a and returns a List<\x>+ [ \x -> y] -> List<y> Would be the type of general map It takes a at least one list of type x_1 and a closure that goes from x_i to y and returns a list of ys  I've been toying with the idea but never got around to implement it,-0.18333333333333332,d
13eo3pa,jjrjd77,"Elm indeed is where I got the idea ""I need this functionality"" from, but it automatically curries so it doesn't have the issue with peeling off one argument at a time.",0.0,elm
13eo3pa,jjrjd77,I think I'll be fine with Haskell analogies as well if you want to explain using that.,0.4166666666666667,haskell
13eo3pa,jjrowkr,"sure -- essentially, what I'm trying to construct is a function from `(a, b, c, ...) -> r` to `(f a, f b, f c, ...) -> f r`.",0.25,c
13eo3pa,jjrowkr,"sure -- essentially, what I'm trying to construct is a function from `(a, b, c, ...) -> r` to `(f a, f b, f c, ...) -> f r`.",0.25,r
13eo3pa,jjrowkr,"to encode this as a type, you first need to be able to talk about ""the list of arguments to a function"" as a unit on their own, instead of one at a time -- this is sort of like a ""list of types"", one element for each argument  if you'll bear with me and pretend that this syntax `(a, b, ...) -> r` is syntax sugar for something like `Fn [a, b, ...] r`, where the `[,]` represents a list of types^[1], then we could construct a type that looks like `Applicative f => (Fn xs r) -> Fn (map f xs) (f r)`^[2] which would be the ""real"" type of `mapMany` we were talking about  so, how do we construct something like this?",0.39,r
13eo3pa,jjrowkr,"I don't want to make any decisions for you on what this sort of nearly-dependently-typed stuff should look like in Cara (or even if you should include it at all :p), but there are a few different ways of going about this:  - now that you have your list of argument types, you could use even more type-level machinery to construct a curried version of the function argument and insert the right number of `<*>` calls - you could get all the arguments as a single data structure (this is the ""heterogeneous list"" i was talking about) -- maybe something like `HList [a, b, c]` is like a tuple `(a, b, c)` -- then you'd need to turn your `HList (map f xs)`  into `f (HList xs)`, and finally apply all the arguments to the function argument at once (you'd need something like an `apply : (Fn xs r, HList xs) -> r`) - cast to `object`!",0.04084821428571431,c
13eo3pa,jjrowkr,"I don't want to make any decisions for you on what this sort of nearly-dependently-typed stuff should look like in Cara (or even if you should include it at all :p), but there are a few different ways of going about this:  - now that you have your list of argument types, you could use even more type-level machinery to construct a curried version of the function argument and insert the right number of `<*>` calls - you could get all the arguments as a single data structure (this is the ""heterogeneous list"" i was talking about) -- maybe something like `HList [a, b, c]` is like a tuple `(a, b, c)` -- then you'd need to turn your `HList (map f xs)`  into `f (HList xs)`, and finally apply all the arguments to the function argument at once (you'd need something like an `apply : (Fn xs r, HList xs) -> r`) - cast to `object`!",0.04084821428571431,r
13eo3pa,jjrowkr,"if you have some sort of ""any"" type, and you're willing to be a little unsafe, you could forgo all this type-astronaut-ing and just take your varargs as a `List (f Any)` -- then repeat with the above^ but with much simpler types: you'd turn your `List (f Any)` into an `f (List Any)`, then map `apply : (Fn xs r, List Any) -> r` to get your answer  in any case, I totally understand if this is too much complexity -- I couldn't even get GHC to let me implement this without manually screwing around with proofs and singletons and all that stuff^[3].",-0.04107142857142857,r
13eo3pa,jjvbhrr,Or perhaps C++ has some unsafe cast capability that makes the nice unlimited API expressible as well :),0.55,c++
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,c
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,python
13elyfa,,"So hey, I am back, I have updated the concept for my programming language with the suggestions from people from the previous post,so here is the updated concept      //Comments work the exact same as C-like languages          //The keyword Use is used to import files,like in the last post,the file name works as the name space     //The keyword Import is used to import modules     //Modules will be explained          //Use the NameSpace::All to import all the contents     Use Sys::{Hello::All,}     Import Math          //This Shows to how to make a class     @Public     Class SomeClass : AbstractClass, IInterface{     	//You need to manually add Private,Internal,Protected or Public Attribute to Define the access of a variable     	//The class Types are similar to C#,there is Abstract,Partial          	//These are the following types available in scorpionest     	/*     	Int ""The number of bits depends on your operating system""     	Dec ""Switches to float or double depending on how many bits your pc is""     	Uint     	Byte     	Bool     	Dyn ""A type that allows dynamic objects,similar to coding in python or a similar language""     	Nullable[] ""A container that allows you to set a type as nullable""     	Str     	Char     	     	There are probably more types to come in the final product     	*/                    	//Variables are Declared via a keyword,followed by their name and their type and value     	//Mutable     	@Private     	Var _foodBar : Str = Str::Empty;	     	//Immutable and Auto keyword(similar to the auto keyword from C++)      	@Private     	Let _lasagna : Auto = 100;     	//Const(only works with primitives and is the same as C#) and nullable Value Types     	@Private     	Const Sandwich : Char = 'a';     	//Static Vars can have only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	@Private     	Static eggSalad : Nullable[Bool] = null;     	//Attributes,to call one you must use a @ followed by the their name     	@Private,Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	//Properities are created by the Prop keyword     	@Public      	SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	//You can Also create a Quick Readonly Properity     	@Public      	Prop LasagnaProp : Auto = Get[Int](_lasagna);     	//Quick get and set Access properites can also be made     	@Public      	Prop EggSalad : Auto = GetSet[Nullable[Bool]](eggSalad);                    	//The val keyword is used to pass by value,also Functions can return values     	@Public      	Fn SomeFunction(val num1 : Int,val num2 : Int) : Int{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	@Public      	Fn SomeFunction2(ref num : Int) : void{     		num = 1;     	}          	// we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	//also as seen,we can have 1 line methods           	//Interface Functions must be Public,also you don't use Fn,you use the Interface Function's name      	@Public     	InterfaceFunction() : void     	{     		FoodBar = If FoodBar == Str::Empty Else ""Hello Guys!",0.08802083333333334,c++
13elyfa,,"Def !SomeClass(){     		Log(""Goodbye :("");     	}     }          /*          Here come modules,modules can either contain extensions,attributes or helpful functions          modules can be the only thing in the file,and must start with the keyword ""extend"" followed by either ""Attribute"",""Extension[]"" or ""Helper""          modules can either be internal or public,and the access modifier attribute must be put before the extend keyword          */     @Public     extends Extension[SomeClass]               //We can add additional Functions,but not additional Variables or Properities          //We can use the Params[] Container to pass an infinite amount of objects as parameters,although it must be the last argument     @Public      Fn ExtensionFunction(val uselessStuffForExample : Params[Dyn]) : bool{     	//The When keyword takes multiple bools and checks for any falses,if detected,it returns from the method with the default value     	When{     	!false,     	true     	}          	//For loops work the same as in kotlin and rust,except we use the Range or RangeInclusive Functions     	For (i in RangeInclusive(1,10)){     		Log(i);     	}     	//While loops work as expected     	While (True){     		Break;     		//There also exists the Break keyword,the Skip keyword(similar to continue),Redo keyword(redos the current loop) and the Reloop keyword(Reloops the entire loop)     	}     	//Switch is intended to be faster and much more cleaner for checking single values similar to the C# variant and requires a constant value     	Switch(1){     		(1,2) => Logl(1),     		3 => Logl(3),     		4 => Logl(4),     		_ => Logl(""Default"")     	};     	return true;     }          //There are other object types other than Classes,these are Structs(The same as in most languages),Enums(Same as in C# but can inherit a constant and if it inherits,it must have a value) and Cases(Sames as Enums in rust)  so how does it look?",0.019940476190476186,kotlin
13elyfa,,"Def !SomeClass(){     		Log(""Goodbye :("");     	}     }          /*          Here come modules,modules can either contain extensions,attributes or helpful functions          modules can be the only thing in the file,and must start with the keyword ""extend"" followed by either ""Attribute"",""Extension[]"" or ""Helper""          modules can either be internal or public,and the access modifier attribute must be put before the extend keyword          */     @Public     extends Extension[SomeClass]               //We can add additional Functions,but not additional Variables or Properities          //We can use the Params[] Container to pass an infinite amount of objects as parameters,although it must be the last argument     @Public      Fn ExtensionFunction(val uselessStuffForExample : Params[Dyn]) : bool{     	//The When keyword takes multiple bools and checks for any falses,if detected,it returns from the method with the default value     	When{     	!false,     	true     	}          	//For loops work the same as in kotlin and rust,except we use the Range or RangeInclusive Functions     	For (i in RangeInclusive(1,10)){     		Log(i);     	}     	//While loops work as expected     	While (True){     		Break;     		//There also exists the Break keyword,the Skip keyword(similar to continue),Redo keyword(redos the current loop) and the Reloop keyword(Reloops the entire loop)     	}     	//Switch is intended to be faster and much more cleaner for checking single values similar to the C# variant and requires a constant value     	Switch(1){     		(1,2) => Logl(1),     		3 => Logl(3),     		4 => Logl(4),     		_ => Logl(""Default"")     	};     	return true;     }          //There are other object types other than Classes,these are Structs(The same as in most languages),Enums(Same as in C# but can inherit a constant and if it inherits,it must have a value) and Cases(Sames as Enums in rust)  so how does it look?",0.019940476190476186,rust
13elyfa,,"Def !SomeClass(){     		Log(""Goodbye :("");     	}     }          /*          Here come modules,modules can either contain extensions,attributes or helpful functions          modules can be the only thing in the file,and must start with the keyword ""extend"" followed by either ""Attribute"",""Extension[]"" or ""Helper""          modules can either be internal or public,and the access modifier attribute must be put before the extend keyword          */     @Public     extends Extension[SomeClass]               //We can add additional Functions,but not additional Variables or Properities          //We can use the Params[] Container to pass an infinite amount of objects as parameters,although it must be the last argument     @Public      Fn ExtensionFunction(val uselessStuffForExample : Params[Dyn]) : bool{     	//The When keyword takes multiple bools and checks for any falses,if detected,it returns from the method with the default value     	When{     	!false,     	true     	}          	//For loops work the same as in kotlin and rust,except we use the Range or RangeInclusive Functions     	For (i in RangeInclusive(1,10)){     		Log(i);     	}     	//While loops work as expected     	While (True){     		Break;     		//There also exists the Break keyword,the Skip keyword(similar to continue),Redo keyword(redos the current loop) and the Reloop keyword(Reloops the entire loop)     	}     	//Switch is intended to be faster and much more cleaner for checking single values similar to the C# variant and requires a constant value     	Switch(1){     		(1,2) => Logl(1),     		3 => Logl(3),     		4 => Logl(4),     		_ => Logl(""Default"")     	};     	return true;     }          //There are other object types other than Classes,these are Structs(The same as in most languages),Enums(Same as in C# but can inherit a constant and if it inherits,it must have a value) and Cases(Sames as Enums in rust)  so how does it look?",0.019940476190476186,c
13elyfa,,"also, I need some help with this language, so far I have made a simple lexer with logos in Rust and was planning to make a parser with nom and a compiler with Inkwell, but I am thinking of switching to another language, should I?",0.05,rust
13elyfa,jjqsztg,"also, I need some help with this language, so far I have made a simple lexer with logos in Rust and was planning to make a parser with nom and a compiler with Inkwell, but I am thinking of switching to another language, should I?",0.05,rust
13elyfa,jjqsztg,"If you are comfortable with Rust, use it, otherwise pick something else.",0.4,rust
13elyfa,jjqxtei,I'd go for something standard like `*`.,0.0,go
13elyfa,jjqwzdh,I disagree on the int thing  Int should be the same as C's int_fast32_t imo  There's no reason to explicitly specify the bit size of an integer if it's not required by the code in question.,0.0,c
13elyfa,jjqu3xp,"Well,the colon thing in declaration is optional,I may remove auto,and lastly I am working with rust,it is good for me in certain cases but not all in all cases,so I was wondering if there was a possible easier option?",0.22857142857142856,rust
13ej6fr,jjq8sc3,"Among other things in here, one thing I found interesting is that there appears to be the Interlisp source code of v1.5 of Quintus Prolog.",0.1875,prolog
13e5ilp,jjocbyw,"Dart has come a long way since version 1, I still vaguely remember how Dart 1.x had a pluggable type system and was supposed to be a better JS.",-0.01666666666666668,dart
13e5ilp,jjocbyw,"Of course most people writing code in Dart are doing this for Flutter as it is now, but it will be really nice to see Dart being used in other areas as well.",0.325,dart
13e5ilp,jjocbyw,"The backend seems to be a good candidate, and maybe web assembly too.",0.7,assembly
13e5ilp,jjnyr12,Saw this comment elsewhere:  >\> it's not bringing anything useful to the table compared to other existing languages   Dart's tooling and compiler are actually state-of-the-art.,0.05833333333333333,dart
13e5ilp,jjnyr12,"Not many languages can claim to target every major OS (Windows, Mac, Linux, Android, iOS) in three different modes (native, JIT, interpreted) and natively compile to both JavaScript and WebAssembly, while also supporting hot-swapping code at runtime.",0.015625,javascript
13e5ilp,jjnyr12,Plus Dart's Pub package manager is stupidly simple and 'just works' compared to pretty much any other language I've used.,0.08125,dart
13e5ilp,jjqs1ed,"Dart is only ""exciting"" if you fell into a coma around Java 7.",0.06666666666666667,dart
13e5ilp,jjqs1ed,"Dart is only ""exciting"" if you fell into a coma around Java 7.",0.06666666666666667,java
13e5ilp,jjqs1ed,"I understand it's targeting a similar kind of people as Go and they don't want to overload the minds of those feeble non-Googlers, but that doesn't explain all the feature work that is happening.",0.033333333333333326,go
13e5ilp,jjolqep,"As in Dart, the GObject and GLib framework that started in the Gimp Open Source Paint Tool and later in the Open Sourc Linux GNome Desktop eventually become the Vala P.L.",0.0,dart
13e5ilp,jjphj73,"None of those great things are a property of Dart, the language.",0.8,dart
13e5ilp,jjphj73,"Dart, the language, does not bring anything new to the table.",0.13636363636363635,dart
13e5ilp,jjphj73,"Tools and compilers are still reasons why you would pick a language over another for a project, and why Dart as a language choice can still make sense for some situations.",0.0,dart
13e5ilp,jjphj73,But it'd be much better for absolutely everyone if the efforts spent on the Dart compiler went into improving the compiler of an existing language with extensive ecosystem.,0.15,dart
13e5ilp,jju6svb,"""Dart is the only language that initially had design flaw X and now no longer has design flaw X"".",0.0,dart
13e5ilp,jjqnsgn,So Kotlin and Typescript don't count then?,0.0,kotlin
13e5ilp,jjqnsgn,So Kotlin and Typescript don't count then?,0.0,typescript
13e5ilp,jju6mp0,Kotlin.,0.0,kotlin
13e5ilp,jju6mp0,Dart has been playing catch up to Kotlin's features for over five years now.,0.0,dart
13e5ilp,jju6mp0,Dart has been playing catch up to Kotlin's features for over five years now.,0.0,kotlin
13e5ilp,jjra194,Scala 3 has had it under a compiler flag for a long time too.,-0.05,scala
13e5ilp,jjrgw0l,Kotlin and TypeScript aren't sound.,0.4,kotlin
13e5ilp,jjrgw0l,Kotlin and TypeScript aren't sound.,0.4,typescript
13e5ilp,jjrupi6,"Uhm, I really don't know haha, don't work on the Dart team, was just clarifying the claim",0.2,dart
13e5ilp,jjrgtaq,"Some examples of how language design interacts with what you might think of as ""implementation features"":  * Dart has no top level static initialization.",0.125,dart
13e5ilp,jjrgtaq,"This means that applications can start up faster than you typically see in, for example, Java.",-0.16666666666666666,java
13e5ilp,jjrgtaq,* Dart doesn't have class loading or other dynamic loading features.,-0.0625,dart
13e5ilp,jjrgtaq,This makes whole-program optimization and large scale dead code elimination work in ways that are very difficult for a language like Java or C#.,-0.21190476190476193,java
13e5ilp,jjrgtaq,This makes whole-program optimization and large scale dead code elimination work in ways that are very difficult for a language like Java or C#.,-0.21190476190476193,c
13e5ilp,jjrgtaq,* Dart's concurrency model is designed to be straightforward to compile to JavaScript while other languages struggle to have the same concurrency semantics on the web without losing a lot of performance.,0.08333333333333333,dart
13e5ilp,jjrgtaq,* Dart's concurrency model is designed to be straightforward to compile to JavaScript while other languages struggle to have the same concurrency semantics on the web without losing a lot of performance.,0.08333333333333333,javascript
13e5ilp,jjrgtaq,"There's a reason every JVM has a JIT, while C++ implementations generally don't.",0.05000000000000002,c++
13e5ilp,jjrgtaq,There's a reason Ruby and Python are still mostly using bytecode interpreters and why ahead of time compilation for them hasn't been successful.,0.625,ruby
13e5ilp,jjrgtaq,There's a reason Ruby and Python are still mostly using bytecode interpreters and why ahead of time compilation for them hasn't been successful.,0.625,python
13e5ilp,jjw1gu5,Awfully specific asterisks that need to be appended to all these claims about Dart ...,0.0,dart
13e5ilp,jjrgnq5,Please go over my original comment again.,0.375,go
13e5ilp,jjrgnq5,"I am talking about Dart, the language.",0.0,dart
13e5ilp,jjrgnq5,Dart's tooling is great.,0.8,dart
13e5ilp,jjrgnq5,And when Flutter was started there were already plenty of better options than Dart.,0.5,dart
13e5ilp,jjzxape,> bigger than the alternative languages that run on VMs and have sound null safety  > Dart's ecosystem is bigger than comparable languages today.,0.13333333333333333,dart
13e5ilp,jjzxape,I'd wager that even Scala's ecosystem (a language that is pretty much dying) is substantially bigger than Dart's.,0.15,scala
13e5ilp,jjzxape,I'd wager that even Scala's ecosystem (a language that is pretty much dying) is substantially bigger than Dart's.,0.15,dart
13e5ilp,jjryca9,It doesn't matter since Dart 3.0 seems to finally be a decent language.,0.16666666666666666,dart
13e5ilp,jjryca9,"Could've had an easier time for everyone but here we are, and that's what my comment was pointing out: Building an ecosystem for Dart, the language, was a waste of resources.",-0.2,dart
13e36pv,,"As to reproducibility, the scientific method requires reproducibility, which is quite tough but there are efforts to go all the way to reproducibility of computations within their development environments using Guix or Nix.",-0.3888888888888889,go
13e36pv,jjnq142,The Julia language is specifically built with scientific computing and researchers in mind.,0.0,julia
13e36pv,jjnq142,"Julia approaches reproducibility from the packaging perspective: local environments (collections of installed packages) are easy to set up, the exact state of each environment is saved locally, along the ""research code"".",0.17083333333333334,julia
13e36pv,jjnq142,"There are also Pluto notebooks, which are the Julia version of reproducible Jupyter-like notebooks.",0.0,julia
13e36pv,jjnq142,Another thing that's often mentioned when talking about Julia for researchers is Julia's Unicode support.,0.0,julia
13e36pv,jjnq142,"Supposedly, researchers like to use Greek letters and various fancy symbols as part of variable names, and Julia lets you do just that.",0.0,julia
13e36pv,jjnq142,"Of course, Julia also provides a lot of tooling for all sorts of computation, optimization, solving equations, fitting neural networks, plotting stuff and so on.",0.5,julia
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,matlab
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,python
13e36pv,jjor8ip,"The ones I know are mostly doing Matlab, Python, OCaml, Fortran and R.  Most of these languages have awful tooling (especially Python), plus a lot of their users that I know of don't even use versioning (!).",0.0,fortran
13e36pv,jjor8ip,My opinion is that replacing Fortran will be tough.,-0.3888888888888889,fortran
13e36pv,jjor8ip,"I successfully converted a friend who is doing her Ph.D. to Julia, but I don't think most of her colleagues would be able to follow.",0.5833333333333334,julia
13e36pv,jjsn7yg,"I would go even further, though.",0.0,go
13e36pv,jjsn7yg,"With containers, you just learn how to set up a container and run it and then you are good to go (for the purposes you're describing).",0.7,go
13e36pv,jjuxm1e,Matlab is great for this.,0.8,matlab
13e36pv,jjuxm1e,"Matlab as a whole is very stable and well maintained, so if all your dependencies are matlab, there's a lot less room for things to break.",0.07777777777777779,matlab
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,python
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,r
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,matlab
13e36pv,jjp2p5w,"Python, R, Matlab and Julia all try to cater to these.",0.0,julia
13e36pv,jjp2p5w,I would expect Rust to become popular here if the scientific computing infrastructure for that language improves.,0.6,rust
13e36pv,jjqyqq2,I think Julia as a language has a few significant flaws like lack of static typing/analysis and the use of multiple dispatch in large projects (which can be a death trap disguised as a feature).,0.17785714285714288,julia
13e36pv,jjqyqq2,"Aside from that, Julia has a marketability problem.",0.0,julia
13e36pv,jjqyqq2,"It does not make a very compelling argument of why it should replace X language It's clearly designed to look like python, but cannot compete with python's insanely huge ecosystem.",0.2966666666666667,python
13e36pv,jjqyqq2,"For all the complaints people have about python, it's probably become irreplaceable in this niche due to the vast amount of libraries available for it.",0.09166666666666667,python
13e36pv,jjqyqq2,Same goes for R in its own niche.,0.3,r
13e36pv,jjqyqq2,"Julia devs have made some misleading claims about Julia's performance (often citing very selective and unrealistic benchmarks), but in reality, Julia's performance is at about Java level in most cases.",0.06666666666666667,julia
13e36pv,jjqyqq2,"Julia devs have made some misleading claims about Julia's performance (often citing very selective and unrealistic benchmarks), but in reality, Julia's performance is at about Java level in most cases.",0.06666666666666667,java
13e36pv,jjqyqq2,So I don't see it replacing Fortran on that end of the spectrum either.,0.0,fortran
13e36pv,jjtj3qh,"Julia offers almost no way to verify that you have written correct code: there's a lack of good linting, has no compile-time errors, it allows type piracy, it has the wildest variable scoping rules I've ever seen, its default import system is basically C-style copy-paste #includes rather than any modern approach, it has no trait/etc system to enforce invariants, etc etc etc.",0.3333333333333333,julia
13e36pv,jjtj3qh,"It's a fine choice for the expert, who's comfortable navigating the footguns and wants all the cool power of multiple dispatch and such.",0.22777777777777777,cool
13e36pv,jjtj3qh,"(I am aware of the irony here, given Julia's decision to focus on scientific applications.)",0.25,julia
13e36pv,jjqdrwn,Hence why I am not holding my breath for Julia to replace matlab.,0.0,julia
13e36pv,jjqdrwn,Hence why I am not holding my breath for Julia to replace matlab.,0.0,matlab
13e36pv,jjtne68,"It's all or nothing: either you go all in and produce (over many years) a piece of software that is sufficiently general, robust and fast that people start adopting it, or you do half-assed Matlab scripts to get papers out.",0.25,go
13e36pv,jjtne68,"It's all or nothing: either you go all in and produce (over many years) a piece of software that is sufficiently general, robust and fast that people start adopting it, or you do half-assed Matlab scripts to get papers out.",0.25,matlab
13e36pv,jjtne68,"These are codes developped over decades that practically no engineer ever looked at, and they are about 500k lines of Fortran too late for refactoring.",-0.3,fortran
13e36pv,jjtne68,Fortran is great because it allows you to write fast code without effort nor much programming knowledge.,0.39999999999999997,fortran
13e36pv,jjtne68,"But maybe it fails at other aspects, such as modularity, environment reproductibility (libraries are sometimes just this old .f77 file snatched 10 years ago from someone's html 1.0 homepage that isn't even hosted anymore), perhaps code correctness analysis tools, etc.",-0.13125,html
13e36pv,jjtne68,"A thing software engineers seem to have trouble understanding sometimes, is that scientists are basically big noobs that have no interest whatsoever in understanding the difference between a pointer, a unique\_ptr, a reference, a const reference, blablabla, and that the path of least resistance should lead to the most efficient and useful implementations from the get go.",0.06,go
13e36pv,jjql6hg,"Biologists & data scientists say ""why should I learn C++ when I can have every library I need in Python?"".",0.0,c++
13e36pv,jjql6hg,"Biologists & data scientists say ""why should I learn C++ when I can have every library I need in Python?"".",0.0,python
13e36pv,jjql6hg,"And then I show them the source of their library, which is more often than not in C++.",0.5,c++
13e36pv,jjtoxu2,"In this context, Matlab is all you ever need.",0.0,matlab
13e36pv,jjtoxu2,"Some are, of course, but some of those big ol pieces of code everyone is using are Fortran (or otherwise) messes that have bits of code from 40 years ago, that have been written in by every PhD student that has come, with practically no control of the quality of the code (no-one in academia has time for code review, something I've incidentally only heard of through the internet despite a PhD and postdoc in a code-heavy field), no unit testing beyond ""here's a couple of test cases, have fun"" and a bunch of print\*, git being used once every couple of years to merge part of a thesis' work in (when it's not plain e-mailing tar.gzs), etc... etc...",0.10178571428571428,fortran
13e36pv,jjtoxu2,It just so happens that Fortran is fast by default.,0.2,fortran
13e36pv,jjwyc0h,"I don't think Julia's devs are even trying to work on this, unfortunately.",-0.5,julia
13e36pv,jjwyc0h,"As an example, when I'm messing around with Julia code (some numerical optimization, neural networks, data visualization and so on), the language feels just fine: I don't need to specify types, I can write functions that dispatch on whatever I need (this needs types, but it's OK), and everything is pretty fast.",0.3416666666666667,julia
13e36pv,jjwyc0h,"I've just finished working on some Python + Equinox code (loving Equinox, BTW) that involves time-series cross-validation (which needs nested loops), and boy is it slower than Julia!",0.75,python
13e36pv,jjwyc0h,"I've just finished working on some Python + Equinox code (loving Equinox, BTW) that involves time-series cross-validation (which needs nested loops), and boy is it slower than Julia!",0.75,julia
13e36pv,jjwyc0h,"In Julia and Flux.jl the exact same code is literally orders of magnitude faster, just out of the box, without any optimizations.",0.125,julia
13e36pv,jjwyc0h,"In Julia, however, I don't need to worry about JIT (except when it takes forever to run code for the first time - ha, got 'em!).",0.3125,julia
13e36pv,jjwyc0h,I don't like it when `MyPackage.jl` basically consists of `include`s that supposedly act more like C's `#include` directives.,0.5,c
13e36pv,jjwyc0h,Even Python has abstract base classes that force you to implement the entire interface.,-0.4,python
13e36pv,jjr6bey,"as opposed to MATLAB, which ships without a package manager and makes life hell for anyone using it.",0.0,matlab
13e36pv,jjqul2q,That's the point of the Python ecosystem or of libraries in general: other people have written stuff do you don't have to.,-0.03749999999999999,python
13e36pv,jjxlkh1,"Ah, I took your mention of Julia to be a recommendation.",0.0,julia
13e36pv,jjxlkh1,"As anecdata, I have definitely seen first-time Julia users run afoul of each of the various things I've mentioned.",0.0,julia
13e36pv,jjxlkh1,Price of bolting a DSL on to Python.,0.0,python
13e36pv,jjux1mj,You'll have to pry matlab from my cold dead hands.,-0.4,matlab
13e36pv,jjux1mj,"The great thing about matlab (for certain problem domains) is that you really don't NEED a package manager, because there's basically no external dependencies to manage.",0.30357142857142855,matlab
13e0b2c,jjpr0l7,I remember trying to reverse engineer it and study its assembly format.,0.0,assembly
13dya1e,,"Usually this is the default behaviour of these constructs, but i found Go to be an oddball (as it usually is), here's the specification of type identity between two `struct` types ([link to the spec](https://go.dev/ref/spec#Type_identity)):  >Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags.",-0.125,go
13dya1e,jjn2f8q,My records look like this in my static language; they are always a named user-type:      record R =         real a         string b     end      record S = (real a; string b)      # alternate compact syntax  This also defines two incompatible types `R` and `S`.,0.029999999999999992,r
13dya1e,jjnd2g8,"I also add a small of array model, so I optimize for `N-values` instead of `Scalar` (all simplified, not the exact impl as today):  ```rust //Records  struct Schema {    fields: Vec<String>,    types: Vec<Kind> }  struct Rel {   schema: Schema //name: String, id: I32...   rows: Vec<Scalar> //ie: A 2-dimensional array } ```  Sum types follow a similar idea:  ```rust //Sum struct Sum {  tag: String,  data: Option<Rel> }  //This is like:  Option::Some(1) == [""Option.Some"", 1] Option::None ==[""Option.None""] ```",0.0,rust
13dya1e,jjnt5iq,"**Summary**  Anyway, I use record / struct types, as a typical ""C"" or ""Pascal"" program declares them.",-0.16666666666666666,c
13dya1e,jjnt5iq,"**Summary**  Anyway, I use record / struct types, as a typical ""C"" or ""Pascal"" program declares them.",-0.16666666666666666,pascal
13dya1e,jjnt5iq,"As an example:      struct RGBA     {        int var R;        int var G;        int var B;        int var A;     }  Is not the same as:      struct ARGB     {        int var A;        int var R;        int var G;        int var B;     }  Both are Product Types, right ?",0.14285714285714285,r
13dya1e,jjnt5iq,"And a common:      union Param     {       int var I;       doubl var F;       char var C;       char* var S;     }  That's a Sum Type, right ?",-0.007142857142857145,c
13dya1e,jjnt5iq,"You will not notest much of a difference, from C or C++, in these fragments of code, except that "";"" and variable declarations aren't not supported here.",0.2,c
13dya1e,jjnt5iq,"You will not notest much of a difference, from C or C++, in these fragments of code, except that "";"" and variable declarations aren't not supported here.",0.2,c++
13dya1e,jjnt5iq,"I considering use C++ alike generics or templates but for non O.O., I ignore if they are considered Sum Types, Product Types or other concept in Type Theory.",-0.125,c++
13dya1e,jjnt5iq,I guess type expression declarations like:      typedef       int var c[512];           ...     int var a[512];     int var b[512];     c var d;     ...,0.0,c
13dya1e,jjnt5iq,I guess type expression declarations like:      typedef       int var c[512];           ...     int var a[512];     int var b[512];     c var d;     ...,0.0,d
13dya1e,jjnt5iq,"The three variables""a"", ""b"", ""d"" are considered equivalent.",0.0,d
13dya1e,jjoalx0,"Both of these types would be declared by associating labels with types, as in C. Like C, the labels correspond to offsets from the begining of the structure, so order and label names definitely both matter.",0.0,c
13dya1e,jjo71qn,"The example from the [PureScript documentation](https://github.com/purescript/documentation/blob/master/language/Records.md) is:      type Lang l = { language :: String | l }          type Language = Lang ( country :: String )     -- equivalent to { language :: String, country :: String }  I'm curious how that differs / is related to the [equivalent in TypeScript](https://www.typescriptlang.org/play?#code/C4TwDgpgBAMghgOwOYB4YD4oF4oG8oA2iSArnEhAFxQDOwATgJbJQC+UAZLAFDeiSxiZCtkHIU+AMYB7EggYhqdJi1bpeMhHSgQAHnAC2YAlTGly0HLm5RbUGXIXUA5ACEASs4A0Nu0WTCps4ACgAq3tys3EA):      type Lang<L> = { language: string } & L          type Language = Lang<{ country: string }>          let example: Language = {       country: 'BR',       language: 'PT',     }  Besides the difference in syntax, are these example fundamentally different?",-0.03333333333333333,typescript
13dya1e,jjnpiko,"I believe this is the same reason for Go to require ordering, requiring equal names is probably to make it easier to implement.",0.0,go
13dya1e,jjnpiko,"edit: Go probably requires equal names to make a more stable ABI too, you have guarantee of the offset for each field name.",0.25,go
13dya1e,jjsuzz5,"Your language looks very interesting, the only other set-based language i know is SETL, but they treat sets the same way APL treats arrays: it's their default data type.",0.13125,apl
13dya1e,jjnstgp,"I've seen this syntax being used in Lua, Javascript and Setl, i tried to come up with a nice syntax like `hashmap.key` for those but found it too difficult to fit in a static language.",0.25,lua
13dya1e,jjnstgp,"I've seen this syntax being used in Lua, Javascript and Setl, i tried to come up with a nice syntax like `hashmap.key` for those but found it too difficult to fit in a static language.",0.25,javascript
13dya1e,jjo3j42,">foo = StandardEuropeanItem with PortugeseModifications  That is very cool, i was thinking about implementing the same idea in my language, but similar to how C# does it: the `{label: value, ...}` is part of the `with` syntax, it doesn't accept arbitrary objects, your idea is a interesting generalization.",0.17099999999999999,cool
13dya1e,jjo3j42,">foo = StandardEuropeanItem with PortugeseModifications  That is very cool, i was thinking about implementing the same idea in my language, but similar to how C# does it: the `{label: value, ...}` is part of the `with` syntax, it doesn't accept arbitrary objects, your idea is a interesting generalization.",0.17099999999999999,c
13dya1e,jjo7sdq,"I do think C does that [to an extent](https://stackoverflow.com/questions/42411819/c-on-x86-64-when-are-structs-classes-passed-and-returned-in-registers), i'd have to look at compiler outputs to be sure, but i think LLVM has this type of optimization.",0.5,c
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,scheme
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,c
13dya1e,jjnvkb3,"There's a very good reason for using this scheme you use in your language, as is used by C and Go: having a usable ABI.",0.9099999999999999,go
13dya1e,jjoemnx,"So, TypeScript has intersection and union types, which is closely related to the subtyping approaches I had mentioned - I should have mentioned these types by name, and used TypeScript as an example!",0.0,typescript
13dya1e,jjoemnx,"The MLstruct paper I linked presents a type system that is essentially a ""fixed"" version of typescript in that it has full inference for intersection and union types.",0.22499999999999998,typescript
13dya1e,jjo7r1f,It's a Ruby inspired smalltalk dialect.,0.0,ruby
13dya1e,jjo7r1f,It is inspired directly by Ruby's own `Struct` and `OpenStruct`.,0.35,ruby
13dya1e,jjnvhdm,"Destructuring, as I understand the term, would be done like this for a function returning 2 values:      F()            # discard both values     a := F()       # discard second value     (a, b) := F()  # use both  Similarly, with multiple assignments such as `(a, b) := (c, d)`, which must be via temporaries to allow rotation etc, this is just done with data movements, not any special type.",-0.06547619047619048,c
13dya1e,jjnvhdm,"Destructuring, as I understand the term, would be done like this for a function returning 2 values:      F()            # discard both values     a := F()       # discard second value     (a, b) := F()  # use both  Similarly, with multiple assignments such as `(a, b) := (c, d)`, which must be via temporaries to allow rotation etc, this is just done with data movements, not any special type.",-0.06547619047619048,d
13dya1e,jjohkt9,> That is very cool  Thanks.,0.3275,cool
13dya1e,jjoep28,"> I do think C does that to an extent, i'd have to look at compiler outputs to be sure, but i think LLVM has this type of optimization.",0.5,c
13dya1e,jjqtupl,"In TypeScript, when the right-hand side of an intersection contains the same key(s) as the left-hand side, there are some surprising results.",0.35,typescript
13dya1e,jjqtupl,"I don't know if this is a TypeScript bug or actually expected, but [this is an interesting example](https://www.typescriptlang.org/play?#code/PTAEEFQZwSwGzgT1AUwB4EMC2AHOKAaUAMwHsAnaAV3JQCgAXRHFUABVJgDsGBmUALygA3qDQAuUFypYARinJFEk6XIVEAXipnzKAX0bNWHbgwBMg9px78AZCNBapKAG4LQBuvgagc1vpImNpaiEqAAjEqSZpqS-HqgIKAA8gDSdHRJQeagGDgsGORQoAykoPKgMLikULCy+CVlAMakXFAM5FRNDJlgAJIA5AAmqGgs3SUAFqzEMEU+6Nh4rPJwpADuoOswDJOkVD4DGgON5axpXig+fqZmAPoYgf4WQqGSkaDKoBYJSS248FYCnIFEu12ed1kT1uITE7yi31ioHiiTA-xwgNQ5BB5AyQA)      // A silly example, for sure     type Point3 = { x: number, y: number, z: number }     type Point2 = Point3 & { z: never }          let point3: Point3 = { x: 1, y: 2, z: 3 } // OK          // Point2 appears to be impossible to construct     // I'd expect the first example below without 'z' to be OK     let point2_a: Point2 = { x: 1, y: 2 } // compile error     let point2_b: Point2 = { x: 1, y: 2, z: 3 } // compile error  I feel like the row polymorphism example may be easier to understand in general (after you get past the ""I've never seen this before"" stage), which is probably related to what you mentioned about it being easier to implement type inference for as well.",0.13717948717948716,typescript
13dya1e,jjo4q82,"One other approach is what is done in C#: `tuple.Item0, tuple.Item1, ..., tuple.ItemN`, which is much simpler than generating letter labels and also fixes the parsing problem.",0.037500000000000006,c
13dya1e,jjnybmg,">Similarly, with multiple assignments such as    >   >(a, b) := (c, d)   >   >, which must be via temporaries to allow rotation etc, this is just done with data movements, not any special type.",-0.09821428571428571,c
13dya1e,jjnybmg,">Similarly, with multiple assignments such as    >   >(a, b) := (c, d)   >   >, which must be via temporaries to allow rotation etc, this is just done with data movements, not any special type.",-0.09821428571428571,d
13dya1e,jjoai3d,"> One other approach is what is done in C#: `tuple.Item0, tuple.Item1, ..., tuple.ItemN`, which is much simpler than generating letter labels and also fixes the parsing problem.",0.037500000000000006,c
13dya1e,jjnzw3s,"Sometimes you need to do a rotation like:      (a, b, c) := (b, c, a)  which would give unexpected results if implemented as `a:=b; b:=c; c:=a`.",-0.4666666666666666,c
13dya1e,jjo5q6y,"True, in my case the problem is that to make the swap in this way requires you to create a product:      set a, b, c = {c, a, b} # this is a product literal  Then there's an edge case with unique references inside an array, their content would be moved and we can't keep track of which references inside an array are moved at compile time (this would need runtime information).",0.3625,c
13dv591,jjmg245,"I believe Python has a single integer type from the users perspective, but automatically promotes numbers as needed in the backend.",-0.07142857142857142,python
13dv591,jjmg245,"That said, one type change that isn't as clear, division in Python 3+ between two integers will always produce a float.",0.10000000000000002,python
13dv591,jjoupvy,"Originally, C designers used to change all integers values into integer, for operations.",0.375,c
13dv591,jjoupvy,"In C, both values were converted into signed integer bigger size ""integer"".",0.0,c
13dv591,jjoupvy,"If you have an expression where the biggest value, either variable (storage), named variable (storage) or literal constant is a 16 bits integers, like this:      uint8_t a = 5;     uint8_t b = 7;     uint8_t c = a * b;  Then may generate an intermediate 32 bits variable:      uint8_t a = 5;     uint8_t b = 7;          // generated by compiler or interpreter:     uint16_t temp123;     temp123 = extend16(a) * extend16(b);          uint8_t c = temp123;  **Literal Constants**  In case of literal constants, is common to put their values into an intermediate variable, although its value is only read, but not modified:      uint8_t c = 3 * 5;  Becomes:      uint8_t temp456 = 3;     uint8_t temp789 = 5;     uint8_t c = temp456 * temp789;  Among other stuff.",-0.10625,c
13dv591,jjpkb9p,You could take the JavaScript approach and decide that all numbers are double-precision floating point.,0.0,javascript
13dv591,jjpkb9p,"If you choose the latter alternative, then you'll probably want an analogue to Python's `struct` module for dealing with explicitly-sized binary data.",0.0,python
13dv591,jjqmtvf,With a language like Python the transition is seamless.,0.1,python
13dv591,jjuccq2,"To be fair, I once tested some computationally-heavy algorithms (I can't recall the specific use case now) written in Java with a version using the int type, and a version using the long type.",0.21666666666666665,java
13dv591,jjuu3hg,"C for example typically uses a default 32-bit `int` type, literals are 32 bits and expressions are widened to 32 bits for evaluation, even if the operands are 8 or 16 bits.",-0.16666666666666666,c
13ds7sy,jjm3dli,See C++.,0.0,c++
13ds7sy,jjm3dli,Look at Rust.,0.0,rust
13ds7sy,jjm3dli,You set the edition for your project and the code will run forever because it can just disable the newer features and use an old version of Rust.,0.1,rust
13ds7sy,jjm3dli,"In the future, I can use the upcoming 2024 edition of Rust with crates that were made with the 2018 version.",0.0,rust
13ds7sy,jjm3dli,"Rust isn't technically backwards compatible, but because the tooling is good, it doesn't matter; in essence it *is* backwards compatible.",0.35,rust
13ds7sy,jjm3dli,"And heck, even Python when used with pip, pyenv, and virtualenv, which still isn't as good as cargo, allows you to run old code without much hassle.",0.3333333333333333,python
13ds7sy,jjm3dli,"So basically what I'm saying is backwards compatibility, if defined as being able to use old code in an unmodified state for many years, is very very important, but backwards compatibility, if defined in terms of implementation - the language itself a la C++, is going to hold you back, and you should put your dev time into a good package manager which, if done right, should give you that first kind of backwards compatibility for free a la Rust.",0.38557142857142856,c++
13ds7sy,jjm3dli,"So basically what I'm saying is backwards compatibility, if defined as being able to use old code in an unmodified state for many years, is very very important, but backwards compatibility, if defined in terms of implementation - the language itself a la C++, is going to hold you back, and you should put your dev time into a good package manager which, if done right, should give you that first kind of backwards compatibility for free a la Rust.",0.38557142857142856,rust
13ds7sy,jjm3je2,(see python 2 -> 3 and scala 2 -> 3).,0.0,python
13ds7sy,jjm3je2,(see python 2 -> 3 and scala 2 -> 3).,0.0,scala
13ds7sy,jjmzmn1,"For example, the C++ std::string transition in GCC 5 is somewhat handled by `abi_tag` but that requires a bunch of manual work which better tools would've done for us.",0.5,c++
13ds7sy,jl9f972,Programs in R are probably quite extreme in that they are often treated as a short-term sratchbook.,-0.125,r
13djghc,,"The idea is that the program acts as, essentially, a compilation script for itself, allowing for Python-like flexibility at compile time with the runtime performance of C++.",0.0,c++
13djghc,,"On the one hand, I do like Rust's style of passing by move-value by default.",0.0,rust
13djghc,,"Ideally, I want the core part of the language to only contain the elegant bare minimum, and the rest of the language to be implemented as part of the standard library (the way Python does it).",0.29,python
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,c++
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,rust
13djghc,,"So, I'm looking for a simple and elegant solution, that would also not be too unfamiliar for programmers coming from C++, Rust or Python.",0.25,python
13djghc,jjlumgt,"Call me old school, but I've always appreciated Java's everything is a reference and references are passed by value.",0.15000000000000002,java
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,c++
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,rust
13djghc,jjplij0,"The first problem is to put C++, Rust, and Python in a room together.",0.25,python
13djghc,jjplij0,C++ templates are Turing complete.,0.1,c++
13djghc,jjplij0,I imagine Rust macros probably are too.,0.0,rust
13djghc,jjplij0,And of course Python has `eval` and the various introspective bits.,0.0,python
13djghc,jjno1oi,"Most mutable parameters should have Rust's ""borrow"" semantics, which are marked by an \`@\` at both declaration and use:      /fn inc @v[#Var #I32] => @v.update (x => x+1)          @my_var << /var 42[#I32]     /do inc @my_var     /do @os.stdout.write_line ""updated value is {my_var.get}""  Ownership transfer of resources is also available.",0.3333333333333333,rust
13djghc,jjm4oot,"In general, I don't want to force a garbade collector, so object ownership and lifetimes are handled akin to C++ and Rust.",0.05000000000000002,c++
13djghc,jjm4oot,"In general, I don't want to force a garbade collector, so object ownership and lifetimes are handled akin to C++ and Rust.",0.05000000000000002,rust
13djghc,jjlv9jy,"Python does the same thing, and I like it, but as you've said, it isn't appropriate without a garbage collector",0.25,python
13djghc,jjpmeru,"To be honest, you can already do pretty much that in Python.",0.35000000000000003,python
13djghc,jjpmeru,"My approach is just a bit more formal, with a stricter type system and some neat things that can't be conveniently implemented in Python (like traits and macros).",0.5,python
13djghc,jjnzh50,Immutable reference is not the same as C's const-reference.,0.0,c
13djghc,jjplslr,The issue was that I basically want the same code to be viable as a constexpr (in C++ terms) function.,0.0,c++
13d2l4r,jjk70uh,"> Generics are a Nightmare  I made a conscious choice not to pursue generics in my language and I'm glad to know that I saved myself a lot of pain 🙂  Vale's region borrowing seems pretty cool though, and I'll be interested to check it out once the design has been iterated and streamlined a bit more.",0.325,cool
13cyl98,jjiznr3,"Examples are ""C"" array, union, enum, or ""Pascal"" file of, set of.",0.0,c
13cyl98,jjiznr3,"Examples are ""C"" array, union, enum, or ""Pascal"" file of, set of.",0.0,pascal
13cyl98,jjiznr3,"Of course, ""C"" types like ""int"", ""uint*"" or ""Pascal"" types like ""byte"" or ""integer"" are subitems of ""Integer"".",0.0,c
13cyl98,jjiznr3,"Of course, ""C"" types like ""int"", ""uint*"" or ""Pascal"" types like ""byte"" or ""integer"" are subitems of ""Integer"".",0.0,pascal
13cyl98,jjiznr3,"The hierarchy starts with a conceptual abstract root type item, like C# or Java ""object"", but also applied to simple types, not just classes.",0.0,c
13cyl98,jjiznr3,"The hierarchy starts with a conceptual abstract root type item, like C# or Java ""object"", but also applied to simple types, not just classes.",0.0,java
13caf1f,jjq3l8y,Pascal P-Code is surprisingly elusive to track down.,0.2722222222222222,pascal
13caf1f,jjq3l8y,"My stuff is designed to be ultra-simple in usage, for example everything needed to run these demos is listed:      c:\demo>dir     11/05/2023  11:40                58 hello.pcl     11/05/2023  11:42            95,744 pci.exe          c:\demo>type hello.pcl      proc main          loadimm ""Hello""          printstr          stop      end          c:\demo>pci hello     Hello  To run any PCL source file, you need just two things: the source file, and the interpreter (or its compiler when it's ready).",0.18333333333333335,c
13caf1f,jjq3l8y,"This is pretty much the same as it works using ASM:      c:\demo>dir     25/03/2023  14:42           145,920 aa.exe     11/05/2023  11:49                85 hello.asm          c:\demo>type hello.asm     main::                              # (:: exports the name)         mov D10, hello         call puts*                      # (* imports the name)         mov D10, 0         call exit*          hello:         db ""Hello"",0          c:\demo>aa hello     Assembling hello.asm to hello.exe          c:\demo>hello     Hello",0.15416666666666667,c
13caf1f,jjsm70h,"The story goes that the original Pascal compiler was written in Pascal to begin with, and then manually (painstakingly) compiled to P-code.",0.375,pascal
13caf1f,jjsm70h,"Because Pascal is designed for one-pass compilation, it's also entirely possible that partial versions of the compiler might have generated code for other parts.",-0.075,pascal
13caf1f,jjkwszk,"The original may have been coded in assembly (probably using one I wrote), or possibly was cross-compiled from an 8-system, itself bootstrapped from assembly.",0.1875,assembly
13caf1f,jjkwszk,"But I can generate renderings of sources in C, or my ASM (or now PCL), and work from those if need be.",0.0,c
13caf1f,jjtbzwj,I haven't actually used Pascal since I was at college in the late 70's.,-0.15,pascal
13caf1f,jjtbzwj,"But then I tracked down what I believe are the actual [sources](http://pascal.hansotten.com/px-descendants/dec-pdp-10-pascal-compiler/) for Pascal on PDP10, and the main compiler is 12Kloc (plus a 4Kloc file for the library.",0.0037037037037036904,pascal
13caf1f,jjtbzwj,"From what I can see of it, it directly generates PDP10 assembly ('MACRO10') mnemonics, not P-Code.",0.1,assembly
13caf1f,jjtbzwj,"(As it happened, my first compiler was a college project, for a machine-oriented language, that also generated PDP10 assembly code, and was written in assembly too.",0.25,assembly
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,javascript
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,kotlin
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,swift
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,rust
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,go
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,elixir
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,java
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,haskell
13c53kf,jjecylm,"Most languages by now either have some variant of async / await (JavaScript, Kotlin, Swift, Rust) or super-lightweight threads (Go, Elixir, Java via Project Loom), or they just have Monads which supersede coroutines entirely (Haskell, Scala).",0.25,scala
13c53kf,jjecylm,"It's at the point where [some say a language isn't suitable for production if it doesn't have good multicore support](https://news.ycombinator.com/item?id=35852321#unv_35855074) (also see Rust speeding through getting async/await *even though they already had `Send + Sync`*, and looking to add async traits).",0.625,rust
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,python
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,c++
13c53kf,jjecylm,"Even Python and C++ have coroutines now, and of course there is a [coroutine library for C which uses macros and low-level magic](https://github.com/hnes/libaco).",0.0,c
13c53kf,jjecylm,"This is what TypeScript is: you have some typed values and untyped values, and want to verify and possibly optimize the typed code while permitting the untyped code; thus, the user is able to take an existing untyped codebase and ""gradually"" add types.",0.25,typescript
13c53kf,jjecylm,"Besides JavaScript/TypeScript, you'll find gradual typing on pretty much any other popular untyped language including [Python](https://docs.python.org/3/library/typing.html), [Lua](https://github.com/andremm/typedlua), and [Racket](https://docs.racket-lang.org/ts-guide/).",0.23125,python
13c53kf,jjecylm,"Besides JavaScript/TypeScript, you'll find gradual typing on pretty much any other popular untyped language including [Python](https://docs.python.org/3/library/typing.html), [Lua](https://github.com/andremm/typedlua), and [Racket](https://docs.racket-lang.org/ts-guide/).",0.23125,lua
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,typescript
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,kotlin
13c53kf,jjecylm,"TypeScript, Kotlin, and Swift all have this.",0.0,swift
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,rust
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,haskell
13c53kf,jjecylm,"Most functional languages like Rust, Haskell, and OCaml probably will never have it because explicit pattern matching achieves essentially the same thing, it's more useful for languages like TypeScript where you already have code checking for subtypes via `if`.",0.26,typescript
13c53kf,jjecylm,"Rust has them and is doing great, Haskell has implemented them as a “new experimental”-kind of thing.",0.40909090909090906,rust
13c53kf,jjecylm,"Rust has them and is doing great, Haskell has implemented them as a “new experimental”-kind of thing.",0.40909090909090906,haskell
13c53kf,jjecylm,"Other languages are looking to incorporate some variant or alternative to Rust’s borrowing rules: [Mojo (the hyped-up “AI” language) includes them](https://docs.modular.com/mojo/programming-manual.html#argument-passing-control-and-memory-ownership), and [Val-lang](https://www.val-lang.dev/) has mutable value semantics which are similar.",-0.2916666666666667,rust
13c53kf,jjecylm,[Swift has first-class “actors” and “distributed” methods](https://www.swift.org/blog/distributed-actors/).,0.0,swift
13c53kf,jjecylm,"[Unison](https://www.unison-lang.org/), Erlang, and Elixir are built with distributed being one of the #1 concerns.",0.0,erlang
13c53kf,jjecylm,"[Unison](https://www.unison-lang.org/), Erlang, and Elixir are built with distributed being one of the #1 concerns.",0.0,elixir
13c53kf,jjecylm,"Scala has [Akka](https://akka.io/) and is used WIDELY for distributed); whereas something like linear types and typed effects, you can't emulate in a library.",-0.1,scala
13c53kf,jjecylm,"People are also working on Effect systems for Haskell ([eff](https://github.com/hasura/eff), [fused-effects](https://hackage.haskell.org/package/fused-effects), [effet](https://hackage.haskell.org/package/effet)).",0.0,haskell
13c53kf,jjecylm,This is *not* in most general-purpose programming languages and probably never will be (maybe we'll see formal methods to verify unsafe code in Rust...) because it's a ton of boilerplate (you have to help the compiler type-check your code) and also extremely complicated.,-0.033333333333333326,rust
13c53kf,jjecylm,Google’s compiler works on C++.,0.0,c++
13c53kf,jjecylm,"These papers have the real bleeding-edge stuff, most of which are super dense proof-of-concepts, and it may literally take decades for these ideas to go into a real-world production compiler.",0.3444444444444444,go
13c53kf,jjeiync,"Brownie points for bringing up homomorphic encryption - its super duper cool stuff, and I don't see it brought up often enough.",0.22777777777777777,cool
13c53kf,jjfpibn,We're seeing a lot of work in the formal methods area and it's what I'm most excited about for existing languages -- projects like RefinedC that add refinement types and ownership types to C (using [[attributes]]...) and using them to automatically generate a proof of program correctness by guided search using the language semantics to tip off the search.,0.4375,c
13c53kf,jjfpwd6,"Rust demonstrating that there can be memory safety without runtime garbage collection seems like a big deal, and I would expect more languages to use similar systems, but try to require less information from the programmer (lifetime specifiers etc).",0.08333333333333334,rust
13c53kf,jji6y27,"Ada had full typing (you can do gradual too), tasking and distributed (in an annex) from the start.",0.35,ada
13c53kf,jjlczgs,"For me, I am hoping for an APL revival; all of what Python/numpy/AI is doing are APL but very verbose.",0.2,apl
13buw08,jjdosl4,\- Reference capabilities similar Rust borrow checker but expanded.,0.0,rust
13buw08,jjdosl4,"\- Data sharing with actors without (necessarily)  copying all the data (like Erlang, if I understand this correctly) .",0.0,erlang
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,rust
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,python
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,c
13bodyk,,"So i am working on a custom programming language that I plan to make,I am following some tutorials and have a lexer written in rust for it,I plan to make it compiled,here is a concept I made      ~Comments are made by a tilde          ~the following code shows different import ways     use Somelib::*;     ~imports all contents     use Somelib::{Something as SomethingElse,SomethingToo};     ~shows how to import multiple items and also Import something with another name     ~also like Python,The filenames work as the namespace          ~This Shows to how to make a class     Pub Sealed class SomeClass : AbstractClass, IInterface     {     	~Naming Standards     	~private/protected variables: camelCase with an underscore like this _variable     	~public variables : camelCase     	~Functions/constantss/properities/classes/structs/enums&enumvalues : PascalCase     	          	~You need to manually add Priv to make a field private or Pub to make a field public and also Protc To make fields protected     	~The class Types are similar to C#,there is Sealed,Abstract,Partial     	~Variables are Declared via the Var keyword,followed by their name and their type and value;     	Var SomeVariable : Int = 1;          	~Mutable     	Priv Var _foodBar : Str = Str::New;	     	~Immutable and Auto keyword(similar to the auto keyword from C++)      	Priv Let _lasagna : Auto = 100;     	~Const(only works with primitives and is the same as C#) and nullable Value Types     	Priv Const Sandwich : Nullable<Bool> = null;     	~Static Vars can by only 1 instance,to access static variables,you need ClassIdentifier::staticVariable,they work the same as C#     	Pub Static eggSalad : Tuple<Int,Str> = Tuple::New<Int,Str>(399,""Salag"");     	~Attributes,to call one you must use a @ followed by the their name     	@Clamp(1,10)     	Var ClampedDecimal : Dec = 0.2;          	~Properities are created by the Prop keyword     	Pub Prop SomeProperity : Str = {get => FoodBar,set => FoodBar = value + ""Hello"" };     	~You can Also create a Quick Readonly Properity     	Pub Prop LasagnaProp : Auto => Lasagna;     	~Quick get and set Access properites can also be made     	Pub Static Prop EggSalad : Auto -> GetSet<>(eggSalad)                    	~The val keyword is used to pass by value,also Functions can return values     	Pub Fn SomeFunction(val num1 : Int,val num2 : Int) : Int     	{     		return num1 + num2;     	}          	The ref keyword is used by to pass by reference,To make a function return no value we use the void keyword     	Pub Fn SomeFunction2(ref num : Int) : void     	{     		num = 1;     	}          	~ we can override Fnctions using the override keyword,these can be either virtual or Abstract Fnctions;     	Pub override Fn OverrideFunction() : void => base.OverrideFunction();     	~also as seen,we can have 1 line methods           	~Interface Funcctions must be Public,also you don't use Fn,you use the Interface Function's name      	Pub InterfaceFunction() : void     	{     		~Simple If statments can be made using a question mark,there still is the normal if statment     		FoodBar == Str::Empty ?",0.1482456140350877,c++
13bodyk,,""");     	}     	     	~We can create static Fnctions via the static keyword     	Pub static Fn StaticFunction() : Int => 1;          	@extern(""Original Function"")     	~As expected,extern Fnctions are made using the extern keyword     	Pub extern Fn ExternalFunction();     }          ~We can extend a classes,allowing for more Functionality,this is to not be mistaken with inheritance     Pub class SomeClassExtension :: SomeClass     {     	~We can add additional Functions,but not additional Variables or Properities     	Pub Fn ExtensionFunction() : bool     	{     		~for loops work similar to kotlin,except we use a struct called range that takes a Uint     		~incase we want an inclusive range, we use Range::NewInclusive     		For (i in Range::New(1,10))     		{     			Log(i);     		}     		~While loops work as expected     		While (True)     		{     			Break;     		}     		~Match is used to returning values to variables     		Let sushi : Auto = Match(Random::RangeInclusive(0,5))     		{     			1 => 3,     			2 => 4.75,     			3 => True,     			value > 3 => ""WOW!",0.31,kotlin
13bodyk,jjeo08u,"I actually mad a trick to extend sealed classes in C# and Java ( Decorator Software Pattern), like stringbuilder class  * It's very good your P.L.",0.14249999999999996,c
13bodyk,jjeo08u,"I actually mad a trick to extend sealed classes in C# and Java ( Decorator Software Pattern), like stringbuilder class  * It's very good your P.L.",0.14249999999999996,java
13bodyk,jjg37oz,"Sorry,but I don't understand the first one,do you mean I should let people decided how the objects identifiers are named?,cuz i plan to let them to do that,it's just a something like snake_case for rust and PascalCase for C# By extending class,you can add methods that don't exist in that class,think of it like traits from rust or extensions from C# So I shouldn't add sealed classes?,I could do that,I thought it could be useful,so as stuff that shouldn't be inherited from should be sealed  Thanks for the compliments on props and access stuff,I also plan to add stuff like modules(similar to static classes from C#,but importing them automatically gives you the methods without the need to type of the static class name)",0.22749999999999998,rust
13bodyk,jjg37oz,"Sorry,but I don't understand the first one,do you mean I should let people decided how the objects identifiers are named?,cuz i plan to let them to do that,it's just a something like snake_case for rust and PascalCase for C# By extending class,you can add methods that don't exist in that class,think of it like traits from rust or extensions from C# So I shouldn't add sealed classes?,I could do that,I thought it could be useful,so as stuff that shouldn't be inherited from should be sealed  Thanks for the compliments on props and access stuff,I also plan to add stuff like modules(similar to static classes from C#,but importing them automatically gives you the methods without the need to type of the static class name)",0.22749999999999998,c
13bodyk,jjdb0ur,"The tilde is a bitwise operator in C, it’s not some unused symbol like you’re saying.",0.0,c
13bodyk,jjgekty,6-you mean the same ones from rust?,-0.15625,rust
13bodyk,jjggo87,"Also, I have no idea if you know, but every object in my language requires an access setting(I find it makes the variables look nicer 5-sounds actually okay 6-i may try to add them like the ones in rust since they are only ones I know,but I still have yet to figure out how they work in rust other than the fact you need to unwrap them 7-i meant something like      If thing {     DoSomething();     }",0.125,rust
13bfvx5,,"Users should be able to add their own IO by wrapping Charm around embedded Go, it shouldn't be something that can be done only by me by hard-wiring stuff.",0.3666666666666667,go
13bfvx5,,Charm is a [Functional Core/Imperative Shell language](https://github.com/tim-hardcastle/Charm/blob/main/docs/functional-core-imperative-shell.md).,0.0,shell
13bfvx5,,"And that last question is very much asking ""What should the imperative shell of a FC/IS language look like?""",0.13,shell
13bfvx5,,because the imperative shell is there to do only two things — mutate the state and do IO.,0.0,shell
13bfvx5,,"Looking at the outside world is impure and must be done in the imperative shell by issuing imperative *commands*, as demonstrated here in the REPL (having first run a script declaring a variable `z` to keep data in):      #0 → get z from Random 6                                                                 ok     #0 → z      5     #0 → get z from UnixClock SECONDS      ok     #0 → z      1683493967     #0 → get z from Input ""What's your name? """,0.15,shell
13bfvx5,,"If there's a Go library for talking to something, it's a work of minutes for anyone who pleases to write their own `get` and `put` and `post` and `delete` commands for accessing it.",0.6,go
13bfvx5,,Here's some IO in the wild: this is the entire imperative shell of [my little example adventure game](https://github.com/tim-hardcastle/Charm/blob/main/examples/adv.ch).,-0.029166666666666664,shell
13bfvx5,,"Note how in the imperative shell you can create local variables by assigning things to them, and that there's an imperative `loop` construct — at this point the functional core of Charm and its imperative shell are pretty much two languages unified by a type system.",0.15,shell
13bfvx5,jjb2ep3,Can you elaborate on how this differs from Haskell's use of the IO monad?,0.5,haskell
13bfvx5,jjb2ep3,Your `get` is very similar to the `x <- readFile ...` notation of Haskell's `do`-notation (which is sugar for the `>>=`operator).,0.0,haskell
13bfvx5,jjb2ep3,"Haskell has nothing corresponding to `put`, `post` or such things - that's usually just done by IO actions that return a unit value.",-0.125,haskell
13bfvx5,jjb2ep3,"Haskell's IO model is not perfect, mostly in that it is not possible to limit exactly *which* kinds of IO are possible, but it is probably the most widely used system that delimits pure and impure code in a principled manner.",0.10803571428571429,haskell
13bfvx5,jjb2rtg,"I think you'll find the ""imperative shell"" part grows and grows.",0.0,shell
13bfvx5,jjbkire,"You don't even really need a wrapper language, you can kinda just choose to write a functional subset of Go.",0.2,go
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,python
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,java
13bfvx5,jjbkire,"I demonstrate this for Python, Java, and Javascript [here](http://www.danielbrice.net/blog/the-io-rosetta-stone/).",0.0,javascript
13bfvx5,jjb346j,"**""How a functional programming based shell / console would look instead of an imperative programming based shell / terminal ?",0.0,shell
13bfvx5,jjb346j,"""**  Ok, the prompt may start similar:      [$root]:   Usually, a console / terminal / shell, would receive an imperative / procedural instruction, with additional parameters or subinstructions, like this:      [$root]: list *  That's an imperative / procedural instruction.",-0.25,shell
13bfvx5,jjb346j,"**  In an imperative console that would be either a command or assignment like this:      [$root]: set path = ""\mydir""  The same operation with a functional syntax may be:      [$root]: path -> ""\mydir""  The same previous list directory example, redirected to a file variable would be ( imperative) :      [$root]: list * >> ""list.txt""  The same example to the console as a file variable may be ( imperative ):      [$root]: list * >> stdin  The same example to the console as a file variable may be ( functional ):      [$root]: stdin -> (list ( ""*"" ) )  If you need a full BASH alike shell script, these previous examples should be adapted as F.P.",-0.3111111111111111,bash
13bfvx5,jjb346j,"**  In an imperative console that would be either a command or assignment like this:      [$root]: set path = ""\mydir""  The same operation with a functional syntax may be:      [$root]: path -> ""\mydir""  The same previous list directory example, redirected to a file variable would be ( imperative) :      [$root]: list * >> ""list.txt""  The same example to the console as a file variable may be ( imperative ):      [$root]: list * >> stdin  The same example to the console as a file variable may be ( functional ):      [$root]: stdin -> (list ( ""*"" ) )  If you need a full BASH alike shell script, these previous examples should be adapted as F.P.",-0.3111111111111111,shell
13bfvx5,jjb346j,"**I would not force the use of an assignment ( ""->"" ) to everything, only when required, and instead try a practical ""LISP"" alike, lists with parentheses syntax instead.",0.0,lisp
13bfvx5,jjbo6s4,Is this meant to be an interactive shell?,0.0,shell
13bfvx5,jjbo6s4,Keywords are fine for scripts but I'd go nuts having to type them out all the time in an interactive session.,0.4166666666666667,go
13bfvx5,jjbi0mq,>Can you elaborate on how this differs from Haskell's use of the IO monad?,0.5,haskell
13bfvx5,jjbi0mq,I'm not a big expert on Haskell.,0.0,haskell
13bfvx5,jjbi0mq,The way they are *similar* is that Charm and Haskell are both functional languages dealing with how you do IO.,0.0,haskell
13bfvx5,jjbi0mq,"The reason they're *different* is that the FC/IS paradigm just says --- what the heck, you *can* mutate state by imperatively importing data --- *so long as you're still in the imperative shell*.",-0.025,shell
13bfvx5,jjbi0mq,Whereas I couldn't give you a detailed breakdown of how Haskell monads work but I'm sure it isn't like that.,0.45,haskell
13bfvx5,jje7e1m,Am I wrong or does this look like Haskell IO monad in disguise?,-0.5,haskell
13bfvx5,jjdsl00,"No, it's ""shell"" as in ""shell of the code"".",0.0,shell
13bfvx5,jjdsl00,"So all your imperative-ness is reduced to about 1% of your code which lives right at the top of your call stack --- the ""imperative shell"" of your code.",0.39285714285714285,shell
13bfvx5,jjdsl00,"The ""imperative shell"" is the `main` function --- all 13 lines of it --- and everything everywhere else is pure and immutable.",0.19047619047619047,shell
13bfvx5,jjchhqy,"You can do the same in Haskell if you are in IO:      main :: IO ()     main = do         myVar <- newIORef ""foo""         modifyIORef myVar (<> ""bar"")         putStrLn =<< readIORef myVar // prints `foobar`  The IORef could be imported from somewhere else.",0.1111111111111111,haskell
13bfvx5,jjbofgd,Overlooking nesting is how Promises in Javascript got to be [fundamentally broken](https://github.com/promises-aplus/promises-spec/issues/94).,0.0,javascript
13bfvx5,jjbooxw,I'd rather write Charm than Go any day :-),0.5,go
13aobtm,,"I am gravitating towards `!` because I am most familiar with C#, Java and other curly-brace languages.",0.25,c
13aobtm,,"I am gravitating towards `!` because I am most familiar with C#, Java and other curly-brace languages.",0.25,java
13aobtm,,": {""Alice"", ""Bob""}  Eew!",-0.9375,alice
13aobtm,,"This looks a lot better (IMO):      name ~: {""Alice"", ""Bob""}  So I am torn: Should I go for familiarity (least surprise) `!` or for aesthetics `~` or some other option?",-0.1875,alice
13aobtm,,"This looks a lot better (IMO):      name ~: {""Alice"", ""Bob""}  So I am torn: Should I go for familiarity (least surprise) `!` or for aesthetics `~` or some other option?",-0.1875,go
13aobtm,,"(Length >= 1 && Length <= 30)          // The set of names already taken     TakenNames = allowableNames && { ""Alice"", ""Bob"" }          // The set of allowable names that are not taken     AvailableNames = AllowableNames & !TakenNames           // A ""variable"" of the type (member of the set)     myNewName : AvailableNames  The definition of `AvailableNames` uses the complement of `TakenNames`.",0.0,alice
13aobtm,jj8wkn4,I’m seeing a lot of “Do what C does” in the comments.,0.0,c
13aobtm,jj7vjo2,My philosophy is to do what C does unless I have a good reason not to.,0.7,c
13aobtm,jj8gnji,And why use a symbol at all: even C allows you to use `not` and `compl` for `!` and `~` respectively.,0.0,c
13aobtm,jj8hy7s,"A story that might be illuminating: in Lua, the ""not equals"" operator is `~=` instead of the C-style `!=`.",0.0,lua
13aobtm,jj8hy7s,"The reason for this is that Lua was created in Brazil, and [the portuguese keyboard](https://cdn.shopify.com/s/files/1/0810/3669/files/portuguese-brazilian-abnt2-mac-kblayout-unilingual-2021.png) has a tilde on the home row of the keyboard (where the apostrophe/quote key is on a QWERTY keyboard).",0.0,lua
13aobtm,jj9b6od,Given that you have a focus on sets and describe your language as  >  a logic programming language based on set theory  I'd probably stray away from your typical C syntax and try to design it more intuitively for that domain.,0.16666666666666669,c
13aobtm,jj9b6od,"I'd imagine something like  * `/:` as not-member-of operator, * `\` as set difference * `!` as negation of a logical statement (I would go with `~` if it weren't for complement/inverse below) * `~` as function inverse/set complement operator (post-fix makes more sense to me here as well as combining complement with inverse instead of negation)  It would look like this:      a : S     a /: T     b : S\T     !",0.14583333333333334,go
13aobtm,jj9b6od,"(c : S)       // equiv to c /: S     d : S~          // equiv to d /: S     x = f~ <| f x   // f >> f~ = identity  Note that I have a small background in the B method and am thus influenced by (Classical) B, which is itself based on Zermelo–Fraenkel set theory.",-0.20833333333333334,c
13aobtm,jj9b6od,"(c : S)       // equiv to c /: S     d : S~          // equiv to d /: S     x = f~ <| f x   // f >> f~ = identity  Note that I have a small background in the B method and am thus influenced by (Classical) B, which is itself based on Zermelo–Fraenkel set theory.",-0.20833333333333334,d
13aobtm,jj9gd6e,"C has `~` for bitwise NOT (`!` for logical NOT), so it’s still familiar to most people.",0.375,c
13aobtm,jjci9e5,"As long as you don't go with the keyword \`not\`, it's fine,",0.18333333333333335,go
13aobtm,jm6akjc,i use “~” (because my language only has bitwise negation and that’s what C uses for that) but it’s kind of ugly for booleans,-0.033333333333333326,c
13aobtm,jj89827,"The only reason C has two operators, `!` and `~` is because it has no built-in boolean type.",0.0,c
13aobtm,jj8henu,"I had this:      Char = c -> Strings [c,,rest] -> rest     WordBeginChars = Unicode.Letters     WordFollowChars = Unicode.Letters | Unicode.Digits     WordToken = (WordBeginChars>>Char) b >> ZeroOrMore (WordFollowChars>>Char) f <- [b,,f]  `Char` is here a function which will accept any character and produce a parser for it.",-0.75,c
13aobtm,jj87se6,"The symbol abuse in C and its subsequent proliferation in C-derived programming languages is a silly convention established because of the lack of a sufficient number of symbols in early character sets, and some misguided desire to avoid spelling things out with reserved words like ""not"", ""NOT"", or "".NOT."".",-0.13333333333333333,c
13aobtm,jj87se6,"""¬"" is the only right way to go!",0.17857142857142855,go
13aobtm,jj8goe0,"After seeing Rust’s janky syntax, just don’t.",0.0,rust
13aobtm,jj8a09w,"If you're gonna allow non-ASCII, why not go the whole way and just provide all the logical binary operators.",0.225,go
13aobtm,jj844lv,> My philosophy is to do what C does unless I have a good reason not to.,0.7,c
13aobtm,jj8l2gl,Go figure.,0.0,go
13aobtm,jj8k7ly,> And why use a symbol at all: even C allows you to use not and compl for !,0.0,c
13aobtm,jj8k7ly,I had no idea C had support for operators as words!,0.0,c
13aobtm,jj7mqkn,"It’d be nice to have ¬ for mathematical syntax reasons, but it’s better to use a character everyone can type out with a single key press.",0.20571428571428574,d
13aobtm,jj94d6r,Consider `a + b - c - d + e - f`.,0.0,c
13aobtm,jj94d6r,Consider `a + b - c - d + e - f`.,0.0,d
13aobtm,jj8pkj4,This thread has helped me decide that `!` is indeed the way to go.,0.0,go
13aobtm,jj9izko,"For instance, the standard arithmetic library will supply rewriting rules such that `a = b + c` is rewritten into `b = a - c` if it is known that `b` if *free* and `a` and `c` are *bound*.",0.13333333333333333,c
13aobtm,jj9mzj0,That is so cool.,0.35,cool
13aobtm,jj8j027,"For example, ALGOL was pretty agnostic about the exact syntax details, letting you use beautiful mathematical operators in print, but also letting you type those operators in a way that actually works on your keyboard.",0.27,algol
13aobtm,jj8j027,"Similarly, C's digraphs.",0.0,c
13aobtm,jj8j027,"Similarly, there have been programming languages that invented entirely novel operators, requiring custom keyboards – notably APL.",0.16666666666666666,apl
13aobtm,jj8j027,"Such a language would not catch on nowadays, and APL's modern incarnation in the form of J has [thankfully ASCIIfied the syntax](https://code.jsoftware.com/wiki/APL2JPhraseBook).",0.1,apl
13aobtm,jj89jow,"> ""¬"" is the only right way to go!",0.17857142857142855,go
13aobtm,jj8hbnm,"The ONLY “symbol abuse” in C is that declaring and dereferencing pointers both use the asterisk, that was a bad move and I wish that was different.",-0.23333333333333328,c
13aobtm,jj8juj3,Rust introduced very little novel syntax.,-0.24375000000000002,rust
13aobtm,jj8juj3,The rest is just a fairly bog-standard ML-family language dressed up to look like C++.,0.7,c++
13aobtm,jj87lca,"I also have good reasons, but it also means your language learning materials need to cover integer operators instead of saying “look at C”.",0.7,c
13aobtm,jjavgm3,Can you go into more detail for what sort of functions inverses could be computed by default?,0.5,go
13aobtm,jj8ubo8,Rust has proven that it causes no end of confusion to do that.,0.0,rust
13aobtm,jj8ubo8,Stick very close to C for symbolic operators.,0.2,c
13aobtm,jj8ubo8,"Don't be afraid to add new *keyword* operators, like Python has `is`, `in`, and `not in` (the last is actually two keywords!)",-0.1159090909090909,python
13aobtm,jj858k3,JavaScript.,0.0,javascript
13aobtm,jj8a65i,You could look at how Julia does it.,0.0,julia
13aobtm,jj9c1dr,"Cool, added you to the follow list, so I see some news from you in the future.",0.175,cool
13aobtm,jj9c1dr,"People don't remember precedence tables at all, and they just intuitively go with it.",0.0,go
13aobtm,jj9c1dr,APL family and Smalltalk does not have any precedence.,0.0,apl
13aobtm,jj9c1dr,"Again, APL family has strict right-associativity, which simplifies stuff a lot.",0.0,apl
13aobtm,jj9c1dr,"Simple binary operation could be ""a + b"", ""a b c"", ""a | +"", ""+ && -"", ""a · ∇"" – from these examples it is obvious that white space is significant in some cases.",0.09375,c
13aobtm,jj9c1dr,That could be really cool.,0.35,cool
13aobtm,jj8m6dk,When C and it's operators where designed there wasn't a boolean type.,0.0,c
13aobtm,jj8jz7a,"C may have a bool, but it is not disjoint from integers.",0.0,c
13aobtm,jj8kyth,APL uses keystrokes these days to make those characters.,0.0,apl
13aobtm,jja07bs,"Bro, fn instead of the return type, with the return type on the far right like C++ invented as alternative syntax in C++11  may not technically be inventing new syntax, but it’s still violates the principle of least surprise, which is my entire point.",0.037012987012987004,c++
13aobtm,jj9314v,Genuine comment : how does one type APL at a reasonable pace on a normal keyboard ?,0.25000000000000006,apl
13aobtm,jj93ijz,"Scriptsprog som HyperTalk og MPW Shell brugte mange af disse symboler, og jeg oplevede aldrig at det danske tastatur var et problem, ikke engang i C, selv om ""{}"" var Option-Shift-""("" og "")"", fordi ""\["" og ""\]"" var Option-""("" og "")"", hvilket for såvidt er en ganske fornuftig og logisk placering,som de temmelig sikkert stadig har.",0.0,shell
13aobtm,jj93ijz,"Scriptsprog som HyperTalk og MPW Shell brugte mange af disse symboler, og jeg oplevede aldrig at det danske tastatur var et problem, ikke engang i C, selv om ""{}"" var Option-Shift-""("" og "")"", fordi ""\["" og ""\]"" var Option-""("" og "")"", hvilket for såvidt er en ganske fornuftig og logisk placering,som de temmelig sikkert stadig har.",0.0,c
13aobtm,jj9mes5,"Your language learning materials should never say ""look at C"".",0.0,c
13aobtm,jjfubkr,"But consider the above, but start with      let bound value     // a value is known at runtime, but not at compile time     let f y = bound value  Now the compiler can go through the same steps, but it will have to generate code to ""redo"" them at runtime.",0.0,go
13aobtm,jj8m0l2,Sometimes one would think that C had been deliberately designed to insultingly annoy countries that do not have English as the primary language.,-0.19999999999999998,c
13aobtm,jj8m0l2,"And no, as far as I can tell/recall (I began studying/using C in 1986-87), no European programmer ever asked for trigraphs, I think it was rather the opposite.",0.03333333333333333,c
13aobtm,jj9q3rb,"Really cool concept, if a little overwhelming.",0.22083333333333333,cool
13aobtm,jj9w14l,"But those ops are different enough that I prefer alternate symbols for them, to make clear what is being done without having to first go and hunt for definitions.",0.07,go
13aobtm,jj9w14l,"Such a low precedence for the former I think is unsuitable for bitwise manipulations, and there is also no reason for the latter to have different precedences across `and or xor` (I know C thinks otherwise).",0.0,c
13aobtm,jj9w14l,"My symbols for these ops are:                 type      precedence          not        logical     and                  5, say (I'd have to go and check)     or                   6 (both and,or short-circuit)          inot       bitwise     iand                 3 (same as + -)     ior                  3     ixor                 3  (I can't remember exactly where `iand` etc came from; it might have been from Fortran.",0.041666666666666664,go
13aobtm,jj9w14l,"My symbols for these ops are:                 type      precedence          not        logical     and                  5, say (I'd have to go and check)     or                   6 (both and,or short-circuit)          inot       bitwise     iand                 3 (same as + -)     ior                  3     ixor                 3  (I can't remember exactly where `iand` etc came from; it might have been from Fortran.",0.041666666666666664,fortran
13aobtm,jjb9a9e,C's syntactic innovation that declaration looks like use has been generally considered to be a mistake.,0.05000000000000002,c
13aobtm,jjb9a9e,"This is real C code, written by real C programmers:      int (*(*(foo)(int))(double))(float);  Many curly-brace languages have deviated to some degree from that madness, separating the type syntax more clearly from the expression syntax (and often, disallowing function pointers).",0.3,c
13aobtm,jjb9a9e,"In that regard, Rust's syntax for types and functions is entirely mainstream with contemporary languages, *in particular if you note that it's mostly an ML-family language dressed up with curly braces*.",0.20833333333333331,rust
13aobtm,jjb9a9e,"Since we're in r/ProgrammingLanguages, I'd also like to point out that C style circumfix declarations have a lot of local ambiguity, so you need to parse the entire declaration in order to know what it is (compare also the [""most vexing parse"" in C++](https://en.wikipedia.org/wiki/Most_vexing_parse)).",0.16666666666666666,c
13aobtm,jjb9a9e,"Since we're in r/ProgrammingLanguages, I'd also like to point out that C style circumfix declarations have a lot of local ambiguity, so you need to parse the entire declaration in order to know what it is (compare also the [""most vexing parse"" in C++](https://en.wikipedia.org/wiki/Most_vexing_parse)).",0.16666666666666666,c++
13aobtm,jjb9a9e,"In C, this strongly pushes you towards LR style parsers.",0.4333333333333333,c
13aobtm,jjb9a9e,"In C++, the parser also needs to track a symbol table, potentially requiring the evaluation of templates during the parse.",0.0,c++
13aobtm,jjb9a9e,"In contrast, Rust's syntax makes it possible to clearly separate syntax and semantics in the compiler (at the cost of needing the turbofish `::<T>()` pseudo-operator).",0.05000000000000001,rust
13aobtm,jjb9a9e,"Since all functions follow the structure `fn NAME`, the regex `/\b fn \s+ (r#|\$)?",0.0,r
13aobtm,jj9lkqg,Special APL keyboards have the symbols written on the keys (in addition to regular letters) and an APL mode switch.,0.17857142857142858,apl
13aobtm,jj8kxv9,"Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",-0.08571428571428572,r
13aobtm,jj8kxv9,"Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",-0.08571428571428572,apl
13aobtm,jjgeymw,Raku (and Perl) is really something different.,0.1,perl
13aobtm,jjbxx6a,"I imagine people just don't like the C++ syntax, but it's a very valid point that applies to real generics as well.",0.2,c++
13aobtm,jjaxlky,"I'm not asking you to move on from FORTRAN IV,  I just don't like modern civilisation to continue to be held back by bad compromises that were made unnecessary and obsolete by technological progress at least two decades ago.",-0.24,fortran
13aobtm,jjbuuj0,"rust’s syntax is still unintuitive due to these design decisions, and I don’t like it and I’m not going to.",-0.125,rust
13aobtm,jjbuuj0,Do not design languages with syntax that looks like this unless you want your language to remain niche like rust and haskall.,0.0,rust
13aobtm,jj8rzss,"Having coded a lot of Prolog, one of the issues I found was that it was pretty hard to use another search strategy than the default depth-first search.",-0.020833333333333343,prolog
13aobtm,jj8rzss,":-)      \> Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",0.10952380952380954,r
13aobtm,jj8rzss,":-)      \> Array programming (as in R, Numpy, APL) is probably an easier mental model for handling a collection of values as if it were a single scalar.",0.10952380952380954,apl
13aobtm,jjbhqtm,"Yes you can have finer graduations, but then you end up with a scheme like C's with far too many levels, many arbitrary and unintuitive, which nobody can remember and you end up just using parentheses anyway, so that there was no point.",0.25,scheme
13aobtm,jjbhqtm,"Yes you can have finer graduations, but then you end up with a scheme like C's with far too many levels, many arbitrary and unintuitive, which nobody can remember and you end up just using parentheses anyway, so that there was no point.",0.25,c
13a4id1,jj5j2m6,"""Conceptually"" because pointers are an assembly feature, you can have your programming language have no aliasing, and optimise out some of those copies by using a pointer under the hood.",0.0,assembly
13a4id1,jj5kfw3,"Rust's `fn index_mut<T>(vec: &mut Vec<T>, index: usize) -> &mut T`; if you want to be able to write      list[index] = 5;     return list;  (or, with less syntax sugar)      *list.mut_at(index) = 5;     return list;  then you need to go from having a `&mut Vec<i32>` to a `&mut i32` with `list[index]` and then go back to having the original `Vec<i32>` so that you can return it.",0.17708333333333334,rust
13a4id1,jj5kfw3,"Rust's `fn index_mut<T>(vec: &mut Vec<T>, index: usize) -> &mut T`; if you want to be able to write      list[index] = 5;     return list;  (or, with less syntax sugar)      *list.mut_at(index) = 5;     return list;  then you need to go from having a `&mut Vec<i32>` to a `&mut i32` with `list[index]` and then go back to having the original `Vec<i32>` so that you can return it.",0.17708333333333334,go
13a4id1,jj5kfw3,"Rust manages this with lifetime annotations (where in safe Rust, the borrow checker ensures that mutable references cannot alias anything else).",0.5,rust
13a4id1,jj5kfw3,"Val fixes this essentially by using continuation passing for indexing; the Rust equivalent would be essentially      list.with_mut_at(index, |item: &mut i32| {       *item = 5;     });  and now *this* works, and is just as flexible, since e.g.",0.0,rust
13a4id1,jj5kfw3,"A more practical example would be (just like Rust's `Mutex`) you could define a `Mutex<T>` where you write `mutex.unlock[]` to get a (mutable reference to) the item inside, which will automatically wait to lock it and unlock the mutex when you no longer use the result.",0.5,rust
13a4id1,jj7o69w,"If you go the Rust route and have &unique references, you can internally modify them all you want without aliasing anything externally  Rust has aliasing, but if you just disable it people would just do      string1 = strip(arg);     string2 = escapeHTML(string1);  it wouldn't actually be so bad in Rust's case, a minor inconvenience",-0.07499999999999997,go
13a4id1,jj7o69w,"If you go the Rust route and have &unique references, you can internally modify them all you want without aliasing anything externally  Rust has aliasing, but if you just disable it people would just do      string1 = strip(arg);     string2 = escapeHTML(string1);  it wouldn't actually be so bad in Rust's case, a minor inconvenience",-0.07499999999999997,rust
13a4id1,jj8z4ep,"Hence, Rust uses borrow checking by annotating all (mutable) references with lifetimes.",0.0,rust
139jnyx,,"You either have to set a mask then OR with the mask then XOR, something like this in C:      int bitwise_not(int num) {         // Create a mask with all bits set to 1         int mask = (1 << (sizeof(int) * CHAR_BIT - 1));         mask |= mask - 1;         // XOR the input number with the mask to get its bitwise NOT         return num ^ mask;     }  --- Why do I have to avoid unary operator?",-0.75,c
139jnyx,jj50f27,"Haskell also uses concatenation for function application, but it is higher precedence than arithmetic operators:  * your first example is written `fn1 a 123 65.7` as above * but your second case needs parens:  `fn1 a (123 + 456) (65.7 * 345)` * and unary operators use the same: `fn1 a (123 + 456) (- x)`",0.1,haskell
139jnyx,jj67gmb,"In the above example, the `+` operator has an associativity rule so you can write `[a + b + c]` and don't have to write `[[a + b] + c]`.",0.0,c
139jnyx,jj6c4tu,"In Haskell, all operators are unary.",0.0,haskell
139jnyx,jj6c4tu,"In Forth, words can operate on some fixed number of arguments.",0.1,forth
139jnyx,jj6bay4,Doesn't Julia do this?,0.0,julia
139jnyx,jj2r6ot,"I could think lisp have space sensitivity but since ""operators"" are just function name then it's probably not for lisp.",0.0,lisp
139jnyx,jj2r6ot,There python indentation too but in my language scopes is like C. Is there any other language with prior art that handle such space sensitivity stuff?,-0.041666666666666664,python
13993w0,,"I started learning Python, which is probably a good skill to have, but its feature set where manipulating raw bits is concerned seems to be ... lacking.",0.2346153846153846,python
13993w0,jj2isii,"It seems like you are looking for an array programming language like APL, J, BQN, or, since you mentioned Python, Numpy.",0.0,apl
13993w0,jj2isii,"It seems like you are looking for an array programming language like APL, J, BQN, or, since you mentioned Python, Numpy.",0.0,python
138yw57,,Is there any kind soul that knows the deep knowledge behind programming languages and compilers that would help me on my journey or just help me decide if I wanna go through with this and how to learn it.,0.06666666666666665,go
138yw57,jj0h18t,Write a Forth.,0.0,forth
138yw57,jj0nk6x,"You can start simple and adjust the scope of your project as you go, but I’m certain that the simplest case you have enough time for.",0.07142857142857142,go
138yw57,jj356qn,"If you make a LISP then parsing will be incredibly easy, and if you make it purely functional then performance will be difficult but you can add way fewer things and still have a complete programming language.",0.061904761904761914,lisp
138yw57,jj356qn,Maybe take a look at Scheme in 48 hours and expand upon that.,0.0,scheme
138yw57,jj04c7c,"Or if you wanna go the extra mile, you could try something like Lox or Cool.",0.175,go
138yw57,jj04c7c,"Or if you wanna go the extra mile, you could try something like Lox or Cool.",0.175,cool
138yw57,jj0e2m6,You can investigate Racket — which was once called PLT Scheme (PLT stands for programming language theory).,0.0,scheme
138yw57,jj0e2m6,It’s a variant of Lisp that is tailor-made for such a project.,0.0,lisp
138yw57,jj0e2m6,Common Lisp might be another good choice.,0.19999999999999998,lisp
138yw57,jj05eac,"Well, in the 3rd year of high school, I made a [web-app that converts arithmetic expressions to i486-compatible assembly](https://flatassembler.github.io/compiler).",0.08,assembly
138yw57,jj0fuch,Look at the Kaleidoscope tutorials https://llvm.org/docs/tutorial/ it will go through the process of writing a simple language from the ground up.,0.0,go
138yw57,jj0i4m7,"Python: print(""hello, world!"")",0.0,python
138yw57,jj0i4m7,"C:   #include <studio.h>  float GPA= 4.0;  int main(){     printf(""hello, world!",0.20833333333333331,c
138yw57,jj0i4m7,"Take structs in C, and make everything a struct.",0.0,c
138yw57,jj1n7c6,"And also i learned C (primary lang ) language, Assembly (NASM for linux) deeply.",0.2,c
138yw57,jj1n7c6,"And also i learned C (primary lang ) language, Assembly (NASM for linux) deeply.",0.2,assembly
138yw57,jj1n7c6,Then i tried to implement a one pass compiler in NASM assembly (to learn assembly - i'm learningby doing) 4.,0.0,assembly
138yw57,jj2u03a,"It's so well written, you can follow the explanation and decide whether you want to do it in Java as the book (at least for the tree-walking interpreter) or in another programming language.",-0.3,java
138yw57,jj0pjce,"Yes, so far it looks like I will read the Crafting Interpreters to get the basics in hand and make some POC, look at Forth, Racket and LLVM, then consider the scope of application and get to it.",0.1,forth
138yw57,jj0pjce,"So far Im very excited about it, will be tough for sure, but wouldnt be fun if it wasnt :D",0.33310185185185187,d
138yw57,jj0p2n8,"> > Python: print(""hello, world!"")",0.0,python
138yw57,jj0n2qb,Forth is a stack-based programming language family/environment.,0.0,forth
138yw57,jj0n2qb,I wrote a Forth as part of my degree's first year end project.,0.25,forth
138yw57,jj0o686,"But fair enough, not everyone likes Lisp.",0.35,lisp
138yw57,jj1w2id,If you are serious about PL design you absolutely need to look into a Scheme and Racket is amazing for writing languages.,0.15555555555555559,scheme
138yw57,jj0sopn,That's Lisp.,0.0,lisp
138yw57,jj0sopn,"Now add static typing, manual memory management and in-line assembly so you can write embedded software or operating systems in it.",0.5,assembly
138yw57,jj0sopn,"Obviously as a class project you're not looking to invent the next C, but why not illustrate the potential?",0.0,c
138yw57,jj0sopn,"Here's an example of the in line assembly:  include[stdio.h]  main[void]{  assembly[x64, intel]{  //your code goes here  }  return[0]  }  It doesn't need to be a complicated syntax.",-0.5,assembly
138yw57,jj0sopn,"Declare the assembly data structure in the main structure, supply the architecture and syntax as the parameters, and fill in your instructions inside that block.",0.16666666666666666,assembly
138yw57,jjldxzm,"You can go down the rabbithole as far as you want with a Forth; making it on LLVM, making your own VM etc.",0.18148148148148147,go
138yw57,jjldxzm,"You can go down the rabbithole as far as you want with a Forth; making it on LLVM, making your own VM etc.",0.18148148148148147,forth
138yw57,jj10fzg,"> that's lisp  Yeah and that was the joke, lol",0.8,lisp
138yw57,jj14jyg,> That's Lisp.,0.0,lisp
138yw57,jj14jyg,"Now add static typing, manual memory management and in-line assembly so you can write embedded software or operating systems in it.",0.5,assembly
138yw57,jj11oui,"Anyway, I actually had the idea originally as an esolang, where everything is a C struct.",0.1875,c
138swus,jj1g3jp,"I use [Asciidoctor](https://asciidoctor.org/), [highlightjs](https://highlightjs.org/), a custom highlight.js language definition and that bash script:      #!/bin/bash     asciidoctor spec.adoc     ex spec.html <<eof     11 insert     <link rel=""stylesheet"" href=""https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/routeros.min.css"">     <!-- other hljs definitions I need (C, x86asm, etc..) -->     .",-0.125,bash
138swus,jj1g3jp,"I use [Asciidoctor](https://asciidoctor.org/), [highlightjs](https://highlightjs.org/), a custom highlight.js language definition and that bash script:      #!/bin/bash     asciidoctor spec.adoc     ex spec.html <<eof     11 insert     <link rel=""stylesheet"" href=""https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/routeros.min.css"">     <!-- other hljs definitions I need (C, x86asm, etc..) -->     .",-0.125,c
138swus,jj1g3jp,"(The seemingly useless removing-then-rewriting conums at the end is necessary because Asciidoctor writes annotations as HTML in the code to display, prompting highlight.js to fill your console with ""unescaped HTML"" security warnings).",-0.25,html
138swus,jj90o98,"The easiest might just be to give your lexer the ability to turn a token stream into HTML, which you can then style with CSS.",0.0,html
138swus,jj90o98,"Even better, add multiple output format support: HTML, LaTeX, Markdown, etc.",0.25,html
138swus,jjdem9s,"](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site)  Alternatively, you can make the lexer output HTML, render the HTML into an image (pretty much just open it in a browser and take a screenshot), then paste the image in your README.",0.15,html
13872od,jj0xhrh,"Not an objective metric, but a while back I had to implement parsers for a number of languages, and for testing I created a ""stress test"" file for each language ([Lua example](https://github.com/boppreh/structured-editor/blob/master/test_files/full.lua)).",0.0,lua
13872od,jj0xhrh,"- Whether it's a keyword or symbol heavy language, and family type (C, Lisp, something exoteric).",-0.2,c
13872od,jj0xhrh,"- Whether it's a keyword or symbol heavy language, and family type (C, Lisp, something exoteric).",-0.2,lisp
13872od,jj0xhrh,- Surprising rules (I learned some hideous tricks in Python that come in handy when golfing).,0.6499999999999999,python
13872od,jizsh74,"There are languages that just embed SQL, Prolog or Assembly, which, as features, are not really ""big.""",0.0,prolog
13872od,jizsh74,"There are languages that just embed SQL, Prolog or Assembly, which, as features, are not really ""big.""",0.0,assembly
13872od,jizsh74,"To work with my language I have a 1478 lines long highlighting grammar file, of which 985 lines are dedicated to x86-64 Assembly alone; that's 66% of `cmova`, `cmovae`, `cmovb`, `cmovbe` and their friends.",-0.05,assembly
13872od,jizsh74,C# in other words.,-0.125,c
13872od,jj08b1h,"|Language | [Ecstasy](https://github.com/xtclang/) language| |:--|:--| |Target | Interpreter, JVM bytecode (wip), LLVM IR and WASM (planned)| |EBNF | yeah| |AST node types | 95| |Compiler & runtime | 272 kloc (mostly Java, some C, some Ecstasy)| |Class libraries | 119 kloc (pure Ecstasy)| |Tests | 11 kloc|",0.35714285714285715,java
13872od,jj08b1h,"|Language | [Ecstasy](https://github.com/xtclang/) language| |:--|:--| |Target | Interpreter, JVM bytecode (wip), LLVM IR and WASM (planned)| |EBNF | yeah| |AST node types | 95| |Compiler & runtime | 272 kloc (mostly Java, some C, some Ecstasy)| |Class libraries | 119 kloc (pure Ecstasy)| |Tests | 11 kloc|",0.35714285714285715,c
13872od,jj17y5p,"| Language | [Sourcerer](https://gitlab.com/cal-coop/utena/haaden-two/-/tree/master/Code/Sourcerer) | |--|--| | Target architecture | The [Utena VM](https://gitlab.com/cal-coop/utena/utena-specification/-/tree/new-spec) | | EBNF productions | 15 | | AST node types | 10 | | Compiler language | Common Lisp | | Compiler lines of code | 314 | | Tests | 203 lines, 13 unit tests |",-0.3,lisp
13872od,jj1tgm0,"Much better than EBNF.| |AST Node Types|35| |Host Language|Python| |Implementation Code Size|About 2,500 lines of Python.",0.5,python
13872od,jj0bztq,C is a P.L.,0.0,c
13872od,jj0bztq,"<edited>  Two keywords that I would like in C would be ""function"" or ""variable"", for function or variable declarations.",0.0,c
13872od,jj0bztq,Several C based P.L.,0.0,c
13872od,jj0bztq,"C designers did mentioned once, that they did considered add them, but rejected them, due it was required C programs to be as short as possible.",-0.041666666666666664,c
1378d15,,The process forces you to go and learn something first.,0.25,go
1378d15,jisdcgg,> We have a short bus that fetches old ladies from the home to teach our young whipper-snappers to maintain the COBOL systems those same ladies wrote before the Hula Hoop was cool.,0.11000000000000001,cobol
1378d15,jisdcgg,> We have a short bus that fetches old ladies from the home to teach our young whipper-snappers to maintain the COBOL systems those same ladies wrote before the Hula Hoop was cool.,0.11000000000000001,cool
1378d15,jivvvee,Async/await (at least in Rust) can be used to make a single-threaded solution but it is ugly because async/await is more complex than necessary yet lacks some of the desired functionality.,-0.16,rust
1378d15,jisjvrr,"With checked-exceptions *as in Java*, the inject-ee appears to need static annotations about things which are not its proper concern.",0.25,java
1378d15,jiy3cg9,"From this page:  > Haxl is a Haskell library that simplifies access to remote data, such as databases or web-based services.",0.13333333333333333,haskell
1378d15,jj3yrqa,"Off I go on a little tangent…  Linear logic is sometimes referred to as a “logic of resources”, but that’s according to its particular definition of what “resources” are, which may or may not suit your needs.",-0.010416666666666671,go
1378d15,jisptp1,I just believe Java gets it wrong by enforcing the checking in the wrong place.,-0.5,java
1378d15,jitztib,I have found Clojure’s dynamically scoped Vars to be very useful for dependency injection and for mocking effectful functions during testing.,0.39,clojure
1378d15,jitrppl,"Additionally, if you do it the Rust way you force checking all exceptions.",0.0,rust
13761ke,jis2p8e,(c) Profit.,0.0,c
13761ke,jis71v7,"Short version:   > In my language, Assembly and binary jumps and calls are typechecked, as in CPU and memory states are checked by a compiler, using a Dependent Type System (as in, it works by you spelling relations between live data) that specialises types down to the smallest units: values.",0.1202020202020202,assembly
13761ke,jis71v7,"> It also understands Linux and GNU C APIs and ABIs, meaning Undefined Behaviour is impossible.",-0.6666666666666666,c
13761ke,jis71v7,Longer version:   I am designing my language by writing a formal specification and go from there.,0.0,go
13761ke,jis71v7,"> It features, among other things, refinement types, safe GC-less aliasing semantics, automated theorem proving, algebraic effects, and a safe interface abstracting Linux and GNU C APIs, as well as System V’s syscall ABI.",0.2916666666666667,c
13761ke,jis71v7,"Then I go on a bit about how I see ""code (un)safety.""",0.0,go
13761ke,jiv6wt7,"""Hey, fellow logicians, you want some basic logic programming with intuitive syntax, but without all Prolog's hustle?",0.0,prolog
13761ke,jisrw3k,"""The paradigmatic use-case in my head is an SME using Excel and PHP and SQL and Python and duct-tape to run their show.",0.0,php
13761ke,jisrw3k,"""The paradigmatic use-case in my head is an SME using Excel and PHP and SQL and Python and duct-tape to run their show.",0.0,python
13761ke,jita7f7,"In mine it would probably start off like this:      print ""<html> <body>""  So, not easy...",-0.21666666666666667,html
13761ke,jiv4qiu,Minimal instruction set functional LISP but with algabraic effects (at least as i understand them) and open ended macros.,-0.13333333333333333,lisp
13761ke,jiv4qiu,"Once i get this going and dogfood a bit, i am going to go and try a step further and expose the parser rules to the language.",0.0,go
13761ke,jj0411u,"You don’t have to go that far, but still, a good guideline is to try to touch on all the basic narrative points, say about 1 minute (100–200 words) per question:  * Who uses it?",0.26666666666666666,go
13761ke,jis4sj7,ohhhhh that explains why java isn't used that much,0.2,java
13761ke,jjlzctq,:D,1.0,d
13761ke,jitomzi,Rust?,0.0,rust
13761ke,jjsiygf,"Looks like this:      f {in rsi: s64; out rax: s64; call}:         mov rax, 2         imul rax, rsi         ret          //`^T` being pointer syntax, as in Pascal     g {in rsi: ^s64, rdi: typeof f, rdx: s64; out [rsi]; clob rax; call; stack 8}:         push rsi         mov rsi, rdx         call rdi         pop rsi         mov [rsi], rax   //useless but shows NRVO         ret          main {tailcall}:         sub rsp, 8         mov rsi, rsp         mov rdi, f         mov rdx, 21         call g                  mov rsi, [rsi]         add rsp, 8         jmp printInt    Here, the indirect call to `f` via `rdi` causes the two signatures to unify:     - `rsi` is clobbered, but `g` pushes and pops it, so the checker ignores it   - `out rax` is translated to `clob rax`  I could also manually save RAX on the stack by increasing the stack size, at which point the checker would happily let me omit the fact that it is written to.",0.48333333333333334,pascal
13761ke,jjsiygf,"All this also is a learning experience in Assembly and systems programming for me, so I know many details are left out (EFLAGS, FP flags, etc..).",0.25,assembly
13761ke,jjsiygf,"It all is nice in that it's some kind of a programmatically laid out ABI syntax, but there is still an ""Abstract-Concrete Barrier"" where you have to manually write a signature mapping a routine's ABI to a Haskell-like function type and how it must ignore registers and stack data that has been clobbered (EDIT: mainly talking about binary code here, not textual and typed Assembly.",0.45555555555555555,assembly
13761ke,jjsiygf,"jnz somewhere                  sub rsp, 16     //Like in TypeScript and Ceylon         mov [rsp], rdx                  mov rdx, rdi         lea rsi, [rsp+8]         mov rdi, f         call g         mov rax, [rsi]                  mov rdx, [rsp]         add rsp, 16         ret  where `loc: some T` just means that `loc` will be matched over.",0.0,typescript
13761ke,jjsiygf,"As far as GNU C is concerned, I have a file that types the dynamic  jumps, so I guess that's cheating.",0.05,c
13761ke,jiw5jzn,I used to make PHP frameworks for fun before I got interested in compilers.,0.275,php
13761ke,jiw5jzn,"That said, if I ever go back to school to study CS in a State University, I think it'll be to head into public research and join Academia, as I'm not interested in software engineering and the whole idea of selling software.",0.018750000000000003,go
13761ke,jitzbfi,"Where I think I am original is that I'm exploring the Assembly and binary space: all that ported to Typed Assembly, and porting that Assembly analysis to binary code.",0.375,assembly
13761ke,jitzbfi,That's where Linux and GNU C interop comes in: the compiler reads statically linked objects and understands the syscalls and dynamic jumps into glibc.,0.0,c
136xdss,,"Existing languages such as Verilog, and VHDL are absolutely horrible to write in and use very old school syntax and semantics.",-0.29,verilog
136xdss,,"Existing languages such as Verilog, and VHDL are absolutely horrible to write in and use very old school syntax and semantics.",-0.29,vhdl
136xdss,,"I think there is so much room for some new HDLs that can absorb great semantics and learnings from modern languages such as Go, Rust, Python etc.",0.2672727272727273,go
136xdss,,"I think there is so much room for some new HDLs that can absorb great semantics and learnings from modern languages such as Go, Rust, Python etc.",0.2672727272727273,rust
136xdss,,"I think there is so much room for some new HDLs that can absorb great semantics and learnings from modern languages such as Go, Rust, Python etc.",0.2672727272727273,python
136xdss,jis8nqs,A lot of people are using python to simulate now with cocotb.,0.0,python
136xdss,jis8nqs,"And, as others have mentioned, there are a lot of new transpilers for languages based on or subsets of language like python, haskell, scala, and rust.",0.13636363636363635,python
136xdss,jis8nqs,"And, as others have mentioned, there are a lot of new transpilers for languages based on or subsets of language like python, haskell, scala, and rust.",0.13636363636363635,haskell
136xdss,jis8nqs,"And, as others have mentioned, there are a lot of new transpilers for languages based on or subsets of language like python, haskell, scala, and rust.",0.13636363636363635,scala
136xdss,jis8nqs,"And, as others have mentioned, there are a lot of new transpilers for languages based on or subsets of language like python, haskell, scala, and rust.",0.13636363636363635,rust
136xdss,jisldod,You don't like Verilog?,0.0,verilog
136xdss,jisluyw,"There are quite a few innovations in HW design, exactly because nobody really likes Verilog.",0.08333333333333333,verilog
136xdss,jisluyw,"Already mentioned Chisel: https://www.chisel-lang.org/  Bluespec Verilog: https://en.wikipedia.org/wiki/Bluespec  SystemC: https://systemc.org/ (primarily considering  HLS)   Some companies internally mix Verilog with various templating languages such as, oh my, PHP.",0.1,verilog
136xdss,jisluyw,"Already mentioned Chisel: https://www.chisel-lang.org/  Bluespec Verilog: https://en.wikipedia.org/wiki/Bluespec  SystemC: https://systemc.org/ (primarily considering  HLS)   Some companies internally mix Verilog with various templating languages such as, oh my, PHP.",0.1,php
136xdss,jisluyw,"As it has already been mentioned, all those language tools are actually transpilers that generate Verilog, because you need to integrate into a hardware design flow.",0.0,verilog
136xdss,jisluyw,"Now imagine 1) you have some quite advanced language on input, something like Haskell, 2) considerable part of your work happens in the assembly produced by a super advanced optimizing Haskell compiler and done by different people with very different skill sets, 3) aaand, what is worse, sometimes those people get back to you and tell that some particular assembly instructions do not fit for some reason, could you please modify your Haskell code in order to generate slightly different assembly?",0.07272727272727274,haskell
136xdss,jisluyw,"Now imagine 1) you have some quite advanced language on input, something like Haskell, 2) considerable part of your work happens in the assembly produced by a super advanced optimizing Haskell compiler and done by different people with very different skill sets, 3) aaand, what is worse, sometimes those people get back to you and tell that some particular assembly instructions do not fit for some reason, could you please modify your Haskell code in order to generate slightly different assembly?",0.07272727272727274,assembly
136xdss,jir8450,It's based on Scala.,0.0,scala
136xdss,jir8450,Compiles to verilog and that compiler itself is based omMLIR & LLVM.,0.0,verilog
136xdss,jirf57c,Quartz is pretty cool.,0.3,cool
136xdss,jiytiag,"I mean, Verilog as a language, for example, is certainly no worse then something like JavaScript.",-0.056249999999999994,verilog
136xdss,jiytiag,"I mean, Verilog as a language, for example, is certainly no worse then something like JavaScript.",-0.056249999999999994,javascript
136xdss,jis9o4g,And ultimatley they all just generate verilog or vhdl lol,0.8,verilog
136xdss,jis9o4g,And ultimatley they all just generate verilog or vhdl lol,0.8,vhdl
136xdss,jiqpo5g,"Cool thanks for sharing, looks too Haskelly for my tastes   I’d love a bastardisation of Go and Rust",0.35000000000000003,cool
136xdss,jiqpo5g,"Cool thanks for sharing, looks too Haskelly for my tastes   I’d love a bastardisation of Go and Rust",0.35000000000000003,d
136xdss,jiqpo5g,"Cool thanks for sharing, looks too Haskelly for my tastes   I’d love a bastardisation of Go and Rust",0.35000000000000003,go
136xdss,jiqpo5g,"Cool thanks for sharing, looks too Haskelly for my tastes   I’d love a bastardisation of Go and Rust",0.35000000000000003,rust
136xdss,jisup8y,VHDL and Verilog both reduce to a RTL.,0.0,vhdl
136xdss,jisup8y,VHDL and Verilog both reduce to a RTL.,0.0,verilog
136xdss,jisup8y,The main vendors support both VHDL and Verilog.,0.16666666666666666,vhdl
136xdss,jisup8y,The main vendors support both VHDL and Verilog.,0.16666666666666666,verilog
136xdss,jisup8y,I'm no expert but have used VHDL a bit.,0.0,vhdl
136wdfw,,"Many note it doesn't solve their AI development woes, introduce new concepts, and offers hardly more than a Python reskin with a helping of Kotlin/Nim.",0.3090909090909091,python
136wdfw,jirmsnm,"APL with a modern skin and the ability to JIT to Cuda, ROCM, and FPGA.",0.2,apl
136wdfw,jiszcjf,"Easier for math and logic (like Julia), and harder for shared memory and side effects (like Rust).",-0.1,julia
136wdfw,jiszcjf,"Easier for math and logic (like Julia), and harder for shared memory and side effects (like Rust).",-0.1,rust
136wdfw,jiszcjf,Mojo is trying to do that while being a superset of Python to make translation easier.,0.0,python
136wdfw,jiszcjf,"Many people frowned at Typescript at the time for having similar ambitions, and look where we are now.",0.25,typescript
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,rust
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,javascript
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,c++
136wdfw,jiw2vne,"Mech currently works with Rust and Javascript, but C++ and Python are on the list of targets as well.",0.0,python
136wdfw,jisnaim,"Already working on it.. and have been for years :)  Must be: - High performance (as fast or faster than C.. surprisingly I believe we can definitely beat C) - Easy to read and understand output by humans (Can be made easier to read than Python) - Minimize bugs that can make it past compiler and make it very easy to follow errors being thrown - and more  Checkout our very much alpha version of the website (Other than front page.. needs a lot of work, documentation and tutorials aren't real yet)  We would definitely appreciate some help if anyone is interested in helping out!",0.24672619047619046,c
136wdfw,jisnaim,"Already working on it.. and have been for years :)  Must be: - High performance (as fast or faster than C.. surprisingly I believe we can definitely beat C) - Easy to read and understand output by humans (Can be made easier to read than Python) - Minimize bugs that can make it past compiler and make it very easy to follow errors being thrown - and more  Checkout our very much alpha version of the website (Other than front page.. needs a lot of work, documentation and tutorials aren't real yet)  We would definitely appreciate some help if anyone is interested in helping out!",0.24672619047619046,python
136wdfw,jit44ec,"Nothing, because Python already satisfied most needs and has enough momentum as the most popular language alongside JS to maintain that.",0.42000000000000004,python
136wdfw,jit44ec,"---  To create an actual competitor, you would first need to create a better C. AI starts with assembly, but we can assume that a language creator does not have the resources to develop their own platform.",0.3375,assembly
136wdfw,jit44ec,"So C, as a flawed portable assembler, is the first thing that would need to be improved, and you can work hard to make sure this is your lingua franca for programs by porting it to whatever platform there is.",-0.010416666666666685,c
136wdfw,jit44ec,"Then, once you have a better C, you would need a sort of a Java.",0.5,c
136wdfw,jit44ec,"Then, once you have a better C, you would need a sort of a Java.",0.5,java
136wdfw,jit44ec,"And finally, you would need to have a communication layer akin to Python, or rather, an API language.",0.0,python
136wdfw,jit44ec,"There is no way in hell you will get data scientists, which are not just used to high level language syntaxes but also sometimes not that PL savvy, to use this alternative without it at least not being as easy and easily learnable as Python, if not more.",0.09533333333333334,python
136wdfw,jit44ec,"---  **tl;dr** An AI programming language is 3 separate languages chained together: an improved C, an improved Java, and an improved Python/JS/SQL mutant.",0.0,c
136wdfw,jit44ec,"---  **tl;dr** An AI programming language is 3 separate languages chained together: an improved C, an improved Java, and an improved Python/JS/SQL mutant.",0.0,java
136wdfw,jit44ec,This is to be expected since modern AI development is a Python - Framework (IL/CUDA) - C(++)/FORTRAN - ASM chain.,0.05,python
136wdfw,jit44ec,This is to be expected since modern AI development is a Python - Framework (IL/CUDA) - C(++)/FORTRAN - ASM chain.,0.05,c
136wdfw,jit44ec,"No amount of APL copium would make it usable by humans generally and considered approachable for big companies who throw money at it, and make modern AI development possible.",0.0625,apl
136wdfw,jirq0vk,What would a modern skin of APL involve?,0.2,apl
136wdfw,jivyo1p,Matlab does most of that I think?,0.5,matlab
136wdfw,jiqkqch,Consider logic programming languages like prolog and its modern descendents.,0.2,prolog
136wdfw,jiqo8v9,Do we agree that JavaScript is terrible in regards to linear algebra (which is core of machine learning) because it lacks operator overloading?,-1.0,javascript
136wdfw,jiqo8v9,LISP).,0.0,lisp
136wdfw,jiyi58b,"""AI language"" at least should be integrated to python, otherwise this is garbage.",-0.3,python
136wdfw,jiu3v9b,"Modules are an absolute must, as is a very opinionated (rust) cargo-like build tool.",0.2,rust
136wdfw,jiu3v9b,"Load data and set options imperatively, then pure functional with pire functions for the performance intensive bit so the optimizer can go wild.",0.15714285714285714,go
136wdfw,jist58c,>Mostly ASCII instead of cryptic symbols    Why not use machine learning to do APL as it was intended?,0.0,apl
136wdfw,jjleph0,The only people who call APL read-only or linenoise are the people that never wrote anything in it.,0.0,apl
136wdfw,jiw3jjw,Matlab is matlab.,0.0,matlab
136wdfw,jiv7e09,I think this would work really nicely as a DSL in an existing flexi-imperative-functional language like Julia.,0.6,julia
136wdfw,jirr52w,"Prolog, Forth, APL",0.0,prolog
136wdfw,jirr52w,"Prolog, Forth, APL",0.0,forth
136wdfw,jirr52w,"Prolog, Forth, APL",0.0,apl
136wbeh,jiqy8zy,Consider [Haskell](https://www.haskell.org/onlinereport/decls.html) which uses `infix(l|r)?,0.0,haskell
136wbeh,jiqy8zy,An issue with the Haskell design is its limitation to 10 precedence levels.,0.0,haskell
136wbeh,jiqy8zy,The haskell choice for a limited set of precedences was probably a decision made to keep the parsing simple.,-0.03571428571428571,haskell
136wbeh,jiqy8zy,Haskell also allows using *any* non-operator function as an infix operator by surrounding it by \`backticks\`.,0.0,haskell
136wbeh,jiw1km7,"There are all sorts of problems with user-defined operators, especially when you can define new symbolic operators, like `+++`, and more so with named operators:      a b c  Here, `a` and `c` are variables; `b` is a user-defined infix operator.",0.21212121212121213,c
136wbeh,jiw1km7,"Further, user-defined names usually obey scope rules; here:      a b c d e  function `b` has higher precedence than `d`, so it's parsed as `(a b c) d e`.",0.0,c
136wbeh,jiw1km7,"Further, user-defined names usually obey scope rules; here:      a b c d e  function `b` has higher precedence than `d`, so it's parsed as `(a b c) d e`.",0.0,d
136wbeh,jiw1km7,"But further down in a different, perhaps nested scope, `b` and `d` are defined another way so that it is parsed as `a b (c d e)`.",-0.051851851851851864,d
136wbeh,jiw1km7,"But further down in a different, perhaps nested scope, `b` and `d` are defined another way so that it is parsed as `a b (c d e)`.",-0.051851851851851864,c
136wbeh,jiw1km7,"Or maybe there, `a` is prefix unary operator, `c` is an infix one, and `e` is postfix!",0.0,c
136wbeh,jiw1km7,"Whereas, `a + b * c` is ALWAYS parsed as `a + (b * c)` everywhere, as those operators are program-wide; there is only one version of each, and precedences cannot be changed.",0.0,c
136wbeh,jiw1km7,Your scheme is workable; a famous language called 'Algol68' implemented all of the above.,0.25,scheme
136wbeh,jitf1m0,">It is a great advantage when people do not have to guess how something might parse  I agree with you, in my PL you can only override standard operators for your types but you can invent a new one so operators are limited, the current implementation of prefix, postfix and infix functions is that they has the top precedence in their category but I will try to find a cool syntax to allow set custom precedence for them",0.21436688311688312,cool
136wbeh,jiy2qh8,"You are right in this case we may end up with `var a = b c d e f g h i;` 😂,  In my language i don't allow define new operators i only allow override existing operations with the same parsing order",0.10551948051948051,c
136wbeh,jiy2qh8,"You are right in this case we may end up with `var a = b c d e f g h i;` 😂,  In my language i don't allow define new operators i only allow override existing operations with the same parsing order",0.10551948051948051,d
136wbeh,jix43m9,"> You are the only other person I have ever seen propose this,   > nobody is doing it this way  Have a look at this article: https://blog.adamant-lang.org/2019/operator-precedence/    Rust is actually doing it too: https://doc.rust-lang.org/reference/expressions.html#expression-precedence  My language has [this precedence graph](http://lngnslnvsk.net/operator-precedence.drawio.svg).",-0.041666666666666664,rust
136wbeh,jiy3g1x,"That's not what you say in the OP:      @infix fun append_str(f *char, s *char) *char { .... }  And elsewhere in your docs:      @infix fun plus(x int64, y int64) int64 = x + y;  The example usage of the latter is `10 plus 20`, so presumably someone could use it as `a plus c`, and someone could also define an infix function called `b` so that `a b c` is possible!",0.15,c
136u340,,"**Multiple Dispatch:**      type Color {         r: Number[0],         g: Number[0],         b: Number[0]     }          const typeStr = (x: String): String => ""String""     const typeStr = (x: Number): String => ""Number""     const typeStr = (x: Boolean): String => ""Boolean""     const typeStr = (x: Color): String => ""Color""          println(typeStr(""hello""))     println(typeStr(45))     println(typeStr(false))     println(typeStr(Color {}))     println(typeStr([1, 2, 3]))          /*          String     Number     Boolean     Color          Error in 'source' @ (16, 24): Dispatch error in function 'typeStr' - No function found matching args: [ List ]          Available functions:          (x: String) => String     (x: Number) => String     (x: Boolean) => String     (x: Color) => String          */  **Refinement Types:**      import string          extend List {         last: () => self[self.length-1]     }          type IsCSVPath = (x: String) => x.split("".",-0.509090909090909,r
136u340,,""").last() == ""txt""          const open = (fileType: IsCSVPath) => println(""Opening csv file..."")     const open = (fileType: IsTXTPath) => println(""Opening txt file..."")     const open = (fileType) => println(""Opening some file..."")          open(""hello.txt"")          // Opening txt file...  **Literal Types:**      type Color {         r: Number[0],         g: Number[0],         b: Number[0]     }          type RedColor = Color {r: 255}          const isRed = (c: RedColor) => println(true)     const isRed = (c: Color) => println(false)          isRed(Color {g: 255}) // false     isRed(Color {r: 255}) // true  I hope I'm not wrong about the terminology of these features, but either way, huge milestone for the language.",-0.24230769230769234,r
136u340,,""").last() == ""txt""          const open = (fileType: IsCSVPath) => println(""Opening csv file..."")     const open = (fileType: IsTXTPath) => println(""Opening txt file..."")     const open = (fileType) => println(""Opening some file..."")          open(""hello.txt"")          // Opening txt file...  **Literal Types:**      type Color {         r: Number[0],         g: Number[0],         b: Number[0]     }          type RedColor = Color {r: 255}          const isRed = (c: RedColor) => println(true)     const isRed = (c: Color) => println(false)          isRed(Color {g: 255}) // false     isRed(Color {r: 255}) // true  I hope I'm not wrong about the terminology of these features, but either way, huge milestone for the language.",-0.24230769230769234,c
136u340,jirjn1v,"Intersections of functions also can be interpreted as functions taking and evaluating to unions, as `(a -> b & c -> d) <: (a | c) -> (b | d)`.",-0.75,c
136u340,jirjn1v,"Intersections of functions also can be interpreted as functions taking and evaluating to unions, as `(a -> b & c -> d) <: (a | c) -> (b | d)`.",-0.75,d
136u340,jirp2jy,"In languages where we use `=` for functions, we typically shift it to the right, allowing you to read this Scala code as ""f(x) equals/is x times two.""",0.05952380952380952,scala
136u340,jirp2jy,"def f(x) = x * 2  Languages which do that and also have support for pattern matching even allows to express a single function in multiple declarations, like this Haskell code:      map :: (a -> b) -> List a -> List b     map _ [] = []     map f (x : xs) = f x : map f xs  It's still limited to a single function type per function, but in the presence of union and intersection types, you can scale this to encompass overloading and multiple dispatch.",-0.1607142857142857,haskell
136u340,jirpnh9,"It's not that uncommon, Typescript's arrow functions work exactly like that.",0.525,typescript
136u340,jirqkgq,[D kinda does](https://dlang.org/spec/declaration.html#alias-reassignment).,0.0,d
136guzf,,"You may notice that the syntax is similar to class extension in Ruby where you ""open"" a class and insert things inside it.",0.0,ruby
136guzf,jiox1sm,"In regards to accessing other classes' internals, there are some precedents: `friend` in C++, and `internal` in .NET for example.",-0.0625,c++
136guzf,jiqiqxk,Class A contains class B and or class C and delegates calls to them as appropriate.,0.5,c
136guzf,jipm667,"You might want to look into Common Lisp's ""method combinations"", which work because classes and (multi-)methods are decoupled.",-0.3,lisp
136guzf,jiqslgt,"So in C++ like syntax, it would be something like:      boolean LoadBalancer::handleRequest(std::pair<Request, ACL::Principal> request) {         // Use request.second to check that request.first is allowed, then pass control to the existing implementation of LoadBalancer::handleRequest if it passes the check     }   Of course in C++ this would require subclassing LoadBalancer and overloading handleRequest to accept a tuple parameter instead of a plain Request, but I am wondering if it is really necessary to add new “possesses” syntax to express what seems to be a tuple of two or more types that you want to bundle together.",0.10551948051948051,c++
135vslx,jilozlr,"We can acknowledge that `+` can be used inappropriately, and agree to leave the matrix partial, or we can create another operator; Haskell uses `++` for string/list concatenation\* and `<>` for associative operations with identities in general.",-0.024999999999999994,haskell
135vslx,jilozlr,\*Haskell strings are actually just lists of characters - a wonderful decision for ergonomics and a horrible one for performance.,0.0,haskell
135vslx,jin5pc9,But I also got used to `.` in PHP and before long that felt fine too.,0.18333333333333335,php
135vslx,jiv051n,My impression is that most of my colleagues will know at least one of Python or Ruby.,0.1,python
135vslx,jiv051n,My impression is that most of my colleagues will know at least one of Python or Ruby.,0.1,ruby
135vslx,jilwmyt,"I guess it makes sense to not ""cram"" too much but in this case, I imagine a programmer that is familiar with Python, Ruby or JavaScript.",0.2875,python
135vslx,jilwmyt,"I guess it makes sense to not ""cram"" too much but in this case, I imagine a programmer that is familiar with Python, Ruby or JavaScript.",0.2875,ruby
135vslx,jilwmyt,"I guess it makes sense to not ""cram"" too much but in this case, I imagine a programmer that is familiar with Python, Ruby or JavaScript.",0.2875,javascript
135vslx,jimdc9x,"> Python, Ruby or JavaScript.",0.0,python
135vslx,jimdc9x,"> Python, Ruby or JavaScript.",0.0,ruby
135vslx,jimdc9x,"> Python, Ruby or JavaScript.",0.0,javascript
135vslx,jimdc9x,"That is a bug in JS', Ruby's and Python's designs.",0.0,ruby
135vslx,jimdc9x,"That is a bug in JS', Ruby's and Python's designs.",0.0,python
135vslx,jimdc9x,Even PHP of all languages got that one right (it uses `.` which it inherited from Perl; and Perl6/Raku uses `~` which it got from D).,0.2857142857142857,php
135vslx,jimdc9x,Even PHP of all languages got that one right (it uses `.` which it inherited from Perl; and Perl6/Raku uses `~` which it got from D).,0.2857142857142857,perl
135vslx,jimdc9x,Even PHP of all languages got that one right (it uses `.` which it inherited from Perl; and Perl6/Raku uses `~` which it got from D).,0.2857142857142857,d
135tfrc,jim616n,"No Tensor scheduling, shape inference, auto diff, auto GPU memory management, AST manipulation, multi-host utilities etc  Just looks like Zig and Python mixed in some way without introducing any new capabilities",0.06818181818181818,python
135tfrc,jils02e,"For context this is by Chris Latter, of LLVM and Swift fame.",0.0,swift
135tfrc,jiljs4r,"I didn't go through the documentation yet, but the landing page looks like it's a lot of corporate nonsense  * ""a new programming language for all AI developers"" made me think it's a new DSL for describing AI models (which would be interesting), but it's ..python?",0.19318181818181818,go
135tfrc,jiljs4r,"I didn't go through the documentation yet, but the landing page looks like it's a lot of corporate nonsense  * ""a new programming language for all AI developers"" made me think it's a new DSL for describing AI models (which would be interesting), but it's ..python?",0.19318181818181818,python
135tfrc,jiljs4r,"* The very first example you see uses Numpy, so this must be 100% python compatible, so I guess this is like pypy but with maybe some extra features (apparently `struct` is a keyword now)  * Also, why Numpy??",0.125,python
135tfrc,jiljs4r,"Surely, their example `softmax` function spends 90% of its time in C++ anyway.",0.5,c++
135tfrc,jim9ndn,The world really doesn't need another python,0.2,python
135tfrc,jimb4av,So they kinda did the Kotlin approach with Python but in the direction of low-level instead of higher-level abstractions.,0.0,kotlin
135tfrc,jimb4av,So they kinda did the Kotlin approach with Python but in the direction of low-level instead of higher-level abstractions.,0.0,python
135tfrc,jimb4av,"I also like to use type checking, contracts, and option type packages in Python but you'll either have to wrap all the other packages you consume or build an abstraction layer on top of it to provide meaningful benefits.",0.2916666666666667,python
135tfrc,jiontxj,"Thanks, but I am staying with python.",0.2,python
135tfrc,jiontxj,> What’s wrong with Python?,-0.5,python
135tfrc,jiontxj,"> Python has well known problems - most obviously, poor low-level performance and CPython implementation decisions like the GIL  are they serious?",-0.07777777777777778,python
135tfrc,jio9in9,It's really difficult for me to understand what exactly they are doing when python libraries and Julia language exist.,-0.125,python
135tfrc,jio9in9,It's really difficult for me to understand what exactly they are doing when python libraries and Julia language exist.,-0.125,julia
135tfrc,jin14m5,That's like asking C++ to be as fast as C even if you extensively use C++ abstractions.,0.1,c++
135tfrc,jin14m5,That's like asking C++ to be as fast as C even if you extensively use C++ abstractions.,0.1,c
135tfrc,jin14m5,Take a look [at this cool talk](https://www.youtube.com/watch?v=rHIkrotSwcc&t=1s) if you want concrete examples of how C++ is slower if you use all its features.,0.25,cool
135tfrc,jin14m5,Take a look [at this cool talk](https://www.youtube.com/watch?v=rHIkrotSwcc&t=1s) if you want concrete examples of how C++ is slower if you use all its features.,0.25,c++
135tfrc,jin14m5,"It might be a design goal of C++ to have zero-cost abstractions, but it's just not possible.",0.0,c++
135tfrc,jin14m5,Everyone would use this language for everything if it were like Python and as fast as C. It should say enough that Linus Torvalds hard banned C++ in the Linux kernel due to performance concerns.,-0.05416666666666667,python
135tfrc,jin14m5,Everyone would use this language for everything if it were like Python and as fast as C. It should say enough that Linus Torvalds hard banned C++ in the Linux kernel due to performance concerns.,-0.05416666666666667,c++
135tfrc,jin14m5,"(Some Rust is being used now though)  The fact is if you need maximum performance, be prepared to write complex C/Rust/stripped down C++ and even a little assembly from time to time.",-0.21435185185185188,rust
135tfrc,jin14m5,"(Some Rust is being used now though)  The fact is if you need maximum performance, be prepared to write complex C/Rust/stripped down C++ and even a little assembly from time to time.",-0.21435185185185188,c++
135tfrc,jin14m5,"(Some Rust is being used now though)  The fact is if you need maximum performance, be prepared to write complex C/Rust/stripped down C++ and even a little assembly from time to time.",-0.21435185185185188,assembly
135tfrc,jiv3udy,"AI languages should move to be more high level and declarative, not ""pythonic C""",0.33,c
135tfrc,jixnpni,I'm wondering if normal python program can import a module written in mojo ?,0.15,python
135tfrc,jnkb19y,"No, Chris Lattner isn't part of the Modular Team, it's just an impersonator who wants to deceive millions of Python developers!",0.25,python
135tfrc,jimrhop,"Agreed, too early to really comment properly, but it kinda just looks like Nim to me, which is to say Pythonic C.",0.10000000000000002,c
135tfrc,jjvqe7x,"Agreed, my vote for a 1 language solution is Julia.",0.0,julia
135tfrc,jinaaj0,"As I understand it,  > this must be 100% python compatible  It actually has an RTS that incorporates CPython and everything that couldn't get compiled to native code goes through it.",0.0,python
135tfrc,jinaaj0,D is a precedent there.,0.0,d
135tfrc,jinaaj0,"In fact D also has an (optional) RTS with a tracing GC, with features for systems programming including inline Assembly instead of MLIR interop.",0.0,d
135tfrc,jinaaj0,"In fact D also has an (optional) RTS with a tracing GC, with features for systems programming including inline Assembly instead of MLIR interop.",0.0,assembly
135tfrc,jinaaj0,So it looks like Mojo and D live in the same space.,0.06818181818181818,d
135tfrc,jioasdf,I think this project shouldn't exist as a commercial product when something like Python already exists and there is Julia too.,0.0,python
135tfrc,jioasdf,I think this project shouldn't exist as a commercial product when something like Python already exists and there is Julia too.,0.0,julia
135tfrc,jioasdf,With Julia you can use the language like you do with Python but the core libraries are also implemented in Julia itself so if you know Julia you know the core too.,0.0,julia
135tfrc,jioasdf,With Julia you can use the language like you do with Python but the core libraries are also implemented in Julia itself so if you know Julia you know the core too.,0.0,python
135tfrc,jioasdf,For python almost every significant library ends up using C++ and I don't think it would be a pleasant experience for a Python programmer to debug template heavy C++ if things go south.,0.3027777777777778,python
135tfrc,jioasdf,For python almost every significant library ends up using C++ and I don't think it would be a pleasant experience for a Python programmer to debug template heavy C++ if things go south.,0.3027777777777778,c++
135tfrc,jioasdf,For python almost every significant library ends up using C++ and I don't think it would be a pleasant experience for a Python programmer to debug template heavy C++ if things go south.,0.3027777777777778,go
135tfrc,jioasdf,I don't know much about Chris lattner beside him being the creator of llvm toolchain and Swift which I have never used.,0.2,swift
135tfrc,jisz7vk,"I mean, it didn't  really need python to get this big, but here we are -\_-",-0.0375,python
135tfrc,jjvrqjr,Julia is the way,0.0,julia
135tfrc,jio97sm,At some level you will need to write assembly and C. In most other domain software can free ride on hardware so optimization done by a compiler is enough but in numerical computing you will need to extract every bit of performance left.,0.155,assembly
135tfrc,jio97sm,Beside the performance concern C++ is bloated with features and debugging template heavy code is difficult.,-0.35,c++
135tfrc,jio97sm,What they are trying to do is already being done by Julia to some degree which provides good enough speed with python-like syntax.,0.35,julia
135tfrc,jin3a9x,"C has a stack of call frames, which is an abstraction that requires implicitly changing pointers and allocating memory, all of which happens at runtime.",0.0,c
135tfrc,jin3a9x,"We shouldn't use C.  Also, Assembly?",0.0,assembly
135tfrc,jin3a9x,"When I write `mov` in Assembly, the assembler will implicitly deduce which opcodes I actually meant, and may not choose the fastest ones - abstractions!",0.0,assembly
135tfrc,jj3n6rj,"Examples:  The oldest in mind is C++ and C, every C program is a C++ program right?",0.2857142857142857,c++
135tfrc,jj3n6rj,"Examples:  The oldest in mind is C++ and C, every C program is a C++ program right?",0.2857142857142857,c
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,lua
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,crystal
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,ruby
135tfrc,jj3n6rj,"Then we have Terra & Lua, Nelua & Lua, Crystal & Ruby, Red & System, Nim & Python.",0.0,python
135tfrc,jj3n6rj,"Python across the years has also expanded into backend, frontend and databases.",0.0,python
135tfrc,jjajl8f,"In addition to what u/lngns mentioned, there are some enterprise-oriented languages, including Thoroughbred BASIC and some OO language I can't remember the name of that I first saw mentioned on Hacker News (I think it starts with a C?)",0.125,c
135tfrc,jjvrdtq,I totally agree that Julia is already way ahead of Mojo and Python at truly solving by the 2 language problem.,0.0,julia
135tfrc,jjvrdtq,I totally agree that Julia is already way ahead of Mojo and Python at truly solving by the 2 language problem.,0.0,python
135tfrc,jinldw1,"> C has a stack of call frames, which is an abstraction that requires implicitly changing pointers and allocating memory, all of which happens at runtime.",0.0,c
135tfrc,jinldw1,">  > We shouldn't use C.  This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries.",0.21250000000000002,c++
135tfrc,jinldw1,">  > We shouldn't use C.  This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries.",0.21250000000000002,c
135tfrc,jinldw1,Or you could look at [this talk](https://www.youtube.com/watch?v=rX0ItVEVjHc) where yet another very high up programmer basically admits they have to avoid most C++ abstractions due to performance needs.,0.19433333333333333,c++
135tfrc,jinldw1,"> Also, Assembly?",0.0,assembly
135tfrc,jinldw1,"When I write mov in Assembly, the assembler will implicitly deduce which opcodes I actually meant, and may not choose the fastest ones - abstractions!",0.0,assembly
135tfrc,jj7jzt6,Python itself is not performant and also not a good choice for glue code.,-0.35,python
135tfrc,jip2uqp,"> This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries  Absolutely not.",0.15000000000000002,c++
135tfrc,jip2uqp,"> This all sounds great, but if your project needs maximum performance, you're going to be writing C++ that is almost exactly the same as C except for a few luxuries  Absolutely not.",0.15000000000000002,c
135tfrc,jip2uqp,"C, ""C++ that is almost the same as C"" and Rust all are, at the same time, too abstract and not abstract enough, to express optimisations I need.",0.0,c
135tfrc,jip2uqp,"C, ""C++ that is almost the same as C"" and Rust all are, at the same time, too abstract and not abstract enough, to express optimisations I need.",0.0,c++
135tfrc,jip2uqp,"C, ""C++ that is almost the same as C"" and Rust all are, at the same time, too abstract and not abstract enough, to express optimisations I need.",0.0,rust
135tfrc,jip2uqp,"But no, C and its ""functions"" have no idea how to do that, and in fact forbid it, instead hoping that an implementation will realise the memory allocation and ABIs are just right.",0.2857142857142857,c
135tfrc,jip2uqp,"Also, whenever I need asynchronous code (which is, all the time), C is a lost cause because of assumptions with abstract ambient states which it never tells you about and just assumes you as a programmer understand.",0.0,c
135tfrc,jip2uqp,"No I am pointing out the fact that saying ""X and its abstractions are objectively worse than C on every performance-related axes, which is the pinnacle of programming discipline"" while in theory even an Assembler shares the same problems, and while in practice C is defined in ways that make some ""performant code"" impossible to express, is incorrect.",-0.35555555555555557,c
135tfrc,jj8zi04,"One criticism I encountered of Julia is their take on handling third party packages, that you can take packages that were not designed to work together, but still use them together, and everything somehow works.",0.0,julia
135tfrc,jj8zi04,"Going back to python, I think this is not only a software issue but a socio-software issue with people and open source software.",0.0,python
135tfrc,jip9fzf,"Everyone getting paid 500+k/yr to program high performance code uses Rust, C, or a stripped down version of C++ (and I'm honestly not sure if Rust programmers must use a subset as I'm not familiar with that language like I am with C/C++).",-0.1082638888888889,rust
135tfrc,jip9fzf,"Everyone getting paid 500+k/yr to program high performance code uses Rust, C, or a stripped down version of C++ (and I'm honestly not sure if Rust programmers must use a subset as I'm not familiar with that language like I am with C/C++).",-0.1082638888888889,c
135tfrc,jip9fzf,"Everyone getting paid 500+k/yr to program high performance code uses Rust, C, or a stripped down version of C++ (and I'm honestly not sure if Rust programmers must use a subset as I'm not familiar with that language like I am with C/C++).",-0.1082638888888889,c++
135tfrc,jip9fzf,There is no debate here even if you want to be cool on Reddit by coming off like a brainiac.,0.35,cool
135tfrc,jip9fzf,"Linux, video game development tuned to PS5/xbox hardware) write straight up C or highly restricted C++ code (e.g.",-0.013333333333333336,c
135tfrc,jip9fzf,"Linux, video game development tuned to PS5/xbox hardware) write straight up C or highly restricted C++ code (e.g.",-0.013333333333333336,c++
135tfrc,jip9fzf,"""No classes, no templates"") with moments of assembly.",0.0,assembly
135tfrc,jj948af,The pain I encountered was that usually each package uses a specific type and you have to go through hoops to make types work together.,-0.125,go
135tfrc,jj948af,"Reading Julia, yes you can pretty easily mix anything you want, and 99% of the time everything works.",0.3416666666666667,julia
135tfrc,jj948af,Python really helped push the scientific community and now it is too big to be left behind.,-0.05,python
135tfrc,jipuf30,"If you did read what I wrote you'd have realised I'm not in disagreement with those lectures and am pointing out issues with your own claims instead: that C++ has issues doesn't mean C doesn't, and doesn't mean that different languages and toolchains with different paradigms face the same challenges (and also that you're the only person to mention C++ at all, and that the first talk literally gives solutions that are trivial outside the constraints of the C++ standard).",0.0225,c++
135tfrc,jipuf30,"If you did read what I wrote you'd have realised I'm not in disagreement with those lectures and am pointing out issues with your own claims instead: that C++ has issues doesn't mean C doesn't, and doesn't mean that different languages and toolchains with different paradigms face the same challenges (and also that you're the only person to mention C++ at all, and that the first talk literally gives solutions that are trivial outside the constraints of the C++ standard).",0.0225,c
135tfrc,jj965mr,">compiler might infer some type differently  ELI5 cause I'm a scientific programmer and not a professional one, do all JIT compilers have fancy algorithms to infer types or is it just a Julia thing?",-0.025,julia
135tfrc,jj965mr,I assume AOT compilers (e.g Fortran) do not because types have to be declared?,0.0,fortran
135tfrc,jiqc4ds,"The salient point this entire time is a language with the mission statement of being as expressive as Python but as fast as C, the claim of the language being discussed, is a pipedream since having nifty abstractions is at odds with being as fast as possible.",0.24,python
135tfrc,jiqc4ds,"The salient point this entire time is a language with the mission statement of being as expressive as Python but as fast as C, the claim of the language being discussed, is a pipedream since having nifty abstractions is at odds with being as fast as possible.",0.24,c
135tfrc,jj9cifr,"Some languages enforce a strong static type (like Haskell) to make the work of the compiler easier, some are weaker around static enforcement (like C).",0.4777777777777778,haskell
135tfrc,jj9cifr,"Some languages enforce a strong static type (like Haskell) to make the work of the compiler easier, some are weaker around static enforcement (like C).",0.4777777777777778,c
135tfrc,jj9cifr,"You can write Julia pretty loose, don't declare any types just create a function and let the compiler infer what it types it needs.",0.08653846153846154,julia
135tfrc,jj9cifr,"function foo(x)          a=x+2         return(a)     end  In Julia with `code_warntype` macro, you can see how the compiler infers types.",0.0,julia
135tfrc,jj9cifr,"If we give the function the input ""2""  the compiler infers all the variables as Int64:      julia> @code_warntype foo(2)  MethodInstance for foo(::Int64)     from foo(x) in Main at REPL\[3\]:1   Arguments     \#self#::Core.Const(foo)     x::Int64   Locals     a::Int64   Body::Int64   1 ─     (a = x + 2)   └──     return a  If we give the function the input ""2.0""  the compiler infers all the variables as Float64:      julia> @code_warntype foo(2.0)  MethodInstance for foo(::Float64)     from foo(x) in Main at REPL\[3\]:1   Arguments     \#self#::Core.Const(foo)     x::Float64   Locals     a::Float64   Body::Float64   1 ─     (a = x + 2)   └──     return a  You can make your function more robust by giving the compiler hints, declaring all types from function input to local variables inside the function will make your code more ""robust"" and if you put any other type the compiler will through an error.",0.20138888888888887,julia
135tfrc,jj9cifr,"In Julia you have this freedom to write strictly or loose, it is awesome for prototyping because you can just develop fast, but if you are not careful you will introduce some nasty correctness errors into your code.",0.034615384615384624,julia
135tfrc,jj9g261,Here is the last one:  I'm sure you have come across the criticism of Julia about silent errors and you mention them here.,0.16666666666666666,julia
135tfrc,jjayzf5,"I'm not the best person to answer this question since only I have extensively used Julia, Imma just say what I gathered.",0.3333333333333333,julia
135tfrc,jjayzf5,Rust is one of those languages that makes your life hard by borrow-checker that tries to prevent most possible errors.,0.02708333333333332,rust
135kjrl,,"Recently, I've been working on an exciting project where I'm trying to create an interpreter from scratch in C++.",0.15,c++
135kjrl,,"It follows a very deterministic process, similar to assembly with mnemonics, and includes a wide range of control flow statements and mathematical functions, all without relying on external libraries.",0.02,assembly
135kjrl,jisouiz,Vaguely resembles Tcl.,-0.5,tcl
135kjrl,jitq088,>Vaguely resembles Tcl.,0.0,tcl
135eooj,jim3m37,Mathias Felleisen is typically working on some cool stuff with PhD candidates.,0.09166666666666666,cool
135eooj,jijwhxv,Research related Lexer in Pascal as a graduate thesis.,0.0,pascal
135eooj,jijwhxv,"One, to prove Modern Procedural Pascal could be used for modern P.L.",0.2,pascal
135eooj,jijwhxv,"Two, to have modern versions of Compiler related tools, for Pascal, like GNU Flex and GNU Bison, since at that time, 25 years ago, Compiler / Interpreter/ P.L.",0.1,pascal
135eooj,jijwhxv,tools were too focused / dominated by C / C++ .,0.0,c
135eooj,jijwhxv,tools were too focused / dominated by C / C++ .,0.0,c++
135eooj,jiya3a1,"Go to https://csrankings.org, filter research area by PL only, location by Europe, and pick publications in the last 5 years.",0.0,go
135eooj,jiya3a1,Go to their webpages and see if the topics of their publications appeal to you.,0.0,go
135cbu7,,"As an example, this is how I would extend the built-in String type:      extend String {        print: () => {             print(self)            ret self         },        at: (index: Number) => self[index]     }          ""hello"".at(2).print() // l  Similarly, this also works on custom types:      type Vector2 {         x: Number,         y: Number,     }          extend Vector2 {         list: () => [self.x, self.y]     }          const vec = Vector2 { x: 10, y: 20 }     const notVec = { x: 10, y: 20 }          vec.list() // [10, 20]     notVec.list() // Error  The reason I think this is one of the most useful features I've implemented, is that alongside C interop, it becomes trivial to extend the language outside of the actual interpreter code.",-0.18125,c
135cbu7,,"And because the string module was created by interoperating with C, I was able to provide type extensions that could not be achieved through vtx source code alone.",0.5,c
135cbu7,jilld1s,Ruby is famous for taking this too far.,0.3,ruby
135cbu7,jilld1s,Rust's `impl` seems to work much better.,0.5,rust
135cbu7,jil9m9g,"I've seen this in many languages under different names; Scala, for example, calls these ""implicits"".",0.25,scala
135cbu7,jij9c52,"See also:  - [Raku's 'augment'](https://docs.raku.org/syntax/augment.html)  - [Stealth mixins for common lisp](https://github.com/robert-strandh/Stealth-mixin)  With that said, although this can be a useful feature, decoupling methods from classes (as common lisp does, and as raku [does optionally, but unfortunately not exclusively](https://www.reddit.com/r/rakulang/comments/pz3y0z/multis_over_methods/)) greatly reduces the need for it.",0.0,lisp
135cbu7,jingfaz,Ruby was my first favorite language - leave the poor thing alone.,0.11666666666666665,ruby
135cbu7,jio173f,Never really dealt with Ruby,-0.1,ruby
135cbu7,jimblth,Did you mean Scala 3's `extension`s?,-0.3125,scala
135cbu7,jiobri9,"There's this popular web framework called Rails which is famous for, among other things, extending builtin classes using this feature of the Ruby language.",0.325,ruby
135cbu7,jiobri9,"Of course, Rails is not the only Ruby project that does this, but it used to be the starting point for Ruby developers for years, and there are anecdotes of them growing so accustomed to the extended library of methods that they struggled writing vanilla Ruby code.",0.0,ruby
135cbu7,jimg9wa,"I remember one way in Scala 2, and a different way introduced later.",0.0,scala
135cbu7,jip644r,Have you ever seen D's universal function call syntax?,0.0,d
1355crn,jiix5sk,"This is a bit of a stretch... Back when I was but a wee lad in high school, I had put together enough Merlin macros to basically count as a 16-bit assembly language for the 6502.",0.05333333333333334,assembly
1355crn,jiix5sk,"In a previous job, I found it worthwhile to build a tiny lisp that would read expressions from Excel spreadsheet cells, and then take advantage of their spatial relationships and formatting along with some large data-dumps from SAP to generate a metric butt-ton of beautifully-formatted financial reports sliced and summarized every which way.",0.10952380952380954,lisp
1355crn,jiiuhui,I'm not sure what counts as cool.,0.04999999999999999,cool
1355crn,jiiuhui,"I did a bunch of other languages (only the [BASIC](https://github.com/tim-hardcastle/Charm/blob/main/examples/basic.ch) and the [Forth](https://github.com/tim-hardcastle/Charm/blob/main/examples/forth.ch) are up to date with the current version of the language I think), and I did [a tiny adventure game](https://github.com/tim-hardcastle/Charm/blob/main/examples/adv.ch) (and used it as the basis for [a tutorial](https://github.com/tim-hardcastle/Charm/blob/main/docs/writing-an-adventure-game-in-charm.md)).",-0.03125,forth
1355crn,jiiuhui,"(You may say these are only tiny projects, which is true, but OTOH they'd be ten times longer in Java.)",0.0875,java
1355crn,jilkrgm,"There's only one thing that can be considered cool about my two languages, which is that I've used them almost exclusively for all my coding needs for just over 40 years.",0.175,cool
1355crn,jikh2f5,"That's very cool, and awesome work on Inko as well.",0.7275,cool
1355crn,jilk9nc,"The compiler shown above translates a programming language, like a variant of Lisp, to these instruction sets for simulators of quantum computers.",0.0,lisp
1352yh6,,"[why sml is good for compiler development](http://flint.cs.yale.edu/cs421/case-for-ml.html)  So, I am just curious what you all think about haskell vs standard ml for compiler development.",0.19999999999999998,haskell
1352yh6,jihmrk8,Both Haskell and OCaml are perfectly suitable for compiler development.,0.55,haskell
1352yh6,jihmrk8,"(Take Appel's book as an example, which uses Standard ML—or Java or C.) OCaml let's you go freewheeling with mutation and IO, like most other common languages.",0.018750000000000003,java
1352yh6,jihmrk8,"(Take Appel's book as an example, which uses Standard ML—or Java or C.) OCaml let's you go freewheeling with mutation and IO, like most other common languages.",0.018750000000000003,go
1352yh6,jihmrk8,"Haskell will, more often than not, require one to either (1) program unidiomatically, or (2) re-think existing algorithms in a way compatible with Haskell's paradigm.",0.5,haskell
1352yh6,jihmrk8,"Things like Big-O complexities frequently change with idiomatic Haskell, usually by a logarithmic factor.",-0.075,haskell
1352yh6,jihmrk8,"If the goal is to learn Haskell's model, along with having a forcing function for you to think deeply about compiler algorithms (because it'll literally be impossible to handwave otherwise), choose Haskell.",-0.3333333333333333,haskell
1352yh6,jik5ia5,I wrote my compiler in Haskell.,0.0,haskell
1352yh6,jik5ia5,Haskell is rich enough to allow local state when that is useful.,0.16875,haskell
1352yh6,jik5ia5,Although overall I would say that laziness is a minor advantage - Haskell's main advantage for compiler development is just that it's a nice language.,0.17916666666666667,haskell
1352yh6,jik5ia5,"When choosing between Haskell and OCaml, pick the one you are more familiar with.",0.4375,haskell
1352yh6,jik5ia5,"If you are equally familiar with both, I would pick Haskell because I find it more pleasant than OCaml.",0.5361111111111111,haskell
1352yh6,jii6dki,Both Haskell and OCaml are highly suitable for langdev.,0.55,haskell
1352yh6,jii6dki,"Although I'm preferential towards OCaml because I know it better, I do think Haskell has the upper hand in terms of its design, does have some deeper systems to learn and enrich yourself with, and has a bigger community.",0.16666666666666666,haskell
1352yh6,jijw9cv,I personally make use if the FParsec parsing library as well as a C# graph theory library.,0.0,c
1352yh6,jihoo2h,I have heard predicting time and space complexity is hard in Haskell because of its lazyness nature.,-0.2916666666666667,haskell
1352yh6,jihoo2h,I know you prefer lisp though :),0.5,lisp
1352yh6,jihp8h3,"Even something as simple as lexing can be written exceedingly simply in Haskell, but secretly hide a huge time or memory cost because you recursed in the wrong order but never took that branch so it never got computed.",-0.09999999999999999,haskell
1352yh6,jihv1sg,Is the book purely functional data structures relevant here as to reasoning about time and space complexity in Haskell?,0.30714285714285716,haskell
1350dfw,jiid1mb,"the D compiler apparently never freed any memory at all, and that proved eventually to be a limitation.",-0.025,d
1350dfw,jiid1mb,"C++ and Zig compilers also include constexpr and comptime interpreters, which makes ownership more complicated as well.",0.0,c++
1350dfw,jiid1mb,"### Mutation, and appending to list/vectors is a complication  The example shows immutable transformations, but sometimes you want to build up the AST directly, and not go through a CST phase (OSH builds the AST directly; YSH/Oil uses a grammar and CST).",0.1,go
1350dfw,jik3s23,"slotmap in Rust), but it's still extra work.",0.0,rust
1350dfw,jij56tn,"In particular, FORTH is basically this.",0.16666666666666666,forth
1350dfw,jiibovk,they go on to generalize flattened ast traversals to hylomorphisms (builiding up then immediately tearing down some intermediate structures).,-0.15555555555555559,go
1350dfw,jihtsc4,It also reminds me of how the Forth language is described.,0.0,forth
1350dfw,jiibofv,they go on to generalize flattened ast traversals to hylomorphisms (builiding up then immediately tearing down some intermediate structures).,-0.15555555555555559,go
1350dfw,jijgaf6,"I think the overall idea is known in Rust cycles as ""Avoid linked lists, use Vec instead.""",0.0,rust
1350dfw,jijioqj,"Do you use this in Sophie or do you have another example (implemented in Python, Lua, C, whatever?)",0.0,python
1350dfw,jijioqj,"Do you use this in Sophie or do you have another example (implemented in Python, Lua, C, whatever?)",0.0,lua
1350dfw,jijioqj,"Do you use this in Sophie or do you have another example (implemented in Python, Lua, C, whatever?)",0.0,c
1350dfw,jijglgt,The Rust compiler totally uses this kind of pattern at every single layer of IR.,0.1761904761904762,rust
1350dfw,jio510b,"I suspect arrays and indices are used to make it applicable in garbage-collected languages (but in this case it's strange to use Rust for the demo), but when you have bump-allocated arenas, arrays and indices are just adding extra indirections",-0.025,rust
134z5vv,,Its syntax and some key features were inspired by Go.,0.0,go
134z5vv,,"However, Umka doesn't rely on the Go ecosystem and only needs the C standard library to run.",0.0,go
134z5vv,,"However, Umka doesn't rely on the Go ecosystem and only needs the C standard library to run.",0.0,c
134z5vv,,The first question I always have to answer when presenting Umka is why we need yet another language if we already have Lua.,0.25,lua
134z5vv,,"The main difference is Umka's static typing that brings a number of advantages:  * Type mismatch error detection at compile time * Clearer program design due to explicitly specified types for function arguments and results * Native support for C data types, such as arrays and structures (in contrast to Lua ""tables"" and ""userdata"")  Umka is now used for scripting in [Tophat](https://tophat2d.dev/), a simple modular 2D game framework by Marek Maškarinec.",0.0236111111111111,c
134z5vv,,"The main difference is Umka's static typing that brings a number of advantages:  * Type mismatch error detection at compile time * Clearer program design due to explicitly specified types for function arguments and results * Native support for C data types, such as arrays and structures (in contrast to Lua ""tables"" and ""userdata"")  Umka is now used for scripting in [Tophat](https://tophat2d.dev/), a simple modular 2D game framework by Marek Maškarinec.",0.0236111111111111,lua
134z5vv,jihtcfl,How did you go about getting people to use your language?,0.0,go
134z5vv,jjdhi0o,"It's like ""MAT"" in ""MATLAB"".",0.0,matlab
134vg7h,jihesz4,I'm reading the material also :D thanks for it I'm just taking a bit to understand everything.,0.6,d
134vg7h,jiiucnm,"In our compiler, we call that a `TypeConstant` (and 21 subclasses, because it's Java and there is no mixin / typeclass support), but I'm sure there are 100 different names for the concept.",0.25,java
134fyou,,"* Random (basic random number generation) * Sys (sort of like Python's sys module, for interacting with the runtime) * SDL (for interfacing with the SDL C library.",-0.3333333333333333,python
134fyou,,"* Random (basic random number generation) * Sys (sort of like Python's sys module, for interacting with the runtime) * SDL (for interfacing with the SDL C library.",-0.3333333333333333,c
134fyou,jiete8o,"This is more personal preference, but including some way to load a dynamic (C) library (.dll, .so, .dylib) and call functions from it can be nice.",0.275,c
134fyou,jif9vww,"Check C ""stdmem.h""  * Basic String Manipulation  Check C ""string.h""  * Filesystem Operations  Create a folder, delete a folder, querying the files or folders in a path.",0.0,c
134fyou,jif9vww,"Check C ""stdio.h""  * Basic Text Input / Output access  Create, open, read, write, close a text file.",0.0,c
134fyou,jif9vww,"Defines standard Text Files like C ""stdin, stdout, stderr"" or C++ ""cin, cout, cerr"".",0.0,c
134fyou,jif9vww,"Defines standard Text Files like C ""stdin, stdout, stderr"" or C++ ""cin, cout, cerr"".",0.0,c++
134fyou,jif9vww,"Warning: Do not add text conversion functions like C ""printf"" here, the console should be only text based, like C# or Java.",0.0,c
134fyou,jif9vww,"Warning: Do not add text conversion functions like C ""printf"" here, the console should be only text based, like C# or Java.",0.0,java
134fyou,jif9vww,"* Basic Operations for Numeric Types: - Add, Substract, Multiply - Cos, Sin functions  * Basic Operations for Date and Time types  * Type Conversion Operations: - Integer to Float and viceversa - All text to other types conversion, C ""vsprintf,"" or C++ ""fmt"" Library goes here.",-0.03125,c
134fyou,jif9vww,"* Basic Operations for Numeric Types: - Add, Substract, Multiply - Cos, Sin functions  * Basic Operations for Date and Time types  * Type Conversion Operations: - Integer to Float and viceversa - All text to other types conversion, C ""vsprintf,"" or C++ ""fmt"" Library goes here.",-0.03125,c++
134fyou,jiim1ll,"Instead give me `c_rand`, which I know is C's `rand`, `chacha20_rand`, `openssl_rand`, etc...    As for actual features:  - Containers: lists, trees, maps and sets primarily.",0.2,c
134fyou,jiim1ll,D does that very good.,0.9099999999999999,d
134fyou,jil5ctz,I actually put a bunch of thought into this and did a scrape of around 97 million imports in github Python repositories to survey what were the most commonly used modules.,0.06666666666666667,python
134fyou,jil5ctz,"Granted, this is in Python, so it may be less applicable in your target domain.",-0.16666666666666666,python
134fyou,jil5ctz,"And for the rest, I plan to have modules for: files and filesystem manipulations (#21, #22), OS and shell commands (#1, #22, #18), time/dates (#4, #13), HTTP requests (not actually a top Python import), base64 (#17), CSV (#14), pattern matching (#3, but I probably won't use regex, probably something more simple), and probably JSON.",0.08333333333333333,shell
134fyou,jil5ctz,"And for the rest, I plan to have modules for: files and filesystem manipulations (#21, #22), OS and shell commands (#1, #22, #18), time/dates (#4, #13), HTTP requests (not actually a top Python import), base64 (#17), CSV (#14), pattern matching (#3, but I probably won't use regex, probably something more simple), and probably JSON.",0.08333333333333333,python
134fyou,jil5ctz,"My language has very easy interoperability with C, so it's pretty fast to make lightweight wrappers to C libraries like libcurl or C standard library functionality.",0.25333333333333335,c
134fyou,jil5ctz,"The modules I chose not to mess with are things like numpy, torch, codecs, and pandas: modules with large and complicated interfaces to highly fine tuned Python libraries.",-0.011011904761904764,python
134fyou,jizb66k,"I think Rust can be a good example - it's not completely devoid of problems, but its collections are generally very nice to use and extend.",0.51,rust
134fyou,jjbiixz,"What no one has mention yet, is some form of unit testing - in Python, you have by default installed Unittest, Java have Junit, etc.",0.0,python
134fyou,jjbiixz,"What no one has mention yet, is some form of unit testing - in Python, you have by default installed Unittest, Java have Junit, etc.",0.0,java
134fyou,jieuewr,"My stdlib does consist of purely C libs that are dynamically linked, there's a lot of opportunity to expand on them.",0.21428571428571427,c
134fyou,jieuewr,Vtx supports C interop out of the box and I'm using that heavily for all of these modules.,-0.2,c
134fyou,jig2i3l,I can probably leverage a pre-existing C lib that handles that.,0.0,c
134ftny,,"I've made a few posts about the language so far on this subreddit, but not sure how to go about getting it tested by real users.",-0.03749999999999999,go
134ftny,jieq5o1,Cool language I like the unique take on dysfunctional programming as you call it.,0.3625,cool
134ftny,jieqaum,"You could take a look at the GitHub actions on my [Forscape](https://github.com/JohnDTill/Forscape) repo in the .github folder, although it's probably not the most idiomatic runner scripting, but it is a C++ project like yours.",0.5,c++
134ftny,jig1y50,"I know what it offers (reactive programming, C interop, some meta programming capabilities etc.",0.1,c
134ftny,jigeh4x,"The scheme I had set up, was a self contained  web based IDE with a few fairly easy programming assignments.",0.11666666666666667,scheme
134ftny,jif10lz,There are a lot of C++ specific optimisations I can do to the source code.,0.0,c++
134b775,jif152l,I highly recommend doing a project with Elm at least once in life.,-0.06999999999999999,elm
134b775,jif152l,"In Elm, everything is 100% immutable.",0.0,elm
134b775,jif152l,"In Elm, you usually throw everything into a single large file until there's a good reason to move some code into a separate file.",0.14821428571428572,elm
134b775,jien4mm,"`strtok()` in C has this very issue, and it’s why `strtok_r()` was added.",0.2,c
134b775,jifrk6q,"In Haskell, I can read `=` the same way I read it in math, which is IME a foundation for equational reasoning that travels *very* far through the experience of working in the language.",0.065,haskell
134b775,jig8shx,"A language like C requires passing `bar` by pointer to modify it, and a language like Rust requires `&mut bar`.",0.0,c
134b775,jig8shx,"A language like C requires passing `bar` by pointer to modify it, and a language like Rust requires `&mut bar`.",0.0,rust
134b775,jifu6et,"A more specific solution for ""never sharing mutable state"" would be the borrowing and ownership model of Rust.",0.25,rust
134b775,jii8jjy,"Similar unexpected invariant violations can also happen if a language uses structural equality for mutable objects:      if a == b:         assert a == b         c.append(100)         # This can fail if c == a or b:         assert a == b  The same thing also applies for caching function arguments or return values:      def get_list(x):         if x not in cache:             cache[x] = list(range(x))         return cache[x]      assert get_list(3) == [1, 2, 3]     get_list(3).append(999)     # Failure:     assert get_list(3) == [1, 2, 3]  In other words, immutable values give you strong invariants that you can build your code around, which opens the door to a lot of possibilities that would otherwise be very hard to do.",-0.09843750000000002,c
134b775,jihzun2,I like how ELM forces the user to think ahead about how the model can change.,0.0,elm
134b775,jigx353,"This is the main thing Rust has proven: Even the best of the best developer totally do bad things with data, even in ""simple"" programs!",0.29333333333333345,rust
134b775,jigx353,"----  A good way to understand this point: Try Rust to do some ""simple stuff"".",0.35,rust
134b775,jigx353,"You will get amazed at how many times the borrow checker will stop you, and you will think ""Rust is wrong, why not allow me to do this?"".",0.0,rust
134b775,jihkrs0,"This case doesn't happen with Java ""containers"" like say ArrayList because the backing storage is hidden from the user.",-0.16666666666666666,java
134b775,jj6vxd8,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,rust
134b775,jj6vxd8,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,c
134b775,jiezzdx,I'll just whip out JavaScript.,0.0,javascript
134b775,jifvtx8,Has anyone tried writing assembly for a processor with immutable registers?,0.0,assembly
134b775,jiflhon,"I'm glad that people are putting in serious effort so we get more options than original Java ""everything is a mutable reference""",0.2604166666666667,java
134b775,jiia4a9,"You can also have mutable values whose size *is* known at compile time, but whose contents change (like a struct in C).",0.0,c
134b775,jiii0ym,"> A good way to understand this point: Try Rust to do some ""simple stuff"".",0.35,rust
134b775,jiii0ym,"You will get amazed at how many times the borrow checker will stop you, and you will think ""Rust is wrong, why not allow me to do this?"".",0.0,rust
134b775,jiii0ym,Rust's borrow checker is overly restrictive and there are many valid programs that Rust won't let you compile.,0.5,rust
134b775,jiii0ym,"As a contrived example, these two versions of code do exactly the same thing, but Rust won't compile the first version:      // Will not compile:     let mut players = vec!",0.015625,rust
134b775,jiii0ym,"}"", players);     let mut first = players.get_mut(0).unwrap();     first.score += 1;  The first version is not unsafe or buggy, its only crime is that it violates Rust's religious doctrines.",0.125,rust
134b775,jiii0ym,"This is a toy example, but I think it's hard to provide any justification for why Rust is correct to call the first program invalid and the second one valid.",-0.013888888888888895,rust
134b775,jiew19o,That's also why Haskell can have in-place mutable arrays with a pure API that looks as if it were immutable.,0.21428571428571427,haskell
134b775,jigt3ir,This is exactly how linked lists work in Lisp.,0.25,lisp
134b775,jj85yfe,Then the problem is the reference to the contents would still generate assembly code for string dereferencing but it's not actually a string anymore.,0.0,assembly
134b775,jj85yfe,"In Rust, this would be done with `let y = x.clone()`, the design philosophy of Rust is to make performance costs explicit.",0.0,rust
134b775,jj85yfe,"Then that's a difference, references in Rust can be to the stack or heap, you don't need to have the performance hit of heap allocation to use a reference.",0.0,rust
134b775,jj85yfe,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,rust
134b775,jj85yfe,That Rust like C has a flawed idea of refs/pointers and union types?,-0.5,c
134b775,jj85yfe,Yeah I think you missed the main conclusion if that was your takeaway - Rust **disallows** this at compile time whereas C does not.,0.16666666666666666,rust
134b775,jj85yfe,Yeah I think you missed the main conclusion if that was your takeaway - Rust **disallows** this at compile time whereas C does not.,0.16666666666666666,c
134b775,jj85yfe,Here's that example in a [Rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3936d36f15180365413d719dac9f370c) to try it out.,0.0,rust
134b775,jj85yfe,The article may be meant for C programmers who don't think that mutable aliasing is a problem.,0.0,c
134b775,jj85yfe,"The article describes why it's also a Bad Idea™ in a single-threaded environment, which is the justification for why Rust doesn't allow it.",-0.6999999999999998,rust
134b775,jifhk6u,Python is so good for this sort of stuff.,0.7,python
134b775,jifhk6u,I'd say it's easy to write correct code up to about a thousand lines of Python.,0.43333333333333335,python
134b775,jiiphxm,"Mine is, and having dogfooded it a lot I think it does have an edge over things like Python or JS in having fewer footguns.",0.0,python
134b775,jiey760,I just wish D would be like C# where I have to say `str.decode(ref i)` or just use a pointer.,0.0,d
134b775,jiey760,I just wish D would be like C# where I have to say `str.decode(ref i)` or just use a pointer.,0.0,c
134b775,jifdfkc,"I know they have benchmarks for certain workloads where it has comparable performance, but this is just marketing talk - it's presented as if every program is going to beat C in performance.",0.21428571428571427,c
134b775,jifdfkc,"in Swift and Val, which has very similar strong guarantees by focusing on the sharing of references instead of their mutability.",0.21666666666666665,swift
134b775,jiin0f4,> it's hard to provide any justification for why Rust is correct to call the first program invalid and the second one valid.,-0.013888888888888895,rust
134b775,jiin0f4,"```  ---  Now, I know that Rust is more restrictive than say, oCalm or Zig, so I can see why a language that is more lenient is fine in some contexts.",0.4791666666666667,rust
134b775,jiin0f4,"After you pay some attention to Rust, is easier to see how to apply the lessons and still be more lenient, but is pretty important to see why reducing the chance of mutability *helps* for your case of ""I wanna code more freely"".",0.425,rust
134b775,jiexepw,"I think a lot of references are implicit, actually Go is very explicit about it by separating the concept of class and struct allowing to attach methods either with pointer or value receivers.",0.2,go
134b775,jig4o5i,"Not sure if your comment is implying this, but Haskell doesnt need linear types to have in-place mutable arrays with a pure API, right?",0.08333333333333333,haskell
134b775,jificju,"Idk, python always bothered me.",0.0,python
134b775,jificju,"For more than 200 lines I usually just switch to Scala, which is just as flexible as python but with a good type system and much easier integration of external libraries.",0.22999999999999998,scala
134b775,jificju,"For more than 200 lines I usually just switch to Scala, which is just as flexible as python but with a good type system and much easier integration of external libraries.",0.22999999999999998,python
134b775,jificju,"The only downside is Scala's compile times, really.",0.1,scala
134b775,jig1xee,Unsafe Rust still has to follow the same aliasing rules as safe Rust.,0.25,rust
134b775,jifjpni,"I am so much more proficient at Python than anything else that I like to use it for almost everything, except when I need C. I want to like Scala, but the compile time really turn me down 😅",0.18148148148148147,python
134b775,jifjpni,"I am so much more proficient at Python than anything else that I like to use it for almost everything, except when I need C. I want to like Scala, but the compile time really turn me down 😅",0.18148148148148147,scala
134b775,jifk9k5,It's the flexibility of JavaScript.,0.0,javascript
134b775,jifk9k5,I know a few people who still use Java for everything.,-0.2,java
134b775,jigfbo5,You can generally do that in Python too; just recently in fact I wanted to return a function with metadata so I just went ahead and attached a bunch of custom attributes to it and Python didn't complain.,0.02500000000000001,python
134b775,jigfbo5,You can ask whether an object has a specifically named field in Python as well.,0.0,python
134b775,jigfbo5,"I'm curious about the ""find *all* [emphasis mine] objects"" part, though; how do you enumerate overall objects in the system in JavaScript?",-0.05,javascript
134b775,jihk5fh,"In frontend Javascript, all objects are somehow part of the `window` object if I remember correctly.",0.0,javascript
134b775,jihk5fh,I know a lot more JS details than python.,0.5,python
134b775,jihk5fh,"And python does seem to be the far more common solution for writing small scripts, even if I can't understand why people bother with pip, anaconda, distro-specific dependencies and that whole mess.",0.012500000000000002,python
13474to,jkervf0,"Oh, and let's not forget the cool concept I want to add to ASL called ""[Topicalizers](https://www.reddit.com/r/ProgrammingLanguages/comments/13i1mxv/comment/jk7v76y/?utm_source=reddit&utm_medium=web2x&context=3).""",0.35,cool
13474to,jidw0a8,"Working on [Vortex](https://github.com/dibsonthis/Vortex), a reactive programming language that implements C interop.",0.0,c
13474to,jidzr0e,"I have created an empty webassembly module with a memory heap and am designing the compiler in javascript first, with the plan to hand-translate that into webassembly after it’s worked out.",0.075,javascript
13474to,jie4efn,"Right now it has a few more features than C (modules, methods on types, limited constant evaluation), but it still isn't at the point that I would call usable.",0.10285714285714284,c
13474to,jiej5vu,"I still don't have a name for it, but it looks like ``` main :: void :=   for 1 .up_to 100, i =>     match i .div_by 3, i .div_by 5        true, true => println ""fizzbuzz""        true, _ => println ""fizz""        _, true => println ""buzz""        _ => println i ``` ``` factorial x :: num :: num :=    if x.lte 1, 1    .else * x, factorial - x, 1 ```  I have no idea how I'll implement this, but I think it looks cool",0.3194444444444444,cool
13474to,jl21qzs,"Which means we have to memory management, but we do not want to export Rust like explicit management.",0.0,rust
13474to,jie71mo,I hope to make the language C like with features like lists and garbage collection.,0.0,c
13474to,jiex4fh,Been so long since I've played with it that I forgot how it works so I might go back to the drawing board and rewrite it from scratch in yet another language.,-0.025,go
13474to,jiex4fh,I thought maybe C and I could write a JIT compiler but lack of algebraic datatypes and pattern matching would make that painful.,-0.7,c
13474to,jiex4fh,"Oh, and I already tried writing my language in my (high-level) language and it didn't work because it is so slow (~1,000x slower than C!",-0.37500000000000006,c
13474to,jifwqdg,"Based on feedback, it looks like that it will go from experimental to official.",0.1,go
13474to,jifwqdg,This back end will use new Java virtual threads feature to support the Ecstasy fiber model.,0.06818181818181818,java
13474to,jihr94r,I also implemented `break` at the same time for completeness (I already implemented both of them in the previous Java interpreter).,-0.08333333333333333,java
13474to,jihr94r,"Beech is probably what I'll go back to after finishing the book, although I still have a couple of things I want to do for [\^!",0.0,go
13474to,jjq2bsv,"Next up is either making templates act as structs, their arguments accessible as members, or an atleast partial ""binding"" for the Lua language and some primitive to extract information from syntax elements  Edit: I've just realized it would be very easy to create a compiler for template definitions so that will be my next task",0.16766666666666669,lua
13474to,jk55mmu,"For now it's implemented in Python, but I plan to reimplement it in my programming language once it is readier.",0.0,python
13474to,jidl2b1,Doesn't time go fast?,0.2,go
13474to,jidl2b1,I implemented Forth in Charm again as another dogfooding exercise and to see how DX has improved since last time.,0.0,forth
13474to,jidl2b1,"(At least on the outside, it's still written in Go on the inside ... for now.",-0.15,go
13474to,jidl2b1,"I have *just* in the last 24 hours or so figured out what the syntax and semantics of I/O should be in Charm so I'm kind of excited about that, I can get rid of my various ad hoc bits of syntax for I/O and unify them in one nice simple scheme.",0.2625,scheme
13474to,jiewex4,"After getting first version of my [Jactl](https://jactl.io) language finished last month I decided that since it uses continuations/coroutines to avoid blocking anything, it would be cool to be able to persist or distribute the continuations that hold the current execution state when suspending due to a blocking operation.",0.1625,cool
13474to,jihogmg,"Instead of representing all objects as a Rust enum, we now have defined a memory layout (with a header word indicating of which type a value is, a reference count, and actual layouts for our types).",0.0,rust
13474to,jine329,Writing a unit test framework for my C codebase.,0.0,c
13474to,jkgf1hv,"Also you reminded me of my first PHP CMS with its style rules written in JSON that looked like this:      [         ""header.html"",         {             ""ifprefix_forums"": [""forums_nav.html""],             ""ifprefix_me"": [""profile.html""]         },         ""footer.html""     ]  I loved that json when I was 14 lol.",-0.08333333333333333,php
13474to,jl1sxsu,"Personally, I think it's a really cool feature, particularly for an object-oriented language that does a lot of method calls/field accesses.",0.1722222222222222,cool
13474to,jiexuzt,"I currently write a JIT in C++, 17 and 20 added a lot of stuff u'd see more in functional langs.",0.25,c++
13474to,jin34t2,(or to C?),0.0,c
13474to,jl4f7p5,"Alright, very cool.",0.45499999999999996,cool
13474to,jieyb0p,"Hmm, I haven't written any C++ in a very long time.",-0.065,c++
13474to,jieyb0p,Maybe I should give it a go!,0.0,go
13474to,jieyutt,This is actually my first C++ Project 💀.,0.25,c++
13474to,jieyutt,"Transition Was pretty smooth though, I wrote a lot of rust code in the past 2 years, and C++ really felt like 95% rust if you use the ""modern c++"".",0.16,rust
13474to,jieyutt,"Transition Was pretty smooth though, I wrote a lot of rust code in the past 2 years, and C++ really felt like 95% rust if you use the ""modern c++"".",0.16,c++
13474to,jif2wie,Cool.,0.35,cool
13474to,jif2wie,I thought about choosing Rust but I really don't like the idea of the borrow checker.,0.2,rust
13474to,jlbk442,"The problem is that forward references can occur within nested scopes (you can close around a variable which hasn't been declared yet), which means I need to a) emit instructions to backpatch values into closures, and b) detect uses of closures that haven't been backpatched yet, and c) track reassignments of closures so that I can detect uses of those too.",0.0,c
13474to,jijsszw,"yeah, I felt so too, having written some C++ now I really don't have problems not having it, the reverse was true though.",0.275,c++
13474to,jijsszw,And static analyzers exist for C++ too.,0.5,c++
13474to,jijsszw,C++'s addition of RAII and smart pointers changed a lot for the language,0.21428571428571427,c++
13474to,jlcf8lo,"This is fast because a) symbols are interned and de-duplicated per-module at compile time, so I can compare symbol pointers--if symbols `foo` and `bar` are equal, then `&foo` and `&bar` will always be equal, b) the hash function is the identity function on the pointer, which turns out to be good enough because c) I'm using [Fibonacci hashing](https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/) to map hashes to indices.",0.18,c
13474to,jldbwsx,But I was talking about this:      a()={         let x = 1;         recur(n) = {             if n < 1 then {                 x = x + 1;                 return x;             } else {                 return recur(n-1);             }         }         b() = {             return recur(x);         }         return b;     }     y() = { let j=a(); print(j()); return j; }     c = a();     d = y(); // prints 1     print(d());  // prints 2     print(c());  // prints 1     print(d());  // prints 3     print(c());  // prints 2      How shall the body of `recur` find the correct value of x if all you have is a stack offset?,0.0,c
13474to,jldbwsx,But I was talking about this:      a()={         let x = 1;         recur(n) = {             if n < 1 then {                 x = x + 1;                 return x;             } else {                 return recur(n-1);             }         }         b() = {             return recur(x);         }         return b;     }     y() = { let j=a(); print(j()); return j; }     c = a();     d = y(); // prints 1     print(d());  // prints 2     print(c());  // prints 1     print(d());  // prints 3     print(c());  // prints 2      How shall the body of `recur` find the correct value of x if all you have is a stack offset?,0.0,d
1340z3r,,(Python does this.,0.0,python
1340z3r,,"Java *appears* to, but it's complicated.)",-0.5,java
1340z3r,,Elm's HTML module) often benefit from globular import.,0.0,elm
1340z3r,,Elm's HTML module) often benefit from globular import.,0.0,html
1340z3r,,"* JavaScript has an ""import map"" mechanism that looks overcaffeinated until you remember how the leftpad fiasco happened.",0.0,javascript
1340z3r,,"* Speaking of Java, what's up with Java's new module system?",0.13636363636363635,java
1340z3r,,* Python has a module for that.,0.0,python
1340z3r,,* Java gets this completely wrong.,-0.5,java
1340z3r,,"Or rather, Java does not bother to try.",0.0,java
1340z3r,,"* Mistake not the platform ABI for C, nor expect it to cater to anything more sophisticated than C. In particular, Windows apparently has multiple calling conventions to trip over.",0.24333333333333335,c
1340z3r,,* Someone is bound to mention rust / cargo / crates.,0.0,rust
1340z3r,,"* Go uses GitHub, which is odd because Google now depends on Microsoft.",-0.16666666666666666,go
1340z3r,,* Python pretty much copied what Perl did.,0.225,python
1340z3r,,* Python pretty much copied what Perl did.,0.225,perl
1340z3r,,* Java: Gradle?,0.0,java
1340z3r,,* Don't even get me started on JavaScript.,0.0,javascript
1340z3r,jics1xu,This is the case in Python for example where attribute access of an object and using a method from a different namespace both are done with the dot operator.,0.0,python
1340z3r,jics1xu,In Rust or C++ you use ‘::’ for the latter,0.0,rust
1340z3r,jics1xu,In Rust or C++ you use ‘::’ for the latter,0.0,c++
1340z3r,jicw7dg,Like other highly interactive languages (Common Lisp and Smalltalk) the runtime can save much of its state to an image file containing an abstract representation of its data.,-0.01625,lisp
1340z3r,jid58y6,"> Go uses GitHub, which is odd because Google now depends on Microsoft.",-0.16666666666666666,go
1340z3r,jid58y6,Go is not dependent on GitHub.,0.0,go
1340z3r,jid58y6,"How are package managed is fully implementation-defined, and Google's `go` implementation has builtin support for multiple CVSs including Git, Mercurial, Bazaar, SVN and Fossil.",0.0,go
1340z3r,jid58y6,"Also that Microsoft owns GitHub is enough to go against many people's political beliefs, to which you need to add all the people who just use other distribution methods and hosts for their own and completely different reasons, which in turn is why depending on a single dependency distribution and management system is not feasible.",0.12908163265306122,go
1340z3r,jid58y6,"To add even more to that: even when a language has some standard mechanisms, and its ecosystem has standard tools, there's always gonna be people who will branch off in their own ecosystems and use Make for everything, and there's always gonna be a Perl script to check if some GNU library is present on the system.",0.22000000000000003,perl
1340z3r,jicu03i,"But in Python, there is no such thing as the static namespace: There is only runtime, and modules are objects like any other.",0.09375,python
1340z3r,jicu03i,"I'm not sure what Java's excuse is, but probably relates to its reverse-DNS system of packaging.",-0.15,java
1340z3r,jicudaq,The only reason that C++ does that is because you need to be able to call a base class method on a derived object.,-0.10000000000000002,c++
1340z3r,jicudaq,Python avoids this by allowing you to call unbound methods directly (as static members of the base class) and passing `this` in explicitly.,-0.15000000000000002,python
1340z3r,jicudaq,"That said, Python's descriptor protocol working at runtime is definitely suboptimal performance-wise, even with interpreter hacks.",0.0,python
1340z3r,jicvkx0,In c++ you can’t confuse an object and a namespace.,0.0,c++
1340z3r,jid20y9,"= flip ($)          List a = interface         (::): a -> List a -> List a         Nil: List a         end  I know some languages like Haskell manage to get away with it by overloading the `.` operator, but I don't like it because `x.f` should imply both `x` and `f` are symbols in scope, but suddenly if `x` is a module then that's false and only one or neither is in scope.",0.02499999999999998,haskell
1340z3r,jicxi56,"Foreign functions are simple to accommodate; mepros has equivalent types to those of C, and header files could be parsed at compile-time if such was considered wise.",0.14375,c
1340z3r,jihe607,"I like dependent typing, but this is very much different; it's more similar to Zig or Python.",0.16666666666666666,python
133w4xu,jic3ysk,C:,0.0,c
133w4xu,jievj1y,:D,1.0,d
133mjln,jiajqoe,It turns out writing web assembly is not so simply and apparently there is no malloc or GC.,0.025,assembly
133as9f,jibi3cw,"Programming languages usually use types instead of sets, since types are much more well behaved and type inference or even just type checking is much more tractable with those, but some type systems, notably that of TypeScript, do have union types!",0.34375,typescript
133as9f,jiaxm8x,"In a language supporting both, like TypeScript, it may look like `(0 | 1 | Bool) -> Int`.",0.25,typescript
1331clq,,"Some compilers at the C level would require `bignum.dll` to be specified, and some can't even use DLLs directly, you need to use `.a` or `.lib` files as well.",0.1,c
1331clq,,"Adding `.h` files in there would be pointless, as no C compilers would know to look inside such a DLL (unless perhaps a stub program can extract such info).",-0.08333333333333333,c
1331clq,,"What I would have liked is for interface information like this to be available in universal, language-neutral format added to such DLLs, which doesn't mean using C syntax with all its crazy stuff.",0.014583333333333337,c
1331clq,,"The nearest I've seen are actually C++ libraries where if you have a tool to enumerate the function names inside a DLL, some will have function signatures coded into those names.",0.0,c++
1331clq,,"My current module scheme is also different, and I use a private library format.",0.0,scheme
1331clq,ji7fyfm,"I don't know what language you use, but I've found that Rust's `object` crate works well for this.",0.0,rust
1331clq,ji83opm,"They work similar to the constants declared in a source file, but the idea is that they should be stored in a different assembly section.",0.0,assembly
1331clq,ji7g6l7,"Consider if you have `importd`/`importx` statements scattered through a codebase, and you decide you want to statically link later on: Now you must go through and replace them all with `import` statements.",0.0,go
1331clq,ji7vqgg,">Consider if you have importd/importx statements scattered through a codebase, and you decide you want to statically link later on: Now you must go through and replace them all with import statements.",0.0,go
1331clq,ji7vqgg,"I mentioned I now use a different scheme where everything that defines the project structure is either at the top of the lead module, or *is* the lead module.",0.25,scheme
1331clq,ji7vqgg,"But if a scheme like mine were to be adopted, library authors could either tidy up their act, or add a special, simple umbrella DLL, which could be done by a third party.",0.23928571428571427,scheme
1331clq,ji7vqgg,Writing bindings to enable me to use arbitrary libraries which come in DLLs and with APIs described as C header files are a different and *much* bigger problem.,-0.03333333333333333,c
1331clq,ji7vqgg,"Apart from a program which tries to translate C to my syntax, but that only does part of the job.",-0.05,c
1331clq,ji7vqgg,This is why C header files are a poor way to describe a cross-language API.,-0.4,c
132ximy,ji6ws86,"Most implementations of Lox turn out to be significantly slower than the one in C, but this one comes really close.",0.35833333333333334,c
132ximy,jjdk0x7,How did you go about building the online playground?,0.0,go
132ximy,jjdk0x7,As a beginner would it be just fine to follow the Web Assembly tutorial?,0.4166666666666667,assembly
132ximy,ji7woiu,* [Writing an Interpreter in Go](https://interpreterbook.com/) / [Writing a Compiler in Go](https://compilerbook.com/) by Thorsten Ball is a great set of books.,0.8,go
132ximy,ji7woiu,"However, since it uses Go, it piggybacks on Go's garbage collector instead of building one of its own.",0.6,go
132ximy,ji7woiu,"This makes the implementation easier, but it also means that you'd have trouble porting it to a non-GC language (like Rust).",-0.2,rust
132ximy,ji7woiu,"* [Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html) by Alex Kladov (one of the main authors behind rust-analyzer) is a great tutorial on building a parser in Rust.",0.17333333333333334,rust
132ximy,ji7woiu,* [rust-langdev](https://github.com/Kixiron/rust-langdev) has a lot of libraries for building compilers in Rust.,0.0,rust
132ximy,ji7woiu,"* [Learning Rust with Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/) is a quick tutorial on unsafe Rust, which you'll need if you're building a garbage collector yourself.",0.27777777777777773,rust
132ximy,ji7woiu,"Aside from these, if you want some inspiration for a production-grade language built in Rust, you might want to go through the source code of [Starlark](https://github.com/facebookexperimental/starlark-rust) and [Gluon](https://github.com/gluon-lang/gluon).",0.0,rust
132ximy,ji7woiu,"Aside from these, if you want some inspiration for a production-grade language built in Rust, you might want to go through the source code of [Starlark](https://github.com/facebookexperimental/starlark-rust) and [Gluon](https://github.com/gluon-lang/gluon).",0.0,go
132ximy,ji7b78i,I've already added Loxcraft to the [Crafting Interpreters wiki](https://github.com/munificent/craftinginterpreters/wiki/Lox-Implementations#rust).,0.0,rust
131seaw,ji33agv,Go is weird since it doesn't follow the standard ABI so I'm not sure how debuginfo works.,-0.25,go
131seaw,ji4j7ha,Go language already saves the names of functions inside the binary objects.,0.0,go
131seaw,ji4j7ha,Is it implemented somewhere apart from Go language ?,0.0,go
131seaw,ji79pfg,We are not dividing C++ for Windows and Solaris.,0.0,c++
131seaw,ji79pfg,C++ is a standard for all people.,0.0,c++
131seaw,ji79pfg,"I know that different compilers can produce some variations in the ASM, but the main part, the principle is the same for all C++ code compiled anywhere.",0.05555555555555555,c++
131seaw,ji79pfg,To better understand what I mean it is useful to see the source code of Go language.,0.1625,go
131s0kg,,"Hi All,   Im a Univeristy Student currently studying Computer Science at the University of Southampton, and as apart of my Dissertation / Thesis i have created a proof-of-concept tool that combines ideas from the Functional Language Haskell with the Block-Based visual paradigm.",0.0,haskell
131s0kg,,"You can find the project at [https://blockell.netlify.app/](https://blockell.netlify.app/), where you can create small programs using blocks to declare functions and generate haskell code.",-0.25,haskell
131s0kg,,"Unfortionately, there are no tutorials for the tool, and to run the code you have to copy it into a haskell file and run it locally on your machine.",0.0,haskell
131s0kg,ji3f3v5,Replit supports Haskell.,0.0,haskell
131s0kg,ji7cza4,Note that I don't know Haskell syntax but I know scala and FP plenty well.,0.0,haskell
131s0kg,ji7cza4,Note that I don't know Haskell syntax but I know scala and FP plenty well.,0.0,scala
131s0kg,ji7cza4,I grabbed \`:\` hoping that that's a cons operator akin to scala's \`::\`.,0.0,scala
131s0kg,ji7cza4,And you need built in documentation to tell me what arguments go where.,0.0,go
131s0kg,ji44xdx,"The haskell playground exists, personally i'd much rather something more minimal like that than replit",0.19999999999999998,haskell
131s0kg,ji7gwvd,"If you like Haskell, maybe this would be more robust if you wrote what you could in elm.",0.5,haskell
131s0kg,ji7gwvd,"If you like Haskell, maybe this would be more robust if you wrote what you could in elm.",0.5,elm
131p8jw,ji2qc3e,"For example, [Elm does the same thing](https://elm-lang.org/examples/shapes).",0.0,elm
131p8jw,ji6ibye,"another option is to enforce a trailing comma, which I believe Go does",0.0,go
130jm92,,Is anyone working creating tools for wasm in C?,0.0,c
130jm92,jhyeaw8,yes like wabt but in C.,0.0,c
130jm92,jhynl3m,it is in C++ https://github.com/WebAssembly/wabt/blob/main/src/tools/wat2wasm.cc,0.0,c++
130ezb6,jhwel9x,Hey cool project.,0.35,cool
130ezb6,jhwhpx5,"The only issue is if you went the spreadsheet route, you’d have to roll your own spreadsheet and you’d be competing with all the online spreadsheets which are more accessible….",0.3666666666666667,d
130et47,jhweqlk,"You sound cool, I haven’t started my language/s yet (have a syntax in mind though) and just about to start crafting interpreters book!",0.41875,cool
130et47,jhwm8rr,"It's a compiled language similar to C++ and Rust with the compiler written in Rust, and I'd be grateful for some help if you're interested.",0.125,c++
130et47,jhwm8rr,"It's a compiled language similar to C++ and Rust with the compiler written in Rust, and I'd be grateful for some help if you're interested.",0.125,rust
130et47,ji0fa4a,"We're working on a Standard COBOL compiler called [Otterkit](https://github.com/otterkit/otterkit), with the goal of helping the ecosystem by providing a free and open source compiler that conforms to the new COBOL 2023 standard.",0.10727272727272727,cobol
130et47,ji0fa4a,We're open to contributors and would love to work with more people to help improve the COBOL ecosystem.,0.3333333333333333,cobol
130et47,jhx896l,I wrote the beginnings of a JIT compiler in C  https://GitHub.com/samsquire/compiler see jitcompiler.c  And a simple language -  https://GitHub.com/samsquire/multiversion-concurrency-control  See LanguageInterpreter.java and ProgramParser.java and LanguageInterpreterRunner.java  The language resembles JavaScript.,0.0,c
130et47,jhx896l,I wrote the beginnings of a JIT compiler in C  https://GitHub.com/samsquire/compiler see jitcompiler.c  And a simple language -  https://GitHub.com/samsquire/multiversion-concurrency-control  See LanguageInterpreter.java and ProgramParser.java and LanguageInterpreterRunner.java  The language resembles JavaScript.,0.0,javascript
130et47,jhzcck3,You sound like someone the Julia programming language group would like.,0.4,julia
130et47,ji0mh9q,* Tight interoperability with Typescript.,-0.17857142857142858,typescript
130et47,ji0mh9q,"If you're interested in WASM, Typescript, Refinement types, Pure Functional, Data Oriented and high performance execution then this may be a good fit.",0.34485714285714286,typescript
130et47,ji5ky2d,"Very cool, possibility is thrilling.",0.3525,cool
130et47,ji5jsya,What was it in rust that you wanted to change while retaining low-level access?,0.0,rust
130et47,ji6ax4k,"I want something that has the syntax of Rust and build system/package manager of Cargo (aside from a few things), but the freedom offered by C++.",-0.2,rust
130et47,ji6ax4k,"I want something that has the syntax of Rust and build system/package manager of Cargo (aside from a few things), but the freedom offered by C++.",-0.2,c++
130et47,ji6ax4k,"I used C++ before switching to Rust (not because of memory safety, but because I got tired of implementing everything myself to simplify installation).",-0.4,c++
130et47,ji6ax4k,"I used C++ before switching to Rust (not because of memory safety, but because I got tired of implementing everything myself to simplify installation).",-0.4,rust
130et47,ji6ax4k,"Along the way, my syntax has diverged somewhat, but it's still closer to Rust than anything else, and if you can read Rust, it should be understandable.",0.0,rust
130an3z,ji1glmo,"C) then you can't control access within the process, as any function can do anything.",0.0,c
130an3z,jiafv3i,"Hardware memory protection is needed for C programs (or unsafe parts of other languages), but in a fully memory-safe language you'll never get a segfault, so there's no need for hardware to protect against it, and you have have a full OS as a single program.",0.05119047619047618,c
130an3z,jiakkco,This has nothing to do with C or Rust.,0.0,c
130an3z,jiakkco,This has nothing to do with C or Rust.,0.0,rust
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,go
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,julia
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,rust
1300cqc,jhupmv7,"The more unusual ones for me, that I'd never used before, and unlikely to use again, included Go, Julia, Rust, D, Nim, Odin and Zig.",0.06666666666666665,d
1300cqc,jhupmv7,"From your list, I've already used older ones like Algol (-60 and -68), Cobol, Fortran and multiple assembly languages.",0.08333333333333333,algol
1300cqc,jhupmv7,"From your list, I've already used older ones like Algol (-60 and -68), Cobol, Fortran and multiple assembly languages.",0.08333333333333333,cobol
1300cqc,jhupmv7,"From your list, I've already used older ones like Algol (-60 and -68), Cobol, Fortran and multiple assembly languages.",0.08333333333333333,fortran
1300cqc,jhupmv7,"From your list, I've already used older ones like Algol (-60 and -68), Cobol, Fortran and multiple assembly languages.",0.08333333333333333,assembly
1300cqc,jhumdvn,Why no love for Pascal?,-0.25,pascal
1300cqc,jhuzyzh,"I’d suggest real insights come from spending substantial time in a paradigm, and picking a few extreme paradigms and going deep.",-0.03125,d
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,prolog
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,c
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,scheme
1300cqc,jhuzyzh,"ML, Prolog, C, Scheme, Ruby.",0.0,ruby
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,ada
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,assembly
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,bash
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,c
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,c++
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,cobol
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,fortran
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,go
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,haskell
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,java
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,lisp
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,python
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,ruby
1300cqc,jhv6urp,"So far I have looked at and learned to some degree (some more than others):  Ada, z/Architecture (mainframe) assembly (at work) and a bit of x86, bash, BASIC, C, C++, C#, COBOL (at work), Fortran, Go, Haskell, Java, Javascript/Typescript, Lisp (Common Lisp), Python, Racket, Raku (a bit), Ruby, Rust, and Smalltalk.",0.075,rust
1300cqc,jhv6urp,Also Pascal and REXX.,0.0,pascal
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,apl
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,forth
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,erlang
1300cqc,jhv6urp,"I tried APL, Forth, Erlang, Eiffel and F# and didn't get very far before giving up.",0.13,eiffel
1300cqc,jhv6urp,Prolog is daunting for similar reasons.,0.0,prolog
1300cqc,jhw2epp,I do not think 52 weeks are enough for Haskell alone.,0.0,haskell
1300cqc,jhw0iaj,I'm having a lot of fun doing Elixir challenges.,0.3,elixir
1300cqc,ji15ikp,Here is the example:  &#x200B;  |Ocaml is a powerful for metaprogramming|Create your own text processing app that highlits the syntax| |:-|:-| |PHP is the embeddable into the HTML.,0.44999999999999996,html
1300cqc,ji15ikp,However out of all fullstack apps that you create the one that you wrote with the PHP will be fastest in terms of development speed.,0.0,php
1300cqc,ji15ikp,Not ideal for single page apps or large portals.|Create your own server with the code that's injected into the HTML.,0.0732142857142857,html
1300cqc,ji15ikp,The code is generating some partso f the HTML based on the user's GeoIP| |Idris is powerful to create your own data types|Create a scientific app that simulates the chemical reactions.,0.44999999999999996,html
1300cqc,ji15ikp,It's translated into Javascript (maybe a web app?,0.0,javascript
1300cqc,ji15ikp,)| |Elixir is a syntax sugar to Erlang that adds a bit of imperative paradigm|Just rewrite your Erlang app in Elixir| |Erlang is a programming language for concurrency where crash of one of the threads deosn't kill entire app.|Create a server with the admin panel.,0.0,erlang
1300cqc,jhvb5o6,"I like to do a similar thing in my spare time with random programming languages, except that I make little games (either by interfacing with a C library like SDL or just making a terminal based game).",-0.271875,c
1300cqc,jhvb5o6,"It's a lot of fun :)  From your list I already tried [Free]Basic, [Gnu]Cobol, Factor, PHP, and Racket.",0.4,cobol
1300cqc,jhvb5o6,"It's a lot of fun :)  From your list I already tried [Free]Basic, [Gnu]Cobol, Factor, PHP, and Racket.",0.4,php
1300cqc,jhwveur,"You have already chosen Haskell and OCaml, which IMO are gateways to Agda/Idris and Coq.",0.0,haskell
1300cqc,ji0zb1x,> 52 languages in 52 weeks  > no esoteric languages  It usually takes us about 8 weeks to take someone from zero to productive in Haskell.,-0.25,haskell
1300cqc,jhwllop,(Except for Haskell),0.0,haskell
1300cqc,jhxriqb,"For Forth, [Thinking Forth](https://thinking-forth.sourceforge.net/) is a lovely free book.",0.45,forth
1300cqc,jhzeipp,> C++  I may have news for you.,0.0,c++
1300cqc,jhzeipp,"Otherwise, I think there's a few important languages that you could put in the list, especially for their genre-defining and paradigm-shifting attributes, and that I thought weird for them not to be included:  - ATS - Ceylon - Céu - Chapel - Cyclone - D - Dafny - E - Eff - Egison - Encore - L.B.",-0.075,d
1300cqc,jhzeipp,"Stanza - Lean - Pony - Red and/or REBOL - TypeScript - Verona  In particular, E is as ""genre-defining"" as is Smalltalk, Cyclone predates both Rust and D with its Borrow-Checking, Dafny and Lean are Theorem Provers, Céu, Chapel, Encore, L.B.",0.08333333333333333,typescript
1300cqc,jhzeipp,"Stanza - Lean - Pony - Red and/or REBOL - TypeScript - Verona  In particular, E is as ""genre-defining"" as is Smalltalk, Cyclone predates both Rust and D with its Borrow-Checking, Dafny and Lean are Theorem Provers, Céu, Chapel, Encore, L.B.",0.08333333333333333,rust
1300cqc,jhzeipp,"Stanza - Lean - Pony - Red and/or REBOL - TypeScript - Verona  In particular, E is as ""genre-defining"" as is Smalltalk, Cyclone predates both Rust and D with its Borrow-Checking, Dafny and Lean are Theorem Provers, Céu, Chapel, Encore, L.B.",0.08333333333333333,d
1300cqc,jhzeipp,I see that you intend to learn Go; I then highly encourage you to learn L.B.,0.16,go
1300cqc,jhzeipp,"Some honourable mentions:  - Alice - Clean - Felix - Limbo, the Dis Virtual Machine, and the Inferno Operating System - Oz  Now a question:  > Basic   > Lisp    Which ones?",0.2888888888888889,alice
1300cqc,jhzeipp,"Some honourable mentions:  - Alice - Clean - Felix - Limbo, the Dis Virtual Machine, and the Inferno Operating System - Oz  Now a question:  > Basic   > Lisp    Which ones?",0.2888888888888889,lisp
1300cqc,jhzeipp,"There's like a thousand of them both, and you mentioned Clojure separately.",0.0,clojure
1300cqc,jhvw4ls,A very cool little language,0.13374999999999998,cool
1300cqc,jhva3kn,"syntax-wise it's pretty close to Ada and generally close to C with extra steps, no?",0.10000000000000002,ada
1300cqc,jhva3kn,"syntax-wise it's pretty close to Ada and generally close to C with extra steps, no?",0.10000000000000002,c
1300cqc,jhva3kn,I'm more curious what Java's doing there hehe,0.2,java
1300cqc,jhv0c11,"I think the ones I’m most keen to lean into from my list are   APL, CommonLisp, Haskell, Rust, Smalltalk",0.5,apl
1300cqc,jhv0c11,"I think the ones I’m most keen to lean into from my list are   APL, CommonLisp, Haskell, Rust, Smalltalk",0.5,haskell
1300cqc,jhv0c11,"I think the ones I’m most keen to lean into from my list are   APL, CommonLisp, Haskell, Rust, Smalltalk",0.5,rust
1300cqc,jhw0dvd,"For erlang, I think this is the best book:  https://learnyousomeerlang.com/content  If you still can't wrap your head around erlang, try Elixir instead.",1.0,erlang
1300cqc,jhw0dvd,"For erlang, I think this is the best book:  https://learnyousomeerlang.com/content  If you still can't wrap your head around erlang, try Elixir instead.",1.0,elixir
1300cqc,jhw0dvd,"Elixir runs on the same VM, so it has the same approach to error handling, distribution, observability etc, but it's much more modern and fixes some of the erlang's problems like packaging, documentation, namespaces, and metaprogramming.",0.175,elixir
1300cqc,jhw0dvd,"Elixir runs on the same VM, so it has the same approach to error handling, distribution, observability etc, but it's much more modern and fixes some of the erlang's problems like packaging, documentation, namespaces, and metaprogramming.",0.175,erlang
1300cqc,jhvxruj,What type of job do you do that requires Cobol?,0.0,cobol
1300cqc,jhw0m8m,Cool I’ll have to check that out!,0.4375,cool
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,bash
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,c
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,c++
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,python
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,javascript
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,lisp
1300cqc,ji009g2,"Quite keen to explore these languages too, and would probably look at these instead of some more conventional ones that I already have knowledge in (Bash, C#, C++, Python, JavaScript etc)  In terms of basic and Lisp, good point, I’d probably just try the most popular implementations",0.3595238095238095,d
1300cqc,jhvem9x,"Java for the JVM mainly and OOP, probably could have dropped C# though but I was trying to get to 52",0.16666666666666666,java
1300cqc,jhvem9x,"Java for the JVM mainly and OOP, probably could have dropped C# though but I was trying to get to 52",0.16666666666666666,c
1300cqc,jhw1j0z,"Also a vendor supplied debit card processing system, also written in COBOL, with a bit of assembler.",0.0,cobol
1300cqc,jhw1j0z,"I don't love COBOL, but it has it's plusses, and it certainly has paid me very well for 25+ years.",0.3047619047619048,cobol
1300cqc,jhw6jyx,Just have a lot of languages I’d like to explore haha,0.2,d
1300cqc,jhvu4wv,"At least for most of their history, C# has been a much more interesting language than Java.",0.3,c
1300cqc,jhvu4wv,"At least for most of their history, C# has been a much more interesting language than Java.",0.3,java
1300cqc,jhvu4wv,"Java has tended to lean toward the minimalist side while C# incorporates more experimental and innovative language features, for better or worse.",0.24000000000000005,java
1300cqc,jhvu4wv,"Java has tended to lean toward the minimalist side while C# incorporates more experimental and innovative language features, for better or worse.",0.24000000000000005,c
12zjsyj,,I'm trying to design a programming language somewhere between C and C++.,0.0,c
12zjsyj,,I'm trying to design a programming language somewhere between C and C++.,0.0,c++
12zjsyj,,"In C, I'd loop through the string, checking if each character was the delimiter.",0.0,c
12zjsyj,,"I want to have some kind of automatic memory cleanup, aka destructor, a bit like C++.",0.6,c++
12zjsyj,,"If I was to implement such a function, it might have the following signature:      String::split: fun(self: String*, delim: char) -> Vec<String> {          }  The problem with this is that the memory in all of the strings in the `Vec` is owned by the input string, so none of them should be deallocated when the `Vec` (and consequentially they) go out of scope.",0.0,go
12zjsyj,,"I know in rust you'd have a `Vec<&str>`, which is not necessarily a pointer, but since in my language there are no references only pointers it doesn't make sense.",0.0,rust
12zjsyj,jhsooxb,I think Rust does this correctly.,0.0,rust
12zjsyj,jhsooxb,"C++ RAII ties things to the stack, Rust is more flexible about where it goes but you then have lifetime semantics.",0.5,c++
12zjsyj,jhsooxb,"C++ RAII ties things to the stack, Rust is more flexible about where it goes but you then have lifetime semantics.",0.5,rust
12zjsyj,jhsooxb,"Side note: Rust’s string split returns an iterator, which you can then chain with other things, collect into a vec or use in a for loop.",-0.125,rust
12zjsyj,jhvye7e,All of these have a NUL terminator if possible (exceptions are noted); this is very useful since it turns out people call a *lot* of C APIs.,0.195,c
12zjsyj,jhvye7e,If doing this from scratch you should make sure it preserves size info (note: the sliced types can't); I didn't due to the VString hack and maybe also the fact that C++ didn't support good enough UDLs at the time.,0.26875,c++
12zjsyj,jhvye7e,Remember that C++ is bad because it doesn't check generics eagerly by default.,-0.6999999999999998,c++
12zjsyj,jhsyruq,"If you'd like to write it semantically like how you'd write the C version, you could add an ability to give ownership of the string argument to the procedure.",0.0,c
12zjsyj,jhul36a,"> The problem with this is that the memory in all of the strings in the Vec is owned by the input string, so none of them should be deallocated when the Vec (and consequentially they) go out of scope.",0.0,go
12zjsyj,jhul36a,"You need either Borrow Checking as featured in D, Cyclone and Rust, or Automatic Garbage Collection.",0.0,d
12zjsyj,jhul36a,"You need either Borrow Checking as featured in D, Cyclone and Rust, or Automatic Garbage Collection.",0.0,rust
12zjsyj,jht5lan,"I do want to implement a more rust-style borrow-checked system with lifetimes but it might be too big brain for me, so I'll probably just end up copying C++.",0.25,c++
12zjsyj,jhted7p,In what way is Rust more flexible?,0.5,rust
12zjsyj,jhted7p,"Basic documentation seems to suggest that the Drop trait just works like a normal destructor and is called when something goes out of scope, tying it to the stack just like C++.",0.075,c++
12zjsyj,jhun3ws,"Alternatively you could use a cow like PHP does in many places, and abstract the whole memory thing away.",0.18888888888888888,php
12zjsyj,jht554f,Java and C# are both interpreted and my language is going to be compiled so a slight difference there.,-0.16666666666666666,java
12zjsyj,jht554f,Java and C# are both interpreted and my language is going to be compiled so a slight difference there.,-0.16666666666666666,c
12zjsyj,jhtg0gc,"If you call `str::split` in Rust, it is impossible (assuming no unsafe) that the result of the function outlive the original `str` in question.",-0.14583333333333331,rust
12zjsyj,jhtg0gc,"In C++ you could call split, drop the original string, and end up with now invalid pointers.",0.375,c++
12zjsyj,jhwox7b,Both Java and c# are compiled to the language of their respective vms.,0.0,java
12zjsyj,jhwox7b,Both Java and c# are compiled to the language of their respective vms.,0.0,c
12zjsyj,jhwox7b,C# also has spans which look a lot like what you are looking for.,0.0,c
12zjsyj,jhwox7b,In c# you can split a string and have stack allocated spans.,0.0,c
12zjsyj,jhu0wyr,Java is not strictly interpreted…,0.0,java
12zjsyj,jhxoed9,"Rust ended up having *most* of these, except that it has no consistency since they grew in an ad-hoc manner, and Rust does not support all the zero-overhead conversions properly.",0.25,rust
12zjsyj,jhv8su8,"Then in D it's written like this (minus a shim due to `decode` not being marked `@nogc`):      import std.container: Array;          @trusted @nogc     Array!string split(return scope const(string) str, dchar delim) pure     {         Array!string res;         size_t lastIdx = 0;         for(size_t i = 0; i < str.length;) {             const j = i;             if(str.decode(i) == delim) {                 res ~= str[lastIdx..j];                 lastIdx = i;             }         }         if(lastIdx < str.length) {             res ~= str[lastIdx..$];         }         return res;     }      @nogc unittest     {         scope str = ""Hello World!",0.08035714285714286,d
12zjsyj,jhv8su8,"The same signature in Rust would be looking like      fn split<'a>(s: &'a str, c: char) -> Vec<&'a str>",0.0,rust
12zjsyj,jhv8su8,"The same signature in Rust would be looking like      fn split<'a>(s: &'a str, c: char) -> Vec<&'a str>",0.0,c
12zjsyj,jhum109,I was describing how I'd implement the algorithm in C.,0.0,c
12zjsyj,jhtskyt,"C++ RAII ties things to the stack, Rust is more flexible about where it goes...",0.5,c++
12zjsyj,jhtskyt,"C++ RAII ties things to the stack, Rust is more flexible about where it goes...",0.5,rust
12zjsyj,jhtskyt,where the original resource is tidied away---Rust is identical to C++ here in that the resource lifetime is tied to the stack.,0.375,c++
12zjsyj,jhtskyt,"I understand how lifetime semantics allow the compiler to reason about the lifetimes of *borrows* safely in ways that C++ can't, and this is certainly a useful thing to add into the conversation ...",0.4,c++
12zjsyj,jhtskyt,"But there seemed to be a suggestion that the lifetime of the underlying resource is handled differently in Rust, and this doesn't seem to be true.",0.175,rust
12zjsyj,jhvgrxm,"The compilation for Java seems to have always been planned to occur at runtime, since 1.0.",0.0,java
12zcoe3,,"Vortex now has a decent baseline implementation of dynamic typing:      type Color {         r: Number,         g: Number,         b: Number,         a: Number     };          const red = Color { r: 255, g: 0, b: 0, a: 255 }  We can also provide defaults to our types.",0.05555555555555555,r
12zcoe3,,"This makes instantiation really easy:      type Color {         r: Number[0],         g: Number[0],         b: Number[0],         a: Number[255]     };          const blue = Color { b: 255 }  Another cool thing we can do is to implement [hooks](https://dibs.gitbook.io/vortex-docs/reference/language-reference/hooks) directly on types, so that the objects instantiated with them are reactive by default:      type Color {         r: Number[0],         g: Number[0],         b: Number[0],         a: Number[255]     };          [Color.r, Color.g, Color.b]::onChange = (color) => {         println(""Firing Color hook..."")     	         if (color > 255) {             color = 255         }         if (color < 0) {             color = 0         }     }  So now we can do this:      var color = Color { }          println(color.r)     // 0     color.r -= 10     // Firing Color hook...     println(color.r)     // 0  Documentation: [Vortex Documentation](https://dibs.gitbook.io/vortex-docs/reference/language-reference/dynamic-types)  Repo: [Vortex Repo](https://github.com/dibsonthis/Vortex)",-0.19523809523809524,r
12zcoe3,,"This makes instantiation really easy:      type Color {         r: Number[0],         g: Number[0],         b: Number[0],         a: Number[255]     };          const blue = Color { b: 255 }  Another cool thing we can do is to implement [hooks](https://dibs.gitbook.io/vortex-docs/reference/language-reference/hooks) directly on types, so that the objects instantiated with them are reactive by default:      type Color {         r: Number[0],         g: Number[0],         b: Number[0],         a: Number[255]     };          [Color.r, Color.g, Color.b]::onChange = (color) => {         println(""Firing Color hook..."")     	         if (color > 255) {             color = 255         }         if (color < 0) {             color = 0         }     }  So now we can do this:      var color = Color { }          println(color.r)     // 0     color.r -= 10     // Firing Color hook...     println(color.r)     // 0  Documentation: [Vortex Documentation](https://dibs.gitbook.io/vortex-docs/reference/language-reference/dynamic-types)  Repo: [Vortex Repo](https://github.com/dibsonthis/Vortex)",-0.19523809523809524,cool
12zcoe3,jhrzsbf,"Example:       type Color {        r: Number = 0,        g: Number = 0,        b: Number = 0,        a: Number = 0      }          const black: Color     const blue: Color { b: 255 }  If you don't like this idea, my question is ""how are you going to support arrays ?""",-0.08333333333333333,r
12zcoe3,jhrzsbf,"Add support for modules / namespaces, before other features, maybe something like:      namespace colors {              type Color {          r: Number = 0,          g: Number = 0,          b: Number = 0,          a: Number = 0        }           }           program game {       import colors;          ...          }  Just before either the program examples or your P.L.",-0.2625,r
12zcoe3,jhsc4uf,"I decided to just go with Number over int/float in Vortex, sort of like JavaScript.",0.0,go
12zcoe3,jhsc4uf,"I decided to just go with Number over int/float in Vortex, sort of like JavaScript.",0.0,javascript
12zcoe3,jhsls5w,This is a really cool project!,0.4375,cool
12zcoe3,jhv9in0,"I mean the decorator would basically skip the hook firing for that particular variable, for example:      var x = 12          x::onChange = () => println(""x has changed"")          x = 15     // hook fires     @noRipple     x = 100     // hook does not fire  But it doesn't make too much sense to place the decorator at the top level, I'm thinking more they'd go inside the hook logic, so that initial hooks fire but further hooks do not:      Color.r::onChange = (color) => {         if (color == 255) {             @noRipple             color = 128         }     }          Color.r::onChange = (color) => {         if (color == 128) {             @noRipple             color = 255         }     }  That way, once the first hook fires, it resolves and doesn't fire any further hooks.",-0.07881944444444444,go
12z66qi,,"Given that most Java / .Net applications are now deployed as backend applications, does it even make sense to have a VM (i.e.",0.5,java
12z66qi,,"Java was first conceived as ""the language of the Internet"", and the vision was that your ""applet"" or whatever should be able to run in a multitude of browsers and on completely different hardware.",0.25,java
12z66qi,jhsum8y,"Sure, Rust ensures that programs are correct reference-wise, but there is something to be said of having a *runtime* environment that provide those guarantees.",0.5,rust
12z66qi,jhrph4s,"It's barely even Java anymore, but more of an annotation-based declarative meta-language with some glue code in Java.",0.275,java
12z66qi,jhrph4s,Java application servers support some neat stuff like that.,0.0,java
12z66qi,jhrph4s,"See for example C# Roslyn source generators, and Scala macros replacing the native runtime reflection framework.",0.0,c
12z66qi,jhrph4s,"See for example C# Roslyn source generators, and Scala macros replacing the native runtime reflection framework.",0.0,scala
12z66qi,jhr92fr,"By contrast, a C++ program with a late binding will 100% of the time incur the cost of a virtual-method lookup.",-0.3,c++
12z66qi,jhrke50,For the AOT use-case my compiler generates C for another factor two in speed when compiled e.g.,0.0,c
12z66qi,jht8hr6,"But GPUs can have significant variation in things like register count, thread count, instruction encoding, and instruction availability even within a generation, and you’d need a compiler for every last target architecture.",0.1875,d
12z66qi,jht8hr6,"So if, for example, Company In Question, LLC has been running their Java application since 2005 or thereabouts on Intel silicon, they were probably running on a Pentium 3, which supported all of the CPUID.1.EDX,ECX extensions up to SSE (packed 32-bit single-precision floating-point arithmetic and mixed bitwise ops on 8 shiny new 128-bit XMM registers).",0.06818181818181818,java
12z66qi,jht8hr6,"All of these extensions require care to use, and are intended to target specific activities or sectors; had Company in Question coded everything in assembly, they’d be forced to update their program repeatedly and expensively in order to chase performance gains on new CPUs (old programs mostly still run, but increasingly poorly in comparison with peers).",-0.06623376623376624,assembly
12z66qi,jht8hr6,"All of these extensions require care to use, and are intended to target specific activities or sectors; had Company in Question coded everything in assembly, they’d be forced to update their program repeatedly and expensively in order to chase performance gains on new CPUs (old programs mostly still run, but increasingly poorly in comparison with peers).",-0.06623376623376624,d
12z66qi,jht8hr6,"But because their program is in Java, they can rely on the fine folks at Sun and the …folks at Oracle to do all that in the JVM for them, and as long as they keep their JVM up-to-date they’re fine.",0.2611111111111111,java
12z66qi,jht8hr6,"Similarly, when you compile C or C++ code, you specify to the compiler the extensions you *know* are present (e.g., by `-m` switches), which you want it to use when optimizing and code-generating, and typically everything else is handled at the library level; e.g., the GNU/Linux ABI supports “ifuncs” which run a load-time ctor to decide how a particular function should resolve, typically based on the properties of the host CPU/platform.",-0.03333333333333333,c
12z66qi,jht8hr6,"Similarly, when you compile C or C++ code, you specify to the compiler the extensions you *know* are present (e.g., by `-m` switches), which you want it to use when optimizing and code-generating, and typically everything else is handled at the library level; e.g., the GNU/Linux ABI supports “ifuncs” which run a load-time ctor to decide how a particular function should resolve, typically based on the properties of the host CPU/platform.",-0.03333333333333333,c++
12z66qi,jht8hr6,"The contract between the Java programmer and JVM, or the C\#/CLI programmer and CLR, is just one more among many, and the ubercomputer spanning the Internet runs on this sort of contractual translation and transpiling.",0.5,java
12z66qi,jhqw49j,More people are compiling Java to native now with Graal and such,0.25,java
12z66qi,jhugnnp,"It is for this reason that a reasonably-written JVM program will *always* be twice as slow as the equivalent C program, but the CLR can usually match C ... unless the GC is a problem, which is often true for any nontrivial program.",-0.0666666666666667,c
12z66qi,jhugnnp,"Targeting either of these is still *miles* ahead of targeting a dynamically-typed VM (javascript, python, lua, etc.)",0.0,javascript
12z66qi,jhugnnp,"Targeting either of these is still *miles* ahead of targeting a dynamically-typed VM (javascript, python, lua, etc.)",0.0,python
12z66qi,jhugnnp,"Targeting either of these is still *miles* ahead of targeting a dynamically-typed VM (javascript, python, lua, etc.)",0.0,lua
12z66qi,jhugnnp,"WASM, Javascript, and Lua are major attempts at application-level sandboxing.",0.0625,javascript
12z66qi,jhugnnp,"WASM, Javascript, and Lua are major attempts at application-level sandboxing.",0.0625,lua
12z66qi,jhtbbpi,One good example is Erlang & Go.,0.7,erlang
12z66qi,jhtbbpi,One good example is Erlang & Go.,0.7,go
12z66qi,jhtbbpi,Having the runtime for dealing with concurrency is a tremendous help (more in the case of Erlang that do more than just that).,0.4444444444444444,erlang
12z66qi,jhtbbpi,"The other side, with Web Assembly, is *the reduction of capabilities*.",-0.125,assembly
12z66qi,jhubd86,"Benefits of the JVM in the real world:  - Garbage collection means memory safety  - The JIT can often produce insane throughput by noticing properties of the data and code that could not be easily expressed in, e.g., the C type system.",-0.12222222222222223,c
12z66qi,jhubd86,"In C++ you must wire up libraries for this, whose interface can vary across applications.",0.0,c++
12z66qi,jhubd86,"In the native code world, the FFI between languages is the C ABI which is... workable.",0.0,c
12z66qi,jhubd86,But I've yet to see a language go this route and still have a runtime as robust as the JVM.,0.0,go
12z66qi,jhvmcub,It was meant to be a go between to allow working on x86 code or C# code without having to do both at once.,0.0,go
12z66qi,jhvmcub,It was meant to be a go between to allow working on x86 code or C# code without having to do both at once.,0.0,c
12z66qi,jhrnrgo,"Well, [the main compiler for my programming language](https://github.com/FlatAssembler/AECforWebAssembly.git) is targetting the JavaScript Virtual Machine by outputting WebAssembly.",0.16666666666666666,javascript
12z66qi,jhrnrgo,"I think it's even better than targetting Java Virtual Machine, because, for one thing, your executables can run in any modern browser if you output WebAssembly.",0.35,java
12z66qi,jhrnrgo,"If you target Java Virtual Machine, the users need to actually download your app.",0.0,java
12z66qi,jhrnrgo,"Furthermore, there is an official assembler for WebAssembly called WebAssembly Binary Toolkit (WABT), so your compiler can output assembly and not have to deal with binary files.",0.0,assembly
12z66qi,jhrnrgo,There is nothing equivalent to that for Java Virtual Machine.,0.0,java
12z66qi,jhrnrgo,"Java Virtual Machine is designed to be implementable in hardware, so it makes trade-offs between being easy for compilers and being easy to implement in hardware.",0.43333333333333335,java
12z66qi,jhrf3gu,"And platform-independency still matters (if not so much for Java specifically, then for other languages).",0.037500000000000006,java
12z66qi,jht1uoo,"Java wasn't conceived of as a language for the Internet, it was designed to be an easier, safer way for enterprises to write software that is in the same space as C++.",0.0,java
12z66qi,jht1uoo,"Java wasn't conceived of as a language for the Internet, it was designed to be an easier, safer way for enterprises to write software that is in the same space as C++.",0.0,c++
12z66qi,jht4lgn,"Since this is the PL subreddit i would also mention the VM creates a chance to be used for language design as well, F# runs on the CLR, Clojure runs on the JVM.",0.0,clojure
12z66qi,jhskbp6,There's a reason why Java has a reputation for being slow and Rust has a reputation for being fast.,-0.05000000000000002,java
12z66qi,jhskbp6,There's a reason why Java has a reputation for being slow and Rust has a reputation for being fast.,-0.05000000000000002,rust
12z66qi,jhrl0qa,I have been doing such tests and measurements for years and have yet to find a VM that consistently delivers better results than C over a sufficient number of benchmarks.,0.25,c
12z66qi,jhtunk9,The memory safety provided by WASM is very different from the memory safety provided by Rust.,0.0,rust
12z66qi,jhtunk9,"I can compile a C program with some vulnerabilities to WASM, and an attacker can achieve remote code execution inside the WASM.",-0.1,c
12z66qi,jhtunk9,"So while it is true that any sandboxed environment offers you some protection, I wouldn't compare it to the stronger memory safety guarantees offered by Rust or other languages.",0.10833333333333332,rust
12z66qi,jhstwca,"I haven’t worked with JEE, but I’ve done a lot of Erlang in the past, which has native support for hot reloading.",0.0,erlang
12z66qi,ji76psn,What is the difference between dependency injection in C# and C++ – if that concept exists in a machine-code language?,0.0,c
12z66qi,ji76psn,What is the difference between dependency injection in C# and C++ – if that concept exists in a machine-code language?,0.0,c++
12z66qi,ji76psn,"I learned Java and other languages in the university but I'm afraid that some ""business-code"" like JEE works completely different and you can't learn it well on your own (because it's suited for big systems created by big teams – I might be wrong).",-0.08928571428571429,java
12z66qi,jht0sa4,"That's the first time I heard about JavaScript Virtual Machine, can you tell me more?",0.375,javascript
12z66qi,jhtqsoq,"Unless I'm missing something, there are several javascript virtual machines- node/ v8, SpiderMonkey, whatever Safari uses...",-0.1,javascript
12z66qi,jhtqsoq,"Some browsers have ways to make javascript interoperate with WebAssembly, but as far I know it is not correct to consider WebAssembly or its bytecode as ""targeting the javascript virtual machine"".",0.1,javascript
12z66qi,jht439j,"Rust, C++, C, etc.)",0.0,rust
12z66qi,jht439j,"Rust, C++, C, etc.)",0.0,c++
12z66qi,jht439j,"Rust, C++, C, etc.)",0.0,c
12z66qi,jht4a3q,"I remember debugging a crash in Oracle's client library, C code compiled to assembly, no debug information, function names obfuscated.",0.0,c
12z66qi,jht4a3q,"I remember debugging a crash in Oracle's client library, C code compiled to assembly, no debug information, function names obfuscated.",0.0,assembly
12z66qi,jhw2fyo,That WASM doesn't target Javascript and that there are several JS machines...,0.0,javascript
12z66qi,jhuf9xv,"Also, the javascript ecosystem has obfuscated third party libraries even though technically the code is available.",0.13333333333333333,javascript
12yqb7x,jhoh9hy,Go through that and you'll end up knowing how to write a full fledged dynamically typed language that gets interpreted in a VM.,0.35,go
12yqb7x,jhorast,"Well, I got started by learning some x86 assembly and making a [web-app that converts arithmetic expressions to x86 assembly](https://flatassembler.github.io/compiler.html).",0.0,assembly
12yqb7x,jhohyfp,And then convert the ast from the parser to C code and compile that.,0.0,c
12yqb7x,jhpf7hn,I've been going through the book myself using Haskell and it's been a blast.,0.0,haskell
12yqb7x,jhoxcoc,"And once you’ve computed all semantics information you pass AST and Sema info to code generator that produces IR, C code or whatever you use for the backend.",0.0,c
12yqb7x,jhojne4,I am more or less comfortable with C. Should I go in with C then?,0.24444444444444446,go
12yqb7x,jhojne4,I am more or less comfortable with C. Should I go in with C then?,0.24444444444444446,c
12yqb7x,jhpbmo4,I wrote an incomplete JIT compiler in C  The frontend is a simple javacript like language.,0.0,c
12yqb7x,jhpbmo4,See function\_only.lang and program2.lang and program.lang  [https://github.com/samsquire/compiler](https://github.com/samsquire/compiler)  The structs might be helpful when designing your AST data structure as there's a lot of manual data structure management in C.,0.0,c
12yqb7x,jhovdj8,"Else I would go with go, java, kotlin or C# because they are statically typed and garbage collected, which will make your development faster and less error prone than in C",-0.16666666666666666,go
12yqb7x,jhovdj8,"Else I would go with go, java, kotlin or C# because they are statically typed and garbage collected, which will make your development faster and less error prone than in C",-0.16666666666666666,java
12yqb7x,jhovdj8,"Else I would go with go, java, kotlin or C# because they are statically typed and garbage collected, which will make your development faster and less error prone than in C",-0.16666666666666666,kotlin
12yqb7x,jhovdj8,"Else I would go with go, java, kotlin or C# because they are statically typed and garbage collected, which will make your development faster and less error prone than in C",-0.16666666666666666,c
12yeuo2,,"You have a database building on the screen, you can take things to the database or from the database, by commanding units to go there.",0.0,go
12yeuo2,,"You can create symbols and assign them to methods, you highlight them and tell them to go into the method and they animate walk into the method.",0.0,go
12yeuo2,jhmwdlh,And it can output the program as Javascript.,0.0,javascript
12yeuo2,jhnc5ru,It's a cyberpunk-flavored game where you control little autonomous agents that execute their own version of assembly.,0.103125,assembly
12yeuo2,jhnls90,Anyone else who thinks doing generic programming with C macros + GCC extensions is actually a pretty good puzzle game?,0.13749999999999998,c
12yeuo2,jhoq6p2,"Some of your points remind me of the Actor model (cf Erlang, Elixir, Akka, Orleans...).",0.0,erlang
12yeuo2,jhoq6p2,"Some of your points remind me of the Actor model (cf Erlang, Elixir, Akka, Orleans...).",0.0,elixir
12yeuo2,jhqrz0l,It's literally a real time strategy game where you program your units in Javascript,-0.1,javascript
12yeuo2,jhp97jl,Orleans grains and actors in Erlang and Akka.,0.0,erlang
12yeuo2,jhoicja,The idea is you can interact with objects and create relations between things and watch it go on,0.0,go
12yc9wh,jhupv93,OK. That's pretty damn cool.,0.3666666666666667,cool
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,javascript
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,typescript
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,python
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,haskell
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,bash
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,lisp
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,apl
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,ada
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,c
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,rust
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,forth
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,erlang
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,html
12y72hc,,Been researching all flavours of languages and just want to learn so much more - Lambda calculus  - JavaScript  - TypeScript - Svelte - Python - Haskell  - Bash - Smalltalk - Lisp - APL - Ada - C - C# - Rust - Icon - Forth - Erlang - Idris - HTML - Reactive programming - Functional - OOP - High Level - Low level - Assembly,0.22,assembly
12y72hc,jhmp3zg,"ADSP: The Podcast - accessible PL oriented discussion around mainly C++ and APL (but some other stuff as well), you might want to cherry pick but don't skip the ones with Sean Parent!",0.1284722222222222,c++
12y72hc,jhmp3zg,"ADSP: The Podcast - accessible PL oriented discussion around mainly C++ and APL (but some other stuff as well), you might want to cherry pick but don't skip the ones with Sean Parent!",0.1284722222222222,apl
12y72hc,jhmp3zg,"Software Unscripted - podcast about PL and implementation (most episodes anyway), very accessible  We Speak Your Language - language designers and researchers talking to language designers and researchers, fairly accessible  Corecursive - some episodes are just about PLs - you need to cherry pick - but TBH, the whole podcast is a goldmine, very accessible  Future of Coding - another goldmine, some cherry picking necessary but the paper discussions that Ivan and Jimmy do are simply the best stuff, very accessible  The Search Space - about logic and relational PLs, accessible  The Type Theory Podcast - type theory related stuff, PLs like Idris, proof assistants and more, requires some contextual knowledge  The Haskell Interlude - great stuff about Haskell ecosystem, reasonably accessible with some contextual knowledge  Elm Town - you have to cherry pick the episodes with Evan Czaplicky + some other more PL oriented, very accessible and fun  Type Theory Forall - some at least contextual knowledge makes it fairly accessible, not only type theory  Lex Fridman Podcast - you really have to cherry pick and it feels weird putting it on this list, BUT!",0.26666666666666666,haskell
12y72hc,jhmp3zg,"Software Unscripted - podcast about PL and implementation (most episodes anyway), very accessible  We Speak Your Language - language designers and researchers talking to language designers and researchers, fairly accessible  Corecursive - some episodes are just about PLs - you need to cherry pick - but TBH, the whole podcast is a goldmine, very accessible  Future of Coding - another goldmine, some cherry picking necessary but the paper discussions that Ivan and Jimmy do are simply the best stuff, very accessible  The Search Space - about logic and relational PLs, accessible  The Type Theory Podcast - type theory related stuff, PLs like Idris, proof assistants and more, requires some contextual knowledge  The Haskell Interlude - great stuff about Haskell ecosystem, reasonably accessible with some contextual knowledge  Elm Town - you have to cherry pick the episodes with Evan Czaplicky + some other more PL oriented, very accessible and fun  Type Theory Forall - some at least contextual knowledge makes it fairly accessible, not only type theory  Lex Fridman Podcast - you really have to cherry pick and it feels weird putting it on this list, BUT!",0.26666666666666666,elm
12y72hc,jhm6g5w,"That’s a great point, and cool hobby project, I hated programming in uni and actually failed my first comp papers (Electrical Engineering) but got back into it because of complex Google spreadsheet programming post University 😂 what’s your language if you’re okay to share it?",0.024999999999999988,cool
12y72hc,jhnn9oh,He also had Guido van Rossom the creator of python on which was a great listen,0.8,python
12y72hc,jhmbkw5,"I like the look of it, it’s cool to do something different",0.175,cool
12y5wjc,jhogowi,"I think Rust does a really, really good job of this.",0.7,rust
12y5wjc,jhogowi,"Here Rust also does a great job, with `rust-analyzer` rendering markdown-formatted tooltips as rich text when you hover over the relevant symbols, and Jetbrains' CLion even rendering the rich text in the source file itself if you view it in ""reader mode.""",0.48750000000000004,rust
12y5wjc,jhogowi,"I've been writing a lot of C++ lately, and the lack of these niceties has been a little bit of a pain point.",-0.24375,c++
12y5wjc,jhq7jz6,"This is because blocks of Eve code are like Prolog horn clauses, so they compose naturally with all other blocks in the program.",-0.012499999999999997,prolog
12y5wjc,jhm41pr,Commenting because I’d like to see what others have to say about this topic.,0.0,d
12y5wjc,jhmm16n,"Also the book ""Lisp in Small Pieces"".",-0.25,lisp
12y5wjc,jhrvt1h,"But thanks for your words on Eve, that was a cool project and I'm sad it ended.",0.01666666666666668,cool
12xwmo2,,"I have been working, on and off, for a year in my GP PL in rust.",0.0,rust
12xwmo2,,"Would you recommend I rewrite the compiler in another language, or keep trying to implement it in rust?",0.0,rust
12xwmo2,,"I was looking for go or odin, C or C++ is not of my preference because I make too many mistakes and it does not have an easy testing framework.",0.4666666666666667,go
12xwmo2,,"I was looking for go or odin, C or C++ is not of my preference because I make too many mistakes and it does not have an easy testing framework.",0.4666666666666667,c
12xwmo2,,"I was looking for go or odin, C or C++ is not of my preference because I make too many mistakes and it does not have an easy testing framework.",0.4666666666666667,c++
12xwmo2,jhkmktf,"I posted my sadness on my experience with C++ as a PLDI impl language a while ago, and I took 6 months to try out a range of languages.",0.0,c++
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,go
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,c
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,rust
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,php
12xwmo2,jhkmktf,"I didn't try go, but did try Dlang, C, Rust, Odin, Zig (old version before allocgate), PHP, raw js, typescript and a few others (fantom!)",-0.12692307692307692,typescript
12xwmo2,jhl1vab,"If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,rust
12xwmo2,jhl1vab,"If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,c
12xwmo2,jhl1vab,"If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,c++
12xwmo2,jhl1vab,"Rust is ""C or C++, good practiques ON"".",0.7,rust
12xwmo2,jhl1vab,"Rust is ""C or C++, good practiques ON"".",0.7,c
12xwmo2,jhl1vab,"Rust is ""C or C++, good practiques ON"".",0.7,c++
12xwmo2,jhl1vab,"I have ""rewritten"" my lang SO MANY TIMES (probably not an exaggeration that closer to 100 times), precisely because is FAST to iterate on Rust.",0.3666666666666667,rust
12xwmo2,jhl1vab,"I tried to learn Rust making the lang, and the first 3 months were absolutely terrible, to the point I almost drop it.",-0.375,rust
12xwmo2,jhl1vab,This is because making another lang force to muscle your way to almost any feature Rust has and deal with things that are not Rust idioms.,0.0,rust
12xwmo2,jhl1vab,"First, I stop implementing things that are non-idiomatic Rust like linked-list-like things, pseudo-OOP, trying to implement ""unsafe"", and trying to optimize blindly (or worry about this prematurely).",-0.125,rust
12xwmo2,jhl1vab,"Write Rust as-is: struct, enums, pattern matching, light on traits.",0.4,rust
12xwmo2,jhl1vab,Go for `.clone`.,0.0,go
12xwmo2,jhl1vab,"**  If you think that Go, Swift, or similar is easier considering that is *exactly* what that language is doing: A lot of clones, things behind `Arc/Rc/Gc`, etc, only in Rust that is piece-meal.",-0.037500000000000006,go
12xwmo2,jhl1vab,"**  If you think that Go, Swift, or similar is easier considering that is *exactly* what that language is doing: A lot of clones, things behind `Arc/Rc/Gc`, etc, only in Rust that is piece-meal.",-0.037500000000000006,swift
12xwmo2,jhl1vab,"**  If you think that Go, Swift, or similar is easier considering that is *exactly* what that language is doing: A lot of clones, things behind `Arc/Rc/Gc`, etc, only in Rust that is piece-meal.",-0.037500000000000006,rust
12xwmo2,jhl1vab,Is so easy on Rust to do this because refactoring works wonders here.,0.43333333333333335,rust
12xwmo2,jhl1vab,"So, if I wanna check a new type-checker Idea, I copy a portion of the AST and then go wild with it in another mini-project.",0.11818181818181818,go
12xwmo2,jhkpd5q,I imagine things like lexers and parsers are easier to write in rust.,0.0,rust
12xwmo2,jhkpd5q,Why not leave some parts in rust ?,0.0,rust
12xwmo2,jhl0f4k,"My favourite and easiest to work with was in C#, back when it didn't take 2 seconds to compile hello world (which is the current case on my machine right now).",0.09523809523809523,c
12xwmo2,jhl0f4k,Pretty much every language can do 10K lines in a second and not even Go compiles 100K on my machine.,0.15,go
12xwmo2,jhl0f4k,If you're competing on speed you'll have to deal with threads and handwritten assembly which is what I did ;),0.25,assembly
12xwmo2,jhlibnp,"If Rust stops being fun, it's time for a change.",0.3,rust
12xwmo2,jhlibnp,"May I suggest a dialect of lisp, such as Scheme or Python?",0.0,lisp
12xwmo2,jhlibnp,"May I suggest a dialect of lisp, such as Scheme or Python?",0.0,scheme
12xwmo2,jhlibnp,"May I suggest a dialect of lisp, such as Scheme or Python?",0.0,python
12xwmo2,jhlibnp,"(Yes, Python is a lisp, albeit a weird one.)",-0.5,python
12xwmo2,jhlibnp,"(Yes, Python is a lisp, albeit a weird one.)",-0.5,lisp
12xwmo2,jhlibnp,Things that don't necessarily fit trivially into Rust's ontology.,0.4,rust
12xwmo2,jhlibnp,But the ontology of a lisp is the lambda calculus.,0.0,lisp
12xwmo2,jhm6xh3,"If it's a General Purpose language, and there is some usable running subset already, bootstrapping would seem the way to go?",0.05000000000000002,go
12xwmo2,jhkx736,Unsafe rust or just create part of the implementation in C/C++.,0.0,rust
12xwmo2,jhoc27u,"I have a compiler implementation in Rust, and aside from a couple small places where I had to re-architect due to borrowck's protests to initial naive implementation I did not really have any issues.",-0.155,rust
12xwmo2,jhku7ib,"I am between go, odin and dlang, maybe even zig since I dont need any combersome arch with dyn libs (it gave me troubles with that and one of the directors, not andrew, told me to move to another lang because of that)",0.0,go
12xwmo2,jhl392a,If you don't need inline assembly and custom calling convention it's a really good language that is joyful to use.,0.7,assembly
12xwmo2,jhnlaym,"Out of interest, have you tried using Haskell (or a similar functional language) as an implementation lang?",0.0,haskell
12xwmo2,jhnlaym,"After trying to write a simple parser in C++, I'm realising how much I'm missing from Haskell, like ergonomic sum types and applicative parsing 😅",0.06666666666666667,c++
12xwmo2,jhnlaym,"After trying to write a simple parser in C++, I'm realising how much I'm missing from Haskell, like ergonomic sum types and applicative parsing 😅",0.06666666666666667,haskell
12xwmo2,jhku8qy,Mind sharing your post about using C++ for this ?,0.0,c++
12xwmo2,jhmqkwl,I've been writing compilers in Go and one thing i miss very badly is sum types or at least non-nullable references.,-0.6049999999999999,go
12xwmo2,jhlg1bt,">If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,rust
12xwmo2,jhlg1bt,">If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,c
12xwmo2,jhlg1bt,">If Rust is hard for you, C or C++ will be worse.",-0.3458333333333333,c++
12xwmo2,jhlg1bt,"Rust is ""C or C++, good practiques ON"".",0.7,rust
12xwmo2,jhlg1bt,"Rust is ""C or C++, good practiques ON"".",0.7,c
12xwmo2,jhlg1bt,"Rust is ""C or C++, good practiques ON"".",0.7,c++
12xwmo2,jhlg1bt,"I know, my first iteration was in C++.",0.25,c++
12xwmo2,jhlg1bt,That is why I said that preferably do not recommend me C or C++.,0.0,c
12xwmo2,jhlg1bt,That is why I said that preferably do not recommend me C or C++.,0.0,c++
12xwmo2,jhlg1bt,">If you think that Go, Swift, or similar is easier considering that is exactly what that language is doing: A lot of clones, things behind Arc/Rc/Gc, etc, only in Rust that is piece-meal.",-0.037500000000000006,go
12xwmo2,jhlg1bt,">If you think that Go, Swift, or similar is easier considering that is exactly what that language is doing: A lot of clones, things behind Arc/Rc/Gc, etc, only in Rust that is piece-meal.",-0.037500000000000006,swift
12xwmo2,jhlg1bt,">If you think that Go, Swift, or similar is easier considering that is exactly what that language is doing: A lot of clones, things behind Arc/Rc/Gc, etc, only in Rust that is piece-meal.",-0.037500000000000006,rust
12xwmo2,jhlg1bt,"When I pass a mutable reference in go, I can modify that exact piece of memory many times.",0.375,go
12xwmo2,jhlg1bt,"In rust, inside a match-case, I cant pass a mut reference of the mut reference I used for the match.",0.0,rust
12xwmo2,jhlg1bt,Is so easy on Rust to do this because refactoring works wonders here.,0.43333333333333335,rust
12xwmo2,jhlg1bt,I know I lack a lot of rust knowledge but these type of things are so frustrating.,-0.4,rust
12xwmo2,jhnmop6,">Yes, Python is a lisp, albeit a weird one.",-0.5,python
12xwmo2,jhnmop6,">Yes, Python is a lisp, albeit a weird one.",-0.5,lisp
12xwmo2,jhl0awn,"> I am having too much friction with the borrow checker  D has a GC by default, and optional borrow checking in `@safe` code, so it should help on that front.",0.35,d
12xwmo2,jhl0awn,"Until DMD was auto-translated to D and got the GC turned on, Bright always advocated for just `malloc`ing without `free`ing, with the rationale that as a compiler is a short-lived CLI tool, the OS itself is good enough of a memory manager.",0.4666666666666666,d
12xwmo2,jhoauyl,"Haskell never really popped up for that reason, but I've just done a quick search and there's GHCJS and a Haskell compiler that outputs WASM.",0.11666666666666665,haskell
12xwmo2,jhoaank,"[https://www.reddit.com/r/Compilers/comments/nwqil5/comment/h1b1vpm/?context=3](https://www.reddit.com/r/Compilers/comments/nwqil5/comment/h1b1vpm/?context=3)  The TLDR and update since then;   * IME Engineering effort is a good 10-20% more than other languages * Related - IME you just end up writing more code in C++ * While I can recognise common mistakes I'm making, its very difficult to develop a process, meta/framework, abstraction, lint, etc - to actually grow as a developer and move beyond the same problems * C++ modules are not great.",0.022499999999999985,c++
12xwmo2,jhoaank,"* C++ Modules also do not align with other PLs ideas of a ""Module"".",-0.125,c++
12xwmo2,jhoaank,"* Using the stdlib has limitations, which are quickly reached with compiler/graph work  I often go back to the mindset of ""C with metaprogramming"" when using C++.",0.16666666666666666,go
12xwmo2,jhoaank,"* Using the stdlib has limitations, which are quickly reached with compiler/graph work  I often go back to the mindset of ""C with metaprogramming"" when using C++.",0.16666666666666666,c
12xwmo2,jhoaank,"* Using the stdlib has limitations, which are quickly reached with compiler/graph work  I often go back to the mindset of ""C with metaprogramming"" when using C++.",0.16666666666666666,c++
12xwmo2,jhoaank,"Not sure if he roams reddit still, but he might be able to offer a second opinion for you too on his experiences using C++ as a PL impl lang.",0.08333333333333333,c++
12xwmo2,jhmzcab,What's the tree/graph structures like in Go?,0.0,go
12xwmo2,jhny13x,Maybe share the bits you are struggling with in the rust reddit?,0.0,rust
12xwmo2,jhl6i7e,"You can always isolate these areas behind interfaces, and go back when performance is a problem.",-0.2,go
12xwmo2,jhl6i7e,That's not to say that I can hack out a quick and dirty prototype as fast as I can in something like javascript.,-0.022222222222222216,javascript
12xwmo2,jhl6i7e,But intuition for memory safe datastructures/patterns has made me much more productive in rust.,0.5,rust
12xwmo2,jhlgk21,In my case C# was the quickest.,0.0,c
12xwmo2,jhlgk21,I haven't written any C# since it has gotten so slow.,-0.30000000000000004,c
12xwmo2,jhlgk21,My current implementation is in C++.,0.0,c++
12xwmo2,jhlgk21,"If you're strong with Java and can easily debug with it, try that",0.43333333333333335,java
12xwmo2,jhpllum,"If you've got those, you're technically a lisp.",0.0,lisp
12xwmo2,jhnwpck,imo it would be a good idea to continue developing it in rust until it will be mature enough to be selfhosted,0.26666666666666666,rust
12xwmo2,jhp1tsk,"I've actually been employed working on a PL in Rust for the last (nearly) 2 years, so I have a LOT of opinions.",0.03333333333333333,rust
12xwmo2,jhp1tsk,"I'm currently in the process of slowly erasing all the stupid shit I wrote when I started because I didn't really ""get"" Rust then.",-0.22000000000000003,rust
12xwmo2,jhp1tsk,"(FWIW, I've been programming for more than 30 years and spent a decade on the C++ standards committee.",0.2,c++
12xwmo2,jhp1tsk,"The ""modern"" approach of building ASTs as a forest of nodes imposes memory requirements that can be tricky in Rust, and easily lead to UB in any language.",0.31666666666666665,rust
12xwmo2,jhp1tsk,Rust is optimized for processing linearizable data.,0.0,rust
12xwmo2,jhp1tsk,Error handling in Rust requires careful thought.,-0.1,rust
12xwmo2,jhp1tsk,C++ is optimized for... whatever you want to optimize for.,0.0,c++
12xwmo2,jhp1tsk,And you're more likely to get it wrong than if you use Rust.,0.0,rust
12xwmo2,ji87s10,"Yes, all graphs and trees in Go are written using pointers, otherwise the compiler can't compute the size of the recursive data structures, usually my ASTs have the structure:      type Node struct {         Lexeme Lexeme         Leaves []*Node     }  So, both `Node.Leaves` and `Node.Leaves[n]` can be a null reference.",-0.25,go
12xwmo2,jhnz1b4,"That was my plan, but being stressed by rust was not in my expectations haha",0.2,rust
12xvdui,,"Looking at C++, it seems that the compiler checks to see which overload it should use by looking for any casts done or arguments passed, but I want to be able to pass around the overloaded function itself in my language.",0.5,c++
12xvdui,jhl5inu,"Not that much languages have that kind of features, and the ones that come to my mind at this instant (TypeScript and Raku) all are built expecting a dynamic runtime.",0.2,typescript
12xvdui,jhkiklk,"Edit: _or a hash table that maps function names to hash tables mapping signatures to function bodies/addresses_   something like ``` std::map<std:: string, std::map<signature, function>> ```  in C++  I haven't put this into practice, mind.",0.0,c++
12xvdui,jhkiklk,"When I think of function overloading, I normally think of C++'s name-mangled solution (which can't support what you describe, since although we do have function objects in C++, IIRC they're not true first-class citizens, which your example implies.",-0.012499999999999997,c++
12xvdui,jhl3zc2,"In C++, you could represent them as a template and provide specializations:      template <class T>     T f(T val);      template<>     i64 f<i64>(i64 val) { return val; }       template<>     f64 f<f64>(f64 val) { return val; }      auto intz = f<i64>(0LL);     auto floatz = f<f64>(0.0);  With type inference, you could infer the template type argument from the function argument.",0.0,c++
12xo1hj,jhjqlc0,"That's really cool, I've wanted to see something like this for a while now!",0.4375,cool
12xo1hj,jhmr27f,}     c:= counter!,0.0,c
12xo1hj,jhmr27f,0.     c:= counter Increment.,0.0,c
12xo1hj,jhmr27f,Objective-C is (was?),0.0,objective-c
12xo1hj,jhksnrg,"Is that the case here, and if not, why do you think languages like Smalltalk and Ruby allow for that configurability?",0.0,ruby
12xo1hj,jhobadm,"For example, names that form natural “opposite pairs” go a long way toward making a language or API feel “intuitive”, and maybe `self` / `val` as implicit receiver/parameter want to be `self` / `other` or `this` / `that` or some such.",-0.015,go
12xo1hj,jhlkc0x,I'm sure you know that ruby and scala are also pure OO.,0.35714285714285715,ruby
12xo1hj,jhlkc0x,I'm sure you know that ruby and scala are also pure OO.,0.35714285714285715,scala
12xo1hj,jhjrhdi,"qdbp isn't pure in the same way, for example, Haskell is.",0.10714285714285714,haskell
12xo1hj,jhojnpb,Wait that's so cool.,0.35,cool
12xo1hj,jhojnpb,"In python syntax, `cow.Ate(""grass"")` and in qdbp, `cow Ate food: ""grass"".` - even a non programmer could understand that.",-0.13333333333333333,python
12xo1hj,jhogl7r,"For example, names that form natural “opposite pairs” go a long way toward making a language or API feel “intuitive”, and maybe self / val as implicit receiver/parameter want to be self / other or this / that or some such.",-0.015,go
12xo1hj,jhk8nbv,"in Java  ``` var s  = ""Hello world"".substring(7);// s is a new string ""world"" ```",0.13636363636363635,java
12xo1hj,jhk8yml,"Basically I don't see how it's ""first-class OOP"", as defined by something like Smalltalk, when it can be implemented with Rust's `struct`/`impl` situation.",0.0,rust
12xo1hj,jhkn8e1,I think the difference between qdbp and Rust in terms of object-orientedness is that centering your programming style around objects is mandatory with qdbp and not with Rust(because everything is an object in qdbp).,0.0,rust
12xo1hj,jhkn8e1,"Yes, you can program in an object-oriented style in rust, as can you in many other languages( like [C](https://www.freetechbooks.com/object-oriented-programming-with-ansi-c-t551.html)), but I wouldn't call either of these object oriented languages.",0.1875,rust
12xo1hj,jhkn8e1,"Yes, you can program in an object-oriented style in rust, as can you in many other languages( like [C](https://www.freetechbooks.com/object-oriented-programming-with-ansi-c-t551.html)), but I wouldn't call either of these object oriented languages.",0.1875,c
12xo1hj,jhkn8e1,"At the end of the day, however, the term ""object-oriented"" is poorly defined and has been used to refer to a lot of styles, from Smalltalk to Self to Java to the [object calculus](https://pages.cpsc.ucalgary.ca/~robin/FMCS/FMCS2014/An%20introduction%20to%20OOC.pdf), all of which have different takes on what ""object oriented"" really means.",-0.06666666666666667,java
12xo1hj,jhkzb9t,"In short, the type system is the static version of the duck typing you get with languages like Python.",0.25,python
12xnvrd,,"But, in the side-bar, he says "" In some other languages, like Pascal, Python, and Go, assignment is a statement. """,-0.125,pascal
12xnvrd,,"But, in the side-bar, he says "" In some other languages, like Pascal, Python, and Go, assignment is a statement. """,-0.125,python
12xnvrd,,"But, in the side-bar, he says "" In some other languages, like Pascal, Python, and Go, assignment is a statement. """,-0.125,go
12xnvrd,jhkigl3,"The historical examples given by [K&R](https://kremlin.cc/k&r.pdf) for C's assignment expression were about its ability to be used as a control expression in a loop, as in      main()     {         int c;         while((c = getchar()) != EOF)             putchar(c);     }          void copy(char to[], char from[])     {         int i;         i = 0;         while((to[i] = from[i]) != '\0')             ++i;     }  This also allows for the documented pattern `nl = nw = nc = 0;` meaning `nl = (nw = (nc = 0));`.",-0.30989583333333337,r
12xnvrd,jhkigl3,"The historical examples given by [K&R](https://kremlin.cc/k&r.pdf) for C's assignment expression were about its ability to be used as a control expression in a loop, as in      main()     {         int c;         while((c = getchar()) != EOF)             putchar(c);     }          void copy(char to[], char from[])     {         int i;         i = 0;         while((to[i] = from[i]) != '\0')             ++i;     }  This also allows for the documented pattern `nl = nw = nc = 0;` meaning `nl = (nw = (nc = 0));`.",-0.30989583333333337,c
12xnvrd,jhkigl3,"In fact, even in C, the latter is a common pattern when dealing with global variables, where `setPropertyX(y)` is expected to return ""old X.""",-0.06000000000000001,c
12xnvrd,jhkigl3,"Rust says `()` is returned, and C++ invokes copy-constructors.",0.0,rust
12xnvrd,jhkigl3,"Rust says `()` is returned, and C++ invokes copy-constructors.",0.0,c++
12xnvrd,jhlq6lb,"*Side side-bar: In Python 3.10 and up, assignment has an expression form and a statement form.",0.0,python
12xnvrd,jhlq6lb,Pascal falls squarely into this camp.,0.0,pascal
12xnvrd,jhlq6lb,C and its ilk (and Lox) operate in a weird middle-ground thanks to some odd circumstances.,-0.15555555555555556,c
12xnvrd,jhlq6lb,So it's in C and by extension Lox.,0.0,c
12xnvrd,jhjbesm,In c      a = b  is an expression assigning the value of `b` to `a` and returning the value of `a`.,0.0,c
12xnvrd,jhjbesm,In Pascal      a := b;  is a statement that doesn't return a value and cannot be used in an expression.,0.0,pascal
12xnvrd,jhm9953,">In fact, even in C, the latter is a common pattern when dealing with global variables, where    >   >setPropertyX(y)   >   > is expected to return ""old X.""",-0.06000000000000001,c
12xnvrd,jhm9953,I don't know where that might be a common pattern (Java?,-0.3,java
12xnvrd,jhm9953,"), but it isn't C. It's not in the C standard, and in the 40 years I've known C, I haven't seen any code using such a convention or any textbook suggesting it.",0.0,c
12xnvrd,jhk0u1x,"You'll find this in the ML family especially, and the style was adapted into Rust as well.",0.0,rust
12xcnv2,jhin6i2,:D,1.0,d
12xc75x,jhrjook,"I remember checking out your language a while ago and thinking it was pretty cool, I can see you've put a ton of effort into it.",0.3,cool
12x46f5,,Lately we’ve seen a lot of progress in low-level programming with Rust being the canonical example.,-0.3,rust
12x46f5,,"The other trend has been the growing adoption of static typing, for example with the success of TypeScript.",0.225,typescript
12x46f5,jhhisc8,"Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,python
12x46f5,jhhisc8,"Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,javascript
12x46f5,jhhisc8,"I saw a presentation on how to use ""gradual types"" to bridge Haskell and a full dependent type system.)",0.35,haskell
12x46f5,jhhzyya,Cause there's very little in Rust that's C-style low level.,-0.12187500000000001,rust
12x46f5,jhhzyya,"Type system is pretty much lifted from haskell, you don't ever need to manually manage memory, and you can't even do pointer arithmetic without promising to be a good boy.",0.3375,haskell
12x46f5,jhi1vh0,"But at the very least like COBOL, Visual Basic... it is allowing business' IT to create lots of low cost programs to automate away parts of repetitive labor intensive processes.",-0.128,cobol
12x46f5,jhk7aye,"Something resembling JS lambdas, Haskell, and list comprehension altogether, but more extensible.",0.5,haskell
12x46f5,jhk7aye,"Simpler OOP, something resembling Ruby.",0.0,ruby
12x46f5,jhk7aye,Python's OOP feels bolted on.,0.0,python
12x46f5,jhk7aye,Array-Oriented Features (like Julia).,0.0,julia
12x46f5,jhk7aye,"Also, package management should be simpler than Python's black hole of pip.",-0.16666666666666666,python
12x46f5,jhk7aye,"Julia largely executes on each of these ideas, but has a few too many flaws holding it back: 1-based indexing, no real OOP support (other than structs), no real logical constructs.",0.029421768707482993,julia
12x46f5,jhi10et,> Lately we’ve seen a lot of progress in low-level programming with Rust being the canonical example.,-0.3,rust
12x46f5,jhi10et,Rust has algebraic datatypes and pattern matching.,0.0,rust
12x46f5,jhi10et,"> The other trend has been the growing adoption of static typing, for example with the success of TypeScript.",0.225,typescript
12x46f5,jhi10et,25 years ago the most popular languages were C++ and Java.,0.55,c++
12x46f5,jhi10et,25 years ago the most popular languages were C++ and Java.,0.55,java
12x46f5,jhi10et,"Today, Javascript and Python are among the most popular languages.",0.55,javascript
12x46f5,jhi10et,"Today, Javascript and Python are among the most popular languages.",0.55,python
12x46f5,jhianvc,"**  I like they way Lambda Expressions are implemented in C#, but not a fan of the company.",0.0,c
12x46f5,jhianvc,"C++ syntax looks very low level programming, but it's valid, since it meant to interact with low level systems.",0.0,c++
12x46f5,jhianvc,"and related compiler developer, I started both a hobbyist static / strong versions of PHP and JavaScript years ago, before Typescript and HHVM and other appeared, but I never finished due workload and an ADDH issue...  **Other (old that look new) features are modules, exceptions, and interfaces / traits.",0.09933712121212121,php
12x46f5,jhianvc,"and related compiler developer, I started both a hobbyist static / strong versions of PHP and JavaScript years ago, before Typescript and HHVM and other appeared, but I never finished due workload and an ADDH issue...  **Other (old that look new) features are modules, exceptions, and interfaces / traits.",0.09933712121212121,javascript
12x46f5,jhianvc,"and related compiler developer, I started both a hobbyist static / strong versions of PHP and JavaScript years ago, before Typescript and HHVM and other appeared, but I never finished due workload and an ADDH issue...  **Other (old that look new) features are modules, exceptions, and interfaces / traits.",0.09933712121212121,typescript
12x46f5,jhianvc,"**  As a Modula / Pascal developer I have seen for years, with ""stack overflow horror"", how a lot of new P.L.",0.13636363636363635,pascal
12x46f5,jhianvc,"(s) appeared, without proper modular support, which ""obsolete"" Pascal and ""obsolete"" Ada had for years !",0.0,pascal
12x46f5,jhianvc,"(s) appeared, without proper modular support, which ""obsolete"" Pascal and ""obsolete"" Ada had for years !",0.0,ada
12x46f5,jhianvc,"C++ just approved their version of Modules recently, the same for Namespaces for PHP.",0.0,c++
12x46f5,jhianvc,"C++ just approved their version of Modules recently, the same for Namespaces for PHP.",0.0,php
12x46f5,jhianvc,"C++ has ""concept"" (s) which is an indirect way to support interfaces.",0.0,c++
12x46f5,jhianvc,"Personally, I prefer a simple syntax with the ""interface"" keyword as Delphi and Java did originally.",0.125,delphi
12x46f5,jhianvc,"Personally, I prefer a simple syntax with the ""interface"" keyword as Delphi and Java did originally.",0.125,java
12x46f5,jhianvc,"**And, speak of Java, ""annotations"", modifiers, specifiers, directives, attributes  and other ways of additional metadata or extending a P.L.",-0.125,java
12x46f5,jhianvc,"Just check how Java based C# has a lot of keywords / features that still are annotations in Java like ""@override"".",0.0,java
12x46f5,jhianvc,"Just check how Java based C# has a lot of keywords / features that still are annotations in Java like ""@override"".",0.0,c
12x46f5,jhi7bcs,The aim being that the programmer can spend more time telling the computer what to do and less time on how to go about doing it.,0.16666666666666669,go
12x46f5,jhi7bcs,"My suspicion is that this trend will continue into AI generated code  consider opening a file in C       FILE * fp = fopen(""myFile.txt"",""r"");       // find length of file      fseek(fp,0,SEEK_END);      long length = ftell(fp);            //allocate memory      buffer = malloc(sizeof(char) * (length+1));       //read data into buffer      fseek(fp,0,SEEK_SET);      fread(fp,sizeof(char)*length,buffer);      buffer[length] = 0;  vs python        File = open(""myFile.txt"", ""r"")       Data = File.read() but these two programs do the same exact thing!",0.065625,c
12x46f5,jhi7bcs,"My suspicion is that this trend will continue into AI generated code  consider opening a file in C       FILE * fp = fopen(""myFile.txt"",""r"");       // find length of file      fseek(fp,0,SEEK_END);      long length = ftell(fp);            //allocate memory      buffer = malloc(sizeof(char) * (length+1));       //read data into buffer      fseek(fp,0,SEEK_SET);      fread(fp,sizeof(char)*length,buffer);      buffer[length] = 0;  vs python        File = open(""myFile.txt"", ""r"")       Data = File.read() but these two programs do the same exact thing!",0.065625,r
12x46f5,jhi7bcs,"My suspicion is that this trend will continue into AI generated code  consider opening a file in C       FILE * fp = fopen(""myFile.txt"",""r"");       // find length of file      fseek(fp,0,SEEK_END);      long length = ftell(fp);            //allocate memory      buffer = malloc(sizeof(char) * (length+1));       //read data into buffer      fseek(fp,0,SEEK_SET);      fread(fp,sizeof(char)*length,buffer);      buffer[length] = 0;  vs python        File = open(""myFile.txt"", ""r"")       Data = File.read() but these two programs do the same exact thing!",0.065625,python
12x46f5,jhhwpma,"All these ideas were from the Common Lisp Object System, with the first two appearing in Flavors around 40 years ago.",-0.024999999999999994,lisp
12x46f5,jhhwpma,"Lisp macros are another big win for writing less, but they have to be approached carefully.",0.13333333333333336,lisp
12x46f5,jhik6ti,"I’ve been doing low level programming in Ada for over 15 years, others have fir about 40.",0.0,ada
12x46f5,jhik6ti,Ada has had type information via attributes since it’s inception.,0.0,ada
12x46f5,jhledr6,"Fortran or COBOL lets you delegate things like memory layout and instruction scheduling to the compiler, among other things.",-0.125,fortran
12x46f5,jhledr6,"Fortran or COBOL lets you delegate things like memory layout and instruction scheduling to the compiler, among other things.",-0.125,cobol
12x46f5,jhledr6,ALGOL and LISP added a clear mathematical foundation for the definition of a programming language.,0.05000000000000001,algol
12x46f5,jhledr6,ALGOL and LISP added a clear mathematical foundation for the definition of a programming language.,0.05000000000000001,lisp
12x46f5,jhledr6,"So, for instance, C is higher-level than BCPL mainly because in BCPL everything is an uninterpreted 32-bit number, whereas C can usually help you out with array indexes and byte access.",-0.04166666666666667,c
12x46f5,jhledr6,"But Algol already had semantically-meaningful data types in 1958, so C loses and BCPL loses harder.",-0.2333333333333333,algol
12x46f5,jhledr6,"But Algol already had semantically-meaningful data types in 1958, so C loses and BCPL loses harder.",-0.2333333333333333,c
12x46f5,jhledr6,"On that metric, *rust* only has that low-level feature that you can (and therefore must) think about physical data layout (e.g.",0.0,rust
12x46f5,jhledr6,"In short, rust is not *that* low-level.",0.0,rust
12x46f5,jhjlbgn,">	Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,python
12x46f5,jhjlbgn,">	Gradual typing has been an area of major work, but mostly because it allowed type systems to be retrofitted to existing popular languages such as Python and JavaScript.",0.290625,javascript
12x46f5,jhjmzyu,"Yeah, Rust is TOTALLY a *great* example of a high-level language.",0.8,rust
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,python
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,ruby
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,lisp
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,c
12x46f5,jhjmzyu,"Is ""higher"" than python, ruby, lisp, C, C++.",0.25,c++
12x46f5,jhjmzyu,"You can also claim it to be higher than Haskell, depending on how you consider the monad <> borrow checker to fall into this.",0.25,haskell
12x46f5,jhjd4om,"[Practical type inference for arbitrary-rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf) is a fantastic, relatively beginner friendly paper about type inference that even features an implementation in Haskell!",0.28958333333333336,haskell
12x46f5,jhjd4om,In other words       A    B     --------        C  just means `If A and B then C`.,-0.125,c
12x46f5,ji3cw88,">Julia largely executes on each of these ideas, but has a few too many flaws holding it back: 1-based indexing,   So your list is missing:  12.",0.06285714285714285,julia
12x46f5,ji3cw88,"1-based didn't really do Fortran any harm, and it's now N-based, like my stuff has always been.",0.2,fortran
12x46f5,ji3cw88,"0-based became popular because of C; C used it because its `A[i]` terms were syntactic sugar for `*(A+i)`, where the index is an offset to a pointer; and relative offsets must start at zero.",0.3,c
12x46f5,jhi9sym,"JS and Python both have stories for typing though, with TypeScript particularly becoming the default over plain JS for tons of people.",0.11785714285714287,python
12x46f5,jhi9sym,"JS and Python both have stories for typing though, with TypeScript particularly becoming the default over plain JS for tons of people.",0.11785714285714287,typescript
12x46f5,jhk3len,"> Javascript  I wouldn't look at JavaScript and say ""this is what programmers want.""",0.0,javascript
12x46f5,jhk3len,"Otherwise we'd have to accept _PHP_ as being a representative of ""programming language evolution"" (and if we trust the charts, was so majorly during the same period Java was).",0.03125,java
12x46f5,jhk3len,"According to the same charts C still is, and always has been, the king anyway, far surpassing everything else.",0.05,c
12x46f5,jhitpth,"I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,rust
12x46f5,jhitpth,"I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,c++
12x46f5,jhitpth,"You can probably hack sum types and pattern matching together in a preprocessor macro in C, but that doesn't make C + CPP high-level in any way.",0.0,c
12x46f5,jhitpth,"An example: if I want a tree data structure, in Haskell (which is high-level) I can just say `data Tree a = Leaf a | Bin (Tree a) (Tree a)`.",0.0,haskell
12x46f5,jhitpth,"In Rust I need to explicitly box the subtrees (`Bin(Box<Tree<A>>, Box<Tree<A>>`), and if I'm unlucky enough I'll also need things like reference counting in case I want to do stuff like structural sharing (which you get for free in Haskell, although it's arguably extra useful there due to immutability).",0.11499999999999999,rust
12x46f5,jhitpth,"In Rust I need to explicitly box the subtrees (`Bin(Box<Tree<A>>, Box<Tree<A>>`), and if I'm unlucky enough I'll also need things like reference counting in case I want to do stuff like structural sharing (which you get for free in Haskell, although it's arguably extra useful there due to immutability).",0.11499999999999999,haskell
12x46f5,jhitpth,"(Then again, using Rc or even Box in Rust also does, as you get good old malloc/free and pointer indirection which also cost resources.)",0.39999999999999997,rust
12x46f5,jhitpth,"As for the growing adoption of static typing, OP is probably refering to the rise of especially TypeScript.",0.25,typescript
12x46f5,jhitpth,Other recent-ish popular languages with static typing include Rust and Go.,0.325,rust
12x46f5,jhitpth,Other recent-ish popular languages with static typing include Rust and Go.,0.325,go
12x46f5,jhmoa28,"Consider the following program in Haskell:      data Person = Person { name :: String }       deriving (Show, Read)      main :: IO ()     main =  do       input <- getLine       let person = read input :: Person       print person  When we start it and enter `Person { name = ""Peter"" }` we get `Person { name = ""Peter"" }`.",0.1111111111111111,haskell
12x46f5,jhiqx49,"I still think optional typing is an interesting approach, and a great fit for adding a type system to an existing dynamically typed language (see: TypeScript).",0.5666666666666668,typescript
12x46f5,jhiqx49,"But for Dart, almost all users were *much* happier when we moved to a sound type system.",0.30000000000000004,dart
12x46f5,jhj0qy6,"For example, imagine a subset of javascript that does not have mutation.",0.0,javascript
12x46f5,jhj0qy6,"All code is valid javascript but if the compiler detects that you want to mutate anything, it throws a compile time error.",0.0,javascript
12x46f5,jhkds0h,"I think that when people talk about low-level languages, they often mean system languages and Rust is definitely that.",-0.15625,rust
12x46f5,jhmfybr,> TypeScript particularly becoming the default over plain JS for tons of people  [9% market share](https://www.itjobswatch.co.uk/jobs/uk/typescript.do).,0.11785714285714287,typescript
12x46f5,jhmg8c0,"> I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,rust
12x46f5,jhmg8c0,"> I would call Rust low-level, because like C++ most of its abstractions are designed to be ""zero-cost"".",0.5,c++
12x46f5,jhmg8c0,"> In Rust I need to explicitly box the subtrees (Bin(Box<Tree<A>>, Box<Tree<A>>)  Rust and Swift give you control over such things.",0.0,rust
12x46f5,jhmg8c0,"> In Rust I need to explicitly box the subtrees (Bin(Box<Tree<A>>, Box<Tree<A>>)  Rust and Swift give you control over such things.",0.0,swift
12x46f5,jhmg8c0,C# lets you control struct layout more than Java too.,0.5,c
12x46f5,jhmg8c0,C# lets you control struct layout more than Java too.,0.5,java
12x46f5,jhmg8c0,Does that make C# low level?,0.0,c
12x46f5,jhmg8c0,"(Then again, using Rc or even Box in Rust also does, as you get good old malloc/free and pointer indirection which also cost resources.)",0.39999999999999997,rust
12x46f5,jhl5ssx,Sum types and pattern matching have already been hacked together in a preprocessor macro in C; see https://github.com/Hirrolot/datatype99.,0.0,c
12x46f5,jhl7153,"I don't expect that to happen, but similar collisions can occur even in non-OO languages, such as with `clone()` for a Rust `&Rc<T>` (an independent issue which also has no such ideal solution).",0.18,rust
12x46f5,jhmr69i,"By using shell input, you're adding another layer: parsing.",0.0,shell
12x46f5,jhmr69i,A date string would be an obvious example of a retex:      d := date »2023/04/25«   // the French quotes delimit retex  The parser for that date format would not be built into the main parser of my PL.,0.05555555555555555,d
12x46f5,jhkf259,"The main thing is that before Rust, ""low-level languages"" always imply ""system languages"".",0.16666666666666666,rust
12x46f5,jhn2hiu,"As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,swift
12x46f5,jhn2hiu,"As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,rust
12x46f5,jhn2hiu,"And yes, struct support in C# makes it lower level than Java.",0.0,c
12x46f5,jhn2hiu,"And yes, struct support in C# makes it lower level than Java.",0.0,java
12x46f5,jhn2hiu,(But I don't know enough about C# to go in depth here.),0.0,c
12x46f5,jhn2hiu,(But I don't know enough about C# to go in depth here.),0.0,go
12x46f5,jhn2hiu,"In fact, C++ has reference counting too I'm pretty sure (in the form of `std::shared_ptr<T>`).",0.375,c++
12x46f5,jhn2hiu,"But I've never heard anyone call C++ a high level language, except when it was new and everything above assembly was high level.",0.1140909090909091,c++
12x46f5,jhn2hiu,"But I've never heard anyone call C++ a high level language, except when it was new and everything above assembly was high level.",0.1140909090909091,assembly
12x46f5,jhnbenr,"Sure but you seem to be implying that zero cost features like C++ exceptions are low-level when, to me, they are just a different default.",0.25,c++
12x46f5,jhnbenr,"> As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,swift
12x46f5,jhnbenr,"> As for Swift, I'm pretty certain that Swift automatically does reference counting for you, while in Rust you need to request it manually (and explicitly call Box::new or Rc::new when creating an instance, to make it clear that you're allocating memory).",0.1880952380952381,rust
12x46f5,jhnbenr,"Again, Swift boxes by default and you cannot annotate to unbox whereas in Rust you annotate to box.",0.0,swift
12x46f5,jhnbenr,"Again, Swift boxes by default and you cannot annotate to unbox whereas in Rust you annotate to box.",0.0,rust
12x46f5,jhnbenr,"> In fact, C++ has reference counting too I'm pretty sure (in the form of std::shared_ptr<T>).",0.375,c++
12x46f5,jhnbenr,"But I've never heard anyone call C++ a high level language, except when it was new and everything above assembly was high level.",0.1140909090909091,c++
12x46f5,jhnbenr,"But I've never heard anyone call C++ a high level language, except when it was new and everything above assembly was high level.",0.1140909090909091,assembly
12x46f5,jibkth8,"You could (and many, I’m sure, have) write an AOT compiled implementation of Lisp.",0.5,lisp
12wzu36,jhiklvp,"you are using to implement your P.L., like ""I'm using C++ for implementing the Cool P.L.""",0.35,c++
12wzu36,jhiklvp,"you are using to implement your P.L., like ""I'm using C++ for implementing the Cool P.L.""",0.35,cool
12wzu36,jhiklvp,"In this case, that means use something like Javadoc or Doxygen for C++, not ""Cool"" source code.",-0.175,c++
12wzu36,jhiklvp,"In this case, that means use something like Javadoc or Doxygen for C++, not ""Cool"" source code.",-0.175,cool
12wzu36,jhiklvp,"And, in this case, that means use something like Javadoc or Doxygen for ""Cool"", not C++, source code   You may want to do the same.",0.175,cool
12wzu36,jhiklvp,"And, in this case, that means use something like Javadoc or Doxygen for ""Cool"", not C++, source code   You may want to do the same.",0.175,c++
12wzu36,jhhna0k,"For the language itself I have multiple tools in place: - for the modules (C++ code used by the VM), doxygen is used again ; I ask every module developer to add a documentation/ folder to their module, with markdown files in it that will be used by doxygen - for the code written in the language itself (eg the standard library), we have created a mini doxygen in Python, that reads the comments above every function/variable/constant declaration and outputs either html or markdown - for anything that can't be put in code, we have a docs/ folder with markdown files, describing the project architecture, how the compiler and VM work, how to embed the language in a cpp project... - for tutorials about the language itself, we write everything in pug files and I wrote a very basic processor for it, outputting plain HTML files for the website  This results in three websites: - the documentation of the language on the ""main"" website, https://arkscript-lang.dev ; - the technical documentation (+ modules) on doxygen: https://arkscript-lang.dev/impl/ - the standard library documentation on https://arkscript-lang.dev/std/  I need to find ways to unify those website more, or at least enhance the process of updating them, but since there is one tool per website it's straightforward (for now)",0.04794372294372295,c++
12wzu36,jhhna0k,"For the language itself I have multiple tools in place: - for the modules (C++ code used by the VM), doxygen is used again ; I ask every module developer to add a documentation/ folder to their module, with markdown files in it that will be used by doxygen - for the code written in the language itself (eg the standard library), we have created a mini doxygen in Python, that reads the comments above every function/variable/constant declaration and outputs either html or markdown - for anything that can't be put in code, we have a docs/ folder with markdown files, describing the project architecture, how the compiler and VM work, how to embed the language in a cpp project... - for tutorials about the language itself, we write everything in pug files and I wrote a very basic processor for it, outputting plain HTML files for the website  This results in three websites: - the documentation of the language on the ""main"" website, https://arkscript-lang.dev ; - the technical documentation (+ modules) on doxygen: https://arkscript-lang.dev/impl/ - the standard library documentation on https://arkscript-lang.dev/std/  I need to find ways to unify those website more, or at least enhance the process of updating them, but since there is one tool per website it's straightforward (for now)",0.04794372294372295,python
12wzu36,jhhna0k,"For the language itself I have multiple tools in place: - for the modules (C++ code used by the VM), doxygen is used again ; I ask every module developer to add a documentation/ folder to their module, with markdown files in it that will be used by doxygen - for the code written in the language itself (eg the standard library), we have created a mini doxygen in Python, that reads the comments above every function/variable/constant declaration and outputs either html or markdown - for anything that can't be put in code, we have a docs/ folder with markdown files, describing the project architecture, how the compiler and VM work, how to embed the language in a cpp project... - for tutorials about the language itself, we write everything in pug files and I wrote a very basic processor for it, outputting plain HTML files for the website  This results in three websites: - the documentation of the language on the ""main"" website, https://arkscript-lang.dev ; - the technical documentation (+ modules) on doxygen: https://arkscript-lang.dev/impl/ - the standard library documentation on https://arkscript-lang.dev/std/  I need to find ways to unify those website more, or at least enhance the process of updating them, but since there is one tool per website it's straightforward (for now)",0.04794372294372295,html
12wzu36,jhilgzo,"Do a design of a P.L., implement it in Programming, check for bugs, updates, go back to the next version...",0.0,go
12wzu36,jhlrjev,Consistent naming throughout -- Apps-Hungarian if you want to go whole-hog with it -- can be the difference in maintainability between *tolerable-if-difficult* and *just stab me now.,0.25,go
12wuus3,,"[https://github.com/syykun/Hana](https://github.com/syykun/Hana)     Here's how a sample class implementation  would like      block sample         string name         int age         block init(string name, int age)             self.name = name             self.age = age         block getAge() : int             return self.age         block sayHi()             writeln(""Hi I am %s, I am %d years old"", self.name, self.age)          sample obj     obj.init(""Hana"", 2)     obj.sayHi()  I really wanted to make my own language so here it is.",0.3,d
12wqo0h,,The way Go or Rust do composition does not appeal to me.,0.0,go
12wqo0h,,The way Go or Rust do composition does not appeal to me.,0.0,rust
12wqo0h,,"In Rust for example, the `ToString` trait to me, is a ""genuine"" trait: It is valid for virtually every kind of object.",0.5,rust
12wqo0h,,"Assumption:  `Protocol<Type>` = Fixed protocol for many types (generic type, like `List<String>`)  `<Protocol>Type` = Many protocol implementations for a fixed type  To give you an example, I implement types from the command pattern of this Rust example: [https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html#approach-using-trait-objects](https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html#approach-using-trait-objects)  In my hypothetical language, types have no defining keyword like ""class"" or ""struct"".",0.07500000000000002,rust
12wqo0h,,........ Should I go back to OOP?,0.0,go
12wqo0h,jhh4zqh,"The fact that Rust uses its `trait`s to support existential types, in the form of `dyn Trait` is largely secondary - it's very convenient that this is possible, and generally works well, but Rust would have traits even if it didn't have `dyn Trait` at all, as they're vital to getting its version of generic functions and generic types to work.",0.00714285714285715,rust
12wqo0h,jhh4zqh,"Since ""X is a subtype of Y"" is a relationship between types, this means that in OOP languages, interfaces must be (and therefore are) types, having the (natural) semantics of existential types; if you have a Java `Stringable` it means you have a `T` where `T` is some class that implements `Stringable`.",0.1,java
12wqo0h,jhh4zqh,"---  The concept of traits were first introduced in Haskell, where they are called typeclasses (unrelated to the OOP concept of ""classes"") was introduced essentially in the 1989 paper [How to make ad-hoc polymorphism less ad-hoc](https://dl.acm.org/doi/pdf/10.1145/75277.75283) by Wadler and Blott.",0.02777777777777778,haskell
12wqo0h,jhh4zqh,"Historically, there were several approaches to making this work:  - All types support `==`   - This works for `==`, but it can cause problems - in particular, `==` doesn't make that much sense for function types if you have closures, and some types shouldn't be compared (at least in the ""default"" value, like hash sets), even if it's possible   - This doesn't work great for other operators, especially user-defined ones - Not all types support `==`   - Then the types of `==` and `member` are wrong, since they both claim to work on all types   - ... so we need to find new types for these functions  Haskell, being Haskell, didn't want to just cause a runtime crash if you called a generic function with a type that didn't work.",0.031502525252525254,haskell
12wqo0h,jhh4zqh,"This approach didn't seem great for Haskell, because it's limited (it works fine for equality, but what about comparison, hashing, conversion to string, etc., ...) and Haskell was meant to be a sort of kitchen-sink for lazy functional programming.",0.22380952380952385,haskell
12wqo0h,jhh4zqh,"In Haskell syntax, we write this as      (==) :: Eq a => a -> a -> Bool     member :: Eq a => [a] -> a -> Bool  where you can read `Eq a =>` as ""for any `a` that implements `Eq`"".",0.5,haskell
12wqo0h,jhh4zqh,"In Rust, the surface syntax is different, but the meaning is exactly the same:      fn eq<T: Eq>(x: T, y: T) -> bool;     fn member<T: Eq>(haystack: &[T], needle: T) -> bool;  here, we can use traits as constraints on generic types.",0.0625,rust
12wqo0h,jhh4zqh,"The fact that they're also used for existential types in Rust is because they're already used to solve the generics problem, not really the other way around.",-0.1125,rust
12wqo0h,jhhfxqs,"In this regard, my hypothetical language would work similiar to Rust.",0.0,rust
12wqo0h,jhhrk6p,I also don't see how your representation of `FromRequest` is any better than the one in Rust to be honest.,0.55,rust
12wqo0h,jhpo62j,"You *think* you can build an API like actix where   > create a FromRequest type with variants Json, Header and Path   that is 100% possible with Rust if you use an enum.",0.0,rust
12wqo0h,jhpo62j,"---  To reiterate: The rust ways is super elegant because covers the cases that others cover where ""something"" is implemented by:  - 100% of the types  But also,  - Just 1 - Just a few, maybe 2 or 3 more right now - 99%, except this time 1 or 2  This is the genius of the idea.",0.2838095238095238,rust
12wqo0h,jhiktlg,"* A unique argument type `FromRequest` the developer can dot into for autocompletion instead of  `web::Json`, `web::Path`, `web::Header`  (web contains 19 struct types, most of them unrelated to extraction)  It just doesn't make sense to me how such types are floating around all over Rust code bases.",0.2916666666666667,rust
12wqo0h,jhrvbzj,But with variants I have this hook (+ 1 optional case) too: In Rust I may create a new type `Csv` in my user code and then implement the required trait(s) for it.,0.13636363636363635,rust
12wqo0h,jhrvbzj,"Rust enum:  * fixed, can not be extended  Rust trait:  * Requires at least 1 extra type (which can implement the trait) * Extra types and the very limited traits (only valid for a certain use case) pollute the API!",-0.0035714285714285665,rust
12wqo0h,jhizs9o,"> A unique argument type `FromRequest` the developer can dot into for autocompletion instead of `web::Json`, `web::Path`, `web::Header` (web contains 19 struct types, most of them unrelated to extraction)  Ok, that's a cool functionality to have I guess and it isn't available *now* in Rust as far as I know.",0.37083333333333335,cool
12wqo0h,jhizs9o,"> A unique argument type `FromRequest` the developer can dot into for autocompletion instead of `web::Json`, `web::Path`, `web::Header` (web contains 19 struct types, most of them unrelated to extraction)  Ok, that's a cool functionality to have I guess and it isn't available *now* in Rust as far as I know.",0.37083333333333335,rust
12wqo0h,jhmh7t1,"If you say it's wrong and it's an overuse of traits, then I wonder why I see it all the time in Rust code.",-0.5,rust
12wdh6x,jhfmzw2,Even C can produce multiple files.,0.0,c
12wdh6x,jhezlxs,Idk why but I thought of Go’s _test.go pattern and thought it’d be better to use a Regex.,0.5,go
12wdh6x,jhezlxs,Idk why but I thought of Go’s _test.go pattern and thought it’d be better to use a Regex.,0.5,d
12wdh6x,jhf0a6c,"So if the user wanted to strip the file extension, they’d do `r((.",0.0,d
12wdh6x,jhf0a6c,"So if the user wanted to strip the file extension, they’d do `r((.",0.0,r
12wdh6x,jhi5399,But there are really *two* variants of the glob DSL in wide use and several different variations in semantics as used in shell languages/dialects.,0.025,shell
12wdh6x,jhi5399,"There’s a generative variant used to find files in `for` statements and as part of command-line expansion (e.g.,  	for f in /*/*/*/../../../*/*/*/../../../*/*/* 	do : ""$f"" 	done  	ls /{,usr/}bin/*sh  ), and a variant used by Bourne `case`/`in`/`esac`, POSIX `${…#…}` `${…##…}` `${…%…}` `${…%%…}`, Bash/Korn `[[…==…]]`, and Bash `${…/…}` `${…/#…}` `${…/#…}` `${…//…}` as a general-purpose text matching mechanism (e.g.,  	case ""$f"" in 	///*) f=""/${f#""${f%%[^/]*}""}"" ;; 	/*) : ;; 	*) k=""$(pwd)"" || exit ""$?""",0.25,bash
12wdh6x,jhi5399,"There are a couple things that generative globs do that regexen-per-se don’t, and it’s primarily due to the fact that the shell must open the leading portion of the glob as a directory, then enumerate its contents to find files matching the initial portion of the trailing segment (`a/b*/c` represents a search for files in `a` whose name begins with `b`, which is a directory containing a file named `c`, rather than a direct search for *all pathnames* which match the glob stringwise), and this serves to split globs around /+es and normalize the trailing surface form of the output as pathnames are constructed.",-0.006249999999999999,shell
12wdh6x,jhi5399,"There are a couple things that generative globs do that regexen-per-se don’t, and it’s primarily due to the fact that the shell must open the leading portion of the glob as a directory, then enumerate its contents to find files matching the initial portion of the trailing segment (`a/b*/c` represents a search for files in `a` whose name begins with `b`, which is a directory containing a file named `c`, rather than a direct search for *all pathnames* which match the glob stringwise), and this serves to split globs around /+es and normalize the trailing surface form of the output as pathnames are constructed.",-0.006249999999999999,c
12wdh6x,jhi5399,"*$`/ would, in this context, presumably match both files&c.",0.0,c
12wdh6x,jhi5399,"within `a`, as well as files&c.",0.0,c
12wdh6x,jhi5399,In Bash’s `extglob` extension we do have an example of all the basic regex operators (plus `!,0.0,bash
12wdh6x,jhi5399,Bash `${/}` and `${//}` perform unanchored search-and-replace; anchored forms can be de-anchored by a leading or trailing `*` or `**`.,0.0,bash
12wdh6x,jhi5399,"Ime there are some desperately-lacking things like the counting quantifiers `{n}` `{n,m}` `{n,}` `{,m}`, and the ability to use lookahead and reluctance more generally would be nice, but these are mostly sugar when you broaden options beyond a single, literal matching operation—e.g., `{n}` can be approximated in Bash by  	printf -v glob '%*s' ""$n"" '' 	glob=""$be4${glob//?/$subpattern}$aftr""  and then using `$glob` unquoted.",0.3157142857142857,bash
12wdh6x,jhi5399,"Then, given `d` = `m` − `n`, /`X{n,m}`/↔/`X{n}X?",0.0,d
12wdh6x,jhi5399,"{d}`/ so you can do  	printf -v glob '%*s' n '' 	printf -v t '%*s' ""$((m - n))"" '' 	glob=""$be4${glob//?/$subpat}${t//?/?",0.0,d
12wdh6x,jhi5399,Some regex languages do support backrefs (my regex for Bash’s `!,0.0,bash
12wdh6x,jhi5399,"I do think that filesystem globbing should be done differently than for normal globs; I think something along the lines of XPath×`find` would be my preference—if you permit arbitrary commands to be mixed in you could, for example, find all PNGs that are small enough to fit in a 32×32 square, or all files which are newer than some other file, or all C files that cause `myhdr.h` to be `#include`d.",0.009375000000000001,c
12wdh6x,jhi5399,"I do think that filesystem globbing should be done differently than for normal globs; I think something along the lines of XPath×`find` would be my preference—if you permit arbitrary commands to be mixed in you could, for example, find all PNGs that are small enough to fit in a 32×32 square, or all files which are newer than some other file, or all C files that cause `myhdr.h` to be `#include`d.",0.009375000000000001,d
12wdh6x,jhf549j,Although I chose Python before choosing to settle on a paradigm more alike to Make,0.5,python
12wdh6x,jhfyo09,Note also that make supports `load` for arbitrary C code; this is more reliable than the much-advertised Guile.,0.2,c
12wdh6x,jhi81f6,"While it may seem that Gradle is Java/jvm centric it is in fact not, and I've been successful using it in both C++, python and even lua projects",0.375,c++
12wdh6x,jhi81f6,"While it may seem that Gradle is Java/jvm centric it is in fact not, and I've been successful using it in both C++, python and even lua projects",0.375,python
12wdh6x,jhi81f6,"While it may seem that Gradle is Java/jvm centric it is in fact not, and I've been successful using it in both C++, python and even lua projects",0.375,lua
12wdh6x,jhh379m,"For what it's worth, bash has suffix stripping though [shell parameter expansions](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion).",0.3,bash
12wdh6x,jhh379m,"For what it's worth, bash has suffix stripping though [shell parameter expansions](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html#Shell-Parameter-Expansion).",0.3,shell
12wdh6x,jhh379m,"For example, if you wanted to strip the suffix from c files: `for f in *.c; do echo ${f%.c}; done`.",0.0,c
12wdh6x,jhhegrq,"Python BEAM has a cute internal DSL for representing the DAG, but afaik it doesn't do incremental recomputation.",0.25,python
12wdh6x,jhfy6us,"There's no need to invent something from scratch; bash's `extglob` already exists (though admittedly, being from a shell it has weird quoting rules).",-0.5,bash
12wdh6x,jhfy6us,"There's no need to invent something from scratch; bash's `extglob` already exists (though admittedly, being from a shell it has weird quoting rules).",-0.5,shell
12wdh6x,jhfy6us,`(` and `)` are already forbidden unquoted in shell.,0.0,shell
12wdh6x,jhtvzpt,"u/rust4yy: I've been building [mandala](https://github.com/amakelov/mandala), a Python framework for (among other things) incremental computing.",-0.125,python
12wdh6x,jhtvzpt,"One way to think of it is ""a build system for Python objects"", except the units of computation are Python functions.",0.0,python
12wdh6x,jhtvzpt,"You might be interested in how `mandala` supports Python's built-in collections (lists, dicts, sets).",0.25,python
12wdh6x,jhfzdgv,"Yeah, the only part of bash that does capture groups is the ERE integration in `[[ string =~ regex ]]` (output in the `BASH_REMATCH` array)",0.0,bash
12w42h6,,"Racket is...  • a programming language—a dialect of Lisp and a descendant of Scheme;  • a family of programming languages—variants of Racket, and more; or  • a set of tools—for using a family of programming languages.",0.5,lisp
12w42h6,,"Racket is...  • a programming language—a dialect of Lisp and a descendant of Scheme;  • a family of programming languages—variants of Racket, and more; or  • a set of tools—for using a family of programming languages.",0.5,scheme
12w42h6,,"Its innovative features have influenced the development of Clojure and Rust, many other languages.",0.2916666666666667,clojure
12w42h6,,"Its innovative features have influenced the development of Clojure and Rust, many other languages.",0.2916666666666667,rust
12w1eup,jhdl8m1,"So I have language statements for this:      print ""Enter 3 numbers: ""     readln a, b, c  Again, error-handling and validation is the hardest bit.",0.0,c
12w1eup,jhgp7m9,HTML has a sublanguage for designing forms.,0.0,html
12w1eup,jhgp7m9,"Maybe it could be useful to ""abstract"" the user to conform to a scheme like HTTP commands, and then this again becomes an instance of the previous problem; for example using a ""user:"" URI-scheme, `POST user:query(""Would you like coffee or tea?"")?response(""coffee"",""tea"")`.",0.06666666666666667,scheme
12w1eup,jhdzcs7,Python is the language I know best.,1.0,python
12w1eup,jhe1r7f,**Unix based C POSIX IO standard libraries.,0.0,c
12w1eup,jhppkrb,"In the case of IO, I say ""a FILE is a relation where the `table` has the schema: Line:String and"":  ```rust let f = file.open("".."") for line in f ?where .line <> """" do     print(line)  //Compare with a db:  let f = sqlite.Customer.open("".."") for line in f ?where .name <> """" do     print(line) ```  So, you can treat anything like a `relation` or maybe better as a `database`.",0.5,rust
12w1eup,jhmfb26,"What actual syntax you want to use, is entirely up to you; I am only suggesting using some general scheme that can accomodate both low level and high level I/O.",0.035,scheme
12vr7i5,jhcnamm,"Rust uses a similar ""anti-constraint"" syntax for unsizable data: `where T: ?Sized`",0.0,rust
12vr7i5,jhco1uy,"In D we solved that by forbidding `ref`, `in` and `out` parameters in `@safe` code from escaping.",0.5,d
12vr7i5,jhco1uy,"If ported to C#, then `void Foo<T>(in T x) {}` should take in `ref struct`s, reference types, and value types, and use the borrowing/escaping rules.",0.0,c
12u92us,jh5r828,I thought a pretty good use case for C interoperability in Vortex was to dynamically link to the awesome SDL library.,0.65,c
12u92us,jh5ryv5,That's really cool!,0.4375,cool
12u92us,jh5ryv5,:D,1.0,d
12u92us,jh5ufya,np —I've been thinking about C bindings a lot lately and it's really encouraging to see someone getting it working!,-0.024999999999999994,c
12u92us,jh7t17w,:D /s,1.0,d
12tz6f1,,*  # Preamble  I have discovered that Go programming language still has an unstable ABI.,0.0,go
12tz6f1,,"This is clearly stated in its documentation, ""Go internal ABI specification"" located at [https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md](https://go.googlesource.com/go/+/refs/heads/dev.regabi/src/cmd/compile/internal-abi.md).",0.05000000000000001,go
12tz6f1,,>This ABI is *unstable* and will change between Go versions.,0.0,go
12tz6f1,,"This fact surprised me a lot, because:  * A stable *(non-alpha, non-beta & greater than 0.9)* version 1.0 of Go language appeared more than 10 years ago according to their website at [https://go.dev/doc/devel/release](https://go.dev/doc/devel/release).",0.3666666666666667,go
12tz6f1,,"For example, C language was created more than 50 years ago when internet did not exist and a lot of historical information of that past time may have been lost for various reasons.",0.0625,c
12tz6f1,jh7uyrm,I don't know Go; perhaps for some things you do need to comply with that internal ABI so that it matters more whether it is stable.,0.25,go
12tz6f1,jh7wewb,"You mention C, which does not define an ABI.",0.0,c
12tz6f1,jh7wewb,D is an exception I can think of.,0.0,d
12tz6f1,jh95zl7,>This ABI is unstable and will change between Go versions.,0.0,go
12tz6f1,jhhkv21,"How register sized types are passed In the C case (1) consists of things like arrays, structs etc, but also types that are smaller than register sized  In addition the language / compiler may define additional calling conventions that may be faster in certain cases.",0.10714285714285714,c
12tz6f1,jhhkv21,"Have an undefined internal ABI, external ABI is the C ABI (limiting what can be exported)  2.",0.0,c
12tz6f1,jha214q,"I was trying to write a native Go adapter for C functions, something similar to FFI in the Rust language.",0.0,go
12tz6f1,jha214q,"I was trying to write a native Go adapter for C functions, something similar to FFI in the Rust language.",0.0,c
12tz6f1,jha214q,"I was trying to write a native Go adapter for C functions, something similar to FFI in the Rust language.",0.0,rust
12tz6f1,jha214q,"Saying native here I mean such an adapter which uses only Go compiler, i.e.",-0.10416666666666667,go
12tz6f1,jha214q,does not use any C compiler as in CGO.,0.0,c
12tz6f1,jhhjs4p,What do you mean “C does not define an ABI”.,-0.3125,c
12tz6f1,jhhjs4p,"While it is platform dependent (obviously), the C ABI is today what we all use when making OS calls.",0.0,c
12tz6f1,jh9vfnl,"Plus it is written in C, while the language you want to use it from isn't.",0.0,c
12tz6f1,jh9vfnl,"It's not just a question of having C compiler; many of these libraries require a whole eco-system of tools in order to build, where it's half of Linux, or a 6000MB VS download.",0.17777777777777778,c
12tz6f1,jhrmwgf,">How register sized types are passed In the C case   Why do you write ""In"" using a capital letter ""I"" ?",0.0,c
12tz6f1,jhisqhu,C is defined in terms of an Abstract Machine.,0.0,c
12tz6f1,jhisqhu,> C ABI is today what we all use when making OS calls.,0.0,c
12tz6f1,jhisqhu,"Whoever at Microsoft decided that ""Standard Call"" was how to talk to the OS and that ""C decl"" was not, clearly disagree(s|d) with you.",-0.025000000000000005,c
12tz6f1,jhisqhu,"Last time I used Windows, GCC also disagreed as I had to go out of my way to get OS interop due to ""the C ABI"" not matching the system DLLs' one.",-0.0625,go
12tz6f1,jhisqhu,"Last time I used Windows, GCC also disagreed as I had to go out of my way to get OS interop due to ""the C ABI"" not matching the system DLLs' one.",-0.0625,c
12tz6f1,jhj75go,Why would the C ABI be defined in the standard?,0.0,c
12tz6f1,jhj75go,"Rather, the C ABI basically is what the linker and OS on the OS / arch requires the ABI to be.",0.0,c
12tz6f1,jhja67q,> X defines an ABI  C does not define an ABI.,0.0,c
12tz6f1,jhja67q,"Windows and linkers disagree with each other, _when running on Windows._  > Why would the C ABI be defined in the standard  That is precisely what OP asked about, and what D does.",0.09166666666666667,c
12tz6f1,jhja67q,"Windows and linkers disagree with each other, _when running on Windows._  > Why would the C ABI be defined in the standard  That is precisely what OP asked about, and what D does.",0.09166666666666667,d
12tz6f1,jhjba7n,D defined part of its ABI as “conforming to the C ABI”.,0.0,d
12tz6f1,jhjba7n,D defined part of its ABI as “conforming to the C ABI”.,0.0,c
12tz6f1,jhjba7n,By definition the claim “C does not have an ABI” and “D has an ABI” cannot be true if the D ABI is defined from the C ABI.,0.35,c
12tz6f1,jhjba7n,By definition the claim “C does not have an ABI” and “D has an ABI” cannot be true if the D ABI is defined from the C ABI.,0.35,d
12tz6f1,jhjduas,"D also says there should exist a ""companion C compiler"" and that the ""C ABI"" is defined by that compiler.",0.0,d
12tz6f1,jhjduas,"D also says there should exist a ""companion C compiler"" and that the ""C ABI"" is defined by that compiler.",0.0,c
12tz6f1,jhjduas,"Because Bright (the dude behind D) also wrote C and C++ compilers, which have their own ABIs.",0.3,d
12tz6f1,jhjduas,"Because Bright (the dude behind D) also wrote C and C++ compilers, which have their own ABIs.",0.3,c
12tz6f1,jhjduas,"Because Bright (the dude behind D) also wrote C and C++ compilers, which have their own ABIs.",0.3,c++
12tz6f1,jhjduas,Also you misquote the spec; the real quote is   > The C ABI referred to in this specification means the C Application Binary Interface of the target system.,0.2,c
12tz6f1,jhjduas,"C and D code should be freely linkable together, in particular, D code shall have access to the entire C ABI runtime library.",0.18888888888888888,c
12tz6f1,jhjduas,"C and D code should be freely linkable together, in particular, D code shall have access to the entire C ABI runtime library.",0.18888888888888888,d
12tz6f1,jhjduas,"Implying the ""C ABI"" is variable, and in particular what is relevant is the one used by the compiler's selected C runtime library, which D compilers have to give access to.",0.2833333333333333,c
12tz6f1,jhjduas,"Implying the ""C ABI"" is variable, and in particular what is relevant is the one used by the compiler's selected C runtime library, which D compilers have to give access to.",0.2833333333333333,d
12tz6f1,jhefrd8,Some libraries built in C language use conditional preprocessing in header files and some structs have different contents on different platforms.,0.0,c
12tz6f1,jhefrd8,Now in Go language it is impossible to invent something internally because of its unstable internal ABI.,-0.2222222222222222,go
12tz6f1,jhefrd8,"I began studying Rust language because it provides a very wide compatibility layer, the FFI.",-0.13,rust
12tz6f1,jhefrd8,"I saw a list of languages supported by Rust's FFI and thought that this language is future, maybe it will even be able to partially replace C code in some projects in future.",0.1,rust
12tz6f1,jhefrd8,"I saw a list of languages supported by Rust's FFI and thought that this language is future, maybe it will even be able to partially replace C code in some projects in future.",0.1,c
12tz6f1,jhf1rr1,"Yeah, back in C, I used to use conditional preprocessing for includes of implementations and perhaps opaque pointers for polymorphism of OS specific structs, but I've never seen conditional preprocessing of fields; that seems quite odd.",-0.05555555555555555,c
12tjcbg,,Can anyone recommend a web assembly book from compiler perspective?,0.0,assembly
12tjcbg,jh4ywar,"* The spec is hard to read but it does go into the nitty gritty details, sometimes in very fine print: https://webassembly.github.io/spec/core/.",0.08333333333333336,go
12tjcbg,jh4y4vj,"Apparently actual WASM source code uses a similar syntax to Lisp (examples are surprisingly elusive to find; every site starts with examples that are not Wasm):      (module       (import ""env"" ""memory"" (memory 1))       (import ""env"" ""log"" (func $log (param i32 i32)))        (data (i32.const 0) ""Hello, World!"")",-0.05937500000000001,lisp
12tjcbg,jh97v90,"It's short but shows a C example side-by-side with  textual WASM ('WAT') and binary WASM, all clearly labeled.",0.05000000000000001,c
12tgsip,,"In my systems language and also in C, that needs to be done explicitly (C needs extensions to enable label pointers).",0.0,c
12tgsip,,I also did a C port [here](https://github.com/sal55/langs/blob/master/temp/sw.c).,0.0,c
12tgsip,,"The results with `gcc-O0` were 3.6 seconds, and with `gcc-O3` were 2.1 seconds (but results vary; using C transpiled from my language, I got 3.3 seconds and 4.2 seconds respectively - yeah, it got slower with `-O3`!).",0.0,c
12tgsip,,**eta:** I notice my C port doesn't have a `default` branch corresponding to my `else`.,0.0,c
12tgsip,jh6ir62,"This is also supported by the ""switch"" control structure of Pascal called ""case"".",0.0,pascal
12tgsip,jh6ir62,"using ""[ ]"" before the identifier, like Java and D, right ?",0.2857142857142857,java
12tgsip,jh6ir62,"using ""[ ]"" before the identifier, like Java and D, right ?",0.2857142857142857,d
12tgsip,jhkfkme,"I tried transpiling to C, but I don't trust that translation.",0.0,c
12tgsip,jhkfkme,"Next I tried writing a [custom C program](https://github.com/sal55/langs/blob/master/temp/fibvm.c) just for the VM execute function; mostly this was a framework machine-generated from my interpreter, with the handlers necessary filled in manually.",0.225,c
12tgsip,jhinepq,Forth newsgroup discussed this long time ago.,-0.05,forth
12tgsip,jh98kpl,"Python has recently acquired `match` I think it is, where you compare one thing against a range of possibilities.",0.0,python
12tgsip,jh6rx3q,"using ""\[ \]"" before the identifier, like Java and D, right ?",0.2857142857142857,java
12tgsip,jh6rx3q,"using ""\[ \]"" before the identifier, like Java and D, right ?",0.2857142857142857,d
12tgsip,jh6rx3q,"According to [dlang.org](https://dlang.org), D declarations go right to left:      int*[]*[3] d; // array of 3 pointers to dynamic arrays of pointers to ints  So a welcome improvement on C where types can be specified in up to 3 different places, eg.",0.21714285714285717,d
12tgsip,jh6rx3q,"According to [dlang.org](https://dlang.org), D declarations go right to left:      int*[]*[3] d; // array of 3 pointers to dynamic arrays of pointers to ints  So a welcome improvement on C where types can be specified in up to 3 different places, eg.",0.21714285714285717,go
12tgsip,jh6rx3q,"According to [dlang.org](https://dlang.org), D declarations go right to left:      int*[]*[3] d; // array of 3 pointers to dynamic arrays of pointers to ints  So a welcome improvement on C where types can be specified in up to 3 different places, eg.",0.21714285714285717,c
12tgsip,jh6rx3q,"But, it's rather different from the LTR scheme I use.",0.0,scheme
12tdn0d,,"The other day I was wondering: _""If my language supports its code being called from C, is there a way I can namespace the symbols my language exports to C in a convenient way?",-0.125,c
12tdn0d,,"""_  Of course, C doesn't have true namespaces in the same way that C++ or many other languages do, but nested named scopes to place functions (and global variables) in can be emulated slightly awkwardly using a struct of function pointers.",0.020833333333333332,c
12tdn0d,,"""_  Of course, C doesn't have true namespaces in the same way that C++ or many other languages do, but nested named scopes to place functions (and global variables) in can be emulated slightly awkwardly using a struct of function pointers.",0.020833333333333332,c++
12tdn0d,,"Take the following sample code in an imaginary C-like language that doesn't exist, declaring two prototypes in a given module's namespace:  ``` module my_module {     int transmogrify(         FILE* data     );      float butter_whicken(         float flams_per_neek,         bool growl     ); }; ```  and a possible C header and source file that get exported for them (NOTE that I've only provided C implementations of the functions to get a compiling example working, in practice the implementation functions would only be prototyped in C but actually defined in the exporting language (I guess that might make them not able to be `static` too, but I'm not completely clear on that...):  ``` // library Header file  #include <stdbool.h> #include <stdio.h> #include <stdlib.h>  struct my_module {     int (*transmogrify)(         FILE* data     );     float (*butter_whicken)(         float flams_per_neek,         bool growl     ); };  extern const struct     my_module my_module;  // library C file  static int transmogrify__implementation(     FILE* data ) {     return 0; // dummy value }  static float butter_whicken__implementation(     float flams_per_neek,     bool growl ) {     return 3.452f; // dummy value }  const struct my_module my_module = {     transmogrify__implementation,     butter_whicken__implementation, };  // program C file  int main(void) {     return my_module.butter_whicken(         my_module.transmogrify(stdout),         false     ); } ```  I can see some upsides and downsides to this approach...  #### Upsides: - `my_module.function_name()` is syntax commonly used for access member functions and module members in other languages, though not in C - Use of this form of scoping is arguably more readable than the more common `my_module_function_name()` in C  #### Downsides: - Two symbols per identifier are introduced.",0.06718749999999998,c
12tdn0d,,"- We don't get ""namespace merging"" across multiple source/header files as happens in C++.",0.0,c++
12tdn0d,,"- This seems a lot of effort to go to just to introduce some syntax sugar, in a language where people are well-accustomed to having to get their hands dirty using verbose code and techniques to get things done.",-0.6,go
12tdn0d,,"I'm aware this technique extends beyond the realm of C bindings to other languages, but I felt as to its slight laboriousness in setting up, making use of it in a scenario where the ""export header"" is machine-written could be a good opportunity to make use of it for little effort on the user's side.",0.09416666666666666,c
12tdn0d,jh2q8jq,You could also follow the C convention and allow specifying a prefix for all exported symbols.,0.0,c
12tdn0d,jh2q8jq,This follows the $(project)_$(function_name) naming convention that already exists in many C codebases and should make LTO much happier.,0.35,c
12tdn0d,jh2d8yt,"It can be cool if you can automate it for consumption in C.   However if I were to use the C API to bind to other languages, then my code would look funky.",0.11249999999999999,cool
12tdn0d,jh2d8yt,"It can be cool if you can automate it for consumption in C.   However if I were to use the C API to bind to other languages, then my code would look funky.",0.11249999999999999,c
12tdn0d,jh2izb1,Almost all of them requires either:  **1 To transpile to or generate a C full source equivalent of your P.L.,0.35,c
12tdn0d,jh2izb1,"**  **2 To compile and generate ""obj"" files compatible with a C Compiler, plus a C alike header file.",0.0,c
12tdn0d,jh2izb1,"**  In both cases, you need functions to follow a C identifier syntax.",0.0,c
12tdn0d,jh2izb1,"Let's have this source code example:             module lists      {         struct List { ... }                 int add (List* L, void* Item) { ... }      }  (1) One is to ""transpile"" your code as a C, using the namespace ID or a abbreviation of the module / namespace ID:  Like:      // lists.h       struct lists_List { ... };          int lists_add (List* L, void* Item) ;}           // lists.c       int lists_add (List* L, void* Item) { ... }      And generate the full source code for both files, or generate an ""object file"" and a C header file.",0.35,c
12tdn0d,jh2izb1,"So, another C program may access it like:      // anypprogram.c     #include ""list.h""     ...     struct lists_List* L =        malloc(sizeof(struct lists_list));     int* I =        malloc(sizeof(int));     *i = 1;     lists_add(L, i));     ...",0.0,c
12tdn0d,jh2izb1,"And, use it in your functions as a parameter:      // modules.h       struct module     {       int ModuleKey;       char ModuleName[128];     } ;           // lists.h     #include ""modules.h""           struct lists_List { ... };          int lists_add       (struct Module* M, List* L, void* Item) { ... }           // lists.c       int lists_add       (struct Module* M, List* L, void* Item) { ... }  Again, you will have to follow C function syntax, although you can add an additional metadata thru your module pointer.",0.0,c
12tdn0d,jh2izb1,"(3) A interface alike based version, like the one you posted:      // modules.h       struct Module     {       int ModuleKey;       char ModuleName[128];     } ;           // lists.h     #include ""modules.h""           struct lists_List { ... };          typedef        int (* lists_add_ftor )         (List* L, void* Item) ;          typedef       struct lists_Module       {          // shared metadata for any module:          struct Module Parent;                   lists_add_ftor add;                 // other functions functor       } ;           // singleton var for each module:     extern struct lists_Module*;           int lists_add       (List* L, void* Item) { ... }          // lists.c        // singleton var for each module:     extern struct lists_Module*;           int lists_add       (struct Module* M, List* L, void* Item) { ... }  Again, you need to follow the C syntax function.",-0.125,c
12tdn0d,jh2izb1,**Do you have or are planning to have a C source generation process ?,0.0,c
12tdn0d,jh3e9a1,"I was just thinking that if I'm going to generate some C header code anyway, I could have some fun and make it more ""elegant"", but this may be foolhardy if it harms optimisation.",0.43333333333333335,c
12tdn0d,jh2fkzj,">However if I were to use the C API to bind to other languages, then my code would look funky.",-0.125,c
12tdn0d,jh36gma,"On #1, it's also possible to use `$` in an identifier, which is accepted by GCC and MSVC, but is quite uncommon in regular C code, so you could use it to easily identify a ""module"", unlike using `_` which is common in variable names.",0.18666666666666668,c
12tdn0d,jh2p6zn,> Do you have or are planning to have a C source generation process ?,0.0,c
12tdn0d,jh2p6zn,"Sort of, only for functions exported from my language to be callable from C. I'm not planning to transpile to C currently, so this will be an extra feature that generates headers only.",0.0,c
12tdn0d,jh2p6zn,"The idea I have is that one may optionally declare functions in my language that are to be exported to C —such functions will have certain restrictions placed upon them so this can be done in a sane and well-defined way (a bit like how `extern ""C""` functions in C++ may not directly reference class objects in their signature, these need to be masked by an opaque pointer because C doesn't know what the hell's going on with thems fancy objects!).",0.07589285714285714,c
12tdn0d,jh2p6zn,"The idea I have is that one may optionally declare functions in my language that are to be exported to C —such functions will have certain restrictions placed upon them so this can be done in a sane and well-defined way (a bit like how `extern ""C""` functions in C++ may not directly reference class objects in their signature, these need to be masked by an opaque pointer because C doesn't know what the hell's going on with thems fancy objects!).",0.07589285714285714,c++
12tdn0d,jh2p6zn,"I intend to have a facility where on compiling said file (or when you run a certain command or something), file gets compiled to binary, and you also get a C header file with C code for the exported functions.",0.21428571428571427,c
12tdn0d,jh2p6zn,That header can then be used by a C compiler to link to the produced binary.,0.0,c
12tdn0d,jh2gv1x,"A C compiler may happily inline everything, but if I try to make a binding for some other language, the other compiler may just see a struct of pointer.",0.18333333333333335,c
12tdn0d,jh2gv1x,"I turned on my brain, and it may just need some wrappers if whatever I'm doing doesn't like C structs.",0.0,c
12tdn0d,jh2q6z5,"Then, you are going to have an optional feature in your compiler alike framework that generates a ""C"" header file and a ""binary file"" / ""object file"" pair.",0.0,c
12tdn0d,jh2q6z5,"Whatever you want to do, you need to generate an C equivalent that should follow C identifiers syntax, whether you mix the namespace / module ID with the function or type identifier, or not ...",0.0,c
12tdn0d,jh2q6z5,"I suggest, implement a fully ""your cool programming language"" transpiler to C first, and later turned into a full source code to binary code, where that binary code may be a single executable or pairs of header and binary ""intermediate / object"" files ...",0.1757142857142857,cool
12tdn0d,jh2q6z5,"I suggest, implement a fully ""your cool programming language"" transpiler to C first, and later turned into a full source code to binary code, where that binary code may be a single executable or pairs of header and binary ""intermediate / object"" files ...",0.1757142857142857,c
12tdn0d,jh3dwxk,">I suggest, implement a fully ""your cool programming language"" transpiler to C first,  It's a nice thought, and it would work, though currently I am planning to target libgccjit and LLVM IRbuilder",0.3,cool
12tdn0d,jh3dwxk,">I suggest, implement a fully ""your cool programming language"" transpiler to C first,  It's a nice thought, and it would work, though currently I am planning to target libgccjit and LLVM IRbuilder",0.3,c
12tdn0d,jh4r56r,"Yes, I'm aware (I even used it for said code) but I neglected to pay attention to the assembly!",0.3125,assembly
12t40pf,,"Hello everyone, last month I shared my programming language in this [post](https://www.reddit.com/r/ProgrammingLanguages/comments/11n2cpy/jot_programming_language/), it was called Jot but thanks to people in the comment, I discovered that the name is not unique and there is a language with the same  The new name is Amun, is come from ancient Egyptian mythology, to read more information about the name [https://en.wikipedia.org/wiki/Amun](https://en.wikipedia.org/wiki/Amun)    Github: https://github.com/amrdeveloper/amun    I have implemented some new features to the language for example  Tuples      fun max_min(x int64, y int64) (int64, int64) {         return if (x > y) (x, y) else (y, x);     }          fun make_tuple<T>(x T, y T) (T, T) = (x, y);          var tuple = (1, 2, ""Hello"", 3, ""World"");  Compile time constants      const ONE = 1;     const TWO = 2;  Generic Struct      struct Pair<T, E> {        first T;        second E;     }  Generic Functions      fun make_pair(x T, y E) Pair<T, E> {        return Pair<T, E> (x, y);     }  String support      for (""Hello, World"") {         printf(""%c"", it);     }          printf(""%d\\n"", ""A"" == ""B"");     printf(""%d\\n"", ""A"" != ""B"");     printf(""%d\\n"", ""A"" > ""B"");     printf(""%d\\n"", ""A"" >= ""B"");     printf(""%d\\n"", ""A"" < ""B"");     printf(""%d\\n"", ""A"" <= ""B"");  Foreach rename element and index      for array {}     for element : array {}     for element, index : array{}  Lambda outside parentheses in function call and constructor      fun let(p *void, callback *() void) void {         if (p != null) {             callback();         }     }          let(point) {         printf(""Point instance is not null\\n"");     };          let(null) {         printf(""Will never print\\n"");     };  Thanks for the feedback and suggestions and if you have time feel free to check the samples and website  I am still working on the language and tested it with applications  The pong game is written in Amun with Raylib: [https://youtu.be/lQt4s0haPGw](https://youtu.be/lQt4s0haPGw)",0.015237603305785134,c
12t2opo,,Vortex (previously Ripple) now has the ability to interop with C or C++ (extern C) libraries!,-0.20833333333333331,c
12t2opo,,Vortex (previously Ripple) now has the ability to interop with C or C++ (extern C) libraries!,-0.20833333333333331,c++
12t1782,jh0yz84,This is so cool!,0.4375,cool
12szecp,jh4eeim,*Cool new features!,0.2602272727272727,cool
12szecp,jh4eeim,* Go recently got generics.,0.0,go
12szecp,jh4eeim,C++ is a monstrum.,0.0,c++
12szecp,jh932rm,"BTW, C++ was designed by a committee.",0.0,c++
12szecp,jh4gzb8,"See the reoccurring debates on e. g. not doing generics with `<>` and the usual response of ""but C++ did it so it can't be wrong!!!"".",-0.61328125,c++
12szecp,jh5dnoi,>  C++ is a monstrum.,0.0,c++
12szecp,jh5c6q9,"why is python like this?""",0.0,python
12srawa,,"[https://github.com/samsquire/compiler](https://github.com/samsquire/compiler)  I do code generation manually, not through assembly like my python compiler (in the same repository) and not in the same style as my python assembler [https://github.com/samsquire/assembler](https://github.com/samsquire/assembler) .",0.0,assembly
12srawa,,"[https://github.com/samsquire/compiler](https://github.com/samsquire/compiler)  I do code generation manually, not through assembly like my python compiler (in the same repository) and not in the same style as my python assembler [https://github.com/samsquire/assembler](https://github.com/samsquire/assembler) .",0.0,python
12srawa,,So here's my plans:  I adapted the garbage collector at  [Writing a Simple Garbage Collector in C (maplant.com)](http://maplant.com/gc.html)  to add extremely primitive simple register scanning.,-0.041666666666666664,c
12srawa,,Imagine being capable of running processes similar to BEAM and Go but with JIT.,0.1,go
12srawa,jgzy18g,The thread yields to the scheduler while checking the loop conditions in your scheme.,0.0,scheme
12srawa,jh0hsr5,Maybe you could look into how some Scheme and ML implementations use continuations to implement threads.,0.0,scheme
12srawa,jgzylsz,In Java that's LockSupport.park()  I still think my scheme is efficient and useful because it doesn't require any additional conditions and takes advantage of the existing loop that was running anyway.,0.3,java
12srawa,jgzylsz,In Java that's LockSupport.park()  I still think my scheme is efficient and useful because it doesn't require any additional conditions and takes advantage of the existing loop that was running anyway.,0.3,scheme
12srawa,jh2d9rb,The important thing to understand about my scheme is that there is no action that the running thread needs to cooperate with that it wouldn't have done anyway if my scheme was not being used.,0.17500000000000002,scheme
12srawa,jh2d9rb,There is NO cooperation at descheduling time in my scheme.,0.0,scheme
12srawa,jh2d9rb,"Unlike Java's LockSupport.park, or Erlang's reduction yield check and Go's stack preemtible growth check (which I don't know if it still uses) and wasmtime's fuel implementation, my solution doesn't require any cooperation at descheduling time that the process wouldn't have already done.",0.0,java
12srawa,jh2d9rb,"Unlike Java's LockSupport.park, or Erlang's reduction yield check and Go's stack preemtible growth check (which I don't know if it still uses) and wasmtime's fuel implementation, my solution doesn't require any cooperation at descheduling time that the process wouldn't have already done.",0.0,erlang
12srawa,jh2d9rb,"Unlike Java's LockSupport.park, or Erlang's reduction yield check and Go's stack preemtible growth check (which I don't know if it still uses) and wasmtime's fuel implementation, my solution doesn't require any cooperation at descheduling time that the process wouldn't have already done.",0.0,go
12srawa,jh2d9rb,There is no hidden yields implemented by my scheme.,0.08333333333333333,scheme
12srawa,jh2kk9f,"That is why Java's Loom is so awesome, because the IO doesn't block a Loom lightweight thread scheduled kernel thread   I'm not sure if they reschedule IO calls to a IO thread pool or something.",0.375,java
12sb8ig,,&#x200B;  EDIT: right now my compiler transpiles to C++ and I have a defer macro that I use to translate the defer stmt.,0.2857142857142857,c++
12sb8ig,,This relies on C++ RAII but I want to implement it without dependening on it.,0.0,c++
12sb8ig,jgxt9pw,"There is the Go style defer, which calls the defered code at the end of the function, or a scope based defer, which calls the defered code at the end of a scope.",0.0,go
12sb8ig,jgxt9pw,"This might be totally okay for your language (my language leans more on the C side of things, so having some hidden allocation for the defer would be a huge no no).",0.30833333333333335,c
12sb8ig,jh0is21,"Here's something else to consider: in go, you have to use a function call, but the arguments are strict.",0.0,go
12sb8ig,jgzmkti,"&#x200B;  &#x200B;  ¹) IIUC, defer as used in Go, which is what pops up when googling ""defer statement"", is like (`𝐝𝐞𝐟𝐞𝐫 P(x) ; Q)` becoming `(𝐩𝐫𝐨𝐜 Pdeferred: P(x) ; Q ; Pdeferred)` , iow creating a parameterless closure such that the argument x is evaluated at the beginning, but the closure and thereby procedure P is only executed at the end.",0.15,go
12sb8ig,jh071n8,(https://github.com/thradams/cake/issues/22)  ```c void f(){    defer something;    if (condition)      return; /*list of defers*/    }  /*list of defers*/ ```  What I am planning to do is to created a linked list of defers statements that are added into AST at end of each scope and at jumps.,0.0,c
12sb8ig,jgxu42j,"Mine, too, is more to the C side of things, tho I think a new feature would break this (defer on error).",0.3181818181818182,c
12sb8ig,jh0w6mf,"Go is too weird, and I won't be implementing it that way.",-0.5,go
12sb8ig,jh0fmcz,It basically behaves like C++ destructors.,0.0,c++
12sb8ig,jh0fmcz,Go defer statement is a weird approach as is not scope based but function scope based.,-0.5,go
12sb8ig,jh9tsr4,Go?,0.0,go
12sb8ig,jh1zq5d,I cant remember if C++ optimized these stuff.,0.0,c++
12sb8ig,jhalcik,I transpile my language to C++ and use said mechanism,0.0,c++
12sb8ig,jh0hifz,"llvm-ir is the obvious example, and i believe lua also falls into that category, but i'd say the main case is compiling to a target language that doesn't support exceptions at all, like arm64, x64, wasm, c, etc.",0.08333333333333333,lua
12sb8ig,jh0hifz,"llvm-ir is the obvious example, and i believe lua also falls into that category, but i'd say the main case is compiling to a target language that doesn't support exceptions at all, like arm64, x64, wasm, c, etc.",0.08333333333333333,c
12rmkjc,,"My goal is not to replace C, Rust or Go.",0.0,c
12rmkjc,,"My goal is not to replace C, Rust or Go.",0.0,rust
12rmkjc,,"My goal is not to replace C, Rust or Go.",0.0,go
12rmkjc,,"My plan is to do the front end in Go, and the backend in LLVM and if I figure out how, re-use Pony's runtime.",0.0,go
12rmkjc,jgv63y4,Maybe you're planning on using a zero value like in Go?,0.0,go
12rmkjc,jgvivus,That just sounds like lisp with extra steps.,0.0,lisp
12rmkjc,jgvivus,"(Sorry, that's very snarky of me, but lisp is king of data-as-code-as-data.)",-0.15,lisp
12rmkjc,jgzcddk,"Tcl is often written off, but I think its got some great ideas to this end.",0.8,tcl
12rmkjc,jguzajl,"Of course in my imaginary compiler everything works, I'll see how things go when I implement this.",0.0,go
12rmkjc,jgwdm0c,"If anything this more closely resembles Smalltalk, and the way blocks are parallel by default means that useful functions look a little like Prolog.",0.153125,prolog
12rmkjc,jgwdm0c,"Lisp has code-as-data, but Smalltalk and Prolog (and, it seems, Yz) have *data-as-code*, with data being implicitly structured by the procedures that create or access it",0.0,lisp
12rmkjc,jgwdm0c,"Lisp has code-as-data, but Smalltalk and Prolog (and, it seems, Yz) have *data-as-code*, with data being implicitly structured by the procedures that create or access it",0.0,prolog
12rmkjc,jgx7cyk,>Mine's concurrent by default  That's pretty cool.,0.3,cool
12rmkjc,jidv9wq,"Back to `public static final please get out of the way greet = ""hi""` programming I started to wish of a PL where I can just remove stuff until there's nothing but blocks of code, but not to the extent of Lisp, but rather as ""familiar"" as JSON and remembered the idea of control structures  as functions and started to learn how many programming languages do things.",0.22916666666666666,lisp
12rmkjc,jgxmvw5,"{     ""true block""  } {    ""false block"" } ```  I learned to program in Lisp using recursion so definitely there must be something there, but if I have to be honest I think there more of JSON than Lisp.",0.20999999999999996,lisp
12rm0s6,,"When we generate machine code, we often need to refer to particular fields off objects in the stack and inside those structs, in at&t assembly we might use ""14-(%rip)"" to refer to data relative to a symbol.",0.08333333333333333,assembly
12rm0s6,,"Like Object in Java, GObject (  [GObject - Wikipedia](https://en.wikipedia.org/wiki/GObject)  ) these represent a global sum type that everyone derives from.",0.0,java
12rm0s6,jgxzc6h,So parallel builds and use of dynamic libraries go out the window.,0.0,go
12rm0s6,jgybdp2,"So, if you have an AST like:      enum ItemType     {         itInteger,         itChar,         itFloat,         itString,     } ;      union VariantItem     {         int I;         char C;         float F;         chat* S[256];     } ;          struct ASTItem     {       union VariantItem;              enum ItemType;       struct ASTItem* Parent;             // other fields      } ;        And replace it with:      enum ItemType     {         itInteger,         itChar,         itFloat,         itString,     } ;           struct ASTItem     {       // void* VariantItem;       nullptr_t VariantItem;            enum ItemType;       struct ASTItem* Parent;             // other fields       } ;      This way, you can handle different object / data types with different size.",-0.0625,c
12rm0s6,jgvx52o,I want my Ruby code to be capable of interacting with my Rust code.,0.2,ruby
12rm0s6,jgvx52o,I want my Ruby code to be capable of interacting with my Rust code.,0.2,rust
12rm0s6,jgvx52o,Or my Erlang code with my Java code.,0.0,erlang
12rm0s6,jgvx52o,Or my Erlang code with my Java code.,0.0,java
12rm0s6,jgvv7cy,"In Java if I want to inject a dependency to an interface, I can do that, but I cannot change the interface because that would break all original implementations of the interface.",0.375,java
12rm0s6,jgxmxfj,"----  I think you should go away, focus on a problem statement comment, one without *any* hint at a solution of any kind, just 2 good problem examples.",0.6499999999999999,go
12rm0s6,jgxmxfj,>I want my Ruby code to be capable of interacting with my Rust code.,0.2,ruby
12rm0s6,jgxmxfj,>I want my Ruby code to be capable of interacting with my Rust code.,0.2,rust
12rm0s6,jgxmxfj,Or my Erlang code with my Java code.,0.0,erlang
12rm0s6,jgxmxfj,Or my Erlang code with my Java code.,0.0,java
12rm0s6,jgxmxfj,"And yes, one of the ways it currently achieves compatibility in practice is via the C FFI of implementations.",0.0,c
12qyhva,jgxg90x,This also includes some live-coding in Haskell towards the end.,0.0,haskell
12qyhva,jgt2obw,"Sounds cool, did you get far with that idea?",0.22499999999999998,cool
12qyhva,jgt7v4r,Common Lisp has mechanisms for :before :after and :around methods.,-0.3,lisp
12qn3na,,"):      i := (<<(<<x)[a][b])[c];  And the suggestion was for something better like Odin's:      i := x^[a][b]^[c];  Which certainly is better, but something I don't really pay attention to since I usually do my own thing.",0.21000000000000002,c
12qn3na,,"Then I wondered how my language deals with that example, since it also uses postfix `^`, and it's like this:      i := x^[a, b]^[c]  One difference (an important one for me), is that successive indices can go inside one pair of `[ ]` (typing `][` instead of `,` is horrible; thank you C for popularising that).",-0.3,c
12qn3na,,"Then I wondered how my language deals with that example, since it also uses postfix `^`, and it's like this:      i := x^[a, b]^[c]  One difference (an important one for me), is that successive indices can go inside one pair of `[ ]` (typing `][` instead of `,` is horrible; thank you C for popularising that).",-0.3,go
12qn3na,,"But my recent compilers make that dereference op optional; it then becomes:      i := x[a, b][c]  Then I thought, could I bring that `c` into the first set of brackets (I've never tried it)?",0.125,c
12qn3na,,"Apparently you can, so it becomes:      i := x[a, b, c]  But with some loss of transparency (which parts are pointers?).",0.05,c
12qn3na,jgqy8vh,In any case am I understanding correctly that `int i = (*(*x[a][b]))[c];` is the C code for this?,-0.75,c
12qn3na,jgqy8vh,"If so, I use `let i = x**a*b**c` for this, which can be parenthesized `(((((x *) * a) * b) *) * c)`.",0.25,c
12qn3na,jgr9b0r,"i : Int = ^(^x(a)(b))(c)  Not the best, but pointer use is discouraged in this language because I have type-safe references.",1.0,c
12qn3na,jgr9b0r,"i = (x^ (a) (b))^ (c)  I have built-in support for multidimensional arrays (2D and 3D only), so if there are same number of elements in the inner arrays, it can instead be:      x : ^[Array2D[^Array[Int]]]     i = ^(^x (a, b)) (c)  Another option could be to have `deref` as a unary function and use the forward pipe operator `|>`.",-0.1875,c
12qn3na,jgr9b0r,"i = ((deref x) (a, b) |> deref) (c)",-0.75,c
12qn3na,jgr0e4e,"Postfixed ""^"" is used in Pascal:       x^ = 5;   as C's prefixed ""*"":      *x = 5;  Just a matter of taste, both work.",0.0,pascal
12qn3na,jgr0e4e,"Postfixed ""^"" is used in Pascal:       x^ = 5;   as C's prefixed ""*"":      *x = 5;  Just a matter of taste, both work.",0.0,c
12qn3na,jgr0e4e,"You are also using Pascal's array indexing like:      a[5, 3] = 2;  Instead of C's array indexing like:       a[5][3] = 2;  Also, both work.",0.0,pascal
12qn3na,jgr0e4e,"You are also using Pascal's array indexing like:      a[5, 3] = 2;  Instead of C's array indexing like:       a[5][3] = 2;  Also, both work.",0.0,c
12qn3na,jgr0e4e,Since I have both a Pascal syntax alike P.L.,0.0,pascal
12qn3na,jgr0e4e,"concept project, and a C syntax alike P.L.",0.0,c
12qn3na,jgr0e4e,"Let's start with how are declared, Pascal style first:      type        // ""array of int (s)""       TypeA = array [0..5] of integers;           ...     var A: TypeA;     A[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""an array of int (s)""       TypeB = ^TypeA;           ...     var B: TypeB;     B^[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC = ^TypeB;           ...     var C: TypeC;     C^^[5-1] := 3;     ...       type        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD = TypeC[0..3];           ...     var D: TypeD;     D[3-1]^^[5-1] := 3;     ...           type        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeE = TypeD[0..9];           ...     var E: TypeE;     E[9-1][3-1]^^[5-1] := 3;     ...           type        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF = ^TypeE;           ...     var F: TypeF;     F^[9-1][3-1]^^[5-1] := 3;     ...       And it's C style counterpart:      typedef        // ""array of ints""       int TypeA[5];          ...     TypeA A;     A[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""an array of int (s)""       TypeA *TypeB;          ...     TypeB B;     B^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeB *TypeC;          ...     TypeC C;     C^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC TypeD[3];          ...     TypeD D;     D^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD TypeE[0..9];          ...     TypeE E;     E[9-1]^^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF *TypeE;          ...     TypeF F;     F^[9-1]^^[5-1] = 3;     ...       **Other P.L.",0.0625,pascal
12qn3na,jgr0e4e,"Let's start with how are declared, Pascal style first:      type        // ""array of int (s)""       TypeA = array [0..5] of integers;           ...     var A: TypeA;     A[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""an array of int (s)""       TypeB = ^TypeA;           ...     var B: TypeB;     B^[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC = ^TypeB;           ...     var C: TypeC;     C^^[5-1] := 3;     ...       type        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD = TypeC[0..3];           ...     var D: TypeD;     D[3-1]^^[5-1] := 3;     ...           type        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeE = TypeD[0..9];           ...     var E: TypeE;     E[9-1][3-1]^^[5-1] := 3;     ...           type        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF = ^TypeE;           ...     var F: TypeF;     F^[9-1][3-1]^^[5-1] := 3;     ...       And it's C style counterpart:      typedef        // ""array of ints""       int TypeA[5];          ...     TypeA A;     A[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""an array of int (s)""       TypeA *TypeB;          ...     TypeB B;     B^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeB *TypeC;          ...     TypeC C;     C^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC TypeD[3];          ...     TypeD D;     D^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD TypeE[0..9];          ...     TypeE E;     E[9-1]^^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF *TypeE;          ...     TypeF F;     F^[9-1]^^[5-1] = 3;     ...       **Other P.L.",0.0625,c
12qn3na,jgr0e4e,"Let's start with how are declared, Pascal style first:      type        // ""array of int (s)""       TypeA = array [0..5] of integers;           ...     var A: TypeA;     A[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""an array of int (s)""       TypeB = ^TypeA;           ...     var B: TypeB;     B^[5-1] := 3;     ...      type        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC = ^TypeB;           ...     var C: TypeC;     C^^[5-1] := 3;     ...       type        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD = TypeC[0..3];           ...     var D: TypeD;     D[3-1]^^[5-1] := 3;     ...           type        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeE = TypeD[0..9];           ...     var E: TypeE;     E[9-1][3-1]^^[5-1] := 3;     ...           type        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF = ^TypeE;           ...     var F: TypeF;     F^[9-1][3-1]^^[5-1] := 3;     ...       And it's C style counterpart:      typedef        // ""array of ints""       int TypeA[5];          ...     TypeA A;     A[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""an array of int (s)""       TypeA *TypeB;          ...     TypeB B;     B^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeB *TypeC;          ...     TypeC C;     C^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeC TypeD[3];          ...     TypeD D;     D^^[5-1] = 3;     ...          typedef        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeD TypeE[0..9];          ...     TypeE E;     E[9-1]^^[5-1] = 3;     ...          typedef        // ""pointer (s) of""        // ""array of""        // ""array of""        // ""pointer (s) of""        // ""pointer (s) of""        // ""an array of int (s)""       TypeF *TypeE;          ...     TypeF F;     F^[9-1]^^[5-1] = 3;     ...       **Other P.L.",0.0625,d
12qn3na,jgr0e4e,"(s)**  Ada with Pascal alike syntax uses ""pointer"" at declaration, but ""^"" as an operator in expressions.",0.0,ada
12qn3na,jgr0e4e,"(s)**  Ada with Pascal alike syntax uses ""pointer"" at declaration, but ""^"" as an operator in expressions.",0.0,pascal
12qn3na,jgr0e4e,"type       PByte = pointer to Byte;     ...     var P: PByte;     ...     P^ := 5;     ...       D and Java, both C alike syntax, uses the same ""*"" and ""[ ]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,d
12qn3na,jgr0e4e,"type       PByte = pointer to Byte;     ...     var P: PByte;     ...     P^ := 5;     ...       D and Java, both C alike syntax, uses the same ""*"" and ""[ ]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,java
12qn3na,jgr0e4e,"type       PByte = pointer to Byte;     ...     var P: PByte;     ...     P^ := 5;     ...       D and Java, both C alike syntax, uses the same ""*"" and ""[ ]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,c
12qn3na,jgsh6ny,"`*x` is wildly known as how dererencing is done in C, so there is scope for confusion.",0.1,c
12qn3na,jgsh6ny,"And `<<` is a prefix operator, which suffers from the same problems of C's `*` that I related elsewhere.",-0.19999999999999998,c
12qn3na,jgrt2zm,"I reject this; we can have a special `NEW` singleton object and overload the normal `[]` operator with its type, so we can write `a[NEW]=val`  * Another singleton (actually, probably not) object is `END`, which has an overloaded `-` operator (and presumably `+` as well), so we can do `a[END-1]` without running into all the disasters of the Python approach.",0.16087662337662337,python
12qn3na,jgweapp,"For what is worth, even Dennis Ritchie acknowledged that the dereferencing syntax in C is less than ideal (and that a postfix operator would've been better):  &#x200B;  >An accident of syntax contributed to the perceived complexity of the language.",0.38333333333333336,c
12qn3na,jgweapp,"The indirection operator, spelled \* in C, is syntactically a unary prefix operator, just as in BCPL and B.",0.0,c
12qn3na,jgweapp,Declarations in C must be read in an \`inside-out' style that many find difficult to grasp \[Anderson 80\].,0.0,c
12qn3na,jgtitoa,"See [the clockwise spiral rule](https://c-faq.com/decl/spiral.anderson.html) for C which is *terrible* both for the parser and for the programmer - you end up with things like `void (f(void (*)(int, int), void (*)(int, int)))(int, int);`^\[0] which is a perfectly legal declaration C for a convoluted, yet plausible, situation.",0.04,c
12qn3na,jgtitoa,"The above example in C turns into `FUNCT f(@FUNCT(INT4, INT4): VOID, @FUNCT(INT4, INT4): VOID): FUNCT(INT4, INT4): VOID;`^\[1], which, although wordier, is *a lot* more straightforward.",0.2916666666666667,c
12qn3na,jgtitoa,"Your example, with the array, would, I believe, turn into `VAR i: INT4 = x[a,b]@@[c];` where `x` is declared as `VAR x: [A,B]@@[C]INT4;` and `A`, `B`, and `C` are the highest values `a`, `b`, and `c`, respectively, can be.",-0.375,c
12qn3na,jgtitoa,"`x[a,b]@@[c]` unravels everything except the `INT4`, so we know its value will be of the type `INT4`.",0.0,c
12qn3na,jgtitoa,Even solutions other than C make (IMO) mistakes such as putting the array type *after* the primary type (as in `char[]`) which makes it *somewhat* easier to parse and *somewhat* more intuitive but... not wholly.,0.19375,c
12qn3na,jgtitoa,"The other neat property of this is that a type is *always* distinguishable from anything else - the `@` (pointer) sign, for example, is prefixed in a type and postfixed in actual usage, as is every other part of a type - meaning that type casts have a much simpler syntax than in C. To cast some pointer to your array type above is as simple as `[A,B]@@[C]INT4(y)` - a bit confusing compared to other syntaxes, but a lot more useful in terms of i.e.",0.0325,c
12qn3na,jgtitoa,"In C, I have to type something like `((struct object *)thing)->data`, a pattern which only gets more unintuitive as the data becomes more complex.",0.19,c
12qn3na,jgtitoa,"This is a lot like Go's solution, except Go didn't quite do it right - there are still cases where you have to parenthesize the type, which actually makes things worse (i.e., something like `(type)(data)`).",-0.038095238095238106,go
12qn3na,jgtitoa,"In C, function pointers are automatically dereferenced: `void (*f)(int x);` can be called with`f(1)`.",0.0,c
12qn3na,jgtitoa,because this is where C turns into gibberish.,0.0,c
12qn3na,jgrg1u6,"In my language, a variable of that type would most likely be declared as     `integer[] array[o] pointer array[n, m] pointer x;` For use, you'd just do     `integer[] i = x[a, b][c];` Dereferencing the pointer type is also optional in my language before doing a subscript, call, or member access.",0.25,c
12qn3na,jgrg1u6,"I wouldn't go so far as to coalesce all indexing since I'd say that's an important distinction in the data structure; the reason I have that subscript of a and b is because it's indexing a multidimensional array, but you could use two unidimensional array types instead if you really wanted to.",0.2333333333333333,go
12qn3na,jgryjiq,"well, i'm working on a toy functional lang that has pointers, but they're not fun to work with  the syntax for this would be ``` x .load .at a, .at b, .load .at c ```",-0.15,c
12qn3na,jgsiup6,"I like Scopes syntax:  - `@ reference` is dereferencing - `@reference` is also allowed (prefix instead of function call, can avoid parentheses) - `@ array index` is array access - `array @ index` as a binary operator, infix notation is allowed as well - `multiarray @ index1 @ index2 @ index3` multiarray access still more concise without the need of a special syntax - `@ multiarray index1 index2 index3` is the same as a variadic macro - `(@ (@ @value index1 index2)) @ index3` same as C `(*((*value)[index1][index2]))[index3]`",0.19142857142857142,c
12qn3na,jgsqw0w,So you can say `example : int ^ a ^ 1 ^ b ^ c ^ 1` and use `example.i.().j.k.()`.,0.0,c
12qn3na,jgsqw0w,"You can also explicitly _convert_, `example convert : int ^ (a * b * c)`, because these types are isomorphic, and the compiler can automatically derive the conversion: ((((x^(a))^(1))^(b))^(c))^(1) ≅ x^(abc).",-0.75,c
12qn3na,jgsqw0w,When you choose representations (written in postfix) such as `int  #a arr  ptr  #b arr  #c arr  ptr` and `int #(a * b * c) arr` then you can tell whether the derived cast is merely an isomorphism/conversion or also a zero-cost equivalence/coercion.,-0.25,c
12qn3na,jgsqw0w,"However, the part of the conversion between `#b arr  #c arr` and `#(b * c) arr` is free regardless.",0.4,c
12qn3na,jgtdo4f,"You'd be able to access it nonetheless, with a lot of work, since array indexing always returns an option:      proc F[take seq:&**&*int, a:int, b:int, c:int] int do         match seq[a] as x         case *&*int then (             match x[b] as y             case &*int then (                 match y[c] as z                 case int then z                 case nil then fatal[""out of bounds""]             )             case nil then fatal[""out of bounds""]         )         case nil then fatal[""out of bounds""];  Notice that this is only possible if you `take` ownership of `seq`, otherwise you'd be invalidating an object that you do not own, which is a compile time error.",0.05,c
12qn3na,jgybgmf,"In my lang, you can ""index"" with several ""selectors"":  ```  let city = [name = ""Miami"", ""Medellin""; state = ""FL"", ""Antioquia""]  let first = city # 0 let first = city # [true, false] let first = city # :first let first = city # [name = ""Miami""] let first = city?where name = ""Miami""  let reversed = city # 1, 0 let reversed = city # :last, :first  let all = city # [true, true] ```  Internally `#` is an operator that could run the equivalent of Rust `[..].iter().find(..)`",0.17142857142857143,rust
12qn3na,jgrc5e7,>In any case am I understanding correctly that `int i = (*(*x[a][b]))[c];`  Yes; if you managed that without using a tool then I'm impressed!,0.125,c
12qn3na,jgrc5e7,">If so, I use `let i = x**a*b**c` for this, which can be parenthesized `(((((x *) * a) * b) *) * c)`.",0.25,c
12qn3na,jgrgvrl,"\[`*` or `^` deref ops\]  Actually, C's `*` deref op works very poorly.",-0.26,c
12qn3na,jgrgvrl,"And for pointer-to-function, it would need `(*P)()`, except C allows `P()` without the deref.",0.0,c
12qn3na,jgrgvrl,"\[ Typing `[i,j] or [i][j]`\]  The first form is definitely sweeter, but C can't use that `[i,j]` because it decided to have a `comma operator`, so that `A[i,j]` means `i; A[j]`.",0.125,c
12qn3na,jgrgvrl,">D and Java, both C alike syntax, uses the same ""\*"" and ""\[ \]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,d
12qn3na,jgrgvrl,">D and Java, both C alike syntax, uses the same ""\*"" and ""\[ \]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,java
12qn3na,jgrgvrl,">D and Java, both C alike syntax, uses the same ""\*"" and ""\[ \]"" operators, but are declared together with the type, not with the identifier, I think this is much better.",0.25,c
12qn3na,jgrgvrl,I think it is well known that C is a basketcase in this area.,0.0,c
12qn3na,jgv0ch9,"Actually, I didn't devise this; I copied it from Algol 68, some decades ago.",0.0,algol
12qn3na,jgv0ch9,C is much more chaotic.,0.5,c
12qn3na,jgv0ch9,"Given the simpler type `pointer to array of int`, which I'd declare as `ref[]int P` and C as `int (*P)[]`, then you access the element by doing a deref first followed by the indexing:      P^[i]            # Mine, using ^ to make things transparent     (*P)[i]          # C  However, in C deref and index operators are completely interchangeable; you can do the index first then deref:      *(P[i])           # C, usually written as *P[i]  This is mind-boggling: given any chain of index and deref ops, C can mix and match them, and it is still valid C, except that only one will be correct.",0.14166666666666666,c
12qn3na,jgv0ch9,"Given the C solution to the type in the OP:      i = (*(*x)[a][b])[c];  You change any `*` to `[]` or vice versa, and it still compiles, so long as you have 5 in all.",-0.4,c
12qn3na,jgv0ch9,"It's not bothered with parentheses either, for example, these are both valid, as are the other 29 combinations:      i = *****x;     i = x[a][b][c][d][e];  Have I mentioned that C was a basketcase?",-0.125,c
12qn3na,jgv0ch9,"It's not bothered with parentheses either, for example, these are both valid, as are the other 29 combinations:      i = *****x;     i = x[a][b][c][d][e];  Have I mentioned that C was a basketcase?",-0.125,d
12qn3na,jgrgy7z,There are tools to translate Odin to C?,0.0,c
12qn3na,jgsngdh,"**  In Pascal, ( yes the later versions of Pascal have pointers ), C ""&"" PTR address operator is ""@"", which is not used for anything else, as well as for the PTR contents""^"" operator.",0.0,pascal
12qn3na,jgsngdh,"**  In Pascal, ( yes the later versions of Pascal have pointers ), C ""&"" PTR address operator is ""@"", which is not used for anything else, as well as for the PTR contents""^"" operator.",0.0,c
12qn3na,jgsngdh,"So is C ""*' PTR contents, and the equivalent Pascal is ""^"".",0.0,c
12qn3na,jgsngdh,"So is C ""*' PTR contents, and the equivalent Pascal is ""^"".",0.0,pascal
12qn3na,jgsngdh,"I never liked the C / C++ ""array same as pointers"".",-0.15,c
12qn3na,jgsngdh,"I never liked the C / C++ ""array same as pointers"".",-0.15,c++
12qn3na,jgsngdh,"In Pascal arrays to pointers always use the PTR address operator for arrays, unlike C ""PTR address not necessary"".",0.0,pascal
12qn3na,jgsngdh,"In Pascal arrays to pointers always use the PTR address operator for arrays, unlike C ""PTR address not necessary"".",0.0,c
12qn3na,jgsngdh,"For a procedural, C alike, P.L., I was considering a required  prefixed ""&&"" for global functors instead of the optional prefixed ""&"".",0.0,c
12qn3na,jgsngdh,"So a procedural example would be:       int add (int a, int b) { ... }      int subs (int a, int b) { ... }      int mul (int a, int b) { ... }           TypeDef          int (int a, int b) ** intfunctor;          ...     intfunctor f = nullptr;          // required ""&&"" instead of optional ""&"",     // for functors and required ""()""     f = &&add();          int c = (**f)(x, y);     ...          // or also,     // infix alternative usage of ""->"",     // instead of prefixed *, for functors     int c = f->(x, y);     ...  For an O.O., C++ alike, P.L., I was considering a prefixed ""&&&"" for C++ alike methods.",-0.75,c
12qn3na,jgsngdh,"So a procedural example would be:       int add (int a, int b) { ... }      int subs (int a, int b) { ... }      int mul (int a, int b) { ... }           TypeDef          int (int a, int b) ** intfunctor;          ...     intfunctor f = nullptr;          // required ""&&"" instead of optional ""&"",     // for functors and required ""()""     f = &&add();          int c = (**f)(x, y);     ...          // or also,     // infix alternative usage of ""->"",     // instead of prefixed *, for functors     int c = f->(x, y);     ...  For an O.O., C++ alike, P.L., I was considering a prefixed ""&&&"" for C++ alike methods.",-0.75,c++
12qn3na,jgsngdh,"example would be:      class AClass     {       //...      int add (int a, int b) { ... }      // ...     }           class BClass     {       //...      int subs (int a, int b) { ... }      // ...     }           class CClass     {       //...      int  mul (int a, int b) { ... }      // ...     }           TypeDef          int (int a, int b) *** intobjfunctor;          ...     ClassA A = new AClass( );     ClassB B= new BClass );     ClassC C= new CClass( );          intobjfunctor f = nullptr;          // required ""&&&"" instead of optional ""&"",     // for objects functors, and required ""( )""     f = &&&A->add();          int c = (***f)(x, y);     ...          // or also,     // infix alternative usage of ""->"",     // instead of prefixed *, for functors     int c = f->(x, y);     ...",-0.08522727272727273,c
12qn3na,jpjk9wb,">In Pascal, ( yes the later versions of Pascal have pointers ),  Pascal, being a language derived from Wirth's earlier work with the language Algol W, always had pointers.",0.0,pascal
12qn3na,jpjk9wb,">In Pascal, ( yes the later versions of Pascal have pointers ),  Pascal, being a language derived from Wirth's earlier work with the language Algol W, always had pointers.",0.0,algol
12qn3na,jpjk9wb,"Wirth and Hoare submitted a proposal for an Algol X the concept name for the successor to Algol 60, but their proposal was rejected in favor of van Wijngaarden's, which eventually became Algol 68.",0.0,algol
12qn3na,jpjk9wb,Wirth then implemented their own proposal as Algol W.,0.6,algol
12qn3na,jgwq6pd,"As C supports these in identifiers, it can be used in many creative ways, like for example a *very* pretty version of Bournegol.",0.44166666666666665,c
12qn3na,jgyypls,"Mine does not, but XCompose covers most of my use cases, and I set up my own [Compose, `g`, `l`] for `λ`, etc..  > Implied multiplication  The language I'm working on is in the Haskell family where whitespace is the application operator.",0.55,haskell
12qn3na,jgwkme1,To allow such expressions is to go against established standards and precedents.,0.0,go
12qn3na,jgzo5gs,":-)  I have also considered allowing runon letters like `abc`, while also having multi-letter identifiers, so that unambiguous constructs get parsed as if the identifiers were separated by spaces `a b c`, but ambiguous constructs fail to compile.",0.0,c
12qn3na,jgwup3t,"> we're talking about mine, where multiplication is far more common than logic symbols  And in the code I write, it is far more common to port code from formal logic as-is than to roll my own, and to rely on specifications and papers which are not written by North American English-speaking C programmers.",0.15000000000000002,c
12qk13g,jgqcxz5,So the day might not be far where we can assume continuations or fibers on all platforms where Scala is running.,0.1,scala
12qk13g,jgqlb33,"What seems to ""go wrong"" (in some sense) is when those things get adapted in the real world and people who learn them don't learn them deeply enough to understand the nuances that distinguish one thing from the other.",-0.10625,go
12qk13g,jgsf734,I left scala behind because it is absolutely terrible for this stuff.,-0.4666666666666666,scala
12qew3q,,What I'm trying to achieve with smooth is to create a build language (and build tool)  * that is simple to understand for novice users - semantic of most syntax features can be guessed as they are similar/same as in popular languages (java / python / C).,0.375,java
12qew3q,,What I'm trying to achieve with smooth is to create a build language (and build tool)  * that is simple to understand for novice users - semantic of most syntax features can be guessed as they are similar/same as in popular languages (java / python / C).,0.375,python
12qew3q,,What I'm trying to achieve with smooth is to create a build language (and build tool)  * that is simple to understand for novice users - semantic of most syntax features can be guessed as they are similar/same as in popular languages (java / python / C).,0.375,c
12q2c1e,,"I'm in the middle of reading this excellent article:  [https://openjdk.org/projects/amber/design-notes/towards-better-serialization](https://openjdk.org/projects/amber/design-notes/towards-better-serialization)  and see that object serialization is near-impossible to get right in Java without integrity, vulnerability and other imperfections.",0.08214285714285714,java
12q2c1e,,"EDIT: As I get closer to the end of the article, I'm beginning to think Javascript is much more suited to serialization than java!",0.625,javascript
12q2c1e,,"EDIT: As I get closer to the end of the article, I'm beginning to think Javascript is much more suited to serialization than java!",0.625,java
12q2c1e,jgoratm,"class IDeserializer<T> {         T deserialize(Proto src);     }      class XDeserializer : IDeserializer<X> {         public X deserialize(Proto src) { ... }     }      class YDeserializer : IDeserializer<Y> {         public Y deserialize(Proto src) { ... }     }      Proto src = receive();     IDeserializer<X> xfact = new XDeserializer();     X x = xfact.deserialize(src);  A potential alternative is [static virtual methods](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members) in C#, which enable you to stick the factory method in the original interface.",0.16856060606060605,c
12q2c1e,jgp027b,"not sure if this is “best” but rust’s [serde](https://serde.rs/) does a great job separating the serialization format (json, xml, …) from the serialization code specific to the data type.",0.3875,rust
12q2c1e,jgpetcu,Lisp by far in my opinion.,0.1,lisp
12q2c1e,jgpfcai,I'd nominate elm.,0.0,elm
12q2c1e,jgqavas,Haskell does it pretty well using typeclasses (maybe Rust as well because of traits).,0.25,haskell
12q2c1e,jgqavas,Haskell does it pretty well using typeclasses (maybe Rust as well because of traits).,0.25,rust
12q2c1e,jgqm633,Haskell does it well.,0.0,haskell
12q2c1e,jgop2jy,"Javascript and Perl do this best, in my experience.",1.0,javascript
12q2c1e,jgop2jy,"Javascript and Perl do this best, in my experience.",1.0,perl
12q2c1e,jgop2jy,"Python does okay, but it really wants to throw an exception every time it runs into an object without an explicit serialization method.",0.35,python
12q2c1e,jgop2jy,"Everywhere I've worked where we used Python, we ended up making our own ""universal JSON"" best-effort serializer, which tries to serialize unknown types, with mixed success.",0.11666666666666665,python
12q2c1e,jgop2jy,"As much as it pains me to admit, Javascript does it best.",0.6,javascript
12q2c1e,jgom7rn,"And padding or packing data fields, plain C style.",-0.21428571428571427,c
12q2c1e,jgrovra,"---  You could say languages like `lisp` are very good at the first concern, but not at the second.",0.38666666666666666,lisp
12q2c1e,jgrovra,The only one from the +12 languages I have used that has been good for BOTH scenarios is Rust.,0.35,rust
12q2c1e,jgrovra,"- If you do things on your own, is likely that the whole thing is easier to do than most languages  I have used kotlin, swift as the most ""modern"" of the recent ones, and they fail so hard on this.",0.13425925925925924,kotlin
12q2c1e,jgrovra,"- If you do things on your own, is likely that the whole thing is easier to do than most languages  I have used kotlin, swift as the most ""modern"" of the recent ones, and they fail so hard on this.",0.13425925925925924,swift
12q2c1e,jgrovra,How good `serialization/deserialization` is on Rust is one of the major reasons people like the language!,0.3890625,rust
12q2c1e,jgrovra,"---  Rust is far from perfect, but I hope this show how much you need to think about this to make things better.",0.45,rust
12q2c1e,jgpuzt0,"Clojure + EDN is the best i've seen, since you're coding with plain data that can be easily consumed by your functions or sent across the wire.",0.4063492063492064,clojure
12q2c1e,jgpstpj,"In Java I'm now used to serialize a lambda Supplier<T> instead of a T, where the lambda can call capture the suppliers for the fields and call the constructor on the deserialized (.get()) field values, but the article seams to be pretty much 100% against this approach.",0.225,java
12q2c1e,jgqit0k,"If you need to support multiple formats with Rust and serde, you'll likely need an intermediate representation for each one.",0.0,rust
12q2c1e,jgpwesi,Yeah and I've used a macro lib in rust to generate elm structs and serialization code from rust structs.,0.0,rust
12q2c1e,jgpwesi,Yeah and I've used a macro lib in rust to generate elm structs and serialization code from rust structs.,0.0,elm
12q2c1e,jgrhfdu,You can't do that with arbitrary data in Lisp.,-0.1,lisp
12q2c1e,jgq2i9d,"We should all give Lisp the love it deserves, the trouble is we, including myself in that statement never give it enough effort to understand how to use it, but where I have seen people proficient in it I have always been amazed with how productive they have been.",0.09999999999999999,lisp
12q2c1e,jgp756c,"I'm not an expert, so feel free to correct me, but I believe that JavaScript's excellent serialization capabilities are due to the fact that the creator of JavaScript, Brendan Eich [wanted to make Scheme](https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/) but for NetScape, so JavaScript has a lot of the power of a LISP.",0.425,javascript
12q2c1e,jgp756c,"I'm not an expert, so feel free to correct me, but I believe that JavaScript's excellent serialization capabilities are due to the fact that the creator of JavaScript, Brendan Eich [wanted to make Scheme](https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/) but for NetScape, so JavaScript has a lot of the power of a LISP.",0.425,scheme
12q2c1e,jgp756c,"I'm not an expert, so feel free to correct me, but I believe that JavaScript's excellent serialization capabilities are due to the fact that the creator of JavaScript, Brendan Eich [wanted to make Scheme](https://thenewstack.io/brendan-eich-on-creating-javascript-in-10-days-and-what-hed-do-differently-today/) but for NetScape, so JavaScript has a lot of the power of a LISP.",0.425,lisp
12q2c1e,jgp756c,"However, I would say that JavaScript does not have as complete serialization as a full LISP, in that any functions implemented natively will be reduced to `function () { [native code] }`.",0.22499999999999998,javascript
12q2c1e,jgp756c,"However, I would say that JavaScript does not have as complete serialization as a full LISP, in that any functions implemented natively will be reduced to `function () { [native code] }`.",0.22499999999999998,lisp
12q2c1e,jgqh0r3,"When you say serialization for JavaScript, are you only referring to the JSON serialization format or are you considering others too?",0.0,javascript
12q2c1e,jgqh0r3,I'd also say that JavaScript has some very unexpected serialization behavior.,0.13,javascript
12q2c1e,jgqlwx1,This approach is done for example in C#.,0.0,c
12q2c1e,jgqhwxs,"In Rust, you can implement a trait for a type if you own at least one of them.",0.15,rust
12q2c1e,jgsugpq,Those 32 types are selected because they represent a way to represent any type in rust in a structural manner.,0.0,rust
12q2c1e,jgsugpq,In essence rust the language would have to change before adding new variants.,0.13636363636363635,rust
12q2c1e,jgrj88l,There should be a db with a tweeter like interface that you just scroll abd it shows lisp macros :)),0.5,lisp
12q2c1e,jgqh5c3,"I am not familiar enough with the bitcoin protocol, but I wrote an [SWF parser](https://github.com/open-flash/swf-parser) in TS and Rust and the issue seems similar to the bitcoin protocol: there's some header at the start and it controls how to deserialize the rest of the entry.",-0.0625,rust
12q2c1e,jgsxynk,"I got confused by their usage of the term ""special status"", because it's not Rust types that are granted special status, it's a different data model entirely (some types happen to be the same between the serde types and the Rust core types).",0.05238095238095238,rust
12q2c1e,jgrjxpb,"Alternatively, you could allow very limited form of evaluation like JavaScript in the browser.",-0.09285714285714286,javascript
12q0q41,,"Some of you might recognize this as a kind of [substructural typing](https://en.wikipedia.org/wiki/Substructural_type_system), and if you look really closely, this is similar to borrowing like we see in [Austral](https://austral-lang.org/linear-types) and Rust.",0.26666666666666666,rust
12q0q41,,"This is slightly different than languages like Rust, which I would classify as ""opt-out"", where it defaults to borrowing (which is similar to linear style), and has users explicitly opt into more expensive approaches via e.g.",0.0,rust
12q0q41,,"It could be promising for Vale, as it means the user has a tool in their toolbox for eliminating memory safety overhead where they want, a familiar benefit of languages like Rust.",0.2875,rust
12q0q41,,"However, linear style also feels like it might also have some of Rust's drawbacks in practice.",0.0,rust
12q0q41,jgoitx9,"Funnily enough, Haskell allows you to [defer type errors to runtime](https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/defer-type-errors.html)!",0.0,haskell
12q0q41,jgs1rt6,"It also seems to apply to borrowing, like Rust's &mut, which makes sense as borrowing is mostly just sugar on top of linear style.",0.5,rust
12q0q41,jgs2lcz,"I think Swift comes closest with its value types, but we can't really take references to them.",0.2,swift
12q0q41,jgtk3gg,"> It also seems to apply to borrowing, like Rust’s &mut   Yep, &mut pushes constraints upward in your program in the same way as linearity.",0.0,rust
12q0q41,jgtk3gg,I’d be interesting in learning more about the language!~~ Nevermind!,0.640625,d
12pz95g,jgoiv0y,"I don't know of any resources off the top of my head (hopefully others have some good ones), but most of my LLVM knowledge comes from three places:   * Using the '-S -emit-llvm' flags when compiling a C program, and looking at the generated .ll LLVM file and comparing it to the original C.  * Looking at others' compilers source code, like Cone and Zig.",0.51875,c
12pz95g,jgpm5dt,Target C or some other language that targets LLVM instead (if you can afford to do so).,-0.125,c
12pz95g,jgpm5dt,"Targeting C is a well-known practice, and plenty of compilers do it.",0.0,c
12pz95g,jgplx23,I’d just suggest finding tutorials elsewhere online,0.0,d
12pz95g,jgr8fmr,"Targeting C is well-known and a valid technique, but this post is simply not about that.",0.0,c
12pz95g,jgqmla2,"And yeah, Nim is an example that primarily compiles to C and plenty of other languages have that as well, even if it's not their ""main"" compiler (using ""main"" in a very loose sense).",0.10166666666666666,c
12pv9c2,jgnopnx,"This works best in languages like Haskell or OCaml, where you also delc1re functions with it so “let foo (of) x = (be) x + 10 in” makes sense (actual code doesn’t include the stuff in parentheses)",0.08333333333333333,haskell
12pv9c2,jgnvp0g,I think we can all agree that C’s choice of `auto` makes the least sense compared to `let` or `var`,-0.3,c
12pv9c2,jgnyjme,"So we want to *encourage better practices* and that requires changing terminology so people think ""ok, why Rust doesn't have `var` and now learn why this changed.",0.5,rust
12pv9c2,jgntf6i,"let means immutable data by default (Rust, OCaml, Nim), It is more “mathematical” in a sense.",0.25,rust
12pv9c2,jgrim7y,"JavaScript uses let instead of var, because var already existed and had inconsistent behaviors.",0.0,javascript
12pv9c2,jgusvw3,"In LISP for example you have a `let`, which is if i recall a macro for smart lambdas, to have a name binding between some sexp value and a name so that you don't have to pass two or more times the same value in multiple locations.",0.17857142857142858,lisp
12pv9c2,jgusvw3,This is not true in some languages like Rust where `let` is `var` under disguise.,-0.175,rust
12pv9c2,jgr54a9,"In Haskell you don't usually use let, just `foo x = x + 10` is enough.",-0.125,haskell
12pv9c2,jgo9kfy,C++ just reused an existing obsolete keyword that kind of fit instead of adding a brand new one.,0.37878787878787873,c++
12pv9c2,jgnw6wt,I think you mean C++  The idea of automatic assignment isn't just a C++ thing either.,-0.3125,c++
12pv9c2,jgnw6wt,Go has `a := funcThatReturnsComplicatedType()` and it's extremely useful.,0.3,go
12pv9c2,jgnwirm,auto is not a replacement of let or var (which doesn’t exist in C to begin with) but a keyword saying: the compiler can and should derive the type of the variable.,0.0,c
12pv9c2,jgnwirm,This is the same syntax as any variable declaration in C which is the ˋtype nameˋ pattern.,0.0,c
12pv9c2,jgv6h7v,C's choice does make sense.,0.0,c
12pv9c2,jgv6h7v,What doesn't is C++'s.,0.0,c++
12pv9c2,jgnv76u,"In JavaScript, let is also mutable, but the difference is mainly in scoping   > let allows you to declare variables that are limited to the scope of a block statement, or expression on which it is used, unlike the var keyword, which declares a variable globally, or locally to an entire function regardless of block scope.",0.031746031746031744,javascript
12pv9c2,jgut0k0,"I forgot to tell that there are languages where `let` and `var` coexist, like Javascript.",0.0,javascript
12pv9c2,jgo5o6w,Scala does this and it's fantastic.,0.4,scala
12pv9c2,jgpsy0h,`auto` in C++ is pretty much the same thing as `var` in C# and Java.,0.15,c++
12pv9c2,jgpsy0h,`auto` in C++ is pretty much the same thing as `var` in C# and Java.,0.15,c
12pv9c2,jgpsy0h,`auto` in C++ is pretty much the same thing as `var` in C# and Java.,0.15,java
12pv9c2,jgo2jn9,"(""{}"", std::any::type_name::<T>())     }     fn main() {         let my_obj = (""1"", 2, [""a"",""b"",""c""]);         print_type(&my_obj);     }     $ cargo run     Finished dev [unoptimized + debuginfo] target(s) in 0.11s Running target/debug/testrust      (&str, i32, [&str; 3])",-0.2916666666666667,c
12pv9c2,jgv6fan,"In C the type declarator replaced the function of ""auto"" in virtual every case.",0.0,c
12pv9c2,jgpg70z,But C doesn’t have var or let syntax!,0.0,c
12pv9c2,jgpg70z,What you are talking about is type inference which many languages do have but C did not until auto was introduced in C23,0.5,c
12pv9c2,jgpgdkr,Furthermore auto only exists in C23 which very few C Programmers use.,-0.13,c
12pv9c2,jgpggis,The link is a C++ header file…,0.0,c++
12pv9c2,jgq1xw2,I don’t think so - that matches the use of let in scheme and lisps,0.0,scheme
12pv9c2,jgpiabn,"It seems like you’re saying type inference could fail, but in a language like Haskell I _can_ explicitly define types and don’t have to rely on inference.",-0.5,haskell
12pqhnt,jgqncyf,"I'm making a big deal of this because the title suggests that OCaml is _literally_ adopting Rust's borrow-checking system as-is, with no changes, and that is absolutely not what's happening.",-0.05,rust
12pqhnt,jgqno27,"with e.g., which I think I did here 🎃)  I don’t disagree that it’s “not just Rust tacked-on”, but I suspect that it being Rust-like-in-ways-that-are-interesting-to-general-audiences is exactly the useful takeaway for said general audiences.",0.20000000000000004,rust
12pqhnt,jgqsb9z,"Rust's borrow checker isn't ""for the sake of example"", which is what that roughly translates to.",-0.1,rust
12pqhnt,jgqsb9z,The modal type system being proposed is quite different from Rust's borrow-checker.,0.0,rust
12pqhnt,jgqsb9z,"It does incorporate the borrow-checking and linearity stuff that Rust has, but a little different, and combined with other facets.",-0.10416666666666667,rust
12pqhnt,jgqsb9z,The fact that they don't explicitly say anything about Rust is itself an indication that this is very different.,0.0,rust
12pqhnt,jgqsb9z,"They are likely doing it specifically to avoid confusion and conflation, though I personally would have liked at least a bit of the proposal to explicitly draw some parallels and contrasts for the benefit of people already familiar with Rust, who will very obviously note the connections but may not be equipped to suss out the differences.",0.1125,rust
12pqhnt,jgqsb9z,"And then I came over here and you had (inadvertently) claimed that this proposal was copy/pasting Rust's borrow-checker into OCaml and I had _feelings_, which I let get the best of me.",1.0,rust
12pqgvu,jgo8n0s,"The NEXT GREAT THING: Cobol++: an extension of the Cobol programming language written with natural language processing tools built in, so you can write code in actual natural English and it'll compile correctly.",0.16666666666666666,cobol
12pqgvu,jgnyqpv,I’ve been meaning to learn more about COBOL,0.5,cobol
12pqgvu,jgrulfq,COBOL farms remembers,0.0,cobol
12po6rc,,"I've been trying to come up with my own general purpose language for a while now, mostly just to play around with but would be cool if it could be more later, but I keep going back to the drawing board...",0.2857142857142857,cool
12po6rc,,Figured it's finally time to stop lurking and just ask folks who've got experience to hopefully help pull my head out of my rear and decide whether or not any of this is even a good idea so far and where to go with things if so.,0.26666666666666666,go
12po6rc,jgn7r92,(C++ uses `< >` because it's all done with templates where types are parameters.,0.0,c++
12po6rc,jgn7r92,(I wish C had been like that.),0.0,c
12po6rc,jgmsl19,"First, one thing you should ask yourself is “what does my language do that makes it special?”   C was higher level (for the time), not horribly slow and worked on multiple systems (with effort)  Java had “write one, run anywhere”.",0.20142857142857143,c
12po6rc,jgmsl19,"First, one thing you should ask yourself is “what does my language do that makes it special?”   C was higher level (for the time), not horribly slow and worked on multiple systems (with effort)  Java had “write one, run anywhere”.",0.20142857142857143,java
12po6rc,jgmsl19,Rust has the borrow checker.,0.0,rust
12po6rc,jgmsl19,Python is easy to write.,0.43333333333333335,python
12po6rc,jgmsl19,Go has easy concurrency and decent performance.,0.3,go
12po6rc,jgpvztm,You might consider using `..<` as in Swift or Nim.,0.0,swift
12po6rc,jgne8ng,"I actually kind of stole the `val`/`var` idea from Kotlin :P  The brackets in a lot of cases are intended to be optional since types can be inferred in a lot of cases, so you could just have `fn add(val<i32> x, val<i32> y)` and for the structure `val<Person> bob = ${...}` or `val bob = $<Person>{...}`.",0.675,kotlin
12po6rc,jgne8ng,(I wish C had been like that.),0.0,c
12po6rc,jgmwkun,"As far as interfaces go... yeah been struggling to think of a good way to incorporate them, this is one of the main parts where I've really been wracking my brain.",0.29166666666666663,go
12po6rc,jgmwkun,I've thought about trying to do something similar to Rust's traits but feels like that could potentially be headache inducing given how the structure syntax works...,0.0,rust
12po6rc,jgqcaq3,Istr Ruby uses .. for conventional half-open range and ... for inclusive range.,-0.14285714285714285,ruby
12po6rc,jgqnktf,It has nothing ressembling C's character literals.,0.0,c
12po6rc,jgqnktf,"In fact that is why Unicode-aware languages tend to drop the idea of a ""character"" altogether (or to go the [D route](https://dlang.org/spec/type.html#basic-data-types)): not only does Unicode not use that idea, but ""anything encoded in UTF-8,"" even if it is only one symbol, is a variably-sized array of code units, also known as ""a string.""",0.0,go
12po6rc,jgqnktf,"In fact that is why Unicode-aware languages tend to drop the idea of a ""character"" altogether (or to go the [D route](https://dlang.org/spec/type.html#basic-data-types)): not only does Unicode not use that idea, but ""anything encoded in UTF-8,"" even if it is only one symbol, is a variably-sized array of code units, also known as ""a string.""",0.0,d
12pk48d,jgmemn1,"From there you just need to convert IR into actual code that can be run, either by translating to assembly, machine code, etc.",0.0,assembly
12pk48d,jgmemn1,"There is someone who made a compiler from scratch on YT/Twitch, and they go through creating their own IR and applying optimisations to it at some point (I think it's called Intercept)",0.6,go
12pk48d,jgmoei0,"I forgot how much stuff I read about compilers that quickly discard because I know I CAN'T replicate all that alone, but lately, I see the code of  https://c9x.me/compile/  and was impressed by a)how clean it looks despite being C!",0.3383333333333334,c
12pk48d,jgmoei0,"and b) it is TRULY small (and if not using C, using chatgpt to port this code look very feasible!)",0.0,c
12pk48d,jgnz0bj,"Take a look a [MLTon](http://mlton.org/WholeProgramOptimization) or [Clang Fortran](https://github.com/flang-compiler/flang)   The real optimization work is in compiling for AI accelerators, scheduling sparse matrix multiplications.",0.2,fortran
12pk48d,jgpugk1,Also the classical [Secrets of the Glasgow Haskell Compiler inliner](https://www.cs.tufts.edu/comp/150FP/archive/simon-peyton-jones/secrets-of-the-glasgow-haskell-compiler-inliner.pdf).,0.0,haskell
12pk48d,jgmo0jb,"and it's related compiler framework in Go, and never used C++ or Plain C, and the book is in C or C++, you may have a problem with it.",-0.10714285714285714,go
12pk48d,jgmo0jb,"and it's related compiler framework in Go, and never used C++ or Plain C, and the book is in C or C++, you may have a problem with it.",-0.10714285714285714,c++
12pk48d,jgmo0jb,"and it's related compiler framework in Go, and never used C++ or Plain C, and the book is in C or C++, you may have a problem with it.",-0.10714285714285714,c
12pk48d,jgmo0jb,"BTW I'm practicing in both C and C++, although not my daily work P.L.",0.0,c
12pk48d,jgmo0jb,"BTW I'm practicing in both C and C++, although not my daily work P.L.",0.0,c++
12pk48d,jgmo0jb,"This is done a lot with destination Plain C or C++, but works well with another P.L.",-0.21428571428571427,c
12pk48d,jgmo0jb,"This is done a lot with destination Plain C or C++, but works well with another P.L.",-0.21428571428571427,c++
12pk48d,jh7prp5,It’s literally a walk through the first C compiler.,0.25,c
12pk48d,jgn2xa6,He has a whole [playlist](https://www.youtube.com/playlist?list=PLysa8wRFCssxGKj_RxBWr3rwmjEYlJIpa) you can go through.,0.2,go
12p0od6,,Since my language is concept-based (like rust traits) all the types that can be copied must implement built-in `Copy` concept.,0.0,rust
12p0od6,,"If this functionality is implemented for every type, that means that there is always a possibility to move a value from one location to another (which sounds logically correct), but there are several problems here too: what is the default version of move operator going to look like, is accepting C++ interpretation of valid but unspecified state ok, what if someone wants their type not to be movable.",0.2375,c++
12p0od6,jgltmba,"There's no `Copy` trait as in Rust, instead a handful of types are marked as value types by the compiler, and these are copied when moved.",0.1,rust
12p0od6,jgv8biu,"Rust assume all types to be movable, but you could easily make this restriction, it will make RAII way less nice however: Because Rust allows all types to be moved trivially, all new values can only be created in aggregate expressions and bond to temporaries and variables can only be initialized by moving an existing value into them.",0.16717171717171717,rust
12p0od6,jglw6dd,"The language is similar to rust in terms of code organization, however I plan on using a GC similar to one in golang",0.0,rust
12p0od6,jgm2b4g,"As for `Copy`, you can either use a marker trait (like `Copy` in Rust) and give your compiler knowledge of this trait, or introduce a special keyword that turns types into copy/value types.",0.35714285714285715,rust
12p0od6,jgm5qmz,Optionally you can cache these results in the current block so future lookups don't have to go through the same effort to find the state.,0.0,go
12omegv,jgki8sy,Cool!,0.4375,cool
12omegv,jgljyx5,"Know what would be also very cool: If there were an instruction to write a symbol on the map - 3 parameters: (y, x, ascii-value).",-0.14750000000000002,cool
12omegv,jgm5a9e,This is so cool!,0.4375,cool
12oke5n,jgix3j2,I don't think I've seen a lang implemented in Fortran before.,0.0,fortran
12oke5n,jgj17s2,"I’ve been using Fortran professionally for about 10 years, so I know it better than any other language.",0.15833333333333333,fortran
12oke5n,jgj17s2,Also this is a good opportunity for me to do things that Fortran isn’t usually used for.,0.22499999999999998,fortran
12oke5n,jgj17s2,"In hindsight C++ might have been a more convenient host language, maybe I’ll do that for the next project :)",0.3333333333333333,c++
12o5rb8,jgh6ael,I’m commenting here because I’d like to know too!,0.0,d
12o49eo,,I've been researching bytecode interpreter optimizations (without JITing) and to test them out made a few simple C implementations: [https://gist.github.com/kartiknair/bef81356d5a4b9eb9ccbbafde4fa87d9](https://gist.github.com/kartiknair/bef81356d5a4b9eb9ccbbafde4fa87d9).,-0.31666666666666665,c
12o49eo,jgh7y52,"👍  Both C and C++ have the bad reputation of been overused at a way that look like a ""cryptography code"".",-0.6999999999999998,c
12o49eo,jgh7y52,"👍  Both C and C++ have the bad reputation of been overused at a way that look like a ""cryptography code"".",-0.6999999999999998,c++
12o49eo,jghjgwn,"Hi Kartiknair,  I had a go with your computed goto version.",0.0,go
12o49eo,jghjgwn,"Not a lot to work on, your jump instruction had a branch in it, so i've given a branchless version a try - https://godbolt.org/z/h1KejE1js   ```c exec_op_jmp_if: {   src_reg = *(++ip);   i64 t_reg = *(++ip);   u64 branchless_mask = ((u64)((regs[src_reg] == 0)) - 1);     ip += t_reg & branchless_mask;    goto* jump_table[*(++ip)]; } ``` This has an additional memory read on the false branch, but it might payoff by removing the branch code.",-0.6333333333333334,c
12o49eo,jgi8dh7,"So perhaps there is room for improvement, but whether that is possible with pure C, I'm not sure.",-0.01190476190476191,c
12o49eo,jgi8dh7,"So it might be that you might need to try assembly (which will be non-portable), but I also suggest you keep trying HLL avenues first, although your computed-goto dispatch loop is already one of the best when using HLL.",0.625,assembly
12o49eo,jgih6j5,So thought I'd go as minimal as possible to try and figure it out.,-0.05,go
12o49eo,jgijd0e,Cool optimization regardless!,0.4375,cool
12o49eo,jgiiqin,"\> So perhaps there is room for improvement, but whether that is possible with pure C, I'm not sure.",-0.01190476190476191,c
12o49eo,jgisnku,"(\*\*Update\*\*: my test using C took 3.9 seconds for the 100M loop, with `gcc-O0`.",0.0,c
12o49eo,jgisnku,"I think I will try a different way...)  Running that loop in native code takes `0.28` seconds in C, optimised or not.",0.0,c
12o49eo,jgisnku,I'd say that 3 times as slow as optimised C is pretty good.,0.21666666666666665,c
12o49eo,jgisnku,I guess GNU C is bit more portable than assembly.,0.5,c
12o49eo,jgisnku,I guess GNU C is bit more portable than assembly.,0.5,assembly
12o49eo,jgl1skp,"\> You don't often see -O3 making things 35%  This is quite interesting, would be curious to see the code/generated assembly to see what's causing that.",0.2,assembly
12o49eo,jgliqk5,"Which was poor, until I applied the modest optimiser of an older compiler version, then it ran it in just under 1.6 seconds, a little better than gcc's 1.65 seconds on the C version.",0.035833333333333314,c
12o49eo,jgliqk5,"ETA:  >This is quite interesting, would be curious to see the code/generated assembly to see what's causing that  This is the [C code](https://github.com/sal55/langs/blob/master/pcl100.c).",0.2,assembly
12o49eo,jgliqk5,"ETA:  >This is quite interesting, would be curious to see the code/generated assembly to see what's causing that  This is the [C code](https://github.com/sal55/langs/blob/master/pcl100.c).",0.2,c
12o49eo,jgliqk5,Tiny C ran it a little slower than `gcc-O0`; 'bcc' (my own compiler) ran it a little faster.,0.056249999999999994,c
12nqbra,,"After doing some research, I found that Lua's VM, for example, doesn't support hardware registers, but makes an array of virtual registers on the stack.",0.0,lua
12nqbra,jgfwsu2,"Also, unless you write your interpreter in assembly, you won't have any guarantees about what's stored in registers or not.",0.0,assembly
12nqbra,jggtno1,It can also happen if you are using lots of inline assembly (not specific to the target program) within your HLL interpreter to speed things up.,0.0,assembly
12nqbra,jghjjc3,"It's not that registers are different, it's that the assembly code you're gonna write will only work on some platforms and have no equivalent on others.",0.0,assembly
12nqbra,jghjjc3,Have you ever read C(++) system headers with thousands of `#ifdef` in them?,0.0,c
12nqbra,jgfo7uy,"Yes, but that's why Java got .jit to replace their instructions with physical optimized equivalents ...  >> 2.1 E.G.",0.0,java
12nqbra,jgfo7uy,"**  Most of the existing compiler tool frameworks like GCC or LLVM use a platform independent intermediate representation code, similar to a V M. interpreter that is transformed into specific hardware platforms, just like Java V.M.",0.125,java
12nqbra,jgfo7uy,Java V.M.,0.0,java
12nqbra,jgg9a8t,"I'm pretty sure that with ARM assembly, in order to do an operation on 2 values, they both must be loaded into registers.",0.375,assembly
12nqbra,jgg9a8t,"I suspect that if I'm going to make a compiler, I'll have to answer that question and many more like it, and that's why I'm not sure if I should go for it or not.",0.25,go
12nqbra,jgg9a8t,"If I do go for an interpreter, I suspect I may try implementing the tip you gave at the end of your complement (because I am hoping for good performance, at least by interpreter standards).",0.19999999999999998,go
12nqbra,jggj5ig,"> I suspect that if I'm going to make a compiler, I'll have to answer that question and many more like it, and that's why I'm not sure if I should go for it or not ...",0.25,go
12nqbra,jggmr3s,"For example, a language intended for data-crunching will benefit a lot from compilation (see Julia), though it might be sufficient to just delegate to native routines (see Python/Numpy).",0.0,julia
12njii1,,"Anyone might implement Forth once, but why *twice*?",0.0,forth
12njii1,,"Well, the first real dogfooding I did was implementing a large subset of [Nick Morgan's Easy Forth](https://skilldrick.github.io/easyforth/) in Charm.",0.27440476190476193,forth
12njii1,,Here's [the code for the Forth](https://github.com/tim-hardcastle/Charm/blob/main/examples/forth.ch).,0.0,forth
12njii1,,Also special commands `quit` to stop Forth and `reset` to return it to its clean state.,0.36190476190476195,forth
12njii1,,Forth > 2 2 + .,0.0,forth
12njii1,,4 Forth > : sqr  dup * ;  OK.,0.5,forth
12njii1,,Forth > 2 sqr  OK.,0.5,forth
12njii1,,Forth > .,0.0,forth
12njii1,,4 Forth > 10 0 do i sqr .,0.0,forth
12njii1,,loop  0 1 4 9 16 25 36 49 64 81 Forth > variable A 10 cells allot  OK.,0.5,forth
12njii1,,Forth > 10 0 do i dup sqr swap A + !,0.0,forth
12njii1,,Forth > 10 0 do i A + ?,0.0,forth
12njii1,,loop  0 1 4 9 16 25 36 49 64 81 Forth >                 ```,0.0,forth
12njii1,jgge53y,"Pre-splitting the input line into whitespace separated words is very untypical for Forth, since it makes parsing words impossible (so you need to special case string handling, and even seem to have a bug of collapsing multiple spaces into one within strings).",-0.027380952380952367,forth
12njii1,jgge53y,"I am aware that this is just an exercise in using your own language Charm, I would just like to note that it should not be considered a typical way to implement Forth.",0.22777777777777777,forth
12njii1,jgisuu7,I've just moved things which in a more complicated language/implementation would go in the lexer into the evaluator instead.,0.0,go
12njii1,jgisuu7,"But then (a) you *don't* know where to look for the assignment, except that it's somewhere further up in the function than the reference to the constant (b) this raises issues of scope and shadowing which makes it harder to read even in functions where those things don't occur --- because they might, and you don't know unless you look (c) and so it's goodnight to referential transparency (d) you have to bikeshed where in the function you want to put each definition because you don't want to do the evaluation unless its needed.",-0.03333333333333333,c
12njii1,jgisuu7,"But then (a) you *don't* know where to look for the assignment, except that it's somewhere further up in the function than the reference to the constant (b) this raises issues of scope and shadowing which makes it harder to read even in functions where those things don't occur --- because they might, and you don't know unless you look (c) and so it's goodnight to referential transparency (d) you have to bikeshed where in the function you want to put each definition because you don't want to do the evaluation unless its needed.",-0.03333333333333333,d
12my72a,jgcf8v6,"I've implemented the Python approach, where a module corresponds to a file.",0.0,python
12my72a,jgdex1q,"So anyway, in my language I mostly copied Rust, in that you have root ""project"" files which contain either inline module declarations or _`extern`_ module declarations, the latter of which causes a filesystem read, and in that you have to tell the compiler about _all_ those roots.",0.25,rust
12my72a,jgdex1q,"As far as splitting modules into files go, I do like Rust:    - `ns Whatever.Example with /*...*/ end` declares the `Whatever.Example` module and the compiler immediately registers it.",0.1,go
12my72a,jgdex1q,"As far as splitting modules into files go, I do like Rust:    - `ns Whatever.Example with /*...*/ end` declares the `Whatever.Example` module and the compiler immediately registers it.",0.1,rust
12my72a,jgdex1q,"Now how do I use those, I mostly copied from D as I consider it the most ergonomic.",0.5,d
12my72a,jgdzpt6,"choosing what symbol to import) is done in the python way `from module import symbol1, symbol2`, however, you can't `from module import all` because at the time i thought that would be unecessary, i think i will eventually implement this in the future.",0.0,python
12my72a,jgdzpt6,"Overall i think this simple scheme is quite sufficient for my needs, but i do prefer to clump things together by their context, for example, my typechecker is a single 3kloc file, this may not work for other programming tastes.",-0.049107142857142856,scheme
12my72a,jgf1ndy,C++ / PHP namespaces work but aren't the best way.,1.0,c++
12my72a,jgf1ndy,C++ / PHP namespaces work but aren't the best way.,1.0,php
12my72a,jgf1ndy,That's why the C++ comite just reinvented a new syntax for modules.,0.13636363636363635,c++
12my72a,jgf1ndy,"Java and C# static Classes does work as modules, but aren't either.",0.5,java
12my72a,jgf1ndy,"Java and C# static Classes does work as modules, but aren't either.",0.5,c
12my72a,jgf1ndy,"**  C++ mixes both ways, but make it's confusing.",-0.3,c++
12my72a,jgf1ndy,"The module folder kind, called ""assemblies"" in C# and ""Packages"" in Delphi/ FreePascal, can only contain other modules, not directly code.",0.10625,c
12my72a,jgf1ndy,"The module file kind, called ""package"" in Java, and ""unit"" in Delphi / FreePascal, are usually single files that contain directly code.",0.20952380952380953,java
12my72a,jgf1ndy,"The module file kind, called ""package"" in Java, and ""unit"" in Delphi / FreePascal, are usually single files that contain directly code.",0.20952380952380953,delphi
12my72a,jgf1ndy,"They are similar to a C++ file where only a new single non anonymous namespace is declared, and all declarations are inside of it.",0.016233766233766232,c++
12my72a,jgf1ndy,Pascal's branch of P.L.,0.0,pascal
12my72a,jgf1ndy,"(s) like Modular, Oberon and Ada, does support multiple nested modules in a single file similar to C++ nested namespaces, but I still consider the single file module per file much better.",0.07142857142857142,ada
12my72a,jgf1ndy,"(s) like Modular, Oberon and Ada, does support multiple nested modules in a single file similar to C++ nested namespaces, but I still consider the single file module per file much better.",0.07142857142857142,c++
12my72a,jgf1ndy,"There's may be other predefined module folders, bit it's better to group them inside a single one, like the predefined, compilation time, C++ ""std"" namespace or ""system"" module.",0.1011904761904762,c++
12my72a,jgf1ndy,"**Check C#, Delphi or FreePascal they have a better module system than the other P.L.",0.1875,c
12my72a,jgf1ndy,"**Check C#, Delphi or FreePascal they have a better module system than the other P.L.",0.1875,delphi
12my72a,jgf3f1m,"Generally, I’d go with File = Module and Folder = Module.",0.05000000000000002,d
12my72a,jgf3f1m,"Generally, I’d go with File = Module and Folder = Module.",0.05000000000000002,go
12my72a,jgfva36,Point is to solve some configuration management problems I experienced with the Python approach.,0.8,python
12mx8q9,,"It seems current programming landscape trends is moving toward improving modularity (package dependency), functional programming (unison-lang, amazon lambda), immutability (Haskell), reproducible build (nix) and portability (web assembly).",0.0,haskell
12mx8q9,,"It seems current programming landscape trends is moving toward improving modularity (package dependency), functional programming (unison-lang, amazon lambda), immutability (Haskell), reproducible build (nix) and portability (web assembly).",0.0,assembly
12mx8q9,,As java developer I also feel the pain of JAR hell everyday and it seems that JARs might be too coarse grained.,-0.1,java
12mx8q9,jgcxmgf,C standard library if you can interop with C,0.0,c
12mx8q9,jgl0mjf,Strings in C rust java or python don't necessarily have the same byte code implementation.,0.0,c
12mx8q9,jgl0mjf,Strings in C rust java or python don't necessarily have the same byte code implementation.,0.0,rust
12mx8q9,jgl0mjf,Strings in C rust java or python don't necessarily have the same byte code implementation.,0.0,java
12mx8q9,jgl0mjf,Strings in C rust java or python don't necessarily have the same byte code implementation.,0.0,python
12mvqv1,,"In the Lisp world one of the major differences between the Scheme/Racket languages and others such as Common Lisp is that CL is a ""Lisp2"" language, meaning that there are two namespaces for symbols: one for variables and a separate one for functions.",-0.07916666666666666,lisp
12mvqv1,jgc7uo3,The Rust languages allows for some fairly confusing stuff due to its name resolution.,-0.2125,rust
12mvqv1,jgc8b3h,"> I am not aware of any other languages like this  Java, for example.",-0.125,java
12mvqv1,jgcjyf6,Haskell also has a namespace for values and a namespace for types.,0.0,haskell
12mvqv1,jgcjyf6,Which means that when you say:  ```haskell data Point = MkPoint Int Int ```  `Point` is a type and `MkPoint` is a function (of type `Int -> Int -> Point`).,0.0,haskell
12mvqv1,jgcjyf6,But you can also say:  ```haskell data Point = Point Int Int ```  And there's a `Point` type and a `Point` function.,0.0,haskell
12mvqv1,jgcc98s,"C has a struct namespace, a variable namespace, and a label namespace.",0.0,c
12mvqv1,jgce56l,Typescript might also be an interesting thing to look into here.,0.5,typescript
12mvqv1,jgce56l,"variables that will end up in the compiled Javascript output), and type variables (i.e.",0.0,javascript
12mvqv1,jgce56l,"For example:      function VarName() {} // runtime namespace     type VarName = string; // compile time namespace      // use VarName as a type -> it represents a string     const x: VarName = ""hello"";     // use VarName as a runtime value -> it represents a function     VarName();      // it is possible to convert names in the runtime namespace     // to compile time values via `typeof`     const x2: typeof VarName = () => {};      // classes declare a name in both the runtime namespace     // and the compile time namespace     class Combined {}     const x3: Combined = new Combined();     //        ^ type         ^ runtime  The benefit of this is that it allows the Typescript type system to sit on top of the existing Javascript one, such that when you compile the result to Javascript, all you need to do is lift up the type layer, and leave behind normal Javascript code.",-0.05194805194805195,typescript
12mvqv1,jgce56l,"For example:      function VarName() {} // runtime namespace     type VarName = string; // compile time namespace      // use VarName as a type -> it represents a string     const x: VarName = ""hello"";     // use VarName as a runtime value -> it represents a function     VarName();      // it is possible to convert names in the runtime namespace     // to compile time values via `typeof`     const x2: typeof VarName = () => {};      // classes declare a name in both the runtime namespace     // and the compile time namespace     class Combined {}     const x3: Combined = new Combined();     //        ^ type         ^ runtime  The benefit of this is that it allows the Typescript type system to sit on top of the existing Javascript one, such that when you compile the result to Javascript, all you need to do is lift up the type layer, and leave behind normal Javascript code.",-0.05194805194805195,javascript
12mvqv1,jge11xq,With the exception of Scheme I can't think of any language that only has one namespace (Common Lisp has I think 6 or 7 namespaces btw.).,-0.15,scheme
12mvqv1,jge11xq,With the exception of Scheme I can't think of any language that only has one namespace (Common Lisp has I think 6 or 7 namespaces btw.).,-0.15,lisp
12mvqv1,jge11xq,All languages I know except Scheme have 3 more namespaces.,0.5,scheme
12mvqv1,jge11xq,"Funny Java expample showing `x` used as a classname, member name, parameter name, method name and variable name:      jshell> class x {        ...>       x x;        ...>       x(x x) {        ...>             this.x = x;        ...>       }        ...>       x x() {        ...>             return this.x;        ...>       }        ...> }     |  created class x          jshell> x x = new x(null)     x ==> x@28c97a5          jshell> x.x()     $3 ==> null          jshell>",0.19318181818181818,java
12mvqv1,jgcdyhu,Shell languages kinda?,0.0,shell
12mvqv1,jgcj10c,C is similar but not exactly like this.,-0.0625,c
12mvqv1,jgcj10c,"C features this phenomenon between types and variables/functions:  ``` int stat(   const char *restrict pathname,   struct stat *restrict statbuf ); ```  although admittedly, this example is less how I remembered it, I remembered it more like:  ``` typedef struct { ... } stat;  int stat (..., stat* ...); ```",0.16666666666666669,c
12mvqv1,jgcq0p8,"After all most languages allow different instances of `foo` because of block scopes, or shadowing, or, in C with its 3 main namespaces, if `foo` is a variable name, extra `foo`s in the same scope can only be struct/enum tags, or labels.",0.1111111111111111,c
12mvqv1,jgft7gu,Does perl 5 count?,0.0,perl
12mvqv1,jgc88yn,"    (defun handle-list (a b c)       (let ((list (list a b c)))          (do-something list)         (do-something2 list)))  The let form calls the function `list` with argments `a`, `b` and `c` and assigns the results to local variable `list`.",0.0,c
12mvqv1,jgcpusr,I just gave it a whirl in [rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=7cd5dccea96414144901c5f0c9b6843f) and it depends on where you put it.,0.0,rust
12mvqv1,jgdj1jq,It's the convention for the (automatic) getters of Java record components:      record Person(String name) {}     person.name == person.name()  (as long as you have access to the private fields of the record),-0.025,java
12mvqv1,jgdmrsg,Or do Lisp let bindings have a different semantic than in ML?,0.0,lisp
12mvqv1,jgh4e3x,"In the case of Common Lisp, however, it is not unimportant that `(do-something list)` could macro-expand into code that uses the `list` function.",-0.04999999999999999,lisp
12mvqv1,jgh4e3x,"Common Lisp doesn't have hygienic macros, but between separate function namespace and the package system, it almost never suffers from this fact.",0.0,lisp
12mvqv1,jgh4e3x,"(An early paper introducing hygienic  macros for Scheme introduced the ""problem"" using a few motivating examples.",-0.05,scheme
12mvqv1,jgh4e3x,*None* of them would have caused problems if Scheme hadn't unified the namespaces.),0.0,scheme
12miujn,,**  The site can only go into private beta once there are enough people committed to the site.,0.0,go
12miujn,,**  Go to the [proposal page](https://area51.stackexchange.com/proposals/127456/programming-language-design) and click commit.,0.0,go
12lz9ky,jgau3v2,>... let's say it should execute about as fast as bash.,0.2,bash
12lz9ky,jgau3v2,"I don't have experience of Bash, but I just ran a Fibonacci benchmark using Bash under Windows WSL.",0.0,bash
12lz9ky,jgau3v2,It's likely that Bash is reparsing the source each time it executes a line.,0.0,bash
12lz9ky,jgbpb5m,It only needs to be able to replace bash.,0.25,bash
12m738n,,I noticed the other day that it won't allow you to generate a function with a name that is not a valid C identifier...,-0.125,c
12m738n,,"This has given me an idea to use ""pretty"" name mangling for symbols in my languages, where say for instance a C++-like declaration such as:  ``` class MyClass {   int some_method(     char x,     int y,     float z   ); } ```  gets mangled as:  `""int MyClass.some_method(char, int, float)""`  Yes, you read me correctly: name-mangling in this scheme is just the whitespace-normalised source for the function's signature!",0.125,scheme
12m738n,,"Edit: I've just realised my test case doesn't completely prove that it's possible to generate such identifiers with the JIT (I remember seeing some code deep in its library implementation that replaces all invalid C identifier characters with underscores), but given the backend support in the GNU assembler, it should still be technically possible to achieve.",0.02,c
12m738n,jg9ryrm,I created an ugly but simple scheme I call Q quoting.,-0.35,scheme
12m738n,jg9ryrm,"Any char not in the ""simple"" C identifier set (_A-Za-z0-9) unicode code point (and the letter capital Q) is encoded as Qxx where xx is a hexadecimal number like 20 or ff.",0.0,c
12m738n,jg9v42l,"For Inko's upcoming LLVM compiler I'm doing something similar: mangled names are in the form `_IXT_NAME` where `X` is the version and `T` a type indicator (`M` for methods, `T` for types, `C` for constants).",0.0,c
12m738n,jgu74ke,"[For anyone not aware, I have a proposal for C and might propose it to C++ as well to overload operators without name mangling](https://www.reddit.com/r/cpp/comments/12rcywj/operator_overloading_without_namemangling/)",-0.125,c
12m738n,jgu74ke,"[For anyone not aware, I have a proposal for C and might propose it to C++ as well to overload operators without name mangling](https://www.reddit.com/r/cpp/comments/12rcywj/operator_overloading_without_namemangling/)",-0.125,c++
12m738n,jg9sxwy,"I don't intend to transform any characters at all with my scheme, unicodes will just be used as-is (with a specified UTF)",0.0,scheme
12m738n,jga6q0c,Not in C++.,0.0,c++
12m738n,jg9xpyq,"I've also considered (in case I wanted to restrict my language's symbols to C identifiers but use arbitrary symbols in the binary) using some form of ""dense symbol encoding"" that turns the (base53,base62...) symbols of C identifiers into a base-255-encoded string, which is more compact although not trivial to encode (base conversions is an area of special interest to me!)",0.011607142857142858,c
12m738n,jg9zhrc,"In theory, nothing to stop this from happening for C++ code, as if I'm not mistaken, name mangling is an implementation detail that's not standardised as part of the language.",0.0,c++
12m738n,jg9m4pz,"i use the llvm c bindings to generate ir, call llvm to optimize it and write it to an object or bitcode file",0.0,c
12m738n,jgaagz1,:D  _One `/bin` to call them all_   _One `/bin` to `find` them_   _One `/bin` to `wget` them all_   _And in the network stack `bind` them!_,1.0,d
12m738n,jgbzbud,"Java and MS jumped all over this in 1993 and it's a failure, IMHO.",-0.3166666666666667,java
12m738n,jgbzbud,"For example, my ""R"" turned backwards is not necessarily the Cyrillic letter called ""Я"".",0.0,r
12m738n,jgbsgnl,My (overly conservative) encoding works with C compilers predating the unicode standard.,0.0,c
12m738n,jgbsgnl,"The output is so simple that every tool we know that processes C code (or object files where these are called symbols) can handle Q encoded ""symbols"".",0.0,c
12m738n,jgbsgnl,"[[Actually, I know this to be false since some C compilers and linkers had a length limitation way back when.]]",-0.13333333333333336,c
12m738n,jgbsgnl,"Modern C compilers, and especially the GNU toolchain, explicitly allow additional characters beyond my overly conservative set (for example $) though C compilers are supposed to use the unicode notion of ""alphanumeric"" to determine if a code point is legal or not in an identifier (comma and space and parens will never be valid parts of C identifiers).",0.13333333333333333,c
12m738n,jgbsgnl,"They must be a super-set of their C compilers though, otherwise, no one would like them.",0.0,c
12m738n,jgbsgnl,"While they aren't bound to (multiple) international standard like C (and C++), if they don't handle C and C++, they'd likely fall out of use or more likely improved to handle C. Linkers *likely* treat everything as sequences of bytes that end in NUL, aka utf-8 NUL terminated strings, but I can't credibly talk about Windows or actually GNU tools since they change every few years.",0.06999999999999999,c
12m738n,jgbsgnl,"While they aren't bound to (multiple) international standard like C (and C++), if they don't handle C and C++, they'd likely fall out of use or more likely improved to handle C. Linkers *likely* treat everything as sequences of bytes that end in NUL, aka utf-8 NUL terminated strings, but I can't credibly talk about Windows or actually GNU tools since they change every few years.",0.06999999999999999,c++
12m738n,jgbsgnl,It's kind of strange that GCC and Microsoft have different ways of name mangling especially since cfront (the first C++ transpolar)  must have also done this and that would form a common basis.,0.08333333333333333,c++
12m738n,jga9fh2,"I thought I was going mad for a second there when I saw that comment, I was pretty sure they weren't in C++!",0.0625,c++
12m738n,jga9fh2,:D,1.0,d
12m738n,jga0ft6,Yes I do 👍 I just think it’d be really nice to at least have an option to have pretty-mangled names without need for a second utility… I sincerely still don’t understand why that isn’t the default behavior for the major compilers.,0.17250000000000001,d
12m738n,jgeruku,"I'm not sure if this is allowed, by the C standard, although is possible.",-0.08333333333333333,c
12m738n,jgce5bo,"Thanks for the tip, that's cool!",0.31875,cool
12m738n,jga3dnq,Being able to debug without needing to demangle is the main motivation for a scheme like the one that I'm proposing.,0.3333333333333333,scheme
12m738n,jga9l00,I think it's because linkers back when C++ was created were only designed to support C identifiers.,0.0,c++
12m738n,jga9l00,I think it's because linkers back when C++ was created were only designed to support C identifiers.,0.0,c
12m738n,jgar379,"Ah cool, they're sigilised!",0.4375,cool
12m738n,jgestv7,"> I'm not sure if this is allowed, by the C standard, although is possible.",-0.08333333333333333,c
12m738n,jgestv7,I'm not modifying the C compiler.,0.0,c
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,c++
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,ada
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,d
12m738n,jgestv7,"I'm modifying GCC's JIT compiler, libgccjit, which builds as a _""language frontend""_ for GCC (just like C++, Ada, D, etc...) and allows you to write C and C++ programs that use the GCC backend through a library interface.",0.0,c
12m738n,jgestv7,"Although libgccjit's structure is evidently C-inspired, it's not a C program builder, it's a builder for GCC's internal IR, so AFAIK C language rules generally don't apply here (it's legal to use arbitrary identifier names in the GNU assembler after all, and AFAIK what I'm doing is roughly the JIT equivalent).",0.05000000000000001,c
12m738n,jgcprco,I believe utf-8 will be their biggest contribution that will live longer than the C language itself.,0.13636363636363635,c
12m738n,jgaz25p,"I mean in C++ argument names aren't part of the type ... but I didn't realize that you were referring to your own mangling scheme, thus the miscommunication.",0.14375,c++
12m738n,jgaz25p,"I mean in C++ argument names aren't part of the type ... but I didn't realize that you were referring to your own mangling scheme, thus the miscommunication.",0.14375,scheme
12m738n,jga94wx,"This was not my intention, my mangling scheme is meant to be type-based, not argument name based, so I provided a type-based example.",0.0,scheme
12m738n,jgb2unv,"Nah, I just conflated parameter names being part of the type with them being part of ""the mangled name"" where I was thinking of that of common implementations--but the only name mangling at issue here is your own, not that of existing C++ implementations.",0.09999999999999999,c++
12lyh50,,"How would a language like Rust define the element type of my bytecode array, or access the various values?",0.0,rust
12lyh50,jg8r785,"They're useful, but I can't say they're wanted here; I myself use an array of bytes to do this (along with a large-integer encoding) in Rust.",0.3,rust
12lyh50,jgc5oqx,In Elm there is this idea of using a pattern like `type UserId = UserId String` where you have a `String` representation of a `UUID` that is tagged in order to make sure you are not accidentally using the `UUID`  of some other structure for `UserId`.,0.1875,elm
12lyh50,jgaa82c,"Under this scheme, 64-bit immediate values simple occupy two bytecode slots.",0.0,scheme
12lyh50,jgahdn4,"Not entirely familiar with Rust, but I believe it supports basic ADTs (via enum) and C-like unions as orthogonal features.",-0.09375,rust
12luon1,,"The idea then arose to allow the comma on the other side, to be able to apply the second argument instead, which would be analogous to `(flip swap) y` in Haskell.",0.125,haskell
12luon1,,"swap (,y)  Except if `y` is a tuple, this will not match the parameter tree, so we need to disambiguate:      swap (,(y,))  The nature of the parameter lists is they're syntactic sugar for linked lists of pairs, so:      (a, b, c, d) == (a, (b, (c, d)))  If we continue this sugar to the call site too, we can specify that `(,(,(,a))) == (,,,a)`  So we could use something like:      color : (r, g, b, a) -> Color      opaque_color = color (,,,1)     semi_transparent_color = color (,,,0.5)  Which would apply only the `a` argument and return a function expecting the other 3.",-0.5208333333333334,c
12luon1,,"swap (,y)  Except if `y` is a tuple, this will not match the parameter tree, so we need to disambiguate:      swap (,(y,))  The nature of the parameter lists is they're syntactic sugar for linked lists of pairs, so:      (a, b, c, d) == (a, (b, (c, d)))  If we continue this sugar to the call site too, we can specify that `(,(,(,a))) == (,,,a)`  So we could use something like:      color : (r, g, b, a) -> Color      opaque_color = color (,,,1)     semi_transparent_color = color (,,,0.5)  Which would apply only the `a` argument and return a function expecting the other 3.",-0.5208333333333334,d
12luon1,,"swap (,y)  Except if `y` is a tuple, this will not match the parameter tree, so we need to disambiguate:      swap (,(y,))  The nature of the parameter lists is they're syntactic sugar for linked lists of pairs, so:      (a, b, c, d) == (a, (b, (c, d)))  If we continue this sugar to the call site too, we can specify that `(,(,(,a))) == (,,,a)`  So we could use something like:      color : (r, g, b, a) -> Color      opaque_color = color (,,,1)     semi_transparent_color = color (,,,0.5)  Which would apply only the `a` argument and return a function expecting the other 3.",-0.5208333333333334,r
12luon1,,"$typeof opaque_color            => (r, g, b) -> Color  We can get rid of `flip` and have something more general.",0.275,r
12luon1,jg82e4e,"After a few experiments, and being in the C family more or less, we ended up with `&` as “do not dereference”, and `_` as “do not bind”.",0.044444444444444446,c
12luon1,jg8min9,"$foo ($vau (a b c) env <body>))  When you call `($foo x y z)`, the body of `$foo` has access to the dynamic environment from where this call was made, using the symbol `env` here.",0.0,c
12luon1,jg8min9,benv) (c .,0.0,c
12luon1,jgaelyp,"Currying can convert a function `(a, b) -> c` into a function `a -> b -> c`, but this does not let you apply the argument `b` without applying `a` first.",0.25,c
12luon1,jgal9h4,"If a parameter tree is (a, (b, (c, d))), and I pass only the first argument, then I just create a copy of the function object replacing the parameter tree with the tail of the original: `(b, (c, d))`, and bind `a` into its local environment.",0.15625,c
12luon1,jgal9h4,"If a parameter tree is (a, (b, (c, d))), and I pass only the first argument, then I just create a copy of the function object replacing the parameter tree with the tail of the original: `(b, (c, d))`, and bind `a` into its local environment.",0.15625,d
12luon1,jgal9h4,"If applying `d`, the resulting function would have parameter list `(a, (b, c))`, which cannot reuse any part of the original parameter tree.",0.375,d
12luon1,jgal9h4,"If applying `d`, the resulting function would have parameter list `(a, (b, c))`, which cannot reuse any part of the original parameter tree.",0.375,c
12luon1,jgamqs5,For example Swift uses named arguments.,0.0,swift
12luon1,jgaok31,"Swift had a notoriously bad implementation of ""tuple-splat"" that they had to [remove it](https://github.com/apple/swift-evolution/blob/main/proposals/0029-remove-implicit-tuple-splat.md).",-0.6999999999999998,swift
12luon1,jgaqhgn,dont confuse Swift's implementation with the idea.,0.0,swift
12lsz7o,jg7nbq7,"Creating bindings for it was too hard so I decided to just port it to Rust all at once, thankfully project is small enough.",-0.18055555555555558,rust
12lsz7o,jg7nbq7,I am using it to make JIT compiler for my R7RS Scheme.,0.0,scheme
12lsz7o,jg898p2,30k LOC is B3 IR + Assembly IR with opts and all passes.,0.0,assembly
12lsz7o,jg898p2,"Note that masm-rs rn only supports x86-64, I am soon going to add ARM64 so expect another 6k LOC :D",0.5,d
12lsz7o,jg85js2,"masm-rs is also a port of JSC \`assembler/\` directory, there are some changes in API to work better with Rust.",0.5,rust
12lsz7o,jg8b9ss,"(Btw, do you have a good overview of ""macroassemblers written in Rust""?",0.7,rust
12lsz7o,jg8bzwu,There are libraries like dynasm or iced-x86 but they emit assembly for specific architecture without providing platform-agnostic API.,0.0,assembly
12lkmyl,,"[Jactl](https://jactl.io) is intended to be used as a scripting language for real-time Java applications to allow users to provide customisations/extensions in a safe, controlled, manner.",0.5,java
12lkmyl,,It has a syntax that borrows heavily from Groovy (with a bit of Perl mixed in) and is suitable for event-loop/reactive applications because scripts are guaranteed to never block the execution thread.,0.11666666666666668,groovy
12lkmyl,,It has a syntax that borrows heavily from Groovy (with a bit of Perl mixed in) and is suitable for event-loop/reactive applications because scripts are guaranteed to never block the execution thread.,0.11666666666666668,perl
12ktce4,,"Ripple is open source, you can check out the repository here: [Ripple on Github](https://github.com/dibsonthis/Ripple)  Below is a basic Ripple program:      var length, area, diff = 0          length::onChange = () => {         area = length ^ 2     }          area::onChange = (old) => {         diff = area - old     }          for (1..10) {         length = length + 1         print(""L: "" + string(length) +                "" - A: "" + string(area) +                "" - D: "" + string(diff) + ""\n"")     }  The way it works is pretty simple.",-0.19999999999999998,d
12ktce4,,"This is a printout of the results:      L: 1.000000 - A: 1.000000 - D: 1.000000     L: 2.000000 - A: 4.000000 - D: 3.000000     L: 3.000000 - A: 9.000000 - D: 5.000000     L: 4.000000 - A: 16.000000 - D: 7.000000     L: 5.000000 - A: 25.000000 - D: 9.000000     L: 6.000000 - A: 36.000000 - D: 11.000000     L: 7.000000 - A: 49.000000 - D: 13.000000     L: 8.000000 - A: 64.000000 - D: 15.000000     L: 9.000000 - A: 81.000000 - D: 17.000000  Ripple is still very much a work in progress, but the repo can be found here: [Ripple](https://github.com/dibsonthis/Ripple)  **Important Note:** Yes, I know side effects may be seen as an anti-pattern, and I am fully aware that this may be a bad idea in many situations.",-0.006666666666666636,d
12ktce4,jg40rzk,"This language vaguely resembles rule based languages, did you take some inspiration from things like Prolog?",-0.5,prolog
12ktce4,jg4amjw,"You made me remember  ""reactive banana"" a library in Haskell for reactive functional programming.",0.0,haskell
12ktce4,jg51d4y,In TCL every variable can have observers.,0.0,tcl
12ktce4,jg83dmh,Cool stuff!,0.4375,cool
12ktce4,jg79wmt,"Very cool, well done on using it on a real project.",0.3275,cool
12ktce4,jgbljkp,"it's when you write a function that's conceptually `Foo bar(Baz)`, but you pass in the `Foo` object (or a reference to it, or whatever)      void bar(Baz input, Foo output)  with the whole idea that it's going to go and set a bunch of fields in the `Foo` object.",0.2,go
12ktce4,jgbljkp,"But, people use this return parameter idiom in Java.",0.0,java
12ktce4,jgdro71,"AH, i've seen this a lot when working with C# in industry, i didn't know that name.",0.0,c
12ktce4,jgdro71,"In C# it's like `int F()` becomes `void F(out int)`, so i think they have a different name.",0.0,c
12ke7n4,,"Along the way, I'll surely collect information about all the functions, and all of the match-case blocks, and so forth.",0.5,forth
12ke7n4,,That Python trick of using and object's (original) memory address as its key in a dictionary?,0.1875,python
12ke7n4,jg2x7tc,"That's why in ""C++"" there's a ""typeinfo"" type, but this type is not restricted to other base type, some compiler / interpreters use a pointer, some uses a ""struct"", others a pointer to another type.",-0.4625,c++
12ke7n4,jg2x7tc,"(s) are known to be good tools to implement an interpreter/ compiler, I personally learned Lisp.",0.35,lisp
12jgfqi,jfy5ad6,"there are some PLs which doesn't distinct at all, or in which for example python or rust, there's an implicit self parameter in calling `object.method()` as `Class.method(object)`",0.3,python
12jgfqi,jfy5ad6,"there are some PLs which doesn't distinct at all, or in which for example python or rust, there's an implicit self parameter in calling `object.method()` as `Class.method(object)`",0.3,rust
12jgfqi,jfylo5r,interesting Python fact: that's not how it works actually.,0.25,python
12jgfqi,jfylo5r,"Calling a member of Python is always just calling a function, but when you instantiate an object, members are created with the names of the method and bound to closures that call the method with the instance as first parameter.",0.25,python
12jgfqi,jfylo5r,"class A:         def foo(self):             return 42      a, b = A(), A()     print(a.foo == A.foo)  # False     print(a.foo == b.foo)  # False     print(type(a.foo))  # method     print(type(A.foo))  # function  So syntaxically, Python does not distinguish methods from other attributes.",-0.3083333333333334,python
12jgfqi,jfzqm5s,"That's the C++ solution: ""if the result of a member access expression resolves to a member function, then that expression can only be the left operand of a call expression.""",0.0,c++
12jfq6s,,"Take the following pseudocode:      # A, B, C are type-parameters          let black_box<A, B>(f: func(A) -> B, g: func(A) -> B) -> (func(A) -> B){        if rand() > 0.5 { f } else { g }     }              let foo = func<A>(a: A) -> (A, number){       return (a, 1)     }          let bar = func<A>(a: A) -> (A, number){       return (a, 2)     }          let result_func = black_box(foo, bar)          result_func(""a"");  # Returns either (""a"", 1) or (""a"", 2)  Is this even possible to typecheck using a hindley-milner-ish type system without further annotations?",0.0,c
12jfq6s,,"If so, how does one go about determining that `foo` and `bar` are called/instantiated with `A=string` without some kind of flow/data-analysis?",0.6,go
12jfq6s,jfxxb0j,"Here's the Haskell equivalent:      module Main (main) where          blackBox :: (a -> b) -> (a -> b) -> (a -> b)     blackBox f g = f          foo :: a -> (a, Int)     foo x = (x, 1)          bar :: a -> (a, Int)     bar x = (x, 2)          resultFunc :: a -> (a, Int)     resultFunc = blackBox foo bar          result :: (String, Int)     result = resultFunc ""a""          main :: IO ()     main = print result  And the result:      (""a"",1)  I think you made a mistake with your signature for `black_box`, it introduces `b` and `c` but then you give the type `(a -> b) -> (a -> b) -> (a -> b)`.",-0.34259259259259267,haskell
12jfq6s,jfxxb0j,"Here's the Haskell equivalent:      module Main (main) where          blackBox :: (a -> b) -> (a -> b) -> (a -> b)     blackBox f g = f          foo :: a -> (a, Int)     foo x = (x, 1)          bar :: a -> (a, Int)     bar x = (x, 2)          resultFunc :: a -> (a, Int)     resultFunc = blackBox foo bar          result :: (String, Int)     result = resultFunc ""a""          main :: IO ()     main = print result  And the result:      (""a"",1)  I think you made a mistake with your signature for `black_box`, it introduces `b` and `c` but then you give the type `(a -> b) -> (a -> b) -> (a -> b)`.",-0.34259259259259267,c
12jfq6s,jfxxb0j,"(a -> b) -> (a -> c) -> Either (a -> b) (a -> c)  In which case, that's fine too.",0.4166666666666667,c
12jfq6s,jfy5kkv,"If you're implementing this in Haskell (Rust might work as well, though it's going to have a few rougher edges),  [Trees That Grow](https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf) will make annotating variables pretty easy.",0.16111111111111112,haskell
12jfq6s,jfy5kkv,"If you're implementing this in Haskell (Rust might work as well, though it's going to have a few rougher edges),  [Trees That Grow](https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf) will make annotating variables pretty easy.",0.16111111111111112,rust
12im9hi,,"While not quite a new programming language per se, `mandala` provides a single decorator + context manager which radically reduces the code needed to manage computational artifacts, and gives ordinary Python programs some interesting features from a PL point of view: - it turns programs into interlinked, persistent data as they run.",0.07873376623376624,python
12im9hi,jfw7dbz,I like the idea of decorators handling the workload in Python.,0.0,python
12im9hi,jfxy9gj,It's great how hackable Python is with so little extra syntax on the user side - the amount of logic you can tie to a decorator is amazing.,0.30312500000000003,python
12il3xp,,"This is normally implemented in languages as a virtual getter with a constant return value, but I feel this is less idiomatic as semantically, the information really is meant to be associated with the class, yet by necessity it has to go with the instance!",0.058333333333333334,go
12il3xp,jfu6l34,C# 11 has it.,0.0,c
12il3xp,jfuaeze,I think it should urgently be added to C++.,0.0,c++
12il3xp,jfvvz3b,Kotlin's companion objects seem to basically do that; would you consider that a solution (replacing the static part with singleton objects that can thus use polymorphism)?,0.5,kotlin
12il3xp,jfvp2ut,Objective-C's methods are all resolved dynamically.,0.0,objective-c
12il3xp,jfvp2ut,"Or as D's FI for Objective-C says it, _the static methods are virtual_.",0.5,d
12il3xp,jfvp2ut,"Or as D's FI for Objective-C says it, _the static methods are virtual_.",0.5,objective-c
12il3xp,jfvp2ut,"In PHP, `Self` refers to the early bound type, while `static` refers to the type name that was used to invoke the current static method.",0.275,php
12il3xp,jfw3mkj,Python example of what I want to implement:  ``` class Parent:     NAME = 'BASE'          def print_self(self):         print(type(self).NAME)  class ChildA(Parent):     NAME = 'Child A'  class ChildB(Parent):     NAME = 'Child B'  def print_name(T: type):     print(T.NAME)   if __name__ == '__main__':     print_name(Parent)     print_name(ChildA)     print_name(ChildB)          p = Parent()     a = ChildA()     b = ChildB()          p.print_self()     a.print_self()     b.print_self() ```,-0.3166666666666667,python
12il3xp,jfwh7cd,(C# added a similar feature last year in version 11.),0.0,c
12il3xp,jg1260f,This is also present in ActionScript 3.,0.0,actionscript
12il3xp,jg1c486,"I went ahead and knocked together a C implementation which could be used as part of a source-to-source language, which relies upon a guarantee that the ""ClassClass"" structs are data-layout compatible (i.e.",0.0,c
12il3xp,jg1c486,"whatever additional static members are defined in child classes, they must have the same members as parent in the same order defined _first_ —I'm pretty sure this is fine due to how pointer arithmetic and struct data layouts work, and I've added some additional ""static"" members in the derived classes to try it out, seems to work...):  ``` #include <stdio.h>  void Parent__print_self(void* instance);  struct ParentVtable {     void (*print_self)(void* instance); } ParentVtable = {Parent__print_self};  struct ParentClass {     void* vtable;     const char* NAME; } ParentClass = {&ParentVtable, ""BASE""};  typedef struct {     void* type; } Parent;  const char* ParentClass__class_name(void* classinstance) {     struct ParentClass* type = classinstance;     return type->NAME; }  Parent Parent__constructor() {     return (Parent){&ParentClass}; }  void Parent__print_self(void* instance) {     Parent* self = instance;     printf(""%s\n"", ParentClass__class_name(self->type)); }  struct ChildAClass {     void* vtable;     const char* NAME;     const char* NOM_DE_PLUME; } ChildAClass = {&ParentVtable, ""Child A"", ""Unknown Writer""};  typedef struct {     void* type; } ChildA;  ChildA ChildA__constructor() {     return (ChildA){&ChildAClass}; }  struct ChildBClass {     void* vtable;     const char* NAME;     const char* NOM_DE_GUERRE; } ChildBClass = {&ParentVtable, ""Child B"", ""Unknown Combatant""};  typedef struct {     void* type; } ChildB;  ChildB ChildB__constructor() {     return (ChildB){&ChildBClass}; }  void ChildC__print_self(void* instance);  struct ChildCVtable {     void (*print_self)(void* instance); } ChildCVtable = {ChildC__print_self};  struct ChildCClass {     void* vtable;     const char* NAME; } ChildCClass = {&ChildCVtable, ""Unknown""};  typedef struct {     void* type; } ChildC;  ChildC ChildC__constructor() {     return (ChildC){&ChildCClass}; }  void ChildC__print_self(void* instance) {     Parent* self = instance;     printf(""Really totally completely %s\n"", ParentClass__class_name(self->type)); }  void print_name(void* classinstance) {     struct ParentClass* type = classinstance;     printf(""%s\n"", type->NAME); }  int main() {     print_name(&ParentClass);     print_name(&ChildAClass);     print_name(&ChildBClass);      Parent p = Parent__constructor();     ChildA a = ChildA__constructor();     ChildB b = ChildB__constructor();     ChildC c = ChildC__constructor();      ((struct ParentVtable*)((struct ParentClass*)p.type)->vtable)->print_self(&p);     ((struct ParentVtable*)((struct ParentClass*)a.type)->vtable)->print_self(&a);     ((struct ParentVtable*)((struct ParentClass*)b.type)->vtable)->print_self(&b);     ((struct ParentVtable*)((struct ParentClass*)c.type)->vtable)->print_self(&c); } ```  ~~I could be wrong, but _I reckon_ those ""ClassClass"" structs could also be used to store vtables too...~~  _I was totally right, you can put the vtable in the class-class too!_",0.0773809523809524,c
12il3xp,jfuhz32,Huh cool.,0.35,cool
12il3xp,jfuhz32,It is often my experience that C# contains features which are on my common-sense wishlist!,0.0,c
12il3xp,jfuhq38,"I agree, I found when I tried to use it in C++ and it didn't work, it was a case that contradicted reasonable expectations of how it should function.",0.2,c++
12il3xp,jfvwqdt,"I would say it is _a_ solution just as using const getters in C++ is (or a workaround if you will), but I am looking to implement a system providing class-level polymorphism in approximately the form I described.",-0.4,c++
12il3xp,jfw0nk4,"huh cool, and thanks for the explainer, I don't know Raku so I needed it!",0.3,cool
12il3xp,jfwia57,"Thanks, cool info!",0.31875,cool
12il3xp,jg159rx,Cool anecdote!,0.4375,cool
12il3xp,jfxpma2,"~~Now to think of it, I think one can go around the difference - the method is called on the instance by using the `static::` construct in an instance method.",0.5,go
12il3xp,jfvihyg,"In fact Scala and Kotlin make it explicit in that instead of ""static methods,"" you got a global ""companion global object.""",0.16666666666666666,scala
12il3xp,jfvihyg,"In fact Scala and Kotlin make it explicit in that instead of ""static methods,"" you got a global ""companion global object.""",0.16666666666666666,kotlin
12il3xp,jfw426c,"Btw, I added a Python example demonstrating exactly what I want to implement in my language.",0.25,python
12il3xp,jfywvz2,"FWIW I realise it's a bit more difficult to visualise what I want in dynamic languages like Python and Raku, where there isn't a direct equivalent of ""calling derived methods from a pointer or reference of base type"" but basically, I'm talking about the ability to have static members accessed in base methods which can be overridden in the derived classes such that base's methods access the derived static variable, not the base one.",-0.19090909090909092,python
12il3xp,jfywvz2,"I think my Python snippet elsewhere in thread illustrates more or less what I want, sans ""calling from a reference of base type"" part",-0.15555555555555556,python
12il3xp,jg5ynp2,> dynamic languages like Python and Raku  Raku is statically typed (albeit gradually).,0.0,python
12idj0s,,"I am guessing I build up on the stack the structure of identifiers based on the token that appears next, such as identifier2 being inside identifier1, this can go on a stack.",0.0,go
12idj0s,jft16tx,"> I am guessing I build up on the stack the structure of identifiers based on the token that appears next, such as identifier2 being inside identifier1, this can go on a stack.",0.0,go
12idj0s,jft75hm,"My advice is to experiment, and document as you go (for your own future sanity).",0.3,go
12idj0s,jft75hm,"In other words, the nicer your language's ""developer experience"" is around invocation, the more hell you're going to have to go through to get there.",0.1875,go
12id0uv,jft49fd,It's a graph machine that proceeds by graph rewriting and is used for compiling/executing Haskell.,0.0,haskell
12id0uv,jft5s1h,"Alternatively, [this is a really nice introduction to the G machine for lazy languages](https://amelia.how/posts/the-gmachine-in-detail.html), and a [less pretty but more rigorous introduction to the Spineless Tagless G Machine](https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf) that GHC (Haskell) uses internally.",0.15555555555555556,haskell
12id0uv,jfxlxue,"Besides the G-machine, you might like looking at the internals of the Erlang VM(AKA the 'BEAM').",0.0,erlang
12id0uv,jfvpz2f,I imagine a compiler could go through STG to output some portable bytecode.,0.0,go
12id0uv,jfwa4uc,"A massively parallel, optimal functional runtime in Rust https://github.com/HigherOrderCO/HVM  Good discussions:   * https://news.ycombinator.com/item?id=35336113  * https://news.ycombinator.com/item?id=30219452  * https://zicklag.github.io/blog/interaction-nets-combinators-calculus/",0.35,rust
12id0uv,jfwupc3,that feels like compiling to a lisp in the best way,1.0,lisp
12id0uv,jfyur0o,I imagine a compiler could go through STG to output some portable bytecode.,0.0,go
12icyia,,I’d like to read “compiling with continuations”.,0.0,d
12icyia,jftil6b,"The [Kotlin intermediate representation](https://kotlinlang.org/spec/asynchronous-programming-with-coroutines.html), e.g., makes a pass to transform all asynchronous functions to CPS.",0.0,kotlin
12icyia,jft8bpl,For example Chez Scheme's nanopass compiler uses more than 30 ILs.,0.5,scheme
12icyia,jfued8g,"Back in the day I was on the frontend side of an OOPish C-embedding language that was translated to plain C in continuation-passing style, for use with an async computing runtime; it could be a bit fiddly, but we were able to use it to walk a contextual “self” around the network, carrying its data with it, and we even got it to distribute execution semi-automatically to the GPU when available.",0.17142857142857143,c
12icyia,jfxuygv,"When programming in an imperative language such as C, we take for granted the notion of a call stack, which is actually an abstraction.",0.0,c
12icyia,jfxuygv,"In assembly code for, e.g., x64 and ARM, the stack is just a convention (we can easily write stackless code if we want).",0.43333333333333335,assembly
12icyia,jfxuygv,"When calling a function, e.g., through the `call` instruction, we give the return address as an extra parameter in a register: but that's actually just the continuation parameter that implictly exists in C but explictly exists in CPS and assembly.",0.0,c
12icyia,jfxuygv,"When calling a function, e.g., through the `call` instruction, we give the return address as an extra parameter in a register: but that's actually just the continuation parameter that implictly exists in C but explictly exists in CPS and assembly.",0.0,assembly
12icyia,jfzmw51,Consider the `longjmp` function in the C standard library.,0.0,c
12icyia,jfzmw51,"It is usually written in assembly, you can call it with the `call` instruction, but it doesn't return to the address given, it clears the stack and performs a jump to somewhere else (at least that's how it works in x86).",-0.275,assembly
12icyia,jg3od26,A more exotic example are delimited continuations which transfer control to an enclosing delimiter but also give you the option to go back where you came from.,0.3333333333333333,go
12icyia,jg2ayab,"You may compare this to how Go, Stackless Python and Chez Scheme implement their stacks.",0.0,go
12icyia,jg2ayab,"You may compare this to how Go, Stackless Python and Chez Scheme implement their stacks.",0.0,python
12icyia,jg2ayab,"You may compare this to how Go, Stackless Python and Chez Scheme implement their stacks.",0.0,scheme
12hwafs,jfqvg19,"The permission model is applied all around a native add-on, and is enforced through a hybrid language-binary scheme that interposes on accesses to sensitive resources from all parts of the native library.",0.1,scheme
12hwafs,jfqvg19,"We infer the add-on’s permission-set automatically, over both its binary and JavaScript sides, via a set of novel program analyses.",0.0,javascript
12hhfe5,jfsmnsh,"All the theory in the world is no good if they're not implemented, and Haskell is the only near-mainstream language with a ton of theory, and it's a complete disaster for any practical work.",-0.08333333333333333,haskell
12hhfe5,jfvw1e7,"I've used Haskell for practical work and I love it, I've written a game in it, I've made a REST server in it.",0.04999999999999999,haskell
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,javascript
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,python
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,ruby
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,groovy
12hhfe5,jfvw1e7,"60% of my job is finding bugs that could have been prevented with a type checker, yet JavaScript, Python, Ruby, Groovy, and PHP all remain extremely popular.",0.6,php
12hhfe5,jfvw1e7,Imagine how many JavaScript frameworks and libraries wouldn't have been made if JavaScript had any amount of solid theory behind its design.,0.033333333333333326,javascript
12hhfe5,jfsszh0,"I thought Rust and Haskell were more-or-less the same language, the primary difference being that Rust has more C-like syntax.",0.3,rust
12hhfe5,jfsszh0,"I thought Rust and Haskell were more-or-less the same language, the primary difference being that Rust has more C-like syntax.",0.3,haskell
12hhfe5,jfsszh0,"Since Rust is definitely not a disaster for practical work (in fact, it's the most loved language in the world), Haskell is not either.",0.39999999999999997,rust
12hhfe5,jfsszh0,"Since Rust is definitely not a disaster for practical work (in fact, it's the most loved language in the world), Haskell is not either.",0.39999999999999997,haskell
12hhfe5,jft4ml3,How much Haskell experience do you have?,0.2,haskell
12hhfe5,jg01iui,"> Haskell is the only near-mainstream language with a ton of theory, and it's a complete disaster for any practical work.",0.05,haskell
12hhfe5,jg01iui,In the real world though... where I just finished writing professional Haskell code...,0.15000000000000002,haskell
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,java
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,c++
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,c
12hhfe5,jfx7u3z,"Forgive me for being picky, but that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,rust
12hhfe5,jfx7u3z,"Also, in terms of actual benefits from a practical statically typed system, I'd wager that Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.1,rust
12hhfe5,jfx7u3z,"Also, in terms of actual benefits from a practical statically typed system, I'd wager that Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.1,haskell
12hhfe5,jfsw3ai,"I disagree with the person you’re replying to, but Haskell and Rust are *very* different languages.",0.0,haskell
12hhfe5,jfsw3ai,"I disagree with the person you’re replying to, but Haskell and Rust are *very* different languages.",0.0,rust
12hhfe5,jfsw3ai,"Based on my admittedly limited knowledge of Rust:  Rust doesn’t have HKTs, which are crucial to how many things in the Haskell standard library work (for example, the Functor, Applicative and Monad type classes).",0.16571428571428573,rust
12hhfe5,jfsw3ai,"Based on my admittedly limited knowledge of Rust:  Rust doesn’t have HKTs, which are crucial to how many things in the Haskell standard library work (for example, the Functor, Applicative and Monad type classes).",0.16571428571428573,haskell
12hhfe5,jfsw3ai,Haskell’s main form of branching is pattern matching on algebraic data types (the other kinds of branching actually compile down to this in GHC’s IR).,-0.028472222222222232,haskell
12hhfe5,jfsw3ai,Regarding the safe part of Haskell: Rust functions are not necessarily referentially transparent while Haskell’s are.,0.25,haskell
12hhfe5,jfsw3ai,Regarding the safe part of Haskell: Rust functions are not necessarily referentially transparent while Haskell’s are.,0.25,rust
12hhfe5,jfsw3ai,Haskell does not have a borrow checker or any notion of ownership or lifetime.,0.0,haskell
12hhfe5,jfsw3ai,"In fact, Haskell doesn’t even have a notion of identity based on memory location.",0.0,haskell
12hhfe5,jfsw3ai,Haskell uses lazy evaluation by default and Rust uses strict evaluation by default.,-0.25,haskell
12hhfe5,jfsw3ai,Haskell uses lazy evaluation by default and Rust uses strict evaluation by default.,-0.25,rust
12hhfe5,jfsw3ai,"As a result, infinite data structures can be directly defined in Haskell, but not so in Rust.",0.1,haskell
12hhfe5,jfsw3ai,"As a result, infinite data structures can be directly defined in Haskell, but not so in Rust.",0.1,rust
12hhfe5,jfsw3ai,Side effects are not controlled in Rust like they are in Haskell.,0.0,rust
12hhfe5,jfsw3ai,Side effects are not controlled in Rust like they are in Haskell.,0.0,haskell
12hhfe5,jfsw3ai,"A stronger argument is that Haskell has been used for years at Facebook for fighting spam, handling millions of requests per second.",0.0,haskell
12hhfe5,jft8qop,"Secondly, there have been calls on various Rust forums encouraging people to go and vote actively, regardless of whether they actually use the language, know about the language, or love/hate the language.",-0.03333333333333333,rust
12hhfe5,jft8qop,"Secondly, there have been calls on various Rust forums encouraging people to go and vote actively, regardless of whether they actually use the language, know about the language, or love/hate the language.",-0.03333333333333333,go
12hhfe5,jft8qop,"Thirdly, the vast majority of users claiming to use Rust on a daily basis does not match up with the actual number of Rust users in the industry.",0.0,rust
12hhfe5,jft8qop,"The vast majority of the people claiming to love Rust have actually either never used it, or have simply done a few tutorials on it.",0.06,rust
12hhfe5,jft8qop,"Rust does have some features borrowed from Haskell, but Rust is a strongly imperative language while Haskell is a pure* Functional language.",0.32380952380952377,rust
12hhfe5,jft8qop,"Rust does have some features borrowed from Haskell, but Rust is a strongly imperative language while Haskell is a pure* Functional language.",0.32380952380952377,haskell
12hhfe5,jft9fdv,"Go read https://old.reddit.com/r/haskell/comments/12eu6ij/is_it_viable_to_get_your_first_programming_job/, for instance.",0.0,go
12hhfe5,jft9fdv,"Both Haskell and Rust have failed in this regard, albeit for different reasons.",-0.25,haskell
12hhfe5,jft9fdv,"Both Haskell and Rust have failed in this regard, albeit for different reasons.",-0.25,rust
12hhfe5,jft9fdv,"Secondly, a language that requires knowledge of a subset of a million different ""extensions"" to the point that core members have to advocate for a return to ""Simple Haskell"" (which is, unfortunately, not powerful enough for most industry work) is symptomatic of deep issues within the language itself.",0.049999999999999996,haskell
12hhfe5,jft9fdv,"Thirdly, for a very strongly typed language, Haskell is notorious for its atrocious error messages and it abysmal build and dependency tooling.",-0.04555555555555554,haskell
12hhfe5,jft9fdv,"Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon), Jones (onto the disaster called ""Verse'), and the few jobs outside of some banks that were create due to Haskell evangelists have been drying up and dying off.",0.034999999999999996,haskell
12hhfe5,jft9fdv,"Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon), Jones (onto the disaster called ""Verse'), and the few jobs outside of some banks that were create due to Haskell evangelists have been drying up and dying off.",0.034999999999999996,rust
12hhfe5,jft9fdv,"Hell, I'd wager that Facebook probably uses more OCaml than it does Haskell.",0.5,haskell
12hhfe5,jft9fdv,"Haskell has been moribund for some time, and it's deep issues not only with the language, but the very core design of the language and its community.",0.06666666666666667,haskell
12hhfe5,jfxals9,"Java, C++, and C# all have *awful* type systems.",-1.0,java
12hhfe5,jfxals9,"Java, C++, and C# all have *awful* type systems.",-1.0,c++
12hhfe5,jfxals9,"Java, C++, and C# all have *awful* type systems.",-1.0,c
12hhfe5,jfxals9,"Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,java
12hhfe5,jfxals9,"Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,c++
12hhfe5,jfxals9,"Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,c
12hhfe5,jfxals9,"Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,rust
12hhfe5,jfxals9,"Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,c
12hhfe5,jfxals9,"It's a nice, well considered language if a little verbose from its C aesthetics.",0.20625,c
12hhfe5,jfxals9,It's pretty much equivalent to Haskell's type system with a different syntax- it's all Hindley Milner + Type classes.,0.15,haskell
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,java
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,c++
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,c
12hhfe5,jg02x6k,"> that whole explanation is basically showcasing the issues/downsides of dynamic languages (which I agree with) which could have been resolved by using even a moderately strongly typed static language - Java, Golang, C++, C#, Rust et al.",0.2833333333333333,rust
12hhfe5,jg02x6k,> ... even though it's not remotely as expressive as Haskell's.,-0.4,haskell
12hhfe5,jg02nov,"> Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.13333333333333333,rust
12hhfe5,jg02nov,"> Rust's is more practical and powerful than Haskell's, even though it's not remotely as expressive as Haskell's.",0.13333333333333333,haskell
12hhfe5,jg02nov,On what grounds do you claim Rust is both not as expressive as Haskell but more powerful?,0.5333333333333333,rust
12hhfe5,jg02nov,On what grounds do you claim Rust is both not as expressive as Haskell but more powerful?,0.5333333333333333,haskell
12hhfe5,jfsx5u1,"OK, I know neither Rust nor Haskell.",0.5,rust
12hhfe5,jfsx5u1,"OK, I know neither Rust nor Haskell.",0.5,haskell
12hhfe5,jfv06yg,And your analysis of simple Haskell is mostly flawed; many of us enjoy a broad amount of the extensions for the ability to great soundly typed programs with ease.,0.23750000000000002,haskell
12hhfe5,jfv06yg,Do you know how absolutely trash GCC error messages are when dealing with templates in c++?,0.2,c++
12hhfe5,jfv06yg,"And to add on, go read: http://www.paulgraham.com/avg.html please.",0.0,go
12hhfe5,jfv06yg,It discusses beating the averages (succeeding as a startup) using lisp.,0.0,lisp
12hhfe5,jg028we,"> to the point that core members have to advocate for a return to ""Simple Haskell""   ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.32499999999999996,haskell
12hhfe5,jg028we,"> to the point that core members have to advocate for a return to ""Simple Haskell""   ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.32499999999999996,scala
12hhfe5,jg028we,"> to the point that core members have to advocate for a return to ""Simple Haskell""   ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.32499999999999996,java
12hhfe5,jg028we,"> Hell, I'd wager that Facebook probably uses more OCaml than it does Haskell.",0.5,haskell
12hhfe5,jg028we,Target uses Haskell for supply chain management... again core infrastructure.,0.0,haskell
12hhfe5,jg028we,"> Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon),  Overblown.",0.25,haskell
12hhfe5,jg028we,"> Finally, the fact that many Haskell stalwarts have all but abandoned the language - Chris Allen and Snoyman (both onto the Rust bandwagon),  Overblown.",0.25,rust
12hhfe5,jg028we,"> Haskell has been moribund for some time, and it's deep issues not only with the language, but the very core design of the language and its community.",0.06666666666666667,haskell
12hhfe5,jfxd5af,"> Java, C++, and C# all have awful type systems.",-1.0,java
12hhfe5,jfxd5af,"> Java, C++, and C# all have awful type systems.",-1.0,c++
12hhfe5,jfxd5af,"> Java, C++, and C# all have awful type systems.",-1.0,c
12hhfe5,jfxd5af,Nowhere in your original post did you showcase anything that could only be solved by Haskell.,0.1875,haskell
12hhfe5,jfxd5af,"> Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,java
12hhfe5,jfxd5af,"> Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,c++
12hhfe5,jfxd5af,"> Java, C++, and C# all have inheritance, which theory and practice have shown time and again to be the worst tool in any situation.",-1.0,c
12hhfe5,jfxd5af,OOP is orthogonal to Functional Programming - this is why languages like Scala still have them.,0.0,scala
12hhfe5,jfxd5af,"Sure, it's a bit silly, but is it easier to use than, say, in Haskell?",0.0,haskell
12hhfe5,jfxd5af,"Do a simple experiment - find a couple of colleagues with no experience in either Golang or Haskell, and teach them both error handling in both languages.",0.0,haskell
12hhfe5,jfxd5af,"Again, in your original post you have made no mention of any feature remotely better solved (or indeed solely solved) by using something like Haskell.",0.4375,haskell
12hhfe5,jfxd5af,"I'd be surprised if your average application, including the REST server and game that you mentioned were better solved in Haskell or practically any other randomly chosen static language.",-0.010714285714285707,haskell
12hhfe5,jfxd5af,"Maybe you should showcase something in your projects where Haskell's uber type system was indispensable - either in expressiveness, performance, or both.",0.4,haskell
12hhfe5,jfxd5af,"> Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,rust
12hhfe5,jfxd5af,"> Rust has a good type system, but that's because Rust is an ML with a C skin, and it's heavily based in theory.",0.24999999999999997,c
12hhfe5,jfxd5af,"It's a nice, well considered language if a little verbose from its C aesthetics.",0.20625,c
12hhfe5,jfxd5af,It's pretty much equivalent to Haskell's type system with a different syntax- it's all Hindley Milner + Type classes.,0.15,haskell
12hhfe5,jfxd5af,"I'm sorry, but Rust is nowehere near an ML.",-0.2,rust
12hhfe5,jfxd5af,"Rust is the exact opposite - strongly imperative and with ubiquitous mutation with an intelligent system that can still provide strong guarantees (extending beyond just memory), and a type system with features inspired from ML and Haskell.",0.38333333333333336,rust
12hhfe5,jfxd5af,"Rust is the exact opposite - strongly imperative and with ubiquitous mutation with an intelligent system that can still provide strong guarantees (extending beyond just memory), and a type system with features inspired from ML and Haskell.",0.38333333333333336,haskell
12hhfe5,jfxd5af,Rust's type system in not equivalent to Haskell's by any stretch of the imagination.,0.0,rust
12hhfe5,jfxd5af,Rust's type system in not equivalent to Haskell's by any stretch of the imagination.,0.0,haskell
12hhfe5,jg1wr9w,Writing a REST server or a game is not where a language like Haskell shines compared to a run-of-the-mill static language.,0.04999999999999999,haskell
12hhfe5,jfylt7b,">And to add on, go read: [http://www.paulgraham.com/avg.html](http://www.paulgraham.com/avg.html) please.",-0.75,go
12hhfe5,jfylt7b,It discusses beating the averages (succeeding as a startup) using lisp.,0.0,lisp
12hhfe5,jfylt7b,"More interesting still is note (1) at the end: their startup wasn't written just in Lisp, but in Lisp, C and later Perl.",0.3333333333333333,lisp
12hhfe5,jfylt7b,"More interesting still is note (1) at the end: their startup wasn't written just in Lisp, but in Lisp, C and later Perl.",0.3333333333333333,c
12hhfe5,jfylt7b,"More interesting still is note (1) at the end: their startup wasn't written just in Lisp, but in Lisp, C and later Perl.",0.3333333333333333,perl
12hhfe5,jfylt7b,"Looking back at the beginning, it says it's written *primarily* in Lisp; funny how easily missed or ignored that bit.",0.27083333333333337,lisp
12hhfe5,jfylt7b,"So, apparently Lisp and its macros is not quite all-powerful enough to do the whole job after all!",0.09999999999999999,lisp
12hhfe5,jfylt7b,"Regarding Haskell, it's one of those languages I can admire but would never be able to use.",0.5,haskell
12hhfe5,jfylt7b,I remember in a C forum where someone would post a 10-line Haskell solution to a task that took 100 or 200 lines of C. I would follow it up with a version that was maybe 15-20 lines but in my scripting language.,0.0,c
12hhfe5,jfylt7b,I remember in a C forum where someone would post a 10-line Haskell solution to a task that took 100 or 200 lines of C. I would follow it up with a version that was maybe 15-20 lines but in my scripting language.,0.0,haskell
12hhfe5,jfylt7b,The difference was that the Haskell verson would be incomprehensible; it would be just too clever.,0.16666666666666666,haskell
12hhfe5,jfx7c0f,And your analysis of simple Haskell is mostly flawed; many of us enjoy a broad amount of the extensions for the ability to great soundly typed programs with ease.,0.23750000000000002,haskell
12hhfe5,jfx7c0f,This is the classic Scala varying feature subsets problem on steroids.,0.16666666666666666,scala
12hhfe5,jfx7c0f,> Do you know how absolutely trash GCC error messages are when dealing with templates in c++?,0.2,c++
12hhfe5,jfx7c0f,"Sure, but C++ (or C for that matter) are expected to be hard to build - too low-level (which Haskell is not).",0.036111111111111115,c++
12hhfe5,jfx7c0f,"Sure, but C++ (or C for that matter) are expected to be hard to build - too low-level (which Haskell is not).",0.036111111111111115,c
12hhfe5,jfx7c0f,"Sure, but C++ (or C for that matter) are expected to be hard to build - too low-level (which Haskell is not).",0.036111111111111115,haskell
12hhfe5,jfx7c0f,Even Rust with its usually great `Cargo` tool often breaks down with native dependencies depending on the platform.,0.32222222222222224,rust
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,java
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,c
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,ruby
12hhfe5,jfx7c0f,"On the other hand, you rarely find builds failing in higher-level languages such as Java, C#, Golang, OCaml, Ruby et al (which are still at a lower abstraction level than Haskell).",0.05833333333333333,haskell
12hhfe5,jfx7c0f,"Also, the ""enlightenment"" achieved by Haskell (much like in the case of Lisps) is greatly over-exaggerated.",0.5,haskell
12hhfe5,jfx7c0f,"> And to add on, go read: http://www.paulgraham.com/avg.html please.",0.0,go
12hhfe5,jfx7c0f,It discusses beating the averages (succeeding as a startup) using lisp.,0.0,lisp
12hhfe5,jfx7c0f,"Moreover, the situations involved in the creation of Viaweb, if you study them, will reveal that using Common Lisp was neither necessary for it to have succeeded, nor did it persist (Yahoo rewrote it in C++ IIRC).",-0.15,lisp
12hhfe5,jfx7c0f,"Moreover, the situations involved in the creation of Viaweb, if you study them, will reveal that using Common Lisp was neither necessary for it to have succeeded, nor did it persist (Yahoo rewrote it in C++ IIRC).",-0.15,c++
12hhfe5,jg1ymt0,There is a reason why Scala failed - too many different paradigmatic feature subsets to the point where two teams would often end up not being able to work together because of the differing subsets that they'd settled upon.,0.125,scala
12hhfe5,jg1ymt0,"So also for Haskell, and even a cursory search on the matter will prove that this is a problem.",0.0,haskell
12hhfe5,jg1ymt0,"> ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.4333333333333333,haskell
12hhfe5,jg1ymt0,"> ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.4333333333333333,scala
12hhfe5,jg1ymt0,"> ""Simple Haskell"" isn't unilaterally popular and for good reason: That sort of prescriptive approach dampens a lot of the USP and just encourages ""write Scala as if it's Java"" styles.",0.4333333333333333,java
12hhfe5,jg1ymt0,Target uses Haskell for supply chain management... again core infrastructure.,0.0,haskell
12hhfe5,jg1ymt0,"The data about Haskell usage is conflicting and inconclusive, and may be definitely outdated, and that was for the large part due to people like Marlow who were evangelising it.",-0.1035714285714286,haskell
12hhfe5,jg1ymt0,"I have a suspicion  they're transitioning large chunks of Haskell into other, more pragmatic languages, and OCaml is an excellent fit for that.",0.39785714285714285,haskell
12hhfe5,jg3jfc3,The best kind - the absolute genius idea of looking at publicly available data which show that Haskell in the industry has been an unmitigated failure.,0.3766666666666667,haskell
12hhfe5,jg0f7vn,"And yes, Haskell programs can be far too clever than they ought to be.",0.13333333333333333,haskell
12hhfe5,jg0f7vn,"That is, it's *easy* to write *complex*, hard to understand code in java (think about all your Abstract classes or Proxies or Factories, God forbid an AbstractSingletonProxyFactoryBean), while other languages like Haskell tend to have *hard* to write code (i.e.",-0.11499999999999999,java
12hhfe5,jg0f7vn,"That is, it's *easy* to write *complex*, hard to understand code in java (think about all your Abstract classes or Proxies or Factories, God forbid an AbstractSingletonProxyFactoryBean), while other languages like Haskell tend to have *hard* to write code (i.e.",-0.11499999999999999,haskell
12hhfe5,jfxp85q,The homoiconicity of lisp is similarly enlightening.,0.3,lisp
12hhfe5,jfxp85q,But his argument is that lisp allowed him to move fast and not break things.,0.2,lisp
12hhfe5,jfxp85q,In 2003 he noted that they wrote a C++ lisp interpreter for some of the files because they were still written in lisp.,0.0,c++
12hhfe5,jfxp85q,In 2003 he noted that they wrote a C++ lisp interpreter for some of the files because they were still written in lisp.,0.0,lisp
12hhfe5,jfxp85q,No language does parser combinators as well as Haskell at the moment.,0.0,haskell
12hhfe5,jfxp85q,"And I'm curious, you said you've dawdled with haskell.",-0.1,haskell
12hhfe5,jg3kjaa,What publicly available data shows Haskell in industry has been an unmitigated failure?,0.04166666666666666,haskell
12hhfe5,jg3kjaa,"You pretend as if you are talking more empirically, but my anecdotal real world professional Haskell experience holds more weight than your ""used Haskell some"" combined with armchair opinions.",0.27999999999999997,haskell
12hhfe5,jg3jqsk,"If you think that a REST server or a game requires Haskell's powerful type system, then you have bigger problems than you realise.",-0.03333333333333335,haskell
12hhfe5,jg2a587,"> God forbid an AbstractSingletonProxyFactoryBean)  Yeah, try using Haskell to write one of those enterprise apps with a team of around 25-30 developers spread across 2-3 subteams.",0.0,haskell
12hhfe5,jg2a587,"Java's abject simplicity (vis-a-vis Haskell) leads to inevitable verbosity, but also excellent maintainability.",0.5,java
12hhfe5,jg2a587,"Java's abject simplicity (vis-a-vis Haskell) leads to inevitable verbosity, but also excellent maintainability.",0.5,haskell
12hhfe5,jfy23jl,The homoiconicity of lisp is similarly enlightening.,0.3,lisp
12hhfe5,jfy23jl,The homoiconicity of Lisp again is simply an artifact of its origins.,0.0,lisp
12hhfe5,jfy23jl,after Lisp's birth.,0.0,lisp
12hhfe5,jfy23jl,They are also Lisp-specific in the sense that Lisp needed them to become somewhat useful in the modern world.,0.25,lisp
12hhfe5,jfy23jl,But his argument is that lisp allowed him to move fast and not break things.,0.2,lisp
12hhfe5,jfy23jl,In 2003 he noted that they wrote a C++ lisp interpreter for some of the files because they were still written in lisp.,0.0,c++
12hhfe5,jfy23jl,In 2003 he noted that they wrote a C++ lisp interpreter for some of the files because they were still written in lisp.,0.0,lisp
12hhfe5,jfy23jl,"Here's his response, verbatim (if he's reading this, I hope he doesn't mind me sharing it here):  ""At the time I wanted to believe I'm better than other people, so I attached to Lisp.",0.1875,lisp
12hhfe5,jfy23jl,"It's laughably naive, but you know what they say, it's a pity youth is wasted on the young :)  Lisp is a useful language to learn and program in for a few months.",0.014285714285714266,lisp
12hhfe5,jfy23jl,Ruby and Python are the obvious suspects.,0.0,ruby
12hhfe5,jfy23jl,Ruby and Python are the obvious suspects.,0.0,python
12hhfe5,jfy23jl,Clojure's pretty good too.,0.475,clojure
12hhfe5,jfy23jl,It doesn't make that much difference in the grand scheme of things.,0.35,scheme
12hhfe5,jfy23jl,"I've dabbled in Common Lisp for many years myself, and came to the same conclusion.",0.06666666666666667,lisp
12hhfe5,jfy23jl,"Just as with the Graham example, over-exaggerating things leads to disaster - like the first version of Reddit itself being in Common Lisp (despite having had no reason to), which resulted in a very unstable and immature product till they switched over to Python soon thereafter.",0.05000000000000001,lisp
12hhfe5,jfy23jl,"Just as with the Graham example, over-exaggerating things leads to disaster - like the first version of Reddit itself being in Common Lisp (despite having had no reason to), which resulted in a very unstable and immature product till they switched over to Python soon thereafter.",0.05000000000000001,python
12hhfe5,jfy23jl,No language does parser combinators as well as Haskell at the moment.,0.0,haskell
12hhfe5,jfy23jl,">  > And I'm curious, you said you've dawdled with haskell.",-0.1,haskell
12hhfe5,jfy23jl,"Hence why the more pragmatic Refinement Types (a la Liquid Haskell, Ada, or even Racket) became more dominant than Dependent Types.",0.5,haskell
12hhfe5,jfy23jl,"Hence why the more pragmatic Refinement Types (a la Liquid Haskell, Ada, or even Racket) became more dominant than Dependent Types.",0.5,ada
12hhfe5,jfy23jl,"""Referential transparency"" is no good when it comes at massive performance costs or when the whole point is rendered moot by more tractable type systems such as Rust's (or ATS') which can prove more useful and more powerful facts about mutation (which is much easier to use than immutability).",0.21500000000000002,rust
12hhfe5,jfy23jl,So also with monads (which were a sort of hack to accommodate the lack of effects in Haskell to begin with) which have inspired streams in Java and enums in Rust (specifically for error handling).,0.0,haskell
12hhfe5,jfy23jl,So also with monads (which were a sort of hack to accommodate the lack of effects in Haskell to begin with) which have inspired streams in Java and enums in Rust (specifically for error handling).,0.0,java
12hhfe5,jfy23jl,So also with monads (which were a sort of hack to accommodate the lack of effects in Haskell to begin with) which have inspired streams in Java and enums in Rust (specifically for error handling).,0.0,rust
12hhfe5,jg4azaw,"If you choose to ignore the non-existent job market in Haskell, the whole reddit thread from /r/haskell that I linked to in a comment in this post's comments about the difficulty of even securing a job in Haskell, about the migration of Haskell stalwarts away from Haskell, about literally every PL ranking out there, about the systemic flaws in the Haskell ecosystem, particularly its tooling, about the abject mess of extensions leading to innumerable SO posts by newbies (and even intermediates) confused by realworld Haskell projects, about the practically nil usage in the industry (or even in academia where OCaml is still more popular), then you are not only disingenuous, but also needlessly truculent and delusional.",0.048958333333333326,haskell
12hhfe5,jg2awn4,*Using* those systems the java devs make may be easy but understanding their code when you dive in can be difficult (due to *complexity*).,0.014583333333333337,java
12hhfe5,jg2awn4,With Haskell the code is really easy to read but often harder to write (but when you do it's very easy to maintain and deal with!).,0.3458333333333334,haskell
12hhfe5,jg2awn4,Also java has nothing like referential transparency.,0.0,java
12hhfe5,jg2ov47,Using those systems the java devs make may be easy but understanding their code when you dive in can be difficult (due to complexity).,-0.06388888888888888,java
12hhfe5,jg2ov47,"The former is inevitable, and the latter is practically non-existent in Java (or similar) whereas it's aplenty in languages with entire sub-languages and too many conceptual ideas in the language itself (Scala, Haskell, Idris et al).",0.08333333333333333,java
12hhfe5,jg2ov47,"The former is inevitable, and the latter is practically non-existent in Java (or similar) whereas it's aplenty in languages with entire sub-languages and too many conceptual ideas in the language itself (Scala, Haskell, Idris et al).",0.08333333333333333,scala
12hhfe5,jg2ov47,"The former is inevitable, and the latter is practically non-existent in Java (or similar) whereas it's aplenty in languages with entire sub-languages and too many conceptual ideas in the language itself (Scala, Haskell, Idris et al).",0.08333333333333333,haskell
12hhfe5,jg2ov47,>  With Haskell the code is really easy to read but often harder to write (but when you do it's very easy to maintain and deal with!).,0.3458333333333334,haskell
12hhfe5,jg2ov47,"This goes against every single complaint by beginners to Haskell who, having finished a book or two on Haskell, then jump into real world code to find themselves completely lost.",-0.017857142857142856,haskell
12hhfe5,jg2ov47,"Hence the call for ""boring Haskell"" or ""Simple Haskell' (i.e,, the simple core language that is Haskell 98 or Haskell 2010 even).",-0.3333333333333333,haskell
12hhfe5,jg2ov47,"As for maintainability, there is no empirical data that shows that type towers created using Haskell are more maintainable than say, in Java.",0.225,haskell
12hhfe5,jg2ov47,"As for maintainability, there is no empirical data that shows that type towers created using Haskell are more maintainable than say, in Java.",0.225,java
12hhfe5,jg2ov47,"One might imagine that at least refactoring would be rendered easier, but again due to the absymal state of tooling coupled with the horrendous error-reporting systems in Haskell, it's more of a pain in Haskell than in Java.",0.025000000000000005,haskell
12hhfe5,jg2ov47,"One might imagine that at least refactoring would be rendered easier, but again due to the absymal state of tooling coupled with the horrendous error-reporting systems in Haskell, it's more of a pain in Haskell than in Java.",0.025000000000000005,java
12hhfe5,jg2ov47,> Also java has nothing like referential transparency.,0.0,java
12hhfe5,jg2ov47,"It's about as meaningless as mocking Haskell's inability to compile to native binaries with no GC, or the fact that Haskell is non-strict by default.",-0.5,haskell
12hhfe5,jg2ov47,Java is not one.,0.0,java
12hdjdx,,Someone even mentioned using JIT for programs written in [assembly](https://www.reddit.com/r/ProgrammingLanguages/comments/12gmxpt/comment/jfn480t/?utm_source=share&utm_medium=web2x&context=3).,0.0,assembly
12hdjdx,jfohab0,V8's tier 1 JavaScript compiler is a non-optimizing compiler.,0.0,javascript
12hdjdx,jfohab0,"To some extent sure, this is one of the motivations for Java.",0.5,java
12hdjdx,jfohab0,"In Java, every method is virtual, so if you were to compile this naively, you would need to compile every call to an indirect vtable call and could not inline or perform any optimizations unless you absolutely know the runtime class of a value.",-0.04999999999999999,java
12hdjdx,jfohab0,Haskell is another great example.,0.8,haskell
12hdjdx,jfohab0,"Even though Haskell is probably one of the most static languages there are, it would absolutely benefit from JIT compilation!",0.4166666666666667,haskell
12hdjdx,jfohab0,"GHC (the standard Haskell AOT compiler) performs a ton of demand analysis to try and optimize laziness out as much as possible, but it is limited by the information it has at compile time.",-0.023809523809523808,haskell
12hdjdx,jfohab0,"Similarly, type classes are desugared into dictionaries (effectively structs of functions), which are (in the polymorphic case) compiled to indirect calls and cannot be inlined, similar to virtual calls in Java.",0.19999999999999998,java
12hdjdx,jfohrwa,Clojure compiles all expressions to JVM bytecode at runtime and then runs it - is it a JIT?,0.0,clojure
12hdjdx,jfojuel,Someone even mentioned using JIT for programs written in assembly.,0.0,assembly
12hdjdx,jfojuel,"There are tools which can AOT compile Java Bytecode and CLR bytecode, but they put some limitations on the features available for use in the language - reflection is usually off the table.",0.07500000000000001,java
12hdjdx,jfonx6x,"Also note that languages like Java are typically AOTed from source to bytecode, then JITed from bytecode to machine code.",-0.16666666666666666,java
12hdjdx,jfonx6x,They did it that way to make it more easily portable (especially given stuff like the old Java applets).,0.25833333333333336,java
12hdjdx,jfogci7,"My language is more like a ""meta"" language like lisp where the reader / lexer can be extended at ""read time""  The runtime for my language looks like this:  Read -> Compile -> Execute -> loop  Or in case it reads a reader word, it will execute the reader word, which is kinda ""hijacking"" the reader and the runtime.",0.5,lisp
12hdjdx,jfok4gn,"When you compile your app to CIL or Java Bytecode the result (theoretically) runs wherever the compatible VM is available; so you don't have to deploy to all these architectures yourself, just to one architecture.",0.2,java
12hdjdx,jfok4gn,"for my Oberon+ implementation, where during development and debugging the code runs on the Mono VM; when ready the app can be either deployed as a CLR compatible assembly or AOT compiled to a specific architecture via generated C, reusing the existing, very powerful toolchains.",0.19666666666666668,assembly
12hdjdx,jfok4gn,"for my Oberon+ implementation, where during development and debugging the code runs on the Mono VM; when ready the app can be either deployed as a CLR compatible assembly or AOT compiled to a specific architecture via generated C, reusing the existing, very powerful toolchains.",0.19666666666666668,c
12hdjdx,jfqh1fw,"Languages are most of the times compiled in IR, and even though the IR is sometimes the final product that is bundled to user, this is always understood to be an AOT (maybe you can say in Python is not AOT, as it is done transparently to you), but the JIT is the part of the runtime that executes the operations of the program on a target machine, typically by generating the binary code.",0.11111111111111112,python
12hdjdx,jfqh1fw,"The main advantages of tracing JITs are multiple:   \- you compile sub-parts of program, meaning that this JIT time, even you do ""complex"" optimizations, it will not add up to much, so it is less ""JIT'tery"" (no pun intended :) )   \- basic blocks are layed out in memory linearly, so compared with a method compiler, that can be large (in Java you can have up-to 65K bytecodes, and if expanded in an IR that you interpret against, it could be a better part of a megabyte), typically these basic blocks are small and even with compiler's data structures, wouldn't go to high memory consumption   \- another amazing advantage for these JITs is that they can decide not to do it: if you would make a JIT for the entire method (like Java or Android would do it, or C#/CLR for that matter), if your JIT has a bug not to support division because your underlying processor doesn't have a division operation (like lower end ARM CPUs) and you don't want to add support for it, this is not an issue for tracing JITs, only blocks with divisions would not be JITted.",0.06297619047619049,java
12hdjdx,jfqh1fw,"The main advantages of tracing JITs are multiple:   \- you compile sub-parts of program, meaning that this JIT time, even you do ""complex"" optimizations, it will not add up to much, so it is less ""JIT'tery"" (no pun intended :) )   \- basic blocks are layed out in memory linearly, so compared with a method compiler, that can be large (in Java you can have up-to 65K bytecodes, and if expanded in an IR that you interpret against, it could be a better part of a megabyte), typically these basic blocks are small and even with compiler's data structures, wouldn't go to high memory consumption   \- another amazing advantage for these JITs is that they can decide not to do it: if you would make a JIT for the entire method (like Java or Android would do it, or C#/CLR for that matter), if your JIT has a bug not to support division because your underlying processor doesn't have a division operation (like lower end ARM CPUs) and you don't want to add support for it, this is not an issue for tracing JITs, only blocks with divisions would not be JITted.",0.06297619047619049,go
12hdjdx,jfqh1fw,"The main advantages of tracing JITs are multiple:   \- you compile sub-parts of program, meaning that this JIT time, even you do ""complex"" optimizations, it will not add up to much, so it is less ""JIT'tery"" (no pun intended :) )   \- basic blocks are layed out in memory linearly, so compared with a method compiler, that can be large (in Java you can have up-to 65K bytecodes, and if expanded in an IR that you interpret against, it could be a better part of a megabyte), typically these basic blocks are small and even with compiler's data structures, wouldn't go to high memory consumption   \- another amazing advantage for these JITs is that they can decide not to do it: if you would make a JIT for the entire method (like Java or Android would do it, or C#/CLR for that matter), if your JIT has a bug not to support division because your underlying processor doesn't have a division operation (like lower end ARM CPUs) and you don't want to add support for it, this is not an issue for tracing JITs, only blocks with divisions would not be JITted.",0.06297619047619049,c
12hdjdx,jfqh1fw,"If I would be you, depending on specifics of the language, I would try to convert it to JavaScript and run it in NodeJS if you want fast speed.",0.2,javascript
12hdjdx,jfqh1fw,"If you are familiar with Java, use Java code or Java bytecode to generate live code.",0.2556818181818182,java
12hdjdx,jfqh1fw,"Or for C#, there are also many ways to generate C# or IL.",0.5,c
12hdjdx,jfqh1fw,"You will be surprised how fast are these JITs (all of them are method based JITs) and they will beat your assembly language, no offense of how good coder you are in assembly!.",0.39166666666666666,assembly
12hdjdx,jfqg5jh,I'd love to try out JITd haskell,0.5,haskell
12hdjdx,jfoih60,"Ditto with Clojure generating bytecode, so only the JVM has a JIT.",0.0,clojure
12hdjdx,jfqtntt,>I would try to convert it to JavaScript and run it in NodeJS if you want fast speed.,0.2,javascript
12hdjdx,jfqtntt,"If you are familiar with Java, use Java code or Java bytecode to generate live code.",0.2556818181818182,java
12hdjdx,jfqtntt,">You will be surprised how fast are these JITs (all of them are method based JITs) and they will beat your assembly language, no offense of how good coder you are in assembly!.",0.39166666666666666,assembly
12hdjdx,jfp3zk7,"You can also compile Clojure code to bytecode ahead of time, and even compile the bytecode to machine code ahead of time using Graal.",0.0,clojure
12hdjdx,jfp3zk7,"**EDIT:** Clojure is even more nuanced in this regard, since an expression is compiled to bytecode on demand and then then the JVM profiles and compiles hot spots to machine code.",0.375,clojure
12hdjdx,jfqk0wi,> I'd say that producing machine code is a criterion  That would disqualify Java Bytecode to WASM/JavaScript/V8 Bytecode JIT compilers.,0.0,java
12hdjdx,jfqk0wi,As well as Java Bytecode to CIL JIT compilers.,0.0,java
12hdjdx,jfqk0wi,"That would also disqualify JSP to Java Bytecode JIT compilers, as well as several other HTML/CSS template compilers which target JS, PHP, or some bytecode.",-0.0625,java
12hdjdx,jfqk0wi,"That would also disqualify JSP to Java Bytecode JIT compilers, as well as several other HTML/CSS template compilers which target JS, PHP, or some bytecode.",-0.0625,php
12hdjdx,jfotuix,"I've usually seen the argument given with respect to Java, x86-to-x86 JITs and similar stuff, where things like branch prediction (or even vectorized instructions) rarely make up for the overhead.",0.016666666666666663,java
12hdjdx,jft9ert,"If you consider that binary to binary translation is not your use-case, there were also dynamic languages which use tracing JITs used as far as my memory goes initially in Adobe's Flash and Firefox 3.x era, Android 2.2 up to version 4.4 (KitKat allowed you to use ""method JIT"" named ART), Lua and PyPy as you said.",0.03333333333333333,lua
12hdjdx,jft9ert,So for your question: ActionScript and JS were using a tracing JIT.,0.0,actionscript
12hdjdx,jft820j,"So most likely for your simplicity, to pass a function to a C API you have 2 options: either provide some template (like C++ templates) and this function is a stub, where you can even specify what interpreter function would be called to return the requested value.",0.25,c
12hdjdx,jft820j,"So most likely for your simplicity, to pass a function to a C API you have 2 options: either provide some template (like C++ templates) and this function is a stub, where you can even specify what interpreter function would be called to return the requested value.",0.25,c++
12hdjdx,jft820j,"When the threshold is met, assuming that there is no branch, when you see that a liner sequence is found by a number of times, a JIT would generate the code (you can use a C compiler for what it worth, compile it as a libSO/dll, load the function) and call it later",0.15,c
12h2epz,jfsr2cx,Cool story bro.,0.35,cool
12gmxpt,,"Features I often like using are : sum types / Rust-like enums and generics  Here are the languages I'm considering and the potential downsides :  C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C++ : not really pleasant to work with for me, and like in C, I don't really like the header system  Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  Zig : am not really familiar with Zig but I'm willing to learn it if someone thinks it would be a good idea to write a JIT compiler in Zig  Nim : same as Zig, but (from what I know ?)",0.08784722222222223,c
12gmxpt,,"Features I often like using are : sum types / Rust-like enums and generics  Here are the languages I'm considering and the potential downsides :  C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C++ : not really pleasant to work with for me, and like in C, I don't really like the header system  Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  Zig : am not really familiar with Zig but I'm willing to learn it if someone thinks it would be a good idea to write a JIT compiler in Zig  Nim : same as Zig, but (from what I know ?)",0.08784722222222223,c++
12gmxpt,,"Features I often like using are : sum types / Rust-like enums and generics  Here are the languages I'm considering and the potential downsides :  C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C++ : not really pleasant to work with for me, and like in C, I don't really like the header system  Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  Zig : am not really familiar with Zig but I'm willing to learn it if someone thinks it would be a good idea to write a JIT compiler in Zig  Nim : same as Zig, but (from what I know ?)",0.08784722222222223,rust
12gmxpt,,it seems to have an even smaller community  A popular choice seems to be C++ and honestly the things that are holding me back the most is the verbosity and unpracticality of the headers and the way I know of to do sum types (std::variant).,0.33999999999999997,c++
12gmxpt,,"I'm also really considering C, due to the simplicity and lack of stuff hidden in constructors destructors and others stuff.",-0.030555555555555548,c
12gmxpt,jflb5li,"Writing it in Rust should be fine, though it is by no means obligatory.",0.4166666666666667,rust
12gmxpt,jflf8pe,"Any language that has bindings to libllvm, or that has libraries that emit llvm IR, combined with llvm's `ORC` JIT compiler: https://llvm.org/docs/ORCv2.html  If you're looking to roll your own, however, I would suggest Rust, as it has both good support for ""high level"" constructs (such as algebraic data types) and good support for more systems-level matters such as linking.",0.37999999999999995,rust
12gmxpt,jfl0ss9,">Rust : writing a JIT compiler (or a VM for starters) involves a lot of unsafe operations so I'm not sure it would be very advantageous to use Rust  So do all the other options, but at least you can isolate and limit the unsafe bits.",-0.11875,rust
12gmxpt,jfl0ss9,"I'd say Haskell might also be worth considering, at least.",0.0,haskell
12gmxpt,jfmgn1n,As someone who writes a lot of Rust; the safety aspect of Rust is only one small bit.,-0.125,rust
12gmxpt,jfmgn1n,You'll still get access to lots of libraries and the Rust language (which does a lot).,0.0,rust
12gmxpt,jfmgn1n,"If you wanted reasons to favour some over others; I'd go for Rust, followed up by C++.",0.0,go
12gmxpt,jfmgn1n,"If you wanted reasons to favour some over others; I'd go for Rust, followed up by C++.",0.0,rust
12gmxpt,jfmgn1n,"If you wanted reasons to favour some over others; I'd go for Rust, followed up by C++.",0.0,c++
12gmxpt,jfmgn1n,"Both have the most support for libraries and such to use (although obviously there is a lot for C too), and both would be the most useful to know in the future.",0.21666666666666667,c
12gmxpt,jfmgn1n,"C++ is used heavily in the industry today, and Rust use is growing heavily.",-0.2,c++
12gmxpt,jfmgn1n,"C++ is used heavily in the industry today, and Rust use is growing heavily.",-0.2,rust
12gmxpt,jfmgn1n,C would be my third place choice (for similar reasons).,0.0,c
12gmxpt,jfmgn1n,I'd personally go with Zig over Nim.,0.0,go
12gmxpt,jflk3j2,"The actual ""emit code and be able to call it"" part is particularly well-suited to C and not many other languages, but you could probably enjoy it more with a nice free Pascal.",0.2435185185185185,c
12gmxpt,jflk3j2,"The actual ""emit code and be able to call it"" part is particularly well-suited to C and not many other languages, but you could probably enjoy it more with a nice free Pascal.",0.2435185185185185,pascal
12gmxpt,jflk3j2,"It's a bit less popular for historical reasons, but I find Pascal generally makes it easier to not get lost.",0.12083333333333335,pascal
12gmxpt,jfm6god,"Assembly, X64 or ARM.",0.0,assembly
12gmxpt,jfm6pk7,"If you're having trouble with Rust, I'd advise giving D a try.",-0.2,rust
12gmxpt,jfm6pk7,"If you're having trouble with Rust, I'd advise giving D a try.",-0.2,d
12gmxpt,jfm6pk7,"You also get interop with [inline Assembly](https://dlang.org/spec/iasm.html) and [C](https://dlang.org/spec/importc.html), and [CTFE](https://dlang.org/spec/function.html#interpretation), for free.",0.4,assembly
12gmxpt,jfm6pk7,"You also get interop with [inline Assembly](https://dlang.org/spec/iasm.html) and [C](https://dlang.org/spec/importc.html), and [CTFE](https://dlang.org/spec/function.html#interpretation), for free.",0.4,c
12gmxpt,jfm6pk7,"You can manually write FFIs with [C++](https://dlang.org/spec/cpp_interface.html) too, including supporting inheritance.",0.25,c++
12gmxpt,jfm6pk7,> C++ [...] sum types (std::variant).,0.0,c++
12gmxpt,jfoeapz,I'm giving my vote to Rust.,0.0,rust
12gmxpt,jfoeapz,"The ""Haskell-lite"" type system and pattern matching are really handy for all things langdev, and at the same time it has all the bit-banging pointer-twiddling abilities that C and C++ have.",0.3,c
12gmxpt,jfoeapz,"The ""Haskell-lite"" type system and pattern matching are really handy for all things langdev, and at the same time it has all the bit-banging pointer-twiddling abilities that C and C++ have.",0.3,c++
12gmxpt,jflgxfd,Rust is probably the nicest language for writing compilers that exists right now.,0.2857142857142857,rust
12gmxpt,jflte57,"Rust seems like a reasonable choice, since you know it.",0.2,rust
12gmxpt,jflgpkn,"> C : lacks generics and sum types are kind of hard to do with unions, I don't really like the header system  C supports single-definition generics via the `_Generic` mechanism.",0.12708333333333333,c
12gmxpt,jflybpa,"Rust is probably the nicest out of these for the compiler on its own, an ML or Haskell might be even better.",0.55,rust
12gmxpt,jflybpa,"Rust is probably the nicest out of these for the compiler on its own, an ML or Haskell might be even better.",0.55,haskell
12gmxpt,jflybpa,"If you don't want to deal with all of Rust's safety guarantees, Zig, while quite small and quickly developing, is probably your best option.",0.3611111111111111,rust
12gmxpt,jfm1128,Why not rust +LLVM?,0.0,rust
12gmxpt,jfmat31,The ruby JIT compiler is written in C and there is one written in Rust.,0.0,ruby
12gmxpt,jfmat31,The ruby JIT compiler is written in C and there is one written in Rust.,0.0,c
12gmxpt,jfmat31,The ruby JIT compiler is written in C and there is one written in Rust.,0.0,rust
12gmxpt,jfmat31,One is also written in ruby itself.,0.0,ruby
12gmxpt,jfmctwc,Otherwise probably rust.,0.0,rust
12gmxpt,jfnbm2l,https://gist.github.com/martinjacobd/3ee56f3c7b7ce621034ec3ecbc8e13f1  I wrote the beginnings of an assembler and a compiler  https://replit.com/@Chronological/Assembler#main.py  https://replit.com/@Chronological/Compiler3#main.py  In python of all languages.,0.0,python
12gmxpt,jfnwp5m,Crystal lang?,0.0,crystal
12gmxpt,jfl3bo9,After major frustrations with compiling llvm with c++ i used llvmlite on python.,0.0625,c++
12gmxpt,jfl3bo9,After major frustrations with compiling llvm with c++ i used llvmlite on python.,0.0625,python
12gmxpt,jfl3bo9,"It has the same drawbacks and bonuses as any python project, so it might not be suitable for your demands.",0.275,python
12gmxpt,jfl9k3r,"C: lacking basic amenities and the idiotic header files  C++: an insanely complex mound of flaws, and also idiotic header files combined with templates for snail compilation speeds  Rust: straitjacket language that dictates how you can or cannot structure your data.",-0.4083333333333333,c
12gmxpt,jfl9k3r,"C: lacking basic amenities and the idiotic header files  C++: an insanely complex mound of flaws, and also idiotic header files combined with templates for snail compilation speeds  Rust: straitjacket language that dictates how you can or cannot structure your data.",-0.4083333333333333,c++
12gmxpt,jfl9k3r,"C: lacking basic amenities and the idiotic header files  C++: an insanely complex mound of flaws, and also idiotic header files combined with templates for snail compilation speeds  Rust: straitjacket language that dictates how you can or cannot structure your data.",-0.4083333333333333,rust
12gmxpt,jfl9k3r,"Tried it several times, don't want to touch it again  Zig: too new and unstable, buggy  Nim: buggy and has too many memory models, incoherent  D: has crappy garbage collector  Ada: nobody uses it and when I installed Gnat IDE it couldn't even build hello world  Vala: nice and compiles to C, but nobody uses it  Personally, I chose C and it's... palatable.",0.1727272727272727,d
12gmxpt,jfl9k3r,"Tried it several times, don't want to touch it again  Zig: too new and unstable, buggy  Nim: buggy and has too many memory models, incoherent  D: has crappy garbage collector  Ada: nobody uses it and when I installed Gnat IDE it couldn't even build hello world  Vala: nice and compiles to C, but nobody uses it  Personally, I chose C and it's... palatable.",0.1727272727272727,ada
12gmxpt,jfl9k3r,"Tried it several times, don't want to touch it again  Zig: too new and unstable, buggy  Nim: buggy and has too many memory models, incoherent  D: has crappy garbage collector  Ada: nobody uses it and when I installed Gnat IDE it couldn't even build hello world  Vala: nice and compiles to C, but nobody uses it  Personally, I chose C and it's... palatable.",0.1727272727272727,c
12gmxpt,jfmnw5l,"Try Julia, it’s extremely productive!",-0.15625,julia
12gmxpt,jfmnw5l,"The differentiable programming community for Julia is amazingly capable and you could absolutely tie into that and further, the broadcasting syntax and ability to write basically pythonic code and compile it like C is a game changer cuz you can implement crazy stuff without the separation front end vs backend.",-0.12,julia
12gmxpt,jfmnw5l,"The differentiable programming community for Julia is amazingly capable and you could absolutely tie into that and further, the broadcasting syntax and ability to write basically pythonic code and compile it like C is a game changer cuz you can implement crazy stuff without the separation front end vs backend.",-0.12,c
12gmxpt,jfmnw5l,I really like the einsum package for Julia because it lets you make badass array code with one liner stencils,0.2,julia
12gmxpt,jflbizw,I think for writing compilers Haskell deserves to make the list.,0.0,haskell
12gmxpt,jfl7a1q,"The first choice may be Java or Scala, due JIT been crossplatform.",0.0625,java
12gmxpt,jfl7a1q,"The first choice may be Java or Scala, due JIT been crossplatform.",0.0625,scala
12gmxpt,jfl7a1q,"**  I considered once making my own JVM custom P.L., lile adding Delphi / C# real properties to a Java syntax alike P.L.",0.4,delphi
12gmxpt,jfl7a1q,"**  I considered once making my own JVM custom P.L., lile adding Delphi / C# real properties to a Java syntax alike P.L.",0.4,c
12gmxpt,jfl7a1q,"**  I considered once making my own JVM custom P.L., lile adding Delphi / C# real properties to a Java syntax alike P.L.",0.4,java
12gmxpt,jfl7a1q,It's an Open Source Crossplatform updated version of Pascal / Delphi / Mac Object Pascal.,0.0,pascal
12gmxpt,jfl7a1q,It's an Open Source Crossplatform updated version of Pascal / Delphi / Mac Object Pascal.,0.0,delphi
12gmxpt,jfl7a1q,"It would work similar to C++, but it's has better features like a better module system, and not messing with C /  C++ headers, or some of Java and JVM oddities.",0.3333333333333333,c++
12gmxpt,jfl7a1q,"It would work similar to C++, but it's has better features like a better module system, and not messing with C /  C++ headers, or some of Java and JVM oddities.",0.3333333333333333,c
12gmxpt,jfl7a1q,"It would work similar to C++, but it's has better features like a better module system, and not messing with C /  C++ headers, or some of Java and JVM oddities.",0.3333333333333333,java
12gmxpt,jfl7a1q,"I started two internal crossplatform projects with Plain C and C++, and switched to FreePascal plus the Lazarus IDE, for productivity.",-0.10714285714285714,c
12gmxpt,jfl7a1q,"I started two internal crossplatform projects with Plain C and C++, and switched to FreePascal plus the Lazarus IDE, for productivity.",-0.10714285714285714,c++
12gmxpt,jfl7a1q,"Or, as you already mentioned, C++ ...",0.0,c++
12gmxpt,jfln77h,"I started writing a JIT compiler for a forth/lisp-like for x64 windows and linux  (and soon Aarch64 mac) 2 days ago in Rust,   it's going pretty well, but if I knew C++ or Zig I would have chosen them.",0.25,rust
12gmxpt,jfln77h,"I started writing a JIT compiler for a forth/lisp-like for x64 windows and linux  (and soon Aarch64 mac) 2 days ago in Rust,   it's going pretty well, but if I knew C++ or Zig I would have chosen them.",0.25,c++
12gmxpt,jfln77h,Rust provides a lot of safety etc.,0.0,rust
12gmxpt,jfs1qjt,"Delphi, or/and also see LLVM.",0.0,delphi
12gmxpt,jfsxpii,Write in Common Lisp :),0.1,lisp
12gmxpt,jfnsy2k,In some cases you want a completely different control flow to what Rust (or C) offers.,0.05,rust
12gmxpt,jfnsy2k,In some cases you want a completely different control flow to what Rust (or C) offers.,0.05,c
12gmxpt,jfnsy2k,"Oh, and you probably want tail call optimization, which is not guaranteed in Rust.",0.0,rust
12gmxpt,jfnsy2k,These would be a complete PITA if you are using Rust.,0.1,rust
12gmxpt,jfllloi,"I haven't mentioned it in my post, but I plan on adding more things like a garbage collector and other stuff that would require precise memory manipulation (and doesn't play that well into Rust's rules for unsafe code)  That aside, Rust is definitely a strong contender",0.3020833333333333,rust
12gmxpt,jflku5v,I really like Rust but I've tried to write a VM / bytecode interpreter already (somewhat different project) and in lots of places I felt like it was just needlessly painful,-0.16666666666666666,rust
12gmxpt,jfl4os3,"And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) https://zackoverflow.dev/writing/unsafe-rust-vs-zig/",0.275,c
12gmxpt,jfl4os3,"And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) https://zackoverflow.dev/writing/unsafe-rust-vs-zig/",0.275,c++
12gmxpt,jfmhgmt,"(I didn't look into it much haha)  Rust seems to be recommended a lot, so I'm like 70% sure I'll end up using it.",0.35,rust
12gmxpt,jflnhjh,\> particularly well-suited to C  It's true... C doesn't really have much competition in that niche haha  \> Pascal  Variant records seem like a very cool feature !,0.2809027777777777,c
12gmxpt,jflnhjh,\> particularly well-suited to C  It's true... C doesn't really have much competition in that niche haha  \> Pascal  Variant records seem like a very cool feature !,0.2809027777777777,pascal
12gmxpt,jflnhjh,\> particularly well-suited to C  It's true... C doesn't really have much competition in that niche haha  \> Pascal  Variant records seem like a very cool feature !,0.2809027777777777,cool
12gmxpt,jflnhjh,I'm considering learning Pascal now haha  \> All of this suggests JIT is a rather large project.,0.20714285714285713,pascal
12gmxpt,jfmgjwb,A JIT compiler in assembly ?,0.0,assembly
12gmxpt,jfogvus,One more Rust vote then !,0.625,rust
12gmxpt,jfllbjz,"Currently the biggest reason I'd prefer Rust over C is, as you mentioned, the enums + match, as well as the module system which is just much better than C's headers",0.25,rust
12gmxpt,jfllbjz,"Currently the biggest reason I'd prefer Rust over C is, as you mentioned, the enums + match, as well as the module system which is just much better than C's headers",0.25,c
12gmxpt,jflvsa6,"I also know C haha, but yeah I might go with Rust",0.2,c
12gmxpt,jflvsa6,"I also know C haha, but yeah I might go with Rust",0.2,go
12gmxpt,jflvsa6,"I also know C haha, but yeah I might go with Rust",0.2,rust
12gmxpt,jforu97,Knowing when to tell rust to shut up is a crucial part of using the language.,0.0,rust
12gmxpt,jflz358,"Hmm another Rust / Zig vote then  \>  It has powerful metaprogramming, sum types, a stripped down version of pattern matching while still being very low level and clear in what it's doing.",0.0611111111111111,rust
12gmxpt,jg93hb3,"Rust why not, LLVM no because I'm creating my own stuff from scratch",0.6,rust
12gmxpt,jfmhmhb,I linked that same article to someone else in the comments haha  But lots of people seem to recommend Rust.,0.1,rust
12gmxpt,jfoj1uq,"Hmmm interesting suggestion, but Crystal seems to work with a GC with does not make it a great candidate for writing a JIT compiler with a GC",0.65,crystal
12gmxpt,jfohazx,"(As you can see my previous project was in C++ haha)  Maybe there are better ways to do all those things I'm doing, but then I really don't know where to learn about that.",0.18333333333333335,c++
12gmxpt,jfohazx,"In fact, I grew a little tired of trying to look up the best way to do X in C++ every time I did something new just because there is so many ways to do X",0.20977272727272728,c++
12gmxpt,jfl4wim,And creating one from scratch in Python is ...far from being the best idea.,1.0,python
12gmxpt,jflkl9n,I wouldn't call Rust a straightjacket language !,0.0,rust
12gmxpt,jflkl9n,"But I agree that it's probably not the best choice in this case...  C is definitely a strong contender in my opinion, even with all the missing features",0.41111111111111115,c
12gmxpt,jfmdicc,"I think you're missing some FP options :) OCaml is ideal for writing PLs (Rust was originally written in OCaml) and Haskell is basically the same (in capability, not design) except with a larger non-academic community  ETA: Haskell isn't *great* for writing JITs.",0.3392857142857143,rust
12gmxpt,jfmdicc,"I think you're missing some FP options :) OCaml is ideal for writing PLs (Rust was originally written in OCaml) and Haskell is basically the same (in capability, not design) except with a larger non-academic community  ETA: Haskell isn't *great* for writing JITs.",0.3392857142857143,haskell
12gmxpt,jfmdicc,OCaml runs its own JIT though iirc it's written in C,0.6,c
12gmxpt,jfmmu9k,You can use D without a GC.,0.0,d
12gmxpt,jfmpgnr,"Well, I'll take a look at Julia, but from what I know it doesn't seem quite low level enough to create my own JIT compiler in it... Maybe I'm wrong though",0.024999999999999994,julia
12gmxpt,jflmsr3,I'm not sure Haskell would be a great language for writing a JIT compiler (maybe I'll use it for the source -> IL compiler ?),0.275,haskell
12gmxpt,jfl8i8u,"I will take a look at Pascal but I would've obviously preferred a more ""modern"" language haha  \> Java or Scala   I'm afraid those would be too slow for me, and I don't think the JVM has great support for directly manipulating memory",0.11249999999999999,pascal
12gmxpt,jfl8i8u,"I will take a look at Pascal but I would've obviously preferred a more ""modern"" language haha  \> Java or Scala   I'm afraid those would be too slow for me, and I don't think the JVM has great support for directly manipulating memory",0.11249999999999999,java
12gmxpt,jfl8i8u,"I will take a look at Pascal but I would've obviously preferred a more ""modern"" language haha  \> Java or Scala   I'm afraid those would be too slow for me, and I don't think the JVM has great support for directly manipulating memory",0.11249999999999999,scala
12gmxpt,jflnqe1,"But Rust seems like a comfortable choice indeed haha, it's the one I know the best out of all three",0.5333333333333333,rust
12gmxpt,jfml472,I personally struggle with Rust but see it’s pros and just can’t seem to get over it’s cons.,0.0,rust
12gmxpt,jfml472,"D is good, GC *”unfortunately.”*  Zig seems powerful but young and buggy  Odin is also young and has bugs, but I haven’t encountered any issues for game making and simple programs.",0.04285714285714285,d
12gmxpt,jfs8rhv,"I won't use LLVM because the goal is to make my own JIT compiler, not use an existing one  I'll look into Delphi I don't really know anything about it",0.4,delphi
12gmxpt,jfmbia3,"> precise memory manipulation  Rust lets you use lifetimes to precisely model memory, even in unsafe code.",0.4,rust
12gmxpt,jfmbia3,"Rust gives you a lot of tools for encapsulating unsafe code in abstractions which provide safe APIs, with the compiler model checking how you manipulate memory.",0.5,rust
12gmxpt,jflo40l,">And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) [https://zackoverflow.dev/writing/unsafe-rust-vs-zig/](https://zackoverflow.dev/writing/unsafe-rust-vs-zig/)  Depends on what you mean by ""better experience"".",0.184375,c
12gmxpt,jflo40l,">And writing ""unsafe but correct"" code is a much better experience in C or C++ (or even Zig apparently) [https://zackoverflow.dev/writing/unsafe-rust-vs-zig/](https://zackoverflow.dev/writing/unsafe-rust-vs-zig/)  Depends on what you mean by ""better experience"".",0.184375,c++
12gmxpt,jflo40l,In Rust you just run [MIRI](https://github.com/rust-lang/miri) which tells you exactly where you have undefined behavior as long as you have at least one test which exercises the affected code path.,-0.033333333333333326,rust
12gmxpt,jfml45x,It is a mix a little like D.,-0.1875,d
12gmxpt,jflu081,I’ve written a couple interpreters in Free Pascal.,0.4,pascal
12gmxpt,jfmu9w5,"IMO, C is easily the best contender for writing a JIT.",0.7166666666666667,c
12gmxpt,jfmu9w5,"C++ is a close second, since it can use most of the features, but I would probably avoid it, because to use most of its features you would probably end up getting tied into C++'s calling conventions.",0.3333333333333333,c++
12gmxpt,jfmu9w5,Using C can be a bit more powerful when you become familiar with the [GCC extensions](https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions).,0.39166666666666666,c
12gmxpt,jfmu9w5,"Another tool which is handy here is LuaJIT's [DynAsm](https://luajit.org/dynasm.html), which can interleave dynamic assembly into C code.",0.3,assembly
12gmxpt,jfmu9w5,"Another tool which is handy here is LuaJIT's [DynAsm](https://luajit.org/dynasm.html), which can interleave dynamic assembly into C code.",0.3,c
12gmxpt,jfmu9w5,"Although it is ugly, making use of the C preprocessor is useful for writing ""generics"", as you write templated code which essentially emits the monomorphized version of generics, and you can control how to dispatch yourself.",-0.13333333333333333,c
12gmxpt,jfmu9w5,"At some point, you will probably want an FFI in your language to make it useful, and that essentially means interfacing with the C calling convention.",0.15,c
12gmxpt,jfmu9w5,It's easier to do this when your runtime is in C too.,0.0,c
12gmxpt,jfmu9w5,I'm working on a runtime in C but it's not in a state ready to share yet.,0.2,c
12gmxpt,jfmu9w5,A possible option is to implement in another language but have it emit C code.,0.0,c
12gmxpt,jfmhp5n,"Written in assembly, to run assembly.",0.0,assembly
12gmxpt,jfmhp5n,"As they say, if you know assembly, ALL software is open source.",0.0,assembly
12gmxpt,jfn480t,Assembly is not binary.,0.0,assembly
12gmxpt,jflpbtz,There's nothing stopping you from doing that in Rust.,0.0,rust
12gmxpt,jflpbtz,See [rust-gc](https://github.com/Manishearth/rust-gc) for an example of a GC implemented in Rust.,0.0,rust
12gmxpt,jflpbtz,"Another example is [mozjs](https://github.com/servo/mozjs), which is Rust bindings to SpiderMonkey.",0.0,rust
12gmxpt,jflpbtz,"The GC there is implemented in C++, but it shows how you'd structure wrapper types for GC'd pointers in Rust so that you can use them safely, even with all the ""ugliness"" of a browser-grade GC.",0.1,c++
12gmxpt,jflpbtz,"The GC there is implemented in C++, but it shows how you'd structure wrapper types for GC'd pointers in Rust so that you can use them safely, even with all the ""ugliness"" of a browser-grade GC.",0.1,rust
12gmxpt,jfm8izx,Cool!,0.4375,cool
12gmxpt,jfm1en1,"I feel like zig might allow you to develop more quickly and with the amount of tools it comes with for detecting and fixing them, I doubt you'll have a large amount (significantly larger than rust, that is) of hard to track down bugs to deal with.",0.10006613756613753,rust
12gmxpt,jfm1en1,On the other Rust's unsafe story is still pretty work in progress.,0.0625,rust
12gmxpt,jfm1en1,"But, from my understanding you know rust better than zig, so that's some friction.",0.5,rust
12gmxpt,jfo0n2e,I don't know how you cast a byte buffer that you compiled in rust to a function to call.,0.0,rust
12gmxpt,jfo0n2e,In that C code in the first link it is straightforward.,0.3125,c
12gmxpt,jfog4an,"Julia itself is already a JIT build&run system, it has native support of AST generation/translation/compilation, you do LISP style homoiconic  AST manipulations, the running process will convert your AST to LLVM IR and compile to runnable machine code for you to call immediately.",0.0,julia
12gmxpt,jfog4an,"Julia itself is already a JIT build&run system, it has native support of AST generation/translation/compilation, you do LISP style homoiconic  AST manipulations, the running process will convert your AST to LLVM IR and compile to runnable machine code for you to call immediately.",0.0,lisp
12gmxpt,jfog4an,"It has ""open"" sum type, you can add more data constructors and/or subtypes on the go, but that also means no one is checking totality for you.",0.25,go
12gmxpt,jfog4an,Also Julia is itself already GCed.,0.0,julia
12gmxpt,jflg2u5,what you just said  Java has a foreign memory API now which includes replacements for sun.misc.Unsafe which was historically used for manual memory manipulation outside the JVM.,-0.041666666666666664,java
12gmxpt,jflg2u5,It also includes a foreign function API that is meant to let you be able to call other native libraries directly from Java code.,0.0875,java
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,c
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,c++
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,python
12gmxpt,jflg2u5,"That also lets you call other languages like C, C++, Python, Ruby, etc all from one place as well.",-0.125,ruby
12gmxpt,jfljsd8,"Pascal ""been not modern or obsolete"" is just a tag applied by other P.L.",-0.1125,pascal
12gmxpt,jfljsd8,"Unless you prefer C++, or even Rust.",0.0,c++
12gmxpt,jfljsd8,"Unless you prefer C++, or even Rust.",0.0,rust
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,c++
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,pascal
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,delphi
12gmxpt,jfljsd8,"that supports both simple types and Object and Class Orientation like C++ and Object Pascal ( Delphi, Mac Pascal, FreePascal, Lazarus), or even Java !",0.0,java
12gmxpt,jfljsd8,"Are you considering ""modern hyped"" Haskell or Python ?",0.2,haskell
12gmxpt,jfljsd8,"Are you considering ""modern hyped"" Haskell or Python ?",0.2,python
12gmxpt,jfmmw9h,"The C ABI is a proven means to integrate libraries, and C/C++ is the common choice for the majority of VMs I'm aware of.",-0.024999999999999994,c
12gmxpt,jfmrpsr,I think [Austral](https://borretti.me/article/introducing-austral) too will be a strong contender against these (esp Rust) in a few years.,0.11666666666666664,rust
12gmxpt,jfmrpsr,"IMO, it has a better type system and borrowing approach than Rust, but is still at a very early stage and not production ready.",0.27666666666666667,rust
12gmxpt,jfmi230,"I think the longer you keep something a reference, the more dangerous it is, because of Rust's aliasing rules (aka cannot have 2 mutable refs to the same region in memory).",-0.033333333333333326,rust
12gmxpt,jfmi230,"Maybe I'm wrong though, I didn't look that much into unsafe Rust.",-0.15,rust
12gmxpt,jfmoq3s,"I've heard about D as well, I'll take a look !",0.0,d
12gmxpt,jfmiime,"\> if you know assembly, ALL software is open source.",0.0,assembly
12gmxpt,jfos7h5,"Assembly _is_ binary, but it's not binary machine code.",0.0,assembly
12gmxpt,jflvpnf,"Nothing is stopping me from implementing a GC in Rust, you're right, I'm just wondering if it's really the best choice for those kinds of things",0.49523809523809526,rust
12gmxpt,jfmd5h3,> Rust's unsafe story is still pretty work in progress  Care to elaborate?,0.375,rust
12gmxpt,jfoitdo,That's not really the hard part in Rust either,-0.19583333333333336,rust
12gmxpt,jfljb7n,"I'm not planning on outperforming python JITs, I'm just saying I don't think I should write a JIT compiler in python.",0.0,python
12gmxpt,jfljb7n,So I won't use python to write my JIT compiler because I don't think I'll get good enough performance or would even be able to manipulate memory in a suitable way for a JIT compiler  I won't use some already existing python JIT because my goal is to write my own,0.47000000000000003,python
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,java
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,c
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,c++
12gmxpt,jflk6cl,"\> Not suggesting you use it   I understand but I'll reply as if you were if you don't mind  I'm sure direct memory manipulation is possible in Java, I just don't think it would be more convenient than in C, C++ or Rust.",0.275,rust
12gmxpt,jflis1i,Yes I had look to that ( Java interaction with outer platforms ).,0.0,java
12gmxpt,jflmhq4,"I could probably use their JIT compiler through reflection, but it's not what I'm looking for, I'm looking to create my own  \> Unless you prefer C++, or even Rust.",0.6,c++
12gmxpt,jflmhq4,"I could probably use their JIT compiler through reflection, but it's not what I'm looking for, I'm looking to create my own  \> Unless you prefer C++, or even Rust.",0.6,rust
12gmxpt,jflmhq4,"Out of all the languages I listed, I'm really considering C and Rust.",0.2,c
12gmxpt,jflmhq4,"Out of all the languages I listed, I'm really considering C and Rust.",0.2,rust
12gmxpt,jflmhq4,I wouldn't use Haskell or Python either for a JIT compiler...,0.0,haskell
12gmxpt,jflmhq4,I wouldn't use Haskell or Python either for a JIT compiler...,0.0,python
12gmxpt,jflmhq4,"I'm looking for a low level language that's nicer to use than C or C++, and would better fit my use case than Rust.",0.3,c
12gmxpt,jflmhq4,"I'm looking for a low level language that's nicer to use than C or C++, and would better fit my use case than Rust.",0.3,c++
12gmxpt,jflmhq4,"I'm looking for a low level language that's nicer to use than C or C++, and would better fit my use case than Rust.",0.3,rust
12gmxpt,jfmpr6u,"Well, thing is, most ""low level"" languages support the C ABI, so I still have a wide selection of languages to choose from.",0.13333333333333333,c
12gmxpt,jfmpr6u,Thinking of Rust and Zig.,0.0,rust
12gmxpt,jfmkwae,"> I think the longer you keep something a reference, the more dangerous it is, because of Rust's aliasing rules  Lifetimes are there to ensure your references don't last longer than they should.",-0.033333333333333326,rust
12gmxpt,jfpksdn,"Just for clarity, its RPython not Python.",0.0,python
12gmxpt,jfpksdn,Its  a subset of python that is transcompiled to C and the compiler can automagically inserts a JIT compiler to your code.,0.0,python
12gmxpt,jfpksdn,Its  a subset of python that is transcompiled to C and the compiler can automagically inserts a JIT compiler to your code.,0.0,c
12gmxpt,jj1b69y,"Well, Julia JIT compiles all your stuff, so you’d be able to use that as the scaffold and customize with macros and stuff.",0.5,julia
12gmxpt,jj1b69y,"Well, Julia JIT compiles all your stuff, so you’d be able to use that as the scaffold and customize with macros and stuff.",0.5,d
12gmxpt,jj1b69y,But yeah maybe Python needs a JIT.,0.0,python
12gmxpt,jj1b69y,Julia IS a JIT haha.,0.2,julia
12gmxpt,jj1b69y,"I also got great results from making a Python graph class which can do a legit topological sort function on its data as a method and return a functional tf.keras.Model, if you’re doing linear algebra JIT compilation then that is a nice way to have something adjacent to the py data stack.",0.7,python
12gmxpt,jj1b69y,"Maybe the best answer for your use case is to do it the hard way in rust, there are some interesting parser combinator crates or you could try to define a grammar and use something that can build a parser from that.",0.40277777777777773,rust
12gmxpt,jj1b69y,"Hasura is a good compiler, but Haskell is pretty intense lol",0.4875,haskell
12gmxpt,jfpop8b,"Yes but :> I won't use some already existing python JIT because my goal is to write my own  So in any case, it's not the right language to write a JIT and a GC in",0.4619047619047619,python
12gmxpt,jfmpadf,"I personally don't think I'll generate complete executables from my IL, because I want to add a lot of reflection features into my language, and have it be able to change its IL at runtime then ask for recompilation (a bit like C# and the CIL)",0.19999999999999998,c
12gmxpt,jj3s4w7,"In that case, you might be better off sucking it up and writing it in rust to jit compile for Python, since Python does need a speed up, it would benefit a lot potentially.",0.25,rust
12gmxpt,jj3s4w7,"In that case, you might be better off sucking it up and writing it in rust to jit compile for Python, since Python does need a speed up, it would benefit a lot potentially.",0.25,python
12gmxpt,jj3s4w7,"So a more generalized jit would be useful for Python developers for sure, especially if it could handle a wider variety of input terminal data types and function primitives than the current most popular Python JIT options (which you could benchmark your novel solution against to make a great clickbait blog post): numba, jax, tf.keras.Model.compile I think, I believe pytorch may have a jit, also PyPy is really good too, but it’s not a decorator for one function, it compiles your whole script.",0.41000000000000003,python
12gmxpt,jj3s4w7,"The cpython team is also working on multiple ways to speed up Python which would be worth looking at but the Python version release schedule is pretty slow, 1x per year in October.",0.0625,python
12gmxpt,jj3s4w7,"Finally, make sure to check out Codon, which came out this year as another allegedly super performant Python compiler.",0.27777777777777773,python
12gmxpt,jj3s4w7,Let me know if Python wasn’t the language you wanted to compile and maybe we can think about the other language if there’s a different one to compile.,-0.0625,python
12gmxpt,jjcul2a,I recommend Rust because it’s low level and focused on correctness and performance,0.0,rust
12g5ekt,jfmo55k,"some C ""tricks"" like using the for statement as a quick hack to have something execute after every iteration instead of putting it at the end of a while is a bit annoying but fine.",-0.01666666666666668,c
12g5ekt,jfj3uys,Pretty cool!,0.34375,cool
12g5ekt,jfjlcj0,"Any FFI code intended to be linked with my VM must be recompiled using my `malloc`, as this is the only way I can ensure the C code does not interfere with the way I allocate memory.",0.0,c
12fkfij,jfgf82r,It leads to a lot of cool design decisions.,0.35,cool
12fkfij,jfi1ti6,"I’m not your parent and I’m not going to interpret them (even though I believe I understood and like the idea), but I’d just like to say that “Implementing Functional Languages: A Tutorial” by David R. Lester and SPJ (and it’s longer predecessor) are great resources on the topic.",0.8,d
12fkfij,jfi1ti6,"In a world where even purist functional programming communities are being taken over by the likes of Rust (which I like, tbc) and others, having the courage to publish something theoretically clean and satisfying without worrying about the semantics of reading from padding between struct fields feels refreshing.",0.45555555555555555,rust
12fg0l6,jfflo17,"Not literally a null value, however I think Option/Maybe types and their accompanying monads in languages like Haskell and F# do basically this.",0.0,haskell
12fg0l6,jffwkk2,"Generic functions in Common Lisp dispatch on all the (required) arguments, so one can add methods that dispatch if a parameter is nil (the CL null value.)",-0.15,lisp
12fg0l6,jfgoiyk,Objective-C allows sending any message (== calling a method) to a nil pointer.,0.0,objective-c
12fg0l6,jfgvhf4,"The funny story is that someone accused me of taking ideas from Ceylon, which I had never even looked at, so I then took the time to go look at Ceylon, and I really liked some of the things I saw there.",0.425,go
12fg0l6,jfgvhf4,"For example:  ``` // this never asserts if a==Null or if foo() returns True assert a?.foo(); ```  A statement expression also grounds, so for example:  ``` // do NOT call foo if either a or c are Null foo(a?, b, c?.d); ```  And of course you can always have the explicit ""else"" expression to do the grounding:  ``` String s = foo(a?, b, c?.d) : """"; ```",0.35,c
12fg0l6,jfgi03i,Many languages like Haskell or Rust enable your functions to return a monadic value `Option<X>` with thus being either `X` or `None`.,0.5,haskell
12fg0l6,jfgi03i,Many languages like Haskell or Rust enable your functions to return a monadic value `Option<X>` with thus being either `X` or `None`.,0.5,rust
12fg0l6,jfih0qx,"If someone understands what's meant by ""Applicative functors are the programming equivalent of lax monoidal functors with tensorial strength in category theory"" and they think that's something they need --- then they'll be delighted to learn that Haskell already exists.",0.55,haskell
12fg0l6,jfjm1w1,"One way is to define the following:  1. a way to convert a value into an optional value (in Haskell this is called `pure` or `return`) 2. a way to apply an optional function to an optional argument to product an optional result (in Haskell this is the `<*>` operator)  Instead of (2), you could (equivalently) define a way to apply a function of two arguments to two optional arguments to produce an optional result.",0.10714285714285714,haskell
12fg0l6,jfjm1w1,"Haskell calls this `liftA2`, but I'm sure you can come up with a better name.",0.5,haskell
12fg0l6,jfjm1w1,"For example, in Haskell, the `pure`/`return`/`liftA2` functions and the `<*>` operator work for any applicative functor, not just the optional type (which Haskell calls `Maybe`).",0.4,haskell
12fg0l6,jfjm1w1,"A common and good way to achieve this is what Rust calls ""traits"" and what Haskell calls ""type classes"".",0.19999999999999998,rust
12fg0l6,jfjm1w1,"A common and good way to achieve this is what Rust calls ""traits"" and what Haskell calls ""type classes"".",0.19999999999999998,haskell
12fg0l6,jfljqq3,"If this seems faintly shocking to you, then this is because you're thinking of the sorts of use-cases for FPLs for which one uses Haskell and ML.",-1.0,haskell
12fg0l6,jfljqq3,"I'm thinking of the use-cases which are presently addressed by PHP, SQL, Python, and Microsoft Excel.",0.0,php
12fg0l6,jfljqq3,"I'm thinking of the use-cases which are presently addressed by PHP, SQL, Python, and Microsoft Excel.",0.0,python
12ex1yj,jff6a0f,"This is essentially a recursive pointer structure, so it'll let you see how Jank compares to Clojure in that regard as well (also, you get another pretty picture).",0.125,clojure
12ev4cm,jfd58ss,"are all methods: instead of `if a then b else c` you have `a ifTrue:[ b ] ifFalse:[ c ]` (brackets denote a ""code block"" AKA closure).",-0.75,c
12ev4cm,jfd58ss,"But it's also very cool, and some of the things it enables are very useful.",0.4225,cool
12ev4cm,jfdurj4,"Many other dynamic languages, especially Ruby, are close to Smalltalk in terms of 'purity'.",0.09375,ruby
12ev4cm,jfdurj4,"Go was [inspired by Smalltalk](https://go.dev/talks/2015/gophercon-goevolution.slide#19) in its interface system - designer Rob Griesemer had worked on [Strongtalk](http://strongtalk.org/history.html), which added an F-bounded polymorphism type system to Smalltalk and was ultimately eaten by Java to become HotSpot.",0.0,go
12ev4cm,jfdurj4,"Go was [inspired by Smalltalk](https://go.dev/talks/2015/gophercon-goevolution.slide#19) in its interface system - designer Rob Griesemer had worked on [Strongtalk](http://strongtalk.org/history.html), which added an F-bounded polymorphism type system to Smalltalk and was ultimately eaten by Java to become HotSpot.",0.0,java
12ev4cm,jfdurj4,"Common Lisp has a multiple-inheritance, multiple-dispatch system that is less pure but still incredibly powerful, especially with its metaobject protocol.",0.009523809523809523,lisp
12ev4cm,jfdurj4,Javascript and Self have prototype-based systems which are awkward to program in but can simulate a Smalltalk-style class system pretty well (I go into this more [in this post](https://rileystew.art/posts/fromprototypestoclasses)).,0.05000000000000001,javascript
12ev4cm,jfdurj4,Javascript and Self have prototype-based systems which are awkward to program in but can simulate a Smalltalk-style class system pretty well (I go into this more [in this post](https://rileystew.art/posts/fromprototypestoclasses)).,0.05000000000000001,go
12ev4cm,jfdurj4,"Most programmers kneejerk reaction to it is based on their encounters with Java and C++ in braindead college courses, blogposts, or whatever, that starts out by defining it in terms of data and procedures, or polymorphism, inheritance, and encapsulation (remember: the pie is a lie!).",0.625,java
12ev4cm,jfdurj4,"Most programmers kneejerk reaction to it is based on their encounters with Java and C++ in braindead college courses, blogposts, or whatever, that starts out by defining it in terms of data and procedures, or polymorphism, inheritance, and encapsulation (remember: the pie is a lie!).",0.625,c++
12ev4cm,jfdx4tr,"Arguably this is proper Java style with getters/setters, but it's easy to accidentally circumvent, and requires much typing to achieve (or Lombok).",0.2111111111111111,java
12ev4cm,jfded84,"For example, in Java, booleans are byte-sized and are defined as 0 and 1 behind the scenes.",-0.4,java
12ev4cm,jfded84,"It's all done through various trickery like that; in a way, it's akin to how many versions of Lisp are defined within themselves.",0.25,lisp
12ev4cm,jfded84,"Lastly, the Little Smalltalk is a complete system in a few thousand lines of C, making it very understandable.",-0.017499999999999995,c
12ev4cm,jfdq4b9,"There's a reason why ""let it crash"" systems like Erlang are so incredibly resilient and ""avoid errors at all cost"" systems crash and burn in the face of scaled up distributed concurrency, and it's related to Erlang's *combining* of both views of computing rather than just one, and the underlying reason is directly grounded in the fundamental fork in thinking about ""object orientation"" that happened in the late 1960s and early 1970s.",0.15999999999999998,erlang
12ev4cm,jfd5x3g,Let's talk Java.,0.0,java
12ev4cm,jfd5x3g,"In terms of OOP, the difference is mostly that Java added a lot of complexity and conceptual impurity.",0.5,java
12ev4cm,jfd5x3g,"Some of the simplicity comes from the dynamism - the class/object distinction in Java, to some extent, is a reflection (hah) of a static/dynamic distinction, or of compile-time/run-time distinction, but no such thing exists in Smalltalk, so classes are objects and reflection is ""built-in"".",0.0,java
12ev4cm,jfd5x3g,Some of the simplicity comes from having a static type system: things like interfaces and generics and overloading go away in Smalltalk.,0.5,go
12ev4cm,jfd5x3g,"Because they're all dynamic, Smalltalk's OOP model really isn't very far off from Python or Ruby (especially Ruby), which pretty much just split the difference between Smalltalk-y internals with a Java-like candy coating, mostly owing to Java's popularity.",0.18000000000000002,python
12ev4cm,jfd5x3g,"Because they're all dynamic, Smalltalk's OOP model really isn't very far off from Python or Ruby (especially Ruby), which pretty much just split the difference between Smalltalk-y internals with a Java-like candy coating, mostly owing to Java's popularity.",0.18000000000000002,ruby
12ev4cm,jfd5x3g,"Because they're all dynamic, Smalltalk's OOP model really isn't very far off from Python or Ruby (especially Ruby), which pretty much just split the difference between Smalltalk-y internals with a Java-like candy coating, mostly owing to Java's popularity.",0.18000000000000002,java
12ev4cm,jfcua37,"In Java for example, not everything is an object.",0.0,java
12ev4cm,jfcua37,"Java has primitive types and their counterpart boxed types (which are objects, or rather classes that can be instantiated to objects).",0.0,java
12ev4cm,jfcua37,"In other OO languages that follow Smalltalk more closely, such as Ruby, everything _is_ an object.",0.125,ruby
12ev4cm,jfdk358,Python and Ruby follow Smalltalk very closely.,0.2,python
12ev4cm,jfdk358,Python and Ruby follow Smalltalk very closely.,0.2,ruby
12ev4cm,jfdk358,"Java, JavaScript, C++ don’t, and aren’t as dynamic.",0.0,java
12ev4cm,jfdk358,"Java, JavaScript, C++ don’t, and aren’t as dynamic.",0.0,javascript
12ev4cm,jfdk358,"Java, JavaScript, C++ don’t, and aren’t as dynamic.",0.0,c++
12ev4cm,jfd7m6w,"The OOP style of Java and C++ stems from Simula, which predates Smalltalk.",0.0,java
12ev4cm,jfd7m6w,"The OOP style of Java and C++ stems from Simula, which predates Smalltalk.",0.0,c++
12ev4cm,jfd10ip,"Whereas in Java, exceptions were always out of place.",0.0,java
12ev4cm,jfga95r,"Comparing Smalltalk and Java also risks getting lost in the static/dynamic divide, which may be interesting in itself but has no bearing on OOP .",0.5,java
12ev4cm,jfga95r,"As the saying goes, you can write FORTRAN code in any language.",0.0,fortran
12ev4cm,jfga95r,"Also, objects are absolutely necessary for lazy evaluation, so Haskell couldn't exist withot being powered by objects.",-0.125,haskell
12ev4cm,jfga95r,Getting back to Java code it can be either OOP or close to FORTRAN (or even FP).,0.0,java
12ev4cm,jfga95r,Getting back to Java code it can be either OOP or close to FORTRAN (or even FP).,0.0,fortran
12ev4cm,jfhmgq0,"In Delphi, object properties are not used as references.",0.0,delphi
12ev4cm,jfd9rlt,"**Classes vs Prototypes**  JavaScript / ECMAScript are ""Object Prototype"" based.",0.0,javascript
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,c++
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,java
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,c
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,pascal
12ev4cm,jfd9rlt,"In the case of C++, Java, C#, Object Pascal (Delphi), I prefer to call them ""Object and Class Oriented Programming"", since they require you to define a class, their methods, fields, and properties, first, at compiler time.",0.25,delphi
12ev4cm,jfd9rlt,"In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,c
12ev4cm,jfd9rlt,"In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,delphi
12ev4cm,jfd9rlt,"In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,pascal
12ev4cm,jfd9rlt,"P.  Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,java
12ev4cm,jfd9rlt,"P.  Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,c++
12ev4cm,jfd9rlt,"Java and C++ comites keep avoiding them, while adding a lot of other ""fancy"" features, some of then unnecessary.",-0.2625,java
12ev4cm,jfd9rlt,"Java and C++ comites keep avoiding them, while adding a lot of other ""fancy"" features, some of then unnecessary.",-0.2625,c++
12ev4cm,jfd9rlt,"version of PHP have each one, also a unusual way to support properties.",0.2,php
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,java
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,c++
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,c
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,delphi
12ev4cm,jfd9rlt,"**Class Inheritance**  Java, C++, C#, Delphi, PHP support the notion of inheritance, allowing a class to extend or change existing features of other classes, without having to declare an entire new class.",0.0037878787878787845,php
12ev4cm,jfd9rlt,"**Message Passing vs Methods**  MacOS Objective -C is similar to C, but not like C++, supporting objects with a different syntax.",0.0625,c
12ev4cm,jfd9rlt,"**Message Passing vs Methods**  MacOS Objective -C is similar to C, but not like C++, supporting objects with a different syntax.",0.0625,c++
12ev4cm,jfd9rlt,"In C++, operations are perform thru local functions A.K.A.",0.0,c++
12ev4cm,jfd9rlt,"(s) took this concept also like Java, C#, Delphi.",0.0,java
12ev4cm,jfd9rlt,"(s) took this concept also like Java, C#, Delphi.",0.0,c
12ev4cm,jfd9rlt,"(s) took this concept also like Java, C#, Delphi.",0.0,delphi
12ev4cm,jfd9rlt,"But, in Java all methods are virtual, but their syntax is misleading.",0.0,java
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,c
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,delphi
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,c++
12ev4cm,jfd9rlt,"C# and Delphi, support both non replaceable methods and replaceable ""virtual"" methods and in both cases the syntax is better than C++ and Java.",0.5,java
12ev4cm,jfd9rlt,There was a version of Object Pascal that did supported message passing.,0.0,pascal
12ev4cm,jfd9rlt,"Personally, Object Pascal (Delphi) is my preferred style and syntax.",0.0,pascal
12ev4cm,jfd9rlt,"Personally, Object Pascal (Delphi) is my preferred style and syntax.",0.0,delphi
12ev4cm,jfd9rlt,"C#, Java and Delphi added them later.",0.0,c
12ev4cm,jfd9rlt,"C#, Java and Delphi added them later.",0.0,java
12ev4cm,jfd9rlt,"C#, Java and Delphi added them later.",0.0,delphi
12ev4cm,jfd9rlt,"(s) like Java, a class can be used by itself as if it was an single existing object by itself that doesn't requires to be created or destroyed.",-0.07142857142857142,java
12ev4cm,jfd9rlt,C# and Delphi added them in later versions.,0.0,c
12ev4cm,jfd9rlt,C# and Delphi added them in later versions.,0.0,delphi
12ev4cm,jfd9rlt,It was originally conceived in a version of Pascal called Modula in response to the Plain C feature of including files.,0.08035714285714286,pascal
12ev4cm,jfd9rlt,It was originally conceived in a version of Pascal called Modula in response to the Plain C feature of including files.,0.08035714285714286,c
12ev4cm,jfd9rlt,"C++ have a very simple version where you can group classes, types and functions in groups of code called ""namespaces"".",0.0,c++
12ev4cm,jfd9rlt,Java expanded those namespaces modules to be hierarchical instead of been as a single list.,-0.07142857142857142,java
12ev4cm,jfd9rlt,"like Modular, Oberon and Ada had a more powerful but complex use of modules.",0.16666666666666666,ada
12ev4cm,jfd9rlt,"(s), a module could also had a special Initialization function and a special finalization function similar to Constructors and destructors in objects   Delphi (Free Pascal) supports this.",0.2785714285714286,delphi
12ev4cm,jfd9rlt,"(s), a module could also had a special Initialization function and a special finalization function similar to Constructors and destructors in objects   Delphi (Free Pascal) supports this.",0.2785714285714286,pascal
12ev4cm,jfd9rlt,"In Java besides namespaces, static Classes are used as modules as well, using static methods and fields to emulate the initialization and finalization and global variables that a namespace doesn't support   Just my two cryptocurrency coins contribution.",0.3333333333333333,java
12ev4cm,jfd0mgf,"C++, Java and their successors dropped this constraint, making objects imperative and mutable, which kinda defeats the purpose in most cases.",0.5,c++
12ev4cm,jfd0mgf,"C++, Java and their successors dropped this constraint, making objects imperative and mutable, which kinda defeats the purpose in most cases.",0.5,java
12ev4cm,jfes4h6,Doesn’t seem too different than Python.,0.0,python
12ev4cm,jfes4h6,Python doesn’t reduce if..else to methods but seems like everything else is doable?,0.0,python
12ev4cm,jfffmt6,"The wording *method call* is barely distinguishable (to students at least) from *function call*; it suggests and early binding scheme, where the caller alone decides what code will run.",-0.049999999999999996,scheme
12ev4cm,jfdb4cy,"Python and Ruby are both older than Java, I believe.",0.16666666666666666,python
12ev4cm,jfdb4cy,"Python and Ruby are both older than Java, I believe.",0.16666666666666666,ruby
12ev4cm,jfdb4cy,"Python and Ruby are both older than Java, I believe.",0.16666666666666666,java
12ev4cm,jffi6gc,"In Smalltalk, Ruby, Python you get a runtime exception, you can catch it or do reflection etc.",0.0,ruby
12ev4cm,jffi6gc,"In Smalltalk, Ruby, Python you get a runtime exception, you can catch it or do reflection etc.",0.0,python
12ev4cm,jffi6gc,In Python and Ruby you get a stack trace (or you're using Rails and you get ActiveBlackMagic behavior).,0.0,python
12ev4cm,jffi6gc,In Python and Ruby you get a stack trace (or you're using Rails and you get ActiveBlackMagic behavior).,0.0,ruby
12ev4cm,jffi6gc,In Java that does doesn't compile.,0.0,java
12ev4cm,jffi6gc,"So you'll go define or extend some interface, define a no-op method or something, and you'll try again.",0.0,go
12ev4cm,jfdr2x9,In what way is JavaScript not late bound?,0.15,javascript
12ev4cm,jffjjek,"> but Smalltalk actually had messages  That's true for Smalltalk-72, but Stmalltalk-76 onwards had polymorphism with compiled methods and dispatch based on lookup tables quite similar to Simula-67 (the ancestor of C++ and Java).",0.11666666666666665,c++
12ev4cm,jffjjek,"> but Smalltalk actually had messages  That's true for Smalltalk-72, but Stmalltalk-76 onwards had polymorphism with compiled methods and dispatch based on lookup tables quite similar to Simula-67 (the ancestor of C++ and Java).",0.11666666666666665,java
12ev4cm,jffqwy2,You're using messages in the Smalltalk sense as soon as you use interfaces in Java.,0.0,java
12ev4cm,jffswrf,">In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,c
12ev4cm,jffswrf,">In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,delphi
12ev4cm,jffswrf,">In C# and Delphi (Object Pascal), you can declare both fields and properties.",0.0,pascal
12ev4cm,jffswrf,">Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,java
12ev4cm,jffswrf,">Java and C++, properties doesn't really exist, there's a trick using functions to emulate them.",0.2,c++
12ev4cm,jffswrf,"(s) like Java, a class can be used by itself as if it was an single existing object by itself that doesn't requires to be created or destroyed.",-0.07142857142857142,java
12ev4cm,jffswrf,Java classes and static methods are modules with scoped functions (that's what \*static\* means).,0.5,java
12ev4cm,jfghbp4,"* People go on and on about Lisp machines, but they don’t have anything on Smalltalk.",0.0,go
12ev4cm,jfghbp4,"* People go on and on about Lisp machines, but they don’t have anything on Smalltalk.",0.0,lisp
12ev4cm,jfghbp4,"Once you get used to having the ability to introspect everything, and the amazing Morphic UI it’s just hard to go back to a regular computing environment.",0.07708333333333335,go
12ev4cm,jfghbp4,It’s like the Common Lisp condition system *but better.,0.1,lisp
12ev4cm,jff8fna,"Since ST historically operates not in terms of files, but in terms of ""images"" which are effectively just a dump of all the objects in the system, it allows for a much deeper level of control over the environment which languages like python, ruby, &c don't necessarily give you.",0.2,python
12ev4cm,jff8fna,"Since ST historically operates not in terms of files, but in terms of ""images"" which are effectively just a dump of all the objects in the system, it allows for a much deeper level of control over the environment which languages like python, ruby, &c don't necessarily give you.",0.2,ruby
12ev4cm,jff8fna,"Since ST historically operates not in terms of files, but in terms of ""images"" which are effectively just a dump of all the objects in the system, it allows for a much deeper level of control over the environment which languages like python, ruby, &c don't necessarily give you.",0.2,c
12ev4cm,jffcdr5,"Yeah, on principle, languages like Python and Ruby are much closer to Smalltalk than Java (even though the Hotspot JVM was historically derived from a Smalltalk VM).",0.1,python
12ev4cm,jffcdr5,"Yeah, on principle, languages like Python and Ruby are much closer to Smalltalk than Java (even though the Hotspot JVM was historically derived from a Smalltalk VM).",0.1,ruby
12ev4cm,jffcdr5,"Yeah, on principle, languages like Python and Ruby are much closer to Smalltalk than Java (even though the Hotspot JVM was historically derived from a Smalltalk VM).",0.1,java
12ev4cm,jffcdr5,"To me, the most practical advantage of those languages over Java in daily programming is that classes are objects or at least first-class things, which means that constructors are normal (factory) methods and you don't need factories.",0.0875,java
12ev4cm,jfffxkr,"In a 2019 discussion between three of the biggest names in concurrency in the world, Sir Tony Hoare said, with instant vigorous agreement from Carl Hewitt (creator of the Actor model) and Joe Armstrong (creator of Erlang), the key test of whether a PL has gotten concurrency right is that the same PL can be used to program communicating processes in software or hardware, occurring over arbitrary space and time scales, from less than nanometers to millions of miles (currently, and the scale is set to continuously increase) and less than nanoseconds to decades (and, again, the scale is set to continuously increase).",-0.018452380952380953,erlang
12ev4cm,jfffxkr,"Or they don't, and you break off what you're doing and go inside the house to figure out what's up, or ask your kid, who's in the garden with you, to do so.",0.0,go
12ev4cm,jfme9xj,"> > The wording *method call* is barely distinguishable (to students at least) from *function call*; it suggests an early binding scheme, where the caller alone decides what code will run.",-0.049999999999999996,scheme
12ev4cm,jfh51hl,"In reality, we do everything we can do reduce the cost of these calls across service boundaries; we have designed it to optimize all the way down to a few instructions plus a vtable call in many cases, but it's a dynamic optimization that requires the ability to deopt to a concurrent queue (I think the Erlang designers called is a ""post office box"" or something like that).",0.036111111111111094,erlang
12ev4cm,jfh51hl,"Smalltalk was infamously insecure (it just was not designed to be secure), and its performance is often 10000%+ worse than C/C++/Rust, and 2500%+ worse than C#/Java/Javascript.",-0.225,c
12ev4cm,jffik4u,"Most widely used PLs have libraries that implement it, and a few somewhat integrate a library into the language at some fundamental level, but I think it needs to go all the way, so share your perspective on what's most interesting.",0.24,go
12ev4cm,jffik4u,As I understand it Elixir is the most interesting.,0.5,elixir
12ev4cm,jffik4u,* Scala.,0.0,scala
12ev4cm,jffik4u,"I recall doubting they'd gotten it right when I last looked at where they went with unifying Akka with the PL itself, but that was a long time ago and they've released Scala 3 since then.",0.07857142857142857,scala
12ev4cm,jfehzi8,"Ruby started life in 1993, with first people using it beside Matz in late 1995.",-0.024999999999999994,ruby
12ev4cm,jfehzi8,"Java started as Oak somewhere in 1989, ~~Oracle~~ Sun started the Java Platform project in 1990, and first demos were shown in 1992.",0.25,java
12ev4cm,jfehzi8,Python started life in december 1989.,0.0,python
12ev4cm,jfh69lc,"They were all in the same ""generation"", but Python and Ruby both appeared before Java.",0.0,python
12ev4cm,jfh69lc,"They were all in the same ""generation"", but Python and Ruby both appeared before Java.",0.0,ruby
12ev4cm,jfh69lc,"They were all in the same ""generation"", but Python and Ruby both appeared before Java.",0.0,java
12ev4cm,jfh69lc,"Java somehow got a huge bump from Netscape and the whole ""world wide web"" thing, which no one really understood, and therefore went crazy over (like bitcoin a few decades later).",-0.01428571428571426,java
12ev4cm,jfh69lc,"Ruby took off when DHH released Ruby on Rails, which was a seriously amazing project for its time (but unfortunately, super inefficient).",0.4666666666666667,ruby
12ev4cm,jfh69lc,"Python just kept on chugging along and growing its user base slowly, until it really took off about ten years ago for a couple different reasons, including big data analysis and ML workloads -- thanks to its easy C library integration.",-0.033333333333333354,python
12ev4cm,jfh69lc,"Python just kept on chugging along and growing its user base slowly, until it really took off about ten years ago for a couple different reasons, including big data analysis and ML workloads -- thanks to its easy C library integration.",-0.033333333333333354,c
12ev4cm,jfezmz2,‘employee.name()’ is essentially a function call in JavaScript.,0.0,javascript
12ev4cm,jfgtjad,"> People go on and on about Lisp machines, but they don’t have anything on Smalltalk.",0.0,go
12ev4cm,jfgtjad,"> People go on and on about Lisp machines, but they don’t have anything on Smalltalk.",0.0,lisp
12ev4cm,jffp0u4,I much prefer that kind of special case to Java's primitive types or Python's `len` is a function not a message.,0.38571428571428573,java
12ev4cm,jffp0u4,I much prefer that kind of special case to Java's primitive types or Python's `len` is a function not a message.,0.38571428571428573,python
12ev4cm,jfhoyzs,Just to clarify something for myself and for perhaps OP: the distinction that you're drawing isn't between Smalltalk and say Java.,0.0,java
12ev4cm,jfhoyzs,You're more drawing a distinction between say Erlang and Java.,0.5,erlang
12ev4cm,jfhoyzs,You're more drawing a distinction between say Erlang and Java.,0.5,java
12ev4cm,jfhoyzs,"I think that the ""let it die"" attitude of Erlang does have nice properties w.r.t.",0.6,erlang
12ev4cm,jfhoyzs,"overall system robustness (though only when married with a process supervision system, which Erlang also provides).",0.08333333333333333,erlang
12ev4cm,jfhoyzs,And Erlang doesn't force that.,0.0,erlang
12ev4cm,jfhoyzs,But you wouldn't want to use VHDL to program business applications.,0.0,vhdl
12ev4cm,jfh2z3i,"Thanks, I didn't know that about Erlang, and Pony, and didn't know Inko at all.",0.2,erlang
12ev4cm,jfienjs,There might be some tricks around partial evaluation to get the dynamic case fast though; I recall they managed to optimise out reflection-heavy Ruby code.,0.03333333333333333,ruby
12ev4cm,jfh7p4d,Java had a hugely funded marketing campaign.,0.4000000000000001,java
12ev4cm,jfh6ta4,Java's type system is sound.,0.4,java
12ev4cm,jfh6ta4,"There was a **bug** ([ACM paper](https://dl.acm.org/doi/10.1145/2983990.2984004)) reported a year or two back, accompanied by [a blog article](https://hackernoon.com/java-is-unsound-28c84cb2b3f) saying ""Java's type system is unsound"".",0.0,java
12ev4cm,jfh6ta4,"However, there is a small but important difference between ""_there is a bug in the JDK that allows something unsound to compile and run_"", and ""_the Java type system is unsound_"".",0.07500000000000001,java
12ev4cm,jfh7auo,"If B is a subtype of A, then Java allows you to pass as an argument (or return) an array of B where an array of A is specified in the type signature.",0.0,java
12ev4cm,jfh7auo,Java's type system will allow you to call this method with an array of Dog which will blow up at runtime on the assignment to the array element.,0.0,java
12ev4cm,jffeh4f,"In fact, Smalltalk is *more* static in some ways than JS, Python, Ruby: objects have a size and internal format fixed at the time their class declaration is compiled.",0.275,python
12ev4cm,jffeh4f,"In fact, Smalltalk is *more* static in some ways than JS, Python, Ruby: objects have a size and internal format fixed at the time their class declaration is compiled.",0.275,ruby
12ev4cm,jfi2hdr,Emacs is the closest thing we have to a Lisp machine.,0.0,lisp
12ev4cm,jfi2hdr,I’m aware of some restoration projects to get a VM Lisp machine working but not very current on them.,0.125,lisp
12ev4cm,jfi2hdr,You know how people always rave about REPL driven development with Common Lisp?,-0.3,lisp
12ev4cm,jfi2hdr,"Cool, that’s handy, but it’s also editable and live.",0.3621212121212121,cool
12ev4cm,jfi2hdr,"(If it errored, you’d get dropped into a live debugging environment that we just described.",0.13636363636363635,d
12ev4cm,jfks34c,Files make code navigation clunky; you can *go to definition* but you lose your current context.,0.0,go
12ev4cm,jfh7r8u,Ruby 3.x gets close with Ractors.,0.0,ruby
12ev4cm,jfhhz7a,"They're self-similar, but written in three different PLs -- Raku, nqp, and C -- and the ability to program what happens in each one is at a lower level than the prior one.",0.0,c
12ev4cm,jfhceqz,"Yet Sun simply relied on the Internet, Java's technical merit, and the efforts of one Kim Polese._""  The other article was 7 years later, talking about what Sun was talking about possibly spending in the future 🤣 ...  Look, I know a bit about Sun (and worked on the acquisition of Sun by Oracle), and there is one thing you can be certain of: Sun couldn't market its way out of a paper bag.",0.012755102040816325,java
12ev4cm,jfl27te,As a layman language nerd I think this is something I just have to experience once but I always put it off because I don’t do a lot of hobby programming anymore and wouldn’t want the time invested go to waste.,-0.2,go
12ev4cm,jfl27te,For example I tried getting into Lisp a few times but reading books and trying stuff out just couldn’t keep me motivated.,-0.2,lisp
12ev4cm,jfhnybj,"I'm looking for something that's much closer to lua, but with more flexibility in the choice of the objects that exist at the runtime .",0.35,lua
12ev4cm,jgli10k,"But the experience will probably be similar to the one you've had with Lisp; in fact the active community is probably smaller (less open source implementations, less dialects, and less presence on social code plaforms)",-0.075,lisp
12ev4cm,jfheksu,Sun did a great job marketing Java but how does one monetize a programming language?,0.8,java
12ev4cm,jfheksu,"On the other hand, without Java, Sun would have sank (set?)",-0.125,java
12ehsjf,,And how did you go about identifying these problems?,0.0,go
12ehsjf,jfb6m9b,"Past me was bit by rather messy mocking in Java which would break abstraction boundaries; I'd write that `findBlahByName` returns something, but `getAllBlahs` would do some default thing which was plain wrong.",-0.29107142857142854,java
12ehsjf,jfb6m9b,"If it sounds like dependency injection, well, I had to make dependency injection in Spring work, which would [also go away](https://gbracha.blogspot.com/2007/12/some-months-ago-i-wrote-couple-of-posts.html).",0.0,go
12ehsjf,jfb6m9b,"Though making any other language also elegantly solves the problem of using Java, so.",0.1875,java
12ehsjf,jfb6m9b,"This was borne out of discussing how such a scheme might behave in Common Lisp for SICL, since thread-local GC was initially planned but we came up with several cases where repeated escapes ruin performance.",-0.075,scheme
12ehsjf,jfb6m9b,"This was borne out of discussing how such a scheme might behave in Common Lisp for SICL, since thread-local GC was initially planned but we came up with several cases where repeated escapes ruin performance.",-0.075,lisp
12ehsjf,jfb9tbv,"So I would like it to be an interactive system like Mathematica, and have a decent and efficient and correct way to implement all these computations that are basically pipelines of ""read some data, run some formulas, print results in CSV, generate a plot"" which are quite common in natural science (I am in the middle of developing one of these pipelines in C++ for a paper that I'm working on with my professor, by the way).",-0.008333333333333331,c++
12ehsjf,jfcjx5n,"* HTML: too verbose, no macros, middling conversion to bbcode.",0.0,html
12ehsjf,jfb2qzj,"A language that provides a way to specify multithreaded synchronisation at the language-level, as in a bit like in C++ how you can use RAII to do memory cleanup in your dtors, and like D's invariants; well, this imaginary language would encode senantics for shared access and critical sections in the language itself...",0.0,c++
12ehsjf,jfb2qzj,"A language that provides a way to specify multithreaded synchronisation at the language-level, as in a bit like in C++ how you can use RAII to do memory cleanup in your dtors, and like D's invariants; well, this imaginary language would encode senantics for shared access and critical sections in the language itself...",0.0,d
12ehsjf,jfh0z43,"Support for both true immutable types and internal asynchronous/concurrent services (concurrent actors, like Erlang processes).",0.175,erlang
12ehsjf,jfdv3d4,"It's hard to explain in one go, but imagine the sort of small business/charity/school/department of a large business/etc that runs off a mess of Excel and Python and SQL and PHP, where someone needs to produce an app for the use of Jared and Samantha from Accounting ... this would all work much better if they had a bunch of [Charm](https://github.com/tim-hardcastle/Charm) services running off a Charm hub wrapped around their database.",-0.0004761904761904745,go
12ehsjf,jfdv3d4,"It's hard to explain in one go, but imagine the sort of small business/charity/school/department of a large business/etc that runs off a mess of Excel and Python and SQL and PHP, where someone needs to produce an app for the use of Jared and Samantha from Accounting ... this would all work much better if they had a bunch of [Charm](https://github.com/tim-hardcastle/Charm) services running off a Charm hub wrapped around their database.",-0.0004761904761904745,python
12ehsjf,jfdv3d4,"It's hard to explain in one go, but imagine the sort of small business/charity/school/department of a large business/etc that runs off a mess of Excel and Python and SQL and PHP, where someone needs to produce an app for the use of Jared and Samantha from Accounting ... this would all work much better if they had a bunch of [Charm](https://github.com/tim-hardcastle/Charm) services running off a Charm hub wrapped around their database.",-0.0004761904761904745,php
12ehsjf,jfcn1hf,"We come from a background writing full stack webapps in Scala, and we're building a language that lets us do more of that with less obstacles.",0.15833333333333333,scala
12ehsjf,jftdt54,"I am making the Lapla programming language with the goal of stopping all critical runtime errors (things that would cause the program to stop unexpectedly, like a panic in Rust or an uncaught exception in Java) **at compile time**.",0.05,rust
12ehsjf,jftdt54,"I am making the Lapla programming language with the goal of stopping all critical runtime errors (things that would cause the program to stop unexpectedly, like a panic in Rust or an uncaught exception in Java) **at compile time**.",0.05,java
12ehsjf,jftdt54,"The Lapla programming language transpiles to C and currently has basic number types, local and static variables, functions and namespaces, with references, structs, enums, generics and a standard library coming soon.",0.1,c
12ehsjf,jfcps47,Rust - because there definitely wasn't enough self righteous software Devs.,0.0,rust
12ehsjf,jfbueqz,"Emscripten always assumes there is a C standard library present on the virtual machine, so it is an overkill for most such small programs.",0.05,c
12ehsjf,jfeq0sq,It's syntax is similar to MATLAB and Octave.,0.0,matlab
12ehsjf,jffl393,* Writing patterns directly in C (or C++) is kinda clumsy.,-0.09999999999999999,c
12ehsjf,jffl393,* Writing patterns directly in C (or C++) is kinda clumsy.,-0.09999999999999999,c++
12ehsjf,jffl393,"However, a fair amount of code in patterns in match.pd is still written in C using blocks { ... } because we haven't yet found a good enough set of abstractions to represent those in DSL.",0.4666666666666666,c
12ehsjf,jfhivdi,"Core syntax is mostly haskell flavoured, evaluation model, etc.",0.5,haskell
12ehsjf,jg6kz1x,I wrote [Jactl](https://jactl.io) as way to embed a scripting language into real-time Java applications where scripts would never block the execution thread making it suitable for event-loop/reactive applications.,0.55,java
12ehsjf,jg6kz1x,"I didn't want to use a language which could invoke arbitrary Java code and create their own threads, or access the file system outside the control of the application developer.",0.16666666666666666,java
12ehsjf,jfdoc9v,Let things be cool and let things be fun.,0.32499999999999996,cool
12ehsjf,jfg262q,Seems Java's `synchronized` keyword does exactly this.,0.25,java
12doeba,jf7hbb9,"I felt such a relief when I ditched React, MobX, Yarn, all that framework crap, and started to write in pure, library-less Typescript.",-0.17142857142857143,typescript
12doeba,jfany9s,If I'm reading/writing data then I usually go for JSON.,-0.25,go
12doeba,jfany9s,TOML is the newcomer (2013) but the fact that it's used by rust for the `cargo.toml` is undoubtedly giving it more visibility.,0.5,rust
12dod7u,,The language features both a tree-walk interpreter and a compiler that can translate programs written in Nox to Lua.,0.0,lua
12dod7u,,"impure) approach it takes to functional programming (Nox features mutable reference cells and while loops) and its implementation of Hindley-Milner type inference, as well as by Lua for the more ""dynamic"" aspects of the language, such as polymorphic records (which behave a lot like Lua tables) and the idea that modules are just sequences of statements that can return values to be exported.",0.16666666666666666,lua
12dod7u,,"While it would be possible to implement them with a combination of records, polymorphic variants and references, performance of the resulting code would probably be subpar compared to a built-in implementation exploiting Lua arrays.",0.0,lua
12dod7u,jfd4voo,Maybe reach out to him if you think you’d like to explore combining efforts.,0.0,d
12dod7u,jfki8hc,Cool!,0.4375,cool
12dod7u,jfcsbdc,This looks cool,0.35,cool
12dod7u,jfspugd,"Does a Box of <A,B,...> fit inside a Box of Box of <A,B,C,...>?",0.4,c
12dod7u,jfygt11,"For example, in Nox a function `fun f(r) { r.x + r.y }` would receive the type `([x: number, y: number | 'a]) -> number`.",0.3,r
12dod7u,jfygt11,"For example, the function `fun f(r) { r <- [x = 1, y = 2]}` would be assigned the type `(&[x : number, y : number]) -> unit` in Nox.",0.3,r
12dadmy,,"It was first introduced in the [Flavors](https://www.softwarepreservation.org/projects/LISP/MIT/nnnfla1-20040122.pdf) system for the Lisp Machine, which also contained a mixin-based multiple inheritance system.",0.125,lisp
12dadmy,,"Both of these features would be carried into the Common Lisp Object System, which also had multiple dispatch and generic functions.",-0.09999999999999999,lisp
12dadmy,jf5uhjo,Ruby has `prepend` which mixes in a module “in front” of the current module instead of behind it in the inheritance chain.,-0.2,ruby
12dadmy,jf61l8j,"Not sure if fully related (I'd have loved to see an example) but C# has a feature that allows you to have a lot of power over which methods compose to what, as long as you do it manually:  You can implement an interface method explicitly, e.g.",0.09999999999999999,c
12dadmy,jfa7qid,"""method combination"" is kind of a 1950s Lisp thing.",0.6,lisp
12dadmy,jfa7qid,"So let's go to a more advanced example, one that ships in the language's core library.",0.45,go
12dadmy,jfhplg2,"There is now support for using mixins in Java :)  One of the Ecstasy developers [""ported"" the Ecstasy mixin concept to Java](https://github.com/xtclang/jmixin/blob/main/src/main/java/org/xtclang/jmixin/Mixin.java).",0.5,java
12dadmy,jfib2od,> There is now support for using mixins in Java :)  Truly it is the Borg of languages.,0.5,java
12dadmy,jfjd8zi,Java is just *gross* at this point and because of backward compatibility all anyone can even *suggest* to improve the language is adding more stuff on.,0.25,java
12dadmy,jfk9is7,"I did mean to add an /s 😉  Also, that's just a library that one of the Ecstasy developers wrote, that adds mixin functionality to Java (as a library, not as part of the language).",-0.3125,java
12dadmy,jfk9is7,"I'm sure if Ecstasy takes off, Java will add mixins, but until then, you'll have to get by with the library ...",0.5,java
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,python
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,bash
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,java
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,c
12d5dek,,For background I currently know well: - Python (1.5 YOE) - JavaScript/TypeScript (1.5 YOE) - Bash   I really hate Java C is okay Go looks good   Help me choose !,0.14375,go
12d5dek,jf4xj7w,I'm pretty sure you can do the first part with either python or JS (or go).,0.3333333333333333,python
12d5dek,jf4xj7w,I'm pretty sure you can do the first part with either python or JS (or go).,0.3333333333333333,go
12d5dek,jf5npw5,"I did crafting interpreters with c#, js and rust.",0.0,c
12d5dek,jf5npw5,"I did crafting interpreters with c#, js and rust.",0.0,rust
12d5dek,jf4y6qg,"If you really hate Java then the Go book is pretty much the same thing as crafting interpreters, but in go.",-0.08750000000000001,java
12d5dek,jf4y6qg,"If you really hate Java then the Go book is pretty much the same thing as crafting interpreters, but in go.",-0.08750000000000001,go
12d5dek,jf8yhyv,I did it in TypeScript and had a lot of fun!,0.375,typescript
12d5dek,jf8yhyv,"There's no need to hate on Java, it's perfectly fine for the job and a good choice for an educational book like Crafting Interpreters.",0.14166666666666666,java
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,kotlin
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,dart
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,java
12d5dek,jf8yhyv,"You could try doing it in Kotlin or Dart if you want to learn a new language that's similar enough to Java while doing it (can be fun, but also can be too much at one time), otherwise honestly you can do it in the languages you already know (Python, TS/JS).",0.20606060606060606,python
12d5dek,jf51slf,"Hi again 😁  If you really need help choosing, go for Writing an interpreter in Go.",0.2,go
12d5dek,jf51slf,It seems like you’re already interested in learning  Go; this book is a pretty good for getting started with it.,0.39999999999999997,go
12d5dek,jf51slf,"I love Crafting interpreters, but it’s written while heavily relying on the chosen implementation languages (Java and C).",0.15,java
12d5dek,jf51slf,"I love Crafting interpreters, but it’s written while heavily relying on the chosen implementation languages (Java and C).",0.15,c
12d5dek,jf51slf,"Writing an interpreter in Go has a sequel that builds on it, called Writing a compiler in Go.",0.0,go
12d5dek,jf86nvi,"I find ""Writing and interpreter in Go"" a bit more approachable than the first part of Crafting Interpreters (which is the part that covers the same topics covered in the interpreter book).",0.25,go
12d5dek,jf86nvi,"The first part of crafting interpreters uses Java but not only it does uses java, but it goes with a technique that I found a bit weird which was generating java code and classes which I personally found hard to understand and a bit unnecessary to me, given that I was following the book using JS.",-0.13452380952380955,java
12d5dek,jf79nc2,"JLox could easily be rewritten in Go, or pretty much any high-level language.",0.29444444444444445,go
12d5dek,jf79nc2,"C isn't the only such language, but I'd argue that even Rust is a bit higher-level than you want: the safety features of Rust get in the way of some tricks which CLox uses to achieve its performance.",0.0,c
12d5dek,jf79nc2,"C isn't the only such language, but I'd argue that even Rust is a bit higher-level than you want: the safety features of Rust get in the way of some tricks which CLox uses to achieve its performance.",0.0,rust
12d5dek,jf79nc2,Go is even higher-level than Rust.,0.0,go
12d5dek,jf79nc2,Go is even higher-level than Rust.,0.0,rust
12d5dek,jf79nc2,"You'd certainly learn from inventing Go solutions to the problems covered in the book, but I think you'd be diverging from what's in the book so far that the book isn't really a useful part of that process.",0.20476190476190478,go
12d5dek,jf79nc2,"Given how much of the programming world is built on C, I think it's a useful thing to learn.",0.25,c
12d5dek,jf79nc2,"If you're really okay with the limitations of a tree-walk interpreter, you might want to check out [MAL](https://github.com/kanaka/mal), which will teach you how to write a tree-walk interpreter for a LISP.",0.5,lisp
12d5dek,jf5xwdb,"However, to get your feet wet with programming language development I recommend (as always) [Compiling to Assembly from Scratch](https://keleshev.com/compiling-to-assembly-from-scratch/).",-0.1,assembly
12d5dek,jf5xwdb,It is using TypeScript to write a compiler but teaches you some basics that will be useful for writing an interpreter too.,0.3,typescript
12d5dek,jf5xwdb,This book translates this approach reasonably well into TypeScript.,0.2,typescript
12d5dek,jf5xwdb,"To quote from the page:  > If you’re into statically-typed functional programming languages (Haskell, OCaml, or Reason ML), you will find that the class structure I used has a nice translation to an algebraic data type.",0.55,haskell
12d5dek,jflxgth,Follow the first half by translating jlex into Python.,0.04166666666666667,python
12d5dek,jflxgth,"If you don't like C, try Pascal.",0.0,c
12d5dek,jflxgth,"If you don't like C, try Pascal.",0.0,pascal
12d5dek,jflxgth,"Yes, you'll be learning Pascal along the way, but you'll only actually need basic core-language stuff for this particular journey so it should not be a big problem.",0.03333333333333333,pascal
12d5dek,jfmaybj,"As others have pointed out already, if you want to implement CLox, you are gonna have a better time using a ""low level"" language that does not get in your way (that discards rust hehe jk).",0.25,rust
12d5dek,jfmaybj,"Some nice options would be: Zig, C++, Odin, C among others.",0.6,c++
12d5dek,jfmaybj,"Some nice options would be: Zig, C++, Odin, C among others.",0.6,c
12d5dek,jf6uqva,"+1, I went thru Crafting Interpreters in Dart of all things.",0.0,dart
12d5dek,jf4ym19,"I like Go as a lang over Java, just looks simpler and less bloated, easier to learn, less terse, modern",-0.04444444444444443,go
12d5dek,jf4ym19,"I like Go as a lang over Java, just looks simpler and less bloated, easier to learn, less terse, modern",-0.04444444444444443,java
12d5dek,jf52feg,"Yeah I think that’s confirmed the choice for me 🥹 really excited to pick it up, always really fun experience learning a new language (unless it’s Bash lol)",0.40227272727272734,bash
12d5dek,jf5rrjb,"In my experience, Part 1 can be written in any language, although I wouldn’t recommend doing it in C, you can do it in Rust (with reference counting, probably) or Kotlin or JS.",0.0,c
12d5dek,jf5rrjb,"In my experience, Part 1 can be written in any language, although I wouldn’t recommend doing it in C, you can do it in Rust (with reference counting, probably) or Kotlin or JS.",0.0,rust
12d5dek,jf5rrjb,"In my experience, Part 1 can be written in any language, although I wouldn’t recommend doing it in C, you can do it in Rust (with reference counting, probably) or Kotlin or JS.",0.0,kotlin
12d5dek,jf5rrjb,"I don’t think  any of this would be an issue in Zig, althplough it becomes a bit of a pain in rust due to aliasing mutable references being UB (even when unused!",-0.15625,rust
12d5dek,jf5rrjb,"which makes writing a GC a non trivial experience and the exact architecture in the book just won’t work for rust, unless you’re ok with UB (which does actually cause miscommunications every so often).",0.25,rust
12d5dek,jf80dyx,but it makes a lot of sense  so ig just go ahead and pick any language you want to follow Crafting Interpreters with  when I was reading it I picked Rust because I knew it had a C part and I really didn't want to write C,0.2,go
12d5dek,jf80dyx,but it makes a lot of sense  so ig just go ahead and pick any language you want to follow Crafting Interpreters with  when I was reading it I picked Rust because I knew it had a C part and I really didn't want to write C,0.2,rust
12d5dek,jf80dyx,but it makes a lot of sense  so ig just go ahead and pick any language you want to follow Crafting Interpreters with  when I was reading it I picked Rust because I knew it had a C part and I really didn't want to write C,0.2,c
12d5dek,jf5hl3j,They must have irrational love for Java or something.,0.5,java
12d5dek,jf7cej8,"Java has a much more powerful type system, a more mature ecosystem, and is extremely portable.",0.255,java
12d5dek,jf7cej8,"Java made some mistakes which newer languages had the benefit of learning from, and some languages (such as C#) have learned from those mistakes and improved.",0.0,java
12d5dek,jf7cej8,"Java made some mistakes which newer languages had the benefit of learning from, and some languages (such as C#) have learned from those mistakes and improved.",0.0,c
12d5dek,jf7cej8,"My biggest critique of Go is that there are many cases where they \*didn't\* learn from the mistakes of previous languages, instead initially opting for macros (go generate) over generics, and now finally adding a bolted-on implementation of generics after learning the hard way that macros are bad (which everyone else already knew).",-0.10972222222222221,go
12d5dek,jf7cej8,"And look: Go has some real upsides over Java, too.",0.2,go
12d5dek,jf7cej8,"And look: Go has some real upsides over Java, too.",0.2,java
12d5dek,jf7cej8,"My point isn't that Go is bad, or that Java is good, it's that both these languages have their positives and negatives, and are the right tools for different jobs.",0.07142857142857145,go
12d5dek,jf7cej8,"My point isn't that Go is bad, or that Java is good, it's that both these languages have their positives and negatives, and are the right tools for different jobs.",0.07142857142857145,java
12d5dek,jf8udi8,"I implemented clox in Rust, using the GC approach I described to provide a mark and sweep, compacting GC.",0.0,rust
12d5dek,jf72b4h,"So, what's stopping you from writing a GC in Go that nulls out or removes the items from the list instead of using free()?",0.4,go
12d5dek,jf5hn4y,"Sorry I meant Go is less Verbose it seems than Java, and more concise!",-0.010416666666666657,go
12d5dek,jf5hn4y,"Sorry I meant Go is less Verbose it seems than Java, and more concise!",-0.010416666666666657,java
12d5dek,jfbeqdx,"I *have* gone through the book, and I'm telling you that C was chosen as the language for the second half of the book for reasons that you can't simply ignore because you don't like C.  There *are* other language that would work, but a language that doesn't let you manually manage memory simply won't work.",-0.05833333333333333,c
12d5dek,jf754xe,Modern Java is refreshingly terse and expressive.,0.5,java
12d5dek,jf5rvxa,I’m planning on doing the Go book/s then crafting interpreters,0.0,go
12czblp,,"I've revised the syntax and going to pick up ""Writing an interpreter in Go"" and learn Go to undertake this challenge.",0.0,go
12czblp,,"true: false          // Loop modifier ""%""     {% i=0; i<10; i++,        // do stuff     }          // Function modifier #, params with ""..."", return with ""@""     sum = {# ...a, ...b,              @ a + b           }     product = {# ...c, ...d, @ c * d}          // Function chaining with ""->"" and placeholder return value ""$""     out = sum(1, 2) -> product($, 4)          // Try block modifier ""++"", Catch block modifier ""--""     {++       // try code     } {--        // catch code     }          // Scoped code blocks:     {       x = 0       y = 0     }  ... just syntax-wise, I converted one of my Python programs to this syntax to get an idea of how it all comes together.",-0.26666666666666666,c
12czblp,,"true: false          // Loop modifier ""%""     {% i=0; i<10; i++,        // do stuff     }          // Function modifier #, params with ""..."", return with ""@""     sum = {# ...a, ...b,              @ a + b           }     product = {# ...c, ...d, @ c * d}          // Function chaining with ""->"" and placeholder return value ""$""     out = sum(1, 2) -> product($, 4)          // Try block modifier ""++"", Catch block modifier ""--""     {++       // try code     } {--        // catch code     }          // Scoped code blocks:     {       x = 0       y = 0     }  ... just syntax-wise, I converted one of my Python programs to this syntax to get an idea of how it all comes together.",-0.26666666666666666,d
12czblp,,"true: false          // Loop modifier ""%""     {% i=0; i<10; i++,        // do stuff     }          // Function modifier #, params with ""..."", return with ""@""     sum = {# ...a, ...b,              @ a + b           }     product = {# ...c, ...d, @ c * d}          // Function chaining with ""->"" and placeholder return value ""$""     out = sum(1, 2) -> product($, 4)          // Try block modifier ""++"", Catch block modifier ""--""     {++       // try code     } {--        // catch code     }          // Scoped code blocks:     {       x = 0       y = 0     }  ... just syntax-wise, I converted one of my Python programs to this syntax to get an idea of how it all comes together.",-0.26666666666666666,python
12czblp,jf50u2g,I feel like languages fall into 3 extremes: 1 where keywords get in the way a lot of the languages expressiveness (Java) but offer flexibility; and the other where syntax is poor or confusing (Bash) and less flexible.,-0.24791666666666665,java
12czblp,jf50u2g,I feel like languages fall into 3 extremes: 1 where keywords get in the way a lot of the languages expressiveness (Java) but offer flexibility; and the other where syntax is poor or confusing (Bash) and less flexible.,-0.24791666666666665,bash
12czblp,jf50u2g,"I feel like I’m similar to Bash, but trying to make the syntax much more concise.",0.19999999999999998,bash
12czblp,jf50u2g,"I’m really inspired by the Pug templating language which rethinks HTML with block modifiers, and find it really beautiful and easy to pick up and understand.",0.49444444444444446,html
12czblp,jfbg3f0,"Today, with the great shift from ASCII to UTF-8, we have a whole lot more symbols at our disposal, and excepting such things as emoticons, many aren't newly invented, they go back centuries.",0.3051948051948052,go
12czblp,jf5iqaf,"condition, // do stuff }         I did look at modifiers outside the code block, but it was hard to maintain consistency which is really important to me, and it makes anon functions look too close to a function call inside parentheses so it looks confusing and mangled, especially as I wanted functions to syntactically look good when used anonymously eg if I put modifiers outside brackets, functions become:       // Named func looks odd     sum = # ...a, ...b, ...c { @ a + b + c }          // Anon func looks really weird!",-0.03148148148148148,c
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,html
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,bash
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,python
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,javascript
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,c
12czblp,jf51luo,"But I’m not a language expert, I know nothing, and I’ve only experienced Html, Bash, Python, JavaScript, C, Rust, and a few DSLs",0.20000000000000004,rust
12czblp,jfbyfnm,"And to be fair, I don't think many people think too deep about how the meaning of `static` relates to its use in Java, C, or C++.",0.425,java
12czblp,jfbyfnm,"And to be fair, I don't think many people think too deep about how the meaning of `static` relates to its use in Java, C, or C++.",0.425,c
12czblp,jfbyfnm,"And to be fair, I don't think many people think too deep about how the meaning of `static` relates to its use in Java, C, or C++.",0.425,c++
12czblp,jfbyfnm,"""wasabi language"" should work pretty well to disambiguate... it works well for Rust, after all.",0.25,rust
12czblp,jf56j1d,"Consider how Typescript is built on top of Javascript, or Kotlin on top of Java.",0.5,typescript
12czblp,jf56j1d,"Consider how Typescript is built on top of Javascript, or Kotlin on top of Java.",0.5,javascript
12czblp,jf56j1d,"Consider how Typescript is built on top of Javascript, or Kotlin on top of Java.",0.5,kotlin
12czblp,jf56j1d,"Consider how Typescript is built on top of Javascript, or Kotlin on top of Java.",0.5,java
12cj0b3,jfk1ra8,"I think this is really cool, thank you for sharing.",0.35,cool
12cj0b3,jfli0f8,"Here's mine, written in Python: [https://github.com/kjosib/booze-tools](https://github.com/kjosib/booze-tools) It also has a few extra bits.",-0.31666666666666665,python
12cj0b3,jfli0f8,"Frankly, I thought the macro-system was a pretty cool contribution to the art.",0.3,cool
12cc5ib,,"The idea is it's a fully keyword-less syntax inspired by APL (but using only what's on your keyboard) for the base language, immutable by default, with special modifiers.",-0.14761904761904762,apl
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,apl
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,bash
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,rust
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,python
12cc5ib,,"my_array = []          # imports (and function params) via ...     ...say          # import submodules too via the module/object access operator ""::""      ...say::hello          # alias imports with the ""~"" operator     ...time ~ t          # Access object properties via ""::""     my_obj::value     my_obj::func()          # Array push shorthand via object access operator and ""<()""     my_array::<(1, 2, 3)  I'm inspired by APL, Bash, Rust, Python, Node, HTML, and Pug (template lang)  So ... how does the syntax look?",0.0,html
12cc5ib,jf2k7vp,"I’m currently working on my own language as well, and I’m using Writing an Interpreter in Go and Make A Lisp as references, as well as Crafting Interpreters.",0.3,go
12cc5ib,jf2k7vp,"I’m currently working on my own language as well, and I’m using Writing an Interpreter in Go and Make A Lisp as references, as well as Crafting Interpreters.",0.3,lisp
12cc5ib,jf2k7vp,"I personally think that you should hold off on learning Rust for building this project, especially if performance is not a top priority.",-0.08333333333333333,rust
12cc5ib,jf2k7vp,"It’s going to take a tremendous effort to learn a new language (let alone Rust, which is already super difficult to learn to use properly), while also trying to learn a new concept.",0.07323232323232322,rust
12cc5ib,jf2k7vp,I suggest building this first in Typescript since you’re already familiar with it.,0.3125,typescript
12cc5ib,jf2k7vp,"Personally, I’m familiar with Go, so I’m using Go for my own.",0.4875,go
12cc5ib,jf2k7vp,"Trust me, I’m having to suppress my urges to learn Rust every day 😁",0.0,rust
12cc5ib,jf0x3cu,"Given my programming experience (3 YOE, fullstack - python, node, JavaScript, typescript, bash)  How long do you reckon it would take to make a very basic interpreter and what language should I write the interpreter with?",-0.025,python
12cc5ib,jf0x3cu,"Given my programming experience (3 YOE, fullstack - python, node, JavaScript, typescript, bash)  How long do you reckon it would take to make a very basic interpreter and what language should I write the interpreter with?",-0.025,javascript
12cc5ib,jf0x3cu,"Given my programming experience (3 YOE, fullstack - python, node, JavaScript, typescript, bash)  How long do you reckon it would take to make a very basic interpreter and what language should I write the interpreter with?",-0.025,typescript
12cc5ib,jf0x3cu,"Given my programming experience (3 YOE, fullstack - python, node, JavaScript, typescript, bash)  How long do you reckon it would take to make a very basic interpreter and what language should I write the interpreter with?",-0.025,bash
12cc5ib,jf2pvj6,"If you want a keyword-less language, you should also have a look at Lisp (like Common Lisp, Scheme, etc.).",-0.3,lisp
12cc5ib,jf2pvj6,"If you want a keyword-less language, you should also have a look at Lisp (like Common Lisp, Scheme, etc.).",-0.3,scheme
12cc5ib,jf2pvj6,```  Which is extensible for else-if like in Arc Lisp:  ``` {?,0.0,lisp
12cc5ib,jf2pvj6,"Would probably look like this:  ```Rust struct Program {      expressions: Vec<Expression>, }  enum Expression {     Assignment(name: String, Block),     Block(Block),     FunctionCall { // like ""say""         name: String,         arguments: Vec<Expression>,     },     ... }  struct Block {     symbol: String, // would be ""?&"" for else-if     arguments: Vec<Expression>, } ```  It would be nice if you could define your own syntax (similar to macros or reader macros).",0.39999999999999997,rust
12cc5ib,jf2o50w,"Not sure where to start with typescript because I haven’t seen any good books for it, I’ve definitely heard of Writing an Interpreter in Go - should I learn Go?",0.15,typescript
12cc5ib,jf2o50w,"Not sure where to start with typescript because I haven’t seen any good books for it, I’ve definitely heard of Writing an Interpreter in Go - should I learn Go?",0.15,go
12cc5ib,jf40tpj,I think the double colon is a rust thing,0.0,rust
12cc5ib,jf2ox5z,"It is, and you can certainly do that if you’d like!",0.26785714285714285,d
12cc5ib,jf2ox5z,"Something else you can do is following the first half of Crafting Interpreters, which is written with Java in the book, but using Typescript.",0.02777777777777778,java
12cc5ib,jf2ox5z,"Something else you can do is following the first half of Crafting Interpreters, which is written with Java in the book, but using Typescript.",0.02777777777777778,typescript
12cc5ib,jf25l0p,I’d be keen to learn a lower level language for this.,0.0,d
12cc5ib,jf25l0p,I’m guessing C would be the best bet?,1.0,c
12cc5ib,jf25l0p,As in lowest barrier to learn (besides all the C lack of safety),0.0,c
12cc5ib,jf4kb91,"Rust got it from C++, actually.",0.0,rust
12cc5ib,jf4kb91,"Rust got it from C++, actually.",0.0,c++
12cc5ib,jf26p9l,I'd recommend C++ or Rust.,0.0,c++
12cc5ib,jf26p9l,I'd recommend C++ or Rust.,0.0,rust
12cc5ib,jf26p9l,"With C, you don't get features like RAII (destructors), methods, and generics.",0.0,c
12cc5ib,jf26p9l,"Since you're coming from higher level languages, I think you'd be better with Rust.",0.375,rust
12cc5ib,jf2ntvh,Works the same way JavaScript works eg (sorry on mobile)  if () { } if () { } else { }  Would be parsed as IF (IF ELSE) etc,-0.25,javascript
12cc5ib,jf4kjf3,"I saw it in Rust and really liked it, assumed most languages used dot notation .",0.55,rust
12cc5ib,jf272uu,Thanks I’ve been itching for a reason to learn Rust so this could be really fun.,0.25,rust
12cc5ib,jf2f99i,"Rust also has some really good tooling for writing languages… Stuff like rowan, logos, nom, etc., all make writing things really nice… Rowan is a library for lossless syntax trees (no parsing is handling with it, it just provides a way for you to abstractly represent your syntax tree in a manner that is, well, lossless.",0.44999999999999996,rust
12cc5ib,jf2f99i,"Rust-analyzer, the current LSP for Rust, uses it internally).",0.0,rust
12cc5ib,jf2e6p1,"Something like this maybe (if my Typescript knowledge hasn't failed me):  ``` function parse(code: String, ctx: Context = new Context()): Context; let ctx = parse(` flamingo code goes here `); ctx.exported_function(); ``` Again, I'm not exactly sure how this would be implemented, but it seems doable.",-0.20454545454545456,typescript
12cc5ib,jf2fjaq,Exciting 🦀 looks like I’ll be learning Rust 🦀🦀,0.3,rust
12cc5ib,jf2f67o,"Thank you, I’ll have a bit of a read up and see how Doable and convenient it is - else I’ll take your advice and investigate Rust!",0.0,rust
12cc5ib,jf2hggi,"Errors: https://crates.io/crates/codespan-reporting  Depending on how you plan on using it, you might find it worthwhile to look into `parking_lot` and `tokio` for concurrency (Rust's `async` is similar to JS).",0.25,rust
12c57rm,jf069gm,"I love this kind of things, really cool",0.4833333333333334,cool
12c57rm,jf0znyu,This is really cool!,0.4375,cool
12bui3u,,"There are currently two ways to compile multiple JavaScript files into a portable executable:  * **The Electron way:** This will ship a browser inside the executable, along with DLLs to make it portable.",0.0,javascript
12bui3u,,"The shipped browser interprets the compiled JavaScript code to run itself, and the shipping of a browser makes itself portable.",0.0,javascript
12bui3u,,"Let's say that we create a framework that ships Chromium as the JavaScript compiler, and Rustup to modify the compiled JavaScript code into what an operating system can run.",0.0,javascript
12bui3u,,"So, Chromium will compile JavaScript into some low level code, and Rustup will compile and modify the code to make it runnable on an operating system.",0.0,javascript
12bui3u,,This framework will compile JavaScript like your average C++ program.,-0.15,javascript
12bui3u,,This framework will compile JavaScript like your average C++ program.,-0.15,c++
12bui3u,,"**Edit:** To clarify some information, Chromium is not a compiler, but we can try to manipulate its components to compile JavaScript code.",0.0,javascript
12bui3u,,"Rustup is a Rust compiler, and the reason why choosing Rust is to manipulate low level data, while C++ is a good alternative, it would be better if it's done by memory safe language who can reach low level.",0.33999999999999997,rust
12bui3u,,"Rustup is a Rust compiler, and the reason why choosing Rust is to manipulate low level data, while C++ is a good alternative, it would be better if it's done by memory safe language who can reach low level.",0.33999999999999997,c++
12bui3u,,"So, Chromium will try to interpret JavaScript, but we will modify the interpreting components, so it actually compiles JavaScript, and Rustup will compile it further to make it portable on an operating system.",0.0,javascript
12bui3u,jezd6jf,>Chromium as the JavaScript compiler  I don't understand what you mean by this.,-0.3125,javascript
12bui3u,jezjpd6,"Electron (and Tauri, I assume) is not about ""compiling JavaScript files into a portable executable,"" it is about ""distributing a **web application** to offline machines.""",0.0,javascript
12bui3u,jezjpd6,"Chromium is not a ""JavaScript compiler;"" it is a [web browser](https://www.chromium.org/chromium-projects/) that you can install and use just like Firefox, IE, or, may Arceus forgive me for uttering those two words, Google Chrome.",0.0,javascript
12bui3u,jf0jb75,How does JavaScript enter the picture in the first place?,0.25,javascript
12bui3u,jf0jb75,"Go have a look at [https://www.destroyallsoftware.com/talks/wat](https://www.destroyallsoftware.com/talks/wat) before answering these questions, too.",0.0,go
12bno5i,jez9xgm,"The tooling provided by VSCode + IntelliJ + neovim is much, much better than anything you‘d manage to build with your own IDE, they have a team of developers and years behind them.",0.23333333333333336,d
12bno5i,jexyf6p,"Visual Basic, Logo, Delphi, HTML Editors,  Adobe Flash Builder, ColdFusion, Smalltalk,   These are languages which thrived because of their high power custom IDEs.",0.05333333333333334,delphi
12bno5i,jexyf6p,"Visual Basic, Logo, Delphi, HTML Editors,  Adobe Flash Builder, ColdFusion, Smalltalk,   These are languages which thrived because of their high power custom IDEs.",0.05333333333333334,html
12bno5i,jf0o7hw,"All I'm saying is that it's not so clear-cut, and there might be reasons to go either way.",0.0,go
12bno5i,jezimnu,not sure if i’d say that all of those thrived.,-0.25,d
12bno5i,jezth0j,Delphi was an also ran to Visual Basic but that still was hundreds of thousands of jobs....,0.0,delphi
12bno5i,jf05cb3,Variants of Smalltalk like Objective-C became mainstream.,0.0,objective-c
12bll1a,jexia9s,"The D programming language generalizes this by allowing D code to be declared as ""static"", which is run at compile-time.",0.5,d
12bll1a,jf0aocw,Maybe a GADT in Haskell?,0.0,haskell
12bll1a,jez9bfr,"D has a _lot_ of metaprogramming features, including a few that use the `static` keyword - namely, `static if`, `static foreach`, and `static assert` - but what's useful about those is that they are declarations, allowing for [conditional compilation](https://dlang.org/spec/version.html) and [programmatic code generation](https://dlang.org/spec/module.html#mixin-declaration).",0.35000000000000003,d
12bll1a,jez9bfr,"Regardless of whether or not you use `static` branches, D's CTFE will run any code you ask it to with only the following definition  > CTFE is subject to the following restrictions:   > - Expressions may not reference any global or local static variables.",0.14814814814814817,d
12bll1a,jey003g,"So, think pipeline,  a stream of values go in, and a stream of values go out.",0.0,go
12bl2ml,jexjebp,"Example with typescript type syntax:      type Concatenation<A, B> = [A,B]   //  AB     type Alternation<A, B>   = A|B     //  A|B     type KleeneStar<A>       = A[]     //  A*",0.0,typescript
12bl2ml,jf1aryf,"if you unify the example provided in the stack language paper `r... int =?= int r...` the sensible solution is `int+`, a stack of integers any length >= 1.",0.0,r
12bl2ml,jezf023,"Take Rust, where you can have some `Vec<T>`, but cannot specify, within the type system, how many `T`s should exist (analogous to regex’s `{m,n}` construct).",0.5,rust
12bl2ml,jezf023,I’d like to be wrong regarding that last paragraph.,-0.25,d
12bl2ml,jezfjk7,Check out Typescript.,0.0,typescript
12bl2ml,jexza35,"let c: [(int, string)*] = [1, ""one"", 2, ""two"", 3, ""three""]     let d: [(int | string)*] = c  What's interesting is, no matter how you compose the types, it's always decidable if A is a subtype of B, but also maybe NP-Complete?",-0.3333333333333333,c
12bl2ml,jexza35,"let c: [(int, string)*] = [1, ""one"", 2, ""two"", 3, ""three""]     let d: [(int | string)*] = c  What's interesting is, no matter how you compose the types, it's always decidable if A is a subtype of B, but also maybe NP-Complete?",-0.3333333333333333,d
12bl2ml,jg0e8lj,"For example, the unifier you generate in your example would be `r... -> int*`, and applying the substitution to the problem would show that, under the extended equivalence rules, the two types are equal.",0.0,r
12bl2ml,jf22ccr,"These topics mostly go over my head right now, I'm confused after just the first couple pages, but it piques my interest none the less.",0.09380952380952381,go
12bl2ml,jf1z9j4,"Admittedly, I'm not well versed in Lisp, but it seems to have the essential operations, `*` for Kleene star (and complementary `+`), `cat` for concatenation, and `or` for alternation.",0.0,lisp
12bl2ml,jeznln7,"One thing that comes to mind is TypeScript interfaces, which feels similar to defining a schema for a document database.",0.0,typescript
12bl2ml,jf4dfem,"Even with just Rust, the Flux compiler plugin offers a refinement type checker (a subset of dependent typing which is easier to solve) which can express cardinality constraints as a simple annotation",0.05,rust
12bl2ml,jf0dkg7,"TypeScript is one of my favorite languages, but I don't think it quite contains what I have in mind.",0.5,typescript
12bl2ml,jf0dkg7,"TypeScript most certainly has alternation in the form of ""union types"".",0.35714285714285715,typescript
12bl2ml,jf0dkg7,"Finally, I'm not aware of anything like Kleene star in Typescript.",-0.125,typescript
12bl2ml,jeyca3d,"For example your example `c` would compose incorrectly:      let c: [int, string][] = [[1, ""one""], [2, ""two""], [3, ""three""]]  I think the composition might work, if the nesting would be flattened.",-0.75,c
12bl2ml,jg4v9j6,"In a way, C - by complete accident of course - ""has"" the Kleene star type, and it works almost exactly in the way I would expect it to work.",0.175,c
12bl2ml,jg4v9j6,"But first, my obligatory Algol 68 mention.",0.25,algol
12bl2ml,jg4v9j6,"In Algol 68, where type is generalised into the concept ""mode"", **union** is not a mode, but a *mood* .",0.0,algol
12bl2ml,jg4v9j6,"If you have thought of C in the meantime, you may have figured out that the ""Kleene star"" type in C is simply pointers.",0.0,c
12bl2ml,jg4v9j6,"And by sheer luck (if you disregard ""declaration mirrors use"", and don't declare multiple variables in one declaration) it looks like this:  T\* x;  And like in Algol 68 with unions, in C a T\* does not have actual values.",0.0,algol
12bl2ml,jg4v9j6,"And by sheer luck (if you disregard ""declaration mirrors use"", and don't declare multiple variables in one declaration) it looks like this:  T\* x;  And like in Algol 68 with unions, in C a T\* does not have actual values.",0.0,c
12bl2ml,jg4v9j6,"I have been thinking about how a ""purified"" version of C might work, with fat pointers storing the size, so you can always ask for example an **int**\* ap what size array it refers to.",0.0,c
12bl2ml,jg1iijr,"I would be interested if it could be the type system which imposes structure and thus informs the semantics what to do, sort of like `pure` or a reader in Haskell.",0.23214285714285715,haskell
12bl2ml,jgbhtau,">(at least in my naïve understanding of regular expression types)  u/theangeryemacsshibe pointed us to **rational type expressions**, with an implementation of such a type system in Common Lisp.",-0.15,lisp
12bl2ml,jgbhtau,"[https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3](https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3)  It makes sense to apply such a type system to a dynamic language, and I think it would work well as an extension to other dynamic languages like Python and JavaScript.",-0.03125,python
12bl2ml,jgbhtau,"[https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3](https://www.reddit.com/r/ProgrammingLanguages/comments/12bl2ml/comment/jf0pbnn/?context=3)  It makes sense to apply such a type system to a dynamic language, and I think it would work well as an extension to other dynamic languages like Python and JavaScript.",-0.03125,javascript
12bl2ml,jg1zn1h,"> it would be really nice to have a product like: > `(⊗) : (α.. -- β..) (γ.. -- δ..) -- (α.. γ.. -- β.. δ..)`  I used to have a system where the type of `call` was something like  `a... b... (b... -- c...) -- a... c...`  The real big problem with 'multiple sequence variables per sequence' for me was that functions with a couple higher-order function calls often got infinitely large types with none most-general, at least from a type inference perspective.",0.03775510204081634,c
12bl2ml,jfymxcr,"Actually I believe in the past PL-theorists have put a great effort into making type systems that are \_not\_ Turing complete, to avoid situations like C++, where the template system is TC, and you cannot in principle be sure your code will finish to compile.",0.22999999999999998,c++
12bl2ml,jgppgfr,"As the analogy is completely coincidental, caused by the choice of ""\*"" for pointer dereference in C, it is not useful in any concrete way.",0.03333333333333335,c
12bl2ml,jgppgfr,"I do believe it could be used to make a language almost indistinguishable from C, with a safe and consistent type system.",0.375,c
12bi2ov,jf0fssc,"Now there's the question: Do you curry everything like Haskell, or do you implicitly pass tuples to functions like Algol?",0.0,haskell
12bi2ov,jf0fssc,"Now there's the question: Do you curry everything like Haskell, or do you implicitly pass tuples to functions like Algol?",0.0,algol
12bi2ov,jexwl77,"Haskell has a function taking `Void` as an argument, and it's called `absurd`.",-0.5,haskell
12bi2ov,jf4649c,"Void is just a type like any other and I fist wanted to support the call to cover genercics (if you can go from A->B, for any A,B, it just be that A or B can also be Void if void is just a type.",-0.125,go
12bi2ov,jf62nyg,"This is definitely not what C means when it says void, otherwise \`void f()\` would be saying a function which returns an element from the empty set.",-0.05,c
12bi2ov,jexhth7,What about `a + c * d + e` for all combinations of `unit` variable values?,0.0,c
12bi2ov,jexhth7,What about `a + c * d + e` for all combinations of `unit` variable values?,0.0,d
12bi2ov,jf13g99,in Dart this is not the case.,0.0,dart
12bi2ov,jf13g99,"So this is valid dart code:      void main() {         void c = 5;         print(c as Object);     }     or even this:      void log<T>(T value) => print(value);     void main() {         void c = 5;         log(c);     }  Of course, there is no much sense in writing code like that at all, but still.",0.07777777777777777,dart
12bi2ov,jf13g99,"So this is valid dart code:      void main() {         void c = 5;         print(c as Object);     }     or even this:      void log<T>(T value) => print(value);     void main() {         void c = 5;         log(c);     }  Of course, there is no much sense in writing code like that at all, but still.",0.07777777777777777,c
12bi2ov,jf679f9,"but overall, it's probably meaningless to consult C for type theory lol, was just giving another perspective :)  btw since C functions are allowed to diverge sometimes the empty type is a valid return type for them",0.14,c
12bi2ov,jf2edag,"I haven’t used dart, so that’s good to know, thank you!",0.875,dart
12bi2ov,jfz4f5f,"yes but it's exceedingly rare for languages to have proper empty type support like Rust's \`!\`, C doesn't have it and I don't even think haskell does.",0.06666666666666667,rust
12bi2ov,jfz4f5f,"yes but it's exceedingly rare for languages to have proper empty type support like Rust's \`!\`, C doesn't have it and I don't even think haskell does.",0.06666666666666667,c
12bi2ov,jfz4f5f,"yes but it's exceedingly rare for languages to have proper empty type support like Rust's \`!\`, C doesn't have it and I don't even think haskell does.",0.06666666666666667,haskell
12bi2ov,jfzp438,"Haskell does, both as `Void` in the standard library and via the `EmptyDataDecls` extension.",0.0,haskell
12bi2ov,jfzp438,"it's such a minor difference though, that a language like C won't care (or need to care)",-0.025,c
12bi2ov,jeykmpf,"\(x :: Int) -> x * 2  and      \x -> (x :: Int) * 2  In Haskell, you would call the first one something like a ""pattern type annotation (or type annotation in a pattern)"" and the second one just a ""type annotation"".",0.125,haskell
12bf369,,"LLVM IR), mine looks like assembly!",0.0,assembly
12bf369,jewsl8k,One the ILs of the GHC Haskell compiler is called C--.,0.0,haskell
12bf369,jewsl8k,One the ILs of the GHC Haskell compiler is called C--.,0.0,c
12bf369,jewsl8k,"If what you have is essentially an assembly that is in good shape to be optimised, then call it ASM++ and then print out native ASM for your target triplet :)",0.39999999999999997,assembly
12bf369,jewu8tm,An assembler is just a compiler for an assembly language.,0.0,assembly
12bf369,jewu8tm,So if you categorize your IL as an assembly language (many ILs are considered assembly languages for the virtual machine) then you can call it an assembler.,0.5,assembly
12bf369,jexq1vq,"If you wanna really break your brain, check out [""High Level Assembly""](https://en.wikipedia.org/wiki/High_Level_Assembly).",0.18,assembly
12bf369,jf4m29i,I guess I will go with 'compiler'.,0.0,go
12bf369,jf4m29i,"Those names are marked with `*`:      Lang Ext   Tool      Name             Descripton          M    .m    mm.exe    M compiler       Translate to exe/pcl/asm/mc/ma                ms.exe    *Run M           Run M from source ('m script')                mc.exe    M transpiler     Translate to C source, or exe via C compiler          PCL  .pcl  pcc.exe   PCL compiler     Translate to exe/asm                pci.exe   PCL interpreter  Run PCL file from source          Q    .q    qc.exe    Q compiler       Compile to .pc bytecode file          ASM  .asm  aa.exe    ASM interpreter  Translate ASM source to exe/obj          --   .pc   pc.exe    Q interpreter    Interpret binary bytecode file          --   .mc   run.exe   *Run 'mc' file   Execute private binary format          Key:          M     - Static systems language     PCL   - Static intermediate language when used outside a compiler     Q     - Dynamic scripting language     ASM   - x64 assembly code in my symtax     .pc   - Binary bytecode file from Q compiler.",0.15714285714285717,c
12bf369,jf4m29i,"Those names are marked with `*`:      Lang Ext   Tool      Name             Descripton          M    .m    mm.exe    M compiler       Translate to exe/pcl/asm/mc/ma                ms.exe    *Run M           Run M from source ('m script')                mc.exe    M transpiler     Translate to C source, or exe via C compiler          PCL  .pcl  pcc.exe   PCL compiler     Translate to exe/asm                pci.exe   PCL interpreter  Run PCL file from source          Q    .q    qc.exe    Q compiler       Compile to .pc bytecode file          ASM  .asm  aa.exe    ASM interpreter  Translate ASM source to exe/obj          --   .pc   pc.exe    Q interpreter    Interpret binary bytecode file          --   .mc   run.exe   *Run 'mc' file   Execute private binary format          Key:          M     - Static systems language     PCL   - Static intermediate language when used outside a compiler     Q     - Dynamic scripting language     ASM   - x64 assembly code in my symtax     .pc   - Binary bytecode file from Q compiler.",0.15714285714285717,assembly
12bf369,jewvna4,The compiler backend then does machine independent optimisation before generating assembly code.,0.0,assembly
12bf369,jeypcpm,"I don't think it needs a while new name just because the target language is C rather than Assembly, or JavaScript instead of JVM bytecode.",0.13636363636363635,c
12bf369,jeypcpm,"I don't think it needs a while new name just because the target language is C rather than Assembly, or JavaScript instead of JVM bytecode.",0.13636363636363635,assembly
12bf369,jeypcpm,"I don't think it needs a while new name just because the target language is C rather than Assembly, or JavaScript instead of JVM bytecode.",0.13636363636363635,javascript
12bf369,jez8vvd,The compiler generates assembly code.,0.0,assembly
12bf369,jez8vvd,The assembler takes this assembly code and generates machine code ie an object file.,0.0,assembly
12bf369,jez8vvd,The linker links functions from the libraries that you used in your program such as `printf` in C,0.0,c
12bf369,jyhlm46,"Whenever we write a story/program in a language like C++, Java, or Python, the compiler starts translating the story/program into a language that can be understood  by the computer, which is the ""machine code.""",0.0,c++
12bf369,jyhlm46,"Whenever we write a story/program in a language like C++, Java, or Python, the compiler starts translating the story/program into a language that can be understood  by the computer, which is the ""machine code.""",0.0,java
12bf369,jyhlm46,"Whenever we write a story/program in a language like C++, Java, or Python, the compiler starts translating the story/program into a language that can be understood  by the computer, which is the ""machine code.""",0.0,python
12bf369,jyhlm46,"Assembler is like writing those super specific dance moves in a language called ""assembly language.""",0.16666666666666666,assembly
12bf369,jyhlm46,"Assembly language, in general, is a bit easier for humans to understand than machine code, but the computer still doesn't know what to do with it.",0.05000000000000002,assembly
12bf369,jexbvvg,"Presumably the `c` stands for `compiler`, but that still needs qualifying as `ll compiler`.",0.0,c
12bf369,jeyzujo,"Back in college, I knew a guy who enjoyed programming in C-- directly.",0.19999999999999998,c
12bf369,jeyzujo,"I somehow doubt it was at all associated with GHC, considering Haskell itself hadn't come out yet...",0.0,haskell
12bf369,jez78ky,A backend takes IR and generates platform-dependent assembly.,0.0,assembly
12bf369,jez6fh8,C-- was designed as an IL for GHC by Simon Peyton Jones and someone else who I don't remember atm.,0.0,c
12bf369,jez6fh8,It came out in 1998 (well after Haskell).,0.0,haskell
12bf369,jez9nhr,So there must have been another C-- at least as early as 1994.,-0.09999999999999999,c
12bf369,jf0z9k2,"No actually C-- was its own project to start with, and a dialect was later included in GHC.",0.19999999999999998,c
12bf369,jf0z9k2,"If you take a look at the old page, you'll see that GHC isn't even mentioned: https://web.archive.org/web/20080611074310/http://www.cminusminus.org/code.html  However that branch of C-- went extinct, and only in GHC's DNA you'll find C-- :)",0.04999999999999999,c
12bcyj6,jewbxyi,There were things like a Chinese version of BASIC and a Russian version of C++ but most programming languages based on non-english languages are teaching languages.,0.125,c++
12bcyj6,jewbxyi,Most popular programming languages even limit identifier names to plain latin characters except for JavaScript.,0.29523809523809524,javascript
12bcyj6,jewayqc,Fun fact: Ruby was created by a Japanese engineer but still keeps the same common contructs as the other 'English based' languages,-0.020833333333333332,ruby
12bcyj6,jewe9kr,But learning Pascal in school around the age of 12 or 13 or so I don't remember ever thinking that this is weird.,-0.5,pascal
12bcyj6,jewbsu3,"Also, there are languages that only use symbols, like APL o very few words like Prolog.",-0.13,apl
12bcyj6,jewbsu3,"Also, there are languages that only use symbols, like APL o very few words like Prolog.",-0.13,prolog
12bcyj6,jewwna6,"The developer of this feature was later in the ALGOL comitee, which was staffed by an international crew, but designed an English based language.",0.0,algol
12bcyj6,jf04stp,"*Could be* even easier for somebody with no knowledge of spoken English to understand this dialect than try to explain to somebody that do why (in C) ""true & false"" is not false, but 0.",0.037499999999999985,c
12bcyj6,jexibzq,There are languages with keywords in other languages (Portugol comes to mind as an Algol clone with Portuguese keywords) but they're generally not that popular outside of educational contexts.,0.13999999999999999,algol
12bcyj6,jexibzq,"There are people working on that - I've seen people on the discord server that were trying to (or at least wanted to) make a system where keyword tokens were transparently translated across locales - but as an ESL myself, I personally don't think it matters that much in the grand scheme of things.",0.1,scheme
12bcyj6,jexibzq,"I guess there could be locale shims and you could depend on the kindness of open-source to populate the appropriate translations, but even massive projects championed by big companies like Jest and Rust still have trouble with translations.",0.075,rust
12bcyj6,jewiu5z,"One of the first high level languages was LISP, and it's basic vocabulary (cond, cons, car, cdr, lambda, atom, ...) can hardly be called ""English"".",0.02366666666666667,lisp
12bcyj6,jexjamm,"Or sometimes spanishize the word, for example library becomes librería instead of the native ""biblioteca"", and allocate becomes ""alocar"" (even though in Spanish ""alocar"" means ""to go crazy"")",-0.3,go
12awbwx,,That also means that JavaScript won't be improved as fast anymore.,0.2,javascript
12awbwx,,"So, are the browsers still competing to improve JavaScript, or did that war end long ago?",-0.05,javascript
12awbwx,jeu78ah,"> So, are the browsers still competing to improve JavaScript  JavaScript's evolution, or what you call ""improvements,"" does not come from competition but from recent [ECMA TC39](https://tc39.es/) standardisation.",0.0,javascript
12awbwx,jeu78ah,"Before last decade the word ""JavaScript"" itself had multiple meanings, mainly ""Mozilla-Flavoured ECMAScript,"" and ""ECMAScript.""",0.05555555555555555,javascript
12awbwx,jey8kb6,That also means that JavaScript won't be improved as fast anymore  I cannot agree with this observation.,0.2,javascript
12awbwx,jey8kb6,JavaScript had a long interstitial period of sluggish to no change to the language in the 10 years between 1999 and 2009.,-0.05,javascript
12awbwx,jewdg5d,"Javascript is standardized, and all improvements go through a standards admission process.",0.0,javascript
12awbwx,jewdg5d,"Javascript is standardized, and all improvements go through a standards admission process.",0.0,go
12awbwx,jetxt1a,"Yes, JavaScript will continue to improve.",0.0,javascript
12awbwx,jetxt1a,"I'm not really an expert in the politics of this, but as long as Google has an interest in keeping web applications competitive with native applications, they have an interest in improving JavaScript.",-0.07500000000000001,javascript
12awbwx,jev0q4u,well when you're at rock bottom you can only go up,0.0,go
12awbwx,jf7p7c0,"JavaScript stopped being ""improved"" a long time ago, instead opting to add lowest-common-denominator features that exist only because people couldn't be arsed to learn the features JavaScript already had.",-0.025,javascript
12awbwx,jf7p7c0,"The best thing JavaScript can do is give WASM full power to do everything JS does without having to use JS as an intermediary, and let JavaScript die.",0.675,javascript
12au6kd,jeuurln,"> what syntax should imports have  When writing D code, it is best practice to selectively `import` only the symbols you actually need, and to do it only when you need them.",0.25,d
12au6kd,jeuurln,I found that D may be the only language that supports this without having `import` be an expression.,0.0,d
12au6kd,jeuurln,"Oh and then you will have people writing code in your language and in Java _at the same time_ but their Java framework, _which you have never heard about_, uses a directory structure that breaks the way people share code for your interpreter, and now you got one person complaining about needing to manually import `../../../../../java/acme/src/whatever/boot.py`.",0.0,java
12au6kd,jeuurln,Java's [classpath](https://en.wikipedia.org/wiki/Classpath) also comes to mind.,0.0,java
12au6kd,jeuurln,Also look at [Java Modules](https://www.oracle.com/uk/corporate/features/understanding-java-9-modules.html) and [Rust Crates](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html).,0.0,java
12au6kd,jeuurln,Also look at [Java Modules](https://www.oracle.com/uk/corporate/features/understanding-java-9-modules.html) and [Rust Crates](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html).,0.0,rust
12au6kd,jeuvuh1,"Even so, you could do worse -- it's more-or-less what the C preprocessor does.",-0.4,c
12au6kd,jevlo6q,C++ comitee just approved to change from namespaces like Java to modules.,0.0,c++
12au6kd,jevlo6q,C++ comitee just approved to change from namespaces like Java to modules.,0.0,java
12au6kd,jevlo6q,Is it similar to C include files or PHP include files ?,0.0,c
12au6kd,jevlo6q,Is it similar to C include files or PHP include files ?,0.0,php
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,perl
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,php
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,python
12au6kd,jevpqm5,"Perl, PHP, Python, Ruby, etc all treat `import` as a command in the same genera as `print`.",0.0,ruby
12au6kd,jeuyy5h,"Python also allows local imports like that but I would fire any programmer who used it except in a very few special cases (lazy loading of modules, essentially).",-0.030571428571428572,python
12au6kd,jeuy1c5,How could you do worse than the C preprocessor?,-0.4,c
12au6kd,jevubks,"Actually, a [whole lot of things](https://futhark.readthedocs.io/en/latest/language-reference.html#module-system) can go in the right-hand side of a module binding, but I don't want to wander too far off into the weeds of higher-order module systems, as they are *not* the right choice for all languages.",0.19523809523809524,go
12au6kd,jev1sar,"If I use `m.f` in a single function in a class I write      class C     {         void g()         {             import m: f;             f(""HI"");         }     }  And if I use it in two functions in that class then I write      class C     {         import m: f;         void g()         {             f(""HI"");         }         void h()         {             f(""IH"");         }     }  etc...  > And then when you do centralize  Never!",-0.08928571428571427,c
12au6kd,jev1sar,""");     }  like you would in Java.",0.0,java
12au6kd,jev1sar,Yes but D works like Haskell and requires you to be more explicit about it.,0.5,d
12au6kd,jev1sar,Yes but D works like Haskell and requires you to be more explicit about it.,0.5,haskell
12au6kd,jeuz6yq,"It's actually a fun (if mildly frustrating) exercise to prove to yourself that the C processor cannot do anything significantly smarter than ""copy-paste the file"" without dropping some functionality.",0.09166666666666666,c
12alw4w,jesq07c,"Ruby grew in popularity around 2005 because it allows a ""natural language-style"" syntax for programming (which Rails took full advantage of).",0.22499999999999998,ruby
12alw4w,jesvt7x,"I mostly agree with all points, including point 1, but I'll notice that Lisp took ""make it easy for the parser"" to an extreme and it seems to me that that limited its reach.",0.1842261904761905,lisp
12alw4w,jettkuq,"But in fact I keep muttering that line from The Zen of Python to myself about how ""complex is better than complicated"" and putting in one more kludge to convert from the syntax the user would expect to the syntax my parser knows how to parse.",0.05,python
12alw4w,jettkuq,"(If you tell me about your cool idea about semantics I will consider stealing it but I will also think ""nope"".",0.35,cool
12alw4w,jex63j2,"For example, in Dart, local functions don't have a leading keyword.",0.0,dart
12alw4w,jex63j2,"It's just:      myLocalFunc(a, b, c, d, e, f) {       body;     }  In principle, these are difficult to parse.",-0.5,c
12alw4w,jex63j2,"It's just:      myLocalFunc(a, b, c, d, e, f) {       body;     }  In principle, these are difficult to parse.",-0.5,d
12alw4w,jex63j2,"I would still prefer if Dart had a leading keyword for functions, and I do think it's a good guideline to avoid unbounded lookahead unless you really love the syntax it enables.",0.6,dart
12alw4w,jex63j2,Do you do no inference like C++ before auto?,0.0,c++
12alw4w,jex63j2,Local inference like C#/Java/etc.?,0.0,c
12alw4w,jex63j2,Is the type system object-oriented with subtyping like Java?,0.0,java
12alw4w,jex63j2,Functional with algebraic datatypes like Rust?,0.0,rust
12alw4w,jex63j2,"Both, like Swift and Scala?",0.0,swift
12alw4w,jex63j2,"Both, like Swift and Scala?",0.0,scala
12alw4w,jex63j2,Are generics erased like Java and SML?,0.0,java
12alw4w,jex63j2,Reified like C# and Dart?,0.0,c
12alw4w,jex63j2,Reified like C# and Dart?,0.0,dart
12alw4w,jex63j2,Monomorphized like Rust?,0.0,rust
12alw4w,jex63j2,Or are they duck typed like templates in C++?,0.0,c++
12alw4w,jex63j2,Or with bounds like Java?,0.0,java
12alw4w,jex63j2,Traits like Rust?,0.0,rust
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,c++
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,c
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,kotlin
12alw4w,jex63j2,"But it turns out there is a lot of value in remixes: C++ is C + Simula, C is B + types, Kotlin is an evolved Java etc.",0.0,java
12alw4w,jex63j2,* C++ gave you object-oriented programming and generic programming while allowing incremental migration from C.  * C rode on UNIX's coattails.,0.0,c++
12alw4w,jex63j2,* C++ gave you object-oriented programming and generic programming while allowing incremental migration from C.  * C rode on UNIX's coattails.,0.0,c
12alw4w,jex63j2,* Kotlin is pushed by JetBrains and has amazing IDE integration.,0.6000000000000001,kotlin
12alw4w,jex63j2,* Objective-C was a gateway to iOS.,0.0,objective-c
12alw4w,jevjoek,J is APL in ASCII.,0.0,apl
12alw4w,jesyz2s,"In regards to Ruby, I don't think the Ruby syntax is special.",0.35714285714285715,ruby
12alw4w,jesvcy4,"Ruby grew in popularity around 2005 because it allows a ""natural language-style"" syntax for programming (which Rails took full advantage of).",0.22499999999999998,ruby
12alw4w,jesvcy4,Ruby had a syntax many considered elegant.,0.5,ruby
12alw4w,jesvcy4,Ruby took off with Rails.,0.0,ruby
12alw4w,jesvcy4,So did Ruby.,0.0,ruby
12alw4w,jetagzu,Assembly and BASIC may be even simpler to parse (EDIT: or nearly so).,0.05,assembly
12alw4w,jeywaqs,"> For example, in Dart, local functions don't have a leading keyword.",0.0,dart
12alw4w,jeywaqs,"After all isn't most language features we've ""invented"" in the last 30 years copies of things already in Algol 68?",0.25,algol
12alw4w,jeywaqs,Language features are mostly GCC C extensions people like to use.,0.5,c
12alw4w,jeywaqs,"Syntax changes are things already well tested in languages with C-like syntax, like C++ or Java.",0.0,c++
12alw4w,jeywaqs,"Syntax changes are things already well tested in languages with C-like syntax, like C++ or Java.",0.0,java
12alw4w,jetour1,> I don't think the Ruby syntax is special.,0.35714285714285715,ruby
12alw4w,jetour1,"While Ruby's syntax may not be compelling *to you*, it is compelling to many others.",0.3666666666666667,ruby
12alw4w,jet7gmc,I suspect Ruby faltered due to performance and lack of scalability.,-0.125,ruby
12alw4w,jet7gmc,"I know of at least 3 projects which started on Ruby on Rails, but later had to be completely reengineered when they failed to scale.",-0.175,ruby
12alw4w,jeuoa4x,"Assembly, maybe, but not if you're writing a real assembler, since those usually need to be able to use (constant) arithmetic expressions as operands, typically written in standard algebraic notation.",0.04722222222222222,assembly
12alw4w,jeuohb3,"Other people I think have mention Lisp, I could adduce Forth ...",-0.125,lisp
12alw4w,jeuohb3,"Other people I think have mention Lisp, I could adduce Forth ...",-0.125,forth
12alw4w,jewcdlx,"No language *needs* macros, but Haskell is lazy yet has a quite powerful and relatively widely used macro system in the form of Template Haskell.",-0.016666666666666673,haskell
12alw4w,jew7mt4,"But the other obvious solution is to use dot-ident like in C initializers:      x = foo(.count = a);  It is not as elegant, but as I started writing more code, I realized that scanning `x = foo(count = a)` was hard, I had to mentally flip things around ""oh it's not count = a, it's a named parameter assignment!"".",0.07638888888888888,c
12alw4w,jetu4dh,Ruby is really slow among slow languages.,-0.30000000000000004,ruby
12alw4w,jev3pgr,"Ah, sorry, I think I might've misunderstood - I thought you meant that BASIC or assembly might be simpler to parse than s-expressions.",-0.25,assembly
12alw4w,jewda35,Ruby is around Python speed these days ams improving a lot more with latest JITs,0.5,ruby
12alw4w,jewda35,Ruby is around Python speed these days ams improving a lot more with latest JITs,0.5,python
12alw4w,jfac43r,"It used to be much worse, and that’s why competitors could go in and duplicate I think.",-0.4,go
12alw4w,jfac43r,"I like Ruby much better than Python, so less Python and more Ruby would be a win in my book.",0.4083333333333333,ruby
12alw4w,jfac43r,"I like Ruby much better than Python, so less Python and more Ruby would be a win in my book.",0.4083333333333333,python
12afe2b,,"The main inspirations are Scopes, Penne, Rust and Markdown.",0.16666666666666666,rust
12afe2b,,"## Concise implementation  This implementation uses tags with parameters to be more concise:  ``` # Fib  - n  Match Compare n 2 - Less: Return 1  Loop c n, prev 1, result 1: Match Compare c 2 - More: Jump Loop Sub c 1, result, Sum result prev  result ```  ## Explanation  The header (""#"") defines the function name ""Fib"".",0.20666666666666664,c
12afe2b,,"``` # Fib  - n u32  Match Compare n 2 - Less: Return 1  Local c n, prev 1, result 1  Loop: Let next Sum prev result Set prev result Set result next  Match Compare n 2 - Less: Return result  Set c Sub c 1 Jump Loop ```  # The language  ## General information  - function names are also type names - most values evaluate to themself when called without parameters - you can only assign to references (like in Scopes)  ## Grammar  Toplevel: - `- [name] [type?",0.027083333333333334,c
12afe2b,jerzan2,Languages with C style syntax don't need indentation but their still used for readability.,0.0,c
12afe2b,jerx0fj,It looks like assembly.,0.0,assembly
12afe2b,jeswk2y,"Let's all go back to assembly/C, use goto for everything, and not use indentation.""",0.0,go
12afe2b,jert0xe,"I personally wouldnt use this but i respect your time and effort into this, maybe make a little mockup in python or smth.",-0.09375,python
12afe2b,jes89oz,Like Python.,0.0,python
12afe2b,jes89oz,"C programs are famous for these, but coerced identation is not the solution.",0.5,c
12afe2b,jes89oz,"C standard just did the opposite, just confirmed ""bool"", ""false"", ""true"" as official keywords instead of macros.",0.06999999999999998,c
12afe2b,jes89oz,"Extended ""if"" like ""elif"", Pascal's ""case+of"" or C ""switch+case"", ""select"", may help.",0.0,pascal
12afe2b,jes89oz,"Extended ""if"" like ""elif"", Pascal's ""case+of"" or C ""switch+case"", ""select"", may help.",0.0,c
12afe2b,jes89oz,"And explicit end-less loop like you mentioned, instead of a ""for (;true;) { ... }"" of C like ""loop { }"", also a good idea, some P L. (s) already have it.",0.4333333333333333,c
12afe2b,jes89oz,"C and Pascal does keep ""go-to"" for teaching control structure, but their communities suggest use the others.",0.0,c
12afe2b,jes89oz,"C and Pascal does keep ""go-to"" for teaching control structure, but their communities suggest use the others.",0.0,pascal
12afe2b,jes89oz,"doesn't allow variable declarations outside a function, Java and C#, doesn't outside a class or class function ( a method ).",0.0,java
12afe2b,jes89oz,"doesn't allow variable declarations outside a function, Java and C#, doesn't outside a class or class function ( a method ).",0.0,c
12afe2b,jes89oz,"C allows them as ""global vars"".",0.0,c
12afe2b,jes89oz,Check good old style Pascal.,0.39999999999999997,pascal
12afe2b,jev1t4r,use assembly bruh,0.0,assembly
12afe2b,jes2lxc,I'll have to go on some long walks while pondering on that one.,-0.05,go
12afe2b,jew1j5s,">not indentation based  Other than Python, what languages are indentation based?",-0.125,python
12afe2b,jesd1is,"This would be nice, too; but this only works if indentation doesn't contain information (like in Python), and we should probably have autoformatting, too ;)  Doing the version control not on the text, but on the AST might also be interesting.",0.3375,python
12afe2b,jesd1is,"People using GC languages also might think, C is backwards, just because it doesn't use GC.",0.0,c
12afe2b,jesf08l,"I also thought, it looks pretty much like assembly.",0.225,assembly
12afe2b,jerus73,In Rust I already used compare and match when I wanted different things to happen for all three cases.,0.0,rust
12afe2b,jerus73,And match in Rust is pretty cumbersome.,0.25,rust
12afe2b,jeshkgg,"When programming in Rust, I already have to do multiple matches.",0.0,rust
12afe2b,jeshkgg,"But the problem with the Rust match is, it almost always causes the level of indentation to increase by two instead of one.",0.0,rust
12afe2b,jeshkgg,"Match can even reduce nesting:  ```Rust match (a, b, c) {     (true, true, false) => ...,     (true, false, _) => ...,     (_, _, true) => ...,     ... } ```  >It effectively makes calls first class objects.",0.18124999999999997,rust
12afe2b,jeshkgg,"Match can even reduce nesting:  ```Rust match (a, b, c) {     (true, true, false) => ...,     (true, false, _) => ...,     (_, _, true) => ...,     ... } ```  >It effectively makes calls first class objects.",0.18124999999999997,c
12afe2b,jeshkgg,"It's like C++, but the only function you are allowed to define is the `()` operator.",0.0,c++
12afe2b,jf2r6nw,">It can be interpreted too for real time coding  I thought of it as a language at a similar level as C, just like the inspiration languages.",0.1,c
12afe2b,jewpuzr,Assembly isn't cross platform and doesn't support macros or generics.,0.0,assembly
12afe2b,jewpuzr,But a cross platform assembly with high level abstractions is basically what I think a good language should be like.,0.2866666666666667,assembly
12afe2b,jewshm4,">Other than Python, what languages are indentation based?",0.0,python
12afe2b,jewluss,Maybe it could become Lisp without parentheses ;),0.25,lisp
12afe2b,jeslbed,"The purpose of all these fancy computer languages is to convey the meaning of a program to _other humans_; if you just want to talk to a machine, there's already machine code and LISP, and literally everything else is about aesthetics.",-0.125,lisp
12afe2b,jevdw7j,"For everything else, we have basically every other programming language made over the last 3 decades that aren't C or assembly that come with more goodies to help with creating code quicker, with less errors, and with more intention imparted to the reader.",0.14166666666666666,c
12afe2b,jevdw7j,"For everything else, we have basically every other programming language made over the last 3 decades that aren't C or assembly that come with more goodies to help with creating code quicker, with less errors, and with more intention imparted to the reader.",0.14166666666666666,assembly
12afe2b,jesnh3u,"Even as a fan of assembly, I would never find myself working in this language voluntarily.",0.0,assembly
12afe2b,jewre5r,>C or assembly  Being close to C in terms of simplicity and features is the point.,0.0,c
12afe2b,jewre5r,>C or assembly  Being close to C in terms of simplicity and features is the point.,0.0,assembly
12afe2b,jesblxn,After looking over my idris code I wrote today and some haskell code I would say I have to think more about what exactly makes those languages more or less readable.,0.2708333333333333,haskell
12afe2b,jp0f839,The stimulus was short Python programs that solve leetcode easys.,0.0,python
12a2e1u,,"print         0     }  FizzBuzz - The classic fizzbuzz, here it is possible to see the inverse-lisp approach, I tried to avoid any digraphs or complex symbols for math for the sake of simplicity, but it could be added with a special evaluator like ""$=""      fizzbuzz :: i32 -> str :: n => {         (15 3 5) n %   // Makes an array literal and applies mod ""n"" over it         0 =  // Compares the result array against 0         1 index // Finds the index that matches ""1""         // Result array literal, swaps with the index for ""at"" to retrieve the proper element         (""FizzBuzz"" ""Fizz"" ""Buzz"" n:str) swp at       }          main :: [str] -> i32 :: args => {         // Read as ""get args, push the index 0 of it as i32         // Make a generate from 0 to this number and apply fizzbuzz over it         // then print and return 0         args 0 at:i32 iota fizzbuzz print         0     }  Factorial - This one made me question if I should or not implement the haskell function pattern matching.",-0.01994047619047619,haskell
12a2e1u,,"I feel like it is a good idea, but I'm interested in second opinions      // Stack Style     fac :: i32 -> i64 :: n => {         n 2 = not         n 1 - fac 2 branch         n *     }          // Haskell Style     fac :: i32 -> i64 :: n     fac 2 => 2     fac n => n 1 - fac n *          main :: [str] -> i32 :: args => {         // Equivalent to Python: print(fac(int(args[0])))         args 0 at:i32 fac print          0     }  Div by zero - This is the first draft for ADTs and unwraping      Maybe a = Just a | Nothing      // Stack Style     div :: i32 -> i32 -> Maybe(f32) :: a b => {         b 0 = not         a b / Just         Nothing         branch     }          // Haskell Style     div :: i32 -> i32 -> Maybe(f32)     div a 0 => Nothing     div a b => a b / Just          main :: [str] :: args => {         args split div         (Just unwrap:str)         (Nothing ""DIV/0 ERROR"")         match         print         0     }",0.004166666666666666,haskell
12a2e1u,,"I feel like it is a good idea, but I'm interested in second opinions      // Stack Style     fac :: i32 -> i64 :: n => {         n 2 = not         n 1 - fac 2 branch         n *     }          // Haskell Style     fac :: i32 -> i64 :: n     fac 2 => 2     fac n => n 1 - fac n *          main :: [str] -> i32 :: args => {         // Equivalent to Python: print(fac(int(args[0])))         args 0 at:i32 fac print          0     }  Div by zero - This is the first draft for ADTs and unwraping      Maybe a = Just a | Nothing      // Stack Style     div :: i32 -> i32 -> Maybe(f32) :: a b => {         b 0 = not         a b / Just         Nothing         branch     }          // Haskell Style     div :: i32 -> i32 -> Maybe(f32)     div a 0 => Nothing     div a b => a b / Just          main :: [str] :: args => {         args split div         (Just unwrap:str)         (Nothing ""DIV/0 ERROR"")         match         print         0     }",0.004166666666666666,python
12a2e1u,jeq8jvo,`Maybe` type: ```rust enum struct Maybe<T> {     T: Just     []: Nothing }  fn my_div(u64: a u64: b) -> [Maybe<u64>] {     b 0 == if {         Maybe::Nothing     } else {         a b / cast(Maybe::Just)     } } ```,0.75,rust
12a2e1u,jeqmt5h,"The Haskell style seems dramatically more concise and readable, though it's less consistent with the rest of the language; replacing it with a `case`/`match` construct could make it more consistent and obviate the need for computing values ahead of time (which interferes with recursion).",0.2388888888888889,haskell
12a2e1u,jf0lwj1,"If you're going to do a stack language, I think avoid what looks like Haskell.",0.0,haskell
12a2e1u,jf0lwj1,"You seem to have type-declarations, and they look like Haskell.",0.0,haskell
12a2e1u,jf0lwj1,Are you familiar with the comment-convention in Forth for illustrating the *stack-effect* of each word?,0.375,forth
12a2e1u,jf0lwj1,Forth has `then` / `else` / `if` compiling-words which I see no analogy to.,0.0,forth
12a2e1u,jerbog4,This makes reading it slightly closer to reading a lisp.,-0.16666666666666666,lisp
12a2e1u,jeq9n2w,"It does look indeed like a lot of ideas are aligned, although I'm not super proficient with Rust, that could be a good learning opportunity",0.26666666666666666,rust
12a2e1u,jeqa5lf,I'm more than willing to help with rust as needed (if i'm not swamped with actual work),0.25,rust
129uw2a,,"My idea for a language (it's must be language, because it will be patching Javascript and PHP's craziness (unlike ts which just make typing static)).",0.5,javascript
129uw2a,,"My idea for a language (it's must be language, because it will be patching Javascript and PHP's craziness (unlike ts which just make typing static)).",0.5,php
129uw2a,,"**No nulls, because, it's the cool thing in Rust (I really am not sure how it handles it)**   2.",0.04999999999999999,cool
129uw2a,,"**No nulls, because, it's the cool thing in Rust (I really am not sure how it handles it)**   2.",0.04999999999999999,rust
129uw2a,,**Compiles down to PHP (ReactPHP for asynchronous) and Javascript (for the frontend).,-0.15555555555555559,php
129uw2a,,**Compiles down to PHP (ReactPHP for asynchronous) and Javascript (for the frontend).,-0.15555555555555559,javascript
129uw2a,,"**   Typescript can already do the Javascript part, but this language should be able to do both static and strong type checking.",0.4777777777777778,typescript
129uw2a,,"**   Typescript can already do the Javascript part, but this language should be able to do both static and strong type checking.",0.4777777777777778,javascript
129uw2a,,**Error handling fashioned like Rust.,0.0,rust
129uw2a,,"So this language should be able to deal with that, either in Rust-fashion, or Java checked exceptions.",0.5,java
129uw2a,,"**Fully built around RxJS**, which I admit, may be a very big stumbling block for beginners, but here's how a code snippet would look like (a little like Angular... and with **@ Input** as **observables**):      component Product {         constructor (private ProductService productService) {}              // Starts off as { loading: true }, and finally emits as         //{ loading: false, success: true, data: T }         response$ = #purchaseButton.click$.pipe(             throttleTime(1000),             switchMap(() => productService.makePurchase()),         )              // here's where HTML goes         !",0.08333333333333331,html
129uw2a,jeq75qs,"Instead of compiling to JS & PHP, just pick one.",0.0,php
129uw2a,jeq9v9x,Agree but I may not heed the advice :D 4.,1.0,d
129uw2a,jeq9v9x,"I figured we could do so like C#, completely drop .pipe()    1.",0.1,c
129uw2a,jesgxvm,"Just trying to show that if you're creating this new cool thing, you don't have to be bound by the existing syntax of JavaScript!",0.2869318181818182,cool
129uw2a,jesgxvm,"Just trying to show that if you're creating this new cool thing, you don't have to be bound by the existing syntax of JavaScript!",0.2869318181818182,javascript
129motb,jeoq4n9,"Start doing videos with titles as ""improved C"" ""the better C++"" ""downsized c++"" and so on, so you appear in more searches for ppl that appeal to this language.",0.5,c
129motb,jeoq4n9,"Start doing videos with titles as ""improved C"" ""the better C++"" ""downsized c++"" and so on, so you appear in more searches for ppl that appeal to this language.",0.5,c++
129i9zd,,"BUT, it is possible in C# (which is very close to TS) with extension methods.",0.1,c
129i9zd,,"},     			StringSplitOptions.RemoveEmptyEntries     		).Length;     	}     }  Here's how you use it:      class Program{         public static void Main(string[] args){             int wordCount = ""meme meeme meemeee"".WordCount();         }     }  It's defeintely more verbose than Rust, but that's just c# as a language.",0.3333333333333333,rust
129i9zd,,"},     			StringSplitOptions.RemoveEmptyEntries     		).Length;     	}     }  Here's how you use it:      class Program{         public static void Main(string[] args){             int wordCount = ""meme meeme meemeee"".WordCount();         }     }  It's defeintely more verbose than Rust, but that's just c# as a language.",0.3333333333333333,c
129i9zd,jenqb09,"Another thing that the extension methods lack that struct impls give you (like… by definition) is that you cannot implement an interface using extension methods, and C# does not have structural typing.",0.0,c
129i9zd,jenhhfc,"In the C# approach, it is done with vtables, where your object has attached to it a pointer to a vtable for every interface it implements.",0.0,c
129i9zd,jeozu2x,"As noted in some of the other responses, it's fairly safe for the compiler to assume that a certain arbitrary function `R f(T, ...)` can be used in a situation in which a method on `T` is required with the signature `R f(...)` (where `...` represent 0 or more specific parameters).",0.16488095238095238,r
129i9zd,jeozu2x,"Languages like Scala have been doing this trick for years: https://docs.scala-lang.org/scala3/reference/contextual/extension-methods.html  I had used the same trick in past work, and found that a number of languages were calling it a _trait_ (although there are lots of terms, and no two languages agree on what any one term means).",-0.125,scala
129i9zd,jeozu2x,"Instead of using ""auto detection"" like in the Scala extension method example (where just having the extension method ""visible"" to the compiler makes it eligible for use), traits typically need to be explicitly glued onto a class.",-0.16666666666666666,scala
129i9zd,jeozu2x,"Starting with the Scala example from the link above (and apologies if ""old reddit"" messes up the formatting):  ``` case class Circle(x: Double, y: Double, radius: Double)  extension (c: Circle)   def circumference: Double = c.radius * math.Pi * 2 ```  A trait would look something like this:  ``` trait CircleEx : Circle   def circumference: Double = c.radius * math.Pi * 2   def area: Double = c.radius * c.radius * math.Pi ```  It's like a sub-class, but instead of being a concrete sub-class with a super, it's an extension to any class that happens to be ""_is a_"" Circle.",0.053030303030303025,scala
129i9zd,jeozu2x,"Starting with the Scala example from the link above (and apologies if ""old reddit"" messes up the formatting):  ``` case class Circle(x: Double, y: Double, radius: Double)  extension (c: Circle)   def circumference: Double = c.radius * math.Pi * 2 ```  A trait would look something like this:  ``` trait CircleEx : Circle   def circumference: Double = c.radius * math.Pi * 2   def area: Double = c.radius * c.radius * math.Pi ```  It's like a sub-class, but instead of being a concrete sub-class with a super, it's an extension to any class that happens to be ""_is a_"" Circle.",0.053030303030303025,c
129i9zd,jeozu2x,"We bind mixins to a class using the `@` annotation concept, loosely stolen from Java I think:  ``` return schema.enablePointers         ?",-0.07692307692307693,java
129i9zd,jeozu2x,"It provides all of the benefits of C++ multi-inheritance, but none of the downsides (like the diamond problem).",0.0,c++
129i9zd,jenh6ti,"Struct impls in Rust can't attach additional methods in foreign crate, trait impls can and it's different functionality than linked post asks about.",-0.0625,rust
129i9zd,jep9n89,C# extensions that can implement interfaces are on the way.,0.0,c
129i9zd,jeowea4,This is more a C#-related issue than an extension-related one.,0.5,c
129i9zd,jeowea4,"C# also have you write those ""extension methods"" in a different and **static** ""class.""",0.25,c
129i9zd,jeowea4,"C# also actually does have something called ""namespace"" which is, somehow, entirely unrelated to the subject at hand.",-0.05555555555555555,c
129i9zd,jeowea4,"Oh and C# also actually supports writing functions outside classes, such as in functions, but not in namespaces, just to blow your mind.",0.0,c
129i9zd,jeowea4,"Anyway, [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/) and [Scala](https://docs.scala-lang.org/scala3/book/ca-extension-methods.html) both allow extensions to implement interfaces.",0.0,swift
129i9zd,jeowea4,"Anyway, [Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/) and [Scala](https://docs.scala-lang.org/scala3/book/ca-extension-methods.html) both allow extensions to implement interfaces.",0.0,scala
129i9zd,jeowt8h,That's cool.,0.35,cool
129i9zd,jeozrs0,"In C#, the dispatch is per object, i.e.",0.0,c
129i9zd,jeoxzp8,Extension methods are not the problem in C#.,0.0,c
129i9zd,jep15uy,">C# also actually supports writing functions outside classes, such as in functions, but not in namespaces  You're talking about the Main() function?",0.041666666666666664,c
129i9zd,jep15uy,"I think that's the only place where that's possible, although I haven't heavily used the latest version of .NET Core and C#, so I'm not sure.",0.009999999999999998,c
129i9zd,jepc0a0,"In Rust, a function can accept a type which implements multiple traits, if that's what you mean, e.g.",-0.15625,rust
129i9zd,jep3svg,"Those have been around since C#7, 6 years ago.",0.0,c
129i9zd,jesbd04,Do you think the main issue is the same syntax and having a different syntax (or other tooling; IntelliJ highlights extension methods in Kotlin in italics) would alleviate it?,0.010416666666666664,kotlin
1292vwo,,"I guess some options could be having to explictly anotate that a variable is going to be passed implicitly into functions: ``` fun game() {   let implicit world = World::new();   spawn(Entity::Zombie); // world here is taken implicitly } ```  Also not sure if ""implicit""/""imply"" are the best keywords  EDIT: what Scala does seems closer to what i had in mind.",0.16249999999999998,scala
1292vwo,jellrcv,Scala probably has the most popular implementation -- they even have their own implicit calculus IIRC -- but most theorem provers and (hopefully) future versions of OCaml have something similar.,0.3666666666666667,scala
1292vwo,jellrcv,"Haskell also has these under the ImplicitParams language extension, where they are implemented in terms of type classes (in a pretty hacky way IMO).",0.25,haskell
1292vwo,jelw681,"For example, in Scheme:          (define world1 ...)      (define world (make-parameter world1))      (define (spawn entity) (world-add-entity (world) entity))      (spawn zombie1) ;; adds zombie1 to world1  You can temporarily change the value of world for a given scope, and it will revert back to its previous value once this dynamic scope exits.",-0.22916666666666666,scheme
1292vwo,jelpi5s,"I remembered my frustration refactoring a C library a few years ago where I was splitting long functions up into smaller ones, how often I ended up with long argument lists for functions which only existed to split the code up.",-0.06,c
1292vwo,jemaeqv,"From Java patterns, we learn that at about four parameters, a function becomes unmaintainable.",0.0,java
1292vwo,jenowgd,Swift recently introduced task-local values.,0.0,swift
1292vwo,jenowgd,In Swift you can write something like this:      struct Game { // Just a namespace         @TaskLocal static var world: World?,0.04999999999999999,swift
1292vwo,jeoajpz,"spawn Entity.Zombie)  Here I'm writing `a -> b => c` to mean _""takes `a`, returns `b`, raises/does `c`,""_ and I'm explicitly marking `WorldDI` as `linear` since it always invokes its continuation.",-0.3125,c
1292vwo,jeoajpz,An effect handler essentially transforms a function of type `a -> b => c` into `a -> d`.,0.0,c
1292vwo,jeoajpz,An effect handler essentially transforms a function of type `a -> b => c` into `a -> d`.,0.0,d
1292vwo,jeoajpz,"However, unlike Scala's implicit parameters, this all can be inferred by a compiler (as in, an intermediary function `f` in a call stack `handler(E); f; g raised E;` does not have to explicitly declare the `E` type), this, in turn, allows individual functions to compose with each other.",-0.0625,scala
1292vwo,jeoajpz,This wouldn't work in Scala where `map` would need to itself be aware of `Log`.,0.25,scala
1292vwo,jf2i6y2,"I don't think this actually works well (and controversially, that includes Scala's implementation).",0.275,scala
1292vwo,jf2i6y2,You can still sort of trace implied arguments in Scala but it's traced a different way from everything else.,0.0,scala
1292vwo,jemqerq,Worth noting but implicit functions in scala could sometimes finish in some very confusing stuff happening depending on scopes of imports etc.,-0.04500000000000001,scala
1292vwo,jemqerq,"So they reworked it to a system called ""given and using"" to provide the same functionality in Scala 3.",0.0,scala
1292vwo,jemamzl,Idris2 has something like this - the magic happens if they're marked \`auto\` or use a fat arrow like in haskell (which is sugar for an auto implicit).,0.3,haskell
1292vwo,jfk0oz3,"I also want my language to have something similar to typeclasses (which I'm trying to conceptualize as adhoc modules), so the way Scala has using/given to deal with that could also work for me",0.0,scala
1292vwo,jemezhq,"> From Java patterns, we learn that at about four parameters, a function becomes unmaintainable.",0.0,java
1292vwo,jemtcwt,"yeah, that final design is very similar to what i was thinking about, but it's not it  it seems in that case the caller would have no control over what actually gets passed into that function, where i want to pass something invisibly  what Scala does is actually much closer to what i meant",0.05,scala
1292vwo,jemeus6,"Scala doesn't answer your question, though.",0.0,scala
1292vwo,jeo2l5b,"If I understand what you're asking correctly, this seems to be exactly what Kotlin's context receivers are:  https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md",0.25,kotlin
128waxk,,"C itself has been widely castigated for being too low level and unsafe, especially in a forum like this which prefers its languages a few levels higher.",-0.010000000000000009,c
128waxk,,Yet C is still tremendously popular for many reasons.,0.55,c
128waxk,,"(I find it annoying that C is associated with low-level programming, that people talk about C-APIs, or even C-ABIs, or C-level types, and describe it as the closest thing to the hardware, as though C had invented low level.",-0.4,c
128waxk,,Yet C doesn't even have a 8-bit byte type!),0.0,c
128waxk,,Can any of them offer an implementation that matches Tiny C's 250KB compiler?,0.0,c
128waxk,,"\[My generated C code requires only 180KB `tcc.exe` plus one of its libraries to build.\]  So, I won't say try harder; how about trying less!",-0.10277777777777779,c
128waxk,,In my case 80% of the issues with C are its syntax; and most C alternatives have the same syntax more or less.,0.20833333333333334,c
128waxk,,"My own systems language, is another private one (I can't support it) that I've always used in place of C. Below I've listed 35 or so differences and enhancements to C (I could write 50 more), and yet it is not much higher level.",0.24375000000000002,c
128waxk,,In C functions are not marked at all; you have to infer where they are!,-0.0625,c
128waxk,,No micromanaging visibility via combinations of C's 30 standard headers.,0.0,c
128waxk,,"`u64` rather than 16 combinations of `long long unsigned [int]`) (C has `uint64_t` in stdint.h, but not really supported by the rest of the language.)",-0.06666666666666667,c
128waxk,,"* Default 64-bit ints and floats (C could have 64-bit `int`, but is typically 32 bits, which means 32-bit literals and a discontinuity between 32 and 64 bits) * Separate Pointers and Arrays.",-0.16666666666666666,c
128waxk,,"(If `P` is a pointer-to-array in C, you need `(*P)[i]` to access an element: deref then index.",0.0,c
128waxk,,But C also allows `*(P[i])`: index then deref.,0.0,c
128waxk,,"C offers some combination of `#define`, `enum`, `const`, and soon `constexpr`, none of which tick all the boxes * Table data: initialise parallel arrays, and optional enums, in table form.",0.05,c
128waxk,,C requires hideous 'x-macros\` to do a similar thing * Bit and bitfield accesses: `A.,0.0,c
128waxk,,"* Chained comparisons: `if a = b = c`; range checks: `if a in b..c`, and check against N values: `if a in [b, c, d]` * Extra built-in ops such as `max`, `max:=`, and fully overloaded `**` and `abs`.",0.0,c
128waxk,,"* Chained comparisons: `if a = b = c`; range checks: `if a in b..c`, and check against N values: `if a in [b, c, d]` * Extra built-in ops such as `max`, `max:=`, and fully overloaded `**` and `abs`.",0.0,d
128waxk,,"* Far less UB than in C * Compiler options to run directly from source, or produce a single amalgamated source file for a whole application.",0.032380952380952385,c
128waxk,jel1823,Oddly enough pascal is a credible replacement for C and has always been.,0.2,pascal
128waxk,jel1823,Oddly enough pascal is a credible replacement for C and has always been.,0.2,c
128waxk,jekpn6p,"C2 is just a tiny addition on top of C, C3 has more, but not that much more - additions are mainly based on GCC extensions to C. Odin is not huge either.",0.24444444444444446,c
128waxk,jemano9,It’s not hard to be better than C.  It’s hard to be _enough_ better than C to displace C.  Rust shows some promise.,0.17083333333333334,c
128waxk,jemano9,It’s not hard to be better than C.  It’s hard to be _enough_ better than C to displace C.  Rust shows some promise.,0.17083333333333334,rust
128waxk,jemano9,I recommend reading Dennis Ritchie’s paper on C from the second History of Programming Languages conference around 1993 (HOPL-II).,0.0,c
128waxk,jemano9,"I was lucky enough to hear his talk, and I left with a great appreciation for what he was trying to do with C and how well he succeeded.",0.2833333333333333,c
128waxk,jemano9,That was the day I stopped being a C hater.,0.0,c
128waxk,jemano9,"And OP, isn’t C++ _the_ mainstream alternative to C.  I have a few colleagues who are always nattering that I should be using it instead of C.  They haven’t convinced me.",-0.2,c++
128waxk,jeksgwz,Zig or Rust,0.0,rust
128waxk,jekzv62,We don't have C replacements so to speak because the need isn't really there.,0.2,c
128waxk,jel2vjk,Odin is a great C replacement in my opinion.,0.8,c
128waxk,jemdsjx,"Forth might be viable as an alternative for some things, Rust for others.",0.0,forth
128waxk,jemdsjx,"Forth might be viable as an alternative for some things, Rust for others.",0.0,rust
128waxk,jemdsjx,Pascal and Fortran were competitors in the same spaces at one time as well as some variants of Basic (I wrote a good amount of PBasic at one point).,0.2333333333333333,pascal
128waxk,jemdsjx,Pascal and Fortran were competitors in the same spaces at one time as well as some variants of Basic (I wrote a good amount of PBasic at one point).,0.2333333333333333,fortran
128waxk,jemdsjx,"The problem at this point is that C is actually pretty hard to beat, for some non-obvious reasons:  1.",-0.020833333333333343,c
128waxk,jemdsjx,"For example, there was a blog post I saw recently about working through *Crafting Interpreters* using Rust, and the author pretty quickly had to dip into unsafe Rust to be able to achieve anything resembling the same performance.",0.21666666666666665,rust
128waxk,jemdsjx,"And if you're using unsafe, a lot of Rust's reason for existence gets thrown out the window.",0.0,rust
128waxk,jemdsjx,"If you're just using C to write an intepreter for your high-level language, that doesn't matter and so C's design, but there are a lot of lower-level portability situations where that matters quite a bit.",0.0,c
128waxk,jemdsjx,The ecosystem of C is vast and more pervasive than you can imagine.,0.25,c
128waxk,jemdsjx,The processor you're viewing this page on was literally built with optimizations on C idioms built into the physical silicon.,0.0,c
128waxk,jemdsjx,"There are a lot of mistakes C made in design, but at this point you'll have to copy those mistakes to interop with the world which has also copied those mistakes when it isn't just written in C.",0.0,c
128waxk,jekooj8,Rust is the primary C alternative and is even accepted in the Linux kernel now.,0.4,rust
128waxk,jekooj8,Rust is the primary C alternative and is even accepted in the Linux kernel now.,0.4,c
128waxk,jekooj8,"The most interesting thing about C isn't it normal programming applications, but rather it's place as the underlying language for many programming languages.",0.4125,c
128waxk,jekooj8,"Python for example is written in C. So in many ways, python is a replacement for C when you need to do higher level tasks.",0.375,python
128waxk,jekooj8,"Python for example is written in C. So in many ways, python is a replacement for C when you need to do higher level tasks.",0.375,c
128waxk,jen9frf,I am Not into low level stuff so this might be obviously you but it is not to me - why is forth never considered??,0.0,forth
128waxk,jen9frf,Seemed capable of carrying all the c workloads,0.2,c
128waxk,jekvx4p,In C functions are not marked at all; you have to infer where they are!,-0.0625,c
128waxk,jekvx4p,"---------  What I'm doing:  I'm working on Yaksha as kind of a C replacement (at least for me personally), it compiles to C too.",0.09999999999999999,c
128waxk,jekuryi,"You'd get some of those features in D, but it's much more C-like than what you've described.",0.5,d
128waxk,jeo461t,"C closesed competitor used to be Pascal and Modula, but the emerging dominance of the C-based Unix systems and the lack of standartisation beyond a teaching focussed subset allowed C to beat them decisively.",0.0,c
128waxk,jeo461t,"C closesed competitor used to be Pascal and Modula, but the emerging dominance of the C-based Unix systems and the lack of standartisation beyond a teaching focussed subset allowed C to beat them decisively.",0.0,pascal
128waxk,jeo461t,"Rust reignited an interest in low level languages and a few C likes have popped up, with Zig (which is however not that similar, if you think about it) on the top.",0.075,rust
128waxk,jeo461t,"Rust reignited an interest in low level languages and a few C likes have popped up, with Zig (which is however not that similar, if you think about it) on the top.",0.075,c
128waxk,jeo461t,"The only languages that really took of in the recent years are does that managed to provide some benefit even a manager could gasp (like Rust with its memory savety or Python with it's good support for scientific, but also data processing capabilities.)",0.22499999999999998,rust
128waxk,jeo461t,"The only languages that really took of in the recent years are does that managed to provide some benefit even a manager could gasp (like Rust with its memory savety or Python with it's good support for scientific, but also data processing capabilities.)",0.22499999999999998,python
128waxk,jekz2rs,"The ""begin end"" was **carefully studied and designed** by it's Pascal inventor Nicklaus Wirth, as **code encapsulation**, several lines of code been encapsulated as a single concept.",-0.05714285714285714,pascal
128waxk,jekz2rs,"There are other ways, like lambda parentheses style or space identation style like Python or keyword plus end keyword like Basic's ""for end for"" that other P.L.",-0.08333333333333333,python
128waxk,jekz2rs,"I learned Basic first, later Pascal and C, and lambda style LISP.",0.08333333333333333,pascal
128waxk,jekz2rs,"I learned Basic first, later Pascal and C, and lambda style LISP.",0.08333333333333333,c
128waxk,jekz2rs,"I learned Basic first, later Pascal and C, and lambda style LISP.",0.08333333333333333,lisp
128waxk,jekz2rs,"I also learned a version of Basic that was space idented just like Python does this days, and although I like code to be idented for clarity reasons, ...  ...",0.0,python
128waxk,jekz2rs,I disagree to use Python or any P.L.,0.0,python
128waxk,jekz2rs,"**  All code that I do in other non python P.L., try to be idented an clear.",-0.01249999999999999,python
128waxk,jekz2rs,"**  If you or any developer needs close access to the processor (s), motherboard, or O.S., it should be a P.L., than like C uses pointers, can't pass or returns parameters that aren't bigger than a CPU's register.",0.0,c
128waxk,jekz2rs,"Otherwise, Pascal and other P.L.",-0.125,pascal
128waxk,jekz2rs,"**A lot of developers want the features of a C, without it's pitfalls.",0.0,c
128waxk,jekz2rs,**  Which are some of C's pitfalls besides using semicolons and braces ?,0.0,c
128waxk,jekz2rs,"There have been requested those types to be added to JS and Java, cause in some cases, they may interact with A.P.I.",0.0,java
128waxk,jekz2rs,"So, a C alternative should consider this.",0.0,c
128waxk,jekz2rs,Rust did.,0.0,rust
128waxk,jekz2rs,"This is one of oddest things that C doesn't have as an standard, even if it's a very ""close to hardware"" feature.",0.1,c
128waxk,jekz2rs,"A C alternative should have this implemented as an standard in the P.L., syntax, libraries and compiler.",0.0,c
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,pascal
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,c
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,c++
128waxk,jekz2rs,"This is well defined in Pascal, and other C variants like JS, C++, C# and Java itself.",-0.125,java
128waxk,jekz2rs,"But not C, due backward compatibility.",0.0625,c
128waxk,jekz2rs,"**Instead of suggesting C alternatives, I started mention the features that a valid C P.L.",0.0,c
128waxk,jet3wzp,"Here are some characteristics of C (from a deleted post in response to a specific suggested language, but I feel are worth listing generally):  * It has a primitive type system that more or less matches current hardware * It allows unrestricted conversions between any types (except, oddly, between object and function pointers, but that can be bypassed easily) * It allows untagged, unchecked unions * It allows type punning * Its type system is used in the APIs of 1000s of libraries and is low level enough to be accessed from many higher level languages (eg.",0.1416666666666667,c
128waxk,jet3wzp,"I can use those libraries from my interpreted, dynamic language) * It can be implemented for a modern PC in 180KB for the compiler (Tiny C; my attempt was 360KB) * It can be compiled at 1 million lines per second on a modest PC with a single core (again tcc) * It has raw pointers and `goto`; basic building blocks, that allow you express anything, and which simplify using this as a transpilation target * It is small and simple enough for someone to feel like they understand the language and can write code they can be confident about  The picture is one of a small, flexible, lightweight, manageable and dependable tool, which doesn't try to do too much (like a pencil, or a screwdriver).",0.0141287284144427,c
128waxk,jet3wzp,"However, C itself has many issues.",0.5,c
128waxk,jf12n4t,">My own systems language, is another private one (I can't support it) that I've always used in place of C. Below I've listed 35 or so differences and enhancements to C  On one side you list enhancements over C, that your systems language has, and on the other side you state that you can't support it.",0.15833333333333333,c
128waxk,jf4wkku,In short: C is too adequate in its domain.,0.16666666666666666,c
128waxk,jf4wkku,"It is easy to get wrong, but if you manage to play by the rules then C rules the world with truth and grace.",-0.033333333333333326,c
128waxk,jf4wkku,(Let Earth receive her C!),0.0,c
128waxk,jekyb94,"Pascal was a C alternative, but sadly other circumstances killed its usage and ""C won"".",-0.1625,pascal
128waxk,jekyb94,"Pascal was a C alternative, but sadly other circumstances killed its usage and ""C won"".",-0.1625,c
128waxk,jekyb94,"A lot of people claim to work on C alternatives, upgrades or fixes, but ultimately end up with a language that is really unlike C. I would say that perhaps Zig is closest to a C alternative, but the language has drifted away from C's philosophy quite a bit (which is not necessarily bad, it's just that it's a different kind of language).",0.22999999999999998,c
128waxk,jekyb94,"I'm trying to create a C alternative myself, but I'm convinced at this point that I'll end up with a completely different language.",0.0,c
128waxk,jekyb94,"✅ - Arrays with value semantics ❌ (lol, code smell) - Slices ✅ (but not first-order) - Properties such as... ❌✅ (handled differently) - Built-in read and print statements ❌ (lol, platform dependent and potentially completely absent on some platforms) - Functions: keyword parameters and optional parameters with default values ✅ - Reference parameters ✅ - Multiple function return values ❌✅ (done with array/tuple under the hood) - and multiple assignments ❌ (lol, code smell) - Expresson-based [sic]: statements and expression are interchangeable ❌ (lol, code and design smell) - Named constants ❌✅ (not handled explicitly) - Table data ❌ (LOL, the language would DEFINITELY not be a C alternative if this was built in) - Bit and bitfield accesses ✅ - Embedded text and binary files ❌ (biggest code smell I have heard of, YIKES) - Chained comparisons ❌ (have a better way of doing it) - range checks ✅ (but general solution) - check against N values ✅ (also general solution) - Extra built-in ops ❌ (everything but basic binary ops is opt-in) - Far less UB than in C ✅ (but depends on what far less means) - Compiler options to run directly from source ❌ (the compiler is not an interpreter or launcher, infeasible given how long some compilation times are potentially) - produce a single amalgamated source file for a whole application ❌ (but because it is not generally possible) - The compiler itself is self-contained ✅ - compiler is very fast.",0.185379188712522,c
128waxk,jekyb94,"❌✅ (depends on the definition of very fast, objectively it is not fast because it does a lot of optimisations, relatively it is)  Some of these are so disjoint from what C is and aims to be you should really reconsider how you call the language you're looking for.",0.09,c
128waxk,jekyb94,"Based on these points it's something other than a ""C alternative"".",-0.125,c
128waxk,jekyb94,The language you're looking for is closer in scope to C++.,0.0,c++
128waxk,jema6q2,"bruh  every modern, high level language seeks to supplant c",0.18,c
128waxk,jelwdwq,This is literally why Rust exists,0.0,rust
128waxk,jemrfef,It's always baffled me why no one has come up with a valid C alternative in 50 years.,0.0,c
128waxk,jemrfef,"For example, one of C's essential features is stability and spec conformance.",0.0,c
128waxk,jemrfef,What do Nim and D introduce?,0.0,d
128waxk,jemrfef,"And Walter Bright has the audacity to include a ""better C"" flag.",0.6000000000000001,c
128waxk,jemrfef,"No, Walter, it's not a better C if it has conservative ""gc"".",-0.25,c
128waxk,jenvd2s,"C does have 8-bit signed and unsigned integer types: `int8_t` and `uint8_t` in `<stdint.h>`, though they may not be defined if no other types with such bitwidths exist.",0.03125,c
128waxk,jenvd2s,"If you don't need a precise width, you can also use `[u]int_least8_t` for the smallest type with at least that width and `[u]int_fast8_t` for the fastest type with that width; this variety is considerably more than Rust or Zig offer.",0.20000000000000004,rust
128waxk,jermrah,Am I the only one here that knows about `_Bitint(n)` in C?,0.0,c
128waxk,jemhpnt,"Yeah, I'm just old enough to remember when Pascal nearly ruled the world --- I progressed from Turbo Pascal to Delphi and I still write in Lazarus when I want to knock up anything portable with a GUI.",0.06666666666666667,pascal
128waxk,jemhpnt,"Yeah, I'm just old enough to remember when Pascal nearly ruled the world --- I progressed from Turbo Pascal to Delphi and I still write in Lazarus when I want to knock up anything portable with a GUI.",0.06666666666666667,delphi
128waxk,jemjfz3,The most popular Pascal is nowadays Ada.,0.55,pascal
128waxk,jemjfz3,The most popular Pascal is nowadays Ada.,0.55,ada
128waxk,jhro0ob,"I like the good old Delphi, the son of Turbo Pascal.",0.39999999999999997,delphi
128waxk,jhro0ob,"I like the good old Delphi, the son of Turbo Pascal.",0.39999999999999997,pascal
128waxk,jhro0ob,But for some reason modern versions of Delphi are absolutely different from the original Delphi language.,0.19166666666666665,delphi
128waxk,jel5kc2,"👍  But they need a huge community support like Rust, or big commercial sponsor support like Google Go or Microsoft C.",0.13333333333333336,rust
128waxk,jel5kc2,"👍  But they need a huge community support like Rust, or big commercial sponsor support like Google Go or Microsoft C.",0.13333333333333336,go
128waxk,jel5kc2,"👍  But they need a huge community support like Rust, or big commercial sponsor support like Google Go or Microsoft C.",0.13333333333333336,c
128waxk,jen1c21,"If you want to address C programmers, you need a ""goto"".",0.0,c
128waxk,jeniznt,"I agree for Zig, but not for Rust.",0.0,rust
128waxk,jeniznt,Today a lot of PL us a C compiler.,0.0,c
128waxk,jeniznt,Try to do the same with a Rust compiler.,0.0,rust
128waxk,jelgp8n,"You can do low level programming in a high level language, I’ve done loads in Ada.",0.08,ada
128waxk,jeuf1a7,The C subreddit has more members than this one for example!,0.625,c
128waxk,jeuf1a7,>We don't have C replacements so to speak because the need isn't really there.,0.2,c
128waxk,jeuf1a7,Nearly every cross-language library exposes a C-like interface expressed in C syntax.,0.1,c
128waxk,jeuf1a7,I use Windows and Linux via functions with interfaces expressed as C headers.,0.0,c
128waxk,jeuf1a7,"Every other language seems to be implemented in C, or targets C.  It does seem there is a need for such a lower level language.",-0.0625,c
128waxk,jenfttn,I was going to mention Forth and Fortran as well as still being used low level alternatives.,0.0,forth
128waxk,jenfttn,I was going to mention Forth and Fortran as well as still being used low level alternatives.,0.0,fortran
128waxk,jenfttn,Chips are designed to run C fast.,0.2,c
128waxk,jenfttn,The last language which seriously challenged C on this was Java where there was meaningful talk of creating low level JVM support in silicon.,0.04166666666666667,c
128waxk,jenfttn,The last language which seriously challenged C on this was Java where there was meaningful talk of creating low level JVM support in silicon.,0.04166666666666667,java
128waxk,jenfttn,"If memory servers, Fujitsu and an Arm vendor put out chips around Java specifications in the 1997-2002 timeframe.",0.0,java
128waxk,jeop39w,"> And if you're using unsafe, a lot of Rust's reason for existence gets thrown out the window.",0.0,rust
128waxk,jeop39w,"Yes, writing the unsafe block itself is just as bad as C, or even a bit worse because of the extra invariants you have to uphold, but it's much clearer which code you have to double check.",-0.18,c
128waxk,jeop39w,The unsafety is much more localised in Rust.,0.5,rust
128waxk,jeop39w,"Rust also has isize and usize, for when you want to have an integer of the native size.",0.0,rust
128waxk,jepq3h6,"For the unsafe bit, I mean that’s not really a reason to toss Rust, I would assume the unsafe bits are related to the VM and the like.",-0.13749999999999998,rust
128waxk,jepq3h6,"So yeah needing unsafe in some parts of performant code isn’t bad, like I think you still would greatly benefit from Rust overall at all the other parts of the PL development process… Like yeah needing unsafe in some parts isn’t a reason to ditch Rust, if it was, the entire standard library would need to be dropped because the safety those types provided, is backed by unsafe code… So yeah, the main rule of thumb is avoid unsafe as much as you can, and be damn fucking careful when you need it.",0.026851851851851877,rust
128waxk,jepq3h6,"So yeah for me the ergonomics of working with Rust (I find it much easier than C to work with), as well as all of the assurances I get in all the places I don’t use unsafe code, outweighs for me the negatives of needing to use unsafe code here and there to maximize performance where I know stuff is safe.",0.35,rust
128waxk,jepq3h6,"So yeah for me the ergonomics of working with Rust (I find it much easier than C to work with), as well as all of the assurances I get in all the places I don’t use unsafe code, outweighs for me the negatives of needing to use unsafe code here and there to maximize performance where I know stuff is safe.",0.35,c
128waxk,jepq3h6,"I say this as a Rust “fanboy”, and yeah I’ve written my fair share of safe rust, unsafe rust, etc, etc, and yeah I’ve enjoyed it all much more than working with C, and have found maintaining code a lot easier, personally.",0.44000000000000006,rust
128waxk,jepq3h6,"I say this as a Rust “fanboy”, and yeah I’ve written my fair share of safe rust, unsafe rust, etc, etc, and yeah I’ve enjoyed it all much more than working with C, and have found maintaining code a lot easier, personally.",0.44000000000000006,c
128waxk,jgukz0a,"For example: types like “int” seem risky as opposed to “i64” but they exist for a reason: …  C integer types were a mistake, in fact they hurt portability.",0.0,c
128waxk,jgukz0a,"Ada’s approach to integer types is vastly superior for portability, as well as more elegant.",0.5666666666666667,ada
128waxk,jgukz0a,>	The ecosystem of C is vast and more pervasive than you can imagine.,0.25,c
128waxk,jgukz0a,The processor you’re viewing this page on was literally built with optimizations on C idioms built into the physical silicon.,0.0,c
128waxk,jgukz0a,Modern hardware does not bow down to C,0.022222222222222213,c
128waxk,jelozmx,"I didn't try C until 1992, and decided I prefered my own half-baked, buggy language (the current one is better!).",0.4083333333333334,c
128waxk,jelozmx,"This analogy may have been used before, but if C was a Model T Ford, I'd be looking for a more modern car for my everyday use.",0.16666666666666666,c
128waxk,jelozmx,"Or maybe I started off with C being a bike, I can't remember!",0.0,c
128waxk,jelozmx,"But this is the C equivalent:      #include <stdio.h>     #include <math.h>          int main(void) {         for (int i=1; i<=10; ++i) {             printf(""%d %f\n"", i, sqrt(i));         }     }  Meanwhile here is the same task in my systems language (the `main` function is not needed, but I left it in to keep it fair; most programs use it):      proc main=         for i to 10 do             println i, sqrt i         end     end  So, I have a preference for clean, clear code.",0.25,c
128waxk,jelozmx,"But this is the C equivalent:      #include <stdio.h>     #include <math.h>          int main(void) {         for (int i=1; i<=10; ++i) {             printf(""%d %f\n"", i, sqrt(i));         }     }  Meanwhile here is the same task in my systems language (the `main` function is not needed, but I left it in to keep it fair; most programs use it):      proc main=         for i to 10 do             println i, sqrt i         end     end  So, I have a preference for clean, clear code.",0.25,d
128waxk,jem43m3,"> Rust is the primary C alternative  No, it's a C++ alternative.",0.4,rust
128waxk,jem43m3,"> Rust is the primary C alternative  No, it's a C++ alternative.",0.4,c
128waxk,jem43m3,"> Rust is the primary C alternative  No, it's a C++ alternative.",0.4,c++
128waxk,jem43m3,Have you seen the madness of copying and rewriting parts of the kernel's internal API from C to Rust?,0.0,c
128waxk,jem43m3,Have you seen the madness of copying and rewriting parts of the kernel's internal API from C to Rust?,0.0,rust
128waxk,jem43m3,"If anything, the immense patch that added ""partial"" (read ""incomplete"") Rust support to the Linux kernel should be an indictment of the language, implementation and fanbase.",-0.05,rust
128waxk,jekxs7a,Rust is not a C alternative.,0.0,rust
128waxk,jekxs7a,Rust is not a C alternative.,0.0,c
128waxk,jekxs7a,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,rust
128waxk,jekxs7a,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,c++
128waxk,jekxs7a,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,c
128waxk,jenbfj7,Look at the task I mentioned [here](https://www.reddit.com/r/ProgrammingLanguages/comments/128waxk/comment/jelozmx/?utm_source=share&utm_medium=web2x&context=3); what would it look like in Forth?,0.0,forth
128waxk,jenbfj7,"And frankly, I'd have no idea how to write Forth.",0.0,forth
128waxk,jenbfj7,I would find assembly easier!,0.0,assembly
128waxk,jel6vfu,"In C you'd have to use shifts and masks, which is error prone.",0.0,c
128waxk,jel6vfu,An example without bit extraction might be written like this:      const capsmask   = 128     const capsshift  = 7          capslock := (lastkey.ctrlkeystate iand capsmask) >> capsshift  Or maybe using C's `!,-0.9375,c
128waxk,jel6vfu,"For example, what is the result type of `a + b * c`?",0.0,c
128waxk,jel6vfu,It depends on the mix of types of `a b c`.,0.0,c
128waxk,jel6vfu,"Perhaps I should have filtered out the C shortcomings that are commonly improved upon, but my list was things that can enhance C, and yet still keep the spirit of the language.",-0.3,c
128waxk,jelnu6x,I disagree to use Python or any P.L.,0.0,python
128waxk,jelclha,">   >The ""begin end"" was carefully studied and designed by it's Pascal inventor Nicklaus Wirth, as code encapsulation, several lines of code been encapsulated as a single concept.",-0.05714285714285714,pascal
128waxk,jelclha,"I said `begin-end` was as bad as braces, for example:      if cond then begin s1; s2 end else begin s3; s4 end     if (cond) {s1; s2;} else {s3; s4;}  compared with languages which got it right, like Algol68 (or Lua for something more recent):      if cond then s1; s2 else s3; s4 end  The first block is delimited with `then .. else`, the second with `else .. end`; what more is needed?",0.11938775510204083,lua
128waxk,jempc4t,"C has _Bool and since C23, `bool`, `true` and `false` are keywords.",-0.02500000000000005,c
128waxk,jf1aagg,"Given that C *is* extensively used as it is, why shouldn't you be able to do the same thing with say, a more palatable syntax?",0.25,c
128waxk,jf1aagg,"(My simplest function pointer type is `ref proc`, C's is `void(*)(void)`; WTF?)",-0.5,c
128waxk,jf1aagg,"Another is that, if *I*, as an amateur language developer, can make a viable systems language that is one-up on C (one that was used in a commercial environment for 20 years), why can't anybody?",-0.125,c
128waxk,jf1aagg,"That is, either something to replace C without creating something quite different and throwing away too much, or to independently create a language to do that job, as I did.",0.0,c
128waxk,jf1aagg,"There must be 1000s of amateur C compilers about, which slavishly implement all its poor features and quirks.",-0.325,c
128waxk,jf63ewt,"My first attempt at writing a substantial C program (around 2012, after 36 years of not using C), I had used a syntax wrapper to make it more palatable.",0.375,c
128waxk,jf63ewt,"If I *had* to write C, it would only be by using such an approach, because the language as it is frankly stinks.",-0.19999999999999998,c
128waxk,jf63ewt,(BTW Rust is frequently touted as a C-replacement.,0.1,rust
128waxk,jelgjo4,"I would say the “hey, I built a language that replaces c” posts all include flaws that c has.",0.0,c
128waxk,jen9zrw,"Here's another, one of a block of such lines:      ichar h_stdio = strinclude ""headers/stdio.h""  This is used in my C compiler to incorporate the standard headers, to make it self-contained in one file.",0.0,c
128waxk,jen9zrw,>Some of these are so disjoint from what C is and aims to be you should really reconsider how you call the language you're looking for.,0.2,c
128waxk,jen9zrw,"Actually, both my C compiler and my systems language compiler are about 400KB (disregarding any bundled support files); all my features do not make the compiler much bigger.",0.0,c
128waxk,jenazdq,"Not specifically of my language, but of a systems language without all of C's baggage, or its vagaries, but which is still ultra lightweight and small-footprint.",0.0,c
128waxk,jen62ly,"> For example, one of C's essential features is stability and spec conformance  It's true that the language hasn't significantly evolved.",0.24166666666666667,c
128waxk,jen62ly,"So to me, C is the opposite of stable: anyone can specify the dialect of C that they want, and how strict they want it.",0.0,c
128waxk,jen62ly,"Every other C program seems to define its own set of integer types, even when `stdint.h` is available (maybe `int32_t` is just too ugly).",0.04375000000000001,c
128waxk,jenxqy9,Of course D wouldn't fill the same role as C with conservative garbage collection; that's what the 'Better C' mode disables.,0.25,d
128waxk,jenxqy9,Of course D wouldn't fill the same role as C with conservative garbage collection; that's what the 'Better C' mode disables.,0.25,c
128waxk,jenxqy9,"(It leaves the compile-time features intact, though, and D still has dramatically more than C.)",0.5,d
128waxk,jenxqy9,"(It leaves the compile-time features intact, though, and D still has dramatically more than C.)",0.5,c
128waxk,jeojnzz,"Because C has to work on everything, those built-in types are only vaguely defined.",-0.25,c
128waxk,jeojnzz,"Of course, being an optional bolt-on in user code, C knows nothing about those types.",0.0,c
128waxk,jeojnzz,"So, for the basic 8 types (8/16/32/64-bit signed/unsigned), there are dozens of possible denotations in C; some may refer to the same type; some are the same size and signedness, but incompatible.",0.0,c
128waxk,jeojnzz,"If a C replacement did nothing except fix this aspect, that would make a welcome change.",0.8,c
128waxk,jeojnzz,1000s of libraries have APIs expressed as C headers using C types.,0.0,c
128waxk,jerwpvb,"(I used to have a syntax like this for integer sizes:      int*8          # (from Fortran) 8 bytes or 64 bit     int:32         # 32 bits  Then I realised I was never going to use anything other than power-of-two widths, and switched to a handful of fixed, single-token denotations like every other language.)",-0.049999999999999996,fortran
128waxk,jerynmi,My first module scheme didn't allow circular imports and it was a nightmare.,0.25,scheme
128waxk,jerynmi,My current module scheme is an utter joy to use.,0.26666666666666666,scheme
128waxk,jerynmi,"You write at the top of the lead module `A` (usually that only contains module stuff):      module B     module C     module D  And now, all modules `A B C D` effectively import each other: the exported names of each module are visible to the others.",0.145,c
128waxk,jerynmi,"You write at the top of the lead module `A` (usually that only contains module stuff):      module B     module C     module D  And now, all modules `A B C D` effectively import each other: the exported names of each module are visible to the others.",0.145,d
128waxk,jelsl56,Anyway there is free pascal.,0.4,pascal
128waxk,jeq9rzc,Isn't Delphi the reason that Pascal died out?,0.0,delphi
128waxk,jeq9rzc,Isn't Delphi the reason that Pascal died out?,0.0,pascal
128waxk,jeq9rzc,"People still using Pascal were told to move to Delphi, but then Borland drove off its customers with its licensing structure, so everyone switched to Free Software compilers.",0.4,pascal
128waxk,jeq9rzc,"People still using Pascal were told to move to Delphi, but then Borland drove off its customers with its licensing structure, so everyone switched to Free Software compilers.",0.4,delphi
128waxk,jen3bln,"I use goto in C a lot, so it’s definitely not like I think it’s “bad practice”",-0.3499999999999999,c
128waxk,jepp5p5,"I mean are we talking about a “replacement” for C or something that is “C, but better”?",0.09375,c
128waxk,jepp5p5,"I mean Rust is a very similar, but simultaneously extremely different language than C, and yeah I’m currently unaware of the viability of transpiling Rust to C, which is what I assume you’re suggesting, then piping that into a C compiler… Like yeah it doesn’t seem all that viable, and like idk it feels rather unnecessary when, you can use Rust code from C if you need to, and vice versa… I may be misinterpreting what you mean, but yeah for something to “replace” C, I don’t think it needs to use a C compiler, like it may be a nice to have, but I fail to see it as a bad thing… Lemme know what you think as I could be wrong here",-0.2125,rust
128waxk,jepp5p5,"I mean Rust is a very similar, but simultaneously extremely different language than C, and yeah I’m currently unaware of the viability of transpiling Rust to C, which is what I assume you’re suggesting, then piping that into a C compiler… Like yeah it doesn’t seem all that viable, and like idk it feels rather unnecessary when, you can use Rust code from C if you need to, and vice versa… I may be misinterpreting what you mean, but yeah for something to “replace” C, I don’t think it needs to use a C compiler, like it may be a nice to have, but I fail to see it as a bad thing… Lemme know what you think as I could be wrong here",-0.2125,c
128waxk,jevn4zc,Pretty much every high level language has a way to ffi with c effectively.,0.3025,c
128waxk,jgz2pov,">C integer types were a mistake, in fact they hurt portability.",0.0,c
128waxk,jgz2pov,"Ada’s approach to integer types is vastly superior for portability, as well as more elegant.",0.5666666666666667,ada
128waxk,jgz2pov,I don't know Ada's integer system so I can't say C's is better--it would not surprise me at all if Ada's was better.,0.5,ada
128waxk,jgz2pov,I don't know Ada's integer system so I can't say C's is better--it would not surprise me at all if Ada's was better.,0.5,c
128waxk,jgz2pov,Modern hardware does not bow down to C  It seems like you could have read the sentence you quoted!,0.002777777777777768,c
128waxk,jemaufz,"You might have liked Pascal/VS, which was IBM’s dialect of Pascal.",0.6,pascal
128waxk,jemqv0s,"I mean if you’ve ever worked with embedded Rust, as well as Rust, you would understand why… I mean you COULD just reuse the C versions of various things you need, but then you’d need to write unsafe code in order to interact with them everywhere… So what then?",-0.20833333333333334,rust
128waxk,jemqv0s,"I mean if you’ve ever worked with embedded Rust, as well as Rust, you would understand why… I mean you COULD just reuse the C versions of various things you need, but then you’d need to write unsafe code in order to interact with them everywhere… So what then?",-0.20833333333333334,c
128waxk,jemqv0s,"I mean if you’ve ever worked with embedded Rust, as well as Rust, you would understand why… I mean you COULD just reuse the C versions of various things you need, but then you’d need to write unsafe code in order to interact with them everywhere… So what then?",-0.20833333333333334,d
128waxk,jemqv0s,"Then you write a safe wrapper around the unsafe code, so that you can use Rust well, safely, which is one of the selling points of the language.",0.5,rust
128waxk,jemqv0s,"What isn’t, is weighing whether adding the language is a detriment, and what it offers and whether it is worth it… You can’t criticize Rust for adding a lot of code to the kernel, a famously fucking massive project…  As for the incompleteness, I would say that’s more the result of A: Linux being a large project using C and B: for a “complete” Rust experience you would, need to integrate cargo… Like I’m not currently aware of exactly how Linux is built (what build system it uses, how it’s configured, etc.",0.1674107142857143,rust
128waxk,jemqv0s,"What isn’t, is weighing whether adding the language is a detriment, and what it offers and whether it is worth it… You can’t criticize Rust for adding a lot of code to the kernel, a famously fucking massive project…  As for the incompleteness, I would say that’s more the result of A: Linux being a large project using C and B: for a “complete” Rust experience you would, need to integrate cargo… Like I’m not currently aware of exactly how Linux is built (what build system it uses, how it’s configured, etc.",0.1674107142857143,c
128waxk,jemqv0s,"), but I would assume that it would be somewhat, idk, awkward to integrate cargo into it, somehow…   I mean with all this in mind, I really think it suggests that Rust, isn’t shit, I mean why go through all the hassle, all of that extra work, to intregrate some new fangled language into the Linux kernel, the largest open source project, the thing that runs virtually all of the internet?",-0.13607954545454543,rust
128waxk,jemqv0s,"), but I would assume that it would be somewhat, idk, awkward to integrate cargo into it, somehow…   I mean with all this in mind, I really think it suggests that Rust, isn’t shit, I mean why go through all the hassle, all of that extra work, to intregrate some new fangled language into the Linux kernel, the largest open source project, the thing that runs virtually all of the internet?",-0.13607954545454543,go
128waxk,jemqv0s,"I highly doubt they did it for nothing, instead I would assume that those working on the Kernel see Rust as, well something that brings a lot to the table here… Those in charge of the kernel have a lot to weigh when making major decisions like using Rust in the Kernel, and the fact they said “yeah do it”, and went through all that hassle, says to me that they think Rust is valuable to the development of the Kernel, that Rust’s downsides in respect to being used in the Kernel, do not outweigh the benefits.",0.11125,rust
128waxk,jemqv0s,Like what compiling being slow and Rust devs being passionate?,-0.17500000000000002,rust
128waxk,jemqv0s,"Like what do you mean here, because yeah all I see here in your post is you describing those in charge of one of the most important pieces of software determining that Rust is ultimately worth the effort, like yeah idk, I’m not too familiar with all the specifics but even if I was entirely wrong up to this point, your criticism still suggests the opposite of what you think it should imply.",0.10892857142857142,rust
128waxk,jel5f8s,"There is Rust code in the Linux kernel now, I think that's about as OS writing as you can get these days.",0.0,rust
128waxk,jeky9ea,"I've dropped C entirely in favor of Rust for 5 years now, no issue (embedded systems engineer for space critical systems with hard real-time constraints)",-0.09722222222222222,c
128waxk,jeky9ea,"I've dropped C entirely in favor of Rust for 5 years now, no issue (embedded systems engineer for space critical systems with hard real-time constraints)",-0.09722222222222222,rust
128waxk,jelcxtr,Dunno why you’re being downvoted for pointing out that Rust is a c++ alternative.,0.0,rust
128waxk,jelcxtr,Dunno why you’re being downvoted for pointing out that Rust is a c++ alternative.,0.0,c++
128waxk,jemkzjn,>Rust is not a C alternative.,0.0,rust
128waxk,jemkzjn,>Rust is not a C alternative.,0.0,c
128waxk,jemkzjn,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,rust
128waxk,jemkzjn,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,c++
128waxk,jemkzjn,"Rust is a C++ replacement, and C++ is an extended C. Neither inherently do what C was made to do: writing operating systems for small computers.",-0.25,c
128waxk,jemkzjn,"I don't know Rust myself, I have seen it from afar.",0.0,rust
128waxk,jemkzjn,(a) Rust is if anything a C++ replacement rather than a C replacement.,0.0,rust
128waxk,jemkzjn,(a) Rust is if anything a C++ replacement rather than a C replacement.,0.0,c++
128waxk,jemkzjn,(a) Rust is if anything a C++ replacement rather than a C replacement.,0.0,c
128waxk,jemkzjn,"The particular virtue of C, and the reason why it carried the day in its day, is that it's portable assembly.",0.16666666666666666,c
128waxk,jemkzjn,"The particular virtue of C, and the reason why it carried the day in its day, is that it's portable assembly.",0.16666666666666666,assembly
128waxk,jemkzjn,Rust's own mother couldn't claim that of Rust.,0.6,rust
128waxk,jemkzjn,Rust answers the same question as C++: how do we get close to the metal while being able to have high-level language constructs?,0.25,rust
128waxk,jemkzjn,Rust answers the same question as C++: how do we get close to the metal while being able to have high-level language constructs?,0.25,c++
128waxk,jemkzjn,"(b) Yes, C was designed to write an OS for the PDP-11.",0.0,c
128waxk,jenjg37,If by normal looking syntax you mean Algol like then I'm hard pressed to see what you want.,-0.1513888888888889,algol
128waxk,jenjg37,The Algol like low level language is C.   The advantage of Forth is that it is incredibly easy to reason about programs because they decompose cleanly.,0.26666666666666666,algol
128waxk,jenjg37,The Algol like low level language is C.   The advantage of Forth is that it is incredibly easy to reason about programs because they decompose cleanly.,0.26666666666666666,forth
128waxk,jenjg37,You don't write tens of thousands of lines of code in Forth you write dozens at most and get the performance advantages where you need them.,0.5,forth
128waxk,jenjg37,"Languages like Factor, Postscript and Joy extend Forth to a higher level.",0.525,forth
128waxk,jenjg37,Here is a reasonable Forth [walk through of the compiler from scratch in assembly](http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.S;h=45e6e854a5d2a4c3f26af264dfce56379d401425;hb=66c56998125f3ac265a3a1df9821fd52cfeee8cc) which is under 2000 lines of assembly.,0.2,forth
128waxk,jenjg37,Here is a reasonable Forth [walk through of the compiler from scratch in assembly](http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.S;h=45e6e854a5d2a4c3f26af264dfce56379d401425;hb=66c56998125f3ac265a3a1df9821fd52cfeee8cc) which is under 2000 lines of assembly.,0.2,assembly
128waxk,jenjg37,Most experienced programmers can learn a Forth in a few days.,0.3666666666666667,forth
128waxk,jenjg37,The HP calculators used to use a Forth variant because it ran energy efficient on bad hardware quickly while making programming simple and powerful.,-0.016666666666666635,forth
128waxk,jeolffj,"Regarding the distinction between ""procedure"" and ""function"":  As I see it, the use of the word function in imperative languages like C is a mistake.",0.0,c
128waxk,jeolffj,This was done right in both Algol 60 and Algol 68.,0.2857142857142857,algol
128waxk,jeolffj,"Wirth used the word ""function"" in Pascal, but wisely decided to revert to ""procedure"" in Modula.",0.7,pascal
128waxk,jelx4c0,"I would also like Pascal to be something like:      if ( some boolean expression )     begin         then ... ;         else ... ;     end;  Where ""..."" could be a single instruction or a block, as originally intended, without the ambiguous syntax of the current Pascal.",0.1011904761904762,pascal
128waxk,jelx4c0,"And C like:      if ( some boolean expression )     {         then ... ;         else ... ;     }  Where ""..."" could be a single instruction or a block, as originally intended, without the ambiguous syntax of the current C.  Cheers.",0.1011904761904762,c
128waxk,jep8fz6,"PASCAL looks good, allowing you to write  **if** *b1* **then** *c1* **else** **if** *b2* **then** *c2* **if** *b3* **then** *c3* **else** *c4*  where as a naive version of ALGOL has  **if** *b1* **then** *c1* **else** **if** *b2* **then** *c2* **else** **if** *b3* **then** *c3* **else** *c4* **fi** **fi** **fi**  with a pile up of closers at the end.",0.19999999999999998,pascal
128waxk,jep8fz6,"PASCAL looks good, allowing you to write  **if** *b1* **then** *c1* **else** **if** *b2* **then** *c2* **if** *b3* **then** *c3* **else** *c4*  where as a naive version of ALGOL has  **if** *b1* **then** *c1* **else** **if** *b2* **then** *c2* **else** **if** *b3* **then** *c3* **else** *c4* **fi** **fi** **fi**  with a pile up of closers at the end.",0.19999999999999998,algol
128waxk,jep8fz6,Sophisticated versions of ALGOL style syntax of course allow  **if** *b1* **then** *c1* **elif** *b2* **then** *c2* **elif** *b3* **then** *c3* **else** *c4* **fi**  so yes Algol68 gets it right.,0.39285714285714285,algol
128waxk,jep8fz6,"Some people may still prefer a grammar with *begin* and *end* keywords to a grammar with *elif* and *fi* and prefer, not  **if** *b* **then** *c d* **else** *e f* **fi**  but  **if** *b* **then** *c d* **else** **begin** *e f* **end**   where *begin* and *end* are needed to collect *e* and *f* into a single unit.",-0.07142857142857142,c
128waxk,jep8fz6,"Some people may still prefer a grammar with *begin* and *end* keywords to a grammar with *elif* and *fi* and prefer, not  **if** *b* **then** *c d* **else** *e f* **fi**  but  **if** *b* **then** *c d* **else** **begin** *e f* **end**   where *begin* and *end* are needed to collect *e* and *f* into a single unit.",-0.07142857142857142,d
128waxk,jep8fz6,But that is not valid PASCAL.,0.0,pascal
128waxk,jep8fz6,PASCAL actually requires that *c* and *d* are double wrapped.,0.0,pascal
128waxk,jep8fz6,PASCAL actually requires that *c* and *d* are double wrapped.,0.0,c
128waxk,jep8fz6,PASCAL actually requires that *c* and *d* are double wrapped.,0.0,d
128waxk,jep8fz6,They have to be grouped together extra hard **then** **begin** *c d* **end** **else**.,-0.14583333333333334,c
128waxk,jep8fz6,They have to be grouped together extra hard **then** **begin** *c d* **end** **else**.,-0.14583333333333334,d
128waxk,jep8fz6,"Even if you think that Algol68 gets it wrong and PASCAL gets it nearly right, the double wrapping of the then part is still stupid, and PASCAL is *nearly* right, rather than *actually* right.",-0.07380952380952381,pascal
128waxk,jf8nbqw,"C also has trigraphs, so if you can't type braces, you're not sunk.",0.0,c
128waxk,jelgujd,People say C replacement but really it's something else.,0.2,c
128waxk,jenb7ih,"now you just have to sit back and be the ""benevolent dictator for life""... like guiddo is for python, or linus is for linux.",0.0,python
128waxk,jet9k72,I used `int2pow<size_t>` (C++) at some point.,0.0,c++
128waxk,jf3xagk,"Arguably Borland is the reason Delphi died out, but Pascal stood the test of time.",0.0,delphi
128waxk,jf3xagk,"Arguably Borland is the reason Delphi died out, but Pascal stood the test of time.",0.0,pascal
128waxk,jen7mp9,"A common use of C is as a target language for compilers and transpilers, where `goto` is necessary to emulate control flow constructs that don't exist in the target.",-0.15,c
128waxk,jen7mp9,Sometimes 'linear' C is generated which only uses `if` and `goto` for all control flow.,0.0,c
128waxk,jew2ep6,I've meant transpiling any language (that currently uses a C compiler) to Rust code that then is compiled by the Rust compiler.,0.0,c
128waxk,jew2ep6,I've meant transpiling any language (that currently uses a C compiler) to Rust code that then is compiled by the Rust compiler.,0.0,rust
128waxk,jelmu28,"Ada was green, the red manual is online, blue and yellow are not; not related to the red you’re talking about.",-0.03333333333333333,ada
128waxk,jewgn2p,"But the HLL does need to know the API used, and this API is very often expressed via a C header file (in the case of GTK, via 700 header files across a dozen directories).",0.2,c
128waxk,jewgn2p,The HLL will need to create bindings in its own language (unless it incorporates an entire C subsystem like Zig).,0.3,c
128waxk,jewgn2p,"Those C headers won't be a single, flat header without nested includes, conditional blocks, C-compiler-specific code (there is no C compiler!",-0.05133928571428571,c
128waxk,jewgn2p,"It will be a mess, one that needs a C compiler to make sense of.",-0.175,c
128waxk,jewgn2p,"So at the very least, if we're going to be stuck with C for this purpose, try harder to create conservative header files such as I've described, that could even be processed with a script rather than needing half a C compiler.",-0.16416666666666666,c
128waxk,jewgn2p,"(This is getting off the topic of a C replacement, but it shows C is entrenched everywhere.)",0.0,c
128waxk,jh1srp4,"C integer types are a half-assed measure for portability, they divorce the language from any particular platform *but they actively harm cross platform code portability*.",0.011111111111111108,c
128waxk,jh1srp4,In K&R C there’s no fucking way to understand what `int a` means without knowing what platform *it was written on!,0.375,r
128waxk,jh1srp4,In K&R C there’s no fucking way to understand what `int a` means without knowing what platform *it was written on!,0.375,c
128waxk,jh1srp4,* It’s the entire reason C89 introduced minimums on C integer types.,0.0,c
128waxk,jenkxhb,> You can’t criticize Rust for adding a lot of code to the kernel  You're not my supervisor!,0.0,rust
128waxk,jenkxhb,Adding Rust to the pot was a mistake.,0.0,rust
128waxk,jenkxhb,"Of course you're not, but you have strong opinions about adding shit to it nonetheless...  > why go through all the hassle, all of that extra work, to intregrate some new fangled language into the Linux kernel  Prestige.",0.09242424242424241,go
128waxk,jenkxhb,"> I really think it suggests that Rust, isn’t shit  Which was the whole point - impressing people who know nothing about the Linux kernel (or Rust, for that matter).",0.06666666666666667,rust
128waxk,jeldg9g,"We had people writing Linux code/modules in Ada over a decade ago, the blogs are still out there if you search for it, but nobody tried to donate it to the kernel because Linus probably would’ve thrown a hissy fit.",0.4,ada
128waxk,jelbs2s,It does not change what Rust or C are.,0.0,rust
128waxk,jelbs2s,It does not change what Rust or C are.,0.0,c
128waxk,jelbs2s,"One should also acknowledge that in terms of Rust's role in the Linux kernel, it has been criticized many times by Linus for essentially not being able to bend according to the kernel's needs.",0.3333333333333333,rust
128waxk,jelbs2s,"Now, it is true that Linus only really likes C (to some extent), and it is true that he is a highly opinionated and dramatic individual, however, if you are trying to commit an appeal to authority, then Linus is a much greater authority on C than whatever implication is being made by Rust being used for Linux' kernel.",0.14083333333333334,c
128waxk,jelbs2s,"Now, it is true that Linus only really likes C (to some extent), and it is true that he is a highly opinionated and dramatic individual, however, if you are trying to commit an appeal to authority, then Linus is a much greater authority on C than whatever implication is being made by Rust being used for Linux' kernel.",0.14083333333333334,rust
128waxk,jel445c,"This does not mean Rust is a C alternative, this simply means you have replaced C with Rust for whatever it is you do.",0.078125,rust
128waxk,jel445c,"This does not mean Rust is a C alternative, this simply means you have replaced C with Rust for whatever it is you do.",0.078125,c
128waxk,jel445c,"That does not change what C or Rust are and aim to do, that just changes how you use either of them.",0.0,c
128waxk,jel445c,"That does not change what C or Rust are and aim to do, that just changes how you use either of them.",0.0,rust
128waxk,jel445c,"I have also initially replaced C with C#, and then with Python, but I would call neither of them an alternative for their predecessor.",0.0,c
128waxk,jel445c,"I have also initially replaced C with C#, and then with Python, but I would call neither of them an alternative for their predecessor.",0.0,python
128waxk,jeld3wu,I'm also surprised but I assume the Rust cult took it as an insult (even though it's not meant to be one).,0.1,rust
128waxk,jelszxi,rust strike force,0.0,rust
128waxk,jennmah,>The Algol like low level language is C.  Algol-style is quite different from C which uses braces.,0.0,algol
128waxk,jennmah,>The Algol like low level language is C.  Algol-style is quite different from C which uses braces.,0.0,c
128waxk,jennmah,I said in my OP that 80% of my issues with C were with its syntax.,0.0,c
128waxk,jennmah,With Forth it would be more like 98%!,0.625,forth
128waxk,jennmah,&#x200B;  >You don't write tens of thousands of lines of code in Forth you write dozens at most and get the performance advantages where you need them.,0.5,forth
128waxk,jennmah,"If a program *needs* 10,000 lines of code to do what it has to do, then how would a Forth program magically reduce that to 10-100 lines?",0.5,forth
128waxk,jennmah,"As for performance, I actually have no idea whether Forth is compiled, interpreted or both.",0.0,forth
128waxk,jennmah,I get the impression that Forth is a language you make up as you go.,0.0,forth
128waxk,jennmah,I get the impression that Forth is a language you make up as you go.,0.0,go
128waxk,jennmah,"Forths can have around 3-8k compilers, complex ones might be 32k  The GForth I downloaded for Windows a few weeks ago (to do with a sub-thread about using Forth as a target language), was 130KB.",-0.25,forth
128waxk,jennmah,"As I said, it's not meant for users to directly program in, but I would  find it considerably easier to do so compared with Forth.",0.1,forth
128waxk,jennmah,"Here's the square root program in my link, expressed in that IL (I've switched from `println` to C's `printf` to keep it more compact):      proc main export         local    i64   .i      ;------------------------         loadimm  i64   1          store    i64   .i      #25:         load     i64   .i          float    r64 i64          sqrt     r64            load     i64   .i          loadimm  u64   ""%lld %f""          callp          printf* 3 2         forup          #25 .i 10 1     end  >250k compiler.",0.2222222222222222,c
128waxk,jennmah,"That was the minimum installation size for a C compiler that would build my generated code, which uses no headers.",0.0,c
128waxk,jennmah,It might have been more like 230KB for the 2-3 Tiny C files needed.,0.25,c
128waxk,jeq4ey3,"In the example of a multi-block statement like `if c then x elsif y else z`, all the blocks `x y z` are naturally delimited by those keywords, except the last.",0.05,c
128waxk,jeq4ey3,"Algol60, Pascal and C approach it by only allowing single statements in all branches.",-0.03571428571428571,pascal
128waxk,jeq4ey3,"Algol60, Pascal and C approach it by only allowing single statements in all branches.",-0.03571428571428571,c
128waxk,jeq4ey3,"Preferably a tangible one (not one you have to infer, as in ~~Pascal~~ Python and Nim, from a negative change in indentation, assuming something follows).",-0.3,python
128waxk,jencuw0,"So say you have this:        ...     if (...) goto A;     ...     if (...) goto B;     ...     A:     ...     B:     ...  Then this can be rewritten as:     switch (START)     {       case START:         ...         if (...) nextcase A;         ...         if (...) nextcase B;         ...         nextcase;       case A:         ...         nextcase;       case B:         ...     }  Not particularly elegant, but will work *exactly* like the C example down to the underlying instructions.",-0.051851851851851864,c
128waxk,jenvijo,">A common use of C is as a target language for compilers and transpilers, where goto is necessary to emulate control flow constructs that don't exist in the target.",-0.15,c
128waxk,jenvijo,Sometimes 'linear' C is generated which only uses if and goto for all control flow.,0.0,c
128waxk,jenvijo,"I've seen C used as a transpilation target many times, but haven't heard of 'linear' C or languages that have such control flow as in the 2nd paragraph.",0.16666666666666666,c
128waxk,jeohwau,You just keep using C as your compiler target.,0.0,c
128waxk,jew5rsv,It seems to be relatively easy to transpile C to Rust.,0.43333333333333335,c
128waxk,jew5rsv,It seems to be relatively easy to transpile C to Rust.,0.43333333333333335,rust
128waxk,jf6ffwf,"If you're looking to replace C as a compilation target, then the answer is LLVM IR.",0.0,c
128waxk,jh35yp1,"C integer types are a half-assed measure for portability, they divorce the language from any particular platform but they actively harm cross platform code portability.",0.011111111111111108,c
128waxk,jh35yp1,In K&R C there’s no fucking way to understand what int a means without knowing what platform it was written on!,0.375,r
128waxk,jh35yp1,In K&R C there’s no fucking way to understand what int a means without knowing what platform it was written on!,0.375,c
128waxk,jh35yp1,It’s the entire reason C89 introduced minimums on C integer types.,0.0,c
128waxk,jh35yp1,"No one cares about K&R C.  > Also, your example is bad because there are many, many cases where a 64 bit integer is legitimately needed, and chopping that down to anything less breaks the program.",-0.0044444444444444176,r
128waxk,jh35yp1,"Again, you should go back and try to read what I said.",0.0,go
128waxk,jh35yp1,"I can, however, reasonably assume that the person reading this page is doing so using an Intel, AMD, or ARM chip, all of which do in fact have instructions geared toward supporting C semantics.",0.225,c
128waxk,jeoiz5b,"Like yeah no it’s one thing to be sketical and entirely another thing to look at one of the most important pieces of software integrating a new language, a project that has been famous for it’s strict policy of “C, C everywhere, everything on C”, and to go “yeah those people in charge of that, and maintainers of that, yeah they’re just doing it for ‘prestige’, couldn’t possibly be any other reason”.",0.20162337662337662,c
128waxk,jeoiz5b,"Like yeah no it’s one thing to be sketical and entirely another thing to look at one of the most important pieces of software integrating a new language, a project that has been famous for it’s strict policy of “C, C everywhere, everything on C”, and to go “yeah those people in charge of that, and maintainers of that, yeah they’re just doing it for ‘prestige’, couldn’t possibly be any other reason”.",0.20162337662337662,go
128waxk,jeoiz5b,"Do you realize how fucking stupid you sound, you literally remind me of the fucking weirdos who hate Rust because they have a code of conduct that essentially says “don’t be a fucking bigot and we aight”, like you’re extremely attached to this idea that it’s a shitty language in it’s entirety and I seriously have to ask, why?",-0.3572916666666667,rust
128waxk,jemr100,"and Rust still made it in, which says something, no?",0.0,rust
128waxk,jem07ap,"And 3rd, rust can actually be used in microcontrollers anyway, the major blocking point for most microcontroller support was not the language but just the fact that the compiler didn't have support due to being based on llvm.",0.0875,rust
128waxk,jem07ap,AVR microcontrollers like the Arduino boards have experimental rust support and once the GCC backend is finished many more microcontrollers can be used with rust.,0.3666666666666667,rust
128waxk,jem07ap,"From my point of view the major issues with C are in fact safety related, when you're doing low level bit twiddling you *really* don't want to accidentally overwrite the wrong memory location, since on embedded systems devices are usually memory mapped and there's no OS to stop you from doing dangerous things.",-0.15535714285714283,c
128waxk,jem07ap,Source: I'm an embedded systems engineer interested in robotics and looking to learn Rust soon because I see it being used in my space more and more as a C alternative.,0.4166666666666667,rust
128waxk,jem07ap,Source: I'm an embedded systems engineer interested in robotics and looking to learn Rust soon because I see it being used in my space more and more as a C alternative.,0.4166666666666667,c
128waxk,jeli8ny,"The sheer size of Rust prevents it from being used in certain circuits like onboard aircraft systems etc  Linus, an opinionated jerk, and linux is not an all encompassing test",0.10714285714285714,rust
128waxk,jel4mta,Thus for my use cases Rust is a great alternative to C. Like Python could be for some of your use cases.,0.8,rust
128waxk,jel4mta,Thus for my use cases Rust is a great alternative to C. Like Python could be for some of your use cases.,0.8,python
128waxk,jel4mta,I have yet to see any use case where Rust would be a bad alternative to C,-0.6999999999999998,rust
128waxk,jel4mta,I have yet to see any use case where Rust would be a bad alternative to C,-0.6999999999999998,c
128waxk,jelh234,They said it was a c++ replacement themselves.,0.0,c++
128waxk,jelwiq9,Just checking in to say that I agree with you on rust not being a C alternative in the sense that it could not fill the entirety of C use cases.,0.0,rust
128waxk,jelwiq9,Just checking in to say that I agree with you on rust not being a C alternative in the sense that it could not fill the entirety of C use cases.,0.0,c
128waxk,jelwiq9,There’ll never be a _”true”_ alternative to C because one is not needed.,0.35,c
128waxk,jelwiq9,"C has become so elementary as to be cemented on most platforms, becoming part of the stack in a sense.",0.4166666666666667,c
128waxk,jelwiq9,"Rust will never be as light, pervasive nor portable as C, and C will never be as safe, approachable and maintainable as Rust.",0.45,rust
128waxk,jelwiq9,"Rust will never be as light, pervasive nor portable as C, and C will never be as safe, approachable and maintainable as Rust.",0.45,c
128waxk,jeldtec,"If ""Rust is a C++ replacement"" and ""C++ is an extended C"" (or, in other words, C++ is a superset of C), then Rust has to be a replacement for C as well.",-0.125,rust
128waxk,jeldtec,"If ""Rust is a C++ replacement"" and ""C++ is an extended C"" (or, in other words, C++ is a superset of C), then Rust has to be a replacement for C as well.",-0.125,c++
128waxk,jeldtec,"If ""Rust is a C++ replacement"" and ""C++ is an extended C"" (or, in other words, C++ is a superset of C), then Rust has to be a replacement for C as well.",-0.125,c
128waxk,jeldtec,It can do everything C can.,0.0,c
128waxk,jen843i,Realize that people have done that in JAVA and that Android has been a massive success.,0.15,java
128waxk,jen843i,"This does not mean that Java's purpose was writing OS' for small computers, that it is good at it, or that it is by extension a C alternative.",0.2020833333333333,java
128waxk,jen843i,"This does not mean that Java's purpose was writing OS' for small computers, that it is good at it, or that it is by extension a C alternative.",0.2020833333333333,c
128waxk,jeowvrc,*A fortiori* it's possible to do that in Rust and C++.,0.0,rust
128waxk,jeowvrc,*A fortiori* it's possible to do that in Rust and C++.,0.0,c++
128waxk,jeowvrc,But C was for that particular: the fact that it was successful for other purposes was because back then the control it gave you over use of memory and time was worth the sacrifice of having as little abstraction as the authors could get away with.,0.15069444444444444,c
128waxk,jeoqipv,Braces function in C as shorthand for 𝐛𝐞𝐠𝐢𝐧 and 𝐞𝐧𝐝.,0.0,c
128waxk,jeoqipv,"C even has a preprocessor that permits you to do:      #define BEGIN {     #define END }  and additionally, as I know you prefer the Algol 68 style of bracketing flow constructs:      #define IF if(     #define THEN ) {     #define ELIF } else if(     #define ELSE } else {     #define FI }     ...  (and I know this ""Bournegol"" style - used by Steven Bourne - is both ridiculed and scorned by ""real"" C programmers; however, it's consistent use could have prevented the 2014 Apple ""goto fail"" vulnerability for example.)",-0.016666666666666663,c
128waxk,jeoqipv,"C even has a preprocessor that permits you to do:      #define BEGIN {     #define END }  and additionally, as I know you prefer the Algol 68 style of bracketing flow constructs:      #define IF if(     #define THEN ) {     #define ELIF } else if(     #define ELSE } else {     #define FI }     ...  (and I know this ""Bournegol"" style - used by Steven Bourne - is both ridiculed and scorned by ""real"" C programmers; however, it's consistent use could have prevented the 2014 Apple ""goto fail"" vulnerability for example.)",-0.016666666666666663,algol
128waxk,jeoqipv,"However, what I believe is a far worse omission in C, is the lack of real nested block structure.",-0.03333333333333335,c
128waxk,jeoqipv,"At least Pascal has it in a degenerate form, allowing nested procedures.",-0.3,pascal
128waxk,jeoqipv,"And apparently this is *so* hard to add to C, that even the GNUC extension for it is problematic (something about trampolines, NX and executable stack...",-0.12083333333333335,c
128waxk,jep1fke,> Algol-style is quite different from C which uses braces.,0.0,c
128waxk,jep1fke,I said in my OP that 80% of my issues with C were with its syntax.,0.0,c
128waxk,jep1fke,With Forth it would be more like 98%!,0.625,forth
128waxk,jep1fke,You are obviously fairly comfortable with Assembly which means you can handle a pretty high degree of awkward syntax.,0.05250000000000002,assembly
128waxk,jep1fke,"> As I said, it's not meant for users to directly program in, but I would find it considerably easier to do so compared with Forth.",0.1,forth
128waxk,jep1fke,I agree that looks easy though not sure why it is easier than Forth (at least one like gforth which has more stuff in it).,0.09583333333333334,forth
128waxk,jf4x80y,Pascal on the JVM!,0.0,pascal
128waxk,jhroffs,I know at least one modern program which still uses Pascal / Delphi.,-0.04999999999999999,pascal
128waxk,jhroffs,I know at least one modern program which still uses Pascal / Delphi.,-0.04999999999999999,delphi
128waxk,jfaujqw,It's really nice to use the Free Pascal toolchain for Atmel microcontrollers.,0.5,pascal
128waxk,jenjz2u,"What's not clear however is, if you allow this arbitrary back and forth program flow, why it doesn't impact on `defer` in the same way.",-0.037500000000000006,forth
128waxk,jenjz2u,"If I split `b`'s block into `b` and `c`, then I need `recase c` after `s2`.",0.0,c
128waxk,jenzn3q,"A Fibonacci function might end up as this C:      static i64 fib(i64 n) {         u64 S1, S2;         S1 = n;         S2 = 3;         if ((i64)S1 >= (i64)S2) goto L2;         S1 = 1;         goto L3;     L2:         S1 = n;         S2 = 1;         *(i64*)&S1 -= (i64)S2;         S1 = fib(S1);         S2 = n;         S3 = 2;         *(i64*)&S2 -= (i64)S3;         S2 = fib(S2);         *(i64*)&S1 += (i64)S2;     L3:         goto L4;     L4:         return S1;     }  The `S1 S2` etc represent the stack of the VM (only 2 slots are needed here).",-0.4166666666666667,c
128waxk,jenzn3q,The generated C requires an optimising compiler to mop up all the redundant temps.,-0.2,c
128waxk,jenzn3q,"For examples of erratic use of `goto`, try and look at examples of Fortran IV or earlier.",0.0,fortran
128waxk,jenzn3q,"Conceivably, somebody might want to port a routine in that language directly into C, rather than try and rewrite it.",0.1,c
128waxk,jem14ie,Rust has the ability to drop the standard library and everything else so you are writing code with zero dependencies.,0.0,rust
128waxk,jem14ie,"I've seen a few research kernels written entirely in Rust, you still get the compile time safety checks and runtime bounds checks (unless you disable that too for speed, it's also an option) so it's still safer than C while being able to target pretty much everything (that has compiler support) that C can.",0.15,rust
128waxk,jem14ie,"I've seen a few research kernels written entirely in Rust, you still get the compile time safety checks and runtime bounds checks (unless you disable that too for speed, it's also an option) so it's still safer than C while being able to target pretty much everything (that has compiler support) that C can.",0.15,c
128waxk,jem14ie,"Note the compiler support, that is one area that C has a legitimate leg up in, and it's because a lot of embedded systems use a customized gcc compiler,  since rust doesn't yet have a GCC frontend and even if it did most of those tool chains are too old to use it, C is your only option still.",0.19999999999999998,c
128waxk,jem14ie,"Note the compiler support, that is one area that C has a legitimate leg up in, and it's because a lot of embedded systems use a customized gcc compiler,  since rust doesn't yet have a GCC frontend and even if it did most of those tool chains are too old to use it, C is your only option still.",0.19999999999999998,rust
128waxk,jemreao,"I mean I’m not exactly sure what the limitations are here but yeah from my experience with embedded rust, you can make it really fucking small if you need to… I managed to write a shitty MBR bootloader that had a bump allocator, an ability to print numbers in hexadecimal to the screen in order, etc, etc, and I through fiddling with the linker, as well as enabling various optimizations, got it to fit into 512 bytes, with room for more, what took more room was the strings I had that I would print to the display.",0.08392857142857144,rust
128waxk,jemreao,"So yeah not sure the exact limitations of these systems but you can make Rust extremely small, embedded Rust can be extremely small, like as I said I managed to fit all of that into 512 bytes.",-0.019999999999999997,rust
128waxk,jel5q8a,"However, Rust cannot be another possibility or choice for the tasks C was made and intended for, because it inherently isn't made to do those tasks, nor does it do them particularly well.",0.16666666666666666,rust
128waxk,jel5q8a,"However, Rust cannot be another possibility or choice for the tasks C was made and intended for, because it inherently isn't made to do those tasks, nor does it do them particularly well.",0.16666666666666666,c
128waxk,jel5q8a,"Although Rust is a replacement for you given your workload, and perhaps an alternative language for what you do, Rust cannot fundamentally be a C alternative, because it isn't even meant to do what C does and is intended for.",0.0,rust
128waxk,jel5q8a,"Although Rust is a replacement for you given your workload, and perhaps an alternative language for what you do, Rust cannot fundamentally be a C alternative, because it isn't even meant to do what C does and is intended for.",0.0,c
128waxk,jel5q8a,Good luck doing that without `unsafe` or with whatever targets Rust emits code for.,0.7,rust
128waxk,jel5q8a,Good luck targetting those architectures with Rust (whereas implementing a C compiler for such a platform was usually done in a week).,0.15,rust
128waxk,jel5q8a,Good luck targetting those architectures with Rust (whereas implementing a C compiler for such a platform was usually done in a week).,0.15,c
128waxk,jel5q8a,"Also, good luck fitting the Rust compiler on what constituted a small computer (also called minicomputer) back when C was developed (or even now).",0.21000000000000002,rust
128waxk,jel5q8a,"Also, good luck fitting the Rust compiler on what constituted a small computer (also called minicomputer) back when C was developed (or even now).",0.21000000000000002,c
128waxk,jelgk0x,But I did not claim I got downvoted because of the Rust cult.,0.0,rust
128waxk,jelgk0x,I claimed that I assume the Rust cult took it as an insult.,0.0,rust
128waxk,jelgk0x,The Rust cult is widespread over programming subreddits and was sighted here multiple times.,0.0,rust
128waxk,jem52rc,"Unless you've been living under a rock, both Rust and Zig have their toxic brigadeering hordes... the latter increasingly outdoing the former.",0.0,rust
128waxk,jeleft3,"C++ was not meant to inherit the purpose of C. It was supposed to be C with classes at first, yes, but it was always intended for large systems, unlike C. It lacked the purpose of building operating systems altogether, let alone for small computers specifically (although mainframe/minicomputer distinction was dying by the time C++ was developed).",0.07857142857142857,c++
128waxk,jeleft3,"C++ was not meant to inherit the purpose of C. It was supposed to be C with classes at first, yes, but it was always intended for large systems, unlike C. It lacked the purpose of building operating systems altogether, let alone for small computers specifically (although mainframe/minicomputer distinction was dying by the time C++ was developed).",0.07857142857142857,c
128waxk,jeleft3,Rust can never be a C alternative simply because it is too different.,0.0,rust
128waxk,jeleft3,Rust can never be a C alternative simply because it is too different.,0.0,c
128waxk,jeleft3,"Really, no modern GPL can be a C alternative given that it would be too big and given that today's motivation for GPLs is much different than those that existed when C was developed.",0.0,c
128waxk,jeleft3,"Not to mention that it's highly likely that a language of similar size to C would be considered incomplete (look at most common Go criticism, ex.).",0.05,c
128waxk,jeleft3,"Not to mention that it's highly likely that a language of similar size to C would be considered incomplete (look at most common Go criticism, ex.).",0.05,go
128waxk,jeleft3,"So no, Rust being a C extension transitively does not imply Rust is a C alternative.",0.0,rust
128waxk,jeleft3,"So no, Rust being a C extension transitively does not imply Rust is a C alternative.",0.0,c
128waxk,jeleft3,Just like Java being a C replacement (words from authors) does not mean Java is a C alternative.,0.15625,java
128waxk,jeleft3,Just like Java being a C replacement (words from authors) does not mean Java is a C alternative.,0.15625,c
128waxk,jeleft3,"Every turing complete language can do everything C can, that is a redundant argument.",-0.05,c
128waxk,jeleft3,I've given examples of where Rust sucks for the very purpose C was built for in another comment as well.,-0.04999999999999999,rust
128waxk,jeleft3,I've given examples of where Rust sucks for the very purpose C was built for in another comment as well.,-0.04999999999999999,c
128waxk,jep1gtc,">C even has a preprocessor that permits you to do:  The extraordinary thing about the C preprocessor is that it has Algol-style blocks for its conditional statements:      #if     #elif     #else     #endif  It has clearer, safer syntax then the main language!",0.2708333333333333,c
128waxk,jep1gtc,"Only `then` is missing to make it fully Algol-like, but it's better than Algol in not needing that business with `begin-end` where there is more than one statement.",0.2,algol
128waxk,jep1gtc,">what I believe is a far worse omission in C, is the lack of real nested block structure.",-0.03333333333333335,c
128waxk,jep1gtc,"At least Pascal has it in a degenerate form, allowing nested procedures.",-0.3,pascal
128waxk,jeq1ke6,Forth is just TOO much stack based.,0.2,forth
128waxk,jeq1ke6,I have taken something away from Forth which is the `(a--b)` notation that describes the stack behaviour.,0.0,forth
128waxk,jfb4fsw,"That sounds cool, but it would be a nostalgia project.",0.35,cool
128waxk,jfb4fsw,Nobody else would want to learn Pascal.,0.0,pascal
128waxk,jemrlw9,"Yeah I wrote a shitty bootloader in Rust (MBR), that had the ability to print and encode numbers to hexadecimal (without a buffer, I used logarithms, I can’t remember the exact specifics of how I did it), a small bump allocator, and so on, and it all fit within 512 bytes, with various optimizations enabled and fucking with the linker, but yeah if you’re main issue is size constraints, you were probably already doing that… So yeah, Rust, fucking small language when you need it to be.",-0.04047619047619048,rust
128waxk,jem5ces,Seen multiple research kernels written in pure rust.,0.10714285714285714,rust
128waxk,jem5ces,"Yes you use unsafe, no that does not invalidate rust's advantages.",0.0,rust
128waxk,jem5ces,"If something goes wrong, you only need to check the areas marked explicitly with unsafe, rather than the entire code base as you would in C. Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",-0.04375000000000001,rust
128waxk,jem5ces,"If something goes wrong, you only need to check the areas marked explicitly with unsafe, rather than the entire code base as you would in C. Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",-0.04375000000000001,c
128waxk,jem5ces,"Architecture support is indeed a sore spot with rust, but it's because it's currently only using LLVM as the compiler backend.",0.0,rust
128waxk,jem5ces,"You'd do that on your development machine, which is significantly more powerful, and I'm pretty sure that you wouldn't be able to run modern C compilers like Clang (which uses the same backend as rust) on such limited systems anyway.",0.24206349206349204,c
128waxk,jem5ces,"You'd do that on your development machine, which is significantly more powerful, and I'm pretty sure that you wouldn't be able to run modern C compilers like Clang (which uses the same backend as rust) on such limited systems anyway.",0.24206349206349204,rust
128waxk,jem5ces,Why would we care if the compiler can run on machines that were around when C was first invented?,0.25,c
128waxk,jem5ces,"Yeah, it probably couldn't, and at the time C was awesome.",1.0,c
128waxk,jem5ces,"But times have changed, we've gotten a lot better at making programming languages, our computers have gotten a lot more powerful, and a lot of people have been bitten by C's lack of safety.",0.43333333333333335,c
128waxk,jem5ces,"Rust isn't for everyone, and that's fine, but making up excuses for why we shouldn't use it is not a solution to a very obvious set of problems we have in front of us today.",0.20833333333333334,rust
128waxk,jem5ces,"Rust can do everything C can, and it can do it with better safety, something that is particularly important in the areas that traditionally only C was used, like embedded systems.",0.3,rust
128waxk,jem5ces,"Rust can do everything C can, and it can do it with better safety, something that is particularly important in the areas that traditionally only C was used, like embedded systems.",0.3,c
128waxk,jem5ces,Source: I'm an embedded systems engineer who has seen *a lot* of bugs caused by C that would have been caught by rust.,0.0,c
128waxk,jem5ces,Source: I'm an embedded systems engineer who has seen *a lot* of bugs caused by C that would have been caught by rust.,0.0,rust
128waxk,jem9he7,>I did not claim I got downvoted because of the Rust cult.,0.0,rust
128waxk,jem9he7,I claimed that I assume the rust cult took it as an insult (in response to someone questioning why I was downvoted).,0.0,rust
128waxk,jels0fs,"And Rust meets that criteria regarding C.  If you just look at the qualities of a language, you'll have a much harder time finding alternatives.",-0.1,rust
128waxk,jels0fs,"As many of C's qualities are a product of its time, and not necessarily central to its idea/purpose, you're not going to find many new languages that are very similar to it (even though they might be made to solve the same problems).",0.18939393939393936,c
128waxk,jeu2c4w,Google for Bournegol and you may find some people's opinion on the original Bourne shell code.,0.375,shell
128waxk,jeu2c4w,Maybe you have never programmed in Pascal?,0.0,pascal
128waxk,jeqgkew,Again no one does that with Forth.,0.0,forth
128waxk,jeqgkew,Forth doesn't claim to allow you to write good 40k line programs.,0.7,forth
128waxk,jeqgkew,"It wants to be your replacement for Assembly language, or possible C.   What you would likely do is create a DSL in Forth and write a short program in the customized DSL.",0.05,assembly
128waxk,jeqgkew,"It wants to be your replacement for Assembly language, or possible C.   What you would likely do is create a DSL in Forth and write a short program in the customized DSL.",0.05,forth
128waxk,jeqgkew,Functional language programs are a lot shorter than C programs.,0.0,c
128waxk,jeqgkew,Anyway you don't like the language then not your replacement for C.,0.0,c
128waxk,jfbicmx,Nobody else would want to learn Pascal.,0.0,pascal
128waxk,jfbicmx,"I keep getting pinged about a remote opportunity where they're looking for Pascal + .NET + AWS and I have to say, I'm both horrified and intrigued by that combination.",-0.1,pascal
128waxk,jen94l2,Except none of this points justify considering Rust a C alternative.,0.0,rust
128waxk,jen94l2,Except none of this points justify considering Rust a C alternative.,0.0,c
128waxk,jen94l2,"As mentioned before, every turing complete language can do what C does, so the capabilities of a language are at most sufficient, but not necessary condition for a language to be called some other language's alternative.",0.11875,c
128waxk,jen94l2,"Instead, these points only somewhat acknowledge that:  - there is a mismatch in the puprose of C and Rust - there is a mismatch of supported platforms of C and Rust - there is a philosophical difference of C and Rust - there is a difference in how C and Rust are handled by programmers  The point that an alternative or replacement for a given workflow is distinct from an alternative for a language is completely missed.",0.1,c
128waxk,jen94l2,"Instead, these points only somewhat acknowledge that:  - there is a mismatch in the puprose of C and Rust - there is a mismatch of supported platforms of C and Rust - there is a philosophical difference of C and Rust - there is a difference in how C and Rust are handled by programmers  The point that an alternative or replacement for a given workflow is distinct from an alternative for a language is completely missed.",0.1,rust
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,java
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,go
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,c
128waxk,jen94l2,"All you said can be applied to Java or even Go, yet they will never be considered a C alternative (they are fundamentally different languages of different sizes, scopes, purposes and things they do well)  There are some trivial objections that I will point out, but will not be addressing, the author should be ashamed of making:  - but it's because it's currently only using LLVM as the compiler backend - Rust is a far better ""alternative"" to C in the embedded space (when it's supported) for this exact reason.",0.14166666666666666,rust
128waxk,jen94l2,- Why would we care if the compiler can run on machines that were around when C was first invented?,0.25,c
128waxk,jen94l2,"Finally, there are several strawmen that I will point out, but will not be addressing, the author should be ashamed of making:  - no that does not invalidate rust's advantages - you wouldn't be able to run modern C compilers like Clang (which uses the same backend as rust) on such limited systems anyway.",0.08979591836734693,rust
128waxk,jen94l2,"Finally, there are several strawmen that I will point out, but will not be addressing, the author should be ashamed of making:  - no that does not invalidate rust's advantages - you wouldn't be able to run modern C compilers like Clang (which uses the same backend as rust) on such limited systems anyway.",0.08979591836734693,c
128n19y,,"But for it to be truly effective, I'd have to have it interop with C++, so that users can define their own interfaces.",0.6,c++
128n19y,jejhwic,"Swift's property wrappers were a somewhat novel approach to solving the scoping problem, kinda, sorta.",0.0,swift
128n19y,jekuf6q,"For C++, there is also [rxqt](https://github.com/tetsurom/rxqt) which ties into Qt's signal's and slots (analogue of C#'s events which were one of the motivations of the original Rx library), and Qt provides you with all of the UI components you need.",0.375,c++
128n19y,jekuf6q,"For C++, there is also [rxqt](https://github.com/tetsurom/rxqt) which ties into Qt's signal's and slots (analogue of C#'s events which were one of the motivations of the original Rx library), and Qt provides you with all of the UI components you need.",0.375,c
128n19y,jekuf6q,"He also developed a Haskell version related to the monad `do` notation, which became [`docase`](https://github.com/tpetricek/Haskell.Joinads) (implemplented as a pre-processor rather than a language extension).",0.05,haskell
128b7pg,,"I was watching a documentary on GraphQL the other day, and it's inspiring to see a technology go from inception to being widely used in production, and honestly I aspire to create something people would use.",0.175,go
128b7pg,,"Which lead me to think, maybe a DSL is the way to go, but writing a DSL to me personally isn't as exciting.",0.3,go
128b7pg,jeip0er,"Go do something else, like basketball, or rock climbing, or weightlifting, or competitive programming.",0.0,go
128b7pg,jei4j7h,"Also, if you have a way for people to install and reuse code snippets, then it can grow like Julia or Elm.",0.0,julia
128b7pg,jei4j7h,"Also, if you have a way for people to install and reuse code snippets, then it can grow like Julia or Elm.",0.0,elm
128b7pg,jek6gnz,I try to leave my hobbies well (enough) documented as I go so I can pick them back up more easily.,0.23333333333333334,go
128b7pg,jek6gnz,I just go with the flow.,0.0,go
128b7pg,jewa5cj,"Glide looks pretty cool though, I like it.",0.3,cool
128b7pg,jeia6ig,"Basically what various langusges do for JS, but for PHP, VBA etc.",0.0,php
128b7pg,jejt79k,"You feed in assembly code, it transliterates to machine code.",0.0,assembly
128b7pg,jejt79k,"Programming in C and C++, the only assembly I even use is inlined so I'm stuck with the GNU syntax anyway.",0.0,c
128b7pg,jejt79k,"Programming in C and C++, the only assembly I even use is inlined so I'm stuck with the GNU syntax anyway.",0.0,c++
128b7pg,jejt79k,"Programming in C and C++, the only assembly I even use is inlined so I'm stuck with the GNU syntax anyway.",0.0,assembly
128b7pg,jemw7f1,"> You feed in assembly code, it transliterates to machine code.",0.0,assembly
1284mk4,jehmvq8,"It's meant to be a dynamically typed functional scripting language, with very uniform syntax (just a bit more syntax than a LISP) and some imperative features sprinkled on top.",0.39999999999999997,lisp
1284mk4,jeiuvot,"Another plan is to write a version of the interpreter directly in C (not transpiled from my language), so as to make this back-end available for others to use.",0.17500000000000002,c
1284mk4,jeiuvot,"This is a minimal Hello program, using C's `puts` as my `print` routines require lots of support:      proc main         loadimm  u64  ""Hello World""         callp         puts* 1 0     end  I believe this will work as it is.",0.033333333333333326,c
1284mk4,jehj3ln,"I made Charm's shell (""the hub"") into a Charm service with (natch) Charm's syntax and semantics.",0.0,shell
1284mk4,jeybmjv,I wrote my language in Go and also have it compiling to wasm so I could embed it in my personal website as a usable demo.,0.0,go
1284mk4,jeybmjv,I have met my goal in making something usable and now I have a performance goal of making my language run as fast as Go's implementation of regex.,0.2,go
1284mk4,jeybmjv,I've got a long way to go because I implemented this in a really dumb way just so I could get it working but I've already made some good improvements.,0.09166666666666666,go
1284mk4,jejiu11,Switching from Gradle Kotlin to Gradle Groovy.,0.0,kotlin
1284mk4,jejiu11,Switching from Gradle Kotlin to Gradle Groovy.,0.0,groovy
1284mk4,jejiu11,Added [Javascript form data](https://github.com/xtclang/xvm/blob/master/lib_web/src/main/x/web/http.x#L268) and [file upload](https://github.com/xtclang/platform/blob/master/platformUI/src/main/x/platformUI/Controller.x#L76) support.,0.0,javascript
1284mk4,jei5zv4,"Random Q:  I’ve been programming exclusively in Python the last 8 or so years, but I studied C++ in college before.",-0.25,python
1284mk4,jei5zv4,"Random Q:  I’ve been programming exclusively in Python the last 8 or so years, but I studied C++ in college before.",-0.25,c++
1284mk4,jei5zv4,How much of C++ do I need to pick up to be comfortable with LLVM code?,0.30000000000000004,c++
1284mk4,jei5zv4,"Also, what would be a good resource for learning modern C++?",0.44999999999999996,c++
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,c
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,java
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,lua
1284mk4,jeip13n,"So far the compiler is written in itself and can output (and bootstrap from) C, Java, JS, Lua, Python and Shark (the one mentioned earlier).",0.05,python
1284mk4,jeqerqo,Linked byte code transpiles into C or run on a byte code interpreter,0.0,c
1284mk4,jh5cv0i,"I have altered perl.vim, the vim syntax highlighting file for Perl, to hide backslashes and escape characters, and use color to distinguish between escaped characters, strings literals, and code.",0.0,perl
1284mk4,jh5cv0i,Here is the file:  [perl.vim](https://pastebin.com/yCZ1wkYY)     I picked Perl because most programmers find the regex syntax especially hard to read.,-0.2777777777777778,perl
1284mk4,jfqtwz6,I couldn't finish it and in retrospective it was basically a reskin for Java (classes inheritance etc).,0.0,java
1284mk4,jfqtwz6,"Now I'm trying again, dropped an 'R' so is now Yz :D, and is still very similar to mainstream, oop langs but **absurdly** simplified.",0.16666666666666666,r
1284mk4,jfqtwz6,"Now I'm trying again, dropped an 'R' so is now Yz :D, and is still very similar to mainstream, oop langs but **absurdly** simplified.",0.16666666666666666,d
1284mk4,jfqtwz6,"Your language gives me hopes and inspiration, I read all the intro in the repo and I see there's html for the tour, although I couldn't find where is hosted.",0.0,html
1284mk4,jekipq5,"> Also, what would be a good resource for learning modern C++  When I don't know something, I like reading the C++ standard and C standard.",0.22499999999999998,c++
1284mk4,jekipq5,"> Also, what would be a good resource for learning modern C++  When I don't know something, I like reading the C++ standard and C standard.",0.22499999999999998,c
1284mk4,jekipq5,"Also, I like reading [cppreference](https://en.cppreference.com/w/cpp), it has the newest info on C++ drafts.",0.0,c++
1284mk4,jfsmpo9,"I wanted something with R since it's basis is Rebol, where also all the lack of reserved words and homoiconicity comes from and I thought about something ""organic"" ... if previous generation of languages were named more by minerals: perl, ruby, ...",0.16666666666666669,r
1284mk4,jfsmpo9,"I wanted something with R since it's basis is Rebol, where also all the lack of reserved words and homoiconicity comes from and I thought about something ""organic"" ... if previous generation of languages were named more by minerals: perl, ruby, ...",0.16666666666666669,perl
1284mk4,jfsmpo9,"I wanted something with R since it's basis is Rebol, where also all the lack of reserved words and homoiconicity comes from and I thought about something ""organic"" ... if previous generation of languages were named more by minerals: perl, ruby, ...",0.16666666666666669,ruby
1284mk4,jfsmpo9,Current ones can be seen here:   [https://refaktor.github.io/rye/TOUR\_0.html](https://refaktor.github.io/rye/TOUR_0.html) \- tour   [https://refaktor.github.io/rye/INTRO\_1.html](https://refaktor.github.io/rye/INTRO_1.html) \- intro to Python programmers     I thought quite long about error handling and I think I have found interesting concept by taking a step back and maybe a step forward but in a different direction than try/catch which I don't like because it muddies the code and is sort of GOTO statement.,-0.05000000000000001,python
1284mk4,jfst1k5,"I can go for hours, actually I'm writing a guide to catch myself into discrepancies.",0.0,go
1284mk4,jfsutsm,"For errors I'm thinking of being values (like in Go), and maybe generics would solve the checking (like `Result` in Rust), that's something I'm still not clear about.",-0.05000000000000001,go
1284mk4,jfsutsm,"For errors I'm thinking of being values (like in Go), and maybe generics would solve the checking (like `Result` in Rust), that's something I'm still not clear about.",-0.05000000000000001,rust
1284mk4,jft1k0k,Cool.,0.35,cool
1284mk4,jft1bqi,"Hehe, cool :) ... Re(d)bol rabbit hole has quite some depth yes :)  I will not try to go too deep on error / failure handling but still ...",0.2066666666666667,cool
1284mk4,jft1bqi,"Hehe, cool :) ... Re(d)bol rabbit hole has quite some depth yes :)  I will not try to go too deep on error / failure handling but still ...",0.2066666666666667,d
1284mk4,jft1bqi,"Hehe, cool :) ... Re(d)bol rabbit hole has quite some depth yes :)  I will not try to go too deep on error / failure handling but still ...",0.2066666666666667,go
1284mk4,jft1bqi,"This was inspired by Go and I think this document: https://middlemost.com/failure-is-your-domain/  Since Failure is just a Rye value, there are also just Rye functions that help you handle them, only they have a flag set that they can handle errors.",-0.15833333333333335,go
1284mk4,jfw858k,I tried your example using `Result` / `Option` like in Rust(tm).,0.0,rust
1284mk4,jfxnxxb,"Hey, this is awesome example with Rust!",1.0,rust
1284mk4,jfxnxxb,:)  I would say it makes sense that Rust returns result wrapped in Result/Option and a dynamic language can return the result or a failure directly.,0.07083333333333333,rust
1284mk4,jfxnxxb,"In Go these are two return values, but in Rye it makes no sense that we would need two, since it can't fail and return correct result at the same time :)  Your Rust example is really nice ... can I use it in a blogpost when I try to explain how Failures in Rye work?",0.15,go
1284mk4,jfxnxxb,"In Go these are two return values, but in Rye it makes no sense that we would need two, since it can't fail and return correct result at the same time :)  Your Rust example is really nice ... can I use it in a blogpost when I try to explain how Failures in Rye work?",0.15,rust
1284mk4,jfxohlp,"Of course, except that that's not Rust, that my fictional language :( but rust has if naturally (even Java).",-0.21666666666666667,rust
1284mk4,jfxohlp,"Of course, except that that's not Rust, that my fictional language :( but rust has if naturally (even Java).",-0.21666666666666667,java
1284mk4,jfxoov6,"Oh, my bad :) ... then your fictional language example is cool :)",0.13000000000000003,cool
1284mk4,jfxt9o6,"haha :"")  I've updated the gist with actual Rust.. (going to try to paste it here)  ```rust fn main() {     let x = split_and_save(10.0, 0.0).unwrap_or_else(|_| -> f32 {1.0});     println!",0.1361111111111111,rust
127h71c,jef36gw,The Indiana version of `concepts` in C++0x could be used to implement modules *properly* in C++.,0.0,c++
127h71c,jefnuc1,I am more familiar with Rust -- its trait is closed to Haskell's typeclass -- and reading the complaints I feel like I can define modular code using Rust trait.,0.25833333333333336,rust
127h71c,jefnuc1,I am more familiar with Rust -- its trait is closed to Haskell's typeclass -- and reading the complaints I feel like I can define modular code using Rust trait.,0.25833333333333336,haskell
127h71c,jefnuc1,"For example, with regard to the stack:      trait Stack<T> {         fn make_empty() -> Self;         fn is_empty(&self) -> bool;         fn pop(&self) -> Option<(Self, T)>;         fn push(&self, item: T) -> Self;     }  And using associated types, it generalizes to the filesystem example:      trait Filesystem {         type Handle: Handle;         type File: File;         type Directory: Directory;         type DirectoryIterator: Iterator<Item = Handle>;          //  some functions     }  There's no built-in theorem prover in Rust, so no compile-time guarantees can be made... for now.",0.0,rust
127h71c,jegjnt2,Like Python and Java both have a concept of modules.,0.0,python
127h71c,jegjnt2,Like Python and Java both have a concept of modules.,0.0,java
127h71c,jegjnt2,"But in Python, apparently a module is essentially just a source file.",0.025,python
127h71c,jegjnt2,"While in Java it's a special kind of way to group your code together (as an alternative to a jar file) using a special `module-info.java` file listing dependencies, exported packages, and other directives.",0.29732142857142857,java
127h71c,jegjnt2,"Meanwhile, this article seems to assert a very specific definition for the concept of modules, which perhaps either does or does not intersect either Python or Java's usage of the term.",0.0,python
127h71c,jegjnt2,"Meanwhile, this article seems to assert a very specific definition for the concept of modules, which perhaps either does or does not intersect either Python or Java's usage of the term.",0.0,java
127h71c,jee9cob,"for 2 decades, yet it's wrongly considered ""obsolete"" due misinformation: Pascal.",-0.3125,pascal
127h71c,jee9cob,"This was due to a, now obsolete magazine's article, that mentioned early version's of Pascal's pinfalls.",-0.012499999999999997,pascal
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,haskell
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,ruby
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,python
127h71c,jee9cob,"But, unlike today's Haskell or Ruby or Python or Rust, the ""obsolete"" mark never got away.",0.0,rust
127h71c,jee9cob,"The same goes for any variant with a different name: Delphi, Ada, FreePascal, Oberon, and of course ""Modula"".",0.0,delphi
127h71c,jee9cob,"The same goes for any variant with a different name: Delphi, Ada, FreePascal, Oberon, and of course ""Modula"".",0.0,ada
127h71c,jee9cob,"And, also ""reinvented"", again and again, most of the times with ingenious, but unnecessary ""hacks"", instead of just learning from Pascal's Modula.",0.19999999999999998,pascal
127h71c,jee9cob,"Another simple ""hack"" was to add the same prefix to all the global non O O. methods to each library file like early  (Plain) C, C++ or PHP files did.",-0.022857142857142854,c
127h71c,jee9cob,"Another simple ""hack"" was to add the same prefix to all the global non O O. methods to each library file like early  (Plain) C, C++ or PHP files did.",-0.022857142857142854,c++
127h71c,jee9cob,"Another simple ""hack"" was to add the same prefix to all the global non O O. methods to each library file like early  (Plain) C, C++ or PHP files did.",-0.022857142857142854,php
127h71c,jee9cob,"Then, C++ and Java ""namespaces"" arrived.",0.0,c++
127h71c,jee9cob,"Then, C++ and Java ""namespaces"" arrived.",0.0,java
127h71c,jee9cob,**Java did add a more organized hierarchical way of namespaces instead of a single plain list like original Modula / Pascal did.,0.14732142857142858,java
127h71c,jee9cob,**Java did add a more organized hierarchical way of namespaces instead of a single plain list like original Modula / Pascal did.,0.14732142857142858,pascal
127h71c,jee9cob,"**  Then, 'static classes"" with ""static members"" arrived, again with Java.",0.5,java
127h71c,jee9cob,"**  This was supported thru ""static class constructors"" and ""static class destructors"" which already existed in Modula / Pascal with a better syntax.",0.5,pascal
127h71c,jee9cob,"The JS, Typescript Prototype trick, mentioned in this post is commonly know as the ""Module Software Design Pattern"".",-0.3,typescript
127h71c,jee9cob,"C++ community quietly accepted this, and finally switched to ""full real modules"" with specific keywords, syntax or semantics, last year, even if it was proposed also 10 years ago.",0.09166666666666667,c++
127h71c,jee9cob,"But, again the ""we don't need anything from Modula / Pascal cause is obsolete and we don't want to be contaminated with obsolescence"" appeared, and their implementation seems ""clunky"".",0.0,pascal
127h71c,jee9cob,from C# / VS to FreePascal / LazarusIDE.,0.0,c
127h71c,jeeccoo,I remember how refreshing it was learning about Haskell's [`containers`](https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map-Strict.html).,0.5,haskell
127h71c,jef47mg,"Currently it's all ""hope your compiler can read C"".",0.0,c
127h71c,jegb7rn,"The brute force of industry, OTOH, doesn't have that luxury, and instead produces monstrosities like C++.",0.0,c++
127h71c,jei7mut,"The article addresses typeclasses in Haskell:   > The downside though is that, without doing some super-advanced stuff, there can be only one such read function for each type.",0.16666666666666666,haskell
127h71c,jei7mut,Go back to having separate readEmployeeFormat1 and readEmployeeFormat2 functions like a pleb.,0.0,go
127h71c,jegzhsd,> reading the complaints I feel like I can define modular code using Rust trait.,0.0,rust
127h71c,jegzhsd,"The big thing ""modules"" in oCalm and others have that most do not is just like (again, as Rust):  ```rust mod stack<T> { //suspiciously look like struct as if a module is not an invisible construct but a first-class thing I can manipulate }  // then maybe you don't need ""hide by default"" because modules hide by default:  -- in file utils.rs mod util {   struct Stack<T> {} //is pub(crate) by default }  -- in file stack.rs mod stack<T> {   use util::Stack //is pub(crate) by default    fn make_empty() -> Stack {} }  // And because modules are first class like structs: fn print_mod(of:&stack<i32>) {}  fn main {   let s = stack<i32>;   print_mod(&s);   let my_stack = s.make_empty() } ```",0.21666666666666665,rust
127h71c,jehs26k,"Oh sure you can, if you want run-time reflection with full generic support such as Java does *not* provide but IIRC .net does.",0.2125,java
127h71c,jeftbj1,"in Java prior to the explicit module system, classes were the smallest unit of modularity.",0.0,java
127h71c,jeftbj1,You can view both Java packages and classes as modules with interfaces.,0.0,java
127h71c,jefq6pd,Yeah I just checked Pascal out of curiosity and honestly it seemed much better than OO mainstream languages for code organization.,0.55,pascal
127h71c,jesqye7,"Doug G wrote the C++ front-end for LLVM, then joined the Swift team; 3.",0.0,c++
127h71c,jesqye7,"Doug G wrote the C++ front-end for LLVM, then joined the Swift team; 3.",0.0,swift
127h71c,jeicd2m,I worked with modules in SML and OCaml before I ever used Haskell seriously.,-0.3333333333333333,haskell
127h71c,jeicd2m,"In fact, this issue is pretty much what led me to switch from ML to Haskell.",0.225,haskell
127h71c,jeicd2m,"Here's a challenge for someone who wants to defend these sort of modules: can you implement something like the Haskell monad transformer stack, using modules instead of type classes?",0.2,haskell
127h71c,jeitsig,"My point was more that, as far as I am concerned, _traits are the modules the author is looking for_ in Rust.",0.3,rust
127h71c,jej4b8c,"For example, the module      module type FileSystem = sig         type filehandle         type dir         type fs_watcher        ...     end  can be written in Java like so       public class FileSystem {         public static class FileHandle {             private int privateField;         }         public static class Dir {}         public static class FsWatcher {}     }",0.1875,java
127h71c,jehrhzb,"To be fair, I studied Pascal in college.",0.7,pascal
127h71c,jeht8q8,"Java was famous at one point for getting people to always write an interface first, then the class, whether or not there would ever be more than one class for that interface.",0.4166666666666667,java
127h71c,jeii5p7,"Just because Haskell's type system lets you do that doesn't mean you have to, nor that it's a good engineering approach.",0.19374999999999998,haskell
127h71c,jeii5p7,OCaml's modules have different tradeoffs than Haskell's type classes and have different strengths.,0.0,haskell
127h71c,jeii5p7,"OCaml's type system is certainly not as powerful as Haskell's, but I consider that a feature.",-0.15,haskell
127h71c,jep8s9w,"Newtyping may work, but specifically for low-level Rust mixed with generics, it will get messy.",-0.1,rust
127h71c,jep8s9w,"In Rust, I'd have to either:   * Change the inner type to `StackListAlt<i32>`, potentially infecting other non-serialization code with this implementation detail (because I'd either need to change signatures or add `as_ref`, `as_mut`, and `into_inner` calls).",-0.041666666666666664,rust
127h71c,jep8s9w,"Personally, I think Rust would have benefitted with OCaml-style modules (although I don't know consequences that entails).",0.0,rust
127h71c,jekgkou,"So I think that no, Rust's Traits do not fulfill the Module requirements the blog post is alluding to.",0.0,rust
127h71c,jeln56d,Nothing stops you from solving your actual problems in Haskell.,0.0,haskell
127h71c,jeln56d,"In fact, what I was saying is that I ended up preferring using Haskell over the ML family precisely because it was easier to solve actual problems with typeclasses than with parameterized modules.",0.2,haskell
127h71c,jeln56d,Rust is a recent example of this.,0.0,rust
127h71c,jen34l6,"Seems to fit the bill, though I'm far from a Java IDE right now, can't check.",0.2619047619047619,java
127h71c,jep61pt,"Go all the way back to 1971 and David Parnas's paper ""[On the criteria to be used in decomposing systems into modules](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf)"".",0.0,go
127h71c,jep61pt,Ruby traits are mix-ins.,0.0,ruby
127h71c,jep61pt,"Haskell type-classes are contract specifications, but they only focus on one type at a time.",0.0,haskell
127h71c,jep61pt,Sorry; I don't know rust.,-0.5,rust
1279h73,,"Sophie is pure and lazy, similar to Haskell, but has an algebraic syntax reminiscent of Pascal.",-0.008928571428571432,haskell
1279h73,,"Sophie is pure and lazy, similar to Haskell, but has an algebraic syntax reminiscent of Pascal.",-0.008928571428571432,pascal
1279h73,,"* [Documentation, including tutorial and various technical notes](https://sophie.readthedocs.io) * [Literate Formal Grammar](https://github.com/kjosib/sophie/blob/main/sophie/Sophie.md) * [Main GitHub page](https://github.com/kjosib/sophie) * [Examples](https://github.com/kjosib/sophie/tree/main/examples)  # The Current State of Affairs:  Initial implementation is in Python, but the semantics are as unlike Python as I can manage.",0.03333333333333333,python
1279h73,,"Long-term I'd like to go with symbolic evaluation because it's more precise, but it's also beyond my comprehension, so bonus!",0.5,go
1279h73,,"At this point, I'm leaning towards the ELM model/update/view concept.",0.0,elm
1279h73,jedokct,It's still Python and has been used for a number of language projects.,0.0,python
1279h73,jedjbh3,"I just retake my functional strict language static and strong typed, implemented in python this week.",0.4666666666666667,python
1279h73,jege24b,The `end.` (with a period) at the end of a file is actually a nod to Pascal.,0.0,pascal
1279h73,jedjtlc,I'm also writing it in python.,0.0,python
1279h73,jedjtlc,I had a Haskell setup at first but then I leave it without touch for two months and when I wanted to use it again... too much wait.,0.225,haskell
1279h73,jedjtlc,"Well, python is the closest I know to that.",0.0,python
1279h73,jehi4jw,I at once recognized `end.` with a period as a borrowing from Pascal.,0.0,pascal
1279h73,jehi4jw,"In the late 1980s, Pascal was big.",-0.15,pascal
1279h73,jehi4jw,Why did C win out over Pascal?,0.8,c
1279h73,jehi4jw,Why did C win out over Pascal?,0.8,pascal
1279h73,jehi4jw,"(Python is even shorter, and therefore perhaps even better than curly brace languages.)",0.5,python
1279h73,jehi4jw,"I've written a fair amount of Pascal, and I can tell you it really is tedious to have to type ""begin"" and ""end"" over and over.",0.09999999999999998,pascal
1279h73,jehi4jw,Pascal code is littered with `THEN BEGIN` and `END ELSE BEGIN` verbiage.,0.0,pascal
1274jaw,jedsbp1,"Very cool project after look a little bit around the code i see that compiler requires file to be .olv extensions which in my opio is not that good, syntax is very normal without any bigger abstractions and i like it.",0.23249999999999998,cool
1274jaw,jedsbp1,Also ur using C in which i'm in love.,0.5,c
1274jaw,jedk6fa,Rust's match keyword,0.0,rust
1274jaw,jedtz9w,"Cool, I wish u luck!",0.4375,cool
1274jaw,jeflk6j,"some people are too serious, but i don't care about downvotes :D",0.33333333333333337,d
1274jaw,jecsmoq,"Tbh, I only went the C style switch route cause it was pretty challenging to get them to work.",0.25,c
1274jaw,jee9t1g,See Python for an example of how it can look in dynamically typed languages.,0.0,python
1274jaw,jedpt19,"I believe that C is like that because of C being ""portable assembly"" --- `break` corresponds to a jump instruction, whereas falling through corresponds to no instruction and so is the default.",0.0,c
1274jaw,jedpt19,"I believe that C is like that because of C being ""portable assembly"" --- `break` corresponds to a jump instruction, whereas falling through corresponds to no instruction and so is the default.",0.0,assembly
1274jaw,jedpt19,"But although that's a reason why C was like that, it's not a reason why we should copy it, we can spare a few more clock cycles on compilation nowadays.",0.15,c
1274jaw,jee3pdo,The crude way that C's `switch` works means that fallthrough is essential.,-0.35,c
1274jaw,jee3pdo,"Although you'd lose the other weird behaviours of C's completely unstructured switch, where `case` and `default` labels can appear literally anywhere, and at any nested level, within the statement that follows `switch (x)`.",-0.17500000000000002,c
1274jaw,jee3pdo,"I noticed also that the OP is keeping C's `for` loop syntax alive, although TBF that was in Lox too.",0.1,c
1274jaw,jekl19k,"Just like in Java, or any other language that supports these keywords.",-0.125,java
12737gc,jefjbzf,It's its own form of assembly code.,0.6,assembly
126jwi7,jed8xmh,"Yes, Lisp style, thank you for the remark.",0.0,lisp
126hsfi,jeaakbc,"Oh that's cool, I didn't know that.",0.35,cool
126d6cl,,I'm building a small interpreted language in Rust.,-0.25,rust
126bz6c,je8zlk8,This would include Turing-complete PLs --- though IIRC I was leaning on the idea that every culture no matter how alien must basically invent Lisp and Forth or something very like them.,-0.024999999999999994,lisp
126bz6c,je8zlk8,This would include Turing-complete PLs --- though IIRC I was leaning on the idea that every culture no matter how alien must basically invent Lisp and Forth or something very like them.,-0.024999999999999994,forth
126bz6c,je8zlk8,"I had a lot of fun planning how I could do this so the game would be playable and solvable, and how the language could be learnable, and all the stuff you'd learn about the owner of the computer and their culture as you'd go along ... but then I remembered all the other stuff I ought to be doing that's probably more useful.",0.11499999999999999,go
126bz6c,je8zlk8,"I mean, most langdev projects also don't come to much but there ya go.",0.12916666666666668,go
126bz6c,je95kwo,"https://github.com/kesh-lang/kesh  I already had some ideas for what JavaScript could have become had it not taken a wrong turn in its early days, when it was called Mocha.",-0.2,javascript
126bz6c,jeg7qih,If I go the route of a less symbolic language and one more dependent on ordinary (fantasy-language) keywords for most of the syntax.,0.14583333333333334,go
126bz6c,jg4zw7d,this is so cool!!,0.546875,cool
126bz6c,jnvg1g4,I can go back to something that was previously being discussed if the discussion gets sidetracked.,-0.08333333333333333,go
126bz6c,jnxcpnf,"--- because code in JVM bytecode is written by computers, and designed to be written by computers, whereas humans use Java, designed for humans, to keep them from having to touch or know about the bytecode.",0.0,java
126bz6c,jnxezzv,Humans don't typically write assembly code as much as they used to either.,0.016666666666666677,assembly
126bz6c,jnxezzv,Nevertheless assembly code and stack machines have their place in substantial strategic computer architecture longevity.,0.0,assembly
126bz6c,jnxezzv,"Any alien we can make intelligible guesses about, is going to use stack architectures, assembly code, and binary code.",-0.25,assembly
126bz6c,jnxezzv,Beings that could do 8 things at one time and so forth.,0.0,forth
126bz6c,jnykgsn,"An overwhelming, multiple-nines majority of assembly language is also written by computers, because although good assembly is more efficient, it's less ergonomic for humans.",0.3833333333333333,assembly
126bz6c,jnyoepg,"No matter how unpopular you may think various forms of assembly code are, thousands upon thousands of computer programmers do use it for real stuff.",0.1,assembly
126bz6c,jnyyzr8,"So I'm supposing an alien race for whom something like Forth would genuinely be more ergonomic than OOP, so they'd overwhelmingly use that.",0.25,forth
126bz6c,jnyyzr8,You're responding by telling me that there's a living to be made in writing assembly.,0.0,assembly
1268gl2,,"What do you guys think: [https://github.com/cmspeedrunner/Zang](https://github.com/cmspeedrunner/Zang) Theres also a vid comparing its speed to nim and go:  NIM COMPARISON: [https://www.youtube.com/watch?v=XSVTSIS9\_ZQ](https://www.youtube.com/watch?v=XSVTSIS9_ZQ)  GO COMPARISON: [https://www.youtube.com/watch?v=uA1e3tRgROI](https://www.youtube.com/watch?v=uA1e3tRgROI)  (BOTH THESE VIDS ARE A JOKE, ALTHOUGH IT WAS SLIGHTLY BETTER THEN NIM AND GO AT THESE TWO TESTS, I DO NOT THINK ZANG IS BETTER THEN NIM OR GO AT ALL)",-0.25,go
1268gl2,jecmcgn,">(BOTH THESE VIDS ARE A JOKE, ALTHOUGH IT WAS SLIGHTLY BETTER THEN NIM AND GO AT THESE TWO TESTS, I DO NOT THINK ZANG IS BETTER THEN NIM OR GO AT ALL)  I'm glad you said that, because in the Nim video it's evident by your command and the compiler output that you compiled the Nim app in full debug mode without optimizations :) [https://i.imgur.com/t3OX2IW.png](https://i.imgur.com/t3OX2IW.png) (notice the DEBUG BUILD in caps, which was added because some people specifically complained that Nim was slow :P)",0.3055555555555556,go
1268gl2,jev6jyl,Change the shell name from shell.py to shell.,0.0,shell
1268gl2,jev6jyl,Add `#!/usr/bin/env python3`  Now you can just go in the terminal and type ``` shell ``` And it will open.,0.0,go
1268gl2,jev6jyl,Add `#!/usr/bin/env python3`  Now you can just go in the terminal and type ``` shell ``` And it will open.,0.0,shell
1268gl2,je9lcz2,"language design, and your right, its kinda similar to python but its just a start for me, i am planning to make a nim-style, compiled language with static typing and borrow checking rather then garbage compiler.",0.2619047619047619,python
1268gl2,je9lcz2,"It will be easier to read then nim and have elements from languages like rust, zig and python, but all rolled together into one big batteries included language.",0.0,rust
1268gl2,je9lcz2,"It will be easier to read then nim and have elements from languages like rust, zig and python, but all rolled together into one big batteries included language.",0.0,python
1268gl2,jebaa6b,This stuff is cool and you should be proud of it.,0.575,cool
1268gl2,jec612f,This is just a wrapper for Python - it is literally just Python with a different syntax.,0.0,python
1268gl2,jec612f,"You wouldn't say that C and Python are isomorphic because even though you can do the same things, some things in Python take a lot more work in C, and vice versa.",0.25,c
1268gl2,jec612f,"You wouldn't say that C and Python are isomorphic because even though you can do the same things, some things in Python take a lot more work in C, and vice versa.",0.25,python
1268gl2,jec612f,Saying this is isomorphic to Python is an important point because it does the exact same things Python does.,0.21666666666666667,python
1264f31,je80qgs,"..., and as someone who studied LISP before the FP trend, an a compiler researcher, found this project with a compiler developer CEO, interesting 👍",0.5,lisp
1264f31,je91k0l,I'm just glad the Haskell gang are finally gettin paid real money and are getting rockstar popularity.,0.2333333333333333,haskell
12649s2,,"By this I mean that  -	the keywords of the PL can be written in more than one human language -	the standard library makes sense in more than one human language -	the compiler can handle symbol names with international characters  Off the top of my head, my thoughts are that some languages are practically extensible enough to support this; some LISP languages come to mind.",0.13194444444444445,lisp
12649s2,,(Does that mean I can write C in Swahili?),-0.3125,c
12649s2,je7pb9l,"But usually they don't exist in isolation:  * APIs for the OS will likely use English-based names for functions, macros, variables, types, enums * APIs for 1000s of external libraries will do the same * Other associated languages like make files or scripts will likely still have keywords in English * External tools like linkers will still have their original names, will use the original English-based command-line options, and messages are likely to be in English unless they adapt to locale * File formats like HTML will use English-based tags etc  I suspect most languages limit internationalisation to Unicode identifiers, string literal data and comments.",0.0673076923076923,html
12649s2,je7pb9l,"Even if there was a Swahili C version, you might have trouble sharing your code with someone using C customised to another language.",-0.2,c
12649s2,je8dc5o,"Java, and by extension JRE languages, support unicode in identifiers.",0.0,java
12649s2,je8dc5o,"If you want to make a language-agnostic language, APL gets mentioned because it has only symbols.",0.0,apl
12649s2,je8dc5o,So for example Python's `getattr(...)` function is toast.,0.0,python
12649s2,je81dej,"Not exactly more than one human language, but APL might interests you.",-0.125,apl
12649s2,je918av,"In Japan, it’s even more so, because, if you look at the Japanese     COBOL text, you find verbs and connecting words and Roman characters in English and the     nouns in Japanese and Japanese characters.",0.1,cobol
12649s2,je918av,"Actually, COBOL has become a language you can talk to programmers around the world.",0.0,cobol
12649s2,je918av,"And the nouns, they’d just have to have a     dictionary for things they were referring to for inventory control and other things like that.",-0.125,d
12649s2,je918av,"They’d     have common nouns throughout NATO, and they could make a dictionary of common verbs and     CHM Ref: X5142.2009 © 1980 Computer History Museum Page 10 of 54     translate the program.",-0.3,d
12649s2,je918av,You could write one in English and you could translate it and it could go     to the xxxx.,0.0,go
12649s2,je918av,"No problem, you’d have communication.",0.0,d
12649s2,je92kvi,"Not exactly what you asked for, but there are programming languages that do not have keywords and therefore make sense in almost all human languages  Off the top of my head, I can think of APL, BQN, and brainfuck, but I'm sure there are more",0.275,apl
12649s2,je7kni0,Swift comes to mind.,0.0,swift
12649s2,je7kni0,I would need to double check Rust and I am not sure about kotlin/java or javascript.,-0.125,rust
12649s2,je7kni0,I would need to double check Rust and I am not sure about kotlin/java or javascript.,-0.125,javascript
12649s2,je827sr,In ruby there is an alias keyword which lets you alias any function or identifier to a keyword of your choice.,0.0,ruby
12649s2,je827sr,"I think it would be interesting to build i8n into the language from the getgo but in ruby you could just create a ""aliases.rb"" file and just include that in the top of your program.",0.5,ruby
12649s2,je8ws84,"1с, the programming language in the 1c accounting thing is technically written in Russian but supports English as well and it's a mix of basic and c++  Granted it's a weird case since it's a language that exists only for a single tool(then again so is gdscript for Godot)",-0.08163265306122448,c++
12649s2,jehvdpt,"> If you want to make a language-agnostic language, APL gets mentioned because it has only symbols.",0.0,apl
12649s2,jehvdpt,APL truly is the most egalitarian language - all humans don't understand it equally.,0.25,apl
12649s2,jec6nju,> So for example Python's  `getattr(...)`   function is toast.,0.0,python
12649s2,jec6nju,That's all a very tall order for Python but I suspect it's doable using a variation of the symbol-related functions used to write `syntax-case` macros in R6RS Scheme.,0.2,python
12649s2,jec6nju,That's all a very tall order for Python but I suspect it's doable using a variation of the symbol-related functions used to write `syntax-case` macros in R6RS Scheme.,0.2,scheme
12649s2,je8vgwv,Programmers would refer to items by whatever name they go by in the programmer's desired locale.,0.0,go
12649s2,je8y5z0,"I learned to program using Basic (and then Comal, Pascal, C, ...) without understanding that GOSUB referred to ""go run sub-routine"".",0.0,pascal
12649s2,je8y5z0,"I learned to program using Basic (and then Comal, Pascal, C, ...) without understanding that GOSUB referred to ""go run sub-routine"".",0.0,c
12649s2,je8y5z0,"I learned to program using Basic (and then Comal, Pascal, C, ...) without understanding that GOSUB referred to ""go run sub-routine"".",0.0,go
12649s2,jeaqex2,"Early Ruby libraries were often written in Japanese if I recall, which shows a preference for unicode everything where possible.",0.03333333333333333,ruby
12649s2,jeaw7l7,"In his 1995 book Komputika Leksikono, Sergio Pokrovskij gives code samples in a version of Pascal with Esperanto keywords.",0.0,pascal
12649s2,je9ogt3,Lisp Factor Smalltalk are all good exames,0.7,lisp
125qpy1,,Here we go at last!,0.0,go
125qpy1,,"Spinnaker is my attempt to address the pet peeves I have in regards to the functional programming languages I've tried (mainly Haskell, Elm, OCaml, Roc...) and a way to create something fun and instructive.",0.23333333333333334,haskell
125qpy1,,"Spinnaker is my attempt to address the pet peeves I have in regards to the functional programming languages I've tried (mainly Haskell, Elm, OCaml, Roc...) and a way to create something fun and instructive.",0.23333333333333334,elm
125qpy1,,"Being inspired by Roc, I decided to go with monomorphization and defunctionalization.",0.0,go
125qpy1,,"My ultimate aim is to compile to C. Right now the available targets are JS, Scheme and an interpreter.",0.22857142857142856,scheme
125qpy1,,I also didn't know Haskell very well before starting this project.,0.1,haskell
125qpy1,je60jqf,Haskell programmers usually use `Text` from the [text](https://hackage.haskell.org/package/text) package instead.,-0.25,haskell
125qpy1,je60jqf,"I know Haskell programmers are pretty bad at using good names, but please try to come up with something more useful than that.",0.21000000000000002,haskell
125qpy1,je8ej1y,looks cool,0.35,cool
125qpy1,jeb7l5y,"SML, OCaml and Haskell have demonstrated that a good choice of data representation can give extremely solid performance with a simple compilation scheme that supports polymorphism.",0.2333333333333333,haskell
125qpy1,jeb7l5y,"SML, OCaml and Haskell have demonstrated that a good choice of data representation can give extremely solid performance with a simple compilation scheme that supports polymorphism.",0.2333333333333333,scheme
125qpy1,je8q9bg,This is very cool!,0.56875,cool
125qpy1,je8q9bg,Waiting for C backend so Spinnaker can be more low level.,0.25,c
125qpy1,je8q9bg,Anyways cool work and have a nice day/night.,0.475,cool
125qpy1,jedscko,"Cool project, I would dive into the code, but I don't know Haskell, so out of curiosity, what is the compilation model?",0.35,cool
125qpy1,jedscko,"Cool project, I would dive into the code, but I don't know Haskell, so out of curiosity, what is the compilation model?",0.35,haskell
125qpy1,jedscko,What is the Scheme implementation currently targeted?,0.0,scheme
125qpy1,je6unmo,"I would like to self host some day, so whatever feature I use in Haskell, I'd have to implement in Spinnaker (this is why I don't use records).",0.0,haskell
125qpy1,jebwlge,"Monomorphization was one of the easiest parts to implement, and it makes it dead-simple to compile down to C.  While Haskell does have solid performance, it achieves it through a great deal of research on optimization, special-casing and runtime trickery.",0.21481481481481482,haskell
125qpy1,jeeb12l,"As for recursive type inference, I would recommend learning some haskell basics, then you could look into [this](https://web.cecs.pdx.edu/~mpj/thih/), it was extremely useful to me.",0.3,haskell
125qpy1,jeeb12l,"I'm using gambit-c as my scheme implementation, but it should work on any r5rs that implements syntax-rules and define-macro.",0.0,scheme
125qpy1,jeeb12l,"Gambit is cool because it compiles to quite fast C, but god is it slow at compiling medium-sized code.",0.08333333333333333,cool
125qpy1,jeeb12l,"Gambit is cool because it compiles to quite fast C, but god is it slow at compiling medium-sized code.",0.08333333333333333,c
125qpy1,je9eoqd,"writeMutVar# :: MutVar# d a -> a -> State# d -> State# d     readMutVar# :: MutVar# d a -> State# d -> (# State# d, a #)  In the case of `IORef`s, that `d` parameter is just `RealWorld`.",0.0,d
125qpy1,je9eoqd,"GHC uses these to maintain data dependencies between `IO` statements since Haskell is lazy, but if your language is strict, you already have control flow dependencies.",-0.25,haskell
125qpy1,je9eoqd,"Well, I hope you don't represent strings as linked lists of UTF-32 codepoints, so it's not like Spinnaker has an equivalent to Haskell `String`s :)  You only need to implement a string type that mimics the subset of the `Text` interface that you use in the compiler, but you would probably want to do that anyway, right?",0.2619047619047619,haskell
125qpy1,je7xp66,:D  https://www.northsails.com/sailing/en/2021/01/difference-between-gennaker-and-spinnaker,1.0,d
125qpy1,jedrhij,"> While Haskell does have solid performance, it achieves it through a great deal of research on optimization, special-casing and runtime trickery.",0.4,haskell
125qpy1,jedrhij,Haskell is hampered by being a lazy-by-default language.,0.0,haskell
125qpy1,jedrhij,"On the other hand, OCaml (or, for example, Chez Scheme) get good performance by implementing simpler optimization and judicious runtime-representation choices.",0.2875,scheme
125qpy1,jedrhij,"I don't think you would need monomorphization to compile down to C. Functional languages that don't do monomorphization typically pick a uniform/untyped representation of values, and you can compile down to C by using this uniform representation in the C code.",-0.1592592592592593,c
125qpy1,jedrhij,"Currently your backends can rely on a garbage collector in their implementation language (Scheme, Haskell), so you don't have to worry about garbage collection.",0.0,scheme
125qpy1,jedrhij,"Currently your backends can rely on a garbage collector in their implementation language (Scheme, Haskell), so you don't have to worry about garbage collection.",0.0,haskell
125qpy1,jedrhij,For a C backend you would have to implement your own garbage collector.,0.6,c
125qpy1,je9odxs,"Of course the `js` and `scm` backends don't care, but with C it would need some work.",0.0,c
125qpy1,je9odxs,"> Well, I hope you don't represent strings as linked lists of UTF-32 codepoints, so it's not like Spinnaker has an equivalent to Haskell Strings :)  Guess what, that's exactly what I'm doing :).",0.4166666666666667,haskell
125qpy1,jeit5nf,"I think the ""platform"" idea makes more sense if you come from Elm, which gives you a set way to interact with the browser and then leaves the rest to port and custom html components.",0.5,elm
125qpy1,jeit5nf,"I think the ""platform"" idea makes more sense if you come from Elm, which gives you a set way to interact with the browser and then leaves the rest to port and custom html components.",0.5,html
125qpy1,je8rcqo,"Got it, thank you, I don't think this will go past the hobby stage.",-0.25,go
125qpy1,jedvyu7,"There is similar doc in the GHC commentary, but it is more complex / harder to read in my experience : https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects  I haven't been able to find again a pointer to similar information for Chez Scheme.",0.09999999999999999,scheme
125qpy1,jej57nr,"I would really like to know how Chez works as it is said to be the most performant Scheme implementation, beating event the compiled ones, but the code base feel quite overwhelming.",0.09999999999999998,scheme
125nu69,je53178,It looks similar to LISP.,0.0,lisp
125nu69,je565tl,"But, if you want to add either C alike unions or enumerated values, you could use the pipe:      ( gameobjectenum = ( enemyID | playerID | obstacleID | weaponID )  And:    ( player = (       (ID: gameobjectenum),       (Health: Word ),       (Armor: Word ),       (Weapon: Word ),       (Damage: Word),     )  Since the previous was a type declaration, how do your make a variable of that type ?",-0.6333333333333333,c
1258dwg,,[Rust is a Scalable Language](https://matklad.github.io/2023/03/28/rust-is-a-scalable-language.html)   [Everything's an API](https://buttondown.email/hillelwayne/archive/everythings-an-api/),0.0,rust
1258dwg,je3yhsa,"Rust in particular thrives despite Cargo, not because of it.",0.16666666666666666,rust
1258dwg,je3xeaa,**Rust's Module System promotes API stability.,0.0,rust
1258dwg,je4qeaz,"The problem with an universal tool is that all those libraries would still have no interop, because some people decided that all we need is pretending everything is C.",0.0,c
1258dwg,je8w4o2,"But you can look at the Java world (yes, really) as a decent example to follow: Gradle supports bidirectional interop with both Maven and Ant builds, and both Maven and Ivy packages, and all three build systems are extensible to other languages like Kotlin.",0.02083333333333333,java
1258dwg,je8w4o2,"But you can look at the Java world (yes, really) as a decent example to follow: Gradle supports bidirectional interop with both Maven and Ant builds, and both Maven and Ivy packages, and all three build systems are extensible to other languages like Kotlin.",0.02083333333333333,kotlin
1252ekz,je2cg1p,"It's probably the most explicit language with a large amount of available samples, like Java 8 or something.",0.37142857142857144,java
1252ekz,je2lhjt,Or at least that is my reasoning but I have not properly tried this yet beyond rust and haskell (I also think there's simply not enough agda data (or a any other language with dependent types) in the training set.,-0.10625,rust
1252ekz,je2lhjt,Or at least that is my reasoning but I have not properly tried this yet beyond rust and haskell (I also think there's simply not enough agda data (or a any other language with dependent types) in the training set.,-0.10625,haskell
1252ekz,je4gxlp,I'm very sad to see a community I consider to be innovative to go this direction.,-0.07500000000000001,go
124yk3s,je1pj1l,That's the big difference between the traditional JS and Rust here.,0.0,rust
124yk3s,je1pj1l,"> I personally like having a method ""namespaced"" to a class/struct, since it provides a kind of organization that I personally like (indented), but I also quite enjoy Rust/Go struct style  Is the Rust syntax not already indented?",0.25,rust
124yk3s,je1pj1l,"The use of the word ""but"" implying not, however I think you have both of what you want in the Rust syntax.",0.0,rust
124yk3s,je1v9p1,A counterargument (inspired by Go's comment style) would be that it makes grepping for a class's methods within a directory easier.,0.0,go
124yk3s,je4yhvo,"That is why in C++ we more commonly use friend functions that have access to the arguments' private members, but are otherwise free functions with two arguments.",0.15000000000000002,c++
124yk3s,je4yhvo,"Even in languages like D, operator overloading requires both `opBinary`, `opBinaryRight` and their friends, and `==` is rewritten into a call to static `Object.opEquals` which does (among other things) `lhs.opEquals(rhs) && rhs.opEquals(lhs)`.",0.1875,d
124yk3s,je4yhvo,"Also, we can go further with this: In my own language, `.` is a user-defined operator with the same precedence as whitespace function application.",0.19999999999999998,go
124yk3s,je4yhvo,"(f: a -> b): b = f x          test ""dot operator"" with         let f = (+) in         assert (40 .f 2 == 42)  In fact languages such as Haskell and L.B.",0.0,haskell
124yk3s,je4yhvo,"foo (x: Int) (y: Int) = x + y     foo (x: Int) (y: Float) = x + floor y          test ""foo"" with         assert (foo 40 2 == 42);         assert (foo 40 2.5 == 42);         assert (40 .foo 2 == 42);         assert (40 .foo 2.5 == 42)  Doing the same with ""methods"" as are in Java, Rust or PHP, is simply impossible.",-0.3333333333333333,java
124yk3s,je4yhvo,"foo (x: Int) (y: Int) = x + y     foo (x: Int) (y: Float) = x + floor y          test ""foo"" with         assert (foo 40 2 == 42);         assert (foo 40 2.5 == 42);         assert (40 .foo 2 == 42);         assert (40 .foo 2.5 == 42)  Doing the same with ""methods"" as are in Java, Rust or PHP, is simply impossible.",-0.3333333333333333,rust
124yk3s,je4yhvo,"foo (x: Int) (y: Int) = x + y     foo (x: Int) (y: Float) = x + floor y          test ""foo"" with         assert (foo 40 2 == 42);         assert (foo 40 2.5 == 42);         assert (40 .foo 2 == 42);         assert (40 .foo 2.5 == 42)  Doing the same with ""methods"" as are in Java, Rust or PHP, is simply impossible.",-0.3333333333333333,php
124yk3s,je4yhvo,"C# surprisingly, can do it with static methods and `dynamic` objects using the DLR, where everything is determined at runtime.",0.39999999999999997,c
124yk3s,je2j0vk,"In the case of rust, searching for the methods is improved over go, for go I have to use a regex while with rust I just search ""impl typename"".",0.0,rust
124yk3s,je2j0vk,"In the case of rust, searching for the methods is improved over go, for go I have to use a regex while with rust I just search ""impl typename"".",0.0,go
124yk3s,je7a8ry,"> foo = Foo(2, 'goodnight');     > foo     { bar = 2, baz = 'goodnight' }     > foo.addToBar(1)     { bar = 3, baz = 'goodnight' }     > foo.appendToBaz(', moon')     { bar = 2, baz = 'goodnight, moon' }  Where this gets powerful is that you can define something similar to extension methods in C# fairly easily, simply by placing the method definition outside the function:      > def appendToBaz(thingWithBaz, toAppend) =>     .",0.16,c
124yk3s,je6xuse,One note is the TypeScript way conflicts with some uses of generics.,0.0,typescript
124yk3s,je6xuse,"Example:      struct Identity<T> {       inner: T     }      impl I<i32> {       // I can call foo.add(10),       // but only if foo : Identity<i32>       fn add(self, x: i32) -> Identity<i32> {         Identity { inner: self.inner + x }       }     }  As far as I know there isn’t a good way of doing this in TypeScript.",0.15999999999999998,typescript
124yk3s,je6xuse,"Scala had the same issue, and there you often workaround this by asking for an implicit equality witness.",0.0,scala
124yk3s,je1qhv6,"Yes definitely, you're right, I actually had Go in mind writing that (where functions/methods are in the same level as the struct), I like Rust's approach, the only difference in syntax being the declarations in a different place (within the \`impl\`).",0.047619047619047616,go
124yk3s,je1qhv6,"Yes definitely, you're right, I actually had Go in mind writing that (where functions/methods are in the same level as the struct), I like Rust's approach, the only difference in syntax being the declarations in a different place (within the \`impl\`).",0.047619047619047616,rust
124yk3s,je1qhv6,"Really good point about the inheritance, tbh inheritance is so natural to me when programming Python that I never though about it that much, with Go composition normally is good enough, and Rust it seems the mindset is so different, traits tend to solve that most of the times, I'm not a big fan of the composition via Enum thing though.",0.275,python
124yk3s,je1qhv6,"Really good point about the inheritance, tbh inheritance is so natural to me when programming Python that I never though about it that much, with Go composition normally is good enough, and Rust it seems the mindset is so different, traits tend to solve that most of the times, I'm not a big fan of the composition via Enum thing though.",0.275,go
124yk3s,je1qhv6,"Really good point about the inheritance, tbh inheritance is so natural to me when programming Python that I never though about it that much, with Go composition normally is good enough, and Rust it seems the mindset is so different, traits tend to solve that most of the times, I'm not a big fan of the composition via Enum thing though.",0.275,rust
124yk3s,je2grll,"Swift and kotlin allow you to have class/struct/enum ""extensions"", which can add new methods onto existing classes, and of course more dynamic languages like smalltalk, ruby etc.",0.21212121212121213,swift
124yk3s,je2grll,"Swift and kotlin allow you to have class/struct/enum ""extensions"", which can add new methods onto existing classes, and of course more dynamic languages like smalltalk, ruby etc.",0.21212121212121213,kotlin
124yk3s,je2grll,"Swift and kotlin allow you to have class/struct/enum ""extensions"", which can add new methods onto existing classes, and of course more dynamic languages like smalltalk, ruby etc.",0.21212121212121213,ruby
124yk3s,je787pv,"EDIT: Also, [TypeScript's intersection types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types) (and [Ceylon's](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types)) and how they allow to represent a multimethod's type as `(a -> b) & (c -> d)` (I know TypeScript doesn't document it for whatever reasons, but `((x: T) => U) & ((y: V) => W)` is valid code).",0.0,typescript
124yk3s,je787pv,"EDIT: Also, [TypeScript's intersection types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types) (and [Ceylon's](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types)) and how they allow to represent a multimethod's type as `(a -> b) & (c -> d)` (I know TypeScript doesn't document it for whatever reasons, but `((x: T) => U) & ((y: V) => W)` is valid code).",0.0,c
124yk3s,je787pv,"EDIT: Also, [TypeScript's intersection types](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types) (and [Ceylon's](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types)) and how they allow to represent a multimethod's type as `(a -> b) & (c -> d)` (I know TypeScript doesn't document it for whatever reasons, but `((x: T) => U) & ((y: V) => W)` is valid code).",0.0,d
124h3n7,,From my Prolog days I recall that the compiler would warn if a predicate could be satisfied in more than one way.,0.5,prolog
124h3n7,jdzf1mm,Now I will need to figure out whether to go with *multi-value* or *choice*.,0.0,go
124h3n7,jee3h9e,"Actually, it will be up to libraries as I try to avoid the Prolog default depth-first search strategy when faced with choices (*non-determinism* in Prolog).",0.0,prolog
123sn1i,,"People seem to love rust's macro system, and I wonder what other tools exist for meta-programming other than macros.",0.08333333333333333,rust
123sn1i,jdxnb64,"//implicit Haskell style:     add x y = x + y     //etc...     applyTo x f = f x          fs = [add 2, mul 2, flip div 2] //note the need of flip     main = putStrLn (map (applyTo 5) fs) //[7, 10, 2.5]  --      //explicit Scala style:     ...          def fs = [(add 2 _), (mul 2 _), (div _ 2)] //note the underscore's placement     def main = putStrLn(map(_(5), fs)) //[7, 10, 2.5]  I'll let you imagine how many different routines I'd have to manually write to get the same effect in C, at which point I'd just manually roll my own loops rather than reuse library functions.",0.23888888888888885,haskell
123sn1i,jdxnb64,"//implicit Haskell style:     add x y = x + y     //etc...     applyTo x f = f x          fs = [add 2, mul 2, flip div 2] //note the need of flip     main = putStrLn (map (applyTo 5) fs) //[7, 10, 2.5]  --      //explicit Scala style:     ...          def fs = [(add 2 _), (mul 2 _), (div _ 2)] //note the underscore's placement     def main = putStrLn(map(_(5), fs)) //[7, 10, 2.5]  I'll let you imagine how many different routines I'd have to manually write to get the same effect in C, at which point I'd just manually roll my own loops rather than reuse library functions.",0.23888888888888885,scala
123sn1i,jdxnb64,"//implicit Haskell style:     add x y = x + y     //etc...     applyTo x f = f x          fs = [add 2, mul 2, flip div 2] //note the need of flip     main = putStrLn (map (applyTo 5) fs) //[7, 10, 2.5]  --      //explicit Scala style:     ...          def fs = [(add 2 _), (mul 2 _), (div _ 2)] //note the underscore's placement     def main = putStrLn(map(_(5), fs)) //[7, 10, 2.5]  I'll let you imagine how many different routines I'd have to manually write to get the same effect in C, at which point I'd just manually roll my own loops rather than reuse library functions.",0.23888888888888885,c
123sn1i,jdwrzyt,To me Ruby is the best for things like this.,1.0,ruby
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,ruby
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,go
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,rust
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,haskell
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,python
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,java
123sn1i,jdxdr5q,"making packages shit-easy to *publish*  like node.js, ruby, go, rust, haskell, and python  not like java, c/c++, or shell languages",0.0,shell
123sn1i,je1g4kd,Rust does that very well.,0.2,rust
123sn1i,je1g4kd,>People seem to love rust's macro system  I don't love it.,0.5,rust
123sn1i,je1g4kd,"I love Lisp macro systems, especially the one of Common Lisp.",0.06666666666666667,lisp
123sn1i,je1g4kd,Especially the macros in Rust.,0.0,rust
123sn1i,je1g4kd,"In some cases, they are useful to create default implementations, like derive-macros in Rust.",0.3,rust
123sn1i,je1g4kd,"There are four types of callables in scopes:  - functions: no need for further explanations - inlines: basically the same as c++ templates (generics and constant expressions in one), the parameters can be types, runtime values and constant values - sugars: syntax macros on the level of symbolic expressions (tokenized hierarchic input) - spices: basically functions, which run at compile time on the partially evaluated input; There even is a memoize decorator, which makes it easy to memoize input and always generates the same result without having to recompute it, especially useful for types, else Array[int, 3] and Array[int, 3] might not be the same type, but a type, which just works in the same way.",0.09333333333333334,c++
123sn1i,je4io6k,"It might be worth to go even further, to multiple dispatch, see [https://www.youtube.com/watch?v=kc9HwsxE1OY](https://www.youtube.com/watch?v=kc9HwsxE1OY) (Interestingly, the re-use here happens in the calling code being in some sense ""re-used"", not the called code)",0.2,go
123sn1i,jdw85bn,Using macros in C do allow for a lot less code duplication but they are not typed and checked like in rust.,-0.16666666666666666,c
123sn1i,jdw85bn,Using macros in C do allow for a lot less code duplication but they are not typed and checked like in rust.,-0.16666666666666666,rust
123sn1i,jdw85bn,In rust they serve the same purpose tho i dont have much experience with them to see if there is anh limitation.,0.1,rust
123sn1i,je0jrkn,C++ concepts are amazing except for template syntax.,0.6000000000000001,c++
123sn1i,je0jrkn,"Meta Assembly Language (MASS, on Handmade Network) does concepts with full meta evaluation of functions would would be amazing for fully programmable generics.",0.47500000000000003,assembly
123sn1i,jdy3746,I would also love to see what it would look like in C (if you have the time of day),0.5,c
123sn1i,jdx178p,"True with C, not true with Rust (macros are perfectly integrated in CLion and VSCode).",0.39166666666666666,c
123sn1i,jdx178p,"True with C, not true with Rust (macros are perfectly integrated in CLion and VSCode).",0.39166666666666666,rust
123sn1i,jdwe7s9,"another issue i have with c macros is it cannot get access to values known at compile time, and multi line macros are quite janky, but other than that it *generally* kind of works.",0.2375,c
123sn1i,jdwi2p5,(Or being necessary to implement half of C++.),-0.08333333333333333,c++
123sn1i,jdwi2p5,Surely implementing half of C++ is a valid use of generics?,0.16666666666666669,c++
123sn1i,jdy3n2m,"C tries to do this, and what does it end up with?",-0.1,c
123sn1i,je0lt6m,"The same Scala code is like this C++:      int add(int x, int y) { return x + y; }     //etc...          const auto fs[] = {         [](int x) { return add(2, x); },         [](int x) { return mul(2, x); },         [](int x) { return div(x, 2); }     };     int main()     {         std::cout << map([](int(*f)(int)) { return f(5); }, fs) << std::endl;     }  Not too bad.",-0.17777777777777773,scala
123sn1i,je0lt6m,"The same Scala code is like this C++:      int add(int x, int y) { return x + y; }     //etc...          const auto fs[] = {         [](int x) { return add(2, x); },         [](int x) { return mul(2, x); },         [](int x) { return div(x, 2); }     };     int main()     {         std::cout << map([](int(*f)(int)) { return f(5); }, fs) << std::endl;     }  Not too bad.",-0.17777777777777773,c++
123sn1i,je0lt6m,"The Haskell one is trickier because in Haskell the `->` type operator is just a binary right-associative operator, meaning a function `a -> b -> c` is a recursive function `a -> (b -> c)`.",0.0,haskell
123sn1i,je0lt6m,"The Haskell one is trickier because in Haskell the `->` type operator is just a binary right-associative operator, meaning a function `a -> b -> c` is a recursive function `a -> (b -> c)`.",0.0,c
123sn1i,je0lt6m,"int(*)(int) add(int x)     {         return [x](int y) {             return x + y;         };     }     //etc...     (int(*)(int(*)(int))) applyTo(int x)     {         return [x](int(*f)(int)) {             return f(x);         };     }     (int(*)(int))(*)(int) flip((int(*)(int))(*f)(int))     {         return [f](int x) {             return [f, x](int y) {                 return f(y)(x);             };         };     }          const auto fs[] = {         add(2),         mul(2),         flip(div)(2)     };     int main()     {         std::cout << map(applyTo(5))(fs) << std::endl;     }  Now I'm using anonymous function literals and closures, which C _does not have_.",0.16666666666666666,c
123sn1i,je0lt6m,"So all this in C would require each function to have its own separate definition, with explicit stack allocations.",0.6,c
123sn1i,je0lt6m,"Though [GNU C's nested functions](https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html) can do that, but are still verbose.",0.0,c
123sn1i,je0x4fr,I was thinking of Lisp-style macros and not C. I'm not familiar with Rust's macros so I need to check them out but how does the IDE cope when you completely change the language's syntax?,-0.04375,rust
123sn1i,jdwmfmx,>Surely implementing half of C++ is a valid use of generics?,-0.16666666666666666,c++
123sn1i,je0znpu,"It's very simple actually: CLion (and VSCode as well I suppose) expand the macro in the background by compiling it, and if the compilation succeeds, the editor shows no error, even when the macro contains completely arbitrary, non Rust, code.",0.15,rust
123sn1i,jdwp6yd,"In c++, boost is widely used.",-0.1,c++
123sn1i,jdwsc2e,"As a certified bad programmer, I often need to go back and make changes to code that I have already written.",-0.3499999999999999,go
1238nxa,,"I've been looking at actor systems like Erlang and Akka because I (think I) want to make actors central to Sophie's way of interacting with the world, which opens an industrial-sized can of design-decision worms.",0.0,erlang
1238nxa,,Presumably the radio-switches atop a physical chess clock implement the mutual exclusion by means of a physical interlock to route clock pulses from a single crystal oscillator to at most one timer.,0.10714285714285715,crystal
1238nxa,,"Now, suppose actor Alice wishes to interact with Bob and Carol.",0.0,alice
1238nxa,,"Suppose further that Bob and Carol both might send Alice a message called ""Right"".",0.14285714285714285,alice
1238nxa,,Alice cannot easily receive messages from both Bob and Carol unless she can distinguish the semantics.,0.43333333333333335,alice
1238nxa,,Akka documentation suggests not to let Bob or Carol address Alice directly.,0.1,alice
1238nxa,,*  The Lisp crowd tells us that *design patterns* reflect deficient syntax.,-0.4,lisp
1238nxa,,"Here's a vague proposal to maybe solve both:  Going back to the initial Alice/Bob/Carol problem, let Alice define two separate *receptors*.",-0.16666666666666666,alice
1238nxa,,In some imagined syntax:      behavior Alice:         for BobProtocol:             on message Right:                 ... turn Alice's steering wheel ...             ... etc ...         for CarolProtocol(session_id):             on message Right:                 ... Alice feels validated ...             ... etc ...         ... etc ...                  on init:             $bob := create Bob reply_to: @here.BobProtocol;             $carol := create Carol reply_to: @here.CarolProtocol(42);  SO: What could *possibly* go wrong?,0.023809523809523798,alice
1238nxa,,In some imagined syntax:      behavior Alice:         for BobProtocol:             on message Right:                 ... turn Alice's steering wheel ...             ... etc ...         for CarolProtocol(session_id):             on message Right:                 ... Alice feels validated ...             ... etc ...         ... etc ...                  on init:             $bob := create Bob reply_to: @here.BobProtocol;             $carol := create Carol reply_to: @here.CarolProtocol(42);  SO: What could *possibly* go wrong?,0.023809523809523798,go
1238nxa,jdvgkdr,"The correct thing to do is have proper types rather than just symbols (atoms), as used by Erlang et al.",0.0,erlang
1238nxa,jdvgkdr,"enum Direction { Left, Right }     channel BobChannel     {         ...         output Direction Request;     }     agent Bob : channel BobChannel     {         Bob ()         {             ...             primary::Request <-- Direction.Right;             ...         }     }      enum Correctness { Right, Wrong }     channel CarolChannel     {         ...         output Correctness Request;     }     agent Carol : channel CarolChannel     {         Carol ()         {             ...             primary::Request <-- Correctness.Right;             ...         }     }  Axum was similar to C# and interoperable with a slightly modified subset of C# which removed `static` and replaced it with an `isolated` keyword, which ensured that multiple threads could not access some shared global state.",0.04497354497354497,c
1238nxa,jdvgkdr,> Akka documentation suggests not to let Bob or Carol address Alice directly.,0.1,alice
1238nxa,jdvgkdr,"It is not necessary, and it is very common in Erlang to pass the Pid of the sender to the recpient of any message, but there can be consequences to doing so which might not be obvious.",-0.13,erlang
1238nxa,jdvgkdr,"Suppose Alice creates actors Bob and Carol, and sends them her own Pid.",0.6,alice
1238nxa,jdvgkdr,"Now if Alice ever wishes to revoke the ability of Bob or Carol to send her messages, she must somehow revoke her own Pid (ie, destroy herself).",0.19999999999999998,alice
1238nxa,jdvil9l,"From what I understand, it sounds like you are proposing that one interface (Alice's interface) should be decomposable into constituent interfaces (the part of the interface that gets exposed to Bob, and the part of the interface that gets exposed to Carol)—is this correct?",0.0,alice
1238nxa,jdvil9l,"For instance, if you have an interface with methods `foo`, `bar`, and `baz`, you may want Alice to have access to `foo` and `bar` while Bob has access to `bar` and `baz`.",0.0,alice
1238nxa,jdvil9l,"In this case, it's trivial to just define `bar` twice, once for Alice and once for Bob, but it gets messy with more methods and more receptors—if you have n methods and m receptors, you may need to respecify O(n) methods for all m versions of the interface.",0.26666666666666666,alice
1238nxa,jdu23ax,"On the other hand, Erlang messages are basically just string-ly typed tuples with zero ceremony.",-0.125,erlang
1238nxa,jdw2i7i,"Proxy-actors allow to expose specialized/parameterized interfaces to Bob and Carol, but then a proxy cannot directly update Alice: it must send another message to Alice, which means inventing (or adopting) yet another protocol and bouncing more messages around the system.",0.3,alice
1238nxa,jdweiyg,"> Proxy-actors allow to expose specialized/parameterized interfaces to Bob and Carol, but then a proxy cannot directly update Alice: it must send another message to Alice, which means inventing (or adopting) yet another protocol and bouncing more messages around the system.",0.3,alice
1238nxa,jdweiyg,"I agree that the visibility part is very important—if Bob is only supposed to use one of Alice's methods, he shouldn't even be able to *accidentally* access the others.",0.2333333333333333,alice
1238nxa,jdweiyg,"Furthermore, even if Bob is known to use the interface correctly, he might pass Alice's interface on to Carol who incorrectly uses methods that Bob doesn't.",0.0,alice
122ng8f,,"How do JIT compiled languages compare to static ones like C++ and Rust in runtime, disk space and RAM usage?",0.5,c++
122ng8f,,"How do JIT compiled languages compare to static ones like C++ and Rust in runtime, disk space and RAM usage?",0.5,rust
122ng8f,jdr49kd,"JIT-accelerated dynamic languages like Python (via PyPy) and Lua (via LuaJIT) can give results similar to native code, when running tiny benchmarks.",0.0,python
122ng8f,jdr49kd,"JIT-accelerated dynamic languages like Python (via PyPy) and Lua (via LuaJIT) can give results similar to native code, when running tiny benchmarks.",0.0,lua
122ng8f,jdr49kd,"The other, a JPEG decoder, doesn't have a Lua version.",-0.125,lua
122ng8f,jdr49kd,"I've been meaning to create a more substantial test program (like a compiler) for years, but coding in either Python or Lua is a slog, given the lack of features I usually rely on.",0.125,python
122ng8f,jdr49kd,"I've been meaning to create a more substantial test program (like a compiler) for years, but coding in either Python or Lua is a slog, given the lack of features I usually rely on.",0.125,lua
122ng8f,jdrhrta,"Here is what you are looking for:   1: https://github.com/rochus-keller/Oberon/blob/master/testcases/Are-we-fast-yet/Are-we-fast-yet_results_linux.pdf  2: http://software.rochus-keller.ch/are-we-fast-yet_lua_results_2020-10-12.pdf  Based on the Are-we-fast-yet benchmark suite the results demonstrate that Lua 5.4.1 (interpreter) takes about 5 times as long as LuaJIT for the same benchmark (ref 2:), whereas Node.js (i.e.",0.15,lua
122ng8f,jdrhrta,"JS V8) takes about half as long as LuaJIT, and the same benchmark transpiled to C and compiled/optimized with GCC is about four times as fast as LuaJIT (ref 1:).",0.09666666666666666,c
122ng8f,jdros49,"The Dynamic nature of Lua and JavaScript make optimizations more difficult -- which is why they typically use a JIT -- although there are techniques usable in JavaScript to ""lock-in"" some types such as integers.",-0.03333333333333333,lua
122ng8f,jdros49,"The Dynamic nature of Lua and JavaScript make optimizations more difficult -- which is why they typically use a JIT -- although there are techniques usable in JavaScript to ""lock-in"" some types such as integers.",-0.03333333333333333,javascript
122ng8f,jdros49,"On the other hand, modern Browsers typically have multi-tiered evaluation strategies for JavaScript: Interpreter -> Lightweight JIT -> Heavy JIT.",-0.07291666666666666,javascript
122ng8f,jdros49,"Even the ""Heavy"" tiers for JavaScript tend to apply only a subset of the optimizations an AOT compiler such as the GCC or LLVM backends will.",-0.06666666666666667,javascript
122ng8f,jdros49,"Any task that benefits from vectorization, for example, will typically perform much better in native languages (C++ and Rust) simply because even if the compiler is not smart enough to auto-vectorize, the developer can use vector intrinsics in the code itself.",0.045238095238095244,c++
122ng8f,jdros49,"Any task that benefits from vectorization, for example, will typically perform much better in native languages (C++ and Rust) simply because even if the compiler is not smart enough to auto-vectorize, the developer can use vector intrinsics in the code itself.",0.045238095238095244,rust
122ng8f,jdros49,"Lua and Javascript typically do not offer vector intrinsics, and JITs typically do not perform auto-vectorization, so that's an entire domain of benchmarks where the difference is stark.",-0.008333333333333338,lua
122ng8f,jdros49,"Lua and Javascript typically do not offer vector intrinsics, and JITs typically do not perform auto-vectorization, so that's an entire domain of benchmarks where the difference is stark.",-0.008333333333333338,javascript
122ng8f,jdrsc5s,I’d guess you’re looking at a factor of 10 if bare metal speed is the biggest factor.,0.05,d
122ng8f,jdrsc5s,"In practice, the reason to use Javascript is to take advantage of its incredible dynamism, so you’re code will almost always spend a lot of time garbage collecting and maintaining overly convenient data structures.",0.9,javascript
122ng8f,jdrsc5s,"Still, a bare metal cpu or a Javascript engine are both computer systems, and in just about every computer system, the biggest share of time is spent in allocations or comparisons.",-0.025,javascript
122ng8f,jdrsc5s,"If you want code to be fast, allocate output arrays ahead of time and pretend you only know enough of the language to write code that looks like C, all just loops, arrays, and arithmetic.",0.06666666666666667,c
122ng8f,jdrfwi9,Lua and Jokescript are single-threaded.,0.0,lua
122ng8f,jdrfwi9,C++ and Rust are multi-threaded.,0.0,c++
122ng8f,jdrfwi9,C++ and Rust are multi-threaded.,0.0,rust
122ng8f,jdv52bo,IME Lua and JS are >5x slower than C++ and Rust but other JIT-compiled languages like those on .NET are comparable to C++ and Rust.,-0.125,lua
122ng8f,jdv52bo,IME Lua and JS are >5x slower than C++ and Rust but other JIT-compiled languages like those on .NET are comparable to C++ and Rust.,-0.125,c++
122ng8f,jdv52bo,IME Lua and JS are >5x slower than C++ and Rust but other JIT-compiled languages like those on .NET are comparable to C++ and Rust.,-0.125,rust
122ng8f,jdsyjki,source: https://old.reddit.com/r/programming/comments/6eg0x/where_are_the_fast_dynamic_languages_is_lisp_the/c03md43/  > the inner loop of mandelbrot is now identical (at the ucode IR level) to the IR generated by a C compiler.,0.0,c
122ng8f,jdsyjki,"Of course it depends on the workload, but it's not uncommon for LuaJIT to match C code when dealing with pure numerics.",-0.09285714285714287,c
122ng8f,jdsyjki,"In a larger program you'd have to write your code to avoid allocations in hot spots, which would be a major pain in the ass, but less of a pain than writing C code.",0.036458333333333336,c
122ng8f,jdsyjki,Plus typically you only have to worry about optimizing the hot spots rather than taking the productivity hit of C across your entire program.,0.020833333333333336,c
122ng8f,jdsyjki,C does very well on the former and very badly on the latter.,-0.17749999999999994,c
122ng8f,jds9aus,There's a third axis actually:  * inlined objects vs indirect objects  C tends to use inlined objects - structs are stored directly inside other structs.,-0.006249999999999999,c
122ng8f,jds9aus,"Java OTOH forces them all to be allocated separately, and this is a major cause of Java being 2x slower for all real-world programs (and also taking up 2x RAM, which is mostly separate from the latency issue proper unless cache misses are a relevant problem).",0.240625,java
122ng8f,jdtcxzu,"(Who would take a substantial C app and rewrite line by line in Lua, or vice versa?)",0.0,c
122ng8f,jdtcxzu,"(Who would take a substantial C app and rewrite line by line in Lua, or vice versa?)",0.0,lua
122ng8f,jdtcxzu,"While Lua itself has introduced an `i64` type, LuaJIT doesn't support that.",0.0,lua
122ng8f,jdtcxzu,"(I do have one reasonable sized project written in dynamic code, an assembler, that I may port to Lua and/or Python, just for the purpose of comparing throughput.",0.1,lua
122ng8f,jdtcxzu,"(I do have one reasonable sized project written in dynamic code, an assembler, that I may port to Lua and/or Python, just for the purpose of comparing throughput.",0.1,python
122ng8f,jdrbq8z,"I remember watching a long running Python batch processor ""warm up"" when run under PyPy.",0.27499999999999997,python
122ng8f,jdsazvw,"You wouldn't take a CPython program that somehow runs across 28 cores, and compare that with a C version that only uses one, and conclude that CPython outperforms C. But you want to allow such misleading results when things are the other way around.",-0.041666666666666664,c
122ng8f,jdteq9l,"> Who would take a substantial C app and rewrite line by line in Lua, or vice versa?",0.0,c
122ng8f,jdteq9l,"> Who would take a substantial C app and rewrite line by line in Lua, or vice versa?",0.0,lua
122ng8f,jdtcqzm,It is also incorrect; several JavaScript runtimes provide the means to create new threads.,0.06818181818181818,javascript
122mhjm,jdquh6j,"For example, Python's indentation, although it doesn't need much context, makes it context-sensitive.",0.2,python
122mhjm,jdquh6j,"You could take any such language (there are many - Rust, even C is context-sensitive), you could reimplement that grammar and discuss benefits and drawbacks of such an approach.",0.16666666666666666,rust
122mhjm,jdquh6j,"You could take any such language (there are many - Rust, even C is context-sensitive), you could reimplement that grammar and discuss benefits and drawbacks of such an approach.",0.16666666666666666,c
122mhjm,jdquh6j,"Now, this doesn't mean you have to create a braced Python.",-0.3125,python
122mhjm,jdquh6j,"For example, Python's context-sensitivity could be eliminate if you would allow for intermittently changing scopes, ex.",0.0,python
122mhjm,jdts7b4,"Many CS schools have an undergrad class called ""compilers"" in which you'll implement (from the ground up) either a Scheme or a thing-that-is-like-Java called decaf, or possibly you'll implement Scheme and just *call* it decaf.",0.25,scheme
122mhjm,jdsz4xl,One idea I was toying with was an MLIR frontend for array languages (APL in particular).,0.16666666666666666,apl
122mhjm,jdsz4xl,"APL is a strange old language that kind of just amuses me, but I think it'd have great benefit from tying into the lastest and greatest matrix stuff.",0.49000000000000005,apl
122mhjm,jduv08y,"For my Bachelor thesis, I have implemented a [PicoBlaze assembler and emulator in JavaScript](https://flatassembler.github.io/PicoBlaze/PicoBlaze).",0.0,javascript
122mhjm,jdr601a,How does that change to the python grammar remove context sensitivity?,0.0,python
122mhjm,jdrb3oa,The reason Python's indentation is context-sensitive is because you have to remember which indentation you're on.,0.0,python
122mhjm,jdrb3oa,"If you didn't track it, then Python grammar for lines is simply:      INDENT*...  See, no context needed, at least not for grammar.",-0.15,python
122mhjm,jdrb3oa,"Here's how an overengineered Hello World could look like then:      def hello():         print(""Hello"")      def world():         print(""World"")      hello()         print("" "")             world()  Despite resembling Python, this grammar is actually context-free.",0.0,python
122mhjm,jdrb3oa,"Furthermore, the consequence of such syntax would for      def hello():         print(""Hello"")     def world():         print(""World"")  produce code equal to Python 3's      def hello():         print(""Hello"")          def world():             print(""World"")  ---  Overall, I won't spoil the potential bachelor thesis further.",0.0,python
122mhjm,jdsflkw,"So this idea is completly useless: It barely recreates some syntax that python supports, misses the big benefit of python's syntax and leads to hard to find bugs that python is designed to avoid.",-0.18541666666666667,python
122mhjm,jdsflkw,"Only benefit is that the grammar is now context free, despite python's indentation rule easily being added to basically any sane parser implementation.",0.2777777777777778,python
122mhjm,jdsgjt0,"Given that Python has to at least once go over the code to compile it, this would be a benefit, especially for large codebases or in hot reloading scenarios.",0.04107142857142857,python
122mhjm,jdsgjt0,"Given that Python has to at least once go over the code to compile it, this would be a benefit, especially for large codebases or in hot reloading scenarios.",0.04107142857142857,go
122mhjm,jdsgjt0,"This is not about Python, this is about computing theory.",0.0,python
122mhjm,jdsgjt0,> It barely recreates some syntax that python supports  I really hope your argument is not that it's useless because I didn't fully write a BSc thesis in a Reddit comment.,-0.08333333333333333,python
122mhjm,jdsgjt0,> misses the big benefit of python's syntax  The big benefit of Python's syntax is readabaility.,0.0,python
122mhjm,jdsgjt0,"In fact, the example I provided enhances it, since now it would be possible to group related things under some indentation, something that isn't possible in Python out of the box.",0.0,python
122mhjm,jdsgjt0,> leads to hard to find bugs that python is designed to avoid.,-0.2916666666666667,python
122mhjm,jdst6gq,Fair  > The big benefit of Python's syntax is readabaility  The big benefit is that the code always behaves exactly like you would read pseduo code.,0.2375,python
122mhjm,jdsuoi8,Python has to use a specialized grammar to generate its parser.,0.0,python
122mhjm,jdsuoi8,There are plenty of differences between Python and pseudocode.,0.0,python
122mhjm,jdsuoi8,"The most obvious one is the use of `=` for equality in pseudocode, while Python uses it for assignment.",0.25,python
122mhjm,jdsuoi8,"For example, Python code does not perform as it reads because there are inherently no significant limitations on naming entities, whereas, with pseudocode, the intent and functionality has to be apparent from the name.",-0.06875,python
122mhjm,jdsuoi8,"It is fully possible to construct pseudocode where differing indentation has no meaning, and therefore the notion that Python is somehow related to pseudocode falls into water.",0.0,python
122mhjm,jdsuoi8,"In other words, let me make myself clear - while Python may be very liberally described as having a significant overlap of pseudocode, pseudocode is, of course, much greater than Python or any specific language it has similarities with, and Python is not really its subset.",0.13571428571428573,python
122mhjm,jdsuoi8,"I also hope you understand that my recommendation (in the sense of making it context-free: the exact recommendation of INDENT/DEDENT may not be) is a superset of Python, so everything you can do in Python, you can do in this hypothetical language.",0.25,python
122mhjm,jdsuoi8,This is because the context-sensitivity in Python comes from the extra constraint it puts into how indentation is used - simpy removing those constraints does not remove expression from the grammar.,0.0,python
122mhjm,jdsuoi8,"Finally, I hope you understand that that implies that any concern you might have can be resolved by limiting this new superset of Python in some way, but without making it context-sensitive.",0.06818181818181818,python
122mhjm,jdsuoi8,"In other words, let me rephrase that, there is no critique you can give on this hypothetical language that would not be a critique of Python, PEP8 or the users.",-0.125,python
122mhjm,jdt52je,"I have an implementation of a minimal extension to a lexer that allows a normal CFG grammar generator to treat python's grammar as normally CFG (in fact, LALR(1) compatible, and maybe even stronger).",0.06666666666666667,python
122mhjm,jdt52je,There are other features in python that make use of the new PEG parser that python has.,0.005681818181818177,python
122mhjm,jdt52je,There are plenty of differences between Python and pseudocode  Sure!,0.625,python
122mhjm,jdt52je,"> so everything you can do in Python, you can do in this hypothetical language  But you can do things you can't do in Python, and this is a problem.",0.0,python
122mhjm,jdt52je,I am claiming that because the specific suggestion you are making to make python a CFG doesn't work without removing the primary benefit python gains with indentation.,0.2,python
122mhjm,jduuqj2,"I have an implementation of a minimal extension to a lexer that allows a normal CFG grammar generator to treat python's grammar as normally CFG (in fact, LALR(1) compatible, and maybe even stronger).",0.06666666666666667,python
122mhjm,jduuqj2,> There are other features in python that make use of the new PEG parser that python has.,0.005681818181818177,python
122mhjm,jduuqj2,"I am talking about a language, one of which is Python, as a whole.",0.2,python
122mhjm,jduuqj2,"In terms of indentation, some pseudocode resembles Python, but not pseudocode as a concept.",0.0,python
122mhjm,jduuqj2,"That is demonstrably false, as there are braced languages, formatting standards, as well as tools like Prettify that clearly utilize indentation the same way as Python.",-0.10000000000000002,python
122mhjm,jduuqj2,It is also wrong in the sense that Python provides tools that allow you to bypass this.,-0.5,python
122mhjm,jduuqj2,"> But you can do things you can't do in Python, and this is a problem.",0.0,python
122mhjm,jduuqj2,> I am claiming that because the specific suggestion you are making to make python a CFG doesn't work without removing the primary benefit python gains with indentation.,0.2,python
122mhjm,jduuqj2,"So, because turning the grammar to a CF one creates a superset of Python, you can create the exact same language with it.",0.125,python
122mhjm,jdxhtpy,They are based on facts about the history of python.,0.0,python
122mhjm,jdxhtpy,"Not that I think you actually care about python, or facts.",0.0,python
1226y82,,"This works fine as long as I'm explicitly using an immediate constant or a symbol, but what if I want to use something bound to a variable as a value in an uninterpreted function?\ `(T = [a b c]), (T -> T)`\ In this example, even though the context makes it clear I'm using *T* in an uninterpreted function, the syntax is undecideable.",0.11666666666666668,c
1226y82,jdq4ie4,The last common option is the lisp way: `(a -> b)` is a pair only when a is an evaluated expression (e.g.,-0.09999999999999999,lisp
1226y82,jdq4ie4,"constant, function call, variable), and then you introduce a new symbol, in lisp it is `'` that *stops* evaluation, so `T=0`, `(T -> b)` is a pair, but `('T -> b)` is a function where `T` is shadowed in the context (alternatively you can make it so a variable doesn't evaluate unless it is prefixed with `'` and then swap the example.",0.06818181818181818,lisp
1226y82,jdrkpqy,"For example, in Haskell `case x of { 1 -> … }` is not the same as `let { y = 1 } in case x of { y -> … }`.",0.0,haskell
1226y82,jdp7tv2,"""**  Start implementing an explicit variable introduction, and later you may add an additional shorter version, that's how C# lambda style functions, gradually changed syntax thru time and different versions.",0.0,c
1226y82,jdp7tv2,"is not C, but here are more practical examples, about using a lambda syntax style functions.",0.5,c
1226y82,jdp7tv2,"C style suggestion:      int mult (int a, b) -> { return a * b; }          void incptr (int p&) -> { p++; }          ...     int b = 7;     int x = mult(3, b);     int q = &b;     incptr(q);     ...     int a[5];     int b[5];     int c[5];          for (int i=0; i < 5; i++)     {        a[i] = i; b[i] = (10 - I); c[i] = 0;     }          void Map(int (*func) (int a, b))     for (int j=0; j < 5; j++)     {        c[i] = func(a, b);     }          ...     Map( &mult );     ...",-0.75,c
1226y82,jdp7tv2,"Version 2:      int mult (int a, b) -> ( a * b )          void incptr (int p&) -> ( p++ )          ...     int b = 7;     int x = mult(3, b);     int q = &b;     incptr(q);     ...         for (int i=0; i < 5; i++)     {        a[i] = i; b[i] = (10 - I); c[i] = 0;     }          void Map(int (*func) (int a, b))     for (int j=0; j < 5; j++)     {        c[i] = func(a, b);     }          ...     Map( &mult );     ...",-0.75,c
1226y82,jdp7tv2,"Version 3:      int mult (a, b) -> ( a * b )          ...     int b = 7;     int x = mult(3, b);     int q = &b;     incptr(q);     ...         for (int i=0; i < 5; i++)     {        a[i] = i; b[i] = (10 - I); c[i] = 0;     }          void Map(int (*func) (int a, b))     for (int j=0; j < 5; j++)     {        c[i] = func(a, b);     }          ...     Map( int (int a, b) -> ( return a * b ) );     ...",-0.75,c
1220v2y,,"The examples are here:  [https://github.com/Kotyesz/Kotyos-lang](https://github.com/Kotyesz/Kotyos-lang)  Also help me find a name, I mean KSL sound cool and all, but if I don't do anything more than these examples I don't think it would fit to contain me.",0.09791666666666667,cool
1220v2y,,"Also if you take influence or make this one a reality please don't do drastic changes for each version, I don't want it to be like rust.",0.0,rust
1220v2y,jdxve47,"When a function is fully declared in C, the compiler is creating a symbol and compiling its body.",0.0,c
1220v2y,jdxve47,"One-pass compilers aren't as relevant nowadays because we have lots of memory, but especially for low-level programming (such as in C) a one-pass compiler is often preferred as it can get similar effects with *much* less memory usage.",0.046666666666666676,c
1220v2y,jdzs80l,"Of course, I have no idea if this would work in practice but enforcing a single return statement like this would be cool.",0.1392857142857143,cool
1220v2y,jdzsomt,"Some languages (Python, Rust) decided to not include the operator at all.",0.0,python
1220v2y,jdzsomt,"Some languages (Python, Rust) decided to not include the operator at all.",0.0,rust
1220v2y,jdrw6e1,Though I might go back soon due to current events.,-0.041666666666666664,go
1220v2y,jdz7yy0,"The idea that you can't redefine things didn't come with C.  The compiler C was designed on was just a naive transformer to assembly, and the assembler was just a naive transformer to a simple object file which the linker patched up.",-0.19999999999999998,c
1220v2y,jdz7yy0,"The idea that you can't redefine things didn't come with C.  The compiler C was designed on was just a naive transformer to assembly, and the assembler was just a naive transformer to a simple object file which the linker patched up.",-0.19999999999999998,assembly
1220v2y,jdz7yy0,Why bother keeping track of extra information your language (original C) doesn't need?,0.1875,c
121xhmg,,"A transpiler is a compiler that translates languages within the same level abstractions, like JavaScript and Python.",0.0,javascript
121xhmg,,"A transpiler is a compiler that translates languages within the same level abstractions, like JavaScript and Python.",0.0,python
121xhmg,,"So, here is a list of all available transpilers:  * `C` **->** `Rust` **=** c2rust **OR** crust * `C++` **->** `Rust` **=** crust  Please help me with filling the list by telling me all of the available transpilers, so I can add it in the list.",0.4,c
121xhmg,,"So, here is a list of all available transpilers:  * `C` **->** `Rust` **=** c2rust **OR** crust * `C++` **->** `Rust` **=** crust  Please help me with filling the list by telling me all of the available transpilers, so I can add it in the list.",0.4,rust
121xhmg,,"So, here is a list of all available transpilers:  * `C` **->** `Rust` **=** c2rust **OR** crust * `C++` **->** `Rust` **=** crust  Please help me with filling the list by telling me all of the available transpilers, so I can add it in the list.",0.4,c++
121xhmg,jdo1hrl,"Well, all of nims backends are transpilers to C, C++, C# and JS.",0.0,c
121xhmg,jdo1hrl,"Well, all of nims backends are transpilers to C, C++, C# and JS.",0.0,c++
121xhmg,jdo1hrl,"Is llvm really that much lower level than C, i.e.",0.2,c
121xhmg,jdo1hrl,What about BF->C?,0.0,c
121xhmg,jdoopya,"There's a ton of languages that compile to JS - OCaml, TypeScript, Flow, ReScript, ReasonML, CoffeeScript, [and like a hundred more in this incomplete list](https://gist.github.com/matthiasak/c3c9c40d0f98ca91def1).",0.5,typescript
121xhmg,jdo5taq,"[https://github.com/cmspeedrunner/Pyf](https://github.com/cmspeedrunner/Pyf)   Python to brainfuck, pyfuck",0.0,python
121xhmg,jdo3rsw,"All your examples count as transpilers IMO, except for C to LLVM.",0.0,c
121xhmg,jdo3rsw,"There are some grey areas: for example I used to routinely write programs in assembly, but I consider that mostly a compiler target now.",0.225,assembly
121xhmg,jdorzer,remember when ES6 was routinely transpiled to JavaScript?,0.0,javascript
121obyd,jdmx0px,"writing on in python myself for the first time, what has been your experience building the ast?",0.25,python
121obyd,jdn8u90,"Nice work but u can think about doing Zang self hosted, so u can replace python.",0.6,python
121obyd,jdrynbo,It looks like a typical Algol derivative.,-0.16666666666666666,algol
121obyd,jdmxwe2,"i built this from scratch without using libraries but i would deffo read up on things like PLY and ANTLR for python, use some external libraries because that will cut the code down alot, for this project i followed some documentation, here are some good links:   https://www.dabeaz.com/ply/ply.html   https://tomassetti.me/antlr-mega-tutorial/   https://ruslanspivak.com/lsbasi-part1/",0.18148148148148147,python
121obyd,jdndnoy,">Nice work but u can think about doing Zang self hosted, so u can replace python.",0.0,python
121obyd,jds0hkl,"The structure may be similar to algol but I have changed quite a lot and I don't agree that it is a ""typical algol derivitive"" when it has extensive inbuilt interoperable based libraries with things like cmd, webbrowser and sys.",-0.05555555555555555,algol
121obyd,jds0hkl,The string library is not found in algol aswell.,0.0,algol
121obyd,jds0hkl,I think its unfair to dismiss it as an algol derivative when it has so much more to offer,0.0,algol
121obyd,jdra52w,"But I’d be happy to do it for you, if need be—do but give me a ssh logon and `sudo` and I’ll have you fapping shamefully in a trice.",0.8,d
121obyd,jggou99,Isn't this from YouTube tutorial that builds an interpreter in python too?,0.0,python
121obyd,jdngzht,"They mean rewriting the whole repo in Zang itself, so you can ""ditch"" python, and start dogfooding.",-0.056249999999999994,python
121obyd,jdnha3u,Look out at porth or other languages like rust they are self hosted.,-0.125,rust
121obyd,jds556h,"Your opinions I actually took, and no I don't just want compliments, but I have the right to offer a rebuttal to your comment saying its just another algol derivative.",0.14285714285714285,algol
121c09t,jdy6nzr,This should go immediately after the definition of `Expr`.,0.0,go
121c09t,je49r3a,data Var : List k -> k -> Type where       Z : Var (x :: xs) x       S : Var xs x -> Var (y :: xs) x      data Tpe : Type where       Base : Tpe       Func : Tpe -> Tpe -> Tpe      data Exp : List Tpe -> Tpe -> Type where       Def : Exp (a :: xs) b -> Exp (Func a b :: xs) r -> Exp xs r       App : Var xs (Func a b) -> Var xs a -> Exp xs b       Let : Exp xs a -> Exp (a :: xs) r -> Exp xs r       Ret : Var xs a -> Exp xs a       mutual       data Val : Tpe -> Type where         Uni : Val Base         Clo :  Exp (a :: xs) b -> Env xs -> Val (Func a b)        data Env : List Tpe -> Type where         Nil : Env []         (::) : Val x -> Env xs -> Env (x :: xs)      data Stk : Tpe -> Type where       End : Stk a       Frm : Exp (a :: xs) b -> Env xs -> Stk b -> Stk a      data Mch : Type where       Run : Exp xs a -> Env xs -> Stk a -> Mch       lookup : Var xs a -> Env xs -> Val a     lookup Z (v :: _) = v     lookup (S x) (v :: vs) = lookup x vs      step : Mch -> Mch     step (Run (Def b e) vs k) = Run e (Clo b vs :: vs) k     step (Run (App f x) vs k) = case lookup f vs of       Clo e ws => Run e (lookup x vs :: ws) k     step (Run (Let e1 e2) vs k) = Run e1 vs (Frm e2 vs k)     step (Run (Ret x) vs End) = Run (Ret x) vs End     step (Run (Ret x) vs (Frm e ws k)) = Run e (lookup x vs :: ws) k       data Steps : Mch -> Type where       Done : Steps (Run (Ret x) vs End)       More : Steps (step e) -> Steps e      total     terminates : (m : Mch) -> Steps m     terminates (Run (Def b e) vs k) = More (terminates (Run e (Clo b vs :: vs) k))     terminates (Run (App f x) vs k) = ?ohoh     terminates (Run (Let e1 e2) vs k) = More (terminates (Run e1 vs (Frm e2 vs k)))     terminates (Run (Ret x) vs End) = Done     terminates (Run (Ret x) vs (Frm e ws k)) = More (terminates (Run e (lookup x vs :: ws) k)),0.016666666666666656,r
120ybk7,jdp0vc1,"TBF, this is a simpler optimisation than the C example, where the compiler has to determine unequivocally that a variable set to `FLAG` was never used.",0.0,c
120c0ss,,"Context: I want to create a web-based C interpreter as a personal project (which can do visualization of memory as a teaching aid) and I was thinking that an explicit control evaluator would be appropriate for gotos (continue, break, return, etc) as those seem to be harder to implement in a tree-walk interpreter, and I don't really wish to create a whole bytecode for a bytecode interpreter.",0.16,c
120c0ss,jdh0g51,"**  I haven't worked with an Explicit Control Evaluator, but I do have worked with Interpreters, and other related tools, and with some C like compilers.",-0.0625,c
120c0ss,jdh0g51,"The other choice would be a CGI compiled tool integrated into a web server, like PHP, Java or Server side JS does.",-0.125,php
120c0ss,jdh0g51,"The other choice would be a CGI compiled tool integrated into a web server, like PHP, Java or Server side JS does.",-0.125,java
120c0ss,jdh0g51,"**There's also the C macro issue, that makes both a compiler and interpreter, or any tool like the Explicit Control Evaluator, difficult to implement, compared to a P.L.",-0.5,c
120c0ss,jdh0g51,"**  And, I do have worked with a C alike macroprocessor, and detecting which location in source code is interpreted, is complex.",-0.3,c
120c0ss,jdh0g51,"Bytecode were called Intermediate Code Representation code in compilers, and aren't always ""byte"" sized, but sometimes ""words"" (2 bytes) or more bytes, but the original Java team wanted to keep it as ""byte"" sized instruction, when most compilers / interpreters were already 2 or 4 based.",0.4583333333333333,java
120c0ss,jdkgubd,"PHP, Ruby and Perl main implementations were tree-walking interpreters for a long time.",0.05833333333333333,php
120c0ss,jdkgubd,"PHP, Ruby and Perl main implementations were tree-walking interpreters for a long time.",0.05833333333333333,ruby
120c0ss,jdkgubd,"PHP, Ruby and Perl main implementations were tree-walking interpreters for a long time.",0.05833333333333333,perl
120c0ss,jdh11q8,"Since it'll be Web based, it'll be done in typescript.",0.0,typescript
120c0ss,jdh11q8,"The interpreter doesn't have to be fast, nor encompass the entire C standard, but most features should be there (eg pointers, memory allocation).",0.175,c
120c0ss,jdhrmlt,"`progn` in Common Lisp, `begin` in Scheme, `$sequence` in Kernel).",-0.3,lisp
120c0ss,jdhrmlt,"`progn` in Common Lisp, `begin` in Scheme, `$sequence` in Kernel).",-0.3,scheme
120c0ss,jdh3gar,Typescript ?,0.0,typescript
120c0ss,jdh3gar,"Don't get surprised if some people try to discourage you, for not using C or C++.",0.1,c
120c0ss,jdh3gar,"Don't get surprised if some people try to discourage you, for not using C or C++.",0.1,c++
120c0ss,jdh3gar,**It can be done in Typescript.,0.0,typescript
120c0ss,jdh3gar,**  I had a similar issue because I did an interpreter related project in procedural / modular Pascal.,0.0,pascal
120c0ss,jdh3gar,"Note: I also wanted to make a PHP extension that included types, before they were added.",0.0,php
120c0ss,jdh3gar,"My interpreter related graduated project took 6 months, and other similar projects that are done in free time have been going on by years, including a C macroprocessor.",0.06875,c
120c0ss,jdh3gar,"Seems you only want to use the simple ""#include"" feature of the C macroprocessor without the ""#define x(...) ..."" feature, which would be a difficult issue,  for your project.",-0.16666666666666666,c
120c0ss,jdh3gar,**Have you already implemented a short version of the C lexer and parser in Typescript?,0.0,c
120c0ss,jdh3gar,**Have you already implemented a short version of the C lexer and parser in Typescript?,0.0,typescript
120c0ss,jdh3gar,"**  You could start with that, recognize a valid set of C files, detecting  valid text tokens, confirm that those C tokens match a valid C syntax, and leave the rest for later.",0.0,c
120c0ss,jdh3gar,"**You will actually need a typescript library set / framework of your own, for the whole project.",0.26666666666666666,typescript
120c0ss,jdjzpn2,"(define f ()         (print ""one"")         (print ""two"")         (print ""three""))  Because Lisp has syntax sugar for defining lambdas and multi-expression lambdas.",0.0,lisp
120c0ss,jdjjkvg,`goto` isn't at all hard to emulate; the problem with it is how it interacts with other features and control flow (the simplest example being C variable declarations).,-0.20833333333333334,c
120c0ss,jdjjkvg,"Unlike `goto`, delimited continuations can only go back to where they have been and are guaranteed to keep the same values they had there.",0.0,go
120c0ss,jdjjkvg,"And they're not very fast, though better than non-delimited continuations (Scheme's `call/cc`).",0.21153846153846154,scheme
120c0ss,jdk4u1z,"> Unlike goto, delimited continuations can only go back to where they have been and are guaranteed to keep the same values they had there.",0.0,go
120c0ss,jdk4u1z,"If you are interpreting C rather than compiling it, you can also only go back to a label which the interpreter has seen (you can't jump forward), unless you pre-evaluate all of the labels of a given scope before evaluating the code under the labels.",0.0,c
120c0ss,jdk4u1z,"If you are interpreting C rather than compiling it, you can also only go back to a label which the interpreter has seen (you can't jump forward), unless you pre-evaluate all of the labels of a given scope before evaluating the code under the labels.",0.0,go
120c0ss,jdk4u1z,"`goto` is simple in ISO C, but in GNU C, you also have computed gotos/[first-class labels](https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html#Labels-as-Values), among other extensions which make it a more complex feature.",0.018750000000000003,c
120c0ss,jdk4u1z,"Also, don't forget that setjmp/longjmp is part of ISO C, and scoped goto is insufficient for providing it.",0.0,c
120721q,,Would it be pretty important to start with a clean slate vanilla typescript project from the get-go?,0.33888888888888885,typescript
11zo078,jdekece,"the people actively cramming new stuff into Python today have probably been intertwined with the language for like 15 years and it's impossible for them to be able to think like someone who's confronted with the whole thing as it currently stands, for the first time.",0.040909090909090916,python
11zo078,jdf5u5x,"I think it's also worth mentioning the ""Curse of Lisp"".",0.3,lisp
11zo078,jddmmpj,Among the many things I like about Erlang is that the language is quite small.,0.125,erlang
11zo078,jddmmpj,"We had a weeklong Erlang class one time, and covered the full language in the first two days.",0.3,erlang
11zo078,jddtasl,"Rather, follow a few rules:  * never rely on a language solution if a library solution would be better * never rely on a library solution if a language solution would be better * have a good story for generated code  C++, for example, is an example that makes the language more complex in order to support library solutions for things that would be much simpler if they were implemented in the language in the first place.",0.26875,c++
11zo078,jddh9hb,"Also relevant, especially as it relates to his mention of patterns/abstractions and Lisp, is Peter Norvig's [critique of GoF patterns](http://www.norvig.com/design-patterns/design-patterns.pdf) in dynamic langauges like Lisp, Smalltalk, and Dylan.",0.13333333333333333,lisp
11zo078,jddh9hb,"GoF is focused on C++ issues stemming from its half-assed object-orientation, such as lack of first-class classes and functions.",0.0,c++
11zo078,jdlnln6,"> Lua was, and is, a small language — and, probably not coincidentally, so is its implementation.",-0.25,lua
11zo078,jdlnln6,"The [Lua repo](https://github.com/lua/lua) is 33,742 lines of code.",0.0,lua
11zo078,jdlql82,"For example, recently I've discovered a nasty bug in Kotlin (incorrect values of constants).",-0.5,kotlin
11zo078,jdlql82,And it's no coincidence that Kotlin's maintained by a small team in a company whose main business is IDEs.,-0.04166666666666667,kotlin
11zo078,jdlql82,"Java, on the other hand, while being ostensibly a worse language, is maintained by a huge company for which it it one of the main cash cows, and huge and expert teams are allocated to it.",0.08833333333333335,java
11zo078,jdlql82,"And lo and behold, I've never ever encountered a bug in Java.",0.0,java
11zo078,jderxxg,I think python's growth isn't very problematic because it's very opt in.,0.2,python
11zo078,jderxxg,"Sure, understanding the entirety of python 3 will be hard, but you don't need to understand e.g.",0.10416666666666666,python
11zo078,jderxxg,"list comprehensions to write python, or even to use any library for it.",0.0,python
11zo078,jdg7jx5,"Taking the rust example you linked, it was talking about the function coloring problem and keywords like await or const that could be added to functions.",0.0,rust
11zo078,jddcasf,"**  C and C++ have the ""fame"" of avoiding and keeping all new keywords as less as possible, even already useful new keywords took a long time to be approved.",0.05934343434343434,c
11zo078,jddcasf,"**  C and C++ have the ""fame"" of avoiding and keeping all new keywords as less as possible, even already useful new keywords took a long time to be approved.",0.05934343434343434,c++
11zo078,jdjm7yr,What meta-languages do I know of in Common Lisp?,-0.3,lisp
11zo078,jdjm7yr,"There's Coalton, which adds a type system on to Common Lisp.",-0.3,lisp
11zo078,jdjm7yr,"There's an implementation of APL, several of minikanren, and some shell syntaxes (hybrids of unix shell and CL itself).",0.0,apl
11zo078,jdjm7yr,"There's an implementation of APL, several of minikanren, and some shell syntaxes (hybrids of unix shell and CL itself).",0.0,shell
11zo078,jdlmehg,Forth is another example.,0.0,forth
11zo078,jdea2rq,That's the problem with Erlang though.,0.0,erlang
11zo078,jde806q,"> GoF is focused on C++ issues stemming from its half-assed object-orientation, such as lack of first-class classes and functions.",0.0,c++
11zo078,jdeml29,"I've been using JavaScript as my primary language at work for about a dozen years now, and ES6 is *vastly* more pleasant to use than earlier versions.",0.4083333333333333,javascript
11zo078,jdeumtz,"You'd have both `for` and `fcollect`, not to mention the rest of the stuff you can do with iterators, if you converted to them instead; Rust and Python both do this and the ergonomics of it are fine.",0.4166666666666667,rust
11zo078,jdeumtz,"You'd have both `for` and `fcollect`, not to mention the rest of the stuff you can do with iterators, if you converted to them instead; Rust and Python both do this and the ergonomics of it are fine.",0.4166666666666667,python
11zo078,jdm0fhw,"I don't know a huge amount about lisps, but you see this to a certain extent at the moment with Rust, where async programming is split into different ecosystems that struggle to interoperate, because they rely on different underlying runtimes that cannot be exchanged.",0.15357142857142858,rust
11zo078,jflsvll,"1000 lisp programmers isn't many , compared to the big boys.",0.25,lisp
11zo078,jdgpdv4,"No, the problem with Erlang is that it doesn't have a static type system.",0.5,erlang
11zo078,jddrn3l,"Yes, programmers are afraid of anything that doesn't look like C.",-0.6,c
11zo078,jdese6h,"Well, if you're using TypeScript that is.",0.0,typescript
11zo078,jdeu1ao,"They're certainly not the most popular - that title goes to JS and Python, largely because of their platforms (browsers, scientific computing engines).",0.30178571428571427,python
11zo078,jdeu1ao,"Probably ease of use for those experienced in them - I definitely prefer typed languages outside my shell, though the convenience there cannot be understated.",0.26666666666666666,shell
11zo078,jdf5avh,Given Python regularly sits at the top of the TIOBE index (swaps positions with C occasionally) that's a pretty strange conclusion.,0.13999999999999999,python
11zo078,jdf5avh,Given Python regularly sits at the top of the TIOBE index (swaps positions with C occasionally) that's a pretty strange conclusion.,0.13999999999999999,c
11zo078,jdewy8n,Rust and Python do this just fine because they have their own runtime; Fennel does not have a runtime.,0.5083333333333333,rust
11zo078,jdewy8n,Rust and Python do this just fine because they have their own runtime; Fennel does not have a runtime.,0.5083333333333333,python
11zo078,jdewy8n,It is strictly a compiler and cannot add any new features that don't already exist in the targeted runtime (the Lua VM) unless they can be implemented purely at compile time.,0.17532467532467533,lua
11zo078,jde3k97,"Plenty of scheme fans would and do, though I believe that a language that defines itself firmly within the lisp family makes implicit promises about elegance and paradigmatic limitations which favor remaining wieldy.",-0.2,scheme
11zo078,jde3k97,"Plenty of scheme fans would and do, though I believe that a language that defines itself firmly within the lisp family makes implicit promises about elegance and paradigmatic limitations which favor remaining wieldy.",-0.2,lisp
11zo078,jdllf24,"Here the difference is in limitations: if we look at a C function invocation ""foo(x)"", we know from the limitations of C functions that x will not be modified, nor will in fact any of the local variables unless the address of those have escaped.",0.0,c
11zo078,jdllf24,In C we do have the possibility that this changes globals.,0.0,c
11zo078,jdllf24,"For C++ - which I consider a worse language from the readability point of view, we can no longer say that x will not be modified (due to implicit ref), we cannot even know that ""foo"" is a function!",-0.278125,c++
11zo078,jdllf24,"This allows C++ to express more syntax-like extensions, but at the cost of local comprehension, and consequently readability.",0.25,c++
11zo078,jdllf24,And the extensions that the talk argues for goes beyond what C++ offers.,0.1,c++
11zo078,jdppi46,"The problem is that almost all (barring ones using reader macros and such) wind up looking exactly like normal Lisp code, and so people sometimes have a tough time discerning them as separate languages, but they definitely are mini-languages of their own.",0.10185185185185186,lisp
11zo078,jdoanhp,When was the last time you read C code with an `unless` macro?,0.0,c
11zo078,jdoanhp,And C _is_ a language that is heavily reliant on macros due to a lack of genericity.,-0.1625,c
11zo078,jdoanhp,"(Because, as it turns out, nobody wants to type out a full C routine signature for every type or syscall under the sun).",0.275,c
11zo078,jdjwj7m,"I have to admit that it was a long time ago since I used Erlang, but I don’t remember that I missed static type checking.",0.225,erlang
11zo078,jdgqx5l,"I don't wish to claim that dynamic languages don't have their place, but I'm a big fan of static typing myself, and when I was dabbling with Erlang, it certainly was annoying as hell having to deal with the dynamic type system.",-0.01428571428571429,erlang
11zo078,jdf6oj4,"Back when the Matasano challenges were a thing, I worked through them in Erlang.",0.0,erlang
11zo078,jdf6oj4,"Erlang by itself does have some neat features, but they're just neat.",0.0,erlang
11zo078,jdeboll,"The whole selling point of Erlang is its concurrency story, and while the core language provides the primitives for it, it's practically impossible to create usable concurrency without the OTP.",-0.2333333333333333,erlang
11zo078,jddw0jm,And C++.,0.0,c++
11zo078,jdfcmys,"Js rules the web space because it was chosen as a browser language and python sees broad general purpose use but is only a category leader in the data space, and even that's just to be a wrapper around C",0.037500000000000006,python
11zo078,jdfcmys,"Js rules the web space because it was chosen as a browser language and python sees broad general purpose use but is only a category leader in the data space, and even that's just to be a wrapper around C",0.037500000000000006,c
11zo078,jdh85l4,"They're certainly not the most popular - that title goes to JS and Python, largely because of their platforms (browsers, scientific computing engines).",0.30178571428571427,python
11zo078,jdh85l4,"Yes, in terms of absolute numbers, sure JS and Python though they are not nearly the same as they used to be.",0.16249999999999998,python
11zo078,jdh85l4,"Python had type annotations galore, and there's clamour (and inevitably fierce debates) about adding actual static typing to the language, which is rather silly in my opinion.",0.0,python
11zo078,jdh85l4,"This is more symptomatic of Python being used across domains where it doesn't really fit, and even there, as /u/Jmc_da_boss mentioned, quite a lot of Python's usage comes from being a script to drive the native (C, mostly) libraries in scientific computing, NLP, ML et al.",0.4666666666666666,python
11zo078,jdh85l4,"This is more symptomatic of Python being used across domains where it doesn't really fit, and even there, as /u/Jmc_da_boss mentioned, quite a lot of Python's usage comes from being a script to drive the native (C, mostly) libraries in scientific computing, NLP, ML et al.",0.4666666666666666,c
11zo078,jdh85l4,">  > Probably ease of use for those experienced in them - I definitely prefer typed languages outside my shell, though the convenience there cannot be understated.",0.26666666666666666,shell
11zo078,jdh85l4,"I am a big fan of dynamic languages (Common Lisp being my favourite), but only as prototyping tools, for scripting support, or for small-to-medium projects.",-0.075,lisp
11zo078,jdh85l4,A year of Clojure + Ruby on a growing project was a nightmarish experience for me.,0.0,clojure
11zo078,jdh85l4,A year of Clojure + Ruby on a growing project was a nightmarish experience for me.,0.0,ruby
11zo078,jdh85l4,"Okay, I am exaggerating a bit, but there's a very big reason why TypeScript has become so popular on the frontend - JS developers can actually focus on the code instead of being bogged down with banal type errors.",0.06349206349206352,typescript
11zo078,jdg3bor,"C#, java, c++and typescript  are a used years they aren't the 1 but they are the most part of the top 10 , and most developer work in some of this langues",0.5,c
11zo078,jdg3bor,"C#, java, c++and typescript  are a used years they aren't the 1 but they are the most part of the top 10 , and most developer work in some of this langues",0.5,java
11zo078,jdg3bor,"C#, java, c++and typescript  are a used years they aren't the 1 but they are the most part of the top 10 , and most developer work in some of this langues",0.5,typescript
11zo078,jdms8ov,"I don't think he ever touched upon the actual mode of implementation, or which layer each feature must go into, quite possibly deliberately so.",0.0,go
11zo078,jdms8ov,"A case in point would be the new streams+lambda feature set in modern Java which feels like a language within a language, and therefore violates those espoused principles.",0.16818181818181818,java
11zo078,jdrf2hq,"As I see it, if I have a complex piece of code, its logic has to go *somewhere*.",-0.3,go
11zo078,jdrf2hq,"Either it has to go in the language implementation itself, in a syntactic extension in userspace, or at the site of each use.",0.0,go
11zo078,jdprrwg,Practically every large Lisp project does that.,0.21428571428571427,lisp
11zo078,jdprrwg,"Also, for the record, C macros are nothing like Lisp macros.",0.0,c
11zo078,jdprrwg,"Also, for the record, C macros are nothing like Lisp macros.",0.0,lisp
11zo078,jdprrwg,Lisp macros operate on the AST unlike C macros which are basically text substitution.,0.0,lisp
11zo078,jdprrwg,Lisp macros operate on the AST unlike C macros which are basically text substitution.,0.0,c
11zo078,jddyd1q,"Erlang certainly has it's own noisy bits, but overall is minimal and elegant.",0.24285714285714288,erlang
11zo078,jdgi1y9,"I know it hasn't taken off quite as much in Python yet, but most big projects that I've seen (both open and closed source) use Typescript rather than Javascript directly.",0.11666666666666665,python
11zo078,jdgi1y9,"I know it hasn't taken off quite as much in Python yet, but most big projects that I've seen (both open and closed source) use Typescript rather than Javascript directly.",0.11666666666666665,typescript
11zo078,jdgi1y9,"I know it hasn't taken off quite as much in Python yet, but most big projects that I've seen (both open and closed source) use Typescript rather than Javascript directly.",0.11666666666666665,javascript
11zo078,jdh6ylk,"It entails practically all aspects of software development using Erlang - concurrency, error recovery, state management, event management et al.",0.0,erlang
11zo078,jdh6ylk,"If you really believe that the primitives in Erlang proper are enough to build industrial applications, try building a gen_server yourself and see how that fares in the **real** world.",0.1,erlang
11zo078,jdghtkj,"Using the primitives that Erlang provides, and not using the OTP, you'd basically have to reinvent the OTP to have any modicum of actual real-world concurrency support.",0.0,erlang
11zo078,jdghtkj,Your whole initial comment was about how simple Erlang was.,0.06666666666666667,erlang
11zo078,jdghtkj,Or that Haskell 98 is simple when it's practically useless.,-0.25,haskell
11zo078,jddz4v9,"Erlang's syntax isn't pretty, but the semantics are!",0.3125,erlang
11zo078,jddz4v9,"I've wondered why there isn't a ""CoffeeScript"" for Erlang.",0.0,erlang
11zo078,jddz4v9,"Yes, there's Elixir, but I'm thinking of pure Erlang just with cleaner syntax.",0.21428571428571427,elixir
11zo078,jddz4v9,"Yes, there's Elixir, but I'm thinking of pure Erlang just with cleaner syntax.",0.21428571428571427,erlang
11zo078,jdh791i,"Even the Python community, reading their forums, want more and more static typing support (even though current Python already has, albeit unenforced, type annotations that at least provide warnings).",0.24,python
11zo078,jdpp1be,"The second goes into some details about his plans for Java itself (most of which didn't go through) and he mentions about Generics, Operator Overloading (possibly constrained), and Value Objects.",0.16666666666666666,java
11zo078,jdpp1be,"The second goes into some details about his plans for Java itself (most of which didn't go through) and he mentions about Generics, Operator Overloading (possibly constrained), and Value Objects.",0.16666666666666666,go
11zo078,jdpp1be,"Unfortunately, only the first one landed in Java and that too in a semi-broken way.",0.125,java
11zo078,jdh014h,Is a statically type language for the BEAM that compiles to Erlang and JS.,0.0,erlang
11zo078,jdm25po,"Type annotations in Python do not produce any warnings, and probably never will (that would be far too costly at runtime for an already relatively slow language).",-0.10000000000000002,python
11zo078,jdm25po,"You may be thinking of PHP, which I believe does use type annotations at runtime for both warnings and errors (although I've not followed that for a long time).",-0.05,php
11zo078,jdm25po,"In Python, static typing is generally provided through external linting tools like Mypy and Pyright.",0.18333333333333335,python
11zo078,jdkz6yq,"Based on my own experiences learning Erlang and working with it (admittedly a long time ago, but I doubt the core language has changed that much), I find it hard to believe that there are such massive applications out there not using the OTP at all (the initial version at least, as you claim).",0.019791666666666666,erlang
11zfe98,,So `'A'` in Rust corresponds to `$A` in Hlang.,0.0,rust
11zfe98,jdcs1s5,"The ultimate “no reserved keywords” language is Tcl:      proc if {tst then _else elsethen} {         set res [uplevel ""expr $tst""]         switch -exact $res {             1 {uplevel $then}             0 {uplevel $elsethen}         }     }      set x 8      if {$x > 7} {         puts ""Yes""     } else {         puts ""No""     }  Above, I hackily overwrite the built in `if` and Tcl doesn’t care because it’s just treated like any other function.",0.03125,tcl
11zfe98,jdcr4jk,"**  I learned LISP with almost no keywords, it was very difficult to understand.",-0.65,lisp
11zfe98,jdkwpwk,Fixed form Fortran has no keywords.,0.1,fortran
11zfe98,jdci3w7,"However, like in Rust, the unary `=` works on the top-most context other than the global context, where it's not allowed and raises a syntax error.",-0.0625,rust
11zfe98,jdci3w7,It's like Elixir or Go in this regard.,0.0,elixir
11zfe98,jdci3w7,It's like Elixir or Go in this regard.,0.0,go
11zfe98,jdevtpr,Lisp's not hard to understand because of a lack of keywords; it uses largely the same ones as other languages.,0.058779761904761904,lisp
11zfe98,jdevtpr,"You could make a Lisp with those forms defined; it might be less visually appealing than one that provides special parsing rules to them, but it shouldn't be harder to understand, because it says the same things.",0.1180952380952381,lisp
11zfe98,jdn0sba,I’d forgotten about Kernel.,0.0,d
11zfe98,jdn0sba,"I’ve got a half-written lisp which is based around having explicit environments, so you can either start from an empty one or inherit from another, without overwriting anything as far as code using the progenitor environment is concerned.",0.0,lisp
11zfe98,jdgzp5b,Avoiding inventing an entirely separate and parallel mechanism for managing language feature versions like epochs in rust.,0.0,rust
11zfe98,jdgzp5b,Java designers exploring adding keywords with dashes after discovering this is backwards compatible with existing lexer behavior to reject these)  And lots of languages struggle with evolving new features when they interact with unfortunate existing design choices that they're stuck with.,-0.18181818181818182,java
11zfe98,jdgzp5b,Versioning keywords can go some way to alleviating this.,0.0,go
11yz68i,,My current starting point is Rust.,0.0,rust
11yz68i,,Or whose patterns design is better or different than that of Rust (even if only on specific points).,0.125,rust
11yz68i,jdb0xtx,"When talking about pattern matching, I can't not mention Prolog, Erlang and Elixir.",0.0,prolog
11yz68i,jdb0xtx,"When talking about pattern matching, I can't not mention Prolog, Erlang and Elixir.",0.0,erlang
11yz68i,jdb0xtx,"When talking about pattern matching, I can't not mention Prolog, Erlang and Elixir.",0.0,elixir
11yz68i,jdajjyt,"Scala's pattern matching allows programmers to write their own patterns, which is pretty neat.",0.425,scala
11yz68i,jdajjyt,"C#'s pattern matching also works in any boolean expression and can declare new variables inside of that expression, which is weird and a little janky but really helpful when writing C# code.",-0.08778409090909091,c
11yz68i,jdaphp4,Check out Haskell’s or standard ml’s pattern matching capabilities.,0.0,haskell
11yz68i,jdaphp4,Racket is a descendant of lisp which makes its pattern matching unusual.,0.2,lisp
11yz68i,jdaphp4,It’s pattern matching is built with a macro which is something unique in lisp languages.,0.375,lisp
11yz68i,jdbjca8,Have a look at Haskell's [pattern synonyms extension](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pattern_synonyms.html),0.0,haskell
11yz68i,jdbtl23,I always liked how Kotlin's smart casts and Typescript's narrowing work.,0.40714285714285714,kotlin
11yz68i,jdbtl23,I always liked how Kotlin's smart casts and Typescript's narrowing work.,0.40714285714285714,typescript
11yz68i,jdc6rdh,in erlang simply very good.,0.9099999999999999,erlang
11yz68i,jdc6rdh,"Directly in the function parameter definition, the **guards** are also practical and in addition erlang has also partly real **unification**.",0.15000000000000002,erlang
11yz68i,jdc6rdh,"The unification feature could go from the power even more in the **Prolog** direction, that would be ingenious.",0.5,go
11yz68i,jdc6rdh,"The unification feature could go from the power even more in the **Prolog** direction, that would be ingenious.",0.5,prolog
11yz68i,jdc6rdh,"I think languages like Prolog offer extremely much,but are partially simply so different, so that one must throw very much experience knowledge from the other programming languages overboard to be able to program with it.Prolog is very hard at first if you come from imperative programming, for example.",0.0544047619047619,prolog
11yz68i,jdc6rdh,"Edit: oh, and as mentioned her elsewhere, pattern matching on **Erlang binaries** is also awesome.",1.0,erlang
11yz68i,jdc6rdh,"e.g:  ``` let (|Even|Odd|) input = if input % 2 = 0 then Even else Odd  let TestNumber input =    match input with    | Even -> printfn ""%d is even"" input    | Odd -> printfn ""%d is odd"" input ```` Scala has something similar to offer, only solved a little differently.",-0.09821428571428571,d
11yz68i,jdc6rdh,"e.g:  ``` let (|Even|Odd|) input = if input % 2 = 0 then Even else Odd  let TestNumber input =    match input with    | Even -> printfn ""%d is even"" input    | Odd -> printfn ""%d is odd"" input ```` Scala has something similar to offer, only solved a little differently.",-0.09821428571428571,scala
11yz68i,jdc6rdh,Scala e.g.,0.0,scala
11yz68i,jdc6rdh,"uses an unapply method on the associated singelton object for this purpose  ``` object Example {     def unapply(t: T): Option[(T1, ..., Tn)] = ... } value match {   case Example(t1, ..., tn) => ... } ```  Edit3:  Personally I find the idea that you can do pattern matching (head/tail) on lists or ""strings"" (in erlang strings are e.g.",0.0,erlang
11yz68i,jdc6rdh,lists of bytes) cool.,0.35,cool
11yz68i,jdc6rdh,In erlang I think simply always in List of data.,0.0,erlang
11yz68i,jdc6rdh,``` type nat is (int x) where x >= 0  function sum(nat[] items) -> nat:    int r = 0    int i = 0     while i < |items| where i >= 0 && r >= 0:       r = r + items[i]       i = i + 1    return r ```,0.0,r
11yz68i,jddjr3u,I like scala’s approach because it lets you define your types in a way and present a different interface for pattern matching interface by writing you own unapply functions.,0.19999999999999998,scala
11yz68i,jdbuynk,"I don’t know rust, but I’m not aware of any other lang that has anything similar to Erlang’s binary pattern matching.",-0.08333333333333333,rust
11yz68i,jdbuynk,"I don’t know rust, but I’m not aware of any other lang that has anything similar to Erlang’s binary pattern matching.",-0.08333333333333333,erlang
11yz68i,jdbuynk,"Erlang is fundamentally built around pattern matching, and has almost no other syntax.",0.0625,erlang
11yz68i,jdewqhc,"I'm designing a C like language so I wanted to design a c-compatible pattern matching construct, if you could call it like that.",0.0,c
11yz68i,jdewqhc,"With that in mind, I really liked how Swift designed their switch statement, more than C# and D.",0.55,swift
11yz68i,jdewqhc,"With that in mind, I really liked how Swift designed their switch statement, more than C# and D.",0.55,c
11yz68i,jdewqhc,"With that in mind, I really liked how Swift designed their switch statement, more than C# and D.",0.55,d
11yz68i,jdck3aa,"Rust cannot handle something like so:        let rec stack_or_reduce lex stack = match lex , stack with           Lint n ,  _      ->  (Texp (ExpInt n))::stack         | Lident v ,  _    ->  (Texp (ExpVar v))::stack         | Lstring s , _    ->  (Texp (ExpStr s))::stack        | Lsymbol ""("" , _  ->  Tlp::stack        | Lsymbol "")"" , (Texp e)::Tlp::st  ->  (Texp e)::st        | Lsymbol "")"" , _ -> stack_or_reduce lex (reduce 0 stack)         | Lsymbol s , _              -> let symbol =                   if s<>""-"" then tsymb s                   (* remove the ambiguity of the ``-'' symbol           *)                  (* according to the last exp element put on the stack *)                  else match stack                        with (Texp _)::_  ->  Tbin MINUS                                      | _ ->  Tunr UMINUS                 in ( match symbol with                        Tunr op  ->  (Tunr op)::stack                      | Tbin op  ->                          ( try stack_or_reduce lex (reduce (priority_binop op)                                                     stack )                           with ParseError -> (Tbin op)::stack )                     | _ -> raise ParseError )        | _ , _ -> raise ParseError ;;  (Source: https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora058.html#toc82)  Specifically, something like this bit (destructuring the elements of the stack `stack`):      | Lsymbol "")"" , (Texp e)::Tlp::st  ->  (Texp e)::st  (Well, it can, sort of, but it's very unwieldy, bare minimum, and then too only for certain types like `Vec` and `VecDeque`, and you could always run into issues with the Borrow Checker).",0.1080357142857143,rust
11yz68i,jdck3aa,"Of course, that being said, it is actually amazing that Rust can have so much of pattern matching support while not being an actual Functional language.",0.26666666666666666,rust
11yz68i,jdcxf1u,Doesn't Rust use PCRE?,0.0,rust
11yz68i,jdcxf1u,Why not go to the source?,0.0,go
11yz68i,jdcxf1u,Look up regular expressions in Perl or Raku.,0.0,perl
11yz68i,jdcevca,looks really cool.,0.35,cool
11yz68i,jdd0amx,Erlang’s bit syntax is amazing,0.6000000000000001,erlang
11yz68i,jdbicpk,> C#'s pattern matching also works in any boolean expression and can declare new variables inside of that expression  We're actually generalizing this idea in what we facetiously call the *Ultimate Conditional Syntax* (UCS).,0.04545454545454545,c
11yz68i,jdbicpk,"Check it out here: https://icfp22.sigplan.org/details/mlfamilyworkshop-2022-papers/6/The-Ultimate-Conditional-Syntax  It allows writing code like:       fun add(x, y) =       if x is Some(xv) and y is Some(yv)       then Some(xv + yv)       else None      fun nonZero(list) =       list is Nil or         list is x :: xs and x != 0 and nonZero(xs)      fun findFirst(list, p) =       if list is         Nil then None         x :: xs and           p(x) then Some(x)           else findFirst(xs, p)      fun zipWith(f, xs, ys) =       if xs is Cons(x, xs)         and ys is Cons(y, ys)         and zipWith(f, xs, ys) is Some(tail)         then Some(Cons(f(x, y), tail))       else if xs is Nil         and ys is Nil         then Some(Nil)       else None      fun mapPartition(f, xs) = if xs is       Nil then (Nil, Nil)       x :: xs and mapPartition(f, xs) is (l, r) and f(x) is         Left(v) then (v :: l, r)         Right(v) then (l, v :: r)      if x <=       31 then ""invisible""       57 and x >= 48 then ""digit""       90 and x >= 65 then ""uppercase""       122 and x >= 97 then ""lowercase""     else ""symbol""  And exhaustivness is checked (conservatively).",0.31500000000000006,r
11yz68i,jde0q8b,"Oh very interesting, the C# `is` expression seems to very similar to what I had in mind when I said ""better"" pattern matching.",0.3833333333333333,c
11yz68i,jdc9w9m,Haskell also has an interesting extension called View Patterns.,0.5,haskell
11yz68i,jdc9w9m,"They don't get used much, but it's a really cool way to add abstraction around algebraic data types, c without restricting pattern-matching capabilities.",0.275,cool
11yz68i,jdc9w9m,"They don't get used much, but it's a really cool way to add abstraction around algebraic data types, c without restricting pattern-matching capabilities.",0.275,c
11yz68i,jdbg55g,Some of this has been implemented in Haskell (which should also be a given language of interest if you haven't looked at it).,0.0,haskell
11yz68i,jdf4o3l,The `is` expression certainly seems to be the way to generalize many special cases like those of Rust.,0.35714285714285715,rust
11yz68i,jddwjxs,"In the same sense as one might say Cthulu is amazing, yes, but probably not the first word I’d grab for.",0.2833333333333334,d
11yz68i,jdcu6eb,This is really really cool.,0.35,cool
11yz68i,jdcmi2a,"At this stage, Haskell is more like a family of languages than a single one!",0.20535714285714285,haskell
11yz68i,jdbjnr9,(I'm not a C# developer),0.0,c
11yz68i,jdbbnwl,"Because, at least in my experience writing and reviewing a ton of code (in C#, not academic): most of the time, I'm interested in one or two patterns, with a default branch.",0.1125,c
11yz68i,jdbbnwl,"In the case of C#, the base type gets an abstract `Match` function which takes a handler closure for each case.",-0.8,c
11yz68i,jdbbnwl,"That way I get both C#'s very powerful but undecidable pattern matching, and exhaustivity for the types that need it.",0.39,c
11yz68i,jdbytfj,"MLScript looks really cool, thanks for sharing!",0.3,cool
11yz68i,jdbytfj,A language designed that way with full interop with TypeScript seems like a dream!,0.4375,typescript
11yz68i,jdbjz3m,"If you have some experience with Rust or Haskell, you will start to appreciate case-exhaustiveness matching",0.0,rust
11yz68i,jdbjz3m,"If you have some experience with Rust or Haskell, you will start to appreciate case-exhaustiveness matching",0.0,haskell
11yz68i,jdb69s3,"It is not easy to implement, but languages like Rust does it.",-0.21666666666666667,rust
11yz68i,jdcum1r,I implemented a prototype of the core algorithm in about 30 lines of Dart code.,0.0,dart
11yz68i,jdbr296,I do have Scala and Haskell experience.,0.0,scala
11yz68i,jdbr296,I do have Scala and Haskell experience.,0.0,haskell
11yz68i,jdbr296,Scala has exhaustive matching under some circumstances (sealed traits).,0.0,scala
11yz68i,jdbr296,"But maybe that's a symptom of ""if you don't have nails, nothing looks like a hammer"" - the lack of proper coproduct types on C#.",0.0,c
11yz68i,jdh6n4r,"This is not pattern matching, just how it would be done in the absence of such features:      record T =         var value     end          func add(x, y) =         if x.usertype = y.usertype = T then  # .type yields Record             T(x.value + y.value)         else             void         end     end          a := T(""abc"")     b := T(""xyz"")     c := add(a, b)          println c              # (abcxyz)     println c.usertype     # T     println add(12, 13)    # 'void'",-0.00625,c
11yz68i,jdchs64,"Does this mean that it will be fully interoperable with the *types* in TypeScript as well, ie giving type-checking and intellisense from imported TypeScript files?",-0.3125,typescript
11yz68i,jdchs64,There are other languages that let you import plain javascript but I don't know if anyone else is doing that?,-0.16964285714285715,javascript
11yz68i,jdchs64,Definately a valuable aim to allow working with TypeScript because so much of the world is moving there.,0.2,typescript
11yz68i,jdchs64,And for me not being able to let go of TypeScript interop is the one thing keeping me from working with other appealing languages.,0.2916666666666667,go
11yz68i,jdchs64,And for me not being able to let go of TypeScript interop is the one thing keeping me from working with other appealing languages.,0.2916666666666667,typescript
11yz68i,jdcljf5,"We have a very flexible type system with subtyping, structural typing, and equirecursive types which is basically compatible with TypeScript (with a few differences here and there which we hope to smooth over with time).",0.13333333333333333,typescript
11yz5rf,,So I'm trying to came up with a cool looking structure syntax for my [programming language](https://github.com/barn-lang/barn).,0.35,cool
11yz5rf,jdavjg9,This is something OCaml and Haskell get right: structure types should use the same syntax as discriminated unions.,0.14285714285714285,haskell
11yz5rf,jdgwfaw,"When declaring formal parameters, you use traditional Algol/C syntax: `(type_t1 arg1, type_t2 arg2 ...)`, but when declaring variables with let, you use ""Pascal"" style: `let somevar : type_t`.",0.0,pascal
11yz5rf,jdgwfaw,"(BTW, implication is (left) distributive over disjunction \[ (p => (q or r)) <=> ((p => q) or (p => r))\], and it seems function parameter types somehow are too, which I think is neat.",0.0,r
11yz5rf,jdbqzer,"I don't really like this concept from OCalm or Haskell, I don't even like the syntax of functional languages.",0.2,haskell
11yz5rf,jdee72w,I think this is something Haskell gets wrong.,-0.5,haskell
11yz5rf,jdcwuna,For other programming languages it would look cool but not for barn.,0.11249999999999999,cool
11yz5rf,jdet3a9,"I agree, Haskell doesn't get that part right.",0.2857142857142857,haskell
11yx65k,jdczncu,"c++'s lifetime model has some gems  rust's ownership model has absolute nuggets  checkout how databases use memory for persistence, querying, caching, and indexing  checkout the different levels of caching in c/c++/assembler programming.",0.1,c++
11yx65k,jdczncu,"c++'s lifetime model has some gems  rust's ownership model has absolute nuggets  checkout how databases use memory for persistence, querying, caching, and indexing  checkout the different levels of caching in c/c++/assembler programming.",0.1,rust
11yx65k,jdcot2n,"Then there's what FORTH does, as [discussed on StackOverflow](https://stackoverflow.com/questions/9882326/memory-management-in-forth).",0.0,forth
11yrcnl,jdb40mh,"Also, from the talk today, they mentioned that they want Verse to be ""the JavaScript of the metaverse"" (paraphrased), so I guess they're trying to push a more functional future in gamedev, rather than just for their own tools.",0.3666666666666667,javascript
11ymq2f,jd8u1og,"Interesting questions—I have seen vexing errors like that in beginners’ code a lot, including of course my own code when I was just learning FP in Haskell & OCaml.",0.55,haskell
11ymq2f,jdb43og,"I'd also add that we typically add at least some type annotations to Haskell code, making the errors less likely to sum up to a big mess.",-0.13472222222222222,haskell
11ymq2f,jdbgzok,Did you go through the whole study?,0.2,go
11ymq2f,jex395f,"Yes, getting accustomed to the errors as you go is expected.",-0.1,go
11ye7c0,jd8m5xh,"However, that's just a helicopter view, and when you go deeper, you understand that they work in different environments, under different constraints, and performance improvement methods used in CPUs and in compilers are quite different.",0.0,go
11ye7c0,jd7xdx0,"I'd maybe ask you the same question: what's an example of an interpreter that doesn't do translation, or why is this translator fundamentally different/more ""compiley"" from something like the python interpreter?",0.0,python
11ye7c0,jd7xdx0,"But I _still_ think it's meaningful to be like ""hey, you probably shouldn't just go around calling that a compiler because that will confuse people who are expecting an AOT compiler"".",0.5,go
11ye7c0,jd7zfx2,"As a concrete example, the SBCL implementation of Common Lisp generates machine code from source code.",-0.07499999999999998,lisp
11ye7c0,jd7zfx2,"> hey, you probably shouldn't just go around calling that a compiler because that will confuse people who are expecting an AOT compiler  On the contrary, it has surprised many people that there is a compiler making sense of forms typed at a Lisp REPL, because they equate ""compiler"" with ""batch compiler"", my past self included.",0.11666666666666665,go
11ye7c0,jd7zfx2,"> hey, you probably shouldn't just go around calling that a compiler because that will confuse people who are expecting an AOT compiler  On the contrary, it has surprised many people that there is a compiler making sense of forms typed at a Lisp REPL, because they equate ""compiler"" with ""batch compiler"", my past self included.",0.11666666666666665,lisp
11ye7c0,jd83gbh,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,python
11ye7c0,jd83gbh,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,c
11ye7c0,jd83gbh,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,assembly
11ye7c0,jd83gbh,C Code) to a lower level (e.g.,0.0,c
11ye7c0,jd87ca7,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,python
11ye7c0,jd87ca7,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,c
11ye7c0,jd87ca7,python -> Cpython bytecode -> C code -> assembly code -> machine code -> microcode -> transistors -> physical interactions -> ...).,0.0,assembly
11ye7c0,jd87ca7,The actual python you write never gets to that level.,0.0,python
11ye7c0,jd8ir2b,"I think to be abundantly clear, 90% of the time I will use the word ""interpreter"" to describe what's running JavaScript (if forced to choose one word or the other), not just Python.",-0.10833333333333334,javascript
11ye7c0,jd8ir2b,"I think to be abundantly clear, 90% of the time I will use the word ""interpreter"" to describe what's running JavaScript (if forced to choose one word or the other), not just Python.",-0.10833333333333334,python
11ye7c0,jd8ir2b,"It's really a whole specific runtime/implementation for the JavaScript virtual machine; on a high level, it really feels more like an interpreter that uses compiled fragments, which I would say seems the same for most of the runtime compilers that you're describing.",0.22285714285714286,javascript
11ye7c0,jd8kjol,Python being run through CPython will never touch actual C since that all got erased when CPython was AOT compiled.,0.0,python
11ye7c0,jd8kjol,Python being run through CPython will never touch actual C since that all got erased when CPython was AOT compiled.,0.0,c
11ye7c0,jd8kjol,It's hard to even argue that it gets translated to operations previously represented in C because it doesn't really.,-0.08611111111111112,c
11ye7c0,jd8recj,And each bytecode is executed by some C code which has already been compiled ahead of time (perhaps years previously) to machine code.,-0.16666666666666666,c
11ye7c0,jd8recj,There is no C nor machine code which has been specifically created for the program you wrote 10 seconds ago and are executing now.,0.0,c
11ye7c0,jd8recj,JIT products like PyPy are different: they may well generate dedicated machine code (C source is very unlikely) for the program you are running now.,-0.325,c
11yayy5,jd6xjah,"CS50  Structure and Interpretation of Computer Programs  Concepts, Techniques, and Models of Computer Programming  Haskell Programming from First Principles",0.25,haskell
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,go
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,r
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,c
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,java
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,python
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,perl
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,haskell
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,erlang
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,lisp
11yayy5,jd88d5c,"Light reading on general programming, for someone's first language:  * The Go Programming Language * K & R C * Java for Dummies * Learning Python * Learning Perl * (various Deitel & Deitel books)  Deep dives into more languages, tools, and ideas  * Learn You A Haskell * Practical Haskell * Learn You Some Erlang * Casting SPELs in LISP * Why's poignant guide to Ruby * Pro Git * Microsoft's ""Code"" book * The Information: A History, A Theory, A Flood * (various O'Reily Media pocket guides) * (various data structures and algorithms books) * (various discrete math books) * (various HPC books) * (various CERT secure programming books)  There's also a Pokemon speedrunning video that neatly introduces assembler, by way of abusing memory not protected by W XOR X.",0.12307692307692308,ruby
11yayy5,jd94tmi,Probably hands down the best was [Why's \(Poignant\) Guide to Ruby](https://poignant.guide/).,0.4222222222222222,ruby
11yayy5,jd94tmi,"Beyond the quirky popular appeal, it was written in a smart way and played to the strengths of Ruby.",0.2714285714285714,ruby
11yayy5,jdbidxl,"The Rust community has put a ton of effort into onboarding/language adoption resources and documentation— the book, the Rustlings course and “Rust by Example” are all quite good: https://www.rust-lang.org/learn",0.7,rust
11yayy5,jd7zgw9,Elixir has a really clear walk through of the language prominently displayed on their site.,0.3,elixir
11yayy5,jdalin2,The Rust book,0.0,rust
11yayy5,jd908t7,Learn You A Haskell,0.0,haskell
11yayy5,jdam02e,Bo quain and Jason Turner do c++ on YouTube that I like.,0.0,c++
11yayy5,jdam02e,Also there's what's a Creal I found some prologue and lisp stuff there too.,0.0,lisp
11yayy5,jdam02e,Actually now I think about it computerphile had a thing reverse Polish notation which I made a calculator in the bad version of lisp with.,-0.3499999999999999,lisp
11yayy5,jd8qngh,K&R demystified the whole concept of programming for me.,0.2,r
11yayy5,jdbowlt,"would you put k&r in the ""light reading"" part, along with ""deitel"", ""dummies"" and ""O'Reilly"" books??",0.4,r
11yayy5,jdbowlt,have you read the entire k&r?,0.0,r
11xppvw,,"What tools are available for making a basic IDE/editor on the web, and do you have versions of your compiler running in Javascript or is the code sent to the server where the compiler executes and sends back the output?",0.13333333333333333,javascript
11xppvw,jd523i8,"I had coded my regular expression programming language in Go, so I compiled it to wasm and made an npm package for it.",0.0,go
11xppvw,jd523i8,"Rust, C++, and I think js and typescript can compile to wasm.",0.0,rust
11xppvw,jd523i8,"Rust, C++, and I think js and typescript can compile to wasm.",0.0,c++
11xppvw,jd523i8,"Rust, C++, and I think js and typescript can compile to wasm.",0.0,typescript
11xn1gp,,"To me, the profusion of programming language choices today is a symptom of the decrepit state of C and of C++.",0.0,c
11xn1gp,,"To me, the profusion of programming language choices today is a symptom of the decrepit state of C and of C++.",0.0,c++
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,go
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,rust
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,c
11xn1gp,,"While I champion Go and Rust for having the balls to wipe the slate clean, I would also love for C and C++ to catch up.",0.43333333333333335,c++
11xn1gp,,"It's not like C or C++ projects will dissappear completely, so they might as well benefit from enriched standards.",0.1,c
11xn1gp,,"It's not like C or C++ projects will dissappear completely, so they might as well benefit from enriched standards.",0.1,c++
11xn1gp,,Both C and C++ are steadily modernizing.,0.16666666666666666,c
11xn1gp,,Both C and C++ are steadily modernizing.,0.16666666666666666,c++
11xn1gp,,"I'd like to see C do showcased on stage, what its preprocessor has been doing behind the curtains all these years.",-0.4,c
11xn1gp,jd56kkt,Unpopular opinion here but... Leave C and C++ alone.,0.0,c
11xn1gp,jd56kkt,Unpopular opinion here but... Leave C and C++ alone.,0.0,c++
11xn1gp,jd56kkt,Go and Rust for example have objectively excellent tooling regardless of what people think of those languages.,1.0,go
11xn1gp,jd56kkt,Go and Rust for example have objectively excellent tooling regardless of what people think of those languages.,1.0,rust
11xn1gp,jdbso9m,"I agree with the headline to 50%, namely for C++.",0.0,c++
11xn1gp,jdbso9m,In my opinion C is really stable and mature.,0.15000000000000002,c
11xn1gp,jdbso9m,What is really missing in C?,-0.2,c
11xn1gp,jdbso9m,But for C++ I totally agree.,0.0,c++
11xn1gp,jdbso9m,"While this can be great for a lot of slow updating companies to mix various libraries compiled with different C++ standards, it really blocks the language.",0.13999999999999999,c++
11xn1gp,jdbso9m,Then the user can choose: Mix use of C++ standards or use the newest only but without all the problems which are there because of the frozen ABI.,0.0,c++
11xn1gp,jd7p7x0,What about improving C as an IR with features like tail calls and ABIs that pass structs in registers?,0.0,c
11xn1gp,jdn33cs,I couldn't care less of C or C++.,-0.16666666666666666,c
11xn1gp,jdn33cs,I couldn't care less of C or C++.,-0.16666666666666666,c++
11xn1gp,jdq63jy,C is stable and IMO fine as it is.,0.4166666666666667,c
11xn1gp,jdq63jy,"C++ is already overfeatured, yet lacking lots of essential things, with no plausible timeframe to cover them.",-0.125,c++
11xn1gp,jd6s10r,"I don't care for C++ but please don't change C. Stability is one of its main pillars, and I would NOT want to see any major new features in it.",0.12184343434343432,c++
11xn1gp,jd6s10r,"The world is running on C, after all.",0.0,c
11xn1gp,jd6s10r,"Stability is in fact the reason I use C despite hating it, and am not using Zig despite loving it.",0.6,c
11xn1gp,jdgvmhu,There was an effort in that direction called [C--](https://en.wikipedia.org/wiki/C--).,0.0,c
11xn1gp,jdgvmhu,"It seems ghc uses a fork of C-- called [cmm](https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/cmm), for it's IR.",0.0,c
11xn1gp,jd7be5e,"Some of the ""stable"" features of C include enforced undefined or implementation-defined behavior.",0.0,c
11xn1gp,jd7be5e,"If the ANSI C committee simply mandated that all integer types must be 2s complement and wrap around with predictable semantics (i.e., the ones supported by x86, PowerPC, Alpha, Arm, MIPS, SPARC, 68K, and anything else that isn't braindead) would that ruin its stability?",-0.1,c
11xn1gp,jd7be5e,"If the ANSI C committee augmented the varags functionality to be able to tell when you have consumed past the end of a ... argument list, would that ruin its stability?",0.125,c
11xn1gp,jd7be5e,"If the ANSI C committee mandated a function to let you multiply two of the largest integers (signed or unsigned) supported by the compiler to yield a double output result (which literally every CPU architected from the 1990s onward supports, and is otherwise emulatable) would that ruin its stability?",0.0,c
11xn1gp,jd7be5e,If the ANSI C committee simply removed strtok() and replaced it with GCC's strtok_r() would that ruin its stability?,0.0,c
11xn1gp,jd7be5e,"On the other hand, the ANSI C committee saw fit to specify ""wchar_t"" before Unicode solidified as a standard.",0.09166666666666667,c
11xn1gp,jd7be5e,"If the ANSI C committee instead defined a unicodeunit_t type and then defined a bunch of APIs to treat and parse it as Unicode data (the Unicode Consortium already has a bunch of sample code for such things), and deprecated usage of wchar_t would that ruin its stability?",0.0,c
11xn1gp,jd42zfp,It's similar to this subreddit but people are much smarter and program only in Forth,0.06666666666666667,forth
11xn1gp,jd7vf53,"So support for ""a function to let you multiply two of the largest integers"" is propable (but in next C that is C29).",0.0,c
11xn1gp,jd9cy5s,"First, reply in substance: C powers the browser you are using, the OS you are using, the myriad libraries like `libpng` or `zlib` that you take for granted, it powers spaceships, airplanes, cars and God know what else, and it does that without any fancy features like closures, GC or whatever strange stuff you're requesting.",0.1,c
11xn1gp,jd9cy5s,"Just look at C++ modules, haha.",0.2,c++
11xn1gp,jd9cy5s,> If the ANSI C committee mandated a function to let you multiply two of the largest integers ...  and is otherwise emulatable  You have your answer.,0.0,c
11xn1gp,jd9cy5s,"> If the ANSI C committee simply removed strtok() and replaced it with GCC's strtok_r() would that ruin its stability  Write your own `strtok`, the C committee isn't there to babysit you.",0.3,c
11xn1gp,jd9cy5s,C code doesn't need emojis of poop in all colors of the rainbow.,0.0,c
11xn1gp,jd5a3ur,Forth is life,0.0,forth
11xn1gp,jdbuvza,>  C powers the browser you are using ...  You're arguing incumbency as a justification for its brokenness?,0.0,c
11xn1gp,jdbuvza,Are you not aware that the Rust language was literally designed so that the Firefox people could transition away from using C/C++?,-0.125,rust
11xn1gp,jdbuvza,Who the hell wants to put in weird features like those into C?,-0.15,c
11xn1gp,jdbuvza,> > If the ANSI C committee mandated a function to let you multiply two of the largest integers ... and is otherwise emulatable  > You have your answer.,0.0,c
11xn1gp,jdbuvza,"The point is that writing the emulation code in current C takes at least 4 times as long and relies on full 2s complement semantics (which until recently, apparently was not mandated).",0.01,c
11xn1gp,jdbuvza,"The crypto community, of course, didn't bother to wait for the ANSI C committee to get its act together, they use ""GMP"" which uses assembly language to implement it.",0.0,c
11xn1gp,jdbuvza,"The crypto community, of course, didn't bother to wait for the ANSI C committee to get its act together, they use ""GMP"" which uses assembly language to implement it.",0.0,assembly
11xn1gp,jdbuvza,"> > If the ANSI C committee simply removed strtok() and replaced it with GCC's strtok_r() would that ruin its stability > Write your own strtok, the C committee isn't there to babysit you.",0.3,c
11xn1gp,jdbuvza,> C code doesn't need emojis of poop in all colors of the rainbow.,0.0,c
11xn1gp,jd7jbnn,>  But what about A*B*C?,0.0,c
11xn1gp,jd7jbnn,The purpose is not to define where you end -- it's to leverage the multi-billion dollar investment by CPU vendors into the transistors on your CPU that went into supporting that feature and is currently inaccessible in ANSI C.  > The big thing about C is that it supports all sorts of devices.,0.08333333333333333,c
11xn1gp,jd7jbnn,"> I proposed once that C should be split into two languages, one for small microcontrollers, the other for ordinary processors used on desktop machines, tablets etc, and which are now predominately 64 bits.",-0.20833333333333334,c
11xn1gp,jd7jbnn,"It's called ANSI C 89 for microcontrollers, and ANSI C 99 (which I believe was finally adopted by the predominant players a few years ago -- only about 15 years late) for everything else.",-0.125,c
11xn1gp,jd7jbnn,I already have a guaranteed 8-bit byte type -- that's because market forces and simple sanity have prevailed over the embrace of vagueness from the ANSI C committee.,0.0,c
11xn1gp,jd7jbnn,"The features I am pointing out are not unavailable to me -- I roll my own, use intrinsics or inline assembly as required, and ignore the proclamations of the ANSI C committee.",0.6,assembly
11xn1gp,jd7jbnn,"The features I am pointing out are not unavailable to me -- I roll my own, use intrinsics or inline assembly as required, and ignore the proclamations of the ANSI C committee.",0.6,c
11xn1gp,jd7jbnn,"), which the ANSI C committee should be providing, and so the language languishes.",0.0,c
11xn1gp,jd7jbnn,Just another reason to be unimpressed with the ANSI C committee.,0.0,c
11xjwwk,jd3mxj0,It's a cool idea!,0.4375,cool
11xjwwk,jd3mxj0,"The way I see it, it's at least quarternary: Strong/Weak and Static/Dynamic - you've a typo in the option ""cmputible fields"" for the features question - compile time function evaluation/code execution probably should be a feature option - I would suggest adding a feature option for ""constrained types"" like Ada's type constraints and D's invariants - I would add ""call <lang> code"" and ""be called from <lang> code"" as options, thinking about C++ and other languages with which one may wish to be interface-compatible with - should ""hybrid"" be an option for memory management, or are you happy to capture this as ""other""?",0.06250000000000001,ada
11xjwwk,jd3mxj0,"The way I see it, it's at least quarternary: Strong/Weak and Static/Dynamic - you've a typo in the option ""cmputible fields"" for the features question - compile time function evaluation/code execution probably should be a feature option - I would suggest adding a feature option for ""constrained types"" like Ada's type constraints and D's invariants - I would add ""call <lang> code"" and ""be called from <lang> code"" as options, thinking about C++ and other languages with which one may wish to be interface-compatible with - should ""hybrid"" be an option for memory management, or are you happy to capture this as ""other""?",0.06250000000000001,d
11xjwwk,jd3mxj0,"The way I see it, it's at least quarternary: Strong/Weak and Static/Dynamic - you've a typo in the option ""cmputible fields"" for the features question - compile time function evaluation/code execution probably should be a feature option - I would suggest adding a feature option for ""constrained types"" like Ada's type constraints and D's invariants - I would add ""call <lang> code"" and ""be called from <lang> code"" as options, thinking about C++ and other languages with which one may wish to be interface-compatible with - should ""hybrid"" be an option for memory management, or are you happy to capture this as ""other""?",0.06250000000000001,c++
11xjwwk,jd3z8ky,Cool idea.,0.35,cool
11xjwwk,jd3pbjn,"It's a cool idea, I would definitely participate.",0.175,cool
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,c
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,c++
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,objective-c
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,java
11xjwwk,jd79fe6,"I'd be interesting to know what other languages beyond the ""big six"" are some languages implemented in (besides say C,C++, Objective-C, Java, JavaScript, C#)  (the ""big six"" is totally my own definition for systems/foundational languages that are popular bases for other languages —I'm open to alterations of said list)",0.18125,javascript
11xjwwk,jda2df0,"> what other languages beyond the ""big six""  Rust is winning with 20 entries.",0.125,rust
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,haskell
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,go
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,c
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,c++
11xjwwk,jda2df0,"5 Haskell, 7 Go, 9 C, 14 C++, 20 Rust.",0.0,rust
11xjwwk,jda2df0,"Is Objective-C really deserving its place in ""the big six?""",0.3,objective-c
11xjwwk,jd8ekac,"Python, Erlang, and Lua all have a smattering of smaller languages targeting their respective runtimes.",0.0,python
11xjwwk,jd8ekac,"Python, Erlang, and Lua all have a smattering of smaller languages targeting their respective runtimes.",0.0,erlang
11xjwwk,jd8ekac,"Python, Erlang, and Lua all have a smattering of smaller languages targeting their respective runtimes.",0.0,lua
11xjwwk,jd8ekac,PHP has a few but really only Hack is notable.,0.09999999999999999,php
11xjwwk,jd8ekac,"I don't know of any 3rd-party languages that target the Objective-C runtime, just Swift.",0.0,objective-c
11xjwwk,jd8ekac,"I don't know of any 3rd-party languages that target the Objective-C runtime, just Swift.",0.0,swift
11xjwwk,jd8ekac,Swift is notable for being the first (afaik) where the hosted language became more popular than the original language the platform was designed for.,0.445,swift
11xjwwk,jda5lst,"sounds like Objective C probably should be replaced with Rust for this definition, good idea!",0.4375,c
11xjwwk,jda5lst,"sounds like Objective C probably should be replaced with Rust for this definition, good idea!",0.4375,rust
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,objective-c
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,java
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,c
11xjwwk,jda3vfc,"> I don't know of any 3rd-party languages that target the Objective-C runtime  Java, C#, Go, Visual Basic, Oxygene and dialects all have [Elements](https://www.remobjects.com/elements/) compiling them against Cocoa (and to Java Bytecode too, for that matter).",0.0,go
11xjwwk,jda3vfc,"Their dialects even have features for interop with Objective-C's runtime, like RC modifiers and autorelease pools.",0.0,objective-c
11x3k9q,jd1vs5f,"APL was originally designed to be written on a board, and coincidently could make a return for phones.",0.375,apl
11x3k9q,jd1ohfo,"You can download a keyboard to program in APL or BQN too, though you have to know all the shortcuts!",0.0,apl
11x3k9q,jd228rk,"The goal was to have many prebuilt components for common constructs, not only for procedures but also for defining data and even other schemas so it could be a simple game of assembly.",-0.05416666666666667,assembly
11x3k9q,jd228rk,"Felt like writing AST by hand, with a lisp feel to it, as all code elements were addressable.",0.0,lisp
11x3k9q,jd5g0mk,"Being able to reorder code blockly style would be cool, though.",0.425,cool
11x3k9q,jd3mgqx,I had the idea of a “conventional” language (a lisp-like) but having a secondary notation roughly APL or J style that could be expanded to the first.,-0.0732142857142857,apl
11x3k9q,jd3mgqx,"I also figured out that if the symbols were hard to understand, you’d at least be able to see the lispy version.",-0.030555555555555558,d
11x3k9q,jd1tz20,Don't forget K. I like using https://ngn.bitbucket.io/k/#r Now that it is in my phone's browser cache it works offline too.,0.0,r
11x3k9q,jd1c3p5,"if you just go around searching for ""touch screen code editor"" or similar prompts you should find what you want",0.0,go
11x3k9q,jd3s3g2,"J, the successor to APL",0.0,apl
11wtv7v,jd6x9yq,I jumped on WASM because JaveScript needs to go away already.,0.0,go
11wtv7v,jd6x9yq,Professionally I use Blazor Webassembly to create SPAs using C# for both backend and frontend.,0.1,c
11wtv7v,jfj6llb,"I don’t think JavaScript is going away for a long time, WASM or no.",-0.05,javascript
11wtv7v,jfj6llb,"WASM is still pretty niche and I don’t really see that changing, it’s something you have to *want* to do and takes a lot of extra work whereas JavaScript has a huge amount of infrastructure and tooling.",0.21250000000000002,javascript
11wiqhz,jczbf7v,"_Note: Rust does not support indexes over `isize::MAX`, or pointer arithmetic with offsets over `isize::MAX`, despite using `usize`.",0.0,rust
11wiqhz,jcy8qly,"Rust uses unsigned, machine sized integers for sizes and indexes, although it is a pretty different language.",0.125,rust
11wiqhz,jcyl0z9,"C's implicit conversions are the devil, as it mixing unsigned and singed numbers, so anything to do away with such problems is a good idea.",0.35,c
11wiqhz,jcze2u1,in Python you often have to add `or None` to avoid edge-case bugs.,0.0,python
11wiqhz,jczg6m9,"> Note: Rust does not support indexes over isize::MAX, or pointer arithmetic with offsets over isize::MAX, despite using usize.",0.0,rust
11wiqhz,jczg6m9,"I can buy the point of `usize` for languages that really need to be able to have structures that cover over half of the memory space, which is pretty much only operating systems or memory managers, but it seems like that won't really work in Rust with this restriction.",0.1638888888888889,rust
11wiqhz,jczg6m9,I wonder if Rust's definition of `usize` is to simplify the interaction with the `size_t` world.,0.0,rust
11wiqhz,jd0k855,"Ugh, try implementing symmetric cryptography or anything that relies heavily on bitwise arithmetic in Java.",-0.2,java
11wiqhz,jd0k855,"And then Java had to introduce a special ""unsigned right shift"" (`>>>`) operator to ignore the sign bit when faking unsigned integers this way.",0.3214285714285714,java
11wiqhz,jd08wgn,"> Note: Rust does not support indexes over `isize::MAX`  Nitpick: this is possible, but only for array/slices of zero sized types.",0.0,rust
11wiqhz,jczys02,"It doesn't support heap allocations over isize::MAX, but pointer arithmetic with wrapping_offset is still allowed and at least on some platforms (Linux 64 bit) you can create create larger arrays (although the rust reference claims otherwise?)",-0.15,rust
11wiqhz,jcziyu6,"Right, I think Rust demonstrates that unsigned can work well for this.",0.2857142857142857,rust
11wiqhz,jcziyu6,Rust's slice abstraction focuses on the slice as a contiguous sequence of constant-size values.,0.0,rust
11wiqhz,jczx0a9,"Well excluding pointer arithmetic, which is a thing in unsafe rust, I think this is more a limitation of LLVM than Rust from what I’m told… So yeah like if you’re implementing your own Vec struct and you use the add method on a pointer to do pointer math, it turns internally uses the offset method, which it itself uses LLVM stuff iirc",0.3666666666666667,rust
11wiqhz,jcztw6n,">Rust uses unsigned, machine sized integers for sizes and indexes  I wonder why modern languages are so allergic to arrays with arbitrary lower bounds?",0.05,rust
11wiqhz,jcylj5d,"In C, isn't it mostly backwards compatibility that prevents `ssize_t` from being used everywhere?",0.5,c
11wiqhz,jd49puw,What are the cases where you need `or None` in Python?,0.0,python
11wiqhz,jcz8uf5,"> Because of historical accident, the C++ standard also uses unsigned integers to represent the size of containers - many members of the standards body believe this to be a mistake, but it is effectively impossible to fix at this point.",-0.04166666666666666,c++
11wiqhz,jcz76a6,"Amusingly, the reason Rust only uses `usize` for indexing is type inference issues.",0.3,rust
11wiqhz,jd145sc,"Both the [CLR](https://learn.microsoft.com/en-us/dotnet/standard/numerics) and [Mono](http://docs.go-mono.com/index.aspx?link=T%3ASystem.UInt32) have them as extensions, and they are standard in [C#](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types).",0.0,c
11wiqhz,jd2ebpt,"This used to be true, a decade ago, but Java added library functions to support unsigned arithmetic.",0.35,java
11wiqhz,jd12i5l,"In D, we even have `void[]` as ""array of arbitrary bytes"" being distinct from `byte[]` where `byte` is an integer type (and that distinction has relevance because ""arbitrary bytes"" include pointers to scan during GC).",0.033333333333333326,d
11wiqhz,jczvld3,">Right, I think Rust demonstrates that unsigned can work well for this.",0.0,rust
11wiqhz,jd0aj5x,C's rules are reversed.,0.0,c
11wiqhz,jd10c8y,"When there is a syntax error after a multi-line string in Perl, the compiler tells me I may have forgot to close the string.",0.0,perl
11wiqhz,jd10c8y,"When I do funny parentheses business in D, it tells me that ""this kind of C casts is not supported.""",0.425,d
11wiqhz,jd10c8y,"When I do funny parentheses business in D, it tells me that ""this kind of C casts is not supported.""",0.425,c
11wiqhz,jd10c8y,"Let's go further and have compilers recognise APIs of languages in the same space:   ""Function `flip` does not exist.",0.0,go
11wiqhz,jd10c8y,Did you mean Haskell's `flip`?,-0.3125,haskell
11wiqhz,jcym7tu,"> In C, isn't it mostly backwards compatibility that prevents ssize_t from being used everywhere?",0.5,c
11wiqhz,jcym7tu,Because reurning two things is simply out of the question for most C code!,0.3125,c
11wiqhz,jd071ej,"EDIT:  After a little more digging, I think I found the motivation in the C standard draft n3047 section 6.5.6  > When an expression that has integer type is added to or subtracted from a pointer... produces an overflow, the behavior is undefined  > the expression `Q` points to the last element of the same array object ... `((Q)-(P))+1` ... has the value zero if the expression `P` points one past the last element of the array object  I'm assuming that pointer operations operate under the same restriction, so the type MUST be signed in order to avoid underflow and the ""warping"" behavior also warned by the Rust docs.",0.0078125,c
11wiqhz,jd071ej,"EDIT:  After a little more digging, I think I found the motivation in the C standard draft n3047 section 6.5.6  > When an expression that has integer type is added to or subtracted from a pointer... produces an overflow, the behavior is undefined  > the expression `Q` points to the last element of the same array object ... `((Q)-(P))+1` ... has the value zero if the expression `P` points one past the last element of the array object  I'm assuming that pointer operations operate under the same restriction, so the type MUST be signed in order to avoid underflow and the ""warping"" behavior also warned by the Rust docs.",0.0078125,rust
11wiqhz,jd0cp4q,"If that's what you're going for - a small number of types that are maximally flexible, like Python or Javascript objects - that's fine, but it has costs in terms of the ability to express correct, mechanically provable, and efficient code.",0.08333333333333334,python
11wiqhz,jd0cp4q,"If that's what you're going for - a small number of types that are maximally flexible, like Python or Javascript objects - that's fine, but it has costs in terms of the ability to express correct, mechanically provable, and efficient code.",0.08333333333333334,javascript
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,go
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,lua
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,python
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,c
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,julia
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,rust
11wiqhz,jd0jpv2,"Here's my example again, together with 12 other languages (all versions of the same benchmark):          p[i] := i           M (these two are mine)         p[i] := i           Q         p[i] = i            Go         p[i] = i            Lua         p[i] = i            Python         p[i] = i;           C         p[i] = i            Julia         p[i as usize] = i;  Rust         p[i] = i;           D         p[i] = i;           Nim         p[i] := i;          Algol68         p[i] = i;           Odin         p[i] = i;           Zig  Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.01785714285714286,d
11wiqhz,jd0jpv2,"When I want that, then I'll code in Ada (or rather, someone else can do so on my behalf).",0.0,ada
11wiqhz,jd0jcil,Rust has `checked_sub` and `saturating_sub` to prevent that.,0.0,rust
11wiqhz,jd1oi5a,"> Are we to be led to believe, that Rust got it right, and all the rest got it wrong?",-0.10714285714285715,rust
11wiqhz,jd1oi5a,"> When I want that, then I'll code in Ada (or rather, someone else can do so on my behalf).",0.0,ada
11wiqhz,jd2hbat,"),  C and Algol68 are over 50 years old.",0.1,c
11wiqhz,jd2hbat,"But Zig, Odin, Go, D, Nim, Julia are much more recent.",0.25,go
11wiqhz,jd2hbat,"But Zig, Odin, Go, D, Nim, Julia are much more recent.",0.25,d
11wiqhz,jd2hbat,"But Zig, Odin, Go, D, Nim, Julia are much more recent.",0.25,julia
11wiqhz,jd2hbat,"There is also Dart, which doesn't have a special unsigned or size type either.",0.35714285714285715,dart
11wiqhz,jd4qgzf,"Certainly C++ has gone much too far in the direction of ""implement everything in the library"", and it is *sometimes* beneficial to prefer a simpler solution in the compiler itself.",0.1714285714285714,c++
11wiqhz,jczxtbk,"Yes, they do, which means there's no reason not to go for the signedness that match the closest an index's domain of definition.",0.0,go
11wiqhz,jd04s2v,"In the end the truth is that C programmers (and Futhark it seems) are the kind of people that think they will never make mistakes and so they want a language that uses the same type for both indexes and index difference, and for indexing to work exactly like in hardware(on certain CPUs), where the CPU doesn't care about the sign of the index.",0.26607142857142857,c
11whkpu,jd19iud,"In my spare time language I go a similar route with unit and intersection types, similar to TypeScript.",0.0,go
11whkpu,jd19iud,"In my spare time language I go a similar route with unit and intersection types, similar to TypeScript.",0.0,typescript
11whkpu,jcyi8t3,Haskell I try to make the binding implicit by working with declarative and referential expressions.,0.0,haskell
11whkpu,jd2orfq,I could go on and put in an expression `(int (x+1)) -> x`.,0.0,go
11whkpu,jd4hju9,"[TypeScript](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html), [Scala](https://docs.scala-lang.org/scala3/book/types-intersection.html) and [Ceylon](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types) are languages which share that property.",0.0,typescript
11whkpu,jd4hju9,"[TypeScript](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html), [Scala](https://docs.scala-lang.org/scala3/book/types-intersection.html) and [Ceylon](https://ceylon-lang.org/documentation/1.3/tour/types/#intersection_types) are languages which share that property.",0.0,scala
11whkpu,jd4hju9,`(a -> b) & (c -> d)` is a subtype of `(a | c) -> (b | d)`.,0.0,c
11whkpu,jd4hju9,`(a -> b) & (c -> d)` is a subtype of `(a | c) -> (b | d)`.,0.0,d
11vnm65,jcu38iu,“One goal is to have easy access to GPU/parallel programming” - cool goal.,0.39166666666666666,cool
11vnm65,jcugpag,"Its theme is unusual, but looks cool.",0.275,cool
11vnm65,jcvcjhh,The comparison of Yaksha to Python and the niche it occupies remind me very much of Nim: https://nim-lang.org/  Are Yaksha's goals distinct from Nim?,0.28,python
11vnm65,jcw6heq,Just go for automatic memory deallocation.,0.0,go
11vnm65,jcw6heq,We all want a typed compiled python.,0.0,python
11vnm65,jdsoxnv,"Hi mate, this is looking great, I wonder if you’d be ok with a DM, I wanted to understand your parser better",0.6,d
11vnm65,jcv8xjo,"Looks good, also I would say that you have some work to do on how you relate to Python.",0.7,python
11vnm65,jcv8xjo,"The more you compare your language to Python, the easier it will be for users to be confused when your language differ from Python in ways that are not obviously required by a different semantic.",0.024999999999999994,python
11vnm65,jcv8xjo,"For example from the home page of your website I can tell that print doesn't work ""as expected"", just like import (because import foo.bar bring foo.bar into the scope in Python and bar in yaksha).",-0.1,python
11vnm65,jcv8xjo,"In both cases the difference could have been avoided if you wanted to, and that will confuse people thinking ""ok, I'll write typed python code and see what happens"".",0.5,python
11vnm65,jcv8xjo,"You can decide you prefer it that way, but then don't talk about Python this much.",0.2,python
11vnm65,jcu3qos,I have seen bunch of Python like languages that do this these days.,0.0,python
11vnm65,je3zjzp,Typed and compiled python sounds a lot like nim.,0.0,python
11vnm65,jda1l53,"Hmm, it does not look anything like `go`.",0.0,go
11vnm65,jda1l53,"Except for `defer`, which I took from go, as I thought that would be useful for deleting stuff & calling a del_xx function.",0.3,go
11vnm65,jda1l53,I'm not a go expert so not sure what exactly are the differences feature wise.,0.2333333333333333,go
11vnm65,jda1l53,One difference is go uses a garbage collector and this does not.,0.0,go
11vnm65,jda1l53,And also put that burden on the language user to manage memory like C or C++ would do!,0.0,c
11vnm65,jda1l53,And also put that burden on the language user to manage memory like C or C++ would do!,0.0,c++
11vl0bk,jd9iee2,Cool,0.35,cool
11vd0q9,,"For example, an array of the 1 and 2 letter abbreviations for the chemical elements usually has to be something like this:  `elements = [""H"",""He"",""Li"",""Be"",""B"",""C"",""N"",""O"",""F"",""Ne"", ....];`  If the string literals were shown in reverse video, or bold, or whatever distinct way the display supports, the quote marks would not be needed:  `elements = [`**H**`,`**He**`,`**Li**`,`**Be**`,`**B**`,`**C**`,`**N**`,`**O**`,`**F**`,`**Ne**`, ....];`  Regexes could be a lot cleaner looking.",0.12777777777777777,c
11vd0q9,,"This snippet of Perl (actually, Raku):  `/ '\\\'' /;          # matches a backslash followed by a single quote: \'`   would instead be this:  `/` **\\'** `/;          # matches a backslash followed by a single quote: \'`  Here are lots more examples, using regexes from the Camel book: [https://jsfiddle.net/twx3bqp2/](https://jsfiddle.net/twx3bqp2/)     Programming languages all stick to symbology.",-0.12755102040816327,perl
11vd0q9,jcsxr3o,[colorForth](https://colorforth.github.io/) by Chuck Moore (the original inventor of Forth) does this.,0.375,forth
11vd0q9,jcso03s,"If you use (optionally hidden) start/end markers (like in HTML, and like [WordPerfect's control sequences](https://de.wikipedia.org/wiki/Datei:Wordperfect_steuerzeichen.png) you end up with a more verbose equivalent of quotes.",0.16666666666666669,html
11vd0q9,jcuck7p,Algol 60 had something similar.,0.0,algol
11vd0q9,jcuqxt3,This reminds me of Terry A. Davis' [DolDoc](https://web.archive.org/web/20220506081504/https://templeos.holyc.xyz/Wb/Doc/DolDocOverview.html#l1) format where the Holy C code can embed 3D graphics.,0.0,c
11vd0q9,jctqom7,"~~Like Erlang or Lisp where `:foo == ""foo""` (or `(== :foo ""foo"")` rather).~~  Like Opal whee `:foo == ""foo""`.",0.0,erlang
11vd0q9,jctqom7,"~~Like Erlang or Lisp where `:foo == ""foo""` (or `(== :foo ""foo"")` rather).~~  Like Opal whee `:foo == ""foo""`.",0.0,lisp
11vd0q9,jcu28m3,"Yes, I think the approach used in HTML is the right approach.",0.2857142857142857,html
11vd0q9,jcu28m3,But HTML is much too verbose.,0.2,html
11vd0q9,jcuv7sf,> I think much more interesting is the question whether one should try and popularize the use of more Unicode symbols and letters for operators and variable names  You mean like [Algol](https://en.wikipedia.org/wiki/ALGOL_60#Standard_operators) which used [XCCS](https://en.wikipedia.org/wiki/Xerox_Character_Code_Standard) instead of ASCII?,0.296875,algol
11vd0q9,jcuv7sf,Fun fact: Unicode inherited `⏨` from Algol code encoded in [GOST 10859](https://en.wikipedia.org/wiki/GOST_10859) and used in the [Buran spaceplane](https://en.wikipedia.org/wiki/Buran_%28spacecraft%29).,0.3,algol
11vd0q9,jcunqjm,"Those who complain about Python's use of ""significant space"" I say are really complaining about ASCII markup.",0.2875,python
11vd0q9,jcunqjm,I think HTML is on the right track.,0.2857142857142857,html
11vd0q9,jcunqjm,"If the terminal supported an HTML like text positioning system, then utilities could use this.",0.0,html
11vd0q9,jcunqjm,"HTML is fundamentally hierarchical, and I think ASCII markup should be that too.",0.0,html
11vd0q9,jcunqjm,"HTML's parent, SGML, actually has a `</>` tag.",0.0,html
11vd0q9,jcunqjm,"A typeless open analogous to a blank HTML tag, `<>`, if such a thing existed, I believe won't be enough, got to have some means of adding type.",0.0,html
11vd0q9,jcvpxry,"OP would need their own text rendering system, but it's totally possible - ALGOL did it, LISP did it, Smalltalk did it, etc.",0.3,algol
11vd0q9,jcvpxry,"OP would need their own text rendering system, but it's totally possible - ALGOL did it, LISP did it, Smalltalk did it, etc.",0.3,lisp
11vd0q9,jcx1f9a,"`""foo""` is a string in Lisp.",0.0,lisp
11vd0q9,jcx1f9a,"In Common Lisp one may well write `|this is a symbol|` which is a symbol, however.",-0.3,lisp
11vd0q9,jcx1f9a,"Erlang tells me `foo == ""foo""` is false too.",-0.4000000000000001,erlang
11vd0q9,jcxl16w,Erlang calls them [atoms](https://www.erlang.org/doc/reference_manual/data_types.html#atom).,0.0,erlang
11vd0q9,jcxl16w,"Clojure says you have to manually intern them (I guess) before checking with `(== :foo (keyword ""foo""))`.",0.0,clojure
11vd0q9,jcxl16w,"Searching a bit had me find that Ruby agrees too, but not Opal.",0.0,ruby
11vd0q9,jcvjqok,Like HTML's `<div>` element.,0.0,html
11vd0q9,jcxnpd4,"Clojure lets me `(== 'foo (symbol ""foo""))`.",0.0,clojure
11vd0q9,jcxnpd4,"Ruby calls the colon-prefixed ones [symbols](https://docs.ruby-lang.org/en/master/syntax/literals_rdoc.html#label-Symbol+Literals), and JRuby says `:foo == ""foo""` is true too.",0.35,ruby
11vd0q9,jcxqobr,"Ruby says `""foo"".class` is String; I suspect there's type punning going on in the comparison.",0.0,ruby
11vd0q9,jcxqobr,"In Common Lisp I can opt in to a bit of type punning by `(string= 'foo ""FOO"")` (the symbol name being uppercased for historical raisins).",-0.15,lisp
11vd0q9,jcyhpwp,Thank you for teaching me more about Lisp!,0.625,lisp
11uhq7c,,"```c // filename -> a.foo  fun hello(){  print ""Hello""; } ```  And then  ```c //filename -> b.foo  import x ""a.foo"" hello() //prints, Hello fun hello(){  print ""xyz"";  }  hello() //prints, xyz   ```  As of now, the custom name doesn't do anything now, but I wanted to make the imported module functions and variables be accessed via something like `name::hello();` so that the namespace would not get polluted.",0.3,c
11uhq7c,,"As of now, this crazy thing is possible =>  file a.foo  ```c fun hello(){   pi = 100; } ```  And b.foo  ```c import afoo ""a.foo"" var pi = 3.14;  hello()  // pi is now 100!!",-0.04374999999999999,c
11uhq7c,jcobtpo,The approach I took to modules is modeled after Python.,0.0,python
11uhq7c,jcobtpo,"The approach Python takes is to have the ""GET_GLOBAL"" opcode first check the globals table, and then do some complicated second-stage lookup for a `__builtins__` entry within that globals table and then lookup things in that; by default, every module has a `__builtins__` member that points to the `builtins` module, and if there is no `__builtins__` member then the `builtins` module is used as a fallback anyway.",-0.125,python
11uhq7c,jcop8tp,"Even with a module scheme with namespace control, that wouldn't stop `pi` being changed like this:      var pi = 3.14     pi = 100  Either on the next line, or in a function in the same module (assuming functions have read/write access to globals; in Python for example `pi` would need declaring as a global inside functions).",0.0,scheme
11uhq7c,jcop8tp,"Even with a module scheme with namespace control, that wouldn't stop `pi` being changed like this:      var pi = 3.14     pi = 100  Either on the next line, or in a function in the same module (assuming functions have read/write access to globals; in Python for example `pi` would need declaring as a global inside functions).",0.0,python
11uhq7c,jctxb92,"In C++, there's no distinction between file modules or folder modules, only namespaces, I recommend do not do this.",0.0,c++
11uhq7c,jctxb92,"In C++, namespaces are used by modules, but a file can contain several modules at the same level.",0.0,c++
11uhq7c,jctxb92,"// windows.hpp          namespace controls.windows     {     }           // buttons.hpp          namespace controls.buttons     {     }           // grids.hpp          namespace controls.grids     {     }       Or this:      // controls.hpp          namespace controls     {       namespace windows       {         // ...       }             namespace buttons        {         // ...       }             namespace grids       {         // ...       }           } // controls       In C++, you can use a previous declared same modular namespaces for new items.",-0.010101010101010102,c++
11uhq7c,jcosij2,"Kuroko's compiler supports a lot of Pythonic syntax for imports, such as `import foo.bar.baz` or `from a.b.c import d`, renamed imports with `as`, relative imports (`from ..foo import ...`), and so on, but the important part of all of these is that they compile to [at least one `OP_IMPORT` instruction](https://github.com/kuroko-lang/kuroko/blob/f09f62e4410addf131ebefa0970b297ca77522d7/src/compiler.c#L2407) that takes a module path as an operand.",0.02500000000000001,d
11uhq7c,jcosij2,"Otherwise, we search through an ordered list of module directories (which is available as a `list` in a built-in system module, as `kuroko.module_paths` - this is equivalent to Python's `sys.path`) and look for `{path}/{module}/__init__.krk`, `{path}/{module}.so`, and `{path}/{module}.krk` one by one, in each directory, until we find one.",0.4,python
11uhq7c,jcosij2,"For the `.so` case, we load the C extension module (using `dlopen`, or `LoadLibraryA` on Windows) and try to [run an exported initializer function](https://github.com/kuroko-lang/kuroko/blob/f09f62e4410addf131ebefa0970b297ca77522d7/src/vm.c#L1347) (which [is expected to return a module object itself](https://github.com/kuroko-lang/kuroko/blob/f09f62e4410addf131ebefa0970b297ca77522d7/src/vm.c#L1369)).",-0.1,c
11u6zgp,jcmonk6,"It sounds like you're talking about ""static"" in C#, which can be combined with accessibility modifiers like public/private/protected.",0.5,c
11u6zgp,jcvbakj,"The big names in OOP presently make no such overt distinction, but (a) it's your language, go nuts; and (b) chances are you want injected-dependencies to be strictly private (or maybe protected, if you go for that sort of thing) whereas for data attributes you probably want at least read access from outside.",-0.049999999999999996,go
11u6zgp,jcxknmh,"Here is an example:      interface Logger {       def warning(message: String): Unit     }      interface User {       def getName(): String     }      def main() = {        def logger = new Logger {         def warning(message) = { println(message) }       }        def user1 = new User {         def getName() = { ""Alice"" }       }        def user2 = new User {         def getName() = { logger.warning(""gotten name""); ""Bob"" }       }        println(user1.getName())       println(user2.getName())      }  We create two users where one of them logs every access to its name.",0.14393939393939392,alice
11u6zgp,jcxkuxh,"Oh cool, I will check so closer!",0.4375,cool
11u4dr1,jcqb121,The bulleted list says it's not a stackful coroutines so I am guessing it doesn't adjust the stack pointer how you could do it in assembly.,0.0,assembly
11u4dr1,jcqtwxz,"> explain more about the coroutines  AFAIK, they are very similar to generators of Python and JS.",0.25,python
11tu8ev,jcmg7wa,Cool bro,0.35,cool
11ttpcd,jcmv3qo,The problem with Lisp.,0.0,lisp
11ttpcd,jcm6sn7,"The biggest problem with Lisp is that it saw itself as an end goal, rather than merely an attempt.",-0.5,lisp
11ttpcd,jcm6sn7,Other languages have taken the good parts of Lisp while abandoning the bad.,-0.04166666666666663,lisp
11ttpcd,jclxns3,Modern FP languages are far superior to Lisp.,0.3333333333333333,lisp
11ttpcd,jcm5aa3,I have a theory about Lisp: it's all in the name.,0.0,lisp
11ttpcd,jcm5aa3,"Lisp is what people who consider themselves superior (or ""smug"", as one might say) use as intermediate language to communicate so that us, mere mortals, won't understand (because we get lost in the multitude of parens).",0.09999999999999998,lisp
11ttpcd,jcnl96s,I'd also add that Common Lisp's desire to be the last and final Lisp was a terrible dead end that crippled Lisp proper for a long time.,-0.22142857142857145,lisp
11ttpcd,jcpitkl,"Common Lisp is a multi paradigm language, not a functional one (though functional programming is one of those paradigms, along with good old imperative/structured and object oriented - especially the latter).",0.1,lisp
11ttpcd,jcpitkl,Scheme is a lisp that's embraced functional style.,0.0,scheme
11ttpcd,jcpitkl,Scheme is a lisp that's embraced functional style.,0.0,lisp
11ttpcd,jcpitkl,(And actually predates Common Lisp) if you're looking for that kind of beast.,0.09999999999999999,lisp
11ttpcd,jcm7sgx,What are the bad parts of lisp?,-0.6999999999999998,lisp
11ttpcd,jcnjg7w,"There used to be the ""search for an adequate Lisp"" to replace Common Lisp.",0.016666666666666663,lisp
11ttpcd,jcnjg7w,My feeling is Haskell was that replacement.,0.0,haskell
11ttpcd,jcnjg7w,"It plays the same intellectual role, Lisp used to.",0.15,lisp
11ttpcd,jcnjg7w,While the Haskell community invented (or mainstreamed) tons of ideas the core ideas of Haskell are all from Lisp.,0.0,haskell
11ttpcd,jcnjg7w,While the Haskell community invented (or mainstreamed) tons of ideas the core ideas of Haskell are all from Lisp.,0.0,lisp
11ttpcd,jcmtkaz,reversed lisp is literally factor and it's the closest thing we have to perfection,0.0,lisp
11ttpcd,jcnks5a,The biggest bad part of Lisp is that it is extremely difficult to optimize performance in terms of execution speed or memory usage.,-0.5999999999999999,lisp
11ttpcd,jcnks5a,And because of the way Lisp resolves itself often quite hard to figure out what to do about it.,-0.2916666666666667,lisp
11ttpcd,jcnks5a,In terms of performance the enormous chain of resolutions give Lisp it's conceptual power and also give Lisp the ability to run dog slow due to small changes.,-0.16875,lisp
11ttpcd,jcnks5a,But they broke a lot of Lisp's simplicity and elegance.,0.0,lisp
11ttpcd,jcnks5a,If more people had helped Mark out it is entirely possible that we could have had a modern Lisp which didn't have those gotchas.,0.2333333333333333,lisp
11ttpcd,jcnks5a,Clojure of course is also a serious player.,-0.3333333333333333,clojure
11ttpcd,jcmtg52,(lol (look (at (this))))      tbh i'm ok with lisp syntax but IMO that's what drives many people off.,0.6,lisp
11ttpcd,jcok3mg,"Much of Haskell is his type system, which does not come from Lisp in particular.",0.18333333333333335,haskell
11ttpcd,jcok3mg,"Much of Haskell is his type system, which does not come from Lisp in particular.",0.18333333333333335,lisp
11ttpcd,jcnt4hm,While I love Haskell it's definitely not 100% superior and there are somethings that it just can't do or at least can't do well e.g.,0.22499999999999998,haskell
11ttpcd,jcnt4hm,Does this mean Haskell is bad?,-0.5062499999999999,haskell
11ttpcd,jcodwri,"https://www.cs.nott.ac.uk/~pszgmh/fold.pdf  > The fold operator has its origins in recursion theory (Kleene, 1952), while the use of fold as a central concept in a programming language dates back to the reduction operator of APL (Iverson, 1962), and later to the insertion operator of FP (Backus, 1978).",0.0,apl
11ttpcd,jcodwri,"The notions of fold, cons, lambda calculus, etc, did not come from Lisp.",0.0,lisp
11ttpcd,jcodwri,This is not to take away the achievement in CS that Lisp represents but our understanding of computation has advanced much further than when Lisp came out.,0.2,lisp
11ttpcd,jcodwri,The fact that type theory can be much easily expressed in Haskell makes it a superior language.,0.5666666666666667,haskell
11ttpcd,jcorjoz,"The invention of type systems is clearly Fortran's modes to Algol's types, I'll grant that.",0.10000000000000002,fortran
11ttpcd,jcorjoz,"The invention of type systems is clearly Fortran's modes to Algol's types, I'll grant that.",0.10000000000000002,algol
11ttpcd,jcorjoz,But that type system is the limited kind we see in Algol based languages even today.,0.2642857142857143,algol
11ttpcd,jcorjoz,When we talk about the Haskell type system it needs to prevent segfault like the Algol ones and while also allowing for rich computational models.,0.375,haskell
11ttpcd,jcorjoz,When we talk about the Haskell type system it needs to prevent segfault like the Algol ones and while also allowing for rich computational models.,0.375,algol
11ttpcd,jcorjoz,Something like Haskell's type system IMHO comes out of James Morris 1968 work at MIT on allowing for a recursion enabling type system for dynamic programming (https://dspace.mit.edu/bitstream/handle/1721.1/64850/23882173-MIT.pdf?sequence=2&isAllowed=y).,0.0,haskell
11ttpcd,jcorjoz,Needless to say the Lisp community.,-0.5,lisp
11ttpcd,jcorjoz,And from there (with a few more steps) Haskell.,0.15,haskell
11ttpcd,jcorjoz,You have types in Common Lisp for objects and the interpreter does allow you to ask type related questions (describe).,-0.15,lisp
11ttpcd,jcorjoz,It wasn't allowed for variables  because Lisp was firmly in the dynamic not static camp.,-0.15,lisp
11ttpcd,jcorjoz,But it was optional and in more niche parts of the Lisp language.,0.5,lisp
11ttpcd,jcorjoz,(Lisp types for Haskell programmers: http://alhassy.com/TypedLisp),0.0,lisp
11ttpcd,jcorjoz,(Lisp types for Haskell programmers: http://alhassy.com/TypedLisp),0.0,haskell
11ttpcd,jcn5hyz,Lisp is fast and has very high expressiveness and a good environment.,0.36933333333333335,lisp
11ttpcd,jcn5hyz,I suppose C just took over with Unix due to better licensing than lisp machines had.,0.1875,c
11ttpcd,jcn5hyz,I suppose C just took over with Unix due to better licensing than lisp machines had.,0.1875,lisp
11ttpcd,jcn5hyz,"And now lisp is so ""foreign"" people are just biased.",-0.125,lisp
11ttpcd,jcp8dma,"I meant that its type system was not from the Lisp language, I agree that its community is close to / tied to ML-style functional programming.",0.0,lisp
11ttpcd,jcp8dma,"However, I wouldn't say that Haskell type system is invented in this kind of early contributions : even ML is now quite far away from all the subsequent features which are now essential to program with it.",0.15999999999999998,haskell
11ttpcd,jcqtv8v,"Type Classes, in particular, were very much a Haskell innovation.",0.21333333333333332,haskell
11ttpcd,jcqtv8v,"Also, the use of monads to allow expressing input/output in a pure functional language which I think was first pioneered in Haskell (I'm less certain of this though).",0.1279761904761905,haskell
11ttpcd,jcnl4v1,Today it isn't just familiarity bias...  modern CPUs (and I mean the last 30 years) are designed to run C fast.,0.021875000000000006,c
11ttpcd,jcnl4v1,Algol based languages were designed around Von Neumann architectures.,0.0,algol
11ttpcd,jcnl4v1,Odd that Python ended up owning so much of the space.,0.016666666666666677,python
11ttpcd,jcpd2rz,My point was that even for the type system Lisp was a critical component of the chain.,0.0,lisp
11ttpcd,jcpd2rz,Basically Haskell is really just an evolution of Lisp.,0.2,haskell
11ttpcd,jcpd2rz,Basically Haskell is really just an evolution of Lisp.,0.2,lisp
11ttpcd,jcrd2wy,Monads predate Haskell.,0.0,haskell
11ttpcd,jcrd2wy,The Gopher community (one of Haskell's direct parents) did the early work before there even was a Haskell.,0.1,haskell
11ttpcd,jcrd2wy,"I'd certainly consider Gopher to be part of the ""Haskell Community"" in a vague sense; the only reason anyone remembers anything from Gopher is because of Haskell.",-0.09523809523809523,haskell
11ttpcd,jcrd2wy,Haskell made monads popular rather than a nice computer science concept.,0.6,haskell
11ttpcd,jcrd2wy,The classic Num typeclass is a Haskell innovation.,0.16666666666666666,haskell
11ttpcd,jcrd2wy,That one Haskell gets deservedly.,0.0,haskell
11ttpcd,jcrxvft,"From my perspective, Type Classes are \*the\* big idea in Haskell.",0.0,haskell
11ttpcd,jcrxvft,One of things I love about Rust is that Traits are so obviously influenced by them - I'm at the point now where I almost find it painful programming without something like that.,-0.06666666666666665,rust
11ttpcd,jcs3hyf,It will feel like Haskell.,0.0,haskell
11ttpcd,jcs3hyf,Gofer was an attempt to implement most of the early Haskell report in a way that could run on an 8mhz 8086 processor with 640k.,0.3,haskell
11tt0jv,,Its like the Java Meta Model and the JVM in one.,0.0,java
11tt0jv,,"&#x200B;  # The Marble Revolution and how to experience it first-hand  In the exercise book, we came to now the age in  which Geppetto and Pinocchio discover  the power of marbles, how does it  go from there?",0.0,go
11tt0jv,jcm50ho,"No, jokes aside :D Actually, I had the idea when seeing a game on someone's phone, in which you had to solve puzzles with kind-of circulating visual elements.",0.15,d
11tt0jv,jcm50ho,I also really like Minecraft :D,0.6,d
11tt0jv,jcnyefr,"Ok, maybe it didn't search for it that long :D Still a fascinating game",0.35,d
11tsjq6,,"ago, there was a discussion here about using Forth as an intermediate language.",0.0,forth
11tsjq6,,"Unfortunately, I cannot find it right now :/  So, more generally, just as C is sometimes used as an intermediate language, what are the arguments (or counter-arguments) for using Forth as an intermediate language?",0.017142857142857144,c
11tsjq6,,"Unfortunately, I cannot find it right now :/  So, more generally, just as C is sometimes used as an intermediate language, what are the arguments (or counter-arguments) for using Forth as an intermediate language?",0.017142857142857144,forth
11tsjq6,,"Personally, I would be happy even with pointers to articles or concepts that demonstrate either a pro or con to using Forth for this purpose....but a bit of description around just posting a URL is always welcome :)  I have to say, I have made some very simple translations in terms of mapping basic language constructs (e.g.",0.35000000000000003,forth
11tsjq6,,"The thing is that Forth can run on anything....so using it as an intermediate language would make the re-use of existing, robust, debugged code (but written in another language), very easy to re-use in all sorts of targets.",0.5633333333333334,forth
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,c
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,pascal
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,java
11tsjq6,,"If a language like C, Pascal or Java was to be compiled down to Forth, would it lose anything?",-0.15555555555555559,forth
11tsjq6,jckkq96,I think Forth would make a good stack vm.,0.7,forth
11tsjq6,jclcpdm,"While many people think of FORTH as “the stack language”, I think it’s better to think of it as a low level language with a clever implementation of “macros” by exposing the currently parsed line as a runtime object, and allowing switching between compilation and execution states at will.",0.23333333333333334,forth
11tsjq6,jclcpdm,"That also means that generating FORTH programmatically is a silly idea, since you aren’t really taking advantage of its benefits, and are limited by the tremendous downside: you can only access the top of the stack.",0.07698412698412697,forth
11tsjq6,jcknqik,"Ooh, this question is a bit of a curveball, cool!",0.4375,cool
11tsjq6,jcknqik,"IIRC, FORTH's self-modifying capabilities may make it a thoroughly versatile and interesting one to use for an intermediary...",0.5,forth
11tsjq6,jclugh3,One of the guys in #ada is using forth in this way to bootstrap an Ada compiler.,0.0,ada
11tsjq6,jclugh3,One of the guys in #ada is using forth in this way to bootstrap an Ada compiler.,0.0,forth
11tsjq6,jclugh3,He says bootstrapping a forth interprets is easy and doesn’t take much work.,0.31666666666666665,forth
11tsjq6,jclafzk,You can think about it as a functional forth + lisp.,0.0,forth
11tsjq6,jclafzk,You can think about it as a functional forth + lisp.,0.0,lisp
11tsjq6,jcnbccv,"In the CLox section of *Crafting Interpreters*, the bytecode generated consists *mostly* of instructions that look suspiciously like Forth.",0.5,forth
11tsjq6,jcnbccv,"However, if you're compiling from a language that isn't strictly stack-based, I think you'll find the adherence to stack-oriented programming in Forth limiting.",0.0,forth
11tsjq6,jcnbccv,This is reflected in CLox where a minority of the instructions in the bytecode are ones that *aren't* in Forth.,0.0,forth
11tsjq6,jcmav32,"J or APL as targets have the same robustness and simple parsing benefits, if you were starting from something like numpy or other array centered code.",-0.03125,apl
11tsjq6,jckw6qw,"This is a terrible idea; Forth is the worst [kind of stack (or other) machine](https://www.reddit.com/r/ProgrammingLanguages/comments/up206c/stack_machines_for_compilers/i8ikupw/) since it is prone to desynchronization, and even if you avoid that it requires non-constant indices to access local variables.",-0.305,forth
11tsjq6,jco20cj,I had a crush on Forth and wanted it to be more useful.,0.4,forth
11tsjq6,jcumei4,FORTH is its own intermediate language.,0.6,forth
11tsjq6,jcumei4,"As presented in, say, Starting Forth or Thinking Forth, the main features you'll miss as a translation target for any other language is a base-pointer for an activation record and a static pointer for finding lexically-enclosed activation records.",0.13541666666666666,forth
11tsjq6,jcumei4,"On the other hand, the separate return and data stacks mean that FORTH can yield super compressed code, possibly on a level difficult to achieve with native code.",-0.12083333333333335,forth
11tsjq6,jcumei4,"Thus, something LLVM is fine, but something like FORTH is rather too powerful.",0.35833333333333334,forth
11tsjq6,jcumei4,"If your source language is agglutinative like FORTH is, then perhaps ... RECUR!",0.0,forth
11tsjq6,jcmkyl2,"Forth is an *idea*, like Scheme.",0.0,forth
11tsjq6,jcmkyl2,"Forth is an *idea*, like Scheme.",0.0,scheme
11tsjq6,jcmkyl2,it isn't a platform like Java.,0.0,java
11tsjq6,jclm4f2,"Forth is incredibly small, you usually ""take the compiler with you"" and yes it is possible to generate binaries.",-0.16666666666666666,forth
11tsjq6,jclm4f2,"As far as speed is concerned, Forth can generate high quality code.",0.13,forth
11tsjq6,jclm4f2,"More recent Forth's also have libraries for GUis, opengl, etc.",0.25,forth
11tsjq6,jclm4f2,"You don't have to bundle anything, your compiler could generate Forth and that code would be used to generate the final program in any reasonably up to date Forth compiler.",0.1,forth
11tsjq6,jclm4f2,"As far as the stack frame comment is concerned, think of Forth like ASM.",0.1,forth
11tsjq6,jclm4f2,"It is the same in Forth, you just push values on the stack and CALL a function.",0.0,forth
11tsjq6,jclm4f2,"I suppose that if you were compiling from a higher level language to generate an ""equivalent"" as it would be expected in other languages, you would have to create a stack frame data structure within Forth.",0.008333333333333331,forth
11tsjq6,jcoeh34,"Since then, ANS Forth was invented.",0.0,forth
11tsjq6,jcomqab,(How can one not have a crush on Forth?),0.0,forth
11tsjq6,jcon7b0,Forth can do recursive calls.,0.0,forth
11tsjq6,jcon7b0,My comment about recursion was with regards to compiling a higher level language like C and whether the stack frame would have to be preserved exactly as it is or could even be improved.,0.25,c
11tsjq6,jcv1zm7,"I alluded to the stack frame difficulties and was wondering if there has been a way to go around it, perhaps using RECURSE too, that may have been known by more seasoned Forth programmers.",0.375,go
11tsjq6,jcv1zm7,"I alluded to the stack frame difficulties and was wondering if there has been a way to go around it, perhaps using RECURSE too, that may have been known by more seasoned Forth programmers.",0.375,forth
11tsjq6,jcx3g6n,Here ya go.,0.0,go
11tsjq6,jcm8795,Even forth compilers use different intermediate formats and forths are not standardized.,0.0,forth
11tsjq6,jcm8795,"If you want to compile to an existing ""language"" use C or LLVM tbh.",0.0,c
11tsjq6,jcq2wj9,"There is [ANS/ISO Forth ""94""](http://www.forth.org/svfig/Win32Forth/DPANS94.txt) and the ongoing draft [Forth ""2012""](https://forth-standard.org/standard/words).",0.0,forth
11tsjq6,jcq2wj9,"Even those are predated by [Forth 79](https://www.complang.tuwien.ac.at/forth/fth79std/FORTH-79.TXT) and [Forth 83](https://www.complang.tuwien.ac.at/forth/fth83std/FORTH83.TXT) from the Forth Standards Team, though both of those have been made practically obsolete due to hard-wired assumptions like that of the address space being less or equal to 2^16 8-bit bytes.",-0.09722222222222221,forth
11tncp0,jcjwtmw,"But this is easy to fix: once you encounter an unrecoverable error, go back and check if any other unrecoverable error preceded it in program order, and if so, report that instead.",0.10277777777777779,go
11tncp0,jcjwtmw,"Here's one idea, although things are starting to get really ugly: if a loop runs for too many iterations, go back and check the potential sources of error that precede it in program order.)",-0.039999999999999994,go
11ti9sc,,You can’t go a week without seeing a post here where someone wants a language with X only to find that X is already solved by algebraic effects.,0.1,go
11ti9sc,jcjt14c,Compare compile errors from Java generics with C++ templates.,0.0,java
11ti9sc,jcjt14c,Compare compile errors from Java generics with C++ templates.,0.0,c++
11ti9sc,jcjt14c,"There's a reason why Elm has neither type classes nor higher kinded types: you don't really need them for frontend code, and the error messages and tooling are amazingly pleasant to work with.",0.39444444444444443,elm
11ti9sc,jcjzi5u,"Because of how different it is, if a language don't have the correct foundation it won't be used at all and will just become a distraction (think about how to combine 2 libraries, one uses Effects and the other Monads)   I recently talked a bit in the OpenJDK, project Amber, mailing list about enhancing Java's checked exceptions.",-0.041666666666666664,java
11ti9sc,jcjzi5u,"Java's checked exceptions is the closest thing we have in the mainstream languages, I claimed that *specifically in Java*, having a stronger checked exceptions system (which turns out to requires to have a stronger generic system) is the better solution than Monads, specifically because it is already integrated in Java, and making the exception system easier to use and enhancing its power will actually unify more libraries rather than leaving it as is, or focusing on Monadic type system.",0.25,java
11ti9sc,jcjzi5u,"(Currently the OpenJDK has a lot of different stuff on their hands, but when the conversation about this will open up, I hope I'll convince enough people there to actually go with my idea)",0.0,go
11ti9sc,jcja9vu,"In the Haskell case, I'm under the impression that:  - Nobody has fully solved the performance hit of effects over monad transformers (but maybe Eff does now?)",0.0,haskell
11ti9sc,jf64dgt,**Multiple resumptions and linear resources**  Could this be solved with Rust style ownership semantics?,0.0,rust
11ti9sc,jf64dgt,"If the continuation is of type `A -> B` in Rust it would be represented as some type which implements `Fn(A) -> B`, `FnMut(A) -> B`, or `FnOnce(A) -> B`.",0.0,rust
11ti9sc,jd13lj8,> Compare compile errors from Java generics with C++ templates.,0.0,java
11ti9sc,jd13lj8,> Compare compile errors from Java generics with C++ templates.,0.0,c++
11ti9sc,jdhozxf,"This allows distinguishing multiple instances of the same kind of effects:  - Idris - [Labelled Effects](https://docs.idris-lang.org/en/latest/effects/state.html#labelled-effects)  - Helium - [Effect Instances](https://bitbucket.org/pl-uwr/helium/wiki/popl20/Tutorial_Instances)   Also, in my library of algebraic effects for Scala, effects are always [uniquely labelled](https://marcinzh.github.io/turbolift/advanced/labelled.html).",0.24375,scala
11ti9sc,jck2pty,"> [..]  I claimed that specifically in Java, having a stronger checked exceptions system (which turns out to requires to have a stronger generic system) is the better solution than Monads [..]  That may well be the case for Java.",0.25,java
11ti9sc,jck2pty,"My personal opinion about checked exceptions in Java is that the main problem is that the effect system lacks polymorphism (this may be what you mean by ""stronger generic system""), which makes effectful code anti-modular and anti-composable.",-0.036458333333333336,java
11ti9sc,jcjp8ss,I'm not sure if these really qualify as problems with effects from a PL-design perspective since they're both so Haskell specific.,-0.016666666666666663,haskell
11ti9sc,jd15ump,"What I mean: templates are much more abstract than Java generics, in that they are much less specific and much less constrained.",-0.029166666666666664,java
11ti9sc,jclxbi1,I don't think coercions are a good solution because they feel like row-level (stack-of-handlers-level) FORTH to me.,0.7,forth
11ti9sc,jcm3l2v,"Yeah, sometimes it seems like everyone except me (and the Elm people I guess) who's writing a functional language is doing it to prove a point I don't understand.",0.0,elm
11ti9sc,jcmjbyn,"Totally agree about checked exceptions in Java, with the addition that there are a number of usability issues such as syntax overhead at the use site and high cost of defining new exception types.",0.0740909090909091,java
11ti9sc,jcqp093,">  Delphi,..., FoxPro,   These are(were) legitimately powerful tools.",0.3,delphi
11ti9sc,jclfvwl,"To get full Koka-style *extensible* effects, you need a bit more, but not much (Koka has a notion of row polymorphism), and if your type system is powerful enough, you can even express this through other features like type classes (as in Haskell).",0.15416666666666667,haskell
11ti9sc,jclsaco,Typed delimited continuations are (as far as I'm aware) usually implemented like [ContT](https://hackage.haskell.org/package/transformers-0.6.1.0/docs/Control-Monad-Trans-Cont.html#t:ContT) in Haskell.,0.033333333333333326,haskell
11ti9sc,jclsaco,"newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }  Here, `r` is an answer type, which means it is the type of the entire resulting computation up to the nearest prompt tag.",-0.375,r
11thzs6,jcj65e9,"I think a lot of people in this sub are annoyed by shell (or just plain hate it), AND also have the skills to contribute to Oil.",-0.4714285714285715,shell
11thzs6,jcj65e9,"As far as I can see, Oil is the only path out of the 8th most used language on Github, and 6th fast growing language of 2022   :)  https://octoverse.github.com/2022/top-programming-languages  We're converging on a fast, compatible shell in pure C++!",0.25255102040816324,shell
11thzs6,jcj65e9,"As far as I can see, Oil is the only path out of the 8th most used language on Github, and 6th fast growing language of 2022   :)  https://octoverse.github.com/2022/top-programming-languages  We're converging on a fast, compatible shell in pure C++!",0.25255102040816324,c++
11thzs6,jcj65e9,Garbage-collected C++ is actually kind of fun -- it makes you realize how much of the language has to do with   book-keeping of memory.,0.36666666666666664,c++
11thzs6,jcmclt6,"Can you say something about how it is largely Bash compatible and also  >Oil is a brand new shell language with Python-like expressions on typed data, Ruby-like blocks, and more.",0.28354978354978355,bash
11thzs6,jcmclt6,"Can you say something about how it is largely Bash compatible and also  >Oil is a brand new shell language with Python-like expressions on typed data, Ruby-like blocks, and more.",0.28354978354978355,shell
11thzs6,jcmclt6,That doesn't sound like Bash at all.,0.4,bash
11thzs6,jcmclt6,Can I run Bash scripts with minimal changes?,-0.1,bash
11thzs6,jcn4i70,"Yes, you can run bash scripts with minimal changes!",-0.125,bash
11thzs6,jcn4i70,It has run thousand lines unmodified bash scripts for years.,0.0,bash
11thzs6,jcn4i70,"This page helped a couple people understand how they relate:  https://github.com/oilshell/oil/wiki/OSH-versus-Oil  Specifically the parts about shell options, and how you upgrade.",0.0,shell
11tajru,jcj4au4,"In any case, Rust is decently mature now.",0.1,rust
11tajru,jckct7g,"I don't know Rust but I do know C++, I assume the definition of ""move"" here is the same as that of _move semantics_ as used in C++..?",0.0,rust
11tajru,jckct7g,"I don't know Rust but I do know C++, I assume the definition of ""move"" here is the same as that of _move semantics_ as used in C++..?",0.0,c++
11tajru,jck7cty,"In rust, all heap memory is managed by some object, so you could make `Box<T>: !Drop where T: !Drop` to statically ensure it keeps the must-move type alive.",0.1,rust
11tajru,jckitwg,"The concept is the same, but the way it's implemented is very different  In Rust, move semantics are the default and built into the language, so if you write `let a = b;` then the value of `b` is moved into `a` and you are no longer allowed to access `b`.",0.0,rust
11tajru,jcmjcmd,* Rust only has destructive moves.,-0.3,rust
11tajru,jcmjcmd,"* C++ only has non-destructive moves, and allows them to be customized (but also has type traits to detect when they're not, which is often used to *emulate* destructive moves for efficiency).",-0.3,c++
11tajru,jckmqqs,"I see, so to get an actual copy, one has to explicitly invoke it, a bit like `deepCopy()` in JavaScript..?",0.0,javascript
11ta0eh,jci32u0,I’m not at the point where I’d advocate for a blanket ban yet though.,0.0,d
11ta0eh,jci6o3e,I would be happy to see them go.,0.8,go
11ta0eh,jci1omy,"Yeah, I’d happily see these types of posts banned.",0.8,d
11ta0eh,jcq90kw,Normally I'd use a batch-compiled statically typed language but all of my favorite such languages have committed suicide at this point so I thought I'd give it a go using Javascript instead.,0.21666666666666667,go
11ta0eh,jcq90kw,Normally I'd use a batch-compiled statically typed language but all of my favorite such languages have committed suicide at this point so I thought I'd give it a go using Javascript instead.,0.21666666666666667,javascript
11ta0eh,jcq90kw,Except I don't know JS so I thought I'd give ChatGPT a go.,0.0,go
11ta0eh,je0uchd,Playing with ChatGPT I find it gives awesome code for Javascript and Python programming but mostly-non-working code for languages like OCaml and terrible code for languages like MMA.,0.0,javascript
11ta0eh,je0uchd,Playing with ChatGPT I find it gives awesome code for Javascript and Python programming but mostly-non-working code for languages like OCaml and terrible code for languages like MMA.,0.0,python
11t057s,jch893k,"But (I don't know Rust well) in that case, I'd want something that integrates nicely into functional Result-type-based error handling (Try/Success/Failure), as opposed to just abruptly panic-ing, which Rust's `assert` appears to do.",0.2375,rust
11t057s,jcj829k,"of fine-grained static types for the AST, and they have templates List<T> and C++ namespaces, so that that single assert() took up hundreds of kilobytes of data space in the executable  The solution was to change it do DCHECK(), so it only expands in debug builds, not release builds",0.14285714285714288,c++
11t057s,jcjloe1,I wish that the rust community would stop believing that panicing upon encountering incorrectness makes a program correct.,0.0,rust
11t057s,jchdi1e,"The closer equivalent to guards (like Swift) is `let ... else`, which is a really nice and not that well known feature.",0.6,swift
11sz6jr,,"For example: in my new language I'm designing, I want to use public and private labels very similar to what C++ does in its declaration of classes.",0.03409090909090909,c++
11sz6jr,jcge88h,"the C++ standard) can be copyrighted, meaning that you cannot verbatim reproduce the document in part or in whole, but you can e.g.",0.1,c++
11sz6jr,jcgkm96,"The C language family contains many languages such as ISO C, C++, and Objective-C.",0.25,c
11sz6jr,jcgkm96,"The C language family contains many languages such as ISO C, C++, and Objective-C.",0.25,c++
11sz6jr,jcgkm96,"The C language family contains many languages such as ISO C, C++, and Objective-C.",0.25,objective-c
11sz6jr,jcgkm96,"While ISO C++ provides a standard, compilers differ a bit in which features of the standard are supported, and many have non-standard language extensions (e.g.",0.16666666666666666,c++
11sz6jr,jcgkm96,GNU C++).,0.0,c++
11sz6jr,jcgkm96,"While Clang, GCC, Intel, and Microsoft probably bought a copy of the ISO C++ standard document, they didn't “license” the language in any meaningful way.",0.25,c++
11sz6jr,jcgkm96,Oracle controls Java.,0.0,java
11sz6jr,jcgkm96,"However, all that Oracle actually owns is the trademark for the *name* “Java”, and copyright in the reference implementation.",0.0,java
11sz6jr,jcgkm96,"But that reference implementation (OpenJDK) is now GPL-licensed, so you're perfectly allowed to modify it in any way you like (as long as you don't market your dialect as “Java”).",0.475,java
11sz6jr,jcgkm96,"That language is now C#, and its early versions were *heavily* inspired by Java – the syntax and semantics are mostly identical, just with a different standard library and a different naming convention.",0.06666666666666667,c
11sz6jr,jcgkm96,"That language is now C#, and its early versions were *heavily* inspired by Java – the syntax and semantics are mostly identical, just with a different standard library and a different naming convention.",0.06666666666666667,java
11sz6jr,jcgqzdm,"Oh, wait, Perl....",0.0,perl
11sz6jr,jcgf4ia,"If however, you made a C++ clone and tried to monetize that, then yeah you'd get a call from a lawyer.",0.0,c++
11sz6jr,jch0328,"Since the holder of C++ is Danish, C++' grammar does not have a license (meaning the authors retain all copyright) and Danish law includes copyright on keywords, it's not straightforward.",-0.1875,c++
11sz6jr,jch0328,"And I don't think Bjarne or the C++ committee would be ever suing you, seeing as how such syntax is not characteristic to the language and might even be fair use.",0.24444444444444444,c++
11sz6jr,jchlak0,"Borland sued Microsoft for some copyright about Delphi syntax, decades ago.",0.0,delphi
11sz6jr,jchlak0,Sun sued Microsoft about Microsoft J that didn't match Java syntax.,0.0,java
11sz6jr,jcgpg9l,"(Like C# and Java, for one severe example of similarities across multiple various levels.)",0.0,c
11sz6jr,jcgpg9l,"(Like C# and Java, for one severe example of similarities across multiple various levels.)",0.0,java
11sz6jr,jchtohr,Give them half a chance and they’d copyright thoughts so you couldn’t have any without paying your monthly thought licence.,-0.16666666666666666,d
11sz6jr,jchfgyy,"Java class-style enums are patented (expires soon), which is a big part of why C# hasn't adopted them (unclear if Oracle would actually go after them, though given their history with Google I imagine MS' lawyers didn't want to chance it).",0.0,java
11sz6jr,jchfgyy,"Java class-style enums are patented (expires soon), which is a big part of why C# hasn't adopted them (unclear if Oracle would actually go after them, though given their history with Google I imagine MS' lawyers didn't want to chance it).",0.0,c
11sz6jr,jchfgyy,"Java class-style enums are patented (expires soon), which is a big part of why C# hasn't adopted them (unclear if Oracle would actually go after them, though given their history with Google I imagine MS' lawyers didn't want to chance it).",0.0,go
11sz6jr,jcgo6fj,google v oracle ruled that google's use of the java api (developed by sun and owned by oracle) in google's android operating system was fair use.,0.39999999999999997,java
11sz6jr,jchav0a,But so many other languages use the same keywords as C++.,0.125,c++
11sz6jr,jchav0a,"Like for my example, Java scopes accessibility of identifiers using the same keywords of public and private on an individual basis, rather than in groups following a label.",0.0,java
11sz6jr,jchav0a,Plus in my case it wouldn't be exactly C++'s syntax.,0.25,c++
11sz6jr,jcuadtw,"As long as you don't call your language Java, C#, or Go, you'll probably be just fine.",0.18333333333333335,java
11sz6jr,jcuadtw,"As long as you don't call your language Java, C#, or Go, you'll probably be just fine.",0.18333333333333335,c
11sz6jr,jcuadtw,"As long as you don't call your language Java, C#, or Go, you'll probably be just fine.",0.18333333333333335,go
11sz6jr,jcuadtw,C# and Java are pretty much isomorphic and both have litigious corporations pushing them.,0.225,c
11sz6jr,jcuadtw,C# and Java are pretty much isomorphic and both have litigious corporations pushing them.,0.225,java
11sz6jr,jcuadtw,"The harshest that got was Oracle telling MS not to say ""Java"" when describing ""Visual J++"".",0.0,java
11sz6jr,jchctvu,"Firstly, people who make successful languages are usually pretty capable and at least somewhat smart, so they do not go out of their way to incriminate themselves by providing statements of (possibly) infringing on someone's copyright.",0.19489795918367345,go
11sz6jr,jchctvu,"Look at the shenanigans that Oracle tried to pull on Google regarding Java, and they failed.",-0.5,java
11sz6jr,jchctvu,> Plus in my case it wouldn't be exactly C++'s syntax.,0.25,c++
11sz6jr,jcioi52,"So, unless you're saying people copied C style features from ada lovelace and Charles Baggage, US copyright lasts that long.",-0.05,c
11sz6jr,jcioi52,"So, unless you're saying people copied C style features from ada lovelace and Charles Baggage, US copyright lasts that long.",-0.05,ada
11sz6jr,jchezn5,"I said that you would technically be infringing copyright, but that if you stopped talking there would be no legal way even an enraged Bjarne would go after you and manage to win the lawsuit.",0.23333333333333336,go
11sqf4f,,"(+3))(1) = 6  	# Like “it” in Kotlin 	{ f(x, y, z) } ≡ { x, y, z -> f(x, y, z) }",0.0,kotlin
11sqf4f,jcgiyfb,"    # Like “it” in Kotlin     { f(x, y, z) } ≡ { x, y, z -> f(x, y, z) }  I'm not a fan of this at all.",0.0,kotlin
11sqf4f,jcgiyfb,"The meaning of `{ f(x, y, z) }` depends on whether variables called `x`, `y`, or `z` are defined anywhere in the parent scope (which is not that unlikely, compared to Kotlin's `it`).",-0.5,kotlin
11sqf4f,jcgiyfb,"If they're not, then that function type syntax is extremely misleading and confusing, especially since `A -> B -> C` and `A -> (B -> C)` presumably mean different things?.",-0.14750000000000002,c
11sqf4f,jcgiyfb,"replace(old, new) = map     {         old -> new,         any -> any     }  I guess this means the same as (in Haskell)?",0.09318181818181817,haskell
11sqf4f,jcvkb75,"I think having special names (like kotlin's `it`, or Swift's `$0, $1, ...`) would be better than implicit parameters w/any names",0.4285714285714286,kotlin
11sqf4f,jcvkb75,"I think having special names (like kotlin's `it`, or Swift's `$0, $1, ...`) would be better than implicit parameters w/any names",0.4285714285714286,swift
11sqf4f,jcfafin,"`x`, `y`, `z` are implicit lambda parameter names, like [`it` in Kotlin](https://kotlinlang.org/docs/lambdas.html#it-implicit-name-of-a-single-parameter).",0.0,kotlin
11sqf4f,jcgwyjr,"The meaning of { f(x, y, z) } depends on whether variables called x, y, or z are defined anywhere in the parent scope (which is not that unlikely, compared to Kotlin's it).",-0.5,kotlin
11sqf4f,jcgwyjr,"They’re partially applied from the end:      f: a -> b -> c -> d     x: a     y: b     z: c     f(y, z): a -> d     f(x, y, z): d     x.f(y, z): d     x.f(z): b -> d  I couldn’t find a better way to combine the pointfree style with iterator chaining (and method chaining in general).",0.19999999999999998,c
11sqf4f,jcgwyjr,"They’re partially applied from the end:      f: a -> b -> c -> d     x: a     y: b     z: c     f(y, z): a -> d     f(x, y, z): d     x.f(y, z): d     x.f(z): b -> d  I couldn’t find a better way to combine the pointfree style with iterator chaining (and method chaining in general).",0.19999999999999998,d
11sqf4f,jcgwyjr,"I love Haskell, but there are a few things about its syntax that I think are unnecessarily exotic:  1.",0.26666666666666666,haskell
11sqf4f,jcgwyjr,"`map g $ filter f xs` goes in the opposite direction from the data flow and also conflicts with the traditional monad direction (`(>>=)` is used much more often than `(=<<)`); I also absolutely love the way method chaining looks:  ``` fibs: Sequence(Int) fibs = (0, 1)     .iterate { (a, b) -> (b, a + b) }     .map(first) ```  > If they're not, then that function type syntax is extremely misleading and confusing, especially since `A -> B -> C` and `A -> (B -> C)` presumably mean different things?",0.0011363636363636374,c
11sqf4f,jcgwyjr,I do have an alternative syntax:  > I guess this means the same as (in Haskell)?,0.25,haskell
11sqf4f,jcj95c2,"What really is the point of putting brackets around the parameter list, unless the function can have a variable number of parameters, like C's `printf()`?",0.2,c
11sqf4f,jcfcrft,"The 6th one is the same as [`it` in Kotlin](https://kotlinlang.org/docs/lambdas.html#it-implicit-name-of-a-single-parameter), implicit lambda parameter names, but 1–3 instead of just one.",0.0,kotlin
11sqf4f,jcfed7j,Python and list comprehension won out in the end.,0.0,python
11sqf4f,jcfje1v,Just like in Rust and Haskell.,0.0,rust
11sqf4f,jcfje1v,Just like in Rust and Haskell.,0.0,haskell
11sqf4f,jcfje1v,Python and list comprehension won out in the end.,0.0,python
11sqf4f,jcfje1v,"Python still has `map`, `filter` etc., they just don’t compose well (you have to write `map(g, filter(f, xs))` or create temporary variables) and aren’t considered pythonic (because Guido has no idea what good code is).",0.7,python
11sqf4f,jcfje1v,"List comprehensions are the opposite of expressive code, as is Python in general.",0.2833333333333334,python
11sqf4f,jckc4y2,> Just like in Rust and Haskell.,0.0,rust
11sqf4f,jckc4y2,> Just like in Rust and Haskell.,0.0,haskell
11sqf4f,jckc4y2,"Here is a non redundant one:      x = filter(x, f)     x = map(x, g)  Here is a cleaner, and actually more expressive one (unrelated to function call syntax):      x = g(y) for y in x if f(x)  > Python still has `map`, `filter` etc.",0.3666666666666667,python
11sqf4f,jckc4y2,"Guido wanted them removed from Python 3 but ultimately they had to stay, and a lot of people nowadays want lambdas removed.",0.0,python
11sqf4f,jckc4y2,"Know that if lambdas get removed, presumably in Python 4 alongside the GIL, if it ever happens, `map` and `filter` will go too.",0.0,python
11sqf4f,jckc4y2,"Know that if lambdas get removed, presumably in Python 4 alongside the GIL, if it ever happens, `map` and `filter` will go too.",0.0,go
11sqf4f,jckc4y2,"I would say he has a pretty good idea of what good code is, but I would argue he was less wise 30 years ago when `map` and `filter` were getting added to Python 1.0.",0.43666666666666665,python
11sqf4f,jckc4y2,It was a Lisp programmer.,0.0,lisp
11sqf4f,jckc4y2,"Given that Lisp a severely non-Pythonic language in terms of syntax, it figures that those additions would ultimately be bad for the language.",-0.6999999999999998,lisp
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,python
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,rust
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,haskell
11sqf4f,jckkxqy,"Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,d
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,python
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,rust
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,haskell
11sqf4f,jcko0gv,"> Maybe I could explain to you why I think my approach is better, but if you seriously believe Python is more expressive than Rust and Haskell (or that it’s well-designed in any way at all), I’d have to start with the basics and spend hours on it.",0.3666666666666667,d
11sqf4f,jcko0gv,"I said that Python's list comprehension represents a more expressive way of representing filter and map, which seems to be the consensus.",0.65,python
11sqf4f,jcko0gv,"I also said that imitating Rust's and Haskell's syntax is not something to be proud of given that their syntax is widely regarded as ugly, complicated or not readable.",-0.12499999999999997,rust
11sqf4f,jcko0gv,"I also said that imitating Rust's and Haskell's syntax is not something to be proud of given that their syntax is widely regarded as ugly, complicated or not readable.",-0.12499999999999997,haskell
11sqf4f,jcko0gv,"For these two things, those who counter the consensus are usually found within the bubble that's being criticised - in this case, these would be the FP and Rust cultist bubbles.",-0.25,rust
11sqf4f,jckvk6a,"> I said that Python's list comprehension represents a more expressive way of representing filter and map, which seems to be the consensus.",0.65,python
11sqf4f,jckvk6a,"Yes, among Python developers.",0.0,python
11sqf4f,jckvk6a,More Python developers?,0.5,python
11sqf4f,jckvk6a,"> these would be the FP and Rust cultist bubbles  Yes, exactly, because people outside those bubbles (and also the Kotlin one) don’t know a thing about expressive code.",0.35000000000000003,rust
11sqf4f,jckvk6a,"> these would be the FP and Rust cultist bubbles  Yes, exactly, because people outside those bubbles (and also the Kotlin one) don’t know a thing about expressive code.",0.35000000000000003,kotlin
11s1nmn,jchkpnh,"You don't push everything then execute (doing so might be a way to write a bytecode program), you work it out as you go; here the top is at the right; push `1` then `2` to get:      1 2  Then call `add` to get:      3  Then call `neg` to get:      -3  No need to push those operations first then apply them.",0.3839285714285714,go
11s1nmn,jcjdfxm,"Compose in Python with those semantics would be approximately:      def compose(f,g):         def h(*args, **kwargs):             return f(g(*args, **kwargs))         return h  The point being that the resulting function has the same signature as the rightmost argument of the *compose* operator, and all the functions to the left presumably take a single argument.",-0.11785714285714285,python
11s1nmn,jcww1dq,"Using D' quasiquoting `mixin`:      paramCount: type -> UInt     paramCount (a -> b) = 1 + paramCount b     paramCount a = 0          unpack f =         let xs = map (\x -> ""_"" ++ toString x) 0..<(paramCount $ typeof f) in         mixin $ ""\("" ++ join "","" xs ++ "") -> f "" ++ join "" "" xs  Use:      (neg .",-0.75,d
11s1nmn,jcd1lnv,Tbh an even better way would be make it stack based and basically reinvent forth.,0.5,forth
11rvqne,jccwp03,I'm curious since both languages are based on Elm.,-0.1,elm
11rmek1,,"What I basically want to know is: given the multiple dispatch, is that a *known* reason to go for some specific kind of VM --- perhaps one I've never heard of?",0.19999999999999998,go
11rmek1,,"\---  ETA: I forgot to say, but if one of you has already written, or knows of, a VM in Go that you think would serve the purpose, then I'm not doing this as a learning experience but to make my lang go faster --- so please point it out.",0.0,go
11rmek1,jc9kjgq,"If memory serves, some of the LISP OO systems do dispatch in the language itself.",0.0,lisp
11rmek1,jc9kjgq,And certainly there are multiple-dispatch libraries for Python.,0.21428571428571427,python
11rmek1,jc9sgzz,args_types could be hash of types like crc32 or a string similar to c++ mangling.,0.0,c++
11rmek1,jc9sgzz,"And you would be able to run your code from a browser, which is super cool!",0.4236111111111111,cool
11rmek1,jcdlyvf,"That said, runtime operator overloading is actually simpler than the general case due to the types usually being ""the same"", which is how Python manages to have something that works pretty well using the ""check derived and call the reversed method first if necessary"" thing.",0.021875000000000006,python
11rmek1,jcb5rn5,I suggest to look into Julia for ideas about the quote “wacky semantics of multiple Dispatch”,0.25,julia
11rmek1,jc9h2zm,I've gotten this far with the project on the basis of (a) I can learn anything (b) people are helpful (c) all relevant knowledge is somewhere on the internet.,0.25,c
11rmek1,jca3bf5,But my languages are imperative:      while a do b:=c end  trivially translates into this stack VM:       ------jump      L10     L6:      ------pushm     c      ------popm      b     L10:      ------pushm     a      ------jumptrue  L6  I understand that `while` in Charm is implemented very differently.,0.0,c
11rmek1,jcai5am,"In order to answer your original question, does your VM have high level bytecode instructions like Java with objects ?",0.2675,java
11rmek1,jca0ybb,"I can imagine it as   ``` x.func(a, b, c) the same as x_func(x, a, b, c) ``` So the first argument decides the call.",0.125,c
11rb6yr,jc84t4b,Cool work!,0.4375,cool
11qm30i,jc4r6j0,"In C / C++, a ""+"" and a ""="" are considered single tokens, but a ""+="" combination is also considered a single token.",-0.07142857142857142,c
11qm30i,jc4r6j0,"In C / C++, a ""+"" and a ""="" are considered single tokens, but a ""+="" combination is also considered a single token.",-0.07142857142857142,c++
11qm30i,jc9qwmv,"For example a line like `a = b + c` might make no sense in a language that only allows `:=` and `==`, but a resilient lexer might issue tokens `id 'a'`, `illegal '='`, `id 'b'`, `op '+'`, `id 'c'`, which IMO is better than to just break with an error as soon as `a =` has been seen.",0.0,c
11qees1,,But the interpreter itself is being written in Java.,0.0,java
11qees1,,Simply because Java is the language I am most proficient in.,0.25,java
11qees1,,"So while it certainly has many features similar to languages I'm familiar with (Java, Python, C), I am attempting to keep the syntax and operators used to define everything as unique and original as I can.",0.30654761904761907,java
11qees1,,"So while it certainly has many features similar to languages I'm familiar with (Java, Python, C), I am attempting to keep the syntax and operators used to define everything as unique and original as I can.",0.30654761904761907,python
11qees1,,"So while it certainly has many features similar to languages I'm familiar with (Java, Python, C), I am attempting to keep the syntax and operators used to define everything as unique and original as I can.",0.30654761904761907,c
11qees1,jc509h2,"* Lowering:     * to handle arbitrary function calls, you *must* either require forward declarations (like C) or else perform two passes over the input (most languages).",0.2,c
11qees1,jc509h2,"* in particular, if you support constexpr evaluation, you need a bytecode interpreter even if you're producing machine code         * but don't make the mistake C++ did and push things to the standard library when they would be simpler in the compiler in the first place.",0.13888888888888887,c++
11qees1,jc509h2,"Don't make the mistake Rust did in assuming ""incremental compilation"" will suffice.",0.0,rust
11qees1,jc509h2,Note that Java is a weird example because its bytecode *appears* to be stack-based but the first thing it does it turn it back into something very similar to register-based.,-0.0625,java
11qees1,jc509h2,"C# has examples for opt-in approach here; Java has been ""we're working on it"" for like a decade and it's clear they don't even understand the problem (based on some of the weird requirements in their proposals).",-0.19999999999999998,c
11qees1,jc509h2,"C# has examples for opt-in approach here; Java has been ""we're working on it"" for like a decade and it's clear they don't even understand the problem (based on some of the weird requirements in their proposals).",-0.19999999999999998,java
11qees1,jc509h2,Do this (think about relocations) even for interpreted languages; don't copy Java's abominable ThreadLocal design.,0.0,java
11qees1,jc4ln5l,"o Go ahead and read/implement ""Crafting Interpreters"" (which others have mentioned).",0.0,go
11qees1,jc42fxo,Don’t copy c or c++.,0.0,c
11qees1,jc42fxo,Don’t copy c or c++.,0.0,c++
11qees1,jc361xd,"In Java land, I would highly recommend ANTLRv4.",0.16,java
11qees1,jc4vjok,"I've been using it myself :P  Also, how would you go about versioning syntax?",0.75,go
11qees1,jcg2o17,I've always just depended on Java handling stuff pretty easily for me with its defaults.,0.3416666666666667,java
11qees1,jcg2o17,"So thanks for pointing me toward beginning to think about how I might go about tackling that aspect of the language, as well.",0.2,go
11qees1,jcg8u6w,I say that and then I realize I want to basically directly copy C++'s public/private labels for type members.,0.1,c++
11qees1,jc41j14,That's the cool thing about language design for me.,0.35,cool
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,pascal
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,algol
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,go
11qees1,jc6lz7l,"I've been using it myself :P  Look at languages with it: Pascal, Algol, Go, and recently Python.",0.375,python
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,fortran
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,c
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,c++
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,php
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,ruby
11qees1,jc6lz7l,"Look at languages without it: Fortran, C, C++, PHP, PL/I, Ruby, Python, ...  Bottom line: if you use anything but `=` for assignment, you are loudly declaring to everyone ""Either I am a esolang weirdo, or my name is Nicklaus Wirth!""",0.125,python
11qees1,jc6lz7l,"> Also, how would you go about versioning syntax?",0.0,go
11qees1,jc6lz7l,"Perl does this with the `use` statement, the same statement that handles module imports:      use v5.24.1;  That's probably the best, simplest implementation imaginable.",0.5,perl
11qees1,jcd6d64,Consider python: should your shebang be `python` or `python2` or `python3` or `python3.5`?,0.0,python
11qees1,jcd6d64,"It depends on what virtual env package you're running, or what your distro decided about the standard python version.",0.0,python
11qees1,jc4d121,Why’d you think?,0.0,d
11qees1,jcggv42,“Familiarity” is a weak argument imo and used by those who flat out refuse with zero reasons to use anything other than c or c++ even when they’re bitching about their flaws.,-0.17500000000000002,c
11qees1,jcggv42,“Familiarity” is a weak argument imo and used by those who flat out refuse with zero reasons to use anything other than c or c++ even when they’re bitching about their flaws.,-0.17500000000000002,c++
11qees1,jc6sm2i,":D  Probably im biased as I just wrote a schoolwork interpreter for a lang spec that used :=, and also I've taught programming to total non-programmers who will not immediately grasp that = is a totally different thing from equality.",0.3333333333333333,d
11qees1,jcepezz,Python's versioning is a good example of how _not_ to do things.,0.7,python
11qees1,jc4eezp,"PHP, JS, Java, and Actionscript copied ideas just fine.",0.4166666666666667,php
11qees1,jc4eezp,"PHP, JS, Java, and Actionscript copied ideas just fine.",0.4166666666666667,java
11qees1,jc4eezp,"PHP, JS, Java, and Actionscript copied ideas just fine.",0.4166666666666667,actionscript
11qees1,jc608q2,"It’s well known why they’re bad languages, but if you’ve not taken any notice of all the “I’ve created my own language based on c only better” posts and not seen how they implement the same bad features then there’s no helping you.",-0.049999999999999954,c
11qees1,jc76fhu,"I've stumbled on this so much with different languages, and I see people stumbling on it with JavaScript a lot.",0.1,javascript
11qees1,jc7o2rk,Explain why you feel C is generally bad.,-0.6999999999999998,c
11qees1,jc7o2rk,I'll offer up that C acts more like an instruction set for assembly.,0.5,c
11qees1,jc7o2rk,I'll offer up that C acts more like an instruction set for assembly.,0.5,assembly
11qees1,jc7o2rk,I could easily write something in HTML with errors and it would work for the public.,0.21666666666666667,html
11qees1,jc7o2rk,"C, I have to revise, debug, test, and put extra effort to make my C programs ""consumable"" to users.",0.0,c
11qees1,jc7o2rk,"With all that work, and with how use to browsers we all are, more people would probably prefer the HTML page.",0.5,html
11qees1,jc7o2rk,Even though I've put much more effort into the C project.,0.5,c
11q26yv,jc18shz,"Thus, it is not an effect handler, its just a condition system from common lisp.",-0.3,lisp
11q26yv,jc2fp8g,"I intend to add a pipeline operator similar to Elixir, to be used with an std::result module which will provide functions to ease writing such complex code.",-0.09999999999999999,elixir
11q26yv,jc2fp8g,I may take inspiration on an Elixir library I wrote a while ago: https://github.com/linkdd/rustic_result,0.0,elixir
11q26yv,jc8vvbk,"Here's old PHP code that does your IO example:      //Given:     function RegisterTemp($service, $f)     {         Services::Register($service, $f);         return new class($service) {             function __construct(private $s) {}             function __destruct()             {                 Services::Unregister($this->s);             }         };     }          Services::RegisterTemp(""Log"", function($lvl, $msg) {         switch($lvl) {         case ""debug"": /* nothing */             break;         default:             echo($msg);         }     });     //do {     Services::Log(""debug"", ""lol"");     Services::Log(""info"", ""Hello World!",0.24659090909090908,php
11q26yv,jc1ro5a,"Also if you want to learn more, study Koka language and their papers and also there is a great book ""The Common Lisp Condition System: Beyond Exception Handling with Control Flow Mechanisms "" that reimplements condition system step by step in CL.",0.3333333333333333,lisp
11pxnu8,,"Over the past few days I've been working on a simple preprocessor that enables metaprogramming in languages that don't support it, such as C.  It's based on Lua and a bit hacky, as it currently transforms the code into a Lua program, and then executes it.",-0.09,lua
11pxnu8,,"As such I might switch to a fully homebrew language and interpreter, or maybe base it on something pure and lazy such as Haskell.",-0.16714285714285715,haskell
11pxnu8,,"For example on how to deal with the lazy-eval issue, or the (currently somewhat hairy) syntax, or how to do multi-file stuff (which isn't really supported, except by loading standard Lua modules, or running multiple files in sequence).",0.05,lua
11pp9hu,,"But more about Barn, It's an compiled programming language to C++.",0.5,c++
11pp9hu,jbzupl1,"I took a look at the code and it looks like the compiler does a very literal line-by-line translation from your language to C++  Of course, this makes the compiler really fast, but it also means you're restricting yourself to all the limitations that come with C++, like the limited type inference, having to forward declare stuff, etc  If you first build the AST entirely and do operations on that before you start generating code, you're going to be able to move your language further away from C++",0.15408163265306124,c++
11pp9hu,jbzqbya,"Writing in Go to compile via C++ is an interesting choice, how did you make it?",0.5,go
11pp9hu,jbzqbya,"Writing in Go to compile via C++ is an interesting choice, how did you make it?",0.5,c++
11pp9hu,jbzqbya,"(I see from your code that it *isn't* because you started with Thorsten Ball's Writing An Interpreter in Go, you've clearly taken your own path.)",0.35,go
11pp9hu,jc0dtl9,Cool project !,0.4375,cool
11pp9hu,jbzg6ga,"Take a look at [Crystal](https://crystal-lang.org/) to pick a random decent example - they start with a basic syntax example, and then have further examples to demonstrate unique features (or at least *features*).",-0.0011904761904761943,crystal
11pp9hu,jc1keyp,The docs say it compiles to C. Where does C++ come into it?,0.0,c++
11pp9hu,jc1c1vb,When I was starting to write Barn Lang I did learning Go so i just wanted to improve my skills in it so i created a language lol,0.4,go
11pp9hu,jc1cfnm,"Barn don't have any specifi goal i just want to create a language in a type i like a good low level one if i can even name it like that lol  Actually i didn't seen that previously, but yes in the variables i use let name: type but in the arguments like in C i use type name that's maybe not good but i like it  It wasn't negative thanks for this 🦧",0.11041666666666666,c
11pp9hu,jc1cimu,https://discord.gg/QM6RRWfT7j here you go i need to get a new link there,0.13636363636363635,go
11pp9hu,jc1qnba,> The docs say it compiles to C. Where does C++ come into it?,0.0,c++
11pp9hu,jc1qnba,"That might have been a mistake, this reddit post and the github about both say it compiles to C++, and you'll see it's C++ if you look at any function in the std library, for example: ``` fun println(string s) {     __code__(""std::cout << s << std::endl;"")     __use__(s) } ```  > even if doing line-by-line transpilation, you don't necessarily still need forward declarations  It is true that you can add a forward declaration to the beginning of the file every time you generate code for a function to make the C++ compiler happy, but if you want to do any sort of static analysis (like type checking) on the Barn code before you generate C++, you need to know about functions that come later in the code, and you don't have this information with a single-shot compiler",0.325,c++
11pp9hu,jc1uceo,Wait where does it say about C?,0.0,c
11pp9hu,jc1uceo,Actually Barn was firstly compiled to C and then to C++,0.125,c
11pp9hu,jc1uceo,Actually Barn was firstly compiled to C and then to C++,0.125,c++
11pp9hu,jc23dxu,"From your link: [https://github.com/barn-lang/barn](https://github.com/barn-lang/barn):  ""*It's a simple programming language written in Go that is compiled to C.*""",-0.375,go
11ozuzq,,"In Haskell, you can apply `map` to any type that implements the right type-class.",0.2857142857142857,haskell
11ozuzq,,"In Elm there is `map` also, but you often see `List.map` to distinguish from other kinds of `map`.",-0.125,elm
11ozuzq,,This suggests that Elm lacks a type-class system.,0.0,elm
11ozuzq,,It also means Elm code contains more redundant references to the concrete types of data structures.,0.15,elm
11ozuzq,,The Haskell style seems to require a more sophisticated translator.,0.5,haskell
11ozuzq,jbw2i6b,"The system at play here are typeclasses/traits, which Haskell has and Elm lacks.",0.0,haskell
11ozuzq,jbw2i6b,"The system at play here are typeclasses/traits, which Haskell has and Elm lacks.",0.0,elm
11ozuzq,jbw2i6b,"Haskell also has higher-kinded types (HKTs) which are necessary for `map` to work (since it's polymorphic on the list constructor `List :: * -> *` and not just a type, e.g.",0.0,haskell
11ozuzq,jbw2i6b,"These systems are directed by namespacing rather than types, which makes them more verbose, but also a very powerful system that leads itself to different idioms than Haskell's system.",0.2966666666666667,haskell
11ozuzq,jbw2i6b,"There are some languages, Elm, maybe Go, which can get away with weaker systems and focus more on abstraction in other areas.",0.1875,elm
11ozuzq,jbw2i6b,"There are some languages, Elm, maybe Go, which can get away with weaker systems and focus more on abstraction in other areas.",0.1875,go
11ozuzq,jbwjv55,Read up on this approach in this excellent post from the Haskell world:  https://www.haskellforall.com/2012/05/scrap-your-type-classes.html?m=1,1.0,haskell
11ozuzq,jbvovxz,"What `Elm` and similar languages are missing is Functors (ocaml style functors, not Haskell's Functor/endofunctor).",-0.1,elm
11ozuzq,jbvovxz,"What `Elm` and similar languages are missing is Functors (ocaml style functors, not Haskell's Functor/endofunctor).",-0.1,haskell
11ozuzq,jbwahzl,"The notion of ""parameterized modules"" sounds promising, although the phrase gives me flashbacks to using Ada in college.",0.2,ada
11ozuzq,jbwr7z7,Perhaps I've been writing too much Python.,0.2,python
11ozuzq,jbw27so,"I know what it is in math, but C++, Haskell, OCaml, etc.",0.0,c++
11ozuzq,jbw27so,"I know what it is in math, but C++, Haskell, OCaml, etc.",0.0,haskell
11ozuzq,jby34g6,"Luckily, Haskell can be configured to be more like System F in that regard.",0.41666666666666663,haskell
11ozuzq,jbw3kzn,"The Haskell and, I believe, SML meaning come from category theory.",0.0,haskell
11ozuzq,jbw3kzn,The other meanings (like in C++ and in Prolog) still ultimately derive from the ancestor of its meaning in category theory (Carnap's usage).,-0.0625,c++
11ozuzq,jbw3kzn,The other meanings (like in C++ and in Prolog) still ultimately derive from the ancestor of its meaning in category theory (Carnap's usage).,-0.0625,prolog
11ovkfj,,"Consider the following example declaring a sum type which should be familiar to Rust devs: ```     enum Variants<T> {         Foo(T),         Bar(MyType),         Baz     } ``` I think what I want to happen here is the following:   - The args `T` and `MyType` in `Some(T)` and `Bar(MyType)` are treated exactly the same, both stored as identifiers to user-defined types regardless of the fact that one is concrete and one is generic.",0.11071428571428572,rust
11ovkfj,jbw7bja,It seems prone to make type checks go faster.,0.0,go
11ovkfj,jbx4q16,"Functional with excellent pattern matching, but not as rigid as Haskell.",1.0,haskell
11ojt84,,"The 0.10.0 Release comes with:  * Tuples and Named Tuples * Passthrough data type * fine grained Core Library configuration * extended filesystem functions * partial evaluation (experimental via low level API)  Also, the license of the TeaScript C++ Library has been changed.",0.10416666666666666,c++
11ojt84,,"**   Here is a nice overview and some highlights:   [https://tea-age.solutions/teascript/overview-and-highlights/](https://tea-age.solutions/teascript/overview-and-highlights/)  The Github repo for the TeaScript C++ Library:   [https://github.com/Florian-Thake/TeaScript-Cpp-Library](https://github.com/Florian-Thake/TeaScript-Cpp-Library)  The Download page for bundles of the Host Application (Win+Lin) and the Library with some more examples:   [https://tea-age.solutions/teascript/downloads/](https://tea-age.solutions/teascript/downloads/)  # EDIT:  Important information for readers who are not familiar with C++ Libraries, or who are wondering about the discussion / comments below.",-0.13392857142857142,c++
11ojt84,,"In C++ exists so called ""header only"" Libraries.",0.0,c++
11ojt84,jbteay4,">Also, the license of the TeaScript C++ Library has been changed.",0.0,c++
11ojt84,jbv6j87,Nice set of features and the language looks accessible (putting aside the use of C++).,0.4875,c++
11ojt84,jbx7s9i,The programmer has to do proper cleanup - same as in the hosting language (C++).,0.0,c++
11ojt84,jbx6fc2,"Well, the one thing what is difficult to understand, is, that my project is a dual used project with 2 topics:  * the C++ Library for to be used in C++ software projects.",-0.5,c++
11ojt84,jbx6fc2,* the TeaScript langauges which can be used without to program any C++ software.,0.0,c++
11ojt84,jbx6fc2,The AGPL license applies for the C++ Library.,0.0,c++
11ojt84,jbx6fc2,"That means, if you and only if you distribute new C++ software based on that Library you are bound to the license.",0.06818181818181818,c++
11ojt84,jbx6fc2,BTW: What is wrong about use C++?,-0.5,c++
11ojt84,jbtnh2m,"shell commands), companies will avoid the GPL like the plague.",0.0,shell
11ojt84,jbx9pnc,"Yes, exactly, using the CLI (or even anything compiled with the Lib privately / undistributed) is a complete different thing as to build a new software (what ever it may do) with the C++ LIB \_and\_ distribute this new software program.",0.10378787878787878,c++
11ojt84,jbx9pnc,Program TeaScript files or execute them has nothing to do with the used License of the C++ Library.,0.0,c++
11ojt84,jbtoyhw,"And, if they want use it but don't want go Open Source, they can purchase a license which then in turn isn't hard either and become 100% safe to use.",0.06944444444444443,go
11ojt84,jbtsjmk,"C++ lets you write any code you like in header files and thanks to its lack of a usable module system, writing everything in headers makes libraries much easier to distribute.",0.2,c++
11ojt84,jbtsjmk,"If you have an issue with this approach, I'm with you, but that is a fight you will have to take out with the C++ folks.",0.0,c++
11ojt84,jbtv8s6,"Ok, are you not familiar with C++ Libraries?",0.15625,c++
11ojt84,jby2wd7,"So I guess what I'm trying to say is that unless TeaScript has really cool, advanced, and automatic C++ interoperability features, of the kind JRuby has with Java; then I'd find it weird if people are repelled by the licence.",0.21250000000000002,cool
11ojt84,jby2wd7,"So I guess what I'm trying to say is that unless TeaScript has really cool, advanced, and automatic C++ interoperability features, of the kind JRuby has with Java; then I'd find it weird if people are repelled by the licence.",0.21250000000000002,c++
11ojt84,jby2wd7,"So I guess what I'm trying to say is that unless TeaScript has really cool, advanced, and automatic C++ interoperability features, of the kind JRuby has with Java; then I'd find it weird if people are repelled by the licence.",0.21250000000000002,java
11ojt84,jby2wd7,"I mean if tomorrow PHP gets under the Anti-Capitalist Software Licence, maybe 2 websites tops will have to refactor their code into a different process, and nothing else will change.",-0.15625,php
11ojt84,jbttqv2,"is totally free, only the C++ Library has the AGPL license.",0.2,c++
11ojt84,jbttqv2,The C++ Library is meant to be used in C++ Application to extend them dynamically during runtime with arbitrary scripting tasks.,-0.1,c++
11ojt84,jbttqv2,"So, if you program software, you can use TeaScript in C++ projects only.",0.0,c++
11ojt84,jbttqv2,"If you want programming scripts, you don't need the C++ Library at all, but just a Host App to execute the script.",0.0,c++
11ojt84,jbttqv2,The complete language with all its features is inside the C++ Library inside the repo.,0.1,c++
11ojt84,jbttqv2,Just if you want to distribute a derived software from the C++ Library you are bound to the license.,0.0,c++
11ojt84,jbtxbxi,I'm going to have to go back and re-read.,0.0,go
11ojt84,jbtxbxi,"That would actually be pretty cool, if the entire thing was in a header-only library.",0.19999999999999998,cool
11ojt84,jbtxqo9,"And, yes the C++ Library should be used by companies either in Open Source projects, or via a purchased license or not at all.",0.0,c++
11ojt84,jbtxqo9,For the language itself you don't need the C++ Lib.,0.0,c++
11ojt84,jbtyn2i,This is not unusual for embeddable C++ projects.,-0.1,c++
11ojt84,jbu1lu0,It just also uses only the C++ TeaScript Library as well.,0.0,c++
11o9mqy,,"Originally, the project started as an exercise to learn C programming for a real project, it eventually evolved into the creation of a new language in C. Initially, I had chosen the LLVM backend, but I later decided to pause development and write a backend that targets WebAssembly directly.",0.13522727272727272,c
11o9mqy,,"For heap memory allocation and management, I am looking to implement Rust's object ownership approach, which sounds more attractive, especially in real-time programming.",0.43333333333333335,rust
11o9mqy,jbv9tm1,"Rust's model gives you memory safety with mutation by controlling aliasing, and in consequence the runtime cannot move objects around.",0.0,rust
11o9mqy,jbvu6z4,The language with GC does provide better ergonomics for programmers than those without GC(rust has longer learning curve than python).,0.5,rust
11o9mqy,jbvu6z4,The language with GC does provide better ergonomics for programmers than those without GC(rust has longer learning curve than python).,0.5,python
11o9mqy,jbxsr90,"My plan is  to use the [Component](https://github.com/WebAssembly/component-model) approach to establish linkage, allowing me to gradually replace portions of the mlang compiler written in C with ones written in mlang itself.",0.0,c
11o9mqy,jby7c71,Reminds me of someone’s high frequence trading system written in Java.,0.16,java
11nzw0x,jbpx6qp,"This post is mostly about Rust, but I found it really interesting and gave me a new perspective on language design in general, so I thought it was worth sharing here.",0.29727272727272724,rust
11nzw0x,jbriae8,"Personally I'm not a crustacean, but what you describe foreshadows Rust jumping the shark.",0.0,rust
11nzw0x,jbriae8,"* If the Rust community seems slow to add a feature, and if that delay stems from a concern for the cost/benefit balance, then I think they're doing it right.",-0.007142857142857173,rust
11nzw0x,jc1e4r6,"We have effects:      effect Exception {       def throw[A](): A     }          effect Iteration[E] {       def yield(item: E): Unit     }          effect Asynchronicity {       def await(): Unit     }   Then we have effectful functions:      def someFunction(): Unit / {Iteration[Int], Asynchronicity, Exception} = {       do yield(5);       do await();       do throw()     }  And finally we have handlers:      def intoOption[R] { program: () => R / Exception }: Option[R] =       try {         val result = program();         Some(result)       } with Exception {         def throw[A]() = None()       }      def intoList[E] { program: () => Unit / Iteration[E] }: List[E] =       try {         program();         Nil()       } with Iteration[E] {           def yield(item) = { val rest = resume(()); Cons(item, rest) }       }      type Future[R] {       Pending(poll: () => Future[R] at {});       Ready(result: R)     }      def intoFuture[R]( program: () => R / Asynchronicity  at {} ): Future[R] =       try {         val result = program();         Ready(result)       } with Asynchronicity {         def await() = Pending(fun() { resume(()) })       }  In fact this is how we usually introduce effect handlers in our talks.",-0.5416666666666666,r
11nzw0x,jbsdebo,"Are you mentioning assembly because of the word ""register"" in the title and article?",0.0,assembly
11nzw0x,jbsdebo,"It's talking about a different meaning of the word, ""any of the varieties of a language that a speaker uses in a particular social context,"" and mapping that definition to programming languages, Rust in particular.",0.09166666666666666,rust
11nzw0x,jbtjmut,"Just writing the program in assembly would take longer than the ""clean code"" took from writing to finish execution.",0.3666666666666667,assembly
11nzw0x,jbtjmut,"And that's not even considering that your hand written would probably be slower than the compiler optimised assembly for even the ""clean code"" version.",0.3666666666666667,assembly
11nzw0x,jbtq5vx,I was replying to the person above me who was saying that they would rather use assembly than think of all this.,0.0,assembly
11njprl,jbom8d0,going to directly generate assembly / binary code ?,0.1,assembly
11njprl,jbom8d0,"going to be translated as another P.L., like C, called ""transpiled"" ?",0.0,c
11njprl,jbpie6q,Python creates a namespace and assigns it to a name in the global scope of the caller.,0.0,python
11njprl,jbpie6q,C++ separates the namespace from the container.,0.0,c++
11njprl,jbpie6q,"Make two or three namespaces, C++ don't care!",0.0,c++
11njprl,jbpie6q,"The type-oriented languages (ML, Haskell, etc.)",0.0,haskell
11njprl,jbpie6q,"Are you an everything-is-an-object language, like Python?",0.0,python
11njprl,jbpie6q,"Or a the-coder-is-always-in-charge like C++, or all-functions-are-global-overloads like the functionals?",0.0,c++
11njprl,jbq3z4k,How about a two-pass scheme?,0.0,scheme
11njprl,jbtelie,So:  ```rust -- file main.rs  fn main() {   add() }  fn add() {}  -- file lib.rs  fn add() {} ```  The main insight is that not (should!),0.1875,rust
11njprl,jbtelie,"Both should be normalized:  ```rust -- file main.rs  fn main.rs::main() {   main.rs::add() }  fn main.rs::add() {}  -- file lib.rs  fn lib.rs::add() {} ```  After this, is about your rules of declaration and visibility.",0.0,rust
11njprl,jbtelie,What happens if:  ```rust -- file main.rs import lib //resolved to main.rs::imports[lib.rs]  fn main.rs::main() {   ?,0.0,rust
11njprl,jbs367h,C++ also has modules now and I think they're separate from namespaces.,0.0,c++
11njprl,jbs367h,"It's worth mentioning that C++ is also a very special case in a lot of ways since it separates header files and implementation, which complicates compilation.",0.3821428571428571,c++
11ncg8q,jbnxniq,Your transpiler's written in Python.,0.0,python
11ncg8q,jbn9072,What if the real brainfuck was the Python we wrote along the way?,0.2,python
11ncg8q,jbubcc7,That's cool!,0.4375,cool
11ncg8q,jbon9q8,[Source](https://github.com/thefunguys/biffle/blob/master/biffle.c) (it’s very bad C),-0.9099999999999998,c
11n7hj3,,[lambdaforge](https://github.com/necloX/lambdaforge) is a python package that I'm currently developing for sampling random lambda terms.,-0.25,python
11n7hj3,,I have ideas but I'm not sure where to go from there.,-0.25,go
11n7hj3,jbnirmm,The project sounds cool.,0.35,cool
11n5535,,"""+f)         OneOrMore Digit i  <--  decimal.Parse i     }          // A parenthesis delimited recursive expression     ParensExp = Symbol ""("" >> Exp exp >> Symbol "")""  <-  exp          // Rule which skips space and matches a character symbol     Symbol = Space >> CharSymbol (CharSymbols sym)  <-  sym          // The set of strings that make up character symbols     CharSymbols = { ""+"", ""-"", ""*"", ""/"", ""^"", ""("", "")"" }  **Compiler combinators**  For completeness, I show here the implementation of the combinators used above      Space = Chars.WhiteSpaceChars >> Char >> Space || Strings          Char = string [c,,rest] -> rest  <-  c          Digit = {'0'...'9'} >> Char          // Matches a rule one or more time and assembling a list     OneOrMore = Rules rule -> {         rule exp >> these exps  <--  [exp,,exps]         rule exp  <--  [exp]     }          LeftAssoc = BinaryOperators operator -> Rules next -> {         these left >> operator f >> next right  <--  f(left,right)         next exp  <--  exp     }          RightAssoc = BinaryOperators operator -> Rules next -> {         next left >> operator f >> these right  <--  f(left,right)         next exp  <--  exp     }          Prefix = id -> BinaryOperators operator -> Rule next -> {         operator op >> these exp  <--  op(id, exp)         next exp  <--  exp     }          BinaryOperators = Parsers ^ (Decimals^2 => Decimals)          Parsers = Strings=>Strings",0.07653061224489796,c
11n2kz7,jbp76jl,"In the topic of features, generic plugin interfaces wrapping over some built-in OS commands should come in handy, so the project would not need to reimplement very common functionality (for instance using curl as a backend for network requests instead of an ad-hoc plugin written in Rust)",0.06999999999999999,rust
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,c++
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,go
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,rust
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,kotlin
11n2cpy,,"Hello everyone, Thanks to everyone in this group for sharing creative work today I want to share my in-development programming language side project called Jot  Github: [https://github.com/AmrDeveloper/Jot](https://github.com/AmrDeveloper/Jot)  Website: [https://amrdeveloper.github.io/Jot/](https://amrdeveloper.github.io/Jot/)  Jot Statically typed, compiled general purpose low level programming language built using C++ and LLVM designed to be simple, fast and easy to use and help you to write internal DSL's, the design is inspired by many languages such as Go, Rust, Jai, Kotlin, Swift  Code Snippets  Import Statement inspired by Go      import {         ""cstdio""         ""cstring""     }  Enum and Switch Expression      // Enumeration with Switch Expressions     enum Op { PLUS, MINUS, POW, DIV }            fun switch_expr_return(x int64, y int64, op Op) int64 {           return switch op {               Op::PLUS -> x + y;               Op::MINUS -> x - y;               Op::POW -> x \* y;               Op::DIV -> x / y;               else -> -1;           };       }   If Expression       var value : int64 = if (true) 10 else 20;  Multi dimensions Array      var array4d = [[[[0]]], [[[1]]], [[[2]]], [[[3]]]];          var strings= [[""Hello"", ""world!",0.06805555555555555,swift
11n2cpy,,"""], [""From"", ""Jot""]];          var matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];     for 0 .. matrix.count - 1 {         for i : 0 .. matrix[it].count - 1 {             printf(""%d\t"", matrix[it][i]);         }         printf(""\n"");     }  Continue and Break with n      var i = 10;     while i > 0 {         i -= 1;         var j = 3;         while j > 0 {             continue 2;             j -= 1;             puts(""Hello"");         }         puts(""World"");     }  For Statement      for {         printf(""Hello, World!\n"");     }          for i : 0 .. 3 {         for j : 0 .. 3 {             printf(""Nested Named for %d %d\n"", i, j);         }     }          for [[1, 2, 3], [4, 5, 6], [7, 8, 9]] {         for it {             printf(""%d\t"", it);         }         printf(""\n"");     }  Defer Statement      fun main() int64 {         var x = 10;         defer printf(""Function Defer %d\n"", x);              {             x = 11;             defer printf(""Scope Defer %d\n"", x);             printf(""Scope %d\n"", x);         }              x = 12;         printf(""After Scope %d\n"", x);              return 0;     }  Lambda expression      var sumOfThree = { (x int64, y int64, z int64) int64 ->              var sumTwo = { (x int64, y int64) int64 -> return x + y; };              return sumTwo(x, y) + z;      };  Infix functions, there also prefix and postfix      struct IntRange {         start int64;         end int64;     }          infix fun to(s int64, e int64) IntRange {         var range : IntRange;         range.start = s;         range.end = e;         return range;     }          infix fun in(value int64, range IntRange) bool {        return value >= range.start && value <= range.end;     }          if 1 in 0 to 10 {        printf(""Yes!\n"");     }  You can find many samples: [https://github.com/AmrDeveloper/Jot/tree/master/samples](https://github.com/AmrDeveloper/Jot/tree/master/samples)  Looking forward to feedback and Feel free to suggest features",0.17380952380952383,d
11n2cpy,jbn9f9d,"Still trying to design a simple way to do that and trying other lang way like rust, zig,...",-0.0625,rust
11n2cpy,jboi8xi,"I can't say how Jot could work since I'm not the author, but in Rust you can specify how you'd like the enum values to be serialized.",0.0,rust
11n2cpy,jboi8xi,"In Rust it would be 1 byte for the discriminant, +3 bytes for padding, then the payload.",0.0,rust
11n2cpy,jboi8xi,Java has an implementation of sum types using inheritance so everything is heap allocated and it'll do a bunch of pointer chasing.,0.0,java
11n2cpy,jboi8xi,"Sure, maybe it's an internal data model of a CSS color that will later be serialized as part of a chunk of HTML.",0.16666666666666666,html
11n2cpy,jboi8xi,"TypeScript takes it a step further, in addition to integers, it's also possible to associate string data with variants.",0.0,typescript
11n2cpy,jboi8xi,I believe that Rust & Swift chose this keyword to be familiar to programmers who came from C family languages.,0.375,rust
11n2cpy,jboi8xi,I believe that Rust & Swift chose this keyword to be familiar to programmers who came from C family languages.,0.375,swift
11n2cpy,jboi8xi,I believe that Rust & Swift chose this keyword to be familiar to programmers who came from C family languages.,0.375,c
11n2cpy,jboi8xi,"The ML family (OCaml, F#, Haskell) express this concept with clearer syntax.",0.0,haskell
11n2cpy,jbowwk4,"In Rust it would be 1 byte for the discriminant, +3 bytes for padding, then the payload  This is the source of confusion.",0.0,rust
11n2cpy,jbowwk4,"But then, *my* enums are those I first encountered in Pascal in the 1970s, and the ones I have in my own languages, where there *can* be associated data, but not the way it is in that `Colours` example:      enumdata colourvalues =         (red,     0xFF0000),         (green,   0x00FF00),         (blue,    0x0000FF)     end  this defines constants `red green blue` with values `1 2 3`, and a separate, corresponding array of values.",-0.03333333333333334,pascal
11n2cpy,jbowwk4,"In the original Pascal, you cannot access the internal numerical values of `red green blue`.",0.034999999999999996,pascal
11mpom9,,"It's written in TypeScript and works with a ""boxed"" representation of values at runtime (`type RuntimeValue = BoxedInt | BoxedString | FunctionRef | ...`), does simple runtime checks (e.g.",0.0,typescript
11mpom9,,Builtin functions (like `add` or `mul` for numbers) are implemented in TypeScript as well.,0.0,typescript
11mpom9,,"This one turns code in my language to simple JavaScript code with conditionals, function calls, etc.",0.0,javascript
11mpom9,,"It prepends to the output a separately-defined ""prelude"" of builtin functions ported to JavaScript.",0.0,javascript
11mpom9,,"For example, my interpreter is typed in the host language (TypeScript).",0.0,typescript
11mpom9,,"However, my JS-targeting compiler simply emits a string of JavaScript code which will throw no errors in cases where my interpreter would panic.",0.0,javascript
11mpom9,,"This is not a problem for the interpreter, but my JavaScript output, which contains `let identifier = ...` for each variable, crashes in these cases with `Identifier has already been declared`.",0.0,javascript
11mpom9,,"Using `var` in JavaScript would solve this, but it would introduce other undesired behavior.",-0.125,javascript
11mpom9,jbiz7ip,"If you write your optimizations passes to reduce the language semantics into a smaller subset of core operations, you should also be able to make the translation to javascript much more mechanically simple.",0.25,javascript
11mpom9,jbjmffy,"I work on Dart and we have a JIT VM, native code compiler, incremental JS compiler, whole-world JS compiler, in-progress WASM compiler, IDE static analyzer, and probably some other pieces I'm forgetting.",0.1875,dart
11mpom9,jbizjmk,"This approach is probably going to be very slow compared to the alternative which would be ""build an interpreter in my compiler to run the stuff that happens at compile-time"", but I think having everything go through libgccjit will ensure consistency, which is arguably very important given ""compile-time"" and ""run-time"" here are expected to be compatible with eachother semantics-wise in the same executable.",0.007499999999999986,go
11mpom9,jbk5oaj,">For example, my interpreter is typed in the host language (TypeScript).",0.0,typescript
11mpom9,jbk5oaj,">However, my JS-targeting compiler simply emits a string of JavaScript code which will throw no errors in cases where my interpreter would panic.",0.0,javascript
11mpom9,jbk5oaj,"This is not a problem for the interpreter, but my JavaScript output, which contains let identifier = ... for each variable, crashes in these cases with Identifier has already been declared.",0.0,javascript
11mpom9,jbk5oaj,"Using var in JavaScript would solve this, but it would introduce other undesired behavior.",-0.125,javascript
11mpom9,jbjv2vw,I had a similar problem while working on a parser that guarantees identical results for arbitrary string-embedded TypeScript syntax between the static (i.e.,0.13333333333333333,typescript
11mpom9,jbjv2vw,parsed via TypeScript generics) and dynamic (i.e.,0.0,typescript
11mpom9,jbjv2vw,parsed via standard JavaScript at runtime) results.,0.0,javascript
11mpom9,jbjv2vw,"if it only exists within TypeScript's type system, hehe...  What I ended up implementing was a small test framework that allowed me to make assertions about both at the same time like this:  ```ts it(""zero divisor"", () => {                 attest(() => type(""number%0"")).throwsAndHasTypeError(                     ""% operator must be followed by a non-zero integer literal (was 0)""                 )             }) ``` (the original source can be found [here](https://github.com/arktypeio/arktype/blob/9a5d3bad70aa09ee3cceb94bf247878b11fc32f5/dev/test/semantics.test.ts#L8) alongside similar tests)  I would definitely prefer using some kind of automated proof system if that is possible, but if there are cases for which it is not, you may have success extending a solution like this to validate several compilers in parallel.",0.09318181818181817,typescript
11mpom9,jbjv2vw,Sounds like a cool project- good luck!,0.6125,cool
11mpom9,jbnnas4,"This is not a problem for the interpreter, but my JavaScript output, which contains let identifier = ... for each variable, crashes in these cases with Identifier has already been declared.",0.0,javascript
11mpom9,jbnnas4,"Using var in JavaScript would solve this, but it would introduce other undesired behavior.",-0.125,javascript
11mpom9,jbkhwdt,"Harper was proposing to call these languages ""unityped"" to underscore the fact that, from a type theory perspective, they have only one type - essentially a kind of sum type which in Javascript looks like ""null | undefined | boolean | number | string | object..."".",0.3,javascript
11mpom9,jbkhwdt,Every term in a Javascript program has that type.,0.0,javascript
11mpom9,jbjs28x,Here you go!,0.0,go
11mpom9,jbkrpds,The [CompCert](https://en.wikipedia.org/wiki/CompCert) C compiler is written and formally verified in Coq,0.0,c
11mpom9,jbklnjd,"I doubt Harper could even launch a single ""statically typed"" program without relying on a dynamically typed shell to do it.",-0.07142857142857142,shell
11mpom9,jbk5ql1,"Python is an example of a runtime type checked language on the ""strong"" side of that spectrum, whereas JS is also runtime type checked but on the ""weak"" side.",0.029166666666666646,python
11mpom9,jbl1m2d,RTTI in C++ and the Java equivalent demonstrate.,0.0,c++
11mpom9,jbl1m2d,RTTI in C++ and the Java equivalent demonstrate.,0.0,java
11mpom9,jbl1m2d,"The simply typed lambda calculus was developed by Church in 1940, before even the first assembly languages were developed.",0.11249999999999999,assembly
11mpom9,jbn3s9w,"For me, the weakly typed languages are assembly and C. JS is strongly-typed because it doesn't let you bypass its type system.",-0.375,assembly
11mpom9,jbojnxc,"Hypothetically, if I created an interpreter for C that did this, would that make it strongly typed?",0.4333333333333333,c
